Prevents uninitialized instances from being created outside the package
Constructs a new instance of this class given its parent and a style value describing its behavior and appearance p The style value is either one of the style constants defined in class code SWT code which is applicable to instances of this class or must be built by em bitwise OR em ing together that is using the code int code operator two or more of those code SWT code style constants The class description lists the style constants that are applicable to the class Style bits are also inherited from superclasses p param parent a widget which will be the parent of the new instance cannot be null param style the style of widget to construct exception IllegalArgumentException ul li ERROR NULL ARGUMENT if the parent is null li ul exception SWTException ul li ERROR THREAD INVALID ACCESS if not called from the thread that created the parent li ul see SWT NO BACKGROUND see SWT NO FOCUS see SWT NO MERGE PAINTS see SWT NO REDRAW RESIZE see SWT NO RADIO GROUP see Widget getStyle
Clears any data that has been cached by a Layout for all widgets that are in the parent hierarchy of the changed control up to and including the receiver If an ancestor does not have a layout it is skipped param changed an array of controls that changed state and require a recalculation of size exception IllegalArgumentException ul li ERROR INVALID ARGUMENT if the changed array is null any of its controls are null or have been disposed li li ERROR INVALID PARENT if any control in changed is not in the widget tree of the receiver li ul exception SWTException ul li ERROR WIDGET DISPOSED if the receiver has been disposed li li ERROR THREAD INVALID ACCESS if not called from the thread that created the receiver li ul since 3 1
Returns a possibly empty array containing the receiver s children Children are returned in the order that they are drawn p Note This is not the actual structure used by the receiver to maintain its list of children so modifying the array will not affect the receiver p return an array of children see Control moveAbove see Control moveBelow exception SWTException ul li ERROR WIDGET DISPOSED if the receiver has been disposed li li ERROR THREAD INVALID ACCESS if not called from the thread that created the receiver li ul
NOTE The current implementation will count non registered children
Returns layout which is associated with the receiver or null if one has not been set return the receiver s layout or null exception SWTException ul li ERROR WIDGET DISPOSED if the receiver has been disposed li li ERROR THREAD INVALID ACCESS if not called from the thread that created the receiver li ul
Gets the possibly empty tabbing order for the control return tabList the ordered list of controls representing the tab order exception SWTException ul li ERROR WIDGET DISPOSED if the receiver has been disposed li li ERROR THREAD INVALID ACCESS if not called from the thread that created the receiver li ul see setTabList
Returns code true code if the receiver has deferred the performing of layout and code false code otherwise return the receiver s deferred layout state exception SWTException ul li ERROR WIDGET DISPOSED if the receiver has been disposed li li ERROR THREAD INVALID ACCESS if not called from the thread that created the receiver li ul see setLayoutDeferred boolean see isLayoutDeferred since 3 1
Returns code true code if the receiver or any ancestor up to and including the receiver s nearest ancestor shell has deferred the performing of layouts Otherwise code false code is returned return the receiver s deferred layout state exception SWTException ul li ERROR WIDGET DISPOSED if the receiver has been disposed li li ERROR THREAD INVALID ACCESS if not called from the thread that created the receiver li ul see setLayoutDeferred boolean see getLayoutDeferred since 3 1
If the receiver has a layout asks the layout to em lay out em that is set the size and location of the receiver s children If the receiver does not have a layout do nothing p This is equivalent to calling code layout true code p exception SWTException ul li ERROR WIDGET DISPOSED if the receiver has been disposed li li ERROR THREAD INVALID ACCESS if not called from the thread that created the receiver li ul
If the receiver has a layout asks the layout to em lay out em that is set the size and location of the receiver s children If the argument is code true code the layout must not rely on any information it has cached about the immediate children If it is code false code the layout may potentially optimize the work it is doing by assuming that none of the receiver s children has changed state since the last layout If the receiver does not have a layout do nothing p If a child is resized as a result of a call to layout the resize event will invoke the layout of the child The layout will cascade down through all child widgets in the receiver s widget tree until a child is encountered that does not resize Note that a layout due to a resize will not flush any cached information same as code layout false code p param changed code true code if the layout must flush its caches and code false code otherwise exception SWTException ul li ERROR WIDGET DISPOSED if the receiver has been disposed li li ERROR THREAD INVALID ACCESS if not called from the thread that created the receiver li ul
If the receiver has a layout asks the layout to em lay out em that is set the size and location of the receiver s children If the changed argument is code true code the layout must not rely on any information it has cached about its children If it is code false code the layout may potentially optimize the work it is doing by assuming that none of the receiver s children has changed state since the last layout If the all argument is code true code the layout will cascade down through all child widgets in the receiver s widget tree regardless of whether the child has changed size The changed argument is applied to all layouts If the all argument is code false code the layout will em not em cascade down through all child widgets in the receiver s widget tree However if a child is resized as a result of a call to layout the resize event will invoke the layout of the child Note that a layout due to a resize will not flush any cached information same as code layout false code p param changed code true code if the layout must flush its caches and code false code otherwise param all code true code if all children in the receiver s widget tree should be laid out and code false code otherwise exception SWTException ul li ERROR WIDGET DISPOSED if the receiver has been disposed li li ERROR THREAD INVALID ACCESS if not called from the thread that created the receiver li ul since 3 1
Forces a lay out that is sets the size and location of all widgets that are in the parent hierarchy of the changed control up to and including the receiver The layouts in the hierarchy must not rely on any information cached about the changed control or any of its ancestors The layout may potentially optimize the work it is doing by assuming that none of the peers of the changed control have changed state since the last layout If an ancestor does not have a layout skip it param changed a control that has had a state change which requires a recalculation of its size exception IllegalArgumentException ul li ERROR INVALID ARGUMENT if the changed array is null any of its controls are null or have been disposed li li ERROR INVALID PARENT if any control in changed is not in the widget tree of the receiver li ul exception SWTException ul li ERROR WIDGET DISPOSED if the receiver has been disposed li li ERROR THREAD INVALID ACCESS if not called from the thread that created the receiver li ul since 3 1

Sets the layout which is associated with the receiver to be the argument which may be null param layout the receiver s new layout or null exception SWTException ul li ERROR WIDGET DISPOSED if the receiver has been disposed li li ERROR THREAD INVALID ACCESS if not called from the thread that created the receiver li ul
If the argument is code true code causes subsequent layout operations in the receiver or any of its children to be ignored No layout of any kind can occur in the receiver or any of its children until the flag is set to false Layout operations that occurred while the flag was code true code are remembered and when the flag is set to code false code the layout operations are performed in an optimized manner Nested calls to this method are stacked param defer the new defer state exception SWTException ul li ERROR WIDGET DISPOSED if the receiver has been disposed li li ERROR THREAD INVALID ACCESS if not called from the thread that created the receiver li ul see layout boolean see layout Control since 3 1
Sets the tabbing order for the specified controls to match the order that they occur in the argument list param tabList the ordered list of controls representing the tab order or null exception IllegalArgumentException ul li ERROR INVALID ARGUMENT if a widget in the tabList is null or has been disposed li li ERROR INVALID PARENT if widget in the tabList is not in the same widget tree li ul exception SWTException ul li ERROR WIDGET DISPOSED if the receiver has been disposed li li ERROR THREAD INVALID ACCESS if not called from the thread that created the receiver li ul
Call layout directly so that subclasses that reimplement this method instead of using a Layout will set the size and location of their children when the font changes
Force clipping of children by setting WS CLIPCHILDREN
Return zero to indicate that the background was not erased
Set focus for a canvas with no children
Feature in Windows When the tool tip control is created the parent of the tool tip is the shell If SetParent is used to reparent the tool bar into a new shell the tool tip is not reparented and pops up underneath the new shell The fix is to make sure the tool tip is a topmost window
Bug in Windows 98 and NT Setting the tool tip to be the top most window using HWND TOPMOST can result in a parent dialog shell being moved behind its parent if the dialog has a sibling that is currently on top The fix is to lock the z order of the active window Feature in Windows Using SetWindowPos with HWND NOTOPMOST to clear the topmost state of a window whose parent is already topmost clears the topmost state of the parent The fix is to check if the parent is already on top and neither set or clear the topmost status of the tool tip
Bug in Windows 98 For some reason the tool bar control sends both TTN GETDISPINFOW and TTN GETDISPINFOA to get the tool tip text and the tab folder control sends only TTN GETDISPINFOW The fix is to handle only TTN GETDISPINFOW even though it should never be sent on Windows 98 NOTE Because the size of NMTTDISPINFO differs between Windows 98 and NT guard against the case where the wrong kind of message occurs by inlining the memory moves and the UNICODE conversion code
Ensure that the orientation of the tool tip matches the orientation of the control
Set the clipping bits
Paint the control and the background
Get the damage
Create the paint GC
Send the paint event
It is possible but unlikely that application code could have disposed the widget in the paint event If this happens attempt to give back the paint GC anyways because this is a scarce Windows resource
widget could be disposed at this point
Dispose the paint GC
It is possible but unlikely that application code could have disposed the widget in the paint event If this happens don t attempt to restore the style
Restore the clipping bits
Begin deferred window positioning
Resize and Layout
It is possible but unlikely that application code could have disposed the widget in the resize event If this happens end the processing of the Windows message by returning the result of the WM SIZE message
End deferred window positioning
Damage the widget to cause a repaint
Resize the embedded window
Check to see if the command is a system command or a user menu item that was added to the system menu
Bug in Windows When a vertical or horizontal scroll bar is hidden or shown while the opposite scroll bar is being scrolled by the user with WM HSCROLL code SB LINEDOWN the scroll bar does not redraw properly The fix is to detect this case and redraw the non client area
Return the result
