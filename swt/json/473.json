{
	"variables":[
		"tabs",
		"oldStart",
		"oldEnd",
		"doubleClick",
		"ignoreModify",
		"ignoreVerify",
		"ignoreCharacter",
		"LIMIT",
		"DELIMITER",
		"EditProc",
		"EditClass",
		"lpWndClass",
		"typedListener",
		"typedListener",
		"typedListener",
		"length",
		"buffer",
		"end",
		"height",
		"width",
		"newFont",
		"oldFont",
		"hDC",
		"tm",
		"count",
		"rect",
		"flags",
		"wrap",
		"length",
		"buffer",
		"newHeight",
		"trim",
		"rect",
		"margins",
		"bits1",
		"bits2",
		"start",
		"pos",
		"cp",
		"start",
		"end",
		"startLine",
		"caretPos",
		"caretLine",
		"caret",
		"length",
		"echo",
		"bits",
		"newFont",
		"oldFont",
		"hDC",
		"tm",
		"start",
		"end",
		"selection",
		"length",
		"start",
		"end",
		"buffer",
		"oldFont",
		"rect",
		"hDC",
		"newFont",
		"flags",
		"SPACE",
		"length",
		"buffer",
		"length",
		"buffer",
		"code",
		"start",
		"end",
		"buffer",
		"cp",
		"wcsTotal",
		"mbcsTotal",
		"buffer",
		"delimiter",
		"delimiterSize",
		"count",
		"line",
		"wcsSize",
		"linePos",
		"mbcsSize",
		"i",
		"bufferSize",
		"key",
		"stateMask",
		"oldText",
		"start",
		"end",
		"lineStart",
		"newStart",
		"newEnd",
		"length",
		"line",
		"lineStart",
		"newStart",
		"newEnd",
		"newText",
		"buffer",
		"rect",
		"start",
		"end",
		"flags",
		"bits",
		"start",
		"end",
		"width",
		"length",
		"buffer",
		"count",
		"topIndex",
		"event",
		"cp",
		"wcsTotal",
		"mbcsTotal",
		"buffer",
		"delimiter",
		"delimiterSize",
		"count",
		"line",
		"wcsSize",
		"linePos",
		"mbcsSize",
		"i",
		"index",
		"bits",
		"result",
		"result",
		"result",
		"result",
		"result",
		"code",
		"display",
		"result",
		"msg",
		"flags",
		"start",
		"end",
		"length",
		"result",
		"hasMenu",
		"x",
		"y",
		"shrg",
		"type",
		"result",
		"result",
		"result",
		"call",
		"start",
		"end",
		"newText",
		"length",
		"buffer",
		"oldText",
		"buffer",
		"code",
		"LIMIT",
		"OS",
		"DELIMITER",
		"OS",
		"EditClass",
		"lpWndClass",
		"EditProc",
		"lpWndClass",
		"parent",
		"style",
		"handle",
		"OS",
		"EditProc",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"OS",
		"handle",
		"OS",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"SWT",
		"typedListener",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"string",
		"SWT",
		"string",
		"Display",
		"string",
		"OS",
		"handle",
		"SWT",
		"SWT",
		"string",
		"string",
		"length",
		"length",
		"string",
		"OS",
		"handle",
		"OS",
		"length",
		"length",
		"string",
		"ignoreCharacter",
		"OS",
		"handle",
		"OS",
		"buffer",
		"ignoreCharacter",
		"OS",
		"handle",
		"OS",
		"style",
		"SWT",
		"style",
		"SWT",
		"style",
		"SWT",
		"style",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"style",
		"SWT",
		"style",
		"SWT",
		"style",
		"SWT",
		"style",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"style",
		"style",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"style",
		"SWT",
		"OS",
		"OS",
		"handle",
		"OS",
		"end",
		"OS",
		"handle",
		"OS",
		"end",
		"end",
		"OS",
		"handle",
		"OS",
		"wHint",
		"SWT",
		"hHint",
		"SWT",
		"OS",
		"handle",
		"newFont",
		"OS",
		"handle",
		"OS",
		"newFont",
		"oldFont",
		"OS",
		"hDC",
		"newFont",
		"OS",
		"OS",
		"hDC",
		"tm",
		"OS",
		"handle",
		"OS",
		"height",
		"count",
		"tm",
		"OS",
		"OS",
		"OS",
		"style",
		"SWT",
		"style",
		"SWT",
		"wrap",
		"wHint",
		"SWT",
		"flags",
		"OS",
		"rect",
		"wHint",
		"OS",
		"handle",
		"length",
		"length",
		"OS",
		"handle",
		"buffer",
		"length",
		"OS",
		"hDC",
		"buffer",
		"length",
		"rect",
		"flags",
		"width",
		"rect",
		"rect",
		"wrap",
		"hHint",
		"SWT",
		"rect",
		"rect",
		"newHeight",
		"height",
		"newHeight",
		"newFont",
		"OS",
		"hDC",
		"oldFont",
		"OS",
		"handle",
		"hDC",
		"width",
		"width",
		"DEFAULT_WIDTH",
		"height",
		"height",
		"DEFAULT_HEIGHT",
		"wHint",
		"SWT",
		"width",
		"wHint",
		"hHint",
		"SWT",
		"height",
		"hHint",
		"width",
		"height",
		"trim",
		"trim",
		"x",
		"y",
		"width",
		"height",
		"OS",
		"handle",
		"OS",
		"rect",
		"margins",
		"rect",
		"margins",
		"margins",
		"style",
		"SWT",
		"rect",
		"style",
		"SWT",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"OS",
		"handle",
		"OS",
		"doubleClick",
		"tabs",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"style",
		"SWT",
		"bits1",
		"OS",
		"style",
		"SWT",
		"bits1",
		"OS",
		"bits2",
		"OS",
		"style",
		"SWT",
		"bits1",
		"OS",
		"bits2",
		"OS",
		"style",
		"SWT",
		"bits1",
		"OS",
		"bits2",
		"OS",
		"style",
		"SWT",
		"bits1",
		"OS",
		"bits2",
		"OS",
		"style",
		"SWT",
		"bits2",
		"OS",
		"OS",
		"handle",
		"OS",
		"bits1",
		"OS",
		"handle",
		"OS",
		"bits2",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"start",
		"OS",
		"handle",
		"OS",
		"start",
		"pos",
		"pos",
		"start",
		"OS",
		"handle",
		"ignoreCharacter",
		"ignoreModify",
		"OS",
		"handle",
		"OS",
		"cp",
		"pos",
		"OS",
		"handle",
		"OS",
		"start",
		"OS",
		"handle",
		"OS",
		"start",
		"start",
		"OS",
		"handle",
		"OS",
		"cp",
		"ignoreCharacter",
		"ignoreModify",
		"pos",
		"pos",
		"OS",
		"handle",
		"OS",
		"start",
		"end",
		"OS",
		"handle",
		"OS",
		"start",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"caretPos",
		"end",
		"caretLine",
		"startLine",
		"caret",
		"start",
		"OS",
		"OS",
		"caret",
		"caret",
		"caret",
		"OS",
		"handle",
		"OS",
		"OS",
		"length",
		"length",
		"length",
		"doubleClick",
		"OS",
		"handle",
		"OS",
		"echo",
		"echo",
		"Display",
		"echo",
		"echo",
		"echo",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"OS",
		"handle",
		"OS",
		"DELIMITER",
		"OS",
		"handle",
		"newFont",
		"OS",
		"handle",
		"OS",
		"newFont",
		"oldFont",
		"OS",
		"hDC",
		"newFont",
		"OS",
		"OS",
		"hDC",
		"tm",
		"newFont",
		"OS",
		"hDC",
		"oldFont",
		"OS",
		"handle",
		"hDC",
		"tm",
		"style",
		"SWT",
		"SWT",
		"OS",
		"handle",
		"OS",
		"start",
		"end",
		"OS",
		"OS",
		"start",
		"start",
		"end",
		"end",
		"start",
		"end",
		"selection",
		"selection",
		"OS",
		"handle",
		"length",
		"OS",
		"handle",
		"OS",
		"start",
		"end",
		"start",
		"end",
		"length",
		"OS",
		"handle",
		"buffer",
		"length",
		"buffer",
		"start",
		"end",
		"start",
		"tabs",
		"OS",
		"handle",
		"OS",
		"handle",
		"OS",
		"newFont",
		"oldFont",
		"OS",
		"hDC",
		"newFont",
		"OS",
		"OS",
		"OS",
		"OS",
		"hDC",
		"SPACE",
		"SPACE",
		"rect",
		"flags",
		"newFont",
		"OS",
		"hDC",
		"oldFont",
		"OS",
		"handle",
		"hDC",
		"rect",
		"rect",
		"tabs",
		"OS",
		"handle",
		"length",
		"length",
		"OS",
		"handle",
		"buffer",
		"length",
		"buffer",
		"length",
		"start",
		"end",
		"end",
		"OS",
		"handle",
		"OS",
		"OS",
		"length",
		"length",
		"start",
		"Math",
		"start",
		"end",
		"Math",
		"end",
		"length",
		"start",
		"end",
		"OS",
		"handle",
		"OS",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"buffer",
		"code",
		"buffer",
		"string",
		"SWT",
		"string",
		"Display",
		"string",
		"SWT",
		"SWT",
		"OS",
		"handle",
		"OS",
		"start",
		"end",
		"string",
		"string",
		"start",
		"end",
		"string",
		"string",
		"ignoreCharacter",
		"OS",
		"handle",
		"OS",
		"buffer",
		"ignoreCharacter",
		"mbcsPos",
		"OS",
		"mbcsPos",
		"delimiter",
		"OS",
		"handle",
		"OS",
		"line",
		"count",
		"line",
		"OS",
		"handle",
		"OS",
		"line",
		"OS",
		"handle",
		"OS",
		"linePos",
		"mbcsSize",
		"mbcsSize",
		"delimiterSize",
		"buffer",
		"buffer",
		"mbcsSize",
		"delimiterSize",
		"buffer",
		"mbcsSize",
		"buffer",
		"mbcsSize",
		"mbcsSize",
		"OS",
		"handle",
		"OS",
		"line",
		"buffer",
		"wcsSize",
		"OS",
		"cp",
		"OS",
		"buffer",
		"mbcsSize",
		"line",
		"count",
		"i",
		"delimiterSize",
		"i",
		"buffer",
		"mbcsSize",
		"delimiter",
		"i",
		"wcsSize",
		"delimiterSize",
		"mbcsTotal",
		"mbcsSize",
		"mbcsPos",
		"mbcsPos",
		"mbcsTotal",
		"wcsSize",
		"OS",
		"cp",
		"OS",
		"buffer",
		"bufferSize",
		"wcsTotal",
		"wcsSize",
		"wcsTotal",
		"wcsSize",
		"mbcsTotal",
		"mbcsSize",
		"wcsTotal",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"eventTable",
		"SWT",
		"listener",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"OS",
		"handle",
		"OS",
		"type",
		"msg",
		"wParam",
		"lParam",
		"event",
		"style",
		"SWT",
		"ignoreVerify",
		"type",
		"SWT",
		"msg",
		"OS",
		"msg",
		"OS",
		"msg",
		"OS",
		"event",
		"SWT",
		"SWT",
		"event",
		"event",
		"msg",
		"OS",
		"key",
		"key",
		"key",
		"key",
		"key",
		"OS",
		"stateMask",
		"SWT",
		"SWT",
		"SWT",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"start",
		"end",
		"key",
		"start",
		"end",
		"start",
		"OS",
		"handle",
		"OS",
		"start",
		"lineStart",
		"start",
		"start",
		"DELIMITER",
		"start",
		"start",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"start",
		"end",
		"OS",
		"handle",
		"OS",
		"newStart",
		"newEnd",
		"start",
		"newStart",
		"start",
		"start",
		"start",
		"Math",
		"start",
		"start",
		"end",
		"OS",
		"handle",
		"start",
		"length",
		"OS",
		"handle",
		"OS",
		"end",
		"OS",
		"handle",
		"OS",
		"line",
		"end",
		"lineStart",
		"DELIMITER",
		"end",
		"end",
		"DELIMITER",
		"end",
		"end",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"start",
		"end",
		"OS",
		"handle",
		"OS",
		"newStart",
		"newEnd",
		"end",
		"newEnd",
		"end",
		"end",
		"end",
		"Math",
		"end",
		"length",
		"style",
		"SWT",
		"oldText",
		"DELIMITER",
		"key",
		"key",
		"oldText",
		"key",
		"oldText",
		"start",
		"end",
		"event",
		"newText",
		"newText",
		"oldText",
		"newText",
		"Display",
		"newText",
		"newText",
		"OS",
		"handle",
		"OS",
		"start",
		"end",
		"ignoreCharacter",
		"OS",
		"handle",
		"OS",
		"buffer",
		"ignoreCharacter",
		"flags",
		"OS",
		"width",
		"OS",
		"handle",
		"rect",
		"rect",
		"rect",
		"OS",
		"handle",
		"OS",
		"start",
		"end",
		"start",
		"end",
		"handle",
		"x",
		"y",
		"width",
		"height",
		"flags",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"start",
		"end",
		"x",
		"y",
		"width",
		"height",
		"flags",
		"doubleClick",
		"style",
		"SWT",
		"echo",
		"echo",
		"Display",
		"echo",
		"echo",
		"OS",
		"handle",
		"OS",
		"echo",
		"OS",
		"handle",
		"style",
		"SWT",
		"editable",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"editable",
		"font",
		"tabs",
		"OS",
		"OS",
		"OS",
		"SWT",
		"SWT",
		"orientation",
		"flags",
		"orientation",
		"flags",
		"flags",
		"style",
		"flags",
		"style",
		"orientation",
		"flags",
		"OS",
		"handle",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"OS",
		"bits",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"OS",
		"start",
		"start",
		"OS",
		"handle",
		"OS",
		"start",
		"start",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"start",
		"start",
		"end",
		"end",
		"OS",
		"handle",
		"OS",
		"start",
		"end",
		"OS",
		"handle",
		"OS",
		"redraw",
		"drawCount",
		"OS",
		"handle",
		"OS",
		"start",
		"end",
		"redraw",
		"oldStart",
		"start",
		"oldEnd",
		"end",
		"oldStart",
		"start",
		"oldEnd",
		"end",
		"OS",
		"handle",
		"OS",
		"selection",
		"SWT",
		"selection",
		"selection",
		"tabs",
		"tabs",
		"tabs",
		"OS",
		"OS",
		"handle",
		"OS",
		"width",
		"string",
		"SWT",
		"string",
		"Display",
		"string",
		"SWT",
		"SWT",
		"OS",
		"handle",
		"string",
		"string",
		"length",
		"string",
		"string",
		"OS",
		"handle",
		"buffer",
		"style",
		"SWT",
		"SWT",
		"limit",
		"SWT",
		"OS",
		"handle",
		"OS",
		"limit",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"index",
		"Math",
		"Math",
		"index",
		"count",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"index",
		"topIndex",
		"OS",
		"handle",
		"OS",
		"ignoreVerify",
		"string",
		"event",
		"string",
		"event",
		"start",
		"event",
		"end",
		"keyEvent",
		"event",
		"keyEvent",
		"event",
		"keyEvent",
		"event",
		"keyEvent",
		"OS",
		"OS",
		"event",
		"start",
		"event",
		"end",
		"SWT",
		"event",
		"event",
		"event",
		"wcsPos",
		"OS",
		"wcsPos",
		"delimiter",
		"OS",
		"handle",
		"OS",
		"line",
		"count",
		"line",
		"OS",
		"handle",
		"OS",
		"line",
		"OS",
		"handle",
		"OS",
		"linePos",
		"mbcsSize",
		"mbcsSize",
		"delimiterSize",
		"buffer",
		"buffer",
		"mbcsSize",
		"delimiterSize",
		"buffer",
		"mbcsSize",
		"buffer",
		"mbcsSize",
		"mbcsSize",
		"OS",
		"handle",
		"OS",
		"line",
		"buffer",
		"wcsSize",
		"OS",
		"cp",
		"OS",
		"buffer",
		"mbcsSize",
		"line",
		"count",
		"i",
		"delimiterSize",
		"i",
		"buffer",
		"mbcsSize",
		"delimiter",
		"i",
		"wcsSize",
		"delimiterSize",
		"wcsTotal",
		"wcsSize",
		"wcsPos",
		"wcsSize",
		"index",
		"mbcsSize",
		"wcsTotal",
		"wcsSize",
		"wcsPos",
		"mbcsTotal",
		"index",
		"OS",
		"buffer",
		"index",
		"index",
		"wcsSize",
		"mbcsTotal",
		"mbcsSize",
		"wcsTotal",
		"wcsSize",
		"mbcsTotal",
		"mbcsSize",
		"mbcsTotal",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"bits",
		"OS",
		"OS",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"OS",
		"bits",
		"EditClass",
		"EditProc",
		"msg",
		"OS",
		"style",
		"SWT",
		"OS",
		"wParam",
		"lParam",
		"result",
		"result",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"ignoreCharacter",
		"wParam",
		"lParam",
		"result",
		"result",
		"wParam",
		"SWT",
		"OS",
		"OS",
		"LRESULT",
		"style",
		"SWT",
		"wParam",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"LRESULT",
		"result",
		"wParam",
		"lParam",
		"result",
		"result",
		"OS",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"result",
		"result",
		"OS",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"result",
		"result",
		"OS",
		"style",
		"SWT",
		"style",
		"SWT",
		"lParam",
		"OS",
		"OS",
		"OS",
		"style",
		"SWT",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"code",
		"OS",
		"OS",
		"code",
		"display",
		"display",
		"wParam",
		"display",
		"display",
		"display",
		"SWT",
		"OS",
		"wParam",
		"lParam",
		"LRESULT",
		"ignoreCharacter",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"msg",
		"handle",
		"OS",
		"OS",
		"flags",
		"OS",
		"msg",
		"OS",
		"msg",
		"ignoreCharacter",
		"SWT",
		"OS",
		"wParam",
		"lParam",
		"display",
		"display",
		"result",
		"SWT",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"SWT",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"OS",
		"handle",
		"OS",
		"handle",
		"doubleClick",
		"LRESULT",
		"OS",
		"handle",
		"OS",
		"start",
		"end",
		"start",
		"end",
		"OS",
		"handle",
		"length",
		"start",
		"OS",
		"handle",
		"OS",
		"length",
		"result",
		"LRESULT",
		"OS",
		"wParam",
		"lParam",
		"SWT",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"menu",
		"menu",
		"hasMenu",
		"SWT",
		"lParam",
		"lParam",
		"shrg",
		"SHRGINFO",
		"shrg",
		"handle",
		"shrg",
		"x",
		"shrg",
		"y",
		"shrg",
		"OS",
		"OS",
		"shrg",
		"type",
		"OS",
		"x",
		"y",
		"LRESULT",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"OS",
		"handle",
		"OS",
		"handle",
		"result",
		"wParam",
		"lParam",
		"result",
		"result",
		"OS",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"result",
		"result",
		"OS",
		"wParam",
		"lParam",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"msg",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"start",
		"end",
		"start",
		"end",
		"newText",
		"call",
		"OS",
		"OS",
		"handle",
		"OS",
		"start",
		"end",
		"newText",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"ignoreModify",
		"ignoreCharacter",
		"OS",
		"handle",
		"OS",
		"start",
		"end",
		"handle",
		"msg",
		"wParam",
		"lParam",
		"OS",
		"handle",
		"length",
		"start",
		"end",
		"length",
		"OS",
		"handle",
		"buffer",
		"length",
		"newText",
		"buffer",
		"start",
		"end",
		"start",
		"newText",
		"handle",
		"msg",
		"wParam",
		"lParam",
		"ignoreModify",
		"ignoreCharacter",
		"newText",
		"newText",
		"newText",
		"newText",
		"start",
		"end",
		"newText",
		"LRESULT",
		"newText",
		"oldText",
		"call",
		"handle",
		"msg",
		"wParam",
		"lParam",
		"newText",
		"Display",
		"newText",
		"newText",
		"ignoreCharacter",
		"OS",
		"handle",
		"OS",
		"buffer",
		"ignoreCharacter",
		"LRESULT",
		"msg",
		"OS",
		"ignoreVerify",
		"ignoreCharacter",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"ignoreVerify",
		"ignoreCharacter",
		"LRESULT",
		"wParam",
		"code",
		"OS",
		"ignoreModify",
		"SWT",
		"LRESULT",
		"OS",
		"style",
		"SWT",
		"style",
		"SWT",
		"OS",
		"style",
		"SWT",
		"style",
		"SWT",
		"wParam",
		"lParam",
		"IsWinNT",
		"lpfnWndProc",
		"EM_LIMITTEXT",
		"ERROR_NULL_ARGUMENT",
		"Modify",
		"ERROR_NULL_ARGUMENT",
		"Selection",
		"DefaultSelection",
		"ERROR_NULL_ARGUMENT",
		"Verify",
		"ERROR_NULL_ARGUMENT",
		"Verify",
		"Verify",
		"EM_SETSEL",
		"EM_REPLACESEL",
		"EM_SCROLLCARET",
		"SINGLE",
		"MULTI",
		"MULTI",
		"LEFT",
		"CENTER",
		"RIGHT",
		"SINGLE",
		"H_SCROLL",
		"V_SCROLL",
		"WRAP",
		"WRAP",
		"MULTI",
		"H_SCROLL",
		"MULTI",
		"PASSWORD",
		"SINGLE",
		"MULTI",
		"H_SCROLL",
		"V_SCROLL",
		"MULTI",
		"SINGLE",
		"IsWinCE",
		"EM_GETSEL",
		"EM_SETSEL",
		"EM_SETSEL",
		"DEFAULT",
		"DEFAULT",
		"WM_GETFONT",
		"IsUnicode",
		"EM_GETLINECOUNT",
		"tmHeight",
		"DT_CALCRECT",
		"DT_EDITCONTROL",
		"DT_NOPREFIX",
		"MULTI",
		"WRAP",
		"DEFAULT",
		"DT_WORDBREAK",
		"right",
		"right",
		"left",
		"DEFAULT",
		"bottom",
		"top",
		"DEFAULT",
		"DEFAULT",
		"width",
		"height",
		"EM_GETMARGINS",
		"x",
		"width",
		"H_SCROLL",
		"width",
		"BORDER",
		"x",
		"y",
		"width",
		"height",
		"WM_COPY",
		"READ_ONLY",
		"WM_CUT",
		"COLOR_WINDOW",
		"MIRRORED",
		"GWL_EXSTYLE",
		"GWL_STYLE",
		"LEFT_TO_RIGHT",
		"WS_EX_LEFTSCROLLBAR",
		"RIGHT",
		"WS_EX_RIGHT",
		"ES_RIGHT",
		"LEFT",
		"WS_EX_RIGHT",
		"ES_RIGHT",
		"RIGHT",
		"WS_EX_RIGHT",
		"ES_RIGHT",
		"LEFT",
		"WS_EX_RIGHT",
		"ES_RIGHT",
		"CENTER",
		"ES_CENTER",
		"GWL_EXSTYLE",
		"GWL_STYLE",
		"EM_LINEFROMCHAR",
		"EM_GETSEL",
		"EM_POSFROMCHAR",
		"EM_REPLACESEL",
		"EM_POSFROMCHAR",
		"EM_SETSEL",
		"EM_REPLACESEL",
		"EM_GETSEL",
		"EM_LINEFROMCHAR",
		"EM_LINEINDEX",
		"EM_LINEFROMCHAR",
		"IsUnicode",
		"IsDBLocale",
		"IsUnicode",
		"IsDBLocale",
		"EM_GETPASSWORDCHAR",
		"GWL_STYLE",
		"ES_READONLY",
		"EM_GETLINECOUNT",
		"WM_GETFONT",
		"IsUnicode",
		"tmHeight",
		"LEFT_TO_RIGHT",
		"RIGHT_TO_LEFT",
		"EM_GETSEL",
		"IsUnicode",
		"IsDBLocale",
		"y",
		"x",
		"EM_GETSEL",
		"WM_GETFONT",
		"DT_CALCRECT",
		"DT_SINGLELINE",
		"DT_NOPREFIX",
		"right",
		"left",
		"IsUnicode",
		"IsDBLocale",
		"EM_GETLIMITTEXT",
		"SINGLE",
		"EM_GETFIRSTVISIBLELINE",
		"EM_GETSCROLLPOS",
		"ERROR_NULL_ARGUMENT",
		"Verify",
		"Verify",
		"EM_GETSEL",
		"EM_REPLACESEL",
		"IsUnicode",
		"EM_GETLINECOUNT",
		"EM_LINEINDEX",
		"EM_LINELENGTH",
		"length",
		"EM_GETLINE",
		"MB_PRECOMPOSED",
		"MB_PRECOMPOSED",
		"READ_ONLY",
		"WM_PASTE",
		"ERROR_NULL_ARGUMENT",
		"Modify",
		"ERROR_NULL_ARGUMENT",
		"Selection",
		"DefaultSelection",
		"ERROR_NULL_ARGUMENT",
		"Verify",
		"EM_SETSEL",
		"READ_ONLY",
		"KeyDown",
		"WM_CHAR",
		"WM_KEYDOWN",
		"WM_IME_CHAR",
		"character",
		"Verify",
		"Verify",
		"character",
		"stateMask",
		"WM_CHAR",
		"WM_KEYDOWN",
		"ALT",
		"SHIFT",
		"CONTROL",
		"VK_LBUTTON",
		"EM_GETSEL",
		"EM_LINEINDEX",
		"IsUnicode",
		"IsDBLocale",
		"EM_SETSEL",
		"EM_GETSEL",
		"EM_LINEFROMCHAR",
		"EM_LINEINDEX",
		"IsUnicode",
		"IsDBLocale",
		"EM_SETSEL",
		"EM_GETSEL",
		"SINGLE",
		"EM_SETSEL",
		"EM_REPLACESEL",
		"SWP_NOSIZE",
		"right",
		"left",
		"EM_GETSEL",
		"EM_SETSEL",
		"EM_SETSEL",
		"doubleClick",
		"MULTI",
		"EM_SETPASSWORDCHAR",
		"READ_ONLY",
		"READ_ONLY",
		"EM_SETREADONLY",
		"IsWinCE",
		"WIN32_VERSION",
		"RIGHT_TO_LEFT",
		"LEFT_TO_RIGHT",
		"GWL_EXSTYLE",
		"RIGHT_TO_LEFT",
		"WS_EX_RTLREADING",
		"WS_EX_LEFTSCROLLBAR",
		"WS_EX_RTLREADING",
		"WS_EX_LEFTSCROLLBAR",
		"GWL_EXSTYLE",
		"IsUnicode",
		"IsDBLocale",
		"EM_SETSEL",
		"EM_SCROLLCARET",
		"IsUnicode",
		"IsDBLocale",
		"EM_SETSEL",
		"EM_SCROLLCARET",
		"EM_GETSEL",
		"EM_SCROLLCARET",
		"ERROR_NULL_ARGUMENT",
		"x",
		"y",
		"tabs",
		"EM_SETTABSTOPS",
		"ERROR_NULL_ARGUMENT",
		"Verify",
		"Verify",
		"MULTI",
		"Modify",
		"ERROR_CANNOT_BE_ZERO",
		"EM_SETLIMITTEXT",
		"SINGLE",
		"EM_GETLINECOUNT",
		"EM_GETFIRSTVISIBLELINE",
		"EM_LINESCROLL",
		"EM_SCROLLCARET",
		"text",
		"start",
		"end",
		"character",
		"character",
		"keyCode",
		"keyCode",
		"stateMask",
		"stateMask",
		"IsUnicode",
		"IsDBLocale",
		"start",
		"end",
		"Verify",
		"doit",
		"text",
		"IsUnicode",
		"EM_GETLINECOUNT",
		"EM_LINEINDEX",
		"EM_LINELENGTH",
		"length",
		"EM_GETLINE",
		"MB_PRECOMPOSED",
		"ES_AUTOHSCROLL",
		"PASSWORD",
		"ES_PASSWORD",
		"CENTER",
		"ES_CENTER",
		"RIGHT",
		"ES_RIGHT",
		"READ_ONLY",
		"ES_READONLY",
		"SINGLE",
		"ES_MULTILINE",
		"ES_NOHIDESEL",
		"ES_AUTOVSCROLL",
		"WRAP",
		"WS_HSCROLL",
		"ES_AUTOHSCROLL",
		"EM_UNDO",
		"SINGLE",
		"EM_UNDO",
		"value",
		"EM_UNDO",
		"DEL",
		"VK_CONTROL",
		"ZERO",
		"SINGLE",
		"CR",
		"DefaultSelection",
		"TAB",
		"ESC",
		"ZERO",
		"WM_CLEAR",
		"WM_CUT",
		"IsPPC",
		"MULTI",
		"READ_ONLY",
		"DLGC_HASSETSEL",
		"DLGC_WANTALLKEYS",
		"DLGC_WANTCHARS",
		"READ_ONLY",
		"WM_GETDLGCODE",
		"DLGC_WANTALLKEYS",
		"DLGC_WANTTAB",
		"display",
		"lastKey",
		"lastAscii",
		"lastVirtual",
		"lastNull",
		"lastDead",
		"KeyDown",
		"WM_IME_CHAR",
		"ZERO",
		"WM_IME_CHAR",
		"PM_REMOVE",
		"PM_NOYIELD",
		"PM_QS_INPUT",
		"PM_QS_POSTMESSAGE",
		"WM_CHAR",
		"WM_CHAR",
		"KeyUp",
		"WM_IME_CHAR",
		"lastKey",
		"lastAscii",
		"MouseDown",
		"WM_LBUTTONDOWN",
		"MouseDoubleClick",
		"WM_LBUTTONDBLCLK",
		"ZERO",
		"EM_GETSEL",
		"EM_LINELENGTH",
		"ZERO",
		"IsPPC",
		"MouseDown",
		"WM_LBUTTONDOWN",
		"MenuDetect",
		"cbSize",
		"sizeof",
		"hwndClient",
		"ptDown_x",
		"ptDown_y",
		"dwFlags",
		"SHRG_RETURNCMD",
		"GN_CONTEXTMENU",
		"ONE",
		"WM_LBUTTONDOWN",
		"WM_PASTE",
		"WM_UNDO",
		"READ_ONLY",
		"Verify",
		"Verify",
		"WM_CLEAR",
		"WM_CUT",
		"EM_GETSEL",
		"WM_PASTE",
		"EM_GETSEL",
		"EM_UNDO",
		"WM_UNDO",
		"EM_CANUNDO",
		"EM_GETSEL",
		"ZERO",
		"EM_REPLACESEL",
		"ZERO",
		"WM_UNDO",
		"WM_UNDO",
		"ONE",
		"EN_CHANGE",
		"Modify",
		"ZERO",
		"EN_ALIGN_LTR_EC",
		"RIGHT_TO_LEFT",
		"LEFT_TO_RIGHT",
		"EN_ALIGN_RTL_EC",
		"LEFT_TO_RIGHT",
		"RIGHT_TO_LEFT",
		"parent",
		"style",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"listener",
		"listener",
		"listener",
		"string",
		"style",
		"wHint",
		"hHint",
		"changed",
		"x",
		"y",
		"width",
		"height",
		"tabs",
		"start",
		"end",
		"string",
		"mbcsPos",
		"listener",
		"listener",
		"listener",
		"type",
		"msg",
		"wParam",
		"lParam",
		"event",
		"x",
		"y",
		"width",
		"height",
		"flags",
		"doubleClick",
		"echo",
		"editable",
		"font",
		"orientation",
		"start",
		"start",
		"end",
		"redraw",
		"selection",
		"tabs",
		"tabs",
		"string",
		"limit",
		"index",
		"string",
		"start",
		"end",
		"keyEvent",
		"wcsPos",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"msg",
		"wParam",
		"lParam",
		"wParam",
		"lParam"
	],
	"extendORImplementFiles":[
		"Scrollable"
	],
	"package":[
		"org.eclipse.swt.widgets"
	],
	"import":[
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt",
		"org.eclipse.swt.graphics",
		"org.eclipse.swt.events"
	],
	"methods":[
		"callWindowProc",
		"createHandle",
		"addModifyListener",
		"addSelectionListener",
		"addVerifyListener",
		"append",
		"checkStyle",
		"clearSelection",
		"computeSize",
		"computeTrim",
		"copy",
		"createWidget",
		"cut",
		"defaultBackground",
		"fixAlignment",
		"getBorderWidth",
		"getCaretLineNumber",
		"getCaretLocation",
		"getCaretPosition",
		"getCharCount",
		"getDoubleClickEnabled",
		"getEchoChar",
		"getEditable",
		"getLineCount",
		"getLineDelimiter",
		"getLineHeight",
		"getOrientation",
		"getSelection",
		"getSelectionCount",
		"getSelectionText",
		"getTabs",
		"getTabWidth",
		"getText",
		"getText",
		"getTextLimit",
		"getTopIndex",
		"getTopPixel",
		"insert",
		"mbcsToWcsPos",
		"paste",
		"removeModifyListener",
		"removeSelectionListener",
		"removeVerifyListener",
		"selectAll",
		"sendKeyEvent",
		"setBounds",
		"setDoubleClickEnabled",
		"setEchoChar",
		"setEditable",
		"setFont",
		"setOrientation",
		"setSelection",
		"setSelection",
		"setRedraw",
		"setSelection",
		"setTabs",
		"setTabStops",
		"setText",
		"setTextLimit",
		"setTopIndex",
		"showSelection",
		"verifyText",
		"wcsToMbcsPos",
		"widgetStyle",
		"windowClass",
		"windowProc",
		"windowProc",
		"WM_CHAR",
		"WM_CLEAR",
		"WM_CUT",
		"WM_GETDLGCODE",
		"WM_IME_CHAR",
		"WM_LBUTTONDBLCLK",
		"WM_LBUTTONDOWN",
		"WM_PASTE",
		"WM_UNDO",
		"wmClipboard",
		"wmCommandChild",
		"GetClassInfo",
		"checkStyle",
		"CallWindowProc",
		"createHandle",
		"SendMessage",
		"checkWidget",
		"error",
		"addListener",
		"checkWidget",
		"error",
		"addListener",
		"addListener",
		"checkWidget",
		"error",
		"addListener",
		"checkWidget",
		"error",
		"withCrLf",
		"GetWindowTextLength",
		"hooks",
		"filters",
		"verifyText",
		"SendMessage",
		"getCodePage",
		"SendMessage",
		"SendMessage",
		"checkBits",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"checkWidget",
		"GetDC",
		"SendMessage",
		"SelectObject",
		"GetTextMetrics",
		"SendMessage",
		"GetWindowTextLength",
		"getCodePage",
		"GetWindowText",
		"DrawText",
		"SelectObject",
		"ReleaseDC",
		"computeTrim",
		"checkWidget",
		"computeTrim",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"createWidget",
		"setTabStops",
		"fixAlignment",
		"checkWidget",
		"SendMessage",
		"GetSysColor",
		"GetWindowLong",
		"GetWindowLong",
		"SetWindowLong",
		"SetWindowLong",
		"checkWidget",
		"getBorderWidth",
		"checkWidget",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"GetWindowTextLength",
		"getCodePage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"mbcsToWcsPos",
		"checkWidget",
		"GetWindowTextLength",
		"mbcsToWcsPos",
		"checkWidget",
		"checkWidget",
		"SendMessage",
		"mbcsToWcs",
		"getCodePage",
		"checkWidget",
		"GetWindowLong",
		"checkWidget",
		"SendMessage",
		"checkWidget",
		"checkWidget",
		"GetDC",
		"SendMessage",
		"SelectObject",
		"GetTextMetrics",
		"SelectObject",
		"ReleaseDC",
		"checkWidget",
		"checkWidget",
		"SendMessage",
		"mbcsToWcsPos",
		"mbcsToWcsPos",
		"checkWidget",
		"getSelection",
		"checkWidget",
		"GetWindowTextLength",
		"SendMessage",
		"getCodePage",
		"GetWindowText",
		"toString",
		"checkWidget",
		"GetDC",
		"SendMessage",
		"SelectObject",
		"getCodePage",
		"DrawText",
		"length",
		"SelectObject",
		"ReleaseDC",
		"checkWidget",
		"GetWindowTextLength",
		"getCodePage",
		"GetWindowText",
		"toString",
		"checkWidget",
		"GetWindowTextLength",
		"mbcsToWcsPos",
		"max",
		"min",
		"substring",
		"getText",
		"checkWidget",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"getTopIndex",
		"getLineHeight",
		"checkWidget",
		"error",
		"withCrLf",
		"hooks",
		"filters",
		"SendMessage",
		"verifyText",
		"getCodePage",
		"SendMessage",
		"getCodePage",
		"getLineDelimiter",
		"length",
		"SendMessageA",
		"SendMessageA",
		"SendMessageA",
		"SendMessageA",
		"MultiByteToWideChar",
		"charAt",
		"MultiByteToWideChar",
		"checkWidget",
		"SendMessage",
		"checkWidget",
		"error",
		"unhook",
		"checkWidget",
		"error",
		"unhook",
		"unhook",
		"checkWidget",
		"error",
		"unhook",
		"checkWidget",
		"SendMessage",
		"sendKeyEvent",
		"hooks",
		"filters",
		"GetKeyState",
		"SendMessage",
		"SendMessage",
		"length",
		"SendMessage",
		"SendMessage",
		"max",
		"GetWindowTextLength",
		"SendMessage",
		"SendMessage",
		"length",
		"length",
		"SendMessage",
		"SendMessage",
		"min",
		"verifyText",
		"withCrLf",
		"getCodePage",
		"SendMessage",
		"SendMessage",
		"GetWindowRect",
		"SendMessage",
		"SetWindowPos",
		"SendMessage",
		"SendMessage",
		"setBounds",
		"checkWidget",
		"checkWidget",
		"wcsToMbcs",
		"getCodePage",
		"SendMessage",
		"InvalidateRect",
		"checkWidget",
		"SendMessage",
		"checkWidget",
		"setFont",
		"setTabStops",
		"checkWidget",
		"VERSION",
		"GetWindowLong",
		"SetWindowLong",
		"fixAlignment",
		"checkWidget",
		"wcsToMbcsPos",
		"SendMessage",
		"SendMessage",
		"checkWidget",
		"wcsToMbcsPos",
		"wcsToMbcsPos",
		"SendMessage",
		"SendMessage",
		"checkWidget",
		"setRedraw",
		"SendMessage",
		"SendMessage",
		"checkWidget",
		"error",
		"setSelection",
		"checkWidget",
		"setTabStops",
		"getTabWidth",
		"GetDialogBaseUnits",
		"SendMessage",
		"checkWidget",
		"error",
		"withCrLf",
		"hooks",
		"filters",
		"GetWindowTextLength",
		"verifyText",
		"getCodePage",
		"SetWindowText",
		"sendEvent",
		"checkWidget",
		"error",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"min",
		"max",
		"SendMessage",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"mbcsToWcsPos",
		"mbcsToWcsPos",
		"sendEvent",
		"isDisposed",
		"getCodePage",
		"getLineDelimiter",
		"length",
		"SendMessageA",
		"SendMessageA",
		"SendMessageA",
		"SendMessageA",
		"MultiByteToWideChar",
		"charAt",
		"IsDBCSLeadByte",
		"widgetStyle",
		"wmClipboard",
		"callWindowProc",
		"windowProc",
		"WM_CHAR",
		"GetKeyState",
		"postEvent",
		"WM_CLEAR",
		"wmClipboard",
		"WM_CUT",
		"wmClipboard",
		"WM_GETDLGCODE",
		"callWindowProc",
		"sendKeyEvent",
		"callWindowProc",
		"PeekMessage",
		"TranslateMessage",
		"DispatchMessage",
		"sendKeyEvent",
		"sendMouseEvent",
		"sendMouseEvent",
		"GetCapture",
		"SetCapture",
		"SendMessage",
		"GetWindowTextLength",
		"SendMessage",
		"WM_LBUTTONDOWN",
		"sendMouseEvent",
		"isDisposed",
		"hooks",
		"SHRecognizeGesture",
		"showMenu",
		"callWindowProc",
		"GetCapture",
		"SetCapture",
		"WM_PASTE",
		"wmClipboard",
		"WM_UNDO",
		"wmClipboard",
		"hooks",
		"filters",
		"SendMessage",
		"SendMessage",
		"getClipboardText",
		"SendMessage",
		"SendMessage",
		"callWindowProc",
		"GetWindowTextLength",
		"getCodePage",
		"GetWindowText",
		"toString",
		"callWindowProc",
		"verifyText",
		"equals",
		"callWindowProc",
		"withCrLf",
		"getCodePage",
		"SendMessage",
		"callWindowProc",
		"sendEvent",
		"isDisposed",
		"fixAlignment",
		"fixAlignment",
		"wmCommandChild",
		"TCHAR",
		"WNDCLASS",
		"TypedListener",
		"TypedListener",
		"TypedListener",
		"TCHAR",
		"TEXTMETRICW",
		"TEXTMETRICA",
		"RECT",
		"TCHAR",
		"Point",
		"TCHAR",
		"TCHAR",
		"Point",
		"TEXTMETRICW",
		"TEXTMETRICA",
		"Point",
		"TCHAR",
		"RECT",
		"TCHAR",
		"TCHAR",
		"TCHAR",
		"String",
		"TCHAR",
		"RECT",
		"TCHAR",
		"Event",
		"LRESULT",
		"LRESULT",
		"MSG",
		"LRESULT",
		"SHRGINFO",
		"LRESULT",
		"TCHAR",
		"TCHAR"
	],
	"methodsBody":{
		"public void setText(String string)":{
			"methodBody":"{\n    checkWidget();\n    if (string == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    string = Display.withCrLf(string);\n    if (hooks(SWT.Verify) || filters(SWT.Verify)) {\n        int length = OS.GetWindowTextLength(handle);\n        string = verifyText(string, 0, length, null);\n        if (string == null)\n            return;\n    }\n    TCHAR buffer = new TCHAR(getCodePage(), string, true);\n    OS.SetWindowText(handle, buffer);\n    \n    if ((style & SWT.MULTI) != 0) {\n        sendEvent(SWT.Modify);\n    \n    }\n}",
			"comments":"/**\n* Sets the contents of the receiver to the given string. If the receiver has style\n* SINGLE and the argument contains multiple lines of text, the result of this\n* operation is undefined and may vary from platform to platform.\n*\n* @param string the new text\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the string is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* Bug in Windows.  When the widget is multi line\n* text widget, it does not send a WM_COMMAND with\n* control code EN_CHANGE from SetWindowText () to\n* notify the application that the text has changed.\n* The fix is to send the event.\n*/\n// widget could be disposed at this point\n",
			"methodName":"public void setText(String string)"
		},
		"int windowProc(int hwnd, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    if (msg == OS.EM_UNDO) {\n        if ((style & SWT.SINGLE) != 0) {\n            LRESULT result = wmClipboard(OS.EM_UNDO, wParam, lParam);\n            if (result != null)\n                return result.value;\n            return callWindowProc(hwnd, OS.EM_UNDO, wParam, lParam);\n        }\n    }\n    return super.windowProc(hwnd, msg, wParam, lParam);\n}",
			"comments":"",
			"methodName":"int windowProc(int hwnd, int msg, int wParam, int lParam)"
		},
		"public void insert(String string)":{
			"methodBody":"{\n    checkWidget();\n    if (string == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    string = Display.withCrLf(string);\n    if (hooks(SWT.Verify) || filters(SWT.Verify)) {\n        int[] start = new int[1], end = new int[1];\n        OS.SendMessage(handle, OS.EM_GETSEL, start, end);\n        string = verifyText(string, start[0], end[0], null);\n        if (string == null)\n            return;\n    }\n    TCHAR buffer = new TCHAR(getCodePage(), string, true);\n    \n    ignoreCharacter = true;\n    OS.SendMessage(handle, OS.EM_REPLACESEL, 0, buffer);\n    ignoreCharacter = false;\n}",
			"comments":"/**\n* Inserts a string.\n* <p>\n* The old selection is replaced with the new text.\n* </p>\n*\n* @param string the string\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the string is <code>null</code></li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* Feature in Windows.  When an edit control with ES_MULTILINE\n* style that does not have the WS_VSCROLL style is full (i.e.\n* there is no space at the end to draw any more characters),\n* EM_REPLACESEL sends a WM_CHAR with a backspace character\n* to remove any further text that is added.  This is an\n* implementation detail of the edit control that is unexpected\n* and can cause endless recursion when EM_REPLACESEL is sent\n* from a WM_CHAR handler.  The fix is to ignore calling the\n* handler from WM_CHAR.\n*/\n",
			"methodName":"public void insert(String string)"
		},
		"public void setOrientation(int orientation)":{
			"methodBody":"{\n    checkWidget();\n    if (OS.IsWinCE)\n        return;\n    if (OS.WIN32_VERSION < OS.VERSION(4, 10))\n        return;\n    int flags = SWT.RIGHT_TO_LEFT | SWT.LEFT_TO_RIGHT;\n    if ((orientation & flags) == 0 || (orientation & flags) == flags)\n        return;\n    style &= ~flags;\n    style |= orientation & flags;\n    int bits = OS.GetWindowLong(handle, OS.GWL_EXSTYLE);\n    if ((style & SWT.RIGHT_TO_LEFT) != 0) {\n        bits |= OS.WS_EX_RTLREADING | OS.WS_EX_LEFTSCROLLBAR;\n    } else {\n        bits &= ~(OS.WS_EX_RTLREADING | OS.WS_EX_LEFTSCROLLBAR);\n    }\n    OS.SetWindowLong(handle, OS.GWL_EXSTYLE, bits);\n    fixAlignment();\n}",
			"comments":"/**\n* Sets the orientation of the receiver, which must be one\n* of the constants <code>SWT.LEFT_TO_RIGHT</code> or <code>SWT.RIGHT_TO_LEFT</code>.\n* <p>\n* Note: This operation is a hint and is not supported on\n* platforms that do not have this concept.\n* </p>\n*\n* @param orientation new orientation style\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 2.1.2\n*/\n",
			"methodName":"public void setOrientation(int orientation)"
		},
		"public int getCaretPosition()":{
			"methodBody":"{\n    checkWidget();\n    int[] start = new int[1], end = new int[1];\n    OS.SendMessage(handle, OS.EM_GETSEL, start, end);\n    int startLine = OS.SendMessage(handle, OS.EM_LINEFROMCHAR, start[0], 0);\n    int caretPos = OS.SendMessage(handle, OS.EM_LINEINDEX, -1, 0);\n    int caretLine = OS.SendMessage(handle, OS.EM_LINEFROMCHAR, caretPos, 0);\n    int caret = end[0];\n    if (caretLine == startLine)\n        caret = start[0];\n    if (!OS.IsUnicode && OS.IsDBLocale)\n        caret = mbcsToWcsPos(caret);\n    return caret;\n}",
			"comments":"/**\n* Returns the character position of the caret.\n* <p>\n* Indexing is zero based.\n* </p>\n*\n* @return the position of the caret\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getCaretPosition()"
		},
		"public String getText(int start, int end)":{
			"methodBody":"{\n    checkWidget();\n    if (!(start <= end && 0 <= end))\n        return \"\";\n    int length = OS.GetWindowTextLength(handle);\n    if (!OS.IsUnicode && OS.IsDBLocale)\n        length = mbcsToWcsPos(length);\n    start = Math.max(0, start);\n    end = Math.min(end, length - 1);\n    \n    return getText().substring(start, end + 1);\n}",
			"comments":"/**\n* Returns a range of text.  Returns an empty string if the\n* start of the range is greater than the end.\n* <p>\n* Indexing is zero based.  The range of\n* a selection is from 0..N-1 where N is\n* the number of characters in the widget.\n* </p>\n*\n* @param start the start of the range\n* @param end the end of the range\n* @return the range of text\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* NOTE: The current implementation uses substring ()\n* which can reference a potentially large character\n* array.\n*/\n",
			"methodName":"public String getText(int start, int end)"
		},
		"public void selectAll()":{
			"methodBody":"{\n    checkWidget();\n    OS.SendMessage(handle, OS.EM_SETSEL, 0, -1);\n}",
			"comments":"/**\n* Selects all the text in the receiver.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void selectAll()"
		},
		"void setTabStops(int tabs)":{
			"methodBody":"{\n    \n    int width = (getTabWidth(tabs) * 4) / (OS.GetDialogBaseUnits() & 0xFFFF);\n    OS.SendMessage(handle, OS.EM_SETTABSTOPS, 1, new int[] { width });\n}",
			"comments":"/*\n* Feature in Windows.  Windows expects the tab spacing in\n* dialog units so we must convert from space widths.  Due\n* to round off error, the tab spacing may not be the exact\n* number of space widths, depending on the font.\n*/\n",
			"methodName":"void setTabStops(int tabs)"
		},
		"int getTabWidth(int tabs)":{
			"methodBody":"{\n    int oldFont = 0;\n    RECT rect = new RECT();\n    int hDC = OS.GetDC(handle);\n    int newFont = OS.SendMessage(handle, OS.WM_GETFONT, 0, 0);\n    if (newFont != 0)\n        oldFont = OS.SelectObject(hDC, newFont);\n    int flags = OS.DT_CALCRECT | OS.DT_SINGLELINE | OS.DT_NOPREFIX;\n    TCHAR SPACE = new TCHAR(getCodePage(), \" \", false);\n    OS.DrawText(hDC, SPACE, SPACE.length(), rect, flags);\n    if (newFont != 0)\n        OS.SelectObject(hDC, oldFont);\n    OS.ReleaseDC(handle, hDC);\n    return (rect.right - rect.left) * tabs;\n}",
			"comments":"",
			"methodName":"int getTabWidth(int tabs)"
		},
		"LRESULT WM_LBUTTONDBLCLK(int wParam, int lParam)":{
			"methodBody":"{\n    \n    sendMouseEvent(SWT.MouseDown, 1, handle, OS.WM_LBUTTONDOWN, wParam, lParam);\n    sendMouseEvent(SWT.MouseDoubleClick, 1, handle, OS.WM_LBUTTONDBLCLK, wParam, lParam);\n    if (OS.GetCapture() != handle)\n        OS.SetCapture(handle);\n    if (!doubleClick)\n        return LRESULT.ZERO;\n    \n    int[] start = new int[1], end = new int[1];\n    OS.SendMessage(handle, OS.EM_GETSEL, start, end);\n    if (start[0] == end[0]) {\n        int length = OS.GetWindowTextLength(handle);\n        if (length == start[0]) {\n            int result = OS.SendMessage(handle, OS.EM_LINELENGTH, length, 0);\n            if (result == 0)\n                return LRESULT.ZERO;\n        }\n    }\n    return null;\n}",
			"comments":"/*\n* Prevent Windows from processing WM_LBUTTONDBLCLK\n* when double clicking behavior is disabled by not\n* calling the window proc.\n*/\n/*\n* Bug in Windows.  When the last line of text in the\n* widget is double clicked and the line is empty, Windows\n* hides the i-beam then moves it to the first line in\n* the widget but does not scroll to show the user.\n* If the user types without clicking the mouse, invalid\n* characters are displayed at the end of each line of\n* text in the widget.  The fix is to detect this case\n* and avoid calling the window proc.\n*/\n",
			"methodName":"LRESULT WM_LBUTTONDBLCLK(int wParam, int lParam)"
		},
		"public int getTabs()":{
			"methodBody":"{\n    checkWidget();\n    return tabs;\n}",
			"comments":"/**\n* Returns the number of tabs.\n* <p>\n* Tab stop spacing is specified in terms of the\n* space (' ') character.  The width of a single\n* tab stop is the pixel width of the spaces.\n* </p>\n*\n* @return the number of tab characters\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getTabs()"
		},
		"LRESULT wmCommandChild(int wParam, int lParam)":{
			"methodBody":"{\n    int code = wParam >> 16;\n    switch(code) {\n        case OS.EN_CHANGE:\n            if (ignoreModify)\n                break;\n            \n            sendEvent(SWT.Modify);\n            if (isDisposed())\n                return LRESULT.ZERO;\n            break;\n        case OS.EN_ALIGN_LTR_EC:\n            style &= ~SWT.RIGHT_TO_LEFT;\n            style |= SWT.LEFT_TO_RIGHT;\n            fixAlignment();\n            break;\n        case OS.EN_ALIGN_RTL_EC:\n            style &= ~SWT.LEFT_TO_RIGHT;\n            style |= SWT.RIGHT_TO_LEFT;\n            fixAlignment();\n            break;\n    }\n    return super.wmCommandChild(wParam, lParam);\n}",
			"comments":"/*\n* It is possible (but unlikely), that application\n* code could have disposed the widget in the modify\n* event.  If this happens, end the processing of the\n* Windows message by returning zero as the result of\n* the window proc.\n*/\n",
			"methodName":"LRESULT wmCommandChild(int wParam, int lParam)"
		},
		"public void copy()":{
			"methodBody":"{\n    checkWidget();\n    OS.SendMessage(handle, OS.WM_COPY, 0, 0);\n}",
			"comments":"/**\n* Copies the selected text.\n* <p>\n* The current selection is copied to the clipboard.\n* </p>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void copy()"
		},
		"public boolean getDoubleClickEnabled()":{
			"methodBody":"{\n    checkWidget();\n    return doubleClick;\n}",
			"comments":"/**\n* Returns the double click enabled flag.\n* <p>\n* The double click flag enables or disables the\n* default action of the text widget when the user\n* double clicks.\n* </p>\n*\n* @return whether or not double click is enabled\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public boolean getDoubleClickEnabled()"
		},
		"public void removeVerifyListener(VerifyListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.Verify, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when the control is verified.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see VerifyListener\n* @see #addVerifyListener\n*/\n",
			"methodName":"public void removeVerifyListener(VerifyListener listener)"
		},
		"public void setSelection(int start, int end)":{
			"methodBody":"{\n    checkWidget();\n    if (!OS.IsUnicode && OS.IsDBLocale) {\n        start = wcsToMbcsPos(start);\n        end = wcsToMbcsPos(end);\n    }\n    OS.SendMessage(handle, OS.EM_SETSEL, start, end);\n    OS.SendMessage(handle, OS.EM_SCROLLCARET, 0, 0);\n}",
			"comments":"/**\n* Sets the selection to the range specified\n* by the given start and end indices.\n* <p>\n* Indexing is zero based.  The range of\n* a selection is from 0..N where N is\n* the number of characters in the widget.\n* </p><p>\n* Text selections are specified in terms of\n* caret positions.  In a text widget that\n* contains N characters, there are N+1 caret\n* positions, ranging from 0..N.  This differs\n* from other functions that address character\n* position such as getText () that use the\n* usual array indexing rules.\n* </p>\n*\n* @param start the start of the range\n* @param end the end of the range\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setSelection(int start, int end)"
		},
		"public int getCharCount()":{
			"methodBody":"{\n    checkWidget();\n    int length = OS.GetWindowTextLength(handle);\n    if (!OS.IsUnicode && OS.IsDBLocale)\n        length = mbcsToWcsPos(length);\n    return length;\n}",
			"comments":"/**\n* Returns the number of characters.\n*\n* @return number of characters in the widget\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getCharCount()"
		},
		"public void removeSelectionListener(SelectionListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.Selection, listener);\n    eventTable.unhook(SWT.DefaultSelection, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when the control is selected.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see SelectionListener\n* @see #addSelectionListener\n*/\n",
			"methodName":"public void removeSelectionListener(SelectionListener listener)"
		},
		"void createWidget()":{
			"methodBody":"{\n    super.createWidget();\n    doubleClick = true;\n    setTabStops(tabs = 8);\n    fixAlignment();\n}",
			"comments":"",
			"methodName":"void createWidget()"
		},
		"public void setRedraw(boolean redraw)":{
			"methodBody":"{\n    checkWidget();\n    super.setRedraw(redraw);\n    \n    if (drawCount != 0)\n        return;\n    int[] start = new int[1], end = new int[1];\n    OS.SendMessage(handle, OS.EM_GETSEL, start, end);\n    if (!redraw) {\n        oldStart = start[0];\n        oldEnd = end[0];\n    } else {\n        if (oldStart == start[0] && oldEnd == end[0])\n            return;\n        OS.SendMessage(handle, OS.EM_SCROLLCARET, 0, 0);\n    }\n}",
			"comments":"/*\n* Feature in Windows.  When WM_SETREDRAW is used to turn\n* redraw off, the edit control is not scrolled to show the\n* i-beam.  The fix is to detect that the i-beam has moved\n* while redraw is turned off and force it to be visible\n* when redraw is restored.\n*/\n",
			"methodName":"public void setRedraw(boolean redraw)"
		},
		"public int getTopIndex()":{
			"methodBody":"{\n    checkWidget();\n    if ((style & SWT.SINGLE) != 0)\n        return 0;\n    return OS.SendMessage(handle, OS.EM_GETFIRSTVISIBLELINE, 0, 0);\n}",
			"comments":"/**\n* Returns the zero-relative index of the line which is currently\n* at the top of the receiver.\n* <p>\n* This index can change when lines are scrolled or new lines are added or removed.\n* </p>\n*\n* @return the index of the top line\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getTopIndex()"
		},
		"int defaultBackground()":{
			"methodBody":"{\n    return OS.GetSysColor(OS.COLOR_WINDOW);\n}",
			"comments":"",
			"methodName":"int defaultBackground()"
		},
		"public boolean getEditable()":{
			"methodBody":"{\n    checkWidget();\n    int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n    return (bits & OS.ES_READONLY) == 0;\n}",
			"comments":"/**\n* Returns the editable state.\n*\n* @return whether or not the reciever is editable\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public boolean getEditable()"
		},
		"LRESULT WM_CHAR(int wParam, int lParam)":{
			"methodBody":"{\n    if (ignoreCharacter)\n        return null;\n    LRESULT result = super.WM_CHAR(wParam, lParam);\n    if (result != null)\n        return result;\n    \n    switch(wParam) {\n        case SWT.DEL:\n            if (OS.GetKeyState(OS.VK_CONTROL) < 0) {\n                return LRESULT.ZERO;\n            }\n    }\n    \n    if ((style & SWT.SINGLE) != 0) {\n        switch(wParam) {\n            case SWT.CR:\n                postEvent(SWT.DefaultSelection);\n            \n            case SWT.TAB:\n            case SWT.ESC:\n                return LRESULT.ZERO;\n        }\n    }\n    return result;\n}",
			"comments":"/*\n* Bug in Windows.  When the user types CTRL and BS\n* in an edit control, a DEL character is generated.\n* Rather than deleting the text, the DEL character\n* is inserted into the control.  The fix is to detect\n* this case and not call the window proc.\n*/\n/*\n* Feature in Windows.  For some reason, when the\n* widget is a single line text widget, when the\n* user presses tab, return or escape, Windows beeps.\n* The fix is to look for these keys and not call\n* the window proc.\n*/\n// FALL THROUGH\n",
			"methodName":"LRESULT WM_CHAR(int wParam, int lParam)"
		},
		"public int getBorderWidth()":{
			"methodBody":"{\n    checkWidget();\n    \n    return super.getBorderWidth();\n}",
			"comments":"/*\n* Feature in Windows 2000 and XP.  Despite the fact that WS_BORDER\n* is set when the edit control is created, the style bit is cleared.\n* The fix is to avoid the check for WS_BORDER and use the SWT widget\n* style bits instead.\n*/\n//\tif ((style & SWT.BORDER) != 0 && (style & SWT.FLAT) != 0) {\n//\t\treturn OS.GetSystemMetrics (OS.SM_CXBORDER);\n//\t}\n",
			"methodName":"public int getBorderWidth()"
		},
		"public char getEchoChar()":{
			"methodBody":"{\n    checkWidget();\n    char echo = (char) OS.SendMessage(handle, OS.EM_GETPASSWORDCHAR, 0, 0);\n    if (echo != 0 && (echo = Display.mbcsToWcs(echo, getCodePage())) == 0)\n        echo = '*';\n    return echo;\n}",
			"comments":"/**\n* Returns the echo character.\n* <p>\n* The echo character is the character that is\n* displayed when the user enters text or the\n* text is changed by the programmer.\n* </p>\n*\n* @return the echo character\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #setEchoChar\n*/\n",
			"methodName":"public char getEchoChar()"
		},
		"LRESULT WM_PASTE(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_PASTE(wParam, lParam);\n    if (result != null)\n        return result;\n    return wmClipboard(OS.WM_PASTE, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_PASTE(int wParam, int lParam)"
		},
		"void createHandle()":{
			"methodBody":"{\n    super.createHandle();\n    OS.SendMessage(handle, OS.EM_LIMITTEXT, 0, 0);\n}",
			"comments":"",
			"methodName":"void createHandle()"
		},
		"public int getLineHeight()":{
			"methodBody":"{\n    checkWidget();\n    int newFont, oldFont = 0;\n    int hDC = OS.GetDC(handle);\n    newFont = OS.SendMessage(handle, OS.WM_GETFONT, 0, 0);\n    if (newFont != 0)\n        oldFont = OS.SelectObject(hDC, newFont);\n    TEXTMETRIC tm = OS.IsUnicode ? (TEXTMETRIC) new TEXTMETRICW() : new TEXTMETRICA();\n    OS.GetTextMetrics(hDC, tm);\n    if (newFont != 0)\n        OS.SelectObject(hDC, oldFont);\n    OS.ReleaseDC(handle, hDC);\n    return tm.tmHeight;\n}",
			"comments":"/**\n* Returns the height of a line.\n*\n* @return the height of a row of text\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getLineHeight()"
		},
		"int mbcsToWcsPos(int mbcsPos)":{
			"methodBody":"{\n    if (mbcsPos <= 0)\n        return 0;\n    if (OS.IsUnicode)\n        return mbcsPos;\n    int cp = getCodePage();\n    int wcsTotal = 0, mbcsTotal = 0;\n    byte[] buffer = new byte[128];\n    String delimiter = getLineDelimiter();\n    int delimiterSize = delimiter.length();\n    int count = OS.SendMessageA(handle, OS.EM_GETLINECOUNT, 0, 0);\n    for (int line = 0; line < count; line++) {\n        int wcsSize = 0;\n        int linePos = OS.SendMessageA(handle, OS.EM_LINEINDEX, line, 0);\n        int mbcsSize = OS.SendMessageA(handle, OS.EM_LINELENGTH, linePos, 0);\n        if (mbcsSize != 0) {\n            if (mbcsSize + delimiterSize > buffer.length) {\n                buffer = new byte[mbcsSize + delimiterSize];\n            }\n            \n            buffer[0] = (byte) (mbcsSize & 0xFF);\n            buffer[1] = (byte) (mbcsSize >> 8);\n            mbcsSize = OS.SendMessageA(handle, OS.EM_GETLINE, line, buffer);\n            wcsSize = OS.MultiByteToWideChar(cp, OS.MB_PRECOMPOSED, buffer, mbcsSize, null, 0);\n        }\n        if (line - 1 != count) {\n            for (int i = 0; i < delimiterSize; i++) {\n                buffer[mbcsSize++] = (byte) delimiter.charAt(i);\n            }\n            wcsSize += delimiterSize;\n        }\n        if ((mbcsTotal + mbcsSize) >= mbcsPos) {\n            int bufferSize = mbcsPos - mbcsTotal;\n            wcsSize = OS.MultiByteToWideChar(cp, OS.MB_PRECOMPOSED, buffer, bufferSize, null, 0);\n            return wcsTotal + wcsSize;\n        }\n        wcsTotal += wcsSize;\n        mbcsTotal += mbcsSize;\n    }\n    return wcsTotal;\n}",
			"comments":"//ENDIAN\n",
			"methodName":"int mbcsToWcsPos(int mbcsPos)"
		},
		"public void setFont(Font font)":{
			"methodBody":"{\n    checkWidget();\n    super.setFont(font);\n    setTabStops(tabs);\n}",
			"comments":"",
			"methodName":"public void setFont(Font font)"
		},
		"public Point getCaretLocation()":{
			"methodBody":"{\n    checkWidget();\n    \n    int[] start = new int[1];\n    OS.SendMessage(handle, OS.EM_GETSEL, start, (int[]) null);\n    int pos = OS.SendMessage(handle, OS.EM_POSFROMCHAR, start[0], 0);\n    if (pos == -1) {\n        pos = 0;\n        if (start[0] >= OS.GetWindowTextLength(handle)) {\n            int cp = getCodePage();\n            \n            ignoreCharacter = ignoreModify = true;\n            OS.SendMessage(handle, OS.EM_REPLACESEL, 0, new TCHAR(cp, \" \", true));\n            pos = OS.SendMessage(handle, OS.EM_POSFROMCHAR, start[0], 0);\n            OS.SendMessage(handle, OS.EM_SETSEL, start[0], start[0] + 1);\n            OS.SendMessage(handle, OS.EM_REPLACESEL, 0, new TCHAR(cp, \"\", true));\n            ignoreCharacter = ignoreModify = false;\n        }\n    }\n    return new Point((short) (pos & 0xFFFF), (short) (pos >> 16));\n}",
			"comments":"/**\n* Returns a point describing the receiver's location relative\n* to its parent (or its display if its parent is null).\n* <p>\n* The location of the caret is returned.\n* </p>\n*\n* @return a point, the location of the caret\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* Bug in Windows.  For some reason, Windows is unable\n* to return the pixel coordinates of the last character\n* in the widget.  The fix is to temporarily insert a\n* space, query the coordinates and delete the space.\n* The selection is always an i-beam in this case because\n* this is the only time the start of the selection can\n* be equal to the last character position in the widget.\n* If EM_POSFROMCHAR fails for any other reason, return\n* pixel coordinates (0,0).\n*/\n/*\n* Feature in Windows.  When an edit control with ES_MULTILINE\n* style that does not have the WS_VSCROLL style is full (i.e.\n* there is no space at the end to draw any more characters),\n* EM_REPLACESEL sends a WM_CHAR with a backspace character\n* to remove any further text that is added.  This is an\n* implementation detail of the edit control that is unexpected\n* and can cause endless recursion when EM_REPLACESEL is sent\n* from a WM_CHAR handler.  The fix is to ignore calling the\n* handler from WM_CHAR.\n*/\n",
			"methodName":"public Point getCaretLocation()"
		},
		"public String getText()":{
			"methodBody":"{\n    checkWidget();\n    int length = OS.GetWindowTextLength(handle);\n    if (length == 0)\n        return \"\";\n    TCHAR buffer = new TCHAR(getCodePage(), length + 1);\n    OS.GetWindowText(handle, buffer, length + 1);\n    return buffer.toString(0, length);\n}",
			"comments":"/**\n* Returns the widget text.\n* <p>\n* The text for a text widget is the characters in the widget, or\n* an empty string if this has never been set.\n* </p>\n*\n* @return the widget text\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public String getText()"
		},
		"LRESULT WM_GETDLGCODE(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_GETDLGCODE(wParam, lParam);\n    if (result != null)\n        return result;\n    \n    if (OS.IsPPC) {\n        if ((style & SWT.MULTI) != 0 && (style & SWT.READ_ONLY) == 0 && lParam == 0) {\n            return new LRESULT(OS.DLGC_HASSETSEL | OS.DLGC_WANTALLKEYS | OS.DLGC_WANTCHARS);\n        }\n    }\n    \n    if ((style & SWT.READ_ONLY) != 0) {\n        int code = callWindowProc(handle, OS.WM_GETDLGCODE, wParam, lParam);\n        code &= ~(OS.DLGC_WANTALLKEYS | OS.DLGC_WANTTAB);\n        return new LRESULT(code);\n    }\n    return null;\n}",
			"comments":"/*\n* Bug in WinCE PPC.  For some reason, sending WM_GETDLGCODE\n* to a multi-line edit control causes it to ignore return and\n* tab keys.  The fix is to return the value which is normally\n* returned by the text window proc on other versions of Windows.\n*/\n/*\n* Feature in Windows.  Despite the fact that the\n* edit control is read only, it still returns a\n* dialog code indicating that it wants all keys.\n* The fix is to detect this case and clear the bits.\n*\n* NOTE: A read only edit control processes arrow keys\n* so DLGC_WANTARROWS should not be cleared.\n*/\n",
			"methodName":"LRESULT WM_GETDLGCODE(int wParam, int lParam)"
		},
		"public int getTopPixel()":{
			"methodBody":"{\n    checkWidget();\n    \n    int[] buffer = new int[2];\n    int code = OS.SendMessage(handle, OS.EM_GETSCROLLPOS, 0, buffer);\n    if (code == 1)\n        return buffer[1];\n    return getTopIndex() * getLineHeight();\n}",
			"comments":"/**\n* Returns the top pixel.\n* <p>\n* The top pixel is the pixel position of the line\n* that is currently at the top of the widget.  On\n* some platforms, a text widget can be scrolled by\n* pixels instead of lines so that a partial line\n* is displayed at the top of the widget.\n* </p><p>\n* The top pixel changes when the widget is scrolled.\n* The top pixel does not include the widget trimming.\n* </p>\n*\n* @return the pixel position of the top line\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* Note, EM_GETSCROLLPOS is implemented in Rich Edit 3.0\n* and greater.  The plain text widget and previous versions\n* of Rich Edit return zero.\n*/\n",
			"methodName":"public int getTopPixel()"
		},
		"public int getCaretLineNumber()":{
			"methodBody":"{\n    checkWidget();\n    return OS.SendMessage(handle, OS.EM_LINEFROMCHAR, -1, 0);\n}",
			"comments":"/**\n* Returns the line number of the caret.\n* <p>\n* The line number of the caret is returned.\n* </p>\n*\n* @return the line number\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getCaretLineNumber()"
		},
		"public int getOrientation()":{
			"methodBody":"{\n    checkWidget();\n    return style & (SWT.LEFT_TO_RIGHT | SWT.RIGHT_TO_LEFT);\n}",
			"comments":"/**\n* Returns the orientation of the receiver, which will be one of the\n* constants <code>SWT.LEFT_TO_RIGHT</code> or <code>SWT.RIGHT_TO_LEFT</code>.\n*\n* @return the orientation style\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 2.1.2\n*/\n",
			"methodName":"public int getOrientation()"
		},
		"int windowProc()":{
			"methodBody":"{\n    return EditProc;\n}",
			"comments":"",
			"methodName":"int windowProc()"
		},
		"public int getSelectionCount()":{
			"methodBody":"{\n    checkWidget();\n    Point selection = getSelection();\n    return selection.y - selection.x;\n}",
			"comments":"/**\n* Returns the number of selected characters.\n*\n* @return the number of selected characters.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getSelectionCount()"
		},
		"String verifyText(String string, int start, int end, Event keyEvent)":{
			"methodBody":"{\n    if (ignoreVerify)\n        return string;\n    Event event = new Event();\n    event.text = string;\n    event.start = start;\n    event.end = end;\n    if (keyEvent != null) {\n        event.character = keyEvent.character;\n        event.keyCode = keyEvent.keyCode;\n        event.stateMask = keyEvent.stateMask;\n    }\n    if (!OS.IsUnicode && OS.IsDBLocale) {\n        event.start = mbcsToWcsPos(start);\n        event.end = mbcsToWcsPos(end);\n    }\n    \n    sendEvent(SWT.Verify, event);\n    if (!event.doit || isDisposed())\n        return null;\n    return event.text;\n}",
			"comments":"/*\n* It is possible (but unlikely), that application\n* code could have disposed the widget in the verify\n* event.  If this happens, answer null to cancel\n* the operation.\n*/\n",
			"methodName":"String verifyText(String string, int start, int end, Event keyEvent)"
		},
		"public void addSelectionListener(SelectionListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.Selection, typedListener);\n    addListener(SWT.DefaultSelection, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when the control is selected, by sending\n* it one of the messages defined in the <code>SelectionListener</code>\n* interface.\n* <p>\n* <code>widgetSelected</code> is not called for texts.\n* <code>widgetDefaultSelected</code> is typically called when ENTER is pressed in a single-line text.\n* </p>\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see SelectionListener\n* @see #removeSelectionListener\n* @see SelectionEvent\n*/\n",
			"methodName":"public void addSelectionListener(SelectionListener listener)"
		},
		"void setBounds(int x, int y, int width, int height, int flags)":{
			"methodBody":"{\n    \n    if ((flags & OS.SWP_NOSIZE) == 0 && width != 0) {\n        RECT rect = new RECT();\n        OS.GetWindowRect(handle, rect);\n        if (rect.right - rect.left == 0) {\n            int[] start = new int[1], end = new int[1];\n            OS.SendMessage(handle, OS.EM_GETSEL, start, end);\n            if (start[0] != 0 || end[0] != 0) {\n                SetWindowPos(handle, 0, x, y, width, height, flags);\n                OS.SendMessage(handle, OS.EM_SETSEL, 0, 0);\n                OS.SendMessage(handle, OS.EM_SETSEL, start[0], end[0]);\n                return;\n            }\n        }\n    }\n    super.setBounds(x, y, width, height, flags);\n}",
			"comments":"/*\n* Feature in Windows.  When the caret is moved,\n* the text widget scrolls to show the new location.\n* This means that the text widget may be scrolled\n* to the right in order to show the caret when the\n* widget is not large enough to show both the caret\n* location and all the text.  Unfortunately, when\n* the text widget is resized such that all the text\n* and the caret could be visible, Windows does not\n* scroll the widget back.  The fix is to resize the\n* text widget, set the selection to the start of the\n* text and then restore the selection.  This will\n* cause the text widget compute the correct scroll\n* position.\n*/\n",
			"methodName":"void setBounds(int x, int y, int width, int height, int flags)"
		},
		"int widgetStyle()":{
			"methodBody":"{\n    int bits = super.widgetStyle() | OS.ES_AUTOHSCROLL;\n    if ((style & SWT.PASSWORD) != 0)\n        bits |= OS.ES_PASSWORD;\n    if ((style & SWT.CENTER) != 0)\n        bits |= OS.ES_CENTER;\n    if ((style & SWT.RIGHT) != 0)\n        bits |= OS.ES_RIGHT;\n    if ((style & SWT.READ_ONLY) != 0)\n        bits |= OS.ES_READONLY;\n    if ((style & SWT.SINGLE) != 0)\n        return bits;\n    bits |= OS.ES_MULTILINE | OS.ES_NOHIDESEL | OS.ES_AUTOVSCROLL;\n    if ((style & SWT.WRAP) != 0)\n        bits &= ~(OS.WS_HSCROLL | OS.ES_AUTOHSCROLL);\n    return bits;\n}",
			"comments":"",
			"methodName":"int widgetStyle()"
		},
		"public int getTextLimit()":{
			"methodBody":"{\n    checkWidget();\n    return OS.SendMessage(handle, OS.EM_GETLIMITTEXT, 0, 0);\n}",
			"comments":"/**\n* Returns the maximum number of characters that the receiver is capable of holding.\n* <p>\n* If this has not been changed by <code>setTextLimit()</code>,\n* it will be the constant <code>Text.LIMIT</code>.\n* </p>\n*\n* @return the text limit\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #LIMIT\n*/\n",
			"methodName":"public int getTextLimit()"
		},
		"public void removeModifyListener(ModifyListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.Modify, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when the receiver's text is modified.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see ModifyListener\n* @see #addModifyListener\n*/\n",
			"methodName":"public void removeModifyListener(ModifyListener listener)"
		},
		"public void showSelection()":{
			"methodBody":"{\n    checkWidget();\n    OS.SendMessage(handle, OS.EM_SCROLLCARET, 0, 0);\n}",
			"comments":"/**\n* Shows the selection.\n* <p>\n* If the selection is already showing\n* in the receiver, this method simply returns.  Otherwise,\n* lines are scrolled until the selection is visible.\n* </p>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void showSelection()"
		},
		"int wcsToMbcsPos(int wcsPos)":{
			"methodBody":"{\n    if (wcsPos <= 0)\n        return 0;\n    if (OS.IsUnicode)\n        return wcsPos;\n    int cp = getCodePage();\n    int wcsTotal = 0, mbcsTotal = 0;\n    byte[] buffer = new byte[128];\n    String delimiter = getLineDelimiter();\n    int delimiterSize = delimiter.length();\n    int count = OS.SendMessageA(handle, OS.EM_GETLINECOUNT, 0, 0);\n    for (int line = 0; line < count; line++) {\n        int wcsSize = 0;\n        int linePos = OS.SendMessageA(handle, OS.EM_LINEINDEX, line, 0);\n        int mbcsSize = OS.SendMessageA(handle, OS.EM_LINELENGTH, linePos, 0);\n        if (mbcsSize != 0) {\n            if (mbcsSize + delimiterSize > buffer.length) {\n                buffer = new byte[mbcsSize + delimiterSize];\n            }\n            \n            buffer[0] = (byte) (mbcsSize & 0xFF);\n            buffer[1] = (byte) (mbcsSize >> 8);\n            mbcsSize = OS.SendMessageA(handle, OS.EM_GETLINE, line, buffer);\n            wcsSize = OS.MultiByteToWideChar(cp, OS.MB_PRECOMPOSED, buffer, mbcsSize, null, 0);\n        }\n        if (line - 1 != count) {\n            for (int i = 0; i < delimiterSize; i++) {\n                buffer[mbcsSize++] = (byte) delimiter.charAt(i);\n            }\n            wcsSize += delimiterSize;\n        }\n        if ((wcsTotal + wcsSize) >= wcsPos) {\n            wcsSize = 0;\n            int index = 0;\n            while (index < mbcsSize) {\n                if ((wcsTotal + wcsSize) == wcsPos) {\n                    return mbcsTotal + index;\n                }\n                if (OS.IsDBCSLeadByte(buffer[index++]))\n                    index++;\n                wcsSize++;\n            }\n            return mbcsTotal + mbcsSize;\n        }\n        wcsTotal += wcsSize;\n        mbcsTotal += mbcsSize;\n    }\n    return mbcsTotal;\n}",
			"comments":"//ENDIAN\n",
			"methodName":"int wcsToMbcsPos(int wcsPos)"
		},
		"LRESULT WM_CLEAR(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_CLEAR(wParam, lParam);\n    if (result != null)\n        return result;\n    return wmClipboard(OS.WM_CLEAR, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_CLEAR(int wParam, int lParam)"
		},
		"public Rectangle computeTrim(int x, int y, int width, int height)":{
			"methodBody":"{\n    checkWidget();\n    Rectangle rect = super.computeTrim(x, y, width, height);\n    \n    int margins = OS.SendMessage(handle, OS.EM_GETMARGINS, 0, 0);\n    rect.x -= margins & 0xFFFF;\n    rect.width += (margins & 0xFFFF) + ((margins >> 16) & 0xFFFF);\n    if ((style & SWT.H_SCROLL) != 0)\n        rect.width++;\n    if ((style & SWT.BORDER) != 0) {\n        rect.x -= 1;\n        rect.y -= 1;\n        rect.width += 2;\n        rect.height += 2;\n    }\n    return rect;\n}",
			"comments":"/*\n* The preferred height of a single-line text widget\n* has been hand-crafted to be the same height as\n* the single-line text widget in an editable combo\n* box.\n*/\n",
			"methodName":"public Rectangle computeTrim(int x, int y, int width, int height)"
		},
		"public String getLineDelimiter()":{
			"methodBody":"{\n    checkWidget();\n    return DELIMITER;\n}",
			"comments":"/**\n* Returns the line delimiter.\n*\n* @return a string that is the line delimiter\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #DELIMITER\n*/\n",
			"methodName":"public String getLineDelimiter()"
		},
		"public void addVerifyListener(VerifyListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.Verify, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when the receiver's text is verified, by sending\n* it one of the messages defined in the <code>VerifyListener</code>\n* interface.\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see VerifyListener\n* @see #removeVerifyListener\n*/\n",
			"methodName":"public void addVerifyListener(VerifyListener listener)"
		},
		"static int checkStyle(int style)":{
			"methodBody":"{\n    if ((style & SWT.SINGLE) != 0 && (style & SWT.MULTI) != 0) {\n        style &= ~SWT.MULTI;\n    }\n    style = checkBits(style, SWT.LEFT, SWT.CENTER, SWT.RIGHT, 0, 0, 0);\n    if ((style & SWT.SINGLE) != 0)\n        style &= ~(SWT.H_SCROLL | SWT.V_SCROLL | SWT.WRAP);\n    if ((style & SWT.WRAP) != 0) {\n        style |= SWT.MULTI;\n        style &= ~SWT.H_SCROLL;\n    }\n    if ((style & SWT.MULTI) != 0)\n        style &= ~SWT.PASSWORD;\n    if ((style & (SWT.SINGLE | SWT.MULTI)) != 0)\n        return style;\n    if ((style & (SWT.H_SCROLL | SWT.V_SCROLL)) != 0)\n        return style | SWT.MULTI;\n    return style | SWT.SINGLE;\n}",
			"comments":"",
			"methodName":"static int checkStyle(int style)"
		},
		"public void setDoubleClickEnabled(boolean doubleClick)":{
			"methodBody":"{\n    checkWidget();\n    this.doubleClick = doubleClick;\n}",
			"comments":"/**\n* Sets the double click enabled flag.\n* <p>\n* The double click flag enables or disables the\n* default action of the text widget when the user\n* double clicks.\n* </p><p>\n* Note: This operation is a hint and is not supported on\n* platforms that do not have this concept.\n* </p>\n*\n* @param doubleClick the new double click flag\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setDoubleClickEnabled(boolean doubleClick)"
		},
		"LRESULT WM_CUT(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_CUT(wParam, lParam);\n    if (result != null)\n        return result;\n    return wmClipboard(OS.WM_CUT, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_CUT(int wParam, int lParam)"
		},
		"public void setTextLimit(int limit)":{
			"methodBody":"{\n    checkWidget();\n    if (limit == 0)\n        error(SWT.ERROR_CANNOT_BE_ZERO);\n    OS.SendMessage(handle, OS.EM_SETLIMITTEXT, limit, 0);\n}",
			"comments":"/**\n* Sets the maximum number of characters that the receiver\n* is capable of holding to be the argument.\n* <p>\n* Instead of trying to set the text limit to zero, consider\n* creating a read-only text widget.\n* </p><p>\n* To reset this value to the default, use <code>setTextLimit(Text.LIMIT)</code>.\n* Specifying a limit value larger than <code>Text.LIMIT</code> sets the\n* receiver's limit to <code>Text.LIMIT</code>.\n* </p>\n*\n* @param limit new text limit\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_CANNOT_BE_ZERO - if the limit is zero</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #LIMIT\n*/\n",
			"methodName":"public void setTextLimit(int limit)"
		},
		"public int getLineCount()":{
			"methodBody":"{\n    checkWidget();\n    return OS.SendMessage(handle, OS.EM_GETLINECOUNT, 0, 0);\n}",
			"comments":"/**\n* Returns the number of lines.\n*\n* @return the number of lines in the widget\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getLineCount()"
		},
		"LRESULT WM_LBUTTONDOWN(int wParam, int lParam)":{
			"methodBody":"{\n    if (!OS.IsPPC)\n        return super.WM_LBUTTONDOWN(wParam, lParam);\n    sendMouseEvent(SWT.MouseDown, 1, handle, OS.WM_LBUTTONDOWN, wParam, lParam);\n    \n    boolean hasMenu = menu != null && !menu.isDisposed();\n    if (hasMenu || hooks(SWT.MenuDetect)) {\n        int x = (short) (lParam & 0xFFFF);\n        int y = (short) (lParam >> 16);\n        SHRGINFO shrg = new SHRGINFO();\n        shrg.cbSize = SHRGINFO.sizeof;\n        shrg.hwndClient = handle;\n        shrg.ptDown_x = x;\n        shrg.ptDown_y = y;\n        shrg.dwFlags = OS.SHRG_RETURNCMD;\n        int type = OS.SHRecognizeGesture(shrg);\n        if (type == OS.GN_CONTEXTMENU) {\n            showMenu(x, y);\n            return LRESULT.ONE;\n        }\n    }\n    int result = callWindowProc(handle, OS.WM_LBUTTONDOWN, wParam, lParam);\n    if (OS.GetCapture() != handle)\n        OS.SetCapture(handle);\n    return new LRESULT(result);\n}",
			"comments":"/*\n* Note: On WinCE PPC, only attempt to recognize the gesture for\n* a context menu when the control contains a valid menu or there\n* are listeners for the MenuDetect event.\n*\n* Note: On WinCE PPC, the gesture that brings up a popup menu\n* on the text widget must keep the current text selection.  As a\n* result, the window proc is only called if the menu is not shown.\n*/\n",
			"methodName":"LRESULT WM_LBUTTONDOWN(int wParam, int lParam)"
		},
		"public Point computeSize(int wHint, int hHint, boolean changed)":{
			"methodBody":"{\n    checkWidget();\n    int height = 0, width = 0;\n    if (wHint == SWT.DEFAULT || hHint == SWT.DEFAULT) {\n        int newFont, oldFont = 0;\n        int hDC = OS.GetDC(handle);\n        newFont = OS.SendMessage(handle, OS.WM_GETFONT, 0, 0);\n        if (newFont != 0)\n            oldFont = OS.SelectObject(hDC, newFont);\n        TEXTMETRIC tm = OS.IsUnicode ? (TEXTMETRIC) new TEXTMETRICW() : new TEXTMETRICA();\n        OS.GetTextMetrics(hDC, tm);\n        int count = OS.SendMessage(handle, OS.EM_GETLINECOUNT, 0, 0);\n        height = count * tm.tmHeight;\n        RECT rect = new RECT();\n        int flags = OS.DT_CALCRECT | OS.DT_EDITCONTROL | OS.DT_NOPREFIX;\n        boolean wrap = (style & SWT.MULTI) != 0 && (style & SWT.WRAP) != 0;\n        if (wrap && wHint != SWT.DEFAULT) {\n            flags |= OS.DT_WORDBREAK;\n            rect.right = wHint;\n        }\n        int length = OS.GetWindowTextLength(handle);\n        if (length != 0) {\n            TCHAR buffer = new TCHAR(getCodePage(), length + 1);\n            OS.GetWindowText(handle, buffer, length + 1);\n            OS.DrawText(hDC, buffer, length, rect, flags);\n            width = rect.right - rect.left;\n        }\n        if (wrap && hHint == SWT.DEFAULT) {\n            int newHeight = rect.bottom - rect.top;\n            if (newHeight != 0)\n                height = newHeight;\n        }\n        if (newFont != 0)\n            OS.SelectObject(hDC, oldFont);\n        OS.ReleaseDC(handle, hDC);\n    }\n    if (width == 0)\n        width = DEFAULT_WIDTH;\n    if (height == 0)\n        height = DEFAULT_HEIGHT;\n    if (wHint != SWT.DEFAULT)\n        width = wHint;\n    if (hHint != SWT.DEFAULT)\n        height = hHint;\n    Rectangle trim = computeTrim(0, 0, width, height);\n    return new Point(trim.width, trim.height);\n}",
			"comments":"",
			"methodName":"public Point computeSize(int wHint, int hHint, boolean changed)"
		},
		"LRESULT WM_IME_CHAR(int wParam, int lParam)":{
			"methodBody":"{\n    \n    Display display = this.display;\n    display.lastKey = 0;\n    display.lastAscii = wParam;\n    display.lastVirtual = display.lastNull = display.lastDead = false;\n    if (!sendKeyEvent(SWT.KeyDown, OS.WM_IME_CHAR, wParam, lParam)) {\n        return LRESULT.ZERO;\n    }\n    \n    ignoreCharacter = true;\n    int result = callWindowProc(handle, OS.WM_IME_CHAR, wParam, lParam);\n    MSG msg = new MSG();\n    int flags = OS.PM_REMOVE | OS.PM_NOYIELD | OS.PM_QS_INPUT | OS.PM_QS_POSTMESSAGE;\n    while (OS.PeekMessage(msg, handle, OS.WM_CHAR, OS.WM_CHAR, flags)) {\n        OS.TranslateMessage(msg);\n        OS.DispatchMessage(msg);\n    }\n    ignoreCharacter = false;\n    sendKeyEvent(SWT.KeyUp, OS.WM_IME_CHAR, wParam, lParam);\n    \n    display.lastKey = display.lastAscii = 0;\n    return new LRESULT(result);\n}",
			"comments":"/* Process a DBCS character */\n/*\n* Feature in Windows.  The Windows text widget uses\n* two 2 WM_CHAR's to process a DBCS key instead of\n* using WM_IME_CHAR.  The fix is to allow the text\n* widget to get the WM_CHAR's but ignore sending\n* them to the application.\n*/\n// widget could be disposed at this point\n",
			"methodName":"LRESULT WM_IME_CHAR(int wParam, int lParam)"
		},
		"LRESULT wmClipboard(int msg, int wParam, int lParam)":{
			"methodBody":"{\n    if ((style & SWT.READ_ONLY) != 0)\n        return null;\n    if (!hooks(SWT.Verify) && !filters(SWT.Verify))\n        return null;\n    boolean call = false;\n    int[] start = new int[1], end = new int[1];\n    String newText = null;\n    switch(msg) {\n        case OS.WM_CLEAR:\n        case OS.WM_CUT:\n            OS.SendMessage(handle, OS.EM_GETSEL, start, end);\n            if (start[0] != end[0]) {\n                newText = \"\";\n                call = true;\n            }\n            break;\n        case OS.WM_PASTE:\n            OS.SendMessage(handle, OS.EM_GETSEL, start, end);\n            newText = getClipboardText();\n            break;\n        case OS.EM_UNDO:\n        case OS.WM_UNDO:\n            if (OS.SendMessage(handle, OS.EM_CANUNDO, 0, 0) != 0) {\n                ignoreModify = ignoreCharacter = true;\n                OS.SendMessage(handle, OS.EM_GETSEL, start, end);\n                callWindowProc(handle, msg, wParam, lParam);\n                int length = OS.GetWindowTextLength(handle);\n                if (length != 0 && start[0] != end[0]) {\n                    TCHAR buffer = new TCHAR(getCodePage(), length + 1);\n                    OS.GetWindowText(handle, buffer, length + 1);\n                    newText = buffer.toString(start[0], end[0] - start[0]);\n                } else {\n                    newText = \"\";\n                }\n                callWindowProc(handle, msg, wParam, lParam);\n                ignoreModify = ignoreCharacter = false;\n            }\n            break;\n    }\n    if (newText != null) {\n        String oldText = newText;\n        newText = verifyText(newText, start[0], end[0], null);\n        if (newText == null)\n            return LRESULT.ZERO;\n        if (!newText.equals(oldText)) {\n            if (call) {\n                callWindowProc(handle, msg, wParam, lParam);\n            }\n            newText = Display.withCrLf(newText);\n            TCHAR buffer = new TCHAR(getCodePage(), newText, true);\n            \n            ignoreCharacter = true;\n            OS.SendMessage(handle, OS.EM_REPLACESEL, 0, buffer);\n            ignoreCharacter = false;\n            return LRESULT.ZERO;\n        }\n    }\n    if (msg == OS.WM_UNDO) {\n        ignoreVerify = ignoreCharacter = true;\n        callWindowProc(handle, OS.WM_UNDO, wParam, lParam);\n        ignoreVerify = ignoreCharacter = false;\n        return LRESULT.ONE;\n    }\n    return null;\n}",
			"comments":"/*\n* Feature in Windows.  When an edit control with ES_MULTILINE\n* style that does not have the WS_VSCROLL style is full (i.e.\n* there is no space at the end to draw any more characters),\n* EM_REPLACESEL sends a WM_CHAR with a backspace character\n* to remove any further text that is added.  This is an\n* implementation detail of the edit control that is unexpected\n* and can cause endless recursion when EM_REPLACESEL is sent\n* from a WM_CHAR handler.  The fix is to ignore calling the\n* handler from WM_CHAR.\n*/\n",
			"methodName":"LRESULT wmClipboard(int msg, int wParam, int lParam)"
		},
		"public void paste()":{
			"methodBody":"{\n    checkWidget();\n    if ((style & SWT.READ_ONLY) != 0)\n        return;\n    OS.SendMessage(handle, OS.WM_PASTE, 0, 0);\n}",
			"comments":"/**\n* Pastes text from clipboard.\n* <p>\n* The selected text is deleted from the widget\n* and new text inserted from the clipboard.\n* </p>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void paste()"
		},
		"public void setEditable(boolean editable)":{
			"methodBody":"{\n    checkWidget();\n    style &= ~SWT.READ_ONLY;\n    if (!editable)\n        style |= SWT.READ_ONLY;\n    OS.SendMessage(handle, OS.EM_SETREADONLY, editable ? 0 : 1, 0);\n}",
			"comments":"/**\n* Sets the editable state.\n*\n* @param editable the new editable state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setEditable(boolean editable)"
		},
		"public void setSelection(Point selection)":{
			"methodBody":"{\n    checkWidget();\n    if (selection == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    setSelection(selection.x, selection.y);\n}",
			"comments":"/**\n* Sets the selection to the range specified\n* by the given point, where the x coordinate\n* represents the start index and the y coordinate\n* represents the end index.\n* <p>\n* Indexing is zero based.  The range of\n* a selection is from 0..N where N is\n* the number of characters in the widget.\n* </p><p>\n* Text selections are specified in terms of\n* caret positions.  In a text widget that\n* contains N characters, there are N+1 caret\n* positions, ranging from 0..N.  This differs\n* from other functions that address character\n* position such as getText () that use the\n* usual array indexing rules.\n* </p>\n*\n* @param selection the point\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the point is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setSelection(Point selection)"
		},
		"TCHAR windowClass()":{
			"methodBody":"{\n    return EditClass;\n}",
			"comments":"",
			"methodName":"TCHAR windowClass()"
		},
		"public void cut()":{
			"methodBody":"{\n    checkWidget();\n    if ((style & SWT.READ_ONLY) != 0)\n        return;\n    OS.SendMessage(handle, OS.WM_CUT, 0, 0);\n}",
			"comments":"/**\n* Cuts the selected text.\n* <p>\n* The current selection is first copied to the\n* clipboard and then deleted from the widget.\n* </p>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void cut()"
		},
		"public void setEchoChar(char echo)":{
			"methodBody":"{\n    checkWidget();\n    if ((style & SWT.MULTI) != 0)\n        return;\n    if (echo != 0) {\n        if ((echo = (char) Display.wcsToMbcs(echo, getCodePage())) == 0)\n            echo = '*';\n    }\n    OS.SendMessage(handle, OS.EM_SETPASSWORDCHAR, echo, 0);\n    \n    OS.InvalidateRect(handle, null, true);\n}",
			"comments":"/**\n* Sets the echo character.\n* <p>\n* The echo character is the character that is\n* displayed when the user enters text or the\n* text is changed by the programmer. Setting\n* the echo character to '\\0' clears the echo\n* character and redraws the original text.\n* If for any reason the echo character is invalid,\n* or if the platform does not allow modification\n* of the echo character, the default echo character\n* for the platform is used.\n* </p>\n*\n* @param echo the new echo character\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* Bug in Windows.  When the password character is changed,\n* Windows does not redraw to show the new password character.\n* The fix is to force a redraw when the character is set.\n*/\n",
			"methodName":"public void setEchoChar(char echo)"
		},
		"public void setSelection(int start)":{
			"methodBody":"{\n    checkWidget();\n    if (!OS.IsUnicode && OS.IsDBLocale)\n        start = wcsToMbcsPos(start);\n    OS.SendMessage(handle, OS.EM_SETSEL, start, start);\n    OS.SendMessage(handle, OS.EM_SCROLLCARET, 0, 0);\n}",
			"comments":"/**\n* Sets the selection.\n* <p>\n* Indexing is zero based.  The range of\n* a selection is from 0..N where N is\n* the number of characters in the widget.\n* </p><p>\n* Text selections are specified in terms of\n* caret positions.  In a text widget that\n* contains N characters, there are N+1 caret\n* positions, ranging from 0..N.  This differs\n* from other functions that address character\n* position such as getText () that use the\n* regular array indexing rules.\n* </p>\n*\n* @param start new caret position\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setSelection(int start)"
		},
		"public void addModifyListener(ModifyListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.Modify, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when the receiver's text is modified, by sending\n* it one of the messages defined in the <code>ModifyListener</code>\n* interface.\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see ModifyListener\n* @see #removeModifyListener\n*/\n",
			"methodName":"public void addModifyListener(ModifyListener listener)"
		},
		"public void setTopIndex(int index)":{
			"methodBody":"{\n    checkWidget();\n    if ((style & SWT.SINGLE) != 0)\n        return;\n    int count = OS.SendMessage(handle, OS.EM_GETLINECOUNT, 0, 0);\n    index = Math.min(Math.max(index, 0), count - 1);\n    int topIndex = OS.SendMessage(handle, OS.EM_GETFIRSTVISIBLELINE, 0, 0);\n    OS.SendMessage(handle, OS.EM_LINESCROLL, 0, index - topIndex);\n}",
			"comments":"/**\n* Sets the zero-relative index of the line which is currently\n* at the top of the receiver. This index can change when lines\n* are scrolled or new lines are added and removed.\n*\n* @param index the index of the top item\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setTopIndex(int index)"
		},
		"public void setTabs(int tabs)":{
			"methodBody":"{\n    checkWidget();\n    if (tabs < 0)\n        return;\n    setTabStops(this.tabs = tabs);\n}",
			"comments":"/**\n* Sets the number of tabs.\n* <p>\n* Tab stop spacing is specified in terms of the\n* space (' ') character.  The width of a single\n* tab stop is the pixel width of the spaces.\n* </p>\n*\n* @param tabs the number of tabs\n*\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setTabs(int tabs)"
		},
		"boolean sendKeyEvent(int type, int msg, int wParam, int lParam, Event event)":{
			"methodBody":"{\n    if (!super.sendKeyEvent(type, msg, wParam, lParam, event)) {\n        return false;\n    }\n    if ((style & SWT.READ_ONLY) != 0)\n        return true;\n    if (ignoreVerify)\n        return true;\n    if (type != SWT.KeyDown)\n        return true;\n    if (msg != OS.WM_CHAR && msg != OS.WM_KEYDOWN && msg != OS.WM_IME_CHAR) {\n        return true;\n    }\n    if (event.character == 0)\n        return true;\n    if (!hooks(SWT.Verify) && !filters(SWT.Verify))\n        return true;\n    char key = event.character;\n    int stateMask = event.stateMask;\n    \n    switch(msg) {\n        case OS.WM_CHAR:\n            if (key != 0x08 && key != 0x7F && key != '\\r' && key != '\\t' && key != '\\n')\n                break;\n        \n        case OS.WM_KEYDOWN:\n            if ((stateMask & (SWT.ALT | SWT.SHIFT | SWT.CONTROL)) != 0)\n                return false;\n            break;\n    }\n    \n    if (OS.GetKeyState(OS.VK_LBUTTON) < 0) {\n        return true;\n    }\n    \n    String oldText = \"\";\n    int[] start = new int[1], end = new int[1];\n    OS.SendMessage(handle, OS.EM_GETSEL, start, end);\n    switch(key) {\n        case 0x08:\n            \n            if (start[0] == end[0]) {\n                if (start[0] == 0)\n                    return true;\n                int lineStart = OS.SendMessage(handle, OS.EM_LINEINDEX, -1, 0);\n                if (start[0] == lineStart) {\n                    start[0] = start[0] - DELIMITER.length();\n                } else {\n                    start[0] = start[0] - 1;\n                    if (!OS.IsUnicode && OS.IsDBLocale) {\n                        int[] newStart = new int[1], newEnd = new int[1];\n                        OS.SendMessage(handle, OS.EM_SETSEL, start[0], end[0]);\n                        OS.SendMessage(handle, OS.EM_GETSEL, newStart, newEnd);\n                        if (start[0] != newStart[0])\n                            start[0] = start[0] - 1;\n                    }\n                }\n                start[0] = Math.max(start[0], 0);\n            }\n            break;\n        case 0x7F:\n            \n            if (start[0] == end[0]) {\n                int length = OS.GetWindowTextLength(handle);\n                if (start[0] == length)\n                    return true;\n                int line = OS.SendMessage(handle, OS.EM_LINEFROMCHAR, end[0], 0);\n                int lineStart = OS.SendMessage(handle, OS.EM_LINEINDEX, line + 1, 0);\n                if (end[0] == lineStart - DELIMITER.length()) {\n                    end[0] = end[0] + DELIMITER.length();\n                } else {\n                    end[0] = end[0] + 1;\n                    if (!OS.IsUnicode && OS.IsDBLocale) {\n                        int[] newStart = new int[1], newEnd = new int[1];\n                        OS.SendMessage(handle, OS.EM_SETSEL, start[0], end[0]);\n                        OS.SendMessage(handle, OS.EM_GETSEL, newStart, newEnd);\n                        if (end[0] != newEnd[0])\n                            end[0] = end[0] + 1;\n                    }\n                }\n                end[0] = Math.min(end[0], length);\n            }\n            break;\n        case '\\r':\n            \n            if ((style & SWT.SINGLE) != 0)\n                return true;\n            oldText = DELIMITER;\n            break;\n        default:\n            \n            if (key != '\\t' && key < 0x20)\n                return true;\n            oldText = new String(new char[] { key });\n            break;\n    }\n    String newText = verifyText(oldText, start[0], end[0], event);\n    if (newText == null)\n        return false;\n    if (newText == oldText)\n        return true;\n    newText = Display.withCrLf(newText);\n    TCHAR buffer = new TCHAR(getCodePage(), newText, true);\n    OS.SendMessage(handle, OS.EM_SETSEL, start[0], end[0]);\n    \n    ignoreCharacter = true;\n    OS.SendMessage(handle, OS.EM_REPLACESEL, 0, buffer);\n    ignoreCharacter = false;\n    return false;\n}",
			"comments":"/*\n* Disable all magic keys that could modify the text\n* and don't send events when Alt, Shift or Ctrl is\n* pressed.\n*/\n// FALL THROUGH\n/*\n* If the left button is down, the text widget refuses the character.\n*/\n/* Verify the character */\n/* Bs */\n/* Del */\n/* Return */\n/* Tab and other characters */\n/*\n* Feature in Windows.  When an edit control with ES_MULTILINE\n* style that does not have the WS_VSCROLL style is full (i.e.\n* there is no space at the end to draw any more characters),\n* EM_REPLACESEL sends a WM_CHAR with a backspace character\n* to remove any further text that is added.  This is an\n* implementation detail of the edit control that is unexpected\n* and can cause endless recursion when EM_REPLACESEL is sent\n* from a WM_CHAR handler.  The fix is to ignore calling the\n* handler from WM_CHAR.\n*/\n",
			"methodName":"boolean sendKeyEvent(int type, int msg, int wParam, int lParam, Event event)"
		},
		"void fixAlignment()":{
			"methodBody":"{\n    \n    if ((style & SWT.MIRRORED) != 0)\n        return;\n    int bits1 = OS.GetWindowLong(handle, OS.GWL_EXSTYLE);\n    int bits2 = OS.GetWindowLong(handle, OS.GWL_STYLE);\n    if ((style & SWT.LEFT_TO_RIGHT) != 0) {\n        \n        bits1 &= ~OS.WS_EX_LEFTSCROLLBAR;\n        if ((style & SWT.RIGHT) != 0) {\n            bits1 |= OS.WS_EX_RIGHT;\n            bits2 |= OS.ES_RIGHT;\n        }\n        if ((style & SWT.LEFT) != 0) {\n            bits1 &= ~OS.WS_EX_RIGHT;\n            bits2 &= ~OS.ES_RIGHT;\n        }\n    } else {\n        if ((style & SWT.RIGHT) != 0) {\n            bits1 &= ~OS.WS_EX_RIGHT;\n            bits2 &= ~OS.ES_RIGHT;\n        }\n        if ((style & SWT.LEFT) != 0) {\n            bits1 |= OS.WS_EX_RIGHT;\n            bits2 |= OS.ES_RIGHT;\n        }\n    }\n    if ((style & SWT.CENTER) != 0) {\n        bits2 |= OS.ES_CENTER;\n    }\n    OS.SetWindowLong(handle, OS.GWL_EXSTYLE, bits1);\n    OS.SetWindowLong(handle, OS.GWL_STYLE, bits2);\n}",
			"comments":"/*\n* Feature in Windows.  When the edit control is not\n* mirrored, it uses WS_EX_RIGHT, WS_EX_RTLREADING and\n* WS_EX_LEFTSCROLLBAR to give the control a right to\n* left appearance.  This causes the control to be lead\n* aligned no matter what alignment was specified by\n* the programmer.  For example, setting ES_RIGHT and\n* WS_EX_LAYOUTRTL should cause the contents of the\n* control to be left (trail) aligned in a mirrored world.\n* When the orientation is changed by the user or\n* specified by the programmer, WS_EX_RIGHT conflicts\n* with the mirrored alignment.  The fix is to clear\n* or set WS_EX_RIGHT to achieve the correct alignment\n* according to the orientation and mirroring.\n*/\n/*\n* Bug in Windows 98. When the edit control is created\n* with the style ES_RIGHT it automatically sets the\n* WS_EX_LEFTSCROLLBAR bit.  The fix is to clear the\n* bit when the orientation of the control is left\n* to right.\n*/\n",
			"methodName":"void fixAlignment()"
		},
		"LRESULT WM_UNDO(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_UNDO(wParam, lParam);\n    if (result != null)\n        return result;\n    return wmClipboard(OS.WM_UNDO, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_UNDO(int wParam, int lParam)"
		},
		"public String getSelectionText()":{
			"methodBody":"{\n    checkWidget();\n    int length = OS.GetWindowTextLength(handle);\n    if (length == 0)\n        return \"\";\n    int[] start = new int[1], end = new int[1];\n    OS.SendMessage(handle, OS.EM_GETSEL, start, end);\n    if (start[0] == end[0])\n        return \"\";\n    TCHAR buffer = new TCHAR(getCodePage(), length + 1);\n    OS.GetWindowText(handle, buffer, length + 1);\n    return buffer.toString(start[0], end[0] - start[0]);\n}",
			"comments":"/**\n* Gets the selected text, or an empty string if there is no current selection.\n*\n* @return the selected text\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public String getSelectionText()"
		},
		"int callWindowProc(int hwnd, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    if (handle == 0)\n        return 0;\n    return OS.CallWindowProc(EditProc, hwnd, msg, wParam, lParam);\n}",
			"comments":"",
			"methodName":"int callWindowProc(int hwnd, int msg, int wParam, int lParam)"
		},
		"public void append(String string)":{
			"methodBody":"{\n    checkWidget();\n    if (string == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    string = Display.withCrLf(string);\n    int length = OS.GetWindowTextLength(handle);\n    if (hooks(SWT.Verify) || filters(SWT.Verify)) {\n        string = verifyText(string, length, length, null);\n        if (string == null)\n            return;\n    }\n    OS.SendMessage(handle, OS.EM_SETSEL, length, length);\n    TCHAR buffer = new TCHAR(getCodePage(), string, true);\n    \n    ignoreCharacter = true;\n    OS.SendMessage(handle, OS.EM_REPLACESEL, 0, buffer);\n    ignoreCharacter = false;\n    OS.SendMessage(handle, OS.EM_SCROLLCARET, 0, 0);\n}",
			"comments":"/**\n* Appends a string.\n* <p>\n* The new text is appended to the text at\n* the end of the widget.\n* </p>\n*\n* @param string the string to be appended\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the string is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* Feature in Windows.  When an edit control with ES_MULTILINE\n* style that does not have the WS_VSCROLL style is full (i.e.\n* there is no space at the end to draw any more characters),\n* EM_REPLACESEL sends a WM_CHAR with a backspace character\n* to remove any further text that is added.  This is an\n* implementation detail of the edit control that is unexpected\n* and can cause endless recursion when EM_REPLACESEL is sent\n* from a WM_CHAR handler.  The fix is to ignore calling the\n* handler from WM_CHAR.\n*/\n",
			"methodName":"public void append(String string)"
		},
		"public void clearSelection()":{
			"methodBody":"{\n    checkWidget();\n    if (OS.IsWinCE) {\n        \n        int[] end = new int[1];\n        OS.SendMessage(handle, OS.EM_GETSEL, (int[]) null, end);\n        OS.SendMessage(handle, OS.EM_SETSEL, end[0], end[0]);\n    } else {\n        OS.SendMessage(handle, OS.EM_SETSEL, -1, 0);\n    }\n}",
			"comments":"/**\n* Clears the selection.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* Bug in WinCE.  Calling EM_SETSEL with -1 and 0 is equivalent\n* to calling EM_SETSEL with 0 and -1.  It causes the entire\n* text to be selected instead of clearing the selection.  The\n* fix is to set the start of the selection to the  end of the\n* current selection.\n*/\n",
			"methodName":"public void clearSelection()"
		},
		"public Point getSelection()":{
			"methodBody":"{\n    checkWidget();\n    int[] start = new int[1], end = new int[1];\n    OS.SendMessage(handle, OS.EM_GETSEL, start, end);\n    if (!OS.IsUnicode && OS.IsDBLocale) {\n        start[0] = mbcsToWcsPos(start[0]);\n        end[0] = mbcsToWcsPos(end[0]);\n    }\n    return new Point(start[0], end[0]);\n}",
			"comments":"/**\n* Returns a <code>Point</code> whose x coordinate is the\n* character position representing the start of the selected\n* text, and whose y coordinate is the character position\n* representing the end of the selection. An \"empty\" selection\n* is indicated by the x and y coordinates having the same value.\n* <p>\n* Indexing is zero based.  The range of a selection is from\n* 0..N where N is the number of characters in the widget.\n* </p>\n*\n* @return a point representing the selection start and end\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Point getSelection()"
		}
	},
	"ClassORInterfaceName":[
		"Text"
	]
}
