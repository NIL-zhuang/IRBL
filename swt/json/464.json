{
	"variables":[
		"activeMenu",
		"hIMC",
		"hwndMDIClient",
		"toolTipHandle",
		"lpstrTip",
		"minWidth",
		"minHeight",
		"brushes",
		"showWithParent",
		"lastActive",
		"psai",
		"region",
		"DialogProc",
		"DialogClass",
		"lpWndClass",
		"mask",
		"bits",
		"typedListener",
		"trim",
		"embedded",
		"bits",
		"flags",
		"logBrush",
		"i",
		"hBrush",
		"length",
		"hBrush",
		"rect",
		"width",
		"height",
		"hIMC",
		"lpfdwConversion",
		"lpfdwSentence",
		"open",
		"result",
		"rect",
		"width",
		"trim",
		"height",
		"rect",
		"bits1",
		"bits2",
		"rect",
		"width",
		"height",
		"count",
		"shells",
		"i",
		"shell",
		"index",
		"result",
		"i",
		"shell",
		"widgetStyle",
		"msg",
		"flags",
		"shells",
		"i",
		"shell",
		"hHeap",
		"i",
		"hBrush",
		"hDC",
		"hOld",
		"result",
		"activate",
		"deactivate",
		"index",
		"length",
		"i",
		"i",
		"imeOn",
		"hIMC",
		"lpfdwConversion",
		"lpfdwSentence",
		"newBits",
		"oldBits",
		"widthLimit",
		"heightLimit",
		"trim",
		"rect",
		"bits1",
		"bits2",
		"size",
		"newWidth",
		"newHeight",
		"hMenu",
		"flags",
		"hRegion",
		"lpti",
		"hHeap",
		"byteCount",
		"hHeap",
		"byteCount",
		"mask",
		"control",
		"hwndShell",
		"bits",
		"trim",
		"trim",
		"trim",
		"bits",
		"fActive",
		"hwnd",
		"bVk",
		"result",
		"loWord",
		"hwndCB",
		"hwndChild",
		"result",
		"bits",
		"result",
		"result",
		"info",
		"result",
		"hittest",
		"control",
		"decorations",
		"pt",
		"pos",
		"hwnd",
		"control",
		"bits",
		"hittest",
		"hittest",
		"result",
		"display",
		"hwndActive",
		"fixActive",
		"code",
		"focusControl",
		"hPalette",
		"hPalette",
		"msg",
		"modalShell",
		"hwndModal",
		"hwndPopup",
		"hitTest",
		"control",
		"pt",
		"rect",
		"result",
		"pSipInfo",
		"result",
		"control",
		"shell",
		"result",
		"cmd",
		"memory",
		"result",
		"lpwp",
		"trim",
		"rect",
		"bits1",
		"bits2",
		"SWT",
		"SWT",
		"OS",
		"OS",
		"DialogClass",
		"lpWndClass",
		"DialogProc",
		"lpWndClass",
		"style",
		"display",
		"OS",
		"SWT",
		"SWT",
		"display",
		"style",
		"display",
		"display",
		"Display",
		"display",
		"display",
		"Display",
		"display",
		"SWT",
		"parent",
		"parent",
		"SWT",
		"style",
		"parent",
		"display",
		"handle",
		"parent",
		"OS",
		"SWT",
		"SWT",
		"parent",
		"parent",
		"parent",
		"style",
		"display",
		"SWT",
		"handle",
		"style",
		"Decorations",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"mask",
		"style",
		"SWT",
		"bits",
		"SWT",
		"style",
		"SWT",
		"bits",
		"SWT",
		"style",
		"SWT",
		"bits",
		"SWT",
		"bits",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"SWT",
		"typedListener",
		"SWT",
		"typedListener",
		"SWT",
		"typedListener",
		"SWT",
		"typedListener",
		"handle",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"trim",
		"OS",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"parent",
		"msg",
		"OS",
		"OS",
		"OS",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"OS",
		"DialogProc",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"hwndMDIClient",
		"OS",
		"hwnd",
		"hwndMDIClient",
		"msg",
		"wParam",
		"lParam",
		"OS",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"handle",
		"embedded",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"OS",
		"OS",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"bits",
		"OS",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"handle",
		"flags",
		"OS",
		"OS",
		"psai",
		"psai",
		"SHACTIVATEINFO",
		"OS",
		"hIMC",
		"OS",
		"hIMC",
		"OS",
		"handle",
		"hIMC",
		"enabled",
		"state",
		"DISABLED",
		"state",
		"DISABLED",
		"Display",
		"OS",
		"enabled",
		"OS",
		"handle",
		"enabled",
		"pixel",
		"OS",
		"OS",
		"OS",
		"OS",
		"pixel",
		"OS",
		"OS",
		"OS",
		"OS",
		"brushes",
		"brushes",
		"i",
		"brushes",
		"i",
		"brushes",
		"i",
		"hBrush",
		"OS",
		"hBrush",
		"LOGBRUSH",
		"logBrush",
		"logBrush",
		"pixel",
		"hBrush",
		"brushes",
		"brushes",
		"length",
		"hBrush",
		"OS",
		"hBrush",
		"System",
		"brushes",
		"brushes",
		"length",
		"brushes",
		"hBrush",
		"OS",
		"pixel",
		"hBrush",
		"cursor",
		"newShell",
		"control",
		"lastActive",
		"toolTipHandle",
		"control",
		"newShell",
		"control",
		"control",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"handle",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"width",
		"height",
		"state",
		"DISABLED",
		"OS",
		"OS",
		"handle",
		"OS",
		"hIMC",
		"open",
		"open",
		"OS",
		"hIMC",
		"lpfdwConversion",
		"lpfdwSentence",
		"OS",
		"handle",
		"hIMC",
		"open",
		"SWT",
		"lpfdwConversion",
		"OS",
		"result",
		"SWT",
		"lpfdwConversion",
		"OS",
		"result",
		"SWT",
		"lpfdwConversion",
		"OS",
		"result",
		"SWT",
		"lpfdwConversion",
		"OS",
		"result",
		"SWT",
		"result",
		"SWT",
		"OS",
		"OS",
		"handle",
		"OS",
		"handle",
		"rect",
		"rect",
		"rect",
		"Math",
		"minWidth",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"style",
		"trim",
		"width",
		"Math",
		"width",
		"OS",
		"OS",
		"Math",
		"minHeight",
		"style",
		"SWT",
		"style",
		"trim",
		"style",
		"SWT",
		"height",
		"Math",
		"height",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"rect",
		"bits1",
		"bits2",
		"height",
		"Math",
		"height",
		"rect",
		"rect",
		"width",
		"height",
		"region",
		"OS",
		"OS",
		"handle",
		"OS",
		"handle",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"width",
		"height",
		"display",
		"i",
		"shells",
		"i",
		"shells",
		"i",
		"shell",
		"shell",
		"shell",
		"shell",
		"shell",
		"count",
		"count",
		"i",
		"shells",
		"i",
		"shells",
		"i",
		"shell",
		"shell",
		"shell",
		"shell",
		"shell",
		"result",
		"index",
		"shells",
		"i",
		"result",
		"layoutCount",
		"hwndMDIClient",
		"OS",
		"OS",
		"OS",
		"OS",
		"hwndMDIClient",
		"OS",
		"widgetStyle",
		"handle",
		"OS",
		"hwndMDIClient",
		"OS",
		"OS",
		"handle",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"msg",
		"flags",
		"hwndMDIClient",
		"i",
		"shells",
		"i",
		"shells",
		"i",
		"shell",
		"shell",
		"activeMenu",
		"display",
		"lpstrTip",
		"OS",
		"OS",
		"hHeap",
		"lpstrTip",
		"lpstrTip",
		"toolTipHandle",
		"brushes",
		"i",
		"brushes",
		"i",
		"brushes",
		"i",
		"hBrush",
		"OS",
		"hBrush",
		"brushes",
		"OS",
		"hIMC",
		"OS",
		"hIMC",
		"lastActive",
		"region",
		"menu",
		"menu",
		"activeMenu",
		"activeMenu",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"eventTable",
		"SWT",
		"listener",
		"eventTable",
		"SWT",
		"listener",
		"eventTable",
		"SWT",
		"listener",
		"eventTable",
		"SWT",
		"listener",
		"OS",
		"handle",
		"OS",
		"hDC",
		"hPalette",
		"OS",
		"hDC",
		"result",
		"OS",
		"handle",
		"OS",
		"hDC",
		"hOld",
		"OS",
		"hDC",
		"OS",
		"handle",
		"hDC",
		"result",
		"LRESULT",
		"LRESULT",
		"control",
		"control",
		"control",
		"lastActive",
		"lastActive",
		"lastActive",
		"lastActive",
		"control",
		"control",
		"control",
		"lastActive",
		"lastActive",
		"lastActive",
		"control",
		"Math",
		"activate",
		"deactivate",
		"index",
		"length",
		"activate",
		"index",
		"deactivate",
		"index",
		"index",
		"deactivate",
		"i",
		"index",
		"i",
		"deactivate",
		"i",
		"deactivate",
		"i",
		"SWT",
		"activate",
		"i",
		"index",
		"i",
		"activate",
		"i",
		"activate",
		"i",
		"SWT",
		"x",
		"y",
		"width",
		"height",
		"flags",
		"state",
		"DISABLED",
		"enabled",
		"enabled",
		"enabled",
		"handle",
		"OS",
		"OS",
		"mode",
		"SWT",
		"mode",
		"SWT",
		"OS",
		"handle",
		"OS",
		"hIMC",
		"imeOn",
		"imeOn",
		"OS",
		"hIMC",
		"lpfdwConversion",
		"lpfdwSentence",
		"OS",
		"OS",
		"mode",
		"SWT",
		"newBits",
		"OS",
		"OS",
		"oldBits",
		"mode",
		"SWT",
		"newBits",
		"OS",
		"oldBits",
		"OS",
		"mode",
		"SWT",
		"newBits",
		"OS",
		"oldBits",
		"OS",
		"mode",
		"SWT",
		"newBits",
		"OS",
		"oldBits",
		"OS",
		"lpfdwConversion",
		"newBits",
		"lpfdwConversion",
		"oldBits",
		"OS",
		"hIMC",
		"lpfdwConversion",
		"lpfdwSentence",
		"OS",
		"handle",
		"hIMC",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"style",
		"trim",
		"widthLimit",
		"OS",
		"OS",
		"style",
		"SWT",
		"heightLimit",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"rect",
		"bits1",
		"bits2",
		"heightLimit",
		"rect",
		"rect",
		"minWidth",
		"Math",
		"widthLimit",
		"width",
		"minHeight",
		"Math",
		"heightLimit",
		"height",
		"Math",
		"size",
		"minWidth",
		"Math",
		"size",
		"minHeight",
		"minWidth",
		"widthLimit",
		"minWidth",
		"SWT",
		"minHeight",
		"heightLimit",
		"minHeight",
		"SWT",
		"newWidth",
		"size",
		"newHeight",
		"size",
		"newWidth",
		"newHeight",
		"size",
		"SWT",
		"size",
		"size",
		"OS",
		"handle",
		"hMenu",
		"OS",
		"enabled",
		"flags",
		"OS",
		"OS",
		"OS",
		"hMenu",
		"cmd",
		"OS",
		"flags",
		"style",
		"SWT",
		"region",
		"region",
		"SWT",
		"region",
		"hRegion",
		"OS",
		"OS",
		"hRegion",
		"region",
		"hRegion",
		"OS",
		"OS",
		"handle",
		"hRegion",
		"region",
		"OS",
		"toolTipHandle",
		"toolTipHandle",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"toolTipHandle",
		"SWT",
		"OS",
		"toolTipHandle",
		"OS",
		"lpti",
		"TOOLINFO",
		"lpti",
		"hwnd",
		"lpti",
		"handle",
		"text",
		"OS",
		"toolTipHandle",
		"OS",
		"lpti",
		"OS",
		"toolTipHandle",
		"OS",
		"lpti",
		"OS",
		"toolTipHandle",
		"OS",
		"lpti",
		"OS",
		"OS",
		"lpti",
		"OS",
		"OS",
		"toolTipHandle",
		"OS",
		"lpti",
		"OS",
		"lpstrTip",
		"OS",
		"hHeap",
		"lpstrTip",
		"buffer",
		"lpstrTip",
		"OS",
		"hHeap",
		"OS",
		"byteCount",
		"OS",
		"lpstrTip",
		"buffer",
		"byteCount",
		"lpnmtdi",
		"lpstrTip",
		"OS",
		"lpstrTip",
		"OS",
		"hHeap",
		"lpstrTip",
		"buffer",
		"lpstrTip",
		"OS",
		"hHeap",
		"OS",
		"byteCount",
		"OS",
		"lpstrTip",
		"buffer",
		"byteCount",
		"lpnmtdi",
		"lpstrTip",
		"drawCount",
		"state",
		"HIDDEN",
		"visible",
		"visible",
		"OS",
		"handle",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"mask",
		"visible",
		"display",
		"display",
		"control",
		"control",
		"OS",
		"hwndShell",
		"parent",
		"hwndShell",
		"parent",
		"hwndShell",
		"OS",
		"hwndShell",
		"OS",
		"OS",
		"display",
		"showWithParent",
		"visible",
		"OS",
		"OS",
		"handle",
		"visible",
		"showWithParent",
		"visible",
		"showWithParent",
		"visible",
		"visible",
		"OS",
		"OS",
		"handle",
		"menuBar",
		"menuBar",
		"msg",
		"msg",
		"parent",
		"Display",
		"OS",
		"OS",
		"handle",
		"handle",
		"handle",
		"parent",
		"parent",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"OS",
		"parent",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"style",
		"trim",
		"bits",
		"OS",
		"parent",
		"OS",
		"bits",
		"OS",
		"OS",
		"bits",
		"style",
		"SWT",
		"bits",
		"OS",
		"bits",
		"OS",
		"DialogClass",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"trim",
		"display",
		"parent",
		"DialogClass",
		"OS",
		"DialogProc",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"trim",
		"parent",
		"DialogProc",
		"handle",
		"bits",
		"OS",
		"bits",
		"OS",
		"OS",
		"OS",
		"bits",
		"OS",
		"parent",
		"bits",
		"bits",
		"OS",
		"bits",
		"OS",
		"OS",
		"OS",
		"SWT",
		"SWT",
		"wParam",
		"fActive",
		"handle",
		"OS",
		"bVk",
		"OS",
		"bVk",
		"OS",
		"bVk",
		"hwnd",
		"wParam",
		"OS",
		"handle",
		"psai",
		"OS",
		"OS",
		"OS",
		"OS",
		"wParam",
		"OS",
		"hIMC",
		"OS",
		"hIMC",
		"OS",
		"hIMC",
		"OS",
		"hIMC",
		"wParam",
		"lParam",
		"parent",
		"LRESULT",
		"result",
		"OS",
		"wParam",
		"loWord",
		"OS",
		"lParam",
		"lParam",
		"handle",
		"OS",
		"handle",
		"OS",
		"LRESULT",
		"OS",
		"OS",
		"menuBar",
		"menuBar",
		"lParam",
		"hwndCB",
		"lParam",
		"hwndCB",
		"wParam",
		"OS",
		"hwndCB",
		"OS",
		"lParam",
		"hwndChild",
		"wParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"result",
		"wParam",
		"lParam",
		"result",
		"result",
		"OS",
		"display",
		"display",
		"result",
		"wParam",
		"lParam",
		"result",
		"result",
		"minWidth",
		"SWT",
		"minHeight",
		"SWT",
		"OS",
		"info",
		"lParam",
		"MINMAXINFO",
		"minWidth",
		"SWT",
		"info",
		"minWidth",
		"minHeight",
		"SWT",
		"info",
		"minHeight",
		"OS",
		"lParam",
		"info",
		"MINMAXINFO",
		"LRESULT",
		"result",
		"wParam",
		"lParam",
		"result",
		"result",
		"lParam",
		"hittest",
		"OS",
		"OS",
		"OS",
		"display",
		"control",
		"control",
		"decorations",
		"decorations",
		"display",
		"display",
		"hittest",
		"display",
		"hittest",
		"OS",
		"hittest",
		"OS",
		"display",
		"control",
		"OS",
		"hittest",
		"OS",
		"display",
		"control",
		"OS",
		"hittest",
		"OS",
		"OS",
		"pt",
		"OS",
		"pt",
		"pos",
		"pt",
		"pos",
		"OS",
		"pt",
		"hwnd",
		"display",
		"hwnd",
		"control",
		"control",
		"CANVAS",
		"control",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"bits",
		"bits",
		"hittest",
		"OS",
		"hittest",
		"OS",
		"OS",
		"control",
		"OS",
		"handle",
		"Display",
		"OS",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"hittest",
		"OS",
		"hittest",
		"OS",
		"hittest",
		"OS",
		"hittest",
		"menuBar",
		"menuBar",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"hittest",
		"OS",
		"hittest",
		"OS",
		"hittest",
		"wParam",
		"lParam",
		"result",
		"result",
		"display",
		"result",
		"OS",
		"display",
		"OS",
		"fixActive",
		"hwndActive",
		"OS",
		"handle",
		"display",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"display",
		"fixActive",
		"OS",
		"hwndActive",
		"display",
		"focusControl",
		"focusControl",
		"focusControl",
		"display",
		"display",
		"code",
		"wParam",
		"handle",
		"display",
		"hPalette",
		"hPalette",
		"wParam",
		"lParam",
		"display",
		"hPalette",
		"hPalette",
		"wParam",
		"lParam",
		"lParam",
		"msg",
		"OS",
		"Display",
		"display",
		"modalShell",
		"modalShell",
		"OS",
		"hwndModal",
		"OS",
		"hwndModal",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"hwndPopup",
		"hwndPopup",
		"handle",
		"display",
		"hwndPopup",
		"OS",
		"hwndPopup",
		"OS",
		"hwndPopup",
		"lParam",
		"hitTest",
		"OS",
		"display",
		"wParam",
		"control",
		"cursor",
		"OS",
		"pt",
		"OS",
		"handle",
		"pt",
		"OS",
		"handle",
		"rect",
		"OS",
		"rect",
		"pt",
		"OS",
		"cursor",
		"msg",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"LRESULT",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"result",
		"result",
		"OS",
		"wParam",
		"OS",
		"style",
		"SWT",
		"OS",
		"handle",
		"wParam",
		"lParam",
		"psai",
		"LRESULT",
		"pSipInfo",
		"SIPINFO",
		"OS",
		"pSipInfo",
		"psai",
		"pSipInfo",
		"OS",
		"result",
		"wParam",
		"lParam",
		"result",
		"result",
		"lParam",
		"OS",
		"control",
		"control",
		"shell",
		"LRESULT",
		"control",
		"control",
		"result",
		"wParam",
		"lParam",
		"result",
		"result",
		"OS",
		"wParam",
		"cmd",
		"OS",
		"Runtime",
		"memory",
		"OS",
		"handle",
		"OS",
		"LRESULT",
		"result",
		"wParam",
		"lParam",
		"result",
		"result",
		"OS",
		"lpwp",
		"lParam",
		"WINDOWPOS",
		"lpwp",
		"OS",
		"lpwp",
		"Math",
		"lpwp",
		"minWidth",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"style",
		"trim",
		"lpwp",
		"Math",
		"lpwp",
		"OS",
		"OS",
		"lpwp",
		"Math",
		"lpwp",
		"minHeight",
		"style",
		"SWT",
		"style",
		"trim",
		"style",
		"SWT",
		"lpwp",
		"Math",
		"lpwp",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"rect",
		"bits1",
		"bits2",
		"lpwp",
		"Math",
		"lpwp",
		"rect",
		"rect",
		"OS",
		"lParam",
		"lpwp",
		"WINDOWPOS",
		"result",
		"DEFAULT",
		"DEFAULT",
		"IsWinCE",
		"lpfnWndProc",
		"IsWinCE",
		"NONE",
		"SHELL_TRIM",
		"ERROR_THREAD_INVALID_ACCESS",
		"ERROR_INVALID_ARGUMENT",
		"style",
		"parent",
		"display",
		"handle",
		"IsWinCE",
		"NONE",
		"DIALOG_TRIM",
		"display",
		"NO_TRIM",
		"SYSTEM_MODAL",
		"APPLICATION_MODAL",
		"PRIMARY_MODAL",
		"SYSTEM_MODAL",
		"SYSTEM_MODAL",
		"APPLICATION_MODAL",
		"APPLICATION_MODAL",
		"PRIMARY_MODAL",
		"PRIMARY_MODAL",
		"ERROR_NULL_ARGUMENT",
		"Close",
		"Iconify",
		"Deiconify",
		"Activate",
		"Deactivate",
		"TOOL",
		"TITLE",
		"CLOSE",
		"MIN",
		"MAX",
		"BORDER",
		"RESIZE",
		"WM_KILLFOCUS",
		"WM_SETFOCUS",
		"GWL_STYLE",
		"WS_OVERLAPPED",
		"WS_CAPTION",
		"IsWinCE",
		"WS_POPUP",
		"TITLE",
		"WS_CAPTION",
		"NO_TRIM",
		"BORDER",
		"RESIZE",
		"WS_BORDER",
		"GWL_STYLE",
		"SWP_DRAWFRAME",
		"SWP_NOMOVE",
		"SWP_NOSIZE",
		"SWP_NOZORDER",
		"SWP_NOACTIVATE",
		"IsWinCE",
		"IsPPC",
		"cbSize",
		"sizeof",
		"IsDBLocale",
		"TrimEnabled",
		"SC_CLOSE",
		"COLOR_BTNFACE",
		"COLOR_BTNFACE",
		"COLOR_WINDOW",
		"COLOR_WINDOW",
		"length",
		"sizeof",
		"lbColor",
		"length",
		"handle",
		"handle",
		"toolTipText",
		"IsWinCE",
		"right",
		"left",
		"bottom",
		"top",
		"left",
		"top",
		"IsDBLocale",
		"NONE",
		"IME_CMODE_ROMAN",
		"ROMAN",
		"IME_CMODE_FULLSHAPE",
		"DBCS",
		"IME_CMODE_KATAKANA",
		"PHONETIC",
		"IME_CMODE_NATIVE",
		"NATIVE",
		"ALPHA",
		"IsWinCE",
		"left",
		"top",
		"TITLE",
		"CLOSE",
		"MIN",
		"MAX",
		"NO_TRIM",
		"SM_CXMINTRACK",
		"NO_TRIM",
		"RESIZE",
		"SM_CYMINTRACK",
		"GWL_STYLE",
		"GWL_EXSTYLE",
		"bottom",
		"top",
		"IsWinCE",
		"right",
		"left",
		"bottom",
		"top",
		"length",
		"parent",
		"length",
		"parent",
		"MDIS_ALLCHILDSTYLES",
		"WS_CHILD",
		"WS_CLIPCHILDREN",
		"WS_CLIPSIBLINGS",
		"IsWinCE",
		"WM_CHANGEUISTATE",
		"UIS_INITIALIZE",
		"PM_NOREMOVE",
		"PM_NOYIELD",
		"PM_QS_SENDMESSAGE",
		"length",
		"length",
		"IsDBLocale",
		"ERROR_NULL_ARGUMENT",
		"Close",
		"Iconify",
		"Deiconify",
		"Activate",
		"Deactivate",
		"ONE",
		"ZERO",
		"length",
		"length",
		"length",
		"Deactivate",
		"length",
		"Activate",
		"IsDBLocale",
		"NONE",
		"ROMAN",
		"IME_CMODE_NATIVE",
		"IME_CMODE_KATAKANA",
		"PHONETIC",
		"IME_CMODE_KATAKANA",
		"IME_CMODE_NATIVE",
		"NATIVE",
		"IME_CMODE_NATIVE",
		"IME_CMODE_KATAKANA",
		"DBCS",
		"IME_CMODE_FULLSHAPE",
		"IME_CMODE_FULLSHAPE",
		"ROMAN",
		"IME_CMODE_ROMAN",
		"IME_CMODE_ROMAN",
		"TITLE",
		"CLOSE",
		"MIN",
		"MAX",
		"NO_TRIM",
		"SM_CXMINTRACK",
		"RESIZE",
		"SM_CYMINTRACK",
		"GWL_STYLE",
		"GWL_EXSTYLE",
		"bottom",
		"top",
		"x",
		"y",
		"DEFAULT",
		"DEFAULT",
		"x",
		"y",
		"ERROR_NULL_ARGUMENT",
		"x",
		"y",
		"MF_ENABLED",
		"MF_DISABLED",
		"MF_GRAYED",
		"MF_BYCOMMAND",
		"NO_TRIM",
		"ERROR_INVALID_ARGUMENT",
		"handle",
		"RGN_OR",
		"region",
		"IsWinCE",
		"TOOLTIPS_CLASS",
		"TTS_ALWAYSTIP",
		"CW_USEDEFAULT",
		"CW_USEDEFAULT",
		"ERROR_NO_HANDLES",
		"TTM_SETMAXTIPWIDTH",
		"cbSize",
		"sizeof",
		"uId",
		"hwnd",
		"TTM_DELTOOL",
		"TTM_GETTOOLINFO",
		"TTM_UPDATE",
		"uFlags",
		"TTF_IDISHWND",
		"TTF_SUBCLASS",
		"lpszText",
		"LPSTR_TEXTCALLBACK",
		"TTM_ADDTOOL",
		"length",
		"HEAP_ZERO_MEMORY",
		"lpszText",
		"length",
		"HEAP_ZERO_MEMORY",
		"lpszText",
		"PRIMARY_MODAL",
		"APPLICATION_MODAL",
		"SYSTEM_MODAL",
		"handle",
		"WM_CANCELMODE",
		"IsWinCE",
		"IsWinCE",
		"TrimEnabled",
		"SC_CLOSE",
		"handle",
		"WS_EX_MDICHILD",
		"TOOL",
		"WS_EX_TOOLWINDOW",
		"IsWinCE",
		"ON_TOP",
		"TITLE",
		"CLOSE",
		"MIN",
		"MAX",
		"NO_TRIM",
		"WS_EX_TOOLWINDOW",
		"IsWin95",
		"WIN32_VERSION",
		"ON_TOP",
		"WS_EX_TOPMOST",
		"IsSP",
		"TOOL",
		"TITLE",
		"CLOSE",
		"MIN",
		"MAX",
		"BORDER",
		"RESIZE",
		"windowShadowClass",
		"IsSP",
		"TOOL",
		"TITLE",
		"CLOSE",
		"MIN",
		"MAX",
		"BORDER",
		"RESIZE",
		"WS_CHILD",
		"WS_CHILD",
		"IsWinCE",
		"IsSP",
		"WS_POPUP",
		"WS_POPUP",
		"WS_OVERLAPPED",
		"WS_CAPTION",
		"IsPPC",
		"HardKeyDown",
		"HardKeyUp",
		"VK_APP1",
		"VK_APP6",
		"fSipUp",
		"SIP_DOWN",
		"SIP_UP",
		"WIN32_VERSION",
		"IsDBLocale",
		"ZERO",
		"IsPPC",
		"IDOK",
		"WM_CLOSE",
		"ZERO",
		"IsPPC",
		"IsSP",
		"hwndCB",
		"GW_CHILD",
		"GWL_STYLE",
		"WS_CHILD",
		"IsWinCE",
		"DEFAULT",
		"DEFAULT",
		"sizeof",
		"DEFAULT",
		"ptMinTrackSize_x",
		"DEFAULT",
		"ptMinTrackSize_y",
		"sizeof",
		"ZERO",
		"HTERROR",
		"HTTRANSPARENT",
		"HTNOWHERE",
		"ignoreRestoreFocus",
		"lastHittest",
		"lastHittestControl",
		"HTMENU",
		"HTSYSMENU",
		"lastHittestControl",
		"IsWin95",
		"HTCAPTION",
		"lastHittestControl",
		"MA_NOACTIVATE",
		"HTMENU",
		"x",
		"y",
		"state",
		"style",
		"NO_FOCUS",
		"ON_TOP",
		"NO_FOCUS",
		"HTBORDER",
		"HTCLIENT",
		"MA_NOACTIVATE",
		"TrimEnabled",
		"HTNOWHERE",
		"WM_NCHITTEST",
		"HTCLIENT",
		"HTMENU",
		"HTBORDER",
		"WM_NCHITTEST",
		"HTMENU",
		"HTBORDER",
		"ignoreRestoreFocus",
		"display",
		"IsWin95",
		"lastHittest",
		"HTCAPTION",
		"lockActiveWindow",
		"WM_NCLBUTTONDOWN",
		"lockActiveWindow",
		"lastHittestControl",
		"lastHittestControl",
		"ignoreRestoreFocus",
		"hPalette",
		"hPalette",
		"WM_LBUTTONDOWN",
		"TrimEnabled",
		"handle",
		"IsWinCE",
		"HTERROR",
		"handle",
		"WM_LBUTTONDOWN",
		"WM_RBUTTONDOWN",
		"WM_MBUTTONDOWN",
		"WM_XBUTTONDOWN",
		"MB_OK",
		"ONE",
		"IsPPC",
		"SPI_SETSIPINFO",
		"RESIZE",
		"ZERO",
		"cbSize",
		"sizeof",
		"fSipUp",
		"fdwFlags",
		"SIPF_ON",
		"SW_PARENTOPENING",
		"showWithParent",
		"ZERO",
		"parent",
		"IsWinNT",
		"SC_MINIMIZE",
		"SW_SHOWMINIMIZED",
		"ZERO",
		"sizeof",
		"flags",
		"SWP_NOSIZE",
		"cx",
		"cx",
		"TITLE",
		"CLOSE",
		"MIN",
		"MAX",
		"NO_TRIM",
		"cx",
		"cx",
		"SM_CXMINTRACK",
		"cy",
		"cy",
		"NO_TRIM",
		"RESIZE",
		"cy",
		"cy",
		"SM_CYMINTRACK",
		"GWL_STYLE",
		"GWL_EXSTYLE",
		"cy",
		"cy",
		"bottom",
		"top",
		"sizeof",
		"style",
		"display",
		"display",
		"style",
		"display",
		"parent",
		"style",
		"handle",
		"parent",
		"parent",
		"style",
		"display",
		"handle",
		"style",
		"listener",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"enabled",
		"pixel",
		"newShell",
		"control",
		"menu",
		"listener",
		"hPalette",
		"control",
		"x",
		"y",
		"width",
		"height",
		"flags",
		"defer",
		"enabled",
		"mode",
		"width",
		"height",
		"size",
		"cmd",
		"enabled",
		"region",
		"hwnd",
		"text",
		"lpnmtdi",
		"buffer",
		"lpnmtdi",
		"buffer",
		"visible",
		"msg",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam"
	],
	"extendORImplementFiles":[
		"Decorations"
	],
	"package":[
		"org.eclipse.swt.widgets"
	],
	"import":[
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt",
		"org.eclipse.swt.graphics",
		"org.eclipse.swt.events"
	],
	"methods":[
		"win32_new",
		"checkStyle",
		"addShellListener",
		"callWindowProc",
		"close",
		"createHandle",
		"dispose",
		"enableWidget",
		"findBrush",
		"findCursor",
		"findThemeControl",
		"fixShell",
		"forceActive",
		"forceResize",
		"getBounds",
		"getEnabled",
		"getImeInputMode",
		"getLocation",
		"getMinimumSize",
		"getRegion",
		"getShell",
		"getSize",
		"getShells",
		"isLayoutDeferred",
		"isEnabled",
		"isVisible",
		"hwndMDIClient",
		"open",
		"releaseChild",
		"releaseHandle",
		"releaseShells",
		"releaseWidget",
		"removeMenu",
		"removeShellListener",
		"selectPalette",
		"setActive",
		"setActiveControl",
		"setBounds",
		"setEnabled",
		"setImeInputMode",
		"setMinimumSize",
		"setMinimumSize",
		"setItemEnabled",
		"setParent",
		"setRegion",
		"setToolTipText",
		"setToolTipText",
		"setToolTipText",
		"setVisible",
		"translateAccelerator",
		"traverseEscape",
		"updateModal",
		"widgetCreateStruct",
		"widgetParent",
		"widgetExtStyle",
		"windowClass",
		"windowProc",
		"widgetStyle",
		"WM_ACTIVATE",
		"WM_COMMAND",
		"WM_DESTROY",
		"WM_ENTERIDLE",
		"WM_GETMINMAXINFO",
		"WM_MOUSEACTIVATE",
		"WM_NCHITTEST",
		"WM_NCLBUTTONDOWN",
		"WM_PALETTECHANGED",
		"WM_QUERYNEWPALETTE",
		"WM_SETCURSOR",
		"WM_SETTINGCHANGE",
		"WM_SHOWWINDOW",
		"WM_SYSCOMMAND",
		"WM_WINDOWPOSCHANGING",
		"GetClassInfo",
		"checkSubclass",
		"getCurrent",
		"getDefault",
		"isValidThread",
		"error",
		"isDisposed",
		"error",
		"checkStyle",
		"createWidget",
		"checkStyle",
		"checkWidget",
		"error",
		"addListener",
		"addListener",
		"addListener",
		"addListener",
		"addListener",
		"DefWindowProc",
		"DefWindowProc",
		"CallWindowProc",
		"DefFrameProc",
		"DefWindowProc",
		"checkWidget",
		"closeWidget",
		"createHandle",
		"GetWindowLong",
		"SetWindowLong",
		"SetWindowPos",
		"setMaximized",
		"ImmCreateContext",
		"ImmAssociateContext",
		"dispose",
		"isActive",
		"setItemEnabled",
		"EnableWindow",
		"GetSysColor",
		"GetSysColorBrush",
		"GetSysColor",
		"GetSysColorBrush",
		"GetObject",
		"DeleteObject",
		"arraycopy",
		"CreateSolidBrush",
		"setActiveControl",
		"setToolTipText",
		"setToolTipText",
		"checkWidget",
		"isVisible",
		"SetForegroundWindow",
		"checkWidget",
		"IsIconic",
		"getBounds",
		"GetWindowRect",
		"checkWidget",
		"checkWidget",
		"ImmGetContext",
		"ImmGetOpenStatus",
		"ImmGetConversionStatus",
		"ImmReleaseContext",
		"checkWidget",
		"IsIconic",
		"getLocation",
		"GetWindowRect",
		"checkWidget",
		"max",
		"max",
		"GetSystemMetrics",
		"max",
		"max",
		"GetSystemMetrics",
		"GetWindowLong",
		"GetWindowLong",
		"AdjustWindowRectEx",
		"max",
		"checkWidget",
		"checkWidget",
		"checkWidget",
		"IsIconic",
		"getSize",
		"GetWindowRect",
		"checkWidget",
		"getShells",
		"checkWidget",
		"checkWidget",
		"getEnabled",
		"checkWidget",
		"getVisible",
		"CreateWindowEx",
		"GetModuleHandle",
		"checkWidget",
		"bringToTop",
		"isDisposed",
		"SetForegroundWindow",
		"SendMessage",
		"setVisible",
		"isDisposed",
		"PeekMessage",
		"restoreFocus",
		"traverseGroup",
		"setFocus",
		"releaseHandle",
		"getShells",
		"isDisposed",
		"releaseResources",
		"releaseShells",
		"releaseWidget",
		"clearModal",
		"GetProcessHeap",
		"HeapFree",
		"DeleteObject",
		"ImmDestroyContext",
		"removeMenu",
		"checkWidget",
		"error",
		"unhook",
		"unhook",
		"unhook",
		"unhook",
		"unhook",
		"GetDC",
		"SelectPalette",
		"RealizePalette",
		"InvalidateRect",
		"SelectPalette",
		"RealizePalette",
		"ReleaseDC",
		"checkWidget",
		"isVisible",
		"bringToTop",
		"isDisposed",
		"isDisposed",
		"getPath",
		"getPath",
		"min",
		"isDisposed",
		"sendEvent",
		"isDisposed",
		"sendEvent",
		"setBounds",
		"checkWidget",
		"setEnabled",
		"GetActiveWindow",
		"restoreFocus",
		"traverseGroup",
		"checkWidget",
		"ImmGetContext",
		"ImmSetOpenStatus",
		"ImmGetConversionStatus",
		"ImmSetConversionStatus",
		"ImmReleaseContext",
		"checkWidget",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"GetWindowLong",
		"GetWindowLong",
		"AdjustWindowRectEx",
		"max",
		"max",
		"getSize",
		"max",
		"max",
		"setSize",
		"checkWidget",
		"error",
		"setMinimumSize",
		"GetSystemMenu",
		"EnableMenuItem",
		"checkWidget",
		"isDisposed",
		"error",
		"CreateRectRgn",
		"CombineRgn",
		"SetWindowRgn",
		"CreateWindowEx",
		"GetModuleHandle",
		"error",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"hasCursor",
		"GetProcessHeap",
		"HeapFree",
		"HeapAlloc",
		"MoveMemory",
		"hasCursor",
		"GetProcessHeap",
		"HeapFree",
		"HeapAlloc",
		"MoveMemory",
		"checkWidget",
		"IsWindowVisible",
		"setModalShell",
		"_getFocusControl",
		"isActive",
		"bringToTop",
		"isDisposed",
		"GetActiveWindow",
		"SendMessage",
		"ReleaseCapture",
		"clearModal",
		"updateModal",
		"ShowOwnedPopups",
		"setVisible",
		"isDisposed",
		"ShowOwnedPopups",
		"isEnabled",
		"isActive",
		"isEnabled",
		"translateMDIAccelerator",
		"translateMenuAccelerator",
		"isVisible",
		"isEnabled",
		"close",
		"setItemEnabled",
		"isActive",
		"EnableWindow",
		"isActive",
		"widgetExtStyle",
		"VERSION",
		"windowClass",
		"windowProc",
		"windowProc",
		"widgetStyle",
		"hooks",
		"hooks",
		"SHSetAppKeyWndAssoc",
		"SHSipPreference",
		"VERSION",
		"ImmGetOpenStatus",
		"ImmSetOpenStatus",
		"ImmSetOpenStatus",
		"WM_ACTIVATE",
		"PostMessage",
		"WM_COMMAND",
		"GetWindow",
		"WM_COMMAND",
		"WM_COMMAND",
		"WM_DESTROY",
		"GetWindowLong",
		"releaseChild",
		"releaseResources",
		"WM_ENTERIDLE",
		"runAsyncMessages",
		"wakeThread",
		"WM_GETMINMAXINFO",
		"MoveMemory",
		"MoveMemory",
		"WM_MOUSEACTIVATE",
		"_getFocusControl",
		"menuShell",
		"getShell",
		"GetCursorPos",
		"GetMessagePos",
		"WindowFromPoint",
		"findControl",
		"setActiveControl",
		"IsWindowEnabled",
		"isEnabled",
		"isActive",
		"callWindowProc",
		"getEnabled",
		"callWindowProc",
		"WM_NCLBUTTONDOWN",
		"SetActiveWindow",
		"callWindowProc",
		"SetActiveWindow",
		"isDisposed",
		"setFocus",
		"selectPalette",
		"WM_PALETTECHANGED",
		"selectPalette",
		"WM_QUERYNEWPALETTE",
		"getModalShell",
		"isActive",
		"IsWindowEnabled",
		"SetActiveWindow",
		"IsWindowEnabled",
		"GetLastActivePopup",
		"getControl",
		"IsWindowEnabled",
		"SetActiveWindow",
		"getEnabled",
		"getControl",
		"GetCursorPos",
		"ScreenToClient",
		"GetClientRect",
		"PtInRect",
		"SetCursor",
		"MessageBeep",
		"WM_SETCURSOR",
		"WM_SETTINGCHANGE",
		"SHHandleWMSettingChange",
		"SipGetInfo",
		"WM_SHOWWINDOW",
		"getShell",
		"WM_SYSCOMMAND",
		"totalMemory",
		"getRuntime",
		"ShowWindow",
		"WM_WINDOWPOSCHANGING",
		"MoveMemory",
		"max",
		"max",
		"GetSystemMetrics",
		"max",
		"max",
		"GetSystemMetrics",
		"GetWindowLong",
		"GetWindowLong",
		"AdjustWindowRectEx",
		"max",
		"MoveMemory",
		"TCHAR",
		"WNDCLASS",
		"Shell",
		"TypedListener",
		"SHACTIVATEINFO",
		"LOGBRUSH",
		"RECT",
		"Rectangle",
		"RECT",
		"Point",
		"RECT",
		"Point",
		"RECT",
		"Point",
		"TCHAR",
		"CREATESTRUCT",
		"MSG",
		"RECT",
		"TCHAR",
		"TOOLINFO",
		"MINMAXINFO",
		"LRESULT",
		"POINT",
		"LRESULT",
		"LRESULT",
		"LRESULT",
		"LRESULT",
		"LRESULT",
		"POINT",
		"RECT",
		"SIPINFO",
		"WINDOWPOS",
		"RECT"
	],
	"methodsBody":{
		"void enableWidget(boolean enabled)":{
			"methodBody":"{\n    if (enabled) {\n        state &= ~DISABLED;\n    } else {\n        state |= DISABLED;\n    }\n    if (Display.TrimEnabled) {\n        if (isActive())\n            setItemEnabled(OS.SC_CLOSE, enabled);\n    } else {\n        OS.EnableWindow(handle, enabled);\n    }\n}",
			"comments":"",
			"methodName":"void enableWidget(boolean enabled)"
		},
		"void setItemEnabled(int cmd, boolean enabled)":{
			"methodBody":"{\n    int hMenu = OS.GetSystemMenu(handle, false);\n    if (hMenu == 0)\n        return;\n    int flags = OS.MF_ENABLED;\n    if (!enabled)\n        flags = OS.MF_DISABLED | OS.MF_GRAYED;\n    OS.EnableMenuItem(hMenu, cmd, OS.MF_BYCOMMAND | flags);\n}",
			"comments":"",
			"methodName":"void setItemEnabled(int cmd, boolean enabled)"
		},
		"public Point getLocation()":{
			"methodBody":"{\n    checkWidget();\n    if (!OS.IsWinCE) {\n        if (OS.IsIconic(handle)) {\n            return super.getLocation();\n        }\n    }\n    RECT rect = new RECT();\n    OS.GetWindowRect(handle, rect);\n    return new Point(rect.left, rect.top);\n}",
			"comments":"",
			"methodName":"public Point getLocation()"
		},
		"public void removeShellListener(ShellListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.Close, listener);\n    eventTable.unhook(SWT.Iconify, listener);\n    eventTable.unhook(SWT.Deiconify, listener);\n    eventTable.unhook(SWT.Activate, listener);\n    eventTable.unhook(SWT.Deactivate, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when operations are performed on the receiver.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see ShellListener\n* @see #addShellListener\n*/\n",
			"methodName":"public void removeShellListener(ShellListener listener)"
		},
		"void removeMenu(Menu menu)":{
			"methodBody":"{\n    super.removeMenu(menu);\n    if (menu == activeMenu)\n        activeMenu = null;\n}",
			"comments":"",
			"methodName":"void removeMenu(Menu menu)"
		},
		"void setActiveControl(Control control)":{
			"methodBody":"{\n    if (control != null && control.isDisposed())\n        control = null;\n    if (lastActive != null && lastActive.isDisposed())\n        lastActive = null;\n    if (lastActive == control)\n        return;\n    \n    Control[] activate = (control == null) ? new Control[0] : control.getPath();\n    Control[] deactivate = (lastActive == null) ? new Control[0] : lastActive.getPath();\n    lastActive = control;\n    int index = 0, length = Math.min(activate.length, deactivate.length);\n    while (index < length) {\n        if (activate[index] != deactivate[index])\n            break;\n        index++;\n    }\n    \n    for (int i = deactivate.length - 1; i >= index; --i) {\n        if (!deactivate[i].isDisposed()) {\n            deactivate[i].sendEvent(SWT.Deactivate);\n        }\n    }\n    for (int i = activate.length - 1; i >= index; --i) {\n        if (!activate[i].isDisposed()) {\n            activate[i].sendEvent(SWT.Activate);\n        }\n    }\n}",
			"comments":"/*\n* Compute the list of controls to be activated and\n* deactivated by finding the first common parent\n* control.\n*/\n/*\n* It is possible (but unlikely), that application\n* code could have destroyed some of the widgets. If\n* this happens, keep processing those widgets that\n* are not disposed.\n*/\n",
			"methodName":"void setActiveControl(Control control)"
		},
		"void setToolTipText(int hwnd, String text)":{
			"methodBody":"{\n    if (OS.IsWinCE)\n        return;\n    if (toolTipHandle == 0) {\n        toolTipHandle = OS.CreateWindowEx(0, new TCHAR(0, OS.TOOLTIPS_CLASS, true), null, OS.TTS_ALWAYSTIP, OS.CW_USEDEFAULT, 0, OS.CW_USEDEFAULT, 0, handle, 0, OS.GetModuleHandle(null), null);\n        if (toolTipHandle == 0)\n            error(SWT.ERROR_NO_HANDLES);\n        \n        OS.SendMessage(toolTipHandle, OS.TTM_SETMAXTIPWIDTH, 0, 0x7FFF);\n    }\n    TOOLINFO lpti = new TOOLINFO();\n    lpti.cbSize = TOOLINFO.sizeof;\n    lpti.uId = hwnd;\n    lpti.hwnd = handle;\n    if (text == null) {\n        OS.SendMessage(toolTipHandle, OS.TTM_DELTOOL, 0, lpti);\n    } else {\n        if (OS.SendMessage(toolTipHandle, OS.TTM_GETTOOLINFO, 0, lpti) != 0) {\n            OS.SendMessage(toolTipHandle, OS.TTM_UPDATE, 0, 0);\n        } else {\n            lpti.uFlags = OS.TTF_IDISHWND | OS.TTF_SUBCLASS;\n            lpti.lpszText = OS.LPSTR_TEXTCALLBACK;\n            OS.SendMessage(toolTipHandle, OS.TTM_ADDTOOL, 0, lpti);\n        }\n    }\n}",
			"comments":"/*\n* Feature in Windows.  Despite the fact that the\n* tool tip text contains \\r\\n, the tooltip will\n* not honour the new line unless TTM_SETMAXTIPWIDTH\n* is set.  The fix is to set TTM_SETMAXTIPWIDTH to\n* a large value.\n*/\n",
			"methodName":"void setToolTipText(int hwnd, String text)"
		},
		"public boolean isEnabled()":{
			"methodBody":"{\n    checkWidget();\n    return getEnabled();\n}",
			"comments":"",
			"methodName":"public boolean isEnabled()"
		},
		"LRESULT WM_GETMINMAXINFO(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_GETMINMAXINFO(wParam, lParam);\n    if (result != null)\n        return result;\n    if (minWidth != SWT.DEFAULT || minHeight != SWT.DEFAULT) {\n        MINMAXINFO info = new MINMAXINFO();\n        OS.MoveMemory(info, lParam, MINMAXINFO.sizeof);\n        if (minWidth != SWT.DEFAULT)\n            info.ptMinTrackSize_x = minWidth;\n        if (minHeight != SWT.DEFAULT)\n            info.ptMinTrackSize_y = minHeight;\n        OS.MoveMemory(lParam, info, MINMAXINFO.sizeof);\n        return LRESULT.ZERO;\n    }\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_GETMINMAXINFO(int wParam, int lParam)"
		},
		"public void setActive()":{
			"methodBody":"{\n    checkWidget();\n    if (!isVisible())\n        return;\n    bringToTop();\n\n}",
			"comments":"/**\n* If the receiver is visible, moves it to the top of the\n* drawing order for the display on which it was created\n* (so that all other shells on that display, which are not\n* the receiver's children will be drawn behind it) and asks\n* the window manager to make the shell active\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 2.0\n* @see Control#moveAbove\n* @see Control#setFocus\n* @see Control#setVisible\n* @see Display#getActiveShell\n* @see Decorations#setDefaultButton\n* @see Shell#open\n* @see Shell#setActive\n*/\n// widget could be disposed at this point\n",
			"methodName":"public void setActive()"
		},
		"public void addShellListener(ShellListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.Close, typedListener);\n    addListener(SWT.Iconify, typedListener);\n    addListener(SWT.Deiconify, typedListener);\n    addListener(SWT.Activate, typedListener);\n    addListener(SWT.Deactivate, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when operations are performed on the receiver,\n* by sending the listener one of the messages defined in the\n* <code>ShellListener</code> interface.\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see ShellListener\n* @see #removeShellListener\n*/\n",
			"methodName":"public void addShellListener(ShellListener listener)"
		},
		"public void setEnabled(boolean enabled)":{
			"methodBody":"{\n    checkWidget();\n    if (((state & DISABLED) == 0) == enabled)\n        return;\n    super.setEnabled(enabled);\n    if (enabled && handle == OS.GetActiveWindow()) {\n        if (!restoreFocus())\n            traverseGroup(true);\n    }\n}",
			"comments":"",
			"methodName":"public void setEnabled(boolean enabled)"
		},
		"int widgetParent()":{
			"methodBody":"{\n    if (handle != 0)\n        return handle;\n    return parent != null ? parent.handle : 0;\n}",
			"comments":"",
			"methodName":"int widgetParent()"
		},
		"public boolean getEnabled()":{
			"methodBody":"{\n    checkWidget();\n    return (state & DISABLED) == 0;\n}",
			"comments":"",
			"methodName":"public boolean getEnabled()"
		},
		"void setBounds(int x, int y, int width, int height, int flags, boolean defer)":{
			"methodBody":"{\n    super.setBounds(x, y, width, height, flags, false);\n}",
			"comments":"",
			"methodName":"void setBounds(int x, int y, int width, int height, int flags, boolean defer)"
		},
		"LRESULT WM_SHOWWINDOW(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_SHOWWINDOW(wParam, lParam);\n    if (result != null)\n        return result;\n    \n    if (lParam == OS.SW_PARENTOPENING) {\n        Control control = this;\n        while (control != null) {\n            Shell shell = control.getShell();\n            if (!shell.showWithParent)\n                return LRESULT.ZERO;\n            control = control.parent;\n        }\n    }\n    return result;\n}",
			"comments":"/*\n* Bug in Windows.  If the shell is hidden while the parent\n* is iconic,  Windows shows the shell when the parent is\n* deiconified.  This does not happen if the shell is hidden\n* while the parent is not an icon.  The fix is to track\n* visible state for the shell and refuse to show the shell\n* when the parent is shown.\n*/\n",
			"methodName":"LRESULT WM_SHOWWINDOW(int wParam, int lParam)"
		},
		"public Shell[] getShells()":{
			"methodBody":"{\n    checkWidget();\n    int count = 0;\n    Shell[] shells = display.getShells();\n    for (int i = 0; i < shells.length; i++) {\n        Control shell = shells[i];\n        do {\n            shell = shell.parent;\n        } while (shell != null && shell != this);\n        if (shell == this)\n            count++;\n    }\n    int index = 0;\n    Shell[] result = new Shell[count];\n    for (int i = 0; i < shells.length; i++) {\n        Control shell = shells[i];\n        do {\n            shell = shell.parent;\n        } while (shell != null && shell != this);\n        if (shell == this) {\n            result[index++] = shells[i];\n        }\n    }\n    return result;\n}",
			"comments":"/**\n* Returns an array containing all shells which are\n* descendents of the receiver.\n* <p>\n* @return the dialog shells\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Shell[] getShells()"
		},
		"int widgetExtStyle()":{
			"methodBody":"{\n    int bits = super.widgetExtStyle() & ~OS.WS_EX_MDICHILD;\n    if ((style & SWT.TOOL) != 0)\n        bits |= OS.WS_EX_TOOLWINDOW;\n    \n    if (!OS.IsWinCE) {\n        if (parent == null) {\n            if ((style & SWT.ON_TOP) != 0) {\n                int trim = SWT.TITLE | SWT.CLOSE | SWT.MIN | SWT.MAX;\n                if ((style & SWT.NO_TRIM) != 0 || (style & trim) == 0) {\n                    bits |= OS.WS_EX_TOOLWINDOW;\n                }\n            }\n        }\n    }\n    \n    if (parent != null) {\n        if (OS.IsWin95)\n            return bits;\n        if (OS.WIN32_VERSION < OS.VERSION(4, 10)) {\n            return bits;\n        }\n    }\n    if ((style & SWT.ON_TOP) != 0)\n        bits |= OS.WS_EX_TOPMOST;\n    return bits;\n}",
			"comments":"/*\n* Feature in Windows.  When a window that does not have a parent\n* is created, it is automatically added to the Windows Task Bar,\n* even when it has no title.  The fix is to use WS_EX_TOOLWINDOW\n* which does not cause the window to appear in the Task Bar.\n*/\n/*\n* Bug in Windows 98 and NT.  Creating a window with the\n* WS_EX_TOPMOST extended style can result in a dialog shell\n* being moved behind its parent.  The exact case where this\n* happens is a shell with two dialog shell children where\n* each dialog child has another hidden dialog child with\n* the WS_EX_TOPMOST extended style.  Clicking on either of\n* the visible dialogs causes them to become active but move\n* to the back, behind the parent shell.  The fix is to\n* disallow the WS_EX_TOPMOST extended style on Windows 98\n* and NT.\n*/\n",
			"methodName":"int widgetExtStyle()"
		},
		"public Rectangle getBounds()":{
			"methodBody":"{\n    checkWidget();\n    if (!OS.IsWinCE) {\n        if (OS.IsIconic(handle))\n            return super.getBounds();\n    }\n    RECT rect = new RECT();\n    OS.GetWindowRect(handle, rect);\n    int width = rect.right - rect.left;\n    int height = rect.bottom - rect.top;\n    return new Rectangle(rect.left, rect.top, width, height);\n}",
			"comments":"",
			"methodName":"public Rectangle getBounds()"
		},
		"public Point getSize()":{
			"methodBody":"{\n    checkWidget();\n    if (!OS.IsWinCE) {\n        if (OS.IsIconic(handle))\n            return super.getSize();\n    }\n    RECT rect = new RECT();\n    OS.GetWindowRect(handle, rect);\n    int width = rect.right - rect.left;\n    int height = rect.bottom - rect.top;\n    return new Point(width, height);\n}",
			"comments":"",
			"methodName":"public Point getSize()"
		},
		"public void setMinimumSize(int width, int height)":{
			"methodBody":"{\n    checkWidget();\n    int widthLimit = 0, heightLimit = 0;\n    int trim = SWT.TITLE | SWT.CLOSE | SWT.MIN | SWT.MAX;\n    if ((style & SWT.NO_TRIM) == 0 && (style & trim) != 0) {\n        widthLimit = OS.GetSystemMetrics(OS.SM_CXMINTRACK);\n        if ((style & SWT.RESIZE) != 0) {\n            heightLimit = OS.GetSystemMetrics(OS.SM_CYMINTRACK);\n        } else {\n            RECT rect = new RECT();\n            int bits1 = OS.GetWindowLong(handle, OS.GWL_STYLE);\n            int bits2 = OS.GetWindowLong(handle, OS.GWL_EXSTYLE);\n            OS.AdjustWindowRectEx(rect, bits1, false, bits2);\n            heightLimit = rect.bottom - rect.top;\n        }\n    }\n    minWidth = Math.max(widthLimit, width);\n    minHeight = Math.max(heightLimit, height);\n    Point size = getSize();\n    int newWidth = Math.max(size.x, minWidth);\n    int newHeight = Math.max(size.y, minHeight);\n    if (minWidth <= widthLimit)\n        minWidth = SWT.DEFAULT;\n    if (minHeight <= heightLimit)\n        minHeight = SWT.DEFAULT;\n    if (newWidth != size.x || newHeight != size.y)\n        setSize(newWidth, newHeight);\n}",
			"comments":"/**\n* Sets the receiver's minimum size to the size specified by the arguments.\n* If the new minimum size is larger than the current size of the receiver,\n* the receiver is resized to the new minimum size.\n*\n* @param width the new minimum width for the receiver\n* @param height the new minimum height for the receiver\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public void setMinimumSize(int width, int height)"
		},
		"public void open()":{
			"methodBody":"{\n    checkWidget();\n    bringToTop();\n    if (isDisposed())\n        return;\n    \n    if (OS.IsWinCE)\n        OS.SetForegroundWindow(handle);\n    OS.SendMessage(handle, OS.WM_CHANGEUISTATE, OS.UIS_INITIALIZE, 0);\n    setVisible(true);\n    if (isDisposed())\n        return;\n    \n    MSG msg = new MSG();\n    int flags = OS.PM_NOREMOVE | OS.PM_NOYIELD | OS.PM_QS_SENDMESSAGE;\n    OS.PeekMessage(msg, 0, 0, 0, flags);\n    if (!restoreFocus() && !traverseGroup(true))\n        setFocus();\n}",
			"comments":"/**\n* Moves the receiver to the top of the drawing order for\n* the display on which it was created (so that all other\n* shells on that display, which are not the receiver's\n* children will be drawn behind it), marks it visible,\n* sets the focus and asks the window manager to make the\n* shell active.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see Control#moveAbove\n* @see Control#setFocus\n* @see Control#setVisible\n* @see Display#getActiveShell\n* @see Decorations#setDefaultButton\n* @see Shell#setActive\n* @see Shell#forceActive\n*/\n/*\n* Feature on WinCE PPC.  A new application becomes\n* the foreground application only if it has at least\n* one visible window before the event loop is started.\n* The workaround is to explicitely force the shell to\n* be the foreground window.\n*/\n/*\n* Bug in Windows XP.  Despite the fact that an icon has been\n* set for a window, the task bar displays the wrong icon the\n* first time the window is made visible with ShowWindow() after\n* a call to BringToTop(), when a long time elapses between the\n* ShowWindow() and the time the event queue is read.  The icon\n* in the window trimming is correct but the one in the task\n* bar does not get updated.  The fix is to call PeekMessage()\n* with the flag PM_NOREMOVE and PM_QS_SENDMESSAGE to respond\n* to a cross thread WM_GETICON.\n*\n* NOTE: This allows other cross thread messages to be delivered,\n* most notably WM_ACTIVATE.\n*/\n",
			"methodName":"public void open()"
		},
		"void createHandle()":{
			"methodBody":"{\n    boolean embedded = handle != 0;\n    \n    \n    \n    super.createHandle();\n    if (!embedded) {\n        int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n        bits &= ~(OS.WS_OVERLAPPED | OS.WS_CAPTION);\n        if (!OS.IsWinCE)\n            bits |= OS.WS_POPUP;\n        if ((style & SWT.TITLE) != 0)\n            bits |= OS.WS_CAPTION;\n        if ((style & SWT.NO_TRIM) == 0) {\n            if ((style & (SWT.BORDER | SWT.RESIZE)) == 0)\n                bits |= OS.WS_BORDER;\n        }\n        \n        OS.SetWindowLong(handle, OS.GWL_STYLE, bits);\n        int flags = OS.SWP_DRAWFRAME | OS.SWP_NOMOVE | OS.SWP_NOSIZE | OS.SWP_NOZORDER | OS.SWP_NOACTIVATE;\n        SetWindowPos(handle, 0, 0, 0, 0, 0, flags);\n        if (OS.IsWinCE)\n            setMaximized(true);\n        if (OS.IsPPC) {\n            psai = new SHACTIVATEINFO();\n            psai.cbSize = SHACTIVATEINFO.sizeof;\n        }\n    }\n    if (OS.IsDBLocale) {\n        hIMC = OS.ImmCreateContext();\n        if (hIMC != 0)\n            OS.ImmAssociateContext(handle, hIMC);\n    }\n}",
			"comments":"/*\n* On Windows 98 and NT, setting a window to be the\n* top most window using HWND_TOPMOST can result in a\n* parent dialog shell being moved behind its parent\n* if the dialog has a sibling that is currently on top\n* This only occurs using SetWindowPos (), not when the\n* handle is created.\n*/\n/*\n* The following code is intentionally commented.\n*/\n//\tif ((style & SWT.ON_TOP) != 0) display.lockActiveWindow = true;\n/*\n* The following code is intentionally commented.\n*/\n//\tif ((style & SWT.ON_TOP) != 0)  display.lockActiveWindow = false;\n/*\n* Bug in Windows.  When the WS_CAPTION bits are cleared using\n* SetWindowLong(), Windows does not resize the client area of\n* the window to get rid of the caption until the first resize.\n* The fix is to use SetWindowPos() with SWP_DRAWFRAME to force\n* the frame to be redrawn and resized.\n*/\n",
			"methodName":"void createHandle()"
		},
		"LRESULT WM_ENTERIDLE(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_ENTERIDLE(wParam, lParam);\n    if (result != null)\n        return result;\n    if (OS.IsWinCE) {\n        if (display.runAsyncMessages(true))\n            display.wakeThread();\n    }\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_ENTERIDLE(int wParam, int lParam)"
		},
		"LRESULT selectPalette(int hPalette)":{
			"methodBody":"{\n    int hDC = OS.GetDC(handle);\n    int hOld = OS.SelectPalette(hDC, hPalette, false);\n    int result = OS.RealizePalette(hDC);\n    if (result > 0) {\n        OS.InvalidateRect(handle, null, true);\n    } else {\n        OS.SelectPalette(hDC, hOld, true);\n        OS.RealizePalette(hDC);\n    }\n    OS.ReleaseDC(handle, hDC);\n    return (result > 0) ? LRESULT.ONE : LRESULT.ZERO;\n}",
			"comments":"",
			"methodName":"LRESULT selectPalette(int hPalette)"
		},
		"void setToolTipText(NMTTDISPINFO lpnmtdi, char[] buffer)":{
			"methodBody":"{\n    \n    if (!hasCursor())\n        return;\n    int hHeap = OS.GetProcessHeap();\n    if (lpstrTip != 0)\n        OS.HeapFree(hHeap, 0, lpstrTip);\n    int byteCount = buffer.length * 2;\n    lpstrTip = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, byteCount);\n    OS.MoveMemory(lpstrTip, buffer, byteCount);\n    lpnmtdi.lpszText = lpstrTip;\n}",
			"comments":"/*\n* Ensure that the current position of the mouse\n* is inside the client area of the shell.  This\n* prevents tool tips from popping up over the\n* shell trimmings.\n*/\n",
			"methodName":"void setToolTipText(NMTTDISPINFO lpnmtdi, char[] buffer)"
		},
		"int findBrush(int pixel)":{
			"methodBody":"{\n    if (pixel == OS.GetSysColor(OS.COLOR_BTNFACE)) {\n        return OS.GetSysColorBrush(OS.COLOR_BTNFACE);\n    }\n    if (pixel == OS.GetSysColor(OS.COLOR_WINDOW)) {\n        return OS.GetSysColorBrush(OS.COLOR_WINDOW);\n    }\n    if (brushes == null)\n        brushes = new int[4];\n    LOGBRUSH logBrush = new LOGBRUSH();\n    for (int i = 0; i < brushes.length; i++) {\n        int hBrush = brushes[i];\n        if (hBrush == 0)\n            break;\n        OS.GetObject(hBrush, LOGBRUSH.sizeof, logBrush);\n        if (logBrush.lbColor == pixel)\n            return hBrush;\n    }\n    int length = brushes.length;\n    int hBrush = brushes[--length];\n    if (hBrush != 0)\n        OS.DeleteObject(hBrush);\n    System.arraycopy(brushes, 0, brushes, 1, length);\n    brushes[0] = hBrush = OS.CreateSolidBrush(pixel);\n    return hBrush;\n}",
			"comments":"",
			"methodName":"int findBrush(int pixel)"
		},
		"int windowProc()":{
			"methodBody":"{\n    if (OS.IsSP)\n        return DialogProc;\n    if ((style & SWT.TOOL) != 0) {\n        int trim = SWT.TITLE | SWT.CLOSE | SWT.MIN | SWT.MAX | SWT.BORDER | SWT.RESIZE;\n        if ((style & trim) == 0)\n            super.windowProc();\n    }\n    return parent != null ? DialogProc : super.windowProc();\n}",
			"comments":"",
			"methodName":"int windowProc()"
		},
		"public void setMinimumSize(Point size)":{
			"methodBody":"{\n    checkWidget();\n    if (size == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    setMinimumSize(size.x, size.y);\n}",
			"comments":"/**\n* Sets the receiver's minimum size to the size specified by the argument.\n* If the new minimum size is larger than the current size of the receiver,\n* the receiver is resized to the new minimum size.\n*\n* @param size the new minimum size for the receiver\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the point is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public void setMinimumSize(Point size)"
		},
		"void releaseChild()":{
			"methodBody":"{\n\n}",
			"comments":"/* Do nothing */\n",
			"methodName":"void releaseChild()"
		},
		"void releaseShells()":{
			"methodBody":"{\n    Shell[] shells = getShells();\n    for (int i = 0; i < shells.length; i++) {\n        Shell shell = shells[i];\n        if (!shell.isDisposed())\n            shell.releaseResources();\n    }\n}",
			"comments":"",
			"methodName":"void releaseShells()"
		},
		"public void forceActive()":{
			"methodBody":"{\n    checkWidget();\n    if (!isVisible())\n        return;\n    OS.SetForegroundWindow(handle);\n}",
			"comments":"/**\n* If the receiver is visible, moves it to the top of the\n* drawing order for the display on which it was created\n* (so that all other shells on that display, which are not\n* the receiver's children will be drawn behind it) and forces\n* the window manager to make the shell active.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 2.0\n* @see Control#moveAbove\n* @see Control#setFocus\n* @see Control#setVisible\n* @see Display#getActiveShell\n* @see Decorations#setDefaultButton\n* @see Shell#open\n* @see Shell#setActive\n*/\n",
			"methodName":"public void forceActive()"
		},
		"int widgetStyle()":{
			"methodBody":"{\n    int bits = super.widgetStyle();\n    if (handle != 0)\n        return bits | OS.WS_CHILD;\n    bits &= ~OS.WS_CHILD;\n    \n    if (OS.IsWinCE) {\n        if (OS.IsSP)\n            return bits | OS.WS_POPUP;\n        return parent == null ? bits : bits | OS.WS_POPUP;\n    }\n    \n    return bits | OS.WS_OVERLAPPED | OS.WS_CAPTION;\n}",
			"comments":"/*\n* Feature in WinCE.  Calling CreateWindowEx () with WS_OVERLAPPED\n* and a parent window causes the new window to become a WS_CHILD of\n* the parent instead of a dialog child.  The fix is to use WS_POPUP\n* for a window with a parent.\n*\n* Feature in WinCE PPC.  A window without a parent with WS_POPUP\n* always shows on top of the Pocket PC 'Today Screen'. The fix\n* is to not set WS_POPUP for a window without a parent on WinCE\n* devices.\n*\n* NOTE: WS_POPUP causes CreateWindowEx () to ignore CW_USEDEFAULT\n* and causes the default window location and size to be zero.\n*/\n/*\n* Use WS_OVERLAPPED for all windows, either dialog or top level\n* so that CreateWindowEx () will respect CW_USEDEFAULT and set\n* the default window location and size.\n*\n* NOTE:  When a WS_OVERLAPPED window is created, Windows gives\n* the new window WS_CAPTION style bits.  These two constants are\n* as follows:\n*\n* \tWS_OVERLAPPED = 0\n* \tWS_CAPTION = WS_BORDER | WS_DLGFRAME\n*\n*/\n",
			"methodName":"int widgetStyle()"
		},
		"public Shell getShell()":{
			"methodBody":"{\n    checkWidget();\n    return this;\n}",
			"comments":"",
			"methodName":"public Shell getShell()"
		},
		"public int getImeInputMode()":{
			"methodBody":"{\n    checkWidget();\n    if (!OS.IsDBLocale)\n        return 0;\n    int hIMC = OS.ImmGetContext(handle);\n    int[] lpfdwConversion = new int[1], lpfdwSentence = new int[1];\n    boolean open = OS.ImmGetOpenStatus(hIMC);\n    if (open)\n        open = OS.ImmGetConversionStatus(hIMC, lpfdwConversion, lpfdwSentence);\n    OS.ImmReleaseContext(handle, hIMC);\n    if (!open)\n        return SWT.NONE;\n    int result = 0;\n    if ((lpfdwConversion[0] & OS.IME_CMODE_ROMAN) != 0)\n        result |= SWT.ROMAN;\n    if ((lpfdwConversion[0] & OS.IME_CMODE_FULLSHAPE) != 0)\n        result |= SWT.DBCS;\n    if ((lpfdwConversion[0] & OS.IME_CMODE_KATAKANA) != 0)\n        return result | SWT.PHONETIC;\n    if ((lpfdwConversion[0] & OS.IME_CMODE_NATIVE) != 0)\n        return result | SWT.NATIVE;\n    return result | SWT.ALPHA;\n}",
			"comments":"/**\n* Returns the receiver's input method editor mode. This\n* will be the result of bitwise OR'ing together one or\n* more of the following constants defined in class\n* <code>SWT</code>:\n* <code>NONE</code>, <code>ROMAN</code>, <code>DBCS</code>,\n* <code>PHONETIC</code>, <code>NATIVE</code>, <code>ALPHA</code>.\n*\n* @return the IME mode\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see SWT\n*/\n",
			"methodName":"public int getImeInputMode()"
		},
		"public boolean isVisible()":{
			"methodBody":"{\n    checkWidget();\n    return getVisible();\n}",
			"comments":"",
			"methodName":"public boolean isVisible()"
		},
		"boolean translateAccelerator(MSG msg)":{
			"methodBody":"{\n    if (!isEnabled() || !isActive())\n        return false;\n    if (menuBar != null && !menuBar.isEnabled())\n        return false;\n    return translateMDIAccelerator(msg) || translateMenuAccelerator(msg);\n}",
			"comments":"",
			"methodName":"boolean translateAccelerator(MSG msg)"
		},
		"void updateModal()":{
			"methodBody":"{\n    if (Display.TrimEnabled) {\n        setItemEnabled(OS.SC_CLOSE, isActive());\n    } else {\n        OS.EnableWindow(handle, isActive());\n    }\n}",
			"comments":"",
			"methodName":"void updateModal()"
		},
		"public void setImeInputMode(int mode)":{
			"methodBody":"{\n    checkWidget();\n    if (!OS.IsDBLocale)\n        return;\n    boolean imeOn = mode != SWT.NONE && mode != SWT.ROMAN;\n    int hIMC = OS.ImmGetContext(handle);\n    OS.ImmSetOpenStatus(hIMC, imeOn);\n    if (imeOn) {\n        int[] lpfdwConversion = new int[1], lpfdwSentence = new int[1];\n        if (OS.ImmGetConversionStatus(hIMC, lpfdwConversion, lpfdwSentence)) {\n            int newBits = 0;\n            int oldBits = OS.IME_CMODE_NATIVE | OS.IME_CMODE_KATAKANA;\n            if ((mode & SWT.PHONETIC) != 0) {\n                newBits = OS.IME_CMODE_KATAKANA | OS.IME_CMODE_NATIVE;\n                oldBits = 0;\n            } else {\n                if ((mode & SWT.NATIVE) != 0) {\n                    newBits = OS.IME_CMODE_NATIVE;\n                    oldBits = OS.IME_CMODE_KATAKANA;\n                }\n            }\n            if ((mode & SWT.DBCS) != 0) {\n                newBits |= OS.IME_CMODE_FULLSHAPE;\n            } else {\n                oldBits |= OS.IME_CMODE_FULLSHAPE;\n            }\n            if ((mode & SWT.ROMAN) != 0) {\n                newBits |= OS.IME_CMODE_ROMAN;\n            } else {\n                oldBits |= OS.IME_CMODE_ROMAN;\n            }\n            lpfdwConversion[0] |= newBits;\n            lpfdwConversion[0] &= ~oldBits;\n            OS.ImmSetConversionStatus(hIMC, lpfdwConversion[0], lpfdwSentence[0]);\n        }\n    }\n    OS.ImmReleaseContext(handle, hIMC);\n}",
			"comments":"/**\n* Sets the input method editor mode to the argument which\n* should be the result of bitwise OR'ing together one or more\n* of the following constants defined in class <code>SWT</code>:\n* <code>NONE</code>, <code>ROMAN</code>, <code>DBCS</code>,\n* <code>PHONETIC</code>, <code>NATIVE</code>, <code>ALPHA</code>.\n*\n* @param mode the new IME mode\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see SWT\n*/\n",
			"methodName":"public void setImeInputMode(int mode)"
		},
		"public boolean isLayoutDeferred()":{
			"methodBody":"{\n    checkWidget();\n    return layoutCount > 0;\n}",
			"comments":"",
			"methodName":"public boolean isLayoutDeferred()"
		},
		"LRESULT WM_NCLBUTTONDOWN(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_NCLBUTTONDOWN(wParam, lParam);\n    if (result != null)\n        return result;\n    \n    if (!display.ignoreRestoreFocus)\n        return result;\n    Display display = this.display;\n    int hwndActive = 0;\n    boolean fixActive = OS.IsWin95 && display.lastHittest == OS.HTCAPTION;\n    if (fixActive)\n        hwndActive = OS.SetActiveWindow(handle);\n    display.lockActiveWindow = true;\n    int code = callWindowProc(handle, OS.WM_NCLBUTTONDOWN, wParam, lParam);\n    display.lockActiveWindow = false;\n    if (fixActive)\n        OS.SetActiveWindow(hwndActive);\n    Control focusControl = display.lastHittestControl;\n    if (focusControl != null && !focusControl.isDisposed()) {\n        focusControl.setFocus();\n    }\n    display.lastHittestControl = null;\n    display.ignoreRestoreFocus = false;\n    return new LRESULT(code);\n}",
			"comments":"/*\n* When the normal activation was interruped in WM_MOUSEACTIVATE\n* because the active shell was an MDI shell, set the active window\n* to the top level shell but lock the active window and stop focus\n* changes.  This allows the user to interact the top level shell\n* in the normal manner.\n*/\n",
			"methodName":"LRESULT WM_NCLBUTTONDOWN(int wParam, int lParam)"
		},
		"LRESULT WM_NCHITTEST(int wParam, int lParam)":{
			"methodBody":"{\n    if (!OS.IsWindowEnabled(handle))\n        return null;\n    if (!isEnabled() || !isActive()) {\n        if (!Display.TrimEnabled)\n            return new LRESULT(OS.HTNOWHERE);\n        int hittest = callWindowProc(handle, OS.WM_NCHITTEST, wParam, lParam);\n        if (hittest == OS.HTCLIENT || hittest == OS.HTMENU)\n            hittest = OS.HTBORDER;\n        return new LRESULT(hittest);\n    }\n    if (menuBar != null && !menuBar.getEnabled()) {\n        int hittest = callWindowProc(handle, OS.WM_NCHITTEST, wParam, lParam);\n        if (hittest == OS.HTMENU)\n            hittest = OS.HTBORDER;\n        return new LRESULT(hittest);\n    }\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_NCHITTEST(int wParam, int lParam)"
		},
		"LRESULT WM_PALETTECHANGED(int wParam, int lParam)":{
			"methodBody":"{\n    if (wParam != handle) {\n        int hPalette = display.hPalette;\n        if (hPalette != 0)\n            return selectPalette(hPalette);\n    }\n    return super.WM_PALETTECHANGED(wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_PALETTECHANGED(int wParam, int lParam)"
		},
		"void releaseHandle()":{
			"methodBody":"{\n    super.releaseHandle();\n    hwndMDIClient = 0;\n}",
			"comments":"",
			"methodName":"void releaseHandle()"
		},
		"static int checkStyle(int style)":{
			"methodBody":"{\n    style = Decorations.checkStyle(style);\n    int mask = SWT.SYSTEM_MODAL | SWT.APPLICATION_MODAL | SWT.PRIMARY_MODAL;\n    int bits = style & ~mask;\n    if ((style & SWT.SYSTEM_MODAL) != 0)\n        return bits | SWT.SYSTEM_MODAL;\n    if ((style & SWT.APPLICATION_MODAL) != 0)\n        return bits | SWT.APPLICATION_MODAL;\n    if ((style & SWT.PRIMARY_MODAL) != 0)\n        return bits | SWT.PRIMARY_MODAL;\n    return bits;\n}",
			"comments":"",
			"methodName":"static int checkStyle(int style)"
		},
		"Cursor findCursor()":{
			"methodBody":"{\n    return cursor;\n}",
			"comments":"",
			"methodName":"Cursor findCursor()"
		},
		"LRESULT WM_COMMAND(int wParam, int lParam)":{
			"methodBody":"{\n    if (OS.IsPPC) {\n        \n        int loWord = wParam & 0xFFFF;\n        if (loWord == OS.IDOK && (lParam == 0 || lParam == handle)) {\n            OS.PostMessage(handle, OS.WM_CLOSE, 0, 0);\n            return LRESULT.ZERO;\n        }\n    }\n    \n    if (OS.IsPPC || OS.IsSP) {\n        if (menuBar != null) {\n            int hwndCB = menuBar.hwndCB;\n            if (lParam != 0 && hwndCB != 0) {\n                if (lParam == hwndCB) {\n                    return super.WM_COMMAND(wParam, 0);\n                } else {\n                    int hwndChild = OS.GetWindow(hwndCB, OS.GW_CHILD);\n                    if (lParam == hwndChild)\n                        return super.WM_COMMAND(wParam, 0);\n                }\n            }\n        }\n    }\n    return super.WM_COMMAND(wParam, lParam);\n}",
			"comments":"/*\n* Note in WinCE PPC:  Close the Shell when the \"Done Button\" has\n* been pressed. lParam is either 0 (PocketPC 2002) or the handle\n* to the Shell (PocketPC).\n*/\n/*\n* Feature in Windows.  On PPC, the menu is not actually an HMENU.\n* By observation, it is a tool bar that is configured to look like\n* a menu.  Therefore, when the PPC menu sends WM_COMMAND messages,\n* lParam is not zero because the WM_COMMAND was not sent from a menu.\n* Sub menu item events originate from the menu bar.  Top menu items\n* events originate from a tool bar.  The fix is to detect the source\n* of the WM_COMMAND and set lParam to zero to pretend that the message\n* came from a real Windows menu, not a tool bar.\n*/\n",
			"methodName":"LRESULT WM_COMMAND(int wParam, int lParam)"
		},
		"LRESULT WM_SETTINGCHANGE(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_SETTINGCHANGE(wParam, lParam);\n    if (result != null)\n        return result;\n    if (OS.IsPPC) {\n        if (wParam == OS.SPI_SETSIPINFO) {\n            \n            if ((style & SWT.RESIZE) != 0) {\n                OS.SHHandleWMSettingChange(handle, wParam, lParam, psai);\n                return LRESULT.ZERO;\n            } else {\n                SIPINFO pSipInfo = new SIPINFO();\n                pSipInfo.cbSize = SIPINFO.sizeof;\n                OS.SipGetInfo(pSipInfo);\n                psai.fSipUp = pSipInfo.fdwFlags & OS.SIPF_ON;\n            }\n        }\n    }\n    return result;\n}",
			"comments":"/*\n* The SIP is in a new state.  Cache its new value.\n* Resize the Shell if it has the style SWT.RESIZE.\n* Note that SHHandleWMSettingChange resizes the\n* Shell and also updates the cached state.\n*/\n",
			"methodName":"LRESULT WM_SETTINGCHANGE(int wParam, int lParam)"
		},
		"void setToolTipText(NMTTDISPINFO lpnmtdi, byte[] buffer)":{
			"methodBody":"{\n    \n    if (!hasCursor())\n        return;\n    int hHeap = OS.GetProcessHeap();\n    if (lpstrTip != 0)\n        OS.HeapFree(hHeap, 0, lpstrTip);\n    int byteCount = buffer.length;\n    lpstrTip = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, byteCount);\n    OS.MoveMemory(lpstrTip, buffer, byteCount);\n    lpnmtdi.lpszText = lpstrTip;\n}",
			"comments":"/*\n* Ensure that the current position of the mouse\n* is inside the client area of the shell.  This\n* prevents tool tips from popping up over the\n* shell trimmings.\n*/\n",
			"methodName":"void setToolTipText(NMTTDISPINFO lpnmtdi, byte[] buffer)"
		},
		"public void close()":{
			"methodBody":"{\n    checkWidget();\n    closeWidget();\n}",
			"comments":"/**\n* Requests that the window manager close the receiver in\n* the same way it would be closed when the user clicks on\n* the \"close box\" or performs some other platform specific\n* key or mouse combination that indicates the window\n* should be removed.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see SWT#Close\n* @see #dispose\n*/\n",
			"methodName":"public void close()"
		},
		"public Region getRegion()":{
			"methodBody":"{\n    checkWidget();\n    return region;\n}",
			"comments":"/**\n* Returns the region that defines the shape of the shell,\n* or null if the shell has the default shape.\n*\n* @return the region that defines the shape of the shell (or null)\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.0\n*\n*/\n",
			"methodName":"public Region getRegion()"
		},
		"LRESULT WM_SETCURSOR(int wParam, int lParam)":{
			"methodBody":"{\n    \n    int msg = (short) (lParam >> 16);\n    if (msg == OS.WM_LBUTTONDOWN) {\n        if (!Display.TrimEnabled) {\n            Shell modalShell = display.getModalShell();\n            if (modalShell != null && !isActive()) {\n                int hwndModal = modalShell.handle;\n                if (OS.IsWindowEnabled(hwndModal)) {\n                    OS.SetActiveWindow(hwndModal);\n                }\n            }\n        }\n        if (!OS.IsWindowEnabled(handle)) {\n            if (!OS.IsWinCE) {\n                int hwndPopup = OS.GetLastActivePopup(handle);\n                if (hwndPopup != 0 && hwndPopup != handle) {\n                    if (display.getControl(hwndPopup) == null) {\n                        if (OS.IsWindowEnabled(hwndPopup)) {\n                            OS.SetActiveWindow(hwndPopup);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    int hitTest = (short) (lParam & 0xFFFF);\n    if (hitTest == OS.HTERROR) {\n        if (!getEnabled()) {\n            Control control = display.getControl(wParam);\n            if (control == this && cursor != null) {\n                POINT pt = new POINT();\n                if (OS.GetCursorPos(pt)) {\n                    OS.ScreenToClient(handle, pt);\n                    RECT rect = new RECT();\n                    OS.GetClientRect(handle, rect);\n                    if (OS.PtInRect(rect, pt)) {\n                        OS.SetCursor(cursor.handle);\n                        switch(msg) {\n                            case OS.WM_LBUTTONDOWN:\n                            case OS.WM_RBUTTONDOWN:\n                            case OS.WM_MBUTTONDOWN:\n                            case OS.WM_XBUTTONDOWN:\n                                OS.MessageBeep(OS.MB_OK);\n                        }\n                        return LRESULT.ONE;\n                    }\n                }\n            }\n        }\n    }\n    return super.WM_SETCURSOR(wParam, lParam);\n}",
			"comments":"/*\n* Feature in Windows.  When the shell is disabled\n* by a Windows standard dialog (like a MessageBox\n* or FileDialog), clicking in the shell does not\n* bring the shell or the dialog to the front. The\n* fix is to detect this case and bring the shell\n* forward.\n*/\n/*\n* When the shell that contains a cursor is disabled,\n* WM_SETCURSOR is called with HTERROR.  Normally,\n* when a control is disabled, the parent will get\n* mouse and cursor events.  In the case of a disabled\n* shell, there is no enabled parent.  In order to\n* show the cursor when a shell is disabled, it is\n* necessary to override WM_SETCURSOR when called\n* with HTERROR to set the cursor but only when the\n* mouse is in the client area of the shell.\n*/\n",
			"methodName":"LRESULT WM_SETCURSOR(int wParam, int lParam)"
		},
		"public void setVisible(boolean visible)":{
			"methodBody":"{\n    checkWidget();\n    if (drawCount != 0) {\n        if (((state & HIDDEN) == 0) == visible)\n            return;\n    } else {\n        if (visible == OS.IsWindowVisible(handle))\n            return;\n    }\n    \n    int mask = SWT.PRIMARY_MODAL | SWT.APPLICATION_MODAL | SWT.SYSTEM_MODAL;\n    if ((style & mask) != 0) {\n        if (visible) {\n            display.setModalShell(this);\n            Control control = display._getFocusControl();\n            if (control != null && !control.isActive()) {\n                bringToTop();\n                if (isDisposed())\n                    return;\n            }\n            int hwndShell = OS.GetActiveWindow();\n            if (hwndShell == 0) {\n                if (parent != null)\n                    hwndShell = parent.handle;\n            }\n            if (hwndShell != 0) {\n                OS.SendMessage(hwndShell, OS.WM_CANCELMODE, 0, 0);\n            }\n            OS.ReleaseCapture();\n        } else {\n            display.clearModal(this);\n        }\n    } else {\n        updateModal();\n    }\n    \n    if (showWithParent && !visible) {\n        if (!OS.IsWinCE)\n            OS.ShowOwnedPopups(handle, false);\n    }\n    super.setVisible(visible);\n    if (isDisposed())\n        return;\n    if (showWithParent == visible)\n        return;\n    showWithParent = visible;\n    if (visible) {\n        if (!OS.IsWinCE)\n            OS.ShowOwnedPopups(handle, true);\n    }\n}",
			"comments":"/*\n* Feature in Windows.  When ShowWindow() is called used to hide\n* a window, Windows attempts to give focus to the parent. If the\n* parent is disabled by EnableWindow(), focus is assigned to\n* another windows on the desktop.  This means that if you hide\n* a modal window before the parent is enabled, the parent will\n* not come to the front.  The fix is to change the modal state\n* before hiding or showing a window so that this does not occur.\n*/\n/*\n* Bug in Windows.  Calling ShowOwnedPopups() to hide the\n* child windows of a hidden window causes the application\n* to be deactivated.  The fix is to call ShowOwnedPopups()\n* to hide children before hiding the parent.\n*/\n",
			"methodName":"public void setVisible(boolean visible)"
		},
		"Control findThemeControl()":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"Control findThemeControl()"
		},
		"LRESULT WM_SYSCOMMAND(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_SYSCOMMAND(wParam, lParam);\n    if (result != null)\n        return result;\n    \n    if (OS.IsWinNT) {\n        int cmd = wParam & 0xFFF0;\n        switch(cmd) {\n            case OS.SC_MINIMIZE:\n                long memory = Runtime.getRuntime().totalMemory();\n                if (memory >= 32 * 1024 * 1024) {\n                    OS.ShowWindow(handle, OS.SW_SHOWMINIMIZED);\n                    return LRESULT.ZERO;\n                }\n        }\n    }\n    return result;\n}",
			"comments":"/*\n* Feature in Windows.  When the last visible window in\n* a process minimized, Windows swaps out the memory for\n* the process.  The assumption is that the user can no\n* longer interact with the window, so the memory can be\n* released to other applications.  However, for programs\n* that use a lot of memory, swapping the memory back in\n* can take a long time, sometimes minutes.  The fix is\n* to intercept WM_SYSCOMMAND looking for SC_MINIMIZE\n* and use ShowWindow() with SW_SHOWMINIMIZED to minimize\n* the window, rather than running the default window proc.\n*\n* NOTE:  The default window proc activates the next\n* top-level window in the Z-order while ShowWindow()\n* with SW_SHOWMINIMIZED does not.  There is no fix for\n* this at this time.\n*/\n",
			"methodName":"LRESULT WM_SYSCOMMAND(int wParam, int lParam)"
		},
		"LRESULT WM_WINDOWPOSCHANGING(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_WINDOWPOSCHANGING(wParam, lParam);\n    if (result != null)\n        return result;\n    WINDOWPOS lpwp = new WINDOWPOS();\n    OS.MoveMemory(lpwp, lParam, WINDOWPOS.sizeof);\n    if ((lpwp.flags & OS.SWP_NOSIZE) == 0) {\n        lpwp.cx = Math.max(lpwp.cx, minWidth);\n        int trim = SWT.TITLE | SWT.CLOSE | SWT.MIN | SWT.MAX;\n        if ((style & SWT.NO_TRIM) == 0 && (style & trim) != 0) {\n            lpwp.cx = Math.max(lpwp.cx, OS.GetSystemMetrics(OS.SM_CXMINTRACK));\n        }\n        lpwp.cy = Math.max(lpwp.cy, minHeight);\n        if ((style & SWT.NO_TRIM) == 0 && (style & trim) != 0) {\n            if ((style & SWT.RESIZE) != 0) {\n                lpwp.cy = Math.max(lpwp.cy, OS.GetSystemMetrics(OS.SM_CYMINTRACK));\n            } else {\n                RECT rect = new RECT();\n                int bits1 = OS.GetWindowLong(handle, OS.GWL_STYLE);\n                int bits2 = OS.GetWindowLong(handle, OS.GWL_EXSTYLE);\n                OS.AdjustWindowRectEx(rect, bits1, false, bits2);\n                lpwp.cy = Math.max(lpwp.cy, rect.bottom - rect.top);\n            }\n        }\n        OS.MoveMemory(lParam, lpwp, WINDOWPOS.sizeof);\n    }\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_WINDOWPOSCHANGING(int wParam, int lParam)"
		},
		"void forceResize()":{
			"methodBody":"{\n\n}",
			"comments":"/* Do nothing */\n",
			"methodName":"void forceResize()"
		},
		"TCHAR windowClass()":{
			"methodBody":"{\n    if (OS.IsSP)\n        return DialogClass;\n    if ((style & SWT.TOOL) != 0) {\n        int trim = SWT.TITLE | SWT.CLOSE | SWT.MIN | SWT.MAX | SWT.BORDER | SWT.RESIZE;\n        if ((style & trim) == 0)\n            return display.windowShadowClass;\n    }\n    return parent != null ? DialogClass : super.windowClass();\n}",
			"comments":"",
			"methodName":"TCHAR windowClass()"
		},
		"public void dispose()":{
			"methodBody":"{\n    \n    \n    \n    \n    \n    \n    \n    \n    super.dispose();\n\n\n}",
			"comments":"/*\n* This code is intentionally commented.  On some\n* platforms, the owner window is repainted right\n* away when a dialog window exits.  This behavior\n* is currently unspecified.\n*/\n//\t/*\n//\t* Note:  It is valid to attempt to dispose a widget\n//\t* more than once.  If this happens, fail silently.\n//\t*/\n//\tif (!isValidWidget ()) return;\n//\tif (!isValidThread ()) error (SWT.ERROR_THREAD_INVALID_ACCESS);\n//\tDisplay oldDisplay = display;\n// widget is disposed at this point\n//\tif (oldDisplay != null) oldDisplay.update ();\n",
			"methodName":"public void dispose()"
		},
		"LRESULT WM_MOUSEACTIVATE(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_MOUSEACTIVATE(wParam, lParam);\n    if (result != null)\n        return result;\n    \n    int hittest = (short) (lParam & 0xFFFF);\n    switch(hittest) {\n        case OS.HTERROR:\n        case OS.HTTRANSPARENT:\n        case OS.HTNOWHERE:\n            break;\n        default:\n            {\n                Control control = display._getFocusControl();\n                if (control != null) {\n                    Decorations decorations = control.menuShell();\n                    if (decorations.getShell() == this && decorations != this) {\n                        display.ignoreRestoreFocus = true;\n                        display.lastHittest = hittest;\n                        display.lastHittestControl = null;\n                        if (hittest == OS.HTMENU || hittest == OS.HTSYSMENU) {\n                            display.lastHittestControl = control;\n                            return null;\n                        }\n                        if (OS.IsWin95 && hittest == OS.HTCAPTION) {\n                            display.lastHittestControl = control;\n                        }\n                        return new LRESULT(OS.MA_NOACTIVATE);\n                    }\n                }\n            }\n    }\n    if (hittest == OS.HTMENU)\n        return null;\n    \n    POINT pt = new POINT();\n    if (!OS.GetCursorPos(pt)) {\n        int pos = OS.GetMessagePos();\n        pt.x = (short) (pos & 0xFFFF);\n        pt.y = (short) (pos >> 16);\n    }\n    int hwnd = OS.WindowFromPoint(pt);\n    if (hwnd == 0)\n        return null;\n    Control control = display.findControl(hwnd);\n    \n    if (control != null && (control.state & CANVAS) != 0) {\n        if ((control.style & SWT.NO_FOCUS) != 0) {\n            int bits = SWT.ON_TOP | SWT.NO_FOCUS;\n            if ((style & bits) == bits) {\n                if (hittest == OS.HTBORDER || hittest == OS.HTCLIENT) {\n                    return new LRESULT(OS.MA_NOACTIVATE);\n                }\n            }\n        }\n    }\n    setActiveControl(control);\n    return null;\n}",
			"comments":"/*\n* Check for WM_MOUSEACTIVATE when an MDI shell is active\n* and stop the normal shell activation but allow the mouse\n* down to be delivered.\n*/\n/*\n* Get the current location of the cursor,\n* not the location of the cursor when the\n* WM_MOUSEACTIVATE was generated.  This is\n* strictly incorrect but is necessary in\n* order to support Activate and Deactivate\n* events for embedded widgets that have\n* their own event loop.  In that case, the\n* cursor location reported by GetMessagePos\n* is the one for our event loop, not the\n* embedded widget's event loop.\n*/\n/*\n* When a shell is created with SWT.ON_TOP and SWT.NO_FOCUS,\n* do not activate the shell when the user clicks on the\n* the client area or on the border or a control within the\n* shell that does not take focus.\n*/\n",
			"methodName":"LRESULT WM_MOUSEACTIVATE(int wParam, int lParam)"
		},
		"int hwndMDIClient()":{
			"methodBody":"{\n    if (hwndMDIClient == 0) {\n        int widgetStyle = OS.MDIS_ALLCHILDSTYLES | OS.WS_CHILD | OS.WS_CLIPCHILDREN | OS.WS_CLIPSIBLINGS;\n        hwndMDIClient = OS.CreateWindowEx(0, new TCHAR(0, \"MDICLIENT\", true), null, widgetStyle, 0, 0, 0, 0, handle, 0, OS.GetModuleHandle(null), new CREATESTRUCT());\n    \n    }\n    return hwndMDIClient;\n}",
			"comments":"//\t\tOS.ShowWindow (hwndMDIClient, OS.SW_SHOW);\n",
			"methodName":"int hwndMDIClient()"
		},
		"CREATESTRUCT widgetCreateStruct()":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"CREATESTRUCT widgetCreateStruct()"
		},
		"public static Shell win32_new(Display display, int handle)":{
			"methodBody":"{\n    return new Shell(display, null, SWT.NO_TRIM, handle);\n}",
			"comments":"/**\n* Invokes platform specific functionality to allocate a new shell.\n* <p>\n* <b>IMPORTANT:</b> This method is <em>not</em> part of the public\n* API for <code>Shell</code>. It is marked public only so that it\n* can be shared within the packages provided by SWT. It is not\n* available on all platforms, and should never be called from\n* application code.\n* </p>\n*\n* @param display the display for the shell\n* @param handle the handle for the shell\n* @return a new shell object containing the specified display and handle\n*/\n",
			"methodName":"public static Shell win32_new(Display display, int handle)"
		},
		"LRESULT WM_DESTROY(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_DESTROY(wParam, lParam);\n    \n    int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n    if ((bits & OS.WS_CHILD) != 0) {\n        releaseChild();\n        releaseResources();\n    }\n    return result;\n}",
			"comments":"/*\n* When the shell is a WS_CHILD window of a non-SWT\n* window, the destroy code does not get called because\n* the non-SWT window does not call dispose ().  Instead,\n* the destroy code is called here in WM_DESTROY.\n*/\n",
			"methodName":"LRESULT WM_DESTROY(int wParam, int lParam)"
		},
		"void releaseWidget()":{
			"methodBody":"{\n    releaseShells();\n    super.releaseWidget();\n    activeMenu = null;\n    display.clearModal(this);\n    if (lpstrTip != 0) {\n        int hHeap = OS.GetProcessHeap();\n        OS.HeapFree(hHeap, 0, lpstrTip);\n    }\n    lpstrTip = 0;\n    toolTipHandle = 0;\n    if (brushes != null) {\n        for (int i = 0; i < brushes.length; i++) {\n            int hBrush = brushes[i];\n            if (hBrush != 0)\n                OS.DeleteObject(hBrush);\n        }\n    }\n    brushes = null;\n    if (OS.IsDBLocale) {\n        if (hIMC != 0)\n            OS.ImmDestroyContext(hIMC);\n    }\n    lastActive = null;\n    region = null;\n}",
			"comments":"",
			"methodName":"void releaseWidget()"
		},
		"LRESULT WM_QUERYNEWPALETTE(int wParam, int lParam)":{
			"methodBody":"{\n    int hPalette = display.hPalette;\n    if (hPalette != 0)\n        return selectPalette(hPalette);\n    return super.WM_QUERYNEWPALETTE(wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_QUERYNEWPALETTE(int wParam, int lParam)"
		},
		"public void setRegion(Region region)":{
			"methodBody":"{\n    checkWidget();\n    if ((style & SWT.NO_TRIM) == 0)\n        return;\n    if (region != null && region.isDisposed())\n        error(SWT.ERROR_INVALID_ARGUMENT);\n    int hRegion = 0;\n    if (region != null) {\n        hRegion = OS.CreateRectRgn(0, 0, 0, 0);\n        OS.CombineRgn(hRegion, region.handle, hRegion, OS.RGN_OR);\n    }\n    OS.SetWindowRgn(handle, hRegion, true);\n    this.region = region;\n}",
			"comments":"/**\n* Sets the shape of the shell to the region specified\n* by the argument.  When the argument is null, the\n* default shape of the shell is restored.  The shell\n* must be created with the style SWT.NO_TRIM in order\n* to specify a region.\n*\n* @param region the region that defines the shape of the shell (or null)\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the region has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.0\n*\n*/\n",
			"methodName":"public void setRegion(Region region)"
		},
		"LRESULT WM_ACTIVATE(int wParam, int lParam)":{
			"methodBody":"{\n    if (OS.IsPPC) {\n        \n        if (hooks(SWT.HardKeyDown) || hooks(SWT.HardKeyUp)) {\n            int fActive = wParam & 0xFFFF;\n            int hwnd = fActive != 0 ? handle : 0;\n            for (int bVk = OS.VK_APP1; bVk <= OS.VK_APP6; bVk++) {\n                OS.SHSetAppKeyWndAssoc((byte) bVk, hwnd);\n            }\n        }\n        \n        if ((wParam & 0xFFFF) != 0) {\n            OS.SHSipPreference(handle, psai.fSipUp == 0 ? OS.SIP_DOWN : OS.SIP_UP);\n        }\n    }\n    \n    if (OS.WIN32_VERSION >= OS.VERSION(5, 1)) {\n        if ((wParam & 0xFFFF) == 0 && OS.IsDBLocale && hIMC != 0) {\n            if (OS.ImmGetOpenStatus(hIMC)) {\n                OS.ImmSetOpenStatus(hIMC, false);\n                OS.ImmSetOpenStatus(hIMC, true);\n            }\n        }\n    }\n    LRESULT result = super.WM_ACTIVATE(wParam, lParam);\n    if (parent != null)\n        return LRESULT.ZERO;\n    return result;\n}",
			"comments":"/*\n* Note: this does not work when we get WM_ACTIVATE prior\n* to adding a listener.\n*/\n/* Restore SIP state when window is activated */\n/*\n* Bug in Windows XP.  When a Shell is deactivated, the\n* IME composition window does not go away. This causes\n* repaint issues.  The fix is to close the IME to cause\n* the composition string to be committed.\n*\n* Note. The IME needs to be reopened in order to preserve\n* the input method status.\n*/\n",
			"methodName":"LRESULT WM_ACTIVATE(int wParam, int lParam)"
		},
		"void setParent()":{
			"methodBody":"{\n\n}",
			"comments":"/* Do nothing.  Not necessary for Shells */\n",
			"methodName":"void setParent()"
		},
		"int callWindowProc(int hwnd, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    if (handle == 0)\n        return 0;\n    if ((style & SWT.TOOL) != 0) {\n        int trim = SWT.TITLE | SWT.CLOSE | SWT.MIN | SWT.MAX | SWT.BORDER | SWT.RESIZE;\n        if ((style & trim) == 0)\n            return OS.DefWindowProc(hwnd, msg, wParam, lParam);\n    }\n    if (parent != null) {\n        switch(msg) {\n            case OS.WM_KILLFOCUS:\n            case OS.WM_SETFOCUS:\n                return OS.DefWindowProc(hwnd, msg, wParam, lParam);\n        }\n        return OS.CallWindowProc(DialogProc, hwnd, msg, wParam, lParam);\n    }\n    if (hwndMDIClient != 0) {\n        return OS.DefFrameProc(hwnd, hwndMDIClient, msg, wParam, lParam);\n    }\n    return OS.DefWindowProc(hwnd, msg, wParam, lParam);\n}",
			"comments":"",
			"methodName":"int callWindowProc(int hwnd, int msg, int wParam, int lParam)"
		},
		"public Point getMinimumSize()":{
			"methodBody":"{\n    checkWidget();\n    int width = Math.max(0, minWidth);\n    int trim = SWT.TITLE | SWT.CLOSE | SWT.MIN | SWT.MAX;\n    if ((style & SWT.NO_TRIM) == 0 && (style & trim) != 0) {\n        width = Math.max(width, OS.GetSystemMetrics(OS.SM_CXMINTRACK));\n    }\n    int height = Math.max(0, minHeight);\n    if ((style & SWT.NO_TRIM) == 0 && (style & trim) != 0) {\n        if ((style & SWT.RESIZE) != 0) {\n            height = Math.max(height, OS.GetSystemMetrics(OS.SM_CYMINTRACK));\n        } else {\n            RECT rect = new RECT();\n            int bits1 = OS.GetWindowLong(handle, OS.GWL_STYLE);\n            int bits2 = OS.GetWindowLong(handle, OS.GWL_EXSTYLE);\n            OS.AdjustWindowRectEx(rect, bits1, false, bits2);\n            height = Math.max(height, rect.bottom - rect.top);\n        }\n    }\n    return new Point(width, height);\n}",
			"comments":"/**\n* Returns a point describing the minimum receiver's size. The\n* x coordinate of the result is the minimum width of the receiver.\n* The y coordinate of the result is the minimum height of the\n* receiver.\n*\n* @return the receiver's size\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public Point getMinimumSize()"
		},
		"boolean traverseEscape()":{
			"methodBody":"{\n    if (parent == null)\n        return false;\n    if (!isVisible() || !isEnabled())\n        return false;\n    close();\n    return true;\n}",
			"comments":"",
			"methodName":"boolean traverseEscape()"
		},
		"void fixShell(Shell newShell, Control control)":{
			"methodBody":"{\n    if (this == newShell)\n        return;\n    if (control == lastActive)\n        setActiveControl(null);\n    if (toolTipHandle != 0) {\n        setToolTipText(control.handle, null);\n    }\n    newShell.setToolTipText(control.handle, control.toolTipText);\n}",
			"comments":"",
			"methodName":"void fixShell(Shell newShell, Control control)"
		}
	},
	"ClassORInterfaceName":[
		"Shell"
	]
}
