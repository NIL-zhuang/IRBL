{
	"variables":[
		"display",
		"iDataObject",
		"refCount",
		"transferAgents",
		"data",
		"CFSTR_PREFERREDDROPEFFECT",
		"chFormatName",
		"name",
		"validName",
		"display",
		"ppv",
		"retryCount",
		"result",
		"msg",
		"dataObject",
		"allowed",
		"i",
		"data",
		"i",
		"result",
		"retryCount",
		"msg",
		"allowedDataTypes",
		"i",
		"formats",
		"newAllowedDataTypes",
		"enumFORMATETC",
		"formats",
		"i",
		"dropeffect",
		"transferData",
		"stgmedium",
		"transferIndex",
		"i",
		"transferData",
		"i",
		"guid",
		"types",
		"data",
		"i",
		"types",
		"names",
		"maxSize",
		"i",
		"buffer",
		"size",
		"types",
		"ppv",
		"dataObject",
		"ppFormatetc",
		"rc",
		"enumFormatetc",
		"rgelt",
		"pceltFetched",
		"formatetc",
		"newTypes",
		"display",
		"display",
		"Display",
		"display",
		"display",
		"Display",
		"display",
		"Thread",
		"DND",
		"SWT",
		"display",
		"CFSTR_PREFERREDDROPEFFECT",
		"OS",
		"chFormatName",
		"validName",
		"name",
		"DND",
		"SWT",
		"display",
		"DND",
		"SWT",
		"display",
		"Thread",
		"DND",
		"SWT",
		"display",
		"DND",
		"SWT",
		"DND",
		"clipboards",
		"DND",
		"COM",
		"COM",
		"COM",
		"display",
		"Thread",
		"DND",
		"SWT",
		"COM",
		"COM",
		"COM",
		"display",
		"transfer",
		"DND",
		"transfer",
		"DND",
		"SWT",
		"clipboards",
		"DND",
		"COM",
		"ppv",
		"result",
		"COM",
		"retryCount",
		"Thread",
		"OS",
		"msg",
		"OS",
		"OS",
		"result",
		"COM",
		"ppv",
		"result",
		"COM",
		"ppv",
		"transfer",
		"i",
		"allowed",
		"i",
		"dataObject",
		"allowed",
		"i",
		"COM",
		"allowed",
		"i",
		"data",
		"ppv",
		"transfer",
		"data",
		"dataObject",
		"display",
		"data",
		"dataTypes",
		"DND",
		"data",
		"dataTypes",
		"data",
		"dataTypes",
		"data",
		"DND",
		"SWT",
		"i",
		"data",
		"i",
		"data",
		"i",
		"dataTypes",
		"i",
		"dataTypes",
		"i",
		"data",
		"i",
		"DND",
		"SWT",
		"clipboards",
		"DND",
		"data",
		"dataTypes",
		"COM",
		"iDataObject",
		"result",
		"COM",
		"retryCount",
		"Thread",
		"OS",
		"msg",
		"OS",
		"OS",
		"result",
		"COM",
		"iDataObject",
		"result",
		"COM",
		"DND",
		"DND",
		"refCount",
		"refCount",
		"iDataObject",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"iDataObject",
		"iDataObject",
		"iDataObject",
		"dwDirection",
		"COM",
		"COM",
		"i",
		"transferAgents",
		"i",
		"transferAgents",
		"i",
		"allowedDataTypes",
		"formats",
		"System",
		"allowedDataTypes",
		"newAllowedDataTypes",
		"allowedDataTypes",
		"System",
		"formats",
		"newAllowedDataTypes",
		"allowedDataTypes",
		"formats",
		"allowedDataTypes",
		"newAllowedDataTypes",
		"enumFORMATETC",
		"allowedDataTypes",
		"i",
		"allowedDataTypes",
		"i",
		"formats",
		"i",
		"allowedDataTypes",
		"i",
		"dropeffect",
		"CFSTR_PREFERREDDROPEFFECT",
		"dropeffect",
		"COM",
		"dropeffect",
		"dropeffect",
		"COM",
		"formats",
		"formats",
		"dropeffect",
		"enumFORMATETC",
		"formats",
		"OS",
		"ppenumFormatetc",
		"enumFORMATETC",
		"COM",
		"pFormatetc",
		"pmedium",
		"COM",
		"pFormatetc",
		"COM",
		"COM",
		"transferData",
		"COM",
		"transferData",
		"pFormatetc",
		"FORMATETC",
		"transferData",
		"transferData",
		"transferData",
		"transferData",
		"COM",
		"transferData",
		"CFSTR_PREFERREDDROPEFFECT",
		"stgmedium",
		"COM",
		"stgmedium",
		"OS",
		"COM",
		"COM",
		"OS",
		"stgmedium",
		"COM",
		"stgmedium",
		"COM",
		"pmedium",
		"stgmedium",
		"STGMEDIUM",
		"COM",
		"i",
		"transferAgents",
		"i",
		"transferAgents",
		"i",
		"transferData",
		"transferIndex",
		"i",
		"transferIndex",
		"COM",
		"transferAgents",
		"transferIndex",
		"data",
		"transferIndex",
		"transferData",
		"COM",
		"pmedium",
		"transferData",
		"STGMEDIUM",
		"transferData",
		"transferAgents",
		"COM",
		"transferData",
		"COM",
		"transferData",
		"pFormatetc",
		"FORMATETC",
		"transferData",
		"transferData",
		"transferData",
		"CFSTR_PREFERREDDROPEFFECT",
		"COM",
		"i",
		"transferAgents",
		"i",
		"transferAgents",
		"i",
		"transferData",
		"COM",
		"COM",
		"riid",
		"ppvObject",
		"COM",
		"COM",
		"guid",
		"riid",
		"GUID",
		"COM",
		"guid",
		"COM",
		"COM",
		"guid",
		"COM",
		"OS",
		"ppvObject",
		"iDataObject",
		"COM",
		"OS",
		"ppvObject",
		"COM",
		"refCount",
		"refCount",
		"COM",
		"refCount",
		"DND",
		"clipboards",
		"DND",
		"types",
		"i",
		"types",
		"i",
		"data",
		"i",
		"data",
		"i",
		"types",
		"i",
		"data",
		"i",
		"types",
		"i",
		"data",
		"types",
		"i",
		"types",
		"i",
		"maxSize",
		"OS",
		"types",
		"i",
		"buffer",
		"maxSize",
		"size",
		"names",
		"i",
		"buffer",
		"size",
		"types",
		"i",
		"COM",
		"names",
		"i",
		"COM",
		"names",
		"i",
		"COM",
		"names",
		"i",
		"COM",
		"names",
		"i",
		"COM",
		"names",
		"i",
		"COM",
		"names",
		"i",
		"COM",
		"names",
		"i",
		"COM",
		"names",
		"i",
		"COM",
		"names",
		"i",
		"COM",
		"names",
		"i",
		"COM",
		"names",
		"i",
		"COM",
		"names",
		"i",
		"COM",
		"names",
		"i",
		"COM",
		"names",
		"i",
		"COM",
		"names",
		"i",
		"COM",
		"names",
		"i",
		"COM",
		"names",
		"i",
		"names",
		"i",
		"names",
		"COM",
		"ppv",
		"COM",
		"types",
		"ppv",
		"dataObject",
		"COM",
		"ppFormatetc",
		"dataObject",
		"rc",
		"COM",
		"types",
		"ppFormatetc",
		"OS",
		"OS",
		"OS",
		"FORMATETC",
		"enumFormatetc",
		"enumFormatetc",
		"rgelt",
		"pceltFetched",
		"COM",
		"pceltFetched",
		"COM",
		"formatetc",
		"rgelt",
		"FORMATETC",
		"types",
		"System",
		"types",
		"newTypes",
		"types",
		"newTypes",
		"types",
		"formatetc",
		"types",
		"newTypes",
		"OS",
		"rgelt",
		"enumFormatetc",
		"types",
		"ERROR_THREAD_INVALID_ACCESS",
		"display",
		"ERROR_INVALID_SUBCLASS",
		"display",
		"ERROR_WIDGET_DISPOSED",
		"ERROR_THREAD_INVALID_ACCESS",
		"ERROR_WIDGET_DISPOSED",
		"CLIPBOARD",
		"CLIPBOARD",
		"iDataObject",
		"S_OK",
		"ERROR_THREAD_INVALID_ACCESS",
		"iDataObject",
		"S_OK",
		"CLIPBOARD",
		"ERROR_NULL_ARGUMENT",
		"CLIPBOARD",
		"S_OK",
		"PM_NOREMOVE",
		"PM_NOYIELD",
		"S_OK",
		"length",
		"formatetc",
		"S_OK",
		"pIDataObject",
		"CLIPBOARD",
		"length",
		"length",
		"length",
		"ERROR_INVALID_ARGUMENT",
		"length",
		"ERROR_INVALID_ARGUMENT",
		"CLIPBOARD",
		"data",
		"transferAgents",
		"S_OK",
		"PM_NOREMOVE",
		"PM_NOYIELD",
		"S_OK",
		"ERROR_CANNOT_SET_CLIPBOARD",
		"DATADIR_SET",
		"E_NOTIMPL",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"formatetc",
		"cfFormat",
		"dwAspect",
		"DVASPECT_CONTENT",
		"lindex",
		"tymed",
		"TYMED_HGLOBAL",
		"length",
		"S_OK",
		"E_INVALIDARG",
		"S_OK",
		"DV_E_FORMATETC",
		"formatetc",
		"formatetc",
		"sizeof",
		"type",
		"cfFormat",
		"formatetc",
		"stgmedium",
		"result",
		"E_FAIL",
		"type",
		"tymed",
		"TYMED_HGLOBAL",
		"unionField",
		"GMEM_FIXED",
		"GMEM_ZEROINIT",
		"unionField",
		"DROPEFFECT_COPY",
		"pUnkForRelease",
		"sizeof",
		"S_OK",
		"length",
		"DV_E_FORMATETC",
		"stgmedium",
		"sizeof",
		"result",
		"E_FAIL",
		"formatetc",
		"formatetc",
		"sizeof",
		"type",
		"cfFormat",
		"formatetc",
		"type",
		"S_OK",
		"length",
		"S_OK",
		"DV_E_FORMATETC",
		"E_INVALIDARG",
		"sizeof",
		"IIDIUnknown",
		"IIDIDataObject",
		"S_OK",
		"E_NOINTERFACE",
		"data",
		"transferAgents",
		"CLIPBOARD",
		"CLIPBOARD",
		"length",
		"length",
		"type",
		"cfFormat",
		"formatetc",
		"length",
		"length",
		"cfFormat",
		"cfFormat",
		"CF_HDROP",
		"CF_TEXT",
		"CF_BITMAP",
		"CF_METAFILEPICT",
		"CF_SYLK",
		"CF_DIF",
		"CF_TIFF",
		"CF_OEMTEXT",
		"CF_DIB",
		"CF_PALETTE",
		"CF_PENDATA",
		"CF_RIFF",
		"CF_WAVE",
		"CF_UNICODETEXT",
		"CF_ENHMETAFILE",
		"CF_LOCALE",
		"CF_MAX",
		"S_OK",
		"DATADIR_GET",
		"S_OK",
		"GMEM_FIXED",
		"GMEM_ZEROINIT",
		"sizeof",
		"S_OK",
		"sizeof",
		"length",
		"length",
		"length",
		"display",
		"clipboards",
		"transfer",
		"transfer",
		"clipboards",
		"t",
		"data",
		"dataTypes",
		"data",
		"dataTypes",
		"clipboards",
		"t",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"dwDirection",
		"ppenumFormatetc",
		"pFormatetc",
		"pmedium",
		"pFormatetc",
		"riid",
		"ppvObject",
		"clipboards"
	],
	"extendORImplementFiles":[],
	"package":[
		"org.eclipse.swt.dnd"
	],
	"import":[
		"org.eclipse.swt",
		"org.eclipse.swt.widgets",
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt.internal.ole.win32"
	],
	"methods":[
		"checkSubclass",
		"checkWidget",
		"clearContents",
		"clearContents",
		"dispose",
		"getContents",
		"getContents",
		"isDisposed",
		"setContents",
		"setContents",
		"AddRef",
		"createCOMInterfaces",
		"method0",
		"method1",
		"method2",
		"method3",
		"method5",
		"method8",
		"disposeCOMInterfaces",
		"EnumFormatEtc",
		"GetData",
		"QueryGetData",
		"QueryInterface",
		"Release",
		"getAvailableTypes",
		"getAvailableTypes",
		"getAvailableTypeNames",
		"_getAvailableTypes",
		"checkSubclass",
		"getCurrent",
		"getDefault",
		"getThread",
		"currentThread",
		"error",
		"RegisterClipboardFormat",
		"createCOMInterfaces",
		"AddRef",
		"getName",
		"getClass",
		"getName",
		"equals",
		"error",
		"error",
		"getThread",
		"currentThread",
		"error",
		"isDisposed",
		"error",
		"clearContents",
		"checkWidget",
		"OleIsCurrentClipboard",
		"getAddress",
		"OleSetClipboard",
		"isDisposed",
		"getThread",
		"currentThread",
		"error",
		"OleIsCurrentClipboard",
		"getAddress",
		"OleFlushClipboard",
		"Release",
		"getContents",
		"checkWidget",
		"error",
		"OleGetClipboard",
		"sleep",
		"PeekMessage",
		"OleGetClipboard",
		"getSupportedTypes",
		"QueryGetData",
		"nativeToJava",
		"Release",
		"setContents",
		"checkWidget",
		"error",
		"validate",
		"error",
		"OleSetClipboard",
		"getAddress",
		"sleep",
		"PeekMessage",
		"OleSetClipboard",
		"getAddress",
		"error",
		"QueryInterface",
		"AddRef",
		"Release",
		"GetData",
		"QueryGetData",
		"EnumFormatEtc",
		"dispose",
		"getSupportedTypes",
		"arraycopy",
		"arraycopy",
		"AddRef",
		"setFormats",
		"MoveMemory",
		"getAddress",
		"QueryGetData",
		"MoveMemory",
		"GlobalAlloc",
		"MoveMemory",
		"MoveMemory",
		"isSupportedType",
		"javaToNative",
		"MoveMemory",
		"MoveMemory",
		"isSupportedType",
		"MoveMemory",
		"IsEqualGUID",
		"IsEqualGUID",
		"MoveMemory",
		"getAddress",
		"AddRef",
		"MoveMemory",
		"disposeCOMInterfaces",
		"CoFreeUnusedLibraries",
		"getAvailableTypes",
		"checkWidget",
		"_getAvailableTypes",
		"checkWidget",
		"_getAvailableTypes",
		"GetClipboardFormatName",
		"toString",
		"OleGetClipboard",
		"EnumFormatEtc",
		"Release",
		"GlobalAlloc",
		"Reset",
		"Next",
		"MoveMemory",
		"arraycopy",
		"GlobalFree",
		"Release",
		"TCHAR",
		"MSG",
		"IDataObject",
		"MSG",
		"COMObject",
		"OleEnumFORMATETC",
		"FORMATETC",
		"TransferData",
		"FORMATETC",
		"STGMEDIUM",
		"STGMEDIUM",
		"TransferData",
		"FORMATETC",
		"GUID",
		"TransferData",
		"TCHAR",
		"IDataObject",
		"IEnumFORMATETC",
		"FORMATETC"
	],
	"methodsBody":{
		"public String[] getAvailableTypeNames()":{
			"methodBody":"{\n    checkWidget();\n    FORMATETC[] types = _getAvailableTypes();\n    String[] names = new String[types.length];\n    int maxSize = 128;\n    for (int i = 0; i < types.length; i++) {\n        TCHAR buffer = new TCHAR(0, maxSize);\n        int size = OS.GetClipboardFormatName(types[i].cfFormat, buffer, maxSize);\n        if (size != 0) {\n            names[i] = buffer.toString(0, size);\n        } else {\n            switch(types[i].cfFormat) {\n                \n                case COM.CF_HDROP:\n                    names[i] = \"CF_HDROP\";\n                    break;\n                \n                case COM.CF_TEXT:\n                    names[i] = \"CF_TEXT\";\n                    break;\n                \n                case COM.CF_BITMAP:\n                    names[i] = \"CF_BITMAP\";\n                    break;\n                \n                case COM.CF_METAFILEPICT:\n                    names[i] = \"CF_METAFILEPICT\";\n                    break;\n                \n                case COM.CF_SYLK:\n                    names[i] = \"CF_SYLK\";\n                    break;\n                \n                case COM.CF_DIF:\n                    names[i] = \"CF_DIF\";\n                    break;\n                \n                case COM.CF_TIFF:\n                    names[i] = \"CF_TIFF\";\n                    break;\n                \n                case COM.CF_OEMTEXT:\n                    names[i] = \"CF_OEMTEXT\";\n                    break;\n                \n                case COM.CF_DIB:\n                    names[i] = \"CF_DIB\";\n                    break;\n                \n                case COM.CF_PALETTE:\n                    names[i] = \"CF_PALETTE\";\n                    break;\n                \n                case COM.CF_PENDATA:\n                    names[i] = \"CF_PENDATA\";\n                    break;\n                \n                case COM.CF_RIFF:\n                    names[i] = \"CF_RIFF\";\n                    break;\n                \n                case COM.CF_WAVE:\n                    names[i] = \"CF_WAVE\";\n                    break;\n                \n                case COM.CF_UNICODETEXT:\n                    names[i] = \"CF_UNICODETEXT\";\n                    break;\n                \n                case COM.CF_ENHMETAFILE:\n                    names[i] = \"CF_ENHMETAFILE\";\n                    break;\n                \n                case COM.CF_LOCALE:\n                    names[i] = \"CF_LOCALE\";\n                    break;\n                \n                case COM.CF_MAX:\n                    names[i] = \"CF_MAX\";\n                    break;\n                \n                default:\n                    names[i] = \"UNKNOWN\";\n            }\n        }\n    }\n    return names;\n}",
			"comments":"/**\n* Returns a platform specific list of the data types currently available on the\n* system clipboard.\n*\n* <p>Note: <code>getAvailableTypeNames</code> is a utility for writing a Transfer\n* sub-class.  It should NOT be used within an application because it provides\n* platform specific information.</p>\n*\n* @return a platform specific list of the data types currently available on the\n* system clipboard\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n//$NON-NLS-1$\n//$NON-NLS-1$\n//$NON-NLS-1$\n//$NON-NLS-1$\n//$NON-NLS-1$\n//$NON-NLS-1$\n//$NON-NLS-1$\n//$NON-NLS-1$\n//$NON-NLS-1$\n//$NON-NLS-1$\n//$NON-NLS-1$\n//$NON-NLS-1$\n//$NON-NLS-1$\n//$NON-NLS-1$\n//$NON-NLS-1$\n//$NON-NLS-1$\n//$NON-NLS-1$\n//$NON-NLS-1$\n",
			"methodName":"public String[] getAvailableTypeNames()"
		},
		"private int EnumFormatEtc(int dwDirection, int ppenumFormatetc)":{
			"methodBody":"{\n    \n    if (dwDirection == COM.DATADIR_SET)\n        return COM.E_NOTIMPL;\n    \n    TransferData[] allowedDataTypes = new TransferData[0];\n    for (int i = 0; i < transferAgents.length; i++) {\n        TransferData[] formats = transferAgents[i].getSupportedTypes();\n        TransferData[] newAllowedDataTypes = new TransferData[allowedDataTypes.length + formats.length];\n        System.arraycopy(allowedDataTypes, 0, newAllowedDataTypes, 0, allowedDataTypes.length);\n        System.arraycopy(formats, 0, newAllowedDataTypes, allowedDataTypes.length, formats.length);\n        allowedDataTypes = newAllowedDataTypes;\n    }\n    OleEnumFORMATETC enumFORMATETC = new OleEnumFORMATETC();\n    enumFORMATETC.AddRef();\n    FORMATETC[] formats = new FORMATETC[allowedDataTypes.length + 1];\n    for (int i = 0; i < allowedDataTypes.length; i++) {\n        formats[i] = allowedDataTypes[i].formatetc;\n    }\n    \n    FORMATETC dropeffect = new FORMATETC();\n    dropeffect.cfFormat = CFSTR_PREFERREDDROPEFFECT;\n    dropeffect.dwAspect = COM.DVASPECT_CONTENT;\n    dropeffect.lindex = -1;\n    dropeffect.tymed = COM.TYMED_HGLOBAL;\n    formats[formats.length - 1] = dropeffect;\n    enumFORMATETC.setFormats(formats);\n    OS.MoveMemory(ppenumFormatetc, new int[] { enumFORMATETC.getAddress() }, 4);\n    return COM.S_OK;\n}",
			"comments":"// only allow getting of data - SetData is not currently supported\n// what types have been registered?\n// include the drop effect format to specify a copy operation\n",
			"methodName":"private int EnumFormatEtc(int dwDirection, int ppenumFormatetc)"
		},
		"protected void checkWidget()":{
			"methodBody":"{\n    Display display = this.display;\n    if (display == null)\n        DND.error(SWT.ERROR_WIDGET_DISPOSED);\n    if (display.getThread() != Thread.currentThread())\n        DND.error(SWT.ERROR_THREAD_INVALID_ACCESS);\n    if (display.isDisposed())\n        DND.error(SWT.ERROR_WIDGET_DISPOSED);\n}",
			"comments":"/**\n* Throws an <code>SWTException</code> if the receiver can not\n* be accessed by the caller. This may include both checks on\n* the state of the receiver and more generally on the entire\n* execution context. This method <em>should</em> be called by\n* widget implementors to enforce the standard SWT invariants.\n* <p>\n* Currently, it is an error to invoke any method (other than\n* <code>isDisposed()</code>) on a widget that has had its\n* <code>dispose()</code> method called. It is also an error\n* to call widget methods from any thread that is different\n* from the thread that created the widget.\n* </p><p>\n* In future releases of SWT, there may be more or fewer error\n* checks and exceptions may be thrown for different reasons.\n* </p>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"protected void checkWidget()"
		},
		"public void clearContents(int clipboards)":{
			"methodBody":"{\n    checkWidget();\n    if ((clipboards & DND.CLIPBOARD) != 0) {\n        if (COM.OleIsCurrentClipboard(this.iDataObject.getAddress()) == COM.S_OK) {\n            COM.OleSetClipboard(0);\n        }\n    }\n}",
			"comments":"/**\n* If this clipboard is currently the owner of the data on the specified\n* clipboard, clear the contents.  If this clipboard is not the owner, then\n* nothing is done.\n*\n* <p>Note that there are clipboard assistant applications that take ownership\n* of data or make copies of data when it is placed on the clipboard.  In these\n* cases, it may not be possible to clear the clipboard.</p>\n*\n* <p>The clipboards value is either one of the clipboard constants defined in\n* class <code>DND</code>, or must be built by <em>bitwise OR</em>'ing together\n* (that is, using the <code>int</code> \"|\" operator) two or more\n* of those <code>DND</code> clipboard constants.</p>\n*\n* @param clipboards to be cleared\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see DND#CLIPBOARD\n* @see DND#SELECTION_CLIPBOARD\n*\n* @since 3.1\n*/\n",
			"methodName":"public void clearContents(int clipboards)"
		},
		"public boolean isDisposed()":{
			"methodBody":"{\n    return (display == null);\n}",
			"comments":"/**\n* Returns <code>true</code> if the clipboard has been disposed,\n* and <code>false</code> otherwise.\n* <p>\n* This method gets the dispose state for the clipboard.\n* When a clipboard has been disposed, it is an error to\n* invoke any other method using the clipboard.\n* </p>\n*\n* @return <code>true</code> when the widget is disposed and <code>false</code> otherwise\n*\n* @since 3.0\n*/\n",
			"methodName":"public boolean isDisposed()"
		},
		"public void clearContents()":{
			"methodBody":"{\n    clearContents(DND.CLIPBOARD);\n}",
			"comments":"/**\n* If this clipboard is currently the owner of the data on the system clipboard,\n* clear the contents.  If this clipboard is not the owner, then nothing is done.\n* Note that there are clipboard assistant applications that take ownership of\n* data or make copies of data when it is placed on the clipboard.  In these\n* cases, it may not be possible to clear the clipboard.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public void clearContents()"
		},
		"protected void checkSubclass()":{
			"methodBody":"{\n    String name = getClass().getName();\n    String validName = Clipboard.class.getName();\n    if (!validName.equals(name)) {\n        DND.error(SWT.ERROR_INVALID_SUBCLASS);\n    }\n}",
			"comments":"/**\n* Checks that this class can be subclassed.\n* <p>\n* The SWT class library is intended to be subclassed\n* only at specific, controlled points. This method enforces this\n* rule unless it is overridden.\n* </p><p>\n* <em>IMPORTANT:</em> By providing an implementation of this\n* method that allows a subclass of a class which does not\n* normally allow subclassing to be created, the implementer\n* agrees to be fully responsible for the fact that any such\n* subclass will likely fail between SWT releases and will be\n* strongly platform specific. No support is provided for\n* user-written classes which are implemented in this fashion.\n* </p><p>\n* The ability to subclass outside of the allowed SWT classes\n* is intended purely to enable those not on the SWT development\n* team to implement patches in order to get around specific\n* limitations in advance of when those limitations can be\n* addressed by the team. Subclassing should not be attempted\n* without an intimate and detailed understanding of the hierarchy.\n* </p>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_INVALID_SUBCLASS - if this class is not an allowed subclass</li>\n* </ul>\n*/\n",
			"methodName":"protected void checkSubclass()"
		},
		"public int method5(int[] args)":{
			"methodBody":"{\n    return QueryGetData(args[0]);\n}",
			"comments":"// method4 GetDataHere - not implemented\n",
			"methodName":"public int method5(int[] args)"
		},
		"public void setContents(Object[] data, Transfer[] dataTypes)":{
			"methodBody":"{\n    setContents(data, dataTypes, DND.CLIPBOARD);\n}",
			"comments":"/**\n* Place data of the specified type on the system clipboard.  More than one type\n* of data can be placed on the system clipboard at the same time.  Setting the\n* data clears any previous data from the system clipboard, regardless of type.\n*\n* <p>NOTE: On some platforms, the data is immediately copied to the system\n* clipboard but on other platforms it is provided upon request.  As a result,\n* if the application modifes the data object it has set on the clipboard, that\n* modification may or may not be available when the data is subsequently\n* requested.</p>\n*\n* <p>The following snippet shows text and RTF text being set on the copy/paste\n* clipboard:\n* </p>\n*\n* <code><pre>\n* \tClipboard clipboard = new Clipboard(display);\n*\tString textData = \"Hello World\";\n*\tString rtfData = \"{\\\\rtf1\\\\b\\\\i Hello World}\";\n*\tTextTransfer textTransfer = TextTransfer.getInstance();\n*\tRTFTransfer rtfTransfer = RTFTransfer.getInstance();\n*\tTransfer[] transfers = new Transfer[]{textTransfer, rtfTransfer};\n*\tObject[] data = new Object[]{textData, rtfData};\n*\tclipboard.setContents(data, transfers);\n*\tclipboard.dispose();\n* </code></pre>\n*\n* @param data the data to be set in the clipboard\n* @param dataTypes the transfer agents that will convert the data to its\n* platform specific format; each entry in the data array must have a\n* corresponding dataType\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if data is null or datatypes is null\n*          or the length of data is not the same as the length of dataTypes</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*  @exception SWTError <ul>\n*    <li>ERROR_CANNOT_SET_CLIPBOARD - if the clipboard is locked or otherwise unavailable</li>\n* </ul>\n*\n* <p>NOTE: ERROR_CANNOT_SET_CLIPBOARD should be an SWTException, since it is a\n* recoverable error, but can not be changed due to backward compatability.</p>\n*/\n",
			"methodName":"public void setContents(Object[] data, Transfer[] dataTypes)"
		},
		"private void createCOMInterfaces()":{
			"methodBody":"{\n    \n    iDataObject = new COMObject(new int[] { 2, 0, 0, 2, 2, 1, 2, 3, 2, 4, 1, 1 }) {\n\n        public int method0(int[] args) {\n            return QueryInterface(args[0], args[1]);\n        }\n\n        public int method1(int[] args) {\n            return AddRef();\n        }\n\n        public int method2(int[] args) {\n            return Release();\n        }\n\n        public int method3(int[] args) {\n            return GetData(args[0], args[1]);\n        }\n\n        \n        public int method5(int[] args) {\n            return QueryGetData(args[0]);\n        }\n\n        \n        \n        public int method8(int[] args) {\n            return EnumFormatEtc(args[0], args[1]);\n        }\n    };\n}",
			"comments":"// register each of the interfaces that this object implements\n// method4 GetDataHere - not implemented\n// method6 GetCanonicalFormatEtc - not implemented\n// method7 SetData - not implemented\n// method9 DAdvise - not implemented\n// method10 DUnadvise - not implemented\n// method11 EnumDAdvise - not implemented\n",
			"methodName":"private void createCOMInterfaces()"
		},
		"private int Release()":{
			"methodBody":"{\n    refCount--;\n    if (refCount == 0) {\n        this.data = new Object[0];\n        this.transferAgents = new Transfer[0];\n        disposeCOMInterfaces();\n        COM.CoFreeUnusedLibraries();\n    }\n    return refCount;\n}",
			"comments":"",
			"methodName":"private int Release()"
		},
		"public void setContents(Object[] data, Transfer[] dataTypes, int clipboards)":{
			"methodBody":"{\n    checkWidget();\n    if (data == null || dataTypes == null || data.length != dataTypes.length || data.length == 0) {\n        DND.error(SWT.ERROR_INVALID_ARGUMENT);\n    }\n    for (int i = 0; i < data.length; i++) {\n        if (data[i] == null || dataTypes[i] == null || !dataTypes[i].validate(data[i])) {\n            DND.error(SWT.ERROR_INVALID_ARGUMENT);\n        }\n    }\n    if ((clipboards & DND.CLIPBOARD) == 0)\n        return;\n    this.data = data;\n    this.transferAgents = dataTypes;\n    int result = COM.OleSetClipboard(iDataObject.getAddress());\n    \n    int retryCount = 0;\n    while (result != COM.S_OK && retryCount++ < 10) {\n        try {\n            Thread.sleep(50);\n        } catch (Throwable t) {\n        }\n        MSG msg = new MSG();\n        OS.PeekMessage(msg, 0, 0, 0, OS.PM_NOREMOVE | OS.PM_NOYIELD);\n        result = COM.OleSetClipboard(iDataObject.getAddress());\n    }\n    if (result != COM.S_OK) {\n        DND.error(DND.ERROR_CANNOT_SET_CLIPBOARD);\n    }\n}",
			"comments":"/**\n* Place data of the specified type on the specified clipboard.  More than one\n* type of data can be placed on the specified clipboard at the same time.\n* Setting the data clears any previous data from the specified\n* clipboard, regardless of type.\n*\n* <p>NOTE: On some platforms, the data is immediately copied to the specified\n* clipboard but on other platforms it is provided upon request.  As a result,\n* if the application modifes the data object it has set on the clipboard, that\n* modification may or may not be available when the data is subsequently\n* requested.</p>\n*\n* <p>The clipboards value is either one of the clipboard constants defined in\n* class <code>DND</code>, or must be built by <em>bitwise OR</em>'ing together\n* (that is, using the <code>int</code> \"|\" operator) two or more\n* of those <code>DND</code> clipboard constants.</p>\n*\n* <p>The following snippet shows text and RTF text being set on the copy/paste\n* clipboard:\n* </p>\n*\n* <code><pre>\n* \tClipboard clipboard = new Clipboard(display);\n*\tString textData = \"Hello World\";\n*\tString rtfData = \"{\\\\rtf1\\\\b\\\\i Hello World}\";\n*\tTextTransfer textTransfer = TextTransfer.getInstance();\n*\tRTFTransfer rtfTransfer = RTFTransfer.getInstance();\n*\tTransfer[] transfers = new Transfer[]{textTransfer, rtfTransfer};\n*\tObject[] data = new Object[]{textData, rtfData};\n*\tclipboard.setContents(data, transfers, DND.CLIPBOARD);\n*\tclipboard.dispose();\n* </code></pre>\n*\n* @param data the data to be set in the clipboard\n* @param dataTypes the transfer agents that will convert the data to its\n* platform specific format; each entry in the data array must have a\n* corresponding dataType\n* @param clipboards on which to set the data\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if data is null or datatypes is null\n*          or the length of data is not the same as the length of dataTypes</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*  @exception SWTError <ul>\n*    <li>ERROR_CANNOT_SET_CLIPBOARD - if the clipboard is locked or otherwise unavailable</li>\n* </ul>\n*\n* <p>NOTE: ERROR_CANNOT_SET_CLIPBOARD should be an SWTException, since it is a\n* recoverable error, but can not be changed due to backward compatability.</p>\n*\n* @see DND#CLIPBOARD\n* @see DND#SELECTION_CLIPBOARD\n*\n* @since 3.1\n*/\n/*\n* Bug in Windows. When a new application takes control\n* of the clipboard, other applications may open the\n* clipboard to determine if they want to record the\n* clipoard updates.  When this happens, the clipboard\n* can not be flushed until the other application is\n* finished.  To allow other applications to get the\n* data, use PeekMessage() to enable cross thread\n* message sends.\n*/\n",
			"methodName":"public void setContents(Object[] data, Transfer[] dataTypes, int clipboards)"
		},
		"public Object getContents(Transfer transfer)":{
			"methodBody":"{\n    return getContents(transfer, DND.CLIPBOARD);\n}",
			"comments":"/**\n* Retrieve the data of the specified type currently available on the system\n* clipboard.  Refer to the specific subclass of <code>Transfer</code> to\n* determine the type of object returned.\n*\n* <p>The following snippet shows text and RTF text being retrieved from the\n* clipboard:</p>\n*\n*    <code><pre>\n*    Clipboard clipboard = new Clipboard(display);\n*    TextTransfer textTransfer = TextTransfer.getInstance();\n*    String textData = (String)clipboard.getContents(textTransfer);\n*    if (textData != null) System.out.println(\"Text is \"+textData);\n*    RTFTransfer rtfTransfer = RTFTransfer.getInstance();\n*    String rtfData = (String)clipboard.getContents(rtfTransfer);\n*    if (rtfData != null) System.out.println(\"RTF Text is \"+rtfData);\n*    clipboard.dispose();\n*    </code></pre>\n*\n* @param transfer the transfer agent for the type of data being requested\n* @return the data obtained from the clipboard or null if no data of this type is available\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if transfer is null</li>\n* </ul>\n*\n* @see Transfer\n*/\n",
			"methodName":"public Object getContents(Transfer transfer)"
		},
		"public Object getContents(Transfer transfer, int clipboards)":{
			"methodBody":"{\n    checkWidget();\n    if (transfer == null)\n        DND.error(SWT.ERROR_NULL_ARGUMENT);\n    if ((clipboards & DND.CLIPBOARD) == 0)\n        return null;\n    \n    int[] ppv = new int[1];\n    int retryCount = 0;\n    int result = COM.OleGetClipboard(ppv);\n    while (result != COM.S_OK && retryCount++ < 10) {\n        try {\n            Thread.sleep(50);\n        } catch (Throwable t) {\n        }\n        MSG msg = new MSG();\n        OS.PeekMessage(msg, 0, 0, 0, OS.PM_NOREMOVE | OS.PM_NOYIELD);\n        result = COM.OleGetClipboard(ppv);\n    }\n    if (result != COM.S_OK)\n        return null;\n    IDataObject dataObject = new IDataObject(ppv[0]);\n    try {\n        TransferData[] allowed = transfer.getSupportedTypes();\n        for (int i = 0; i < allowed.length; i++) {\n            if (dataObject.QueryGetData(allowed[i].formatetc) == COM.S_OK) {\n                TransferData data = allowed[i];\n                data.pIDataObject = ppv[0];\n                return transfer.nativeToJava(data);\n            }\n        }\n    } finally {\n        dataObject.Release();\n    }\n    \n    return null;\n}",
			"comments":"/**\n* Retrieve the data of the specified type currently available on the specified\n* clipboard.  Refer to the specific subclass of <code>Transfer</code> to\n* determine the type of object returned.\n*\n* <p>The following snippet shows text and RTF text being retrieved from the\n* clipboard:</p>\n*\n*    <code><pre>\n*    Clipboard clipboard = new Clipboard(display);\n*    TextTransfer textTransfer = TextTransfer.getInstance();\n*    String textData = (String)clipboard.getContents(textTransfer);\n*    if (textData != null) System.out.println(\"Text is \"+textData);\n*    RTFTransfer rtfTransfer = RTFTransfer.getInstance();\n*    String rtfData = (String)clipboard.getContents(rtfTransfer, DND.CLIPBOARD);\n*    if (rtfData != null) System.out.println(\"RTF Text is \"+rtfData);\n*    clipboard.dispose();\n*    </code></pre>\n*\n* <p>The clipboards value is either one of the clipboard constants defined in\n* class <code>DND</code>, or must be built by <em>bitwise OR</em>'ing together\n* (that is, using the <code>int</code> \"|\" operator) two or more\n* of those <code>DND</code> clipboard constants.</p>\n*\n* @param transfer the transfer agent for the type of data being requested\n* @param clipboards on which to look for data\n*\n* @return the data obtained from the clipboard or null if no data of this type is available\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if transfer is null</li>\n* </ul>\n*\n* @see Transfer\n* @see DND#CLIPBOARD\n* @see DND#SELECTION_CLIPBOARD\n*\n* @since 3.1\n*/\n/*\n* Bug in Windows. When a new application takes control\n* of the clipboard, other applications may open the\n* clipboard to determine if they want to record the\n* clipoard updates.  When this happens, the clipboard\n* can not be accessed until the other application is\n* finished.  To allow the other applications to release\n* the clipboard, use PeekMessage() to enable cross thread\n* message sends.\n*/\n// No data available for this transfer\n",
			"methodName":"public Object getContents(Transfer transfer, int clipboards)"
		},
		"public TransferData[] getAvailableTypes()":{
			"methodBody":"{\n    return getAvailableTypes(DND.CLIPBOARD);\n}",
			"comments":"/**\n* Returns an array of the data types currently available on the system\n* clipboard. Use with Transfer.isSupportedType.\n*\n* @return array of data types currently available on the system clipboard\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see Transfer#isSupportedType\n*\n* @since 3.0\n*/\n",
			"methodName":"public TransferData[] getAvailableTypes()"
		},
		"public int method8(int[] args)":{
			"methodBody":"{\n    return EnumFormatEtc(args[0], args[1]);\n}",
			"comments":"// method6 GetCanonicalFormatEtc - not implemented\n// method7 SetData - not implemented\n",
			"methodName":"public int method8(int[] args)"
		},
		"private FORMATETC[] _getAvailableTypes()":{
			"methodBody":"{\n    FORMATETC[] types = new FORMATETC[0];\n    int[] ppv = new int[1];\n    if (COM.OleGetClipboard(ppv) != COM.S_OK)\n        return types;\n    IDataObject dataObject = new IDataObject(ppv[0]);\n    int[] ppFormatetc = new int[1];\n    int rc = dataObject.EnumFormatEtc(COM.DATADIR_GET, ppFormatetc);\n    dataObject.Release();\n    if (rc != COM.S_OK)\n        return types;\n    IEnumFORMATETC enumFormatetc = new IEnumFORMATETC(ppFormatetc[0]);\n    \n    int rgelt = OS.GlobalAlloc(OS.GMEM_FIXED | OS.GMEM_ZEROINIT, FORMATETC.sizeof);\n    int[] pceltFetched = new int[1];\n    enumFormatetc.Reset();\n    while (enumFormatetc.Next(1, rgelt, pceltFetched) == COM.S_OK && pceltFetched[0] == 1) {\n        FORMATETC formatetc = new FORMATETC();\n        COM.MoveMemory(formatetc, rgelt, FORMATETC.sizeof);\n        FORMATETC[] newTypes = new FORMATETC[types.length + 1];\n        System.arraycopy(types, 0, newTypes, 0, types.length);\n        newTypes[types.length] = formatetc;\n        types = newTypes;\n    }\n    OS.GlobalFree(rgelt);\n    enumFormatetc.Release();\n    return types;\n}",
			"comments":"// Loop over enumerator and save any types that match what we are looking for\n",
			"methodName":"private FORMATETC[] _getAvailableTypes()"
		},
		"public void dispose()":{
			"methodBody":"{\n    if (isDisposed())\n        return;\n    if (display.getThread() != Thread.currentThread())\n        DND.error(SWT.ERROR_THREAD_INVALID_ACCESS);\n    if (COM.OleIsCurrentClipboard(this.iDataObject.getAddress()) == COM.S_OK) {\n        COM.OleFlushClipboard();\n    }\n    this.Release();\n    display = null;\n}",
			"comments":"/**\n* Disposes of the operating system resources associated with the clipboard.\n* The data will still be available on the system clipboard after the dispose\n* method is called.\n*\n* <p>NOTE: On some platforms the data will not be available once the application\n* has exited or the display has been disposed.</p>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the parent</li>\n* </ul>\n*/\n",
			"methodName":"public void dispose()"
		},
		"private int AddRef()":{
			"methodBody":"{\n    refCount++;\n    return refCount;\n}",
			"comments":"",
			"methodName":"private int AddRef()"
		},
		"public TransferData[] getAvailableTypes(int clipboards)":{
			"methodBody":"{\n    checkWidget();\n    if ((clipboards & DND.CLIPBOARD) == 0)\n        return new TransferData[0];\n    FORMATETC[] types = _getAvailableTypes();\n    TransferData[] data = new TransferData[types.length];\n    for (int i = 0; i < types.length; i++) {\n        data[i] = new TransferData();\n        data[i].type = types[i].cfFormat;\n        data[i].formatetc = types[i];\n    }\n    return data;\n}",
			"comments":"/**\n* Returns an array of the data types currently available on the specified\n* clipboard. Use with Transfer.isSupportedType.\n*\n* <p>The clipboards value is either one of the clipboard constants defined in\n* class <code>DND</code>, or must be built by <em>bitwise OR</em>'ing together\n* (that is, using the <code>int</code> \"|\" operator) two or more\n* of those <code>DND</code> clipboard constants.</p>\n*\n* @param clipboards from which to get the data types\n* @return array of data types currently available on the specified clipboard\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see Transfer#isSupportedType\n* @see DND#CLIPBOARD\n* @see DND#SELECTION_CLIPBOARD\n*\n* @since 3.1\n*/\n",
			"methodName":"public TransferData[] getAvailableTypes(int clipboards)"
		},
		"private int QueryInterface(int riid, int ppvObject)":{
			"methodBody":"{\n    if (riid == 0 || ppvObject == 0)\n        return COM.E_INVALIDARG;\n    GUID guid = new GUID();\n    COM.MoveMemory(guid, riid, GUID.sizeof);\n    if (COM.IsEqualGUID(guid, COM.IIDIUnknown) || COM.IsEqualGUID(guid, COM.IIDIDataObject)) {\n        OS.MoveMemory(ppvObject, new int[] { iDataObject.getAddress() }, 4);\n        AddRef();\n        return COM.S_OK;\n    }\n    OS.MoveMemory(ppvObject, new int[] { 0 }, 4);\n    return COM.E_NOINTERFACE;\n}",
			"comments":"",
			"methodName":"private int QueryInterface(int riid, int ppvObject)"
		},
		"public int method3(int[] args)":{
			"methodBody":"{\n    return GetData(args[0], args[1]);\n}",
			"comments":"",
			"methodName":"public int method3(int[] args)"
		},
		"private int QueryGetData(int pFormatetc)":{
			"methodBody":"{\n    if (transferAgents == null)\n        return COM.E_FAIL;\n    TransferData transferData = new TransferData();\n    transferData.formatetc = new FORMATETC();\n    COM.MoveMemory(transferData.formatetc, pFormatetc, FORMATETC.sizeof);\n    transferData.type = transferData.formatetc.cfFormat;\n    if (transferData.type == CFSTR_PREFERREDDROPEFFECT)\n        return COM.S_OK;\n    \n    for (int i = 0; i < transferAgents.length; i++) {\n        if (transferAgents[i].isSupportedType(transferData))\n            return COM.S_OK;\n    }\n    return COM.DV_E_FORMATETC;\n}",
			"comments":"// is this type supported by the transfer agent?\n",
			"methodName":"private int QueryGetData(int pFormatetc)"
		},
		"public int method2(int[] args)":{
			"methodBody":"{\n    return Release();\n}",
			"comments":"",
			"methodName":"public int method2(int[] args)"
		},
		"private void disposeCOMInterfaces()":{
			"methodBody":"{\n    if (iDataObject != null)\n        iDataObject.dispose();\n    iDataObject = null;\n}",
			"comments":"",
			"methodName":"private void disposeCOMInterfaces()"
		},
		"public int method1(int[] args)":{
			"methodBody":"{\n    return AddRef();\n}",
			"comments":"",
			"methodName":"public int method1(int[] args)"
		},
		"private int GetData(int pFormatetc, int pmedium)":{
			"methodBody":"{\n    \n    if (pFormatetc == 0 || pmedium == 0)\n        return COM.E_INVALIDARG;\n    if (QueryGetData(pFormatetc) != COM.S_OK)\n        return COM.DV_E_FORMATETC;\n    TransferData transferData = new TransferData();\n    transferData.formatetc = new FORMATETC();\n    COM.MoveMemory(transferData.formatetc, pFormatetc, FORMATETC.sizeof);\n    transferData.type = transferData.formatetc.cfFormat;\n    transferData.stgmedium = new STGMEDIUM();\n    transferData.result = COM.E_FAIL;\n    if (transferData.type == CFSTR_PREFERREDDROPEFFECT) {\n        \n        STGMEDIUM stgmedium = new STGMEDIUM();\n        stgmedium.tymed = COM.TYMED_HGLOBAL;\n        stgmedium.unionField = OS.GlobalAlloc(COM.GMEM_FIXED | COM.GMEM_ZEROINIT, 4);\n        OS.MoveMemory(stgmedium.unionField, new int[] { COM.DROPEFFECT_COPY }, 4);\n        stgmedium.pUnkForRelease = 0;\n        COM.MoveMemory(pmedium, stgmedium, STGMEDIUM.sizeof);\n        return COM.S_OK;\n    }\n    \n    int transferIndex = -1;\n    for (int i = 0; i < transferAgents.length; i++) {\n        if (transferAgents[i].isSupportedType(transferData)) {\n            transferIndex = i;\n            break;\n        }\n    }\n    if (transferIndex == -1)\n        return COM.DV_E_FORMATETC;\n    transferAgents[transferIndex].javaToNative(data[transferIndex], transferData);\n    COM.MoveMemory(pmedium, transferData.stgmedium, STGMEDIUM.sizeof);\n    return transferData.result;\n}",
			"comments":"/* Called by a data consumer to obtain data from a source data object.\nThe GetData method renders the data described in the specified FORMATETC\nstructure and transfers it through the specified STGMEDIUM structure.\nThe caller then assumes responsibility for releasing the STGMEDIUM structure.\n*/\n// specify that a copy operation is to be performed\n// get matching transfer agent to perform conversion\n",
			"methodName":"private int GetData(int pFormatetc, int pmedium)"
		},
		"public int method0(int[] args)":{
			"methodBody":"{\n    return QueryInterface(args[0], args[1]);\n}",
			"comments":"",
			"methodName":"public int method0(int[] args)"
		}
	},
	"ClassORInterfaceName":[
		"Clipboard"
	]
}
