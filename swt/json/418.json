{
	"variables":[
		"iUnknown",
		"iOleInPlaceFrame",
		"objIOleInPlaceActiveObject",
		"currentdoc",
		"refCount",
		"fileMenuItems",
		"containerMenuItems",
		"windowMenuItems",
		"listener",
		"CHECK_FOCUS",
		"HHOOK",
		"HHOOKMSG",
		"display",
		"time",
		"timer",
		"lastFocus",
		"hwnd",
		"ownerHwnd",
		"currentFocus",
		"frame",
		"event",
		"callback",
		"address",
		"threadId",
		"hHook",
		"display",
		"hHook",
		"msg",
		"message",
		"widget",
		"hwnd",
		"site",
		"consumed",
		"thread",
		"lpgui",
		"rc",
		"mask",
		"frame",
		"hwndOld",
		"rectBorder",
		"id",
		"lpmii",
		"menubar",
		"hMenu",
		"lpmii",
		"hHeap",
		"cch",
		"byteCount",
		"pszText",
		"fileMenuCount",
		"newindex",
		"i",
		"item",
		"index",
		"containerMenuCount",
		"i",
		"item",
		"index",
		"windowMenuCount",
		"i",
		"item",
		"index",
		"lpRect",
		"guid",
		"menubar",
		"hMenu",
		"ids",
		"i",
		"item",
		"index",
		"id",
		"i",
		"item",
		"index",
		"id",
		"i",
		"item",
		"index",
		"id",
		"index",
		"i",
		"id",
		"borderwidth",
		"lpRect",
		"inPlaceActiveObject",
		"menubar",
		"handle",
		"result",
		"menubar",
		"shell",
		"hwnd",
		"hAccel",
		"msg",
		"result",
		"parent",
		"style",
		"SWT",
		"SWT",
		"listener",
		"e",
		"SWT",
		"e",
		"SWT",
		"SWT",
		"e",
		"OLE",
		"SWT",
		"SWT",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"listener",
		"display",
		"display",
		"display",
		"CHECK_FOCUS",
		"display",
		"CHECK_FOCUS",
		"CHECK_FOCUS",
		"timer",
		"lastFocus",
		"lastFocus",
		"OS",
		"hwnd",
		"OS",
		"hwnd",
		"OS",
		"ownerHwnd",
		"display",
		"time",
		"timer",
		"hwnd",
		"OS",
		"hwnd",
		"lastFocus",
		"lastFocus",
		"lastFocus",
		"display",
		"currentFocus",
		"currentFocus",
		"currentFocus",
		"frame",
		"lastFocus",
		"currentFocus",
		"lastFocus",
		"lastFocus",
		"lastFocus",
		"SWT",
		"event",
		"currentFocus",
		"currentFocus",
		"currentFocus",
		"SWT",
		"event",
		"lastFocus",
		"currentFocus",
		"display",
		"time",
		"timer",
		"display",
		"time",
		"timer",
		"display",
		"HHOOK",
		"callback",
		"address",
		"SWT",
		"SWT",
		"OS",
		"OS",
		"OS",
		"address",
		"threadId",
		"hHook",
		"callback",
		"display",
		"HHOOK",
		"hHook",
		"display",
		"HHOOKMSG",
		"display",
		"hHook",
		"OS",
		"hHook",
		"callback",
		"callback",
		"Display",
		"display",
		"display",
		"HHOOK",
		"hHook",
		"code",
		"OS",
		"hHook",
		"code",
		"wParam",
		"lParam",
		"display",
		"HHOOKMSG",
		"OS",
		"msg",
		"lParam",
		"MSG",
		"msg",
		"OS",
		"message",
		"message",
		"OS",
		"display",
		"msg",
		"hwnd",
		"widget",
		"display",
		"hwnd",
		"widget",
		"hwnd",
		"OS",
		"hwnd",
		"widget",
		"widget",
		"widget",
		"site",
		"hwnd",
		"OS",
		"msg",
		"lpgui",
		"GUITHREADINFO",
		"OS",
		"thread",
		"lpgui",
		"OS",
		"OS",
		"OS",
		"OS",
		"rc",
		"lpgui",
		"mask",
		"site",
		"consumed",
		"frame",
		"msg",
		"consumed",
		"msg",
		"msg",
		"site",
		"consumed",
		"OS",
		"msg",
		"msg",
		"hwndOld",
		"consumed",
		"msg",
		"OS",
		"msg",
		"msg",
		"OS",
		"lParam",
		"msg",
		"MSG",
		"OS",
		"hHook",
		"code",
		"wParam",
		"lParam",
		"refCount",
		"refCount",
		"COM",
		"iUnknown",
		"args",
		"args",
		"iOleInPlaceFrame",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"iUnknown",
		"iUnknown",
		"iUnknown",
		"iOleInPlaceFrame",
		"iOleInPlaceFrame",
		"iOleInPlaceFrame",
		"lprectBorder",
		"COM",
		"OS",
		"handle",
		"rectBorder",
		"OS",
		"lprectBorder",
		"rectBorder",
		"RECT",
		"COM",
		"containerMenuItems",
		"fileMenuItems",
		"iOleInPlaceFrame",
		"lpmii",
		"MENUITEMINFO",
		"lpmii",
		"OS",
		"OS",
		"OS",
		"OS",
		"hMenu",
		"index",
		"lpmii",
		"lpmii",
		"OS",
		"OS",
		"id",
		"lpmii",
		"id",
		"lpmii",
		"id",
		"phwnd",
		"COM",
		"phwnd",
		"handle",
		"COM",
		"windowMenuItems",
		"menubar",
		"menubar",
		"COM",
		"lpMenuWidths",
		"COM",
		"menubar",
		"OS",
		"cch",
		"TCHAR",
		"OS",
		"hHeap",
		"OS",
		"byteCount",
		"lpmii",
		"MENUITEMINFO",
		"lpmii",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"lpmii",
		"pszText",
		"lpmii",
		"cch",
		"i",
		"i",
		"i",
		"item",
		"item",
		"item",
		"lpmii",
		"cch",
		"OS",
		"hMenu",
		"index",
		"lpmii",
		"OS",
		"hmenuShared",
		"newindex",
		"lpmii",
		"fileMenuCount",
		"newindex",
		"COM",
		"lpMenuWidths",
		"fileMenuCount",
		"i",
		"i",
		"i",
		"item",
		"item",
		"item",
		"lpmii",
		"cch",
		"OS",
		"hMenu",
		"index",
		"lpmii",
		"OS",
		"hmenuShared",
		"newindex",
		"lpmii",
		"containerMenuCount",
		"newindex",
		"COM",
		"lpMenuWidths",
		"containerMenuCount",
		"i",
		"i",
		"i",
		"item",
		"item",
		"item",
		"lpmii",
		"cch",
		"OS",
		"hMenu",
		"index",
		"lpmii",
		"OS",
		"hmenuShared",
		"newindex",
		"lpmii",
		"windowMenuCount",
		"newindex",
		"COM",
		"lpMenuWidths",
		"windowMenuCount",
		"pszText",
		"OS",
		"hHeap",
		"pszText",
		"COM",
		"currentdoc",
		"SWT",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"listener",
		"objIOleInPlaceActiveObject",
		"OS",
		"handle",
		"lpRect",
		"objIOleInPlaceActiveObject",
		"lpRect",
		"iOleInPlaceFrame",
		"riid",
		"ppvObject",
		"COM",
		"COM",
		"guid",
		"riid",
		"GUID",
		"COM",
		"guid",
		"COM",
		"COM",
		"guid",
		"COM",
		"COM",
		"ppvObject",
		"iOleInPlaceFrame",
		"COM",
		"COM",
		"ppvObject",
		"COM",
		"refCount",
		"refCount",
		"COM",
		"refCount",
		"objIOleInPlaceActiveObject",
		"objIOleInPlaceActiveObject",
		"objIOleInPlaceActiveObject",
		"menubar",
		"menubar",
		"COM",
		"menubar",
		"i",
		"i",
		"i",
		"item",
		"item",
		"item",
		"item",
		"hMenu",
		"index",
		"ids",
		"id",
		"i",
		"i",
		"i",
		"item",
		"item",
		"item",
		"item",
		"hMenu",
		"index",
		"ids",
		"id",
		"i",
		"i",
		"i",
		"item",
		"item",
		"item",
		"item",
		"hMenu",
		"index",
		"ids",
		"id",
		"OS",
		"hmenuShared",
		"index",
		"i",
		"i",
		"hmenuShared",
		"i",
		"ids",
		"id",
		"OS",
		"hmenuShared",
		"i",
		"OS",
		"COM",
		"COM",
		"objIOleInPlaceActiveObject",
		"objIOleInPlaceActiveObject",
		"objIOleInPlaceActiveObject",
		"pActiveObject",
		"objIOleInPlaceActiveObject",
		"pActiveObject",
		"objIOleInPlaceActiveObject",
		"COM",
		"objIOleInPlaceActiveObject",
		"COM",
		"pborderwidths",
		"currentdoc",
		"COM",
		"COM",
		"borderwidth",
		"pborderwidths",
		"RECT",
		"currentdoc",
		"borderwidth",
		"COM",
		"containerMenuItems",
		"containerMenus",
		"currentdoc",
		"currentdoc",
		"doc",
		"currentdoc",
		"objIOleInPlaceActiveObject",
		"OS",
		"handle",
		"lpRect",
		"objIOleInPlaceActiveObject",
		"lpRect",
		"iOleInPlaceFrame",
		"fileMenuItems",
		"fileMenus",
		"objIOleInPlaceActiveObject",
		"inPlaceActiveObject",
		"objIOleInPlaceActiveObject",
		"menubar",
		"menubar",
		"COM",
		"hwndActiveObject",
		"iOleInPlaceFrame",
		"inPlaceActiveObject",
		"menubar",
		"hmenuShared",
		"holemenu",
		"hmenuShared",
		"menubar",
		"hmenuShared",
		"COM",
		"OS",
		"handle",
		"hmenuShared",
		"OS",
		"handle",
		"COM",
		"holemenu",
		"handle",
		"hwndActiveObject",
		"iOleInPlaceFrame",
		"inPlaceActiveObject",
		"windowMenuItems",
		"windowMenus",
		"objIOleInPlaceActiveObject",
		"objIOleInPlaceActiveObject",
		"msg",
		"result",
		"COM",
		"result",
		"COM",
		"menubar",
		"menubar",
		"menubar",
		"COM",
		"wID",
		"COM",
		"menubar",
		"shell",
		"OS",
		"hwnd",
		"OS",
		"hAccel",
		"COM",
		"OS",
		"msg",
		"lpmsg",
		"MSG",
		"OS",
		"hwnd",
		"hAccel",
		"msg",
		"result",
		"COM",
		"COM",
		"CLIP_CHILDREN",
		"CLIP_SIBLINGS",
		"type",
		"Dispose",
		"Resize",
		"Move",
		"ERROR_NOT_IMPLEMENTED",
		"Dispose",
		"Resize",
		"Move",
		"GW_OWNER",
		"FocusOut",
		"FocusIn",
		"ERROR_NO_MORE_CALLBACKS",
		"WH_GETMESSAGE",
		"sizeof",
		"message",
		"WM_KEYFIRST",
		"WM_KEYLAST",
		"hwnd",
		"handle",
		"hwnd",
		"cbSize",
		"sizeof",
		"GUI_INMENUMODE",
		"GUI_INMOVESIZE",
		"GUI_POPUPMENUMODE",
		"GUI_SYSTEMMENUMODE",
		"flags",
		"frame",
		"hwnd",
		"hwnd",
		"handle",
		"hwnd",
		"message",
		"WM_NULL",
		"wParam",
		"lParam",
		"sizeof",
		"S_OK",
		"E_INVALIDARG",
		"sizeof",
		"S_OK",
		"cbSize",
		"sizeof",
		"fMask",
		"MIIM_STATE",
		"MIIM_SUBMENU",
		"MIIM_ID",
		"fState",
		"MF_POPUP",
		"MF_POPUP",
		"hSubMenu",
		"wID",
		"S_OK",
		"S_OK",
		"handle",
		"sizeof",
		"HEAP_ZERO_MEMORY",
		"cbSize",
		"sizeof",
		"fMask",
		"MIIM_STATE",
		"MIIM_ID",
		"MIIM_TYPE",
		"MIIM_SUBMENU",
		"MIIM_DATA",
		"dwTypeData",
		"cch",
		"fileMenuItems",
		"length",
		"fileMenuItems",
		"fileMenuItems",
		"cch",
		"containerMenuItems",
		"length",
		"containerMenuItems",
		"containerMenuItems",
		"cch",
		"windowMenuItems",
		"length",
		"windowMenuItems",
		"windowMenuItems",
		"cch",
		"S_OK",
		"Dispose",
		"Resize",
		"Move",
		"E_INVALIDARG",
		"sizeof",
		"IIDIUnknown",
		"IIDIOleInPlaceFrame",
		"S_OK",
		"E_NOINTERFACE",
		"S_FALSE",
		"handle",
		"fileMenuItems",
		"length",
		"fileMenuItems",
		"fileMenuItems",
		"containerMenuItems",
		"length",
		"containerMenuItems",
		"containerMenuItems",
		"windowMenuItems",
		"length",
		"windowMenuItems",
		"windowMenuItems",
		"MF_BYPOSITION",
		"S_OK",
		"S_OK",
		"S_OK",
		"S_OK",
		"S_OK",
		"sizeof",
		"S_OK",
		"handle",
		"handle",
		"handle",
		"E_FAIL",
		"S_FALSE",
		"E_NOTIMPL",
		"S_FALSE",
		"S_FALSE",
		"handle",
		"WM_APP",
		"S_FALSE",
		"sizeof",
		"S_FALSE",
		"S_OK",
		"parent",
		"style",
		"e",
		"display",
		"display",
		"code",
		"wParam",
		"lParam",
		"fEnterMode",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"lprectBorder",
		"hMenu",
		"index",
		"phwnd",
		"hmenuShared",
		"lpMenuWidths",
		"e",
		"e",
		"riid",
		"ppvObject",
		"hmenuShared",
		"pborderwidths",
		"pActiveObject",
		"pszObjName",
		"pborderwidths",
		"containerMenus",
		"doc",
		"fileMenus",
		"hmenuShared",
		"holemenu",
		"hwndActiveObject",
		"windowMenus",
		"msg",
		"lpmsg",
		"wID"
	],
	"extendORImplementFiles":[
		"Composite"
	],
	"package":[
		"org.eclipse.swt.ole.win32"
	],
	"import":[
		"org.eclipse.swt",
		"org.eclipse.swt.internal.ole.win32",
		"org.eclipse.swt.widgets",
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt.internal",
		"java.util.Vector"
	],
	"methods":[
		"handleEvent",
		"initCheckFocus",
		"run",
		"initMsgHook",
		"run",
		"getMsgProc",
		"AddRef",
		"ContextSensitiveHelp",
		"createCOMInterfaces",
		"method0",
		"method1",
		"method2",
		"method0",
		"method1",
		"method2",
		"method3",
		"method4",
		"method5",
		"method6",
		"method7",
		"method8",
		"method9",
		"method10",
		"method11",
		"method14",
		"disposeCOMInterfaces",
		"GetBorder",
		"getContainerMenus",
		"getFileMenus",
		"getIOleInPlaceFrame",
		"getMenuItemID",
		"GetWindow",
		"getWindowMenus",
		"InsertMenus",
		"onDispose",
		"onResize",
		"QueryInterface",
		"Release",
		"releaseObjectInterfaces",
		"RemoveMenus",
		"RequestBorderSpace",
		"SetActiveObject",
		"SetBorderSpace",
		"setContainerMenus",
		"getCurrentDocument",
		"setCurrentDocument",
		"setFileMenus",
		"SetMenu",
		"setWindowMenus",
		"translateOleAccelerator",
		"TranslateAccelerator",
		"createCOMInterfaces",
		"onDispose",
		"onResize",
		"error",
		"addListener",
		"addListener",
		"addListener",
		"AddRef",
		"getDisplay",
		"initCheckFocus",
		"initMsgHook",
		"getData",
		"setData",
		"isDisposed",
		"GetFocus",
		"GetWindow",
		"timerExec",
		"GetParent",
		"isDisposed",
		"isFocusControl",
		"getFocusControl",
		"getCurrentDocument",
		"isDisposed",
		"notifyListeners",
		"isDisposed",
		"notifyListeners",
		"timerExec",
		"timerExec",
		"getData",
		"getAddress",
		"error",
		"GetCurrentThreadId",
		"SetWindowsHookEx",
		"dispose",
		"setData",
		"setData",
		"disposeExec",
		"UnhookWindowsHookEx",
		"dispose",
		"getCurrent",
		"getData",
		"CallNextHookEx",
		"intValue",
		"getData",
		"MoveMemory",
		"findWidget",
		"GetParent",
		"GetWindowThreadProcessId",
		"GetGUIThreadInfo",
		"translateOleAccelerator",
		"DispatchMessage",
		"MoveMemory",
		"CallNextHookEx",
		"intValue",
		"QueryInterface",
		"AddRef",
		"Release",
		"QueryInterface",
		"AddRef",
		"Release",
		"GetWindow",
		"ContextSensitiveHelp",
		"GetBorder",
		"RequestBorderSpace",
		"SetBorderSpace",
		"SetActiveObject",
		"InsertMenus",
		"SetMenu",
		"RemoveMenus",
		"TranslateAccelerator",
		"dispose",
		"dispose",
		"GetClientRect",
		"MoveMemory",
		"getAddress",
		"GetMenuItemInfo",
		"MoveMemory",
		"getMenuBar",
		"getShell",
		"isDisposed",
		"MoveMemory",
		"GetProcessHeap",
		"HeapAlloc",
		"indexOf",
		"getParent",
		"GetMenuItemInfo",
		"InsertMenuItem",
		"MoveMemory",
		"indexOf",
		"getParent",
		"GetMenuItemInfo",
		"InsertMenuItem",
		"MoveMemory",
		"indexOf",
		"getParent",
		"GetMenuItemInfo",
		"InsertMenuItem",
		"MoveMemory",
		"HeapFree",
		"releaseObjectInterfaces",
		"Release",
		"removeListener",
		"removeListener",
		"removeListener",
		"GetClientRect",
		"ResizeBorder",
		"getAddress",
		"MoveMemory",
		"IsEqualGUID",
		"IsEqualGUID",
		"MoveMemory",
		"getAddress",
		"AddRef",
		"MoveMemory",
		"disposeCOMInterfaces",
		"CoFreeUnusedLibraries",
		"Release",
		"getMenuBar",
		"getShell",
		"isDisposed",
		"isDisposed",
		"indexOf",
		"getParent",
		"getMenuItemID",
		"addElement",
		"isDisposed",
		"indexOf",
		"getParent",
		"getMenuItemID",
		"addElement",
		"isDisposed",
		"indexOf",
		"getParent",
		"getMenuItemID",
		"addElement",
		"GetMenuItemCount",
		"getMenuItemID",
		"contains",
		"RemoveMenu",
		"Release",
		"AddRef",
		"MoveMemory",
		"setBorderSpace",
		"GetClientRect",
		"ResizeBorder",
		"getAddress",
		"getAddress",
		"getMenuBar",
		"getShell",
		"isDisposed",
		"OleSetMenuDescriptor",
		"getShell",
		"getAddress",
		"getShell",
		"SetMenu",
		"DrawMenuBar",
		"OleSetMenuDescriptor",
		"getAddress",
		"TranslateAccelerator",
		"getMenuBar",
		"getShell",
		"isDisposed",
		"isEnabled",
		"getShell",
		"SendMessage",
		"MoveMemory",
		"TranslateAccelerator",
		"Listener",
		"Runnable",
		"Event",
		"Callback",
		"Integer",
		"MSG",
		"Runnable",
		"GUITHREADINFO",
		"COMObject",
		"COMObject",
		"RECT",
		"MENUITEMINFO",
		"MENUITEMINFO",
		"RECT",
		"GUID",
		"Vector",
		"Integer",
		"Integer",
		"Integer",
		"Integer",
		"IOleInPlaceActiveObject",
		"RECT",
		"RECT",
		"MSG"
	],
	"methodsBody":{
		"private void onResize(Event e)":{
			"methodBody":"{\n    if (objIOleInPlaceActiveObject != null) {\n        RECT lpRect = new RECT();\n        OS.GetClientRect(handle, lpRect);\n        objIOleInPlaceActiveObject.ResizeBorder(lpRect, iOleInPlaceFrame.getAddress(), true);\n    }\n}",
			"comments":"",
			"methodName":"private void onResize(Event e)"
		},
		"public void setWindowMenus(MenuItem[] windowMenus)":{
			"methodBody":"{\n    windowMenuItems = windowMenus;\n}",
			"comments":"/**\n*\n* Set the menu items that should appear in the Window location when an OLE Document\n* is in-place activated.\n*\n* <p>When an OLE Document is in-place active, the Document provides its own menus but the application\n* is given the opportunity to merge some of its menus into the menubar.  The application\n* is allowed to insert its menus in three locations: File (far left), Container(middle) and Window\n* (far right just before Help).  The OLE Document retains control of the Edit, Object and Help\n* menu locations.  Note that an application can insert more than one menu into a single location.\n*\n* <p>This method must be called before in place activation of the OLE Document.  After the Document\n* is activated, the menu bar will not be modified until a subsequent activation.\n*\n* @param windowMenus an array of top level MenuItems to be inserted into the Window location of\n*        the menubar\n*/\n",
			"methodName":"public void setWindowMenus(MenuItem[] windowMenus)"
		},
		"private int TranslateAccelerator(int lpmsg, int wID)":{
			"methodBody":"{\n    Menu menubar = getShell().getMenuBar();\n    if (menubar == null || menubar.isDisposed() || !menubar.isEnabled())\n        return COM.S_FALSE;\n    if (wID < 0)\n        return COM.S_FALSE;\n    Shell shell = menubar.getShell();\n    int hwnd = shell.handle;\n    int hAccel = OS.SendMessage(hwnd, OS.WM_APP + 1, 0, 0);\n    if (hAccel == 0)\n        return COM.S_FALSE;\n    MSG msg = new MSG();\n    OS.MoveMemory(msg, lpmsg, MSG.sizeof);\n    int result = OS.TranslateAccelerator(hwnd, hAccel, msg);\n    return result == 0 ? COM.S_FALSE : COM.S_OK;\n}",
			"comments":"",
			"methodName":"private int TranslateAccelerator(int lpmsg, int wID)"
		},
		"private boolean translateOleAccelerator(MSG msg)":{
			"methodBody":"{\n    if (objIOleInPlaceActiveObject == null)\n        return false;\n    int result = objIOleInPlaceActiveObject.TranslateAccelerator(msg);\n    return (result != COM.S_FALSE && result != COM.E_NOTIMPL);\n}",
			"comments":"",
			"methodName":"private boolean translateOleAccelerator(MSG msg)"
		},
		"private int RemoveMenus(int hmenuShared)":{
			"methodBody":"{\n    Menu menubar = getShell().getMenuBar();\n    if (menubar == null || menubar.isDisposed())\n        return COM.S_FALSE;\n    int hMenu = menubar.handle;\n    Vector ids = new Vector();\n    if (this.fileMenuItems != null) {\n        for (int i = 0; i < this.fileMenuItems.length; i++) {\n            MenuItem item = this.fileMenuItems[i];\n            if (item != null && !item.isDisposed()) {\n                int index = item.getParent().indexOf(item);\n                \n                int id = getMenuItemID(hMenu, index);\n                ids.addElement(new Integer(id));\n            }\n        }\n    }\n    if (this.containerMenuItems != null) {\n        for (int i = 0; i < this.containerMenuItems.length; i++) {\n            MenuItem item = this.containerMenuItems[i];\n            if (item != null && !item.isDisposed()) {\n                int index = item.getParent().indexOf(item);\n                int id = getMenuItemID(hMenu, index);\n                ids.addElement(new Integer(id));\n            }\n        }\n    }\n    if (this.windowMenuItems != null) {\n        for (int i = 0; i < this.windowMenuItems.length; i++) {\n            MenuItem item = this.windowMenuItems[i];\n            if (item != null && !item.isDisposed()) {\n                int index = item.getParent().indexOf(item);\n                int id = getMenuItemID(hMenu, index);\n                ids.addElement(new Integer(id));\n            }\n        }\n    }\n    int index = OS.GetMenuItemCount(hmenuShared) - 1;\n    for (int i = index; i >= 0; i--) {\n        int id = getMenuItemID(hmenuShared, i);\n        if (ids.contains(new Integer(id))) {\n            OS.RemoveMenu(hmenuShared, i, OS.MF_BYPOSITION);\n        }\n    }\n    return COM.S_OK;\n}",
			"comments":"// get Id from original menubar\n",
			"methodName":"private int RemoveMenus(int hmenuShared)"
		},
		"OleClientSite getCurrentDocument()":{
			"methodBody":"{\n    return currentdoc;\n}",
			"comments":"",
			"methodName":"OleClientSite getCurrentDocument()"
		},
		"int getIOleInPlaceFrame()":{
			"methodBody":"{\n    return iOleInPlaceFrame.getAddress();\n}",
			"comments":"",
			"methodName":"int getIOleInPlaceFrame()"
		},
		"public void setFileMenus(MenuItem[] fileMenus)":{
			"methodBody":"{\n    fileMenuItems = fileMenus;\n}",
			"comments":"/**\n*\n* Specify the menu items that should appear in the File location when an OLE Document\n* is in-place activated.\n*\n* <p>When an OLE Document is in-place active, the Document provides its own menus but the application\n* is given the opportunity to merge some of its menus into the menubar.  The application\n* is allowed to insert its menus in three locations: File (far left), Container(middle) and Window\n* (far right just before Help).  The OLE Document retains control of the Edit, Object and Help\n* menu locations.  Note that an application can insert more than one menu into a single location.\n*\n* <p>This method must be called before in place activation of the OLE Document.  After the Document\n* is activated, the menu bar will not be modified until a subsequent activation.\n*\n* @param fileMenus an array of top level MenuItems to be inserted into the Flie location of\n*        the menubar\n*/\n",
			"methodName":"public void setFileMenus(MenuItem[] fileMenus)"
		},
		"private int getMenuItemID(int hMenu, int index)":{
			"methodBody":"{\n    int id = 0;\n    MENUITEMINFO lpmii = new MENUITEMINFO();\n    lpmii.cbSize = MENUITEMINFO.sizeof;\n    lpmii.fMask = OS.MIIM_STATE | OS.MIIM_SUBMENU | OS.MIIM_ID;\n    OS.GetMenuItemInfo(hMenu, index, true, lpmii);\n    if ((lpmii.fState & OS.MF_POPUP) == OS.MF_POPUP) {\n        id = lpmii.hSubMenu;\n    } else {\n        id = lpmii.wID;\n    }\n    return id;\n}",
			"comments":"",
			"methodName":"private int getMenuItemID(int hMenu, int index)"
		},
		"int AddRef()":{
			"methodBody":"{\n    refCount++;\n    return refCount;\n}",
			"comments":"/**\n* Increment the count of references to this instance\n*\n* @return the current reference count\n*/\n",
			"methodName":"int AddRef()"
		},
		"public int method4(int[] args)":{
			"methodBody":"{\n    return ContextSensitiveHelp(args[0]);\n}",
			"comments":"",
			"methodName":"public int method4(int[] args)"
		},
		"private static void initMsgHook(Display display)":{
			"methodBody":"{\n    if (display.getData(HHOOK) != null)\n        return;\n    \n    final Callback callback = new Callback(OleFrame.class, \"getMsgProc\", 3);\n    int address = callback.getAddress();\n    if (address == 0)\n        SWT.error(SWT.ERROR_NO_MORE_CALLBACKS);\n    int threadId = OS.GetCurrentThreadId();\n    final int hHook = OS.SetWindowsHookEx(OS.WH_GETMESSAGE, address, 0, threadId);\n    if (hHook == 0) {\n        callback.dispose();\n        return;\n    }\n    display.setData(HHOOK, new Integer(hHook));\n    display.setData(HHOOKMSG, new MSG());\n    display.disposeExec(new Runnable() {\n\n        public void run() {\n            if (hHook != 0)\n                OS.UnhookWindowsHookEx(hHook);\n            if (callback != null)\n                callback.dispose();\n        }\n    });\n}",
			"comments":"//$NON-NLS-1$\n",
			"methodName":"private static void initMsgHook(Display display)"
		},
		"public int method5(int[] args)":{
			"methodBody":"{\n    return GetBorder(args[0]);\n}",
			"comments":"",
			"methodName":"public int method5(int[] args)"
		},
		"private int RequestBorderSpace(int pborderwidths)":{
			"methodBody":"{\n    return COM.S_OK;\n}",
			"comments":"",
			"methodName":"private int RequestBorderSpace(int pborderwidths)"
		},
		"private void onDispose(Event e)":{
			"methodBody":"{\n    releaseObjectInterfaces();\n    currentdoc = null;\n    this.Release();\n    removeListener(SWT.Dispose, listener);\n    removeListener(SWT.Resize, listener);\n    removeListener(SWT.Move, listener);\n}",
			"comments":"",
			"methodName":"private void onDispose(Event e)"
		},
		"private void createCOMInterfaces()":{
			"methodBody":"{\n    \n    iUnknown = new COMObject(new int[] { 2, 0, 0 }) {\n\n        public int method0(int[] args) {\n            return QueryInterface(args[0], args[1]);\n        }\n\n        public int method1(int[] args) {\n            return AddRef();\n        }\n\n        public int method2(int[] args) {\n            return Release();\n        }\n    };\n    iOleInPlaceFrame = new COMObject(new int[] { 2, 0, 0, 1, 1, 1, 1, 1, 2, 2, 3, 1, 1, 1, 2 }) {\n\n        public int method0(int[] args) {\n            return QueryInterface(args[0], args[1]);\n        }\n\n        public int method1(int[] args) {\n            return AddRef();\n        }\n\n        public int method2(int[] args) {\n            return Release();\n        }\n\n        public int method3(int[] args) {\n            return GetWindow(args[0]);\n        }\n\n        public int method4(int[] args) {\n            return ContextSensitiveHelp(args[0]);\n        }\n\n        public int method5(int[] args) {\n            return GetBorder(args[0]);\n        }\n\n        public int method6(int[] args) {\n            return RequestBorderSpace(args[0]);\n        }\n\n        public int method7(int[] args) {\n            return SetBorderSpace(args[0]);\n        }\n\n        public int method8(int[] args) {\n            return SetActiveObject(args[0], args[1]);\n        }\n\n        public int method9(int[] args) {\n            return InsertMenus(args[0], args[1]);\n        }\n\n        public int method10(int[] args) {\n            return SetMenu(args[0], args[1], args[2]);\n        }\n\n        public int method11(int[] args) {\n            return RemoveMenus(args[0]);\n        }\n\n        \n        \n        public int method14(int[] args) {\n            return TranslateAccelerator(args[0], args[1]);\n        }\n    };\n}",
			"comments":"// Create each of the interfaces that this object implements\n// method12 SetStatusText - not implemented\n// method13 EnableModeless - not implemented\n",
			"methodName":"private void createCOMInterfaces()"
		},
		"private int SetMenu(int hmenuShared, int holemenu, int hwndActiveObject)":{
			"methodBody":"{\n    int inPlaceActiveObject = 0;\n    if (objIOleInPlaceActiveObject != null)\n        inPlaceActiveObject = objIOleInPlaceActiveObject.getAddress();\n    Menu menubar = getShell().getMenuBar();\n    if (menubar == null || menubar.isDisposed()) {\n        return COM.OleSetMenuDescriptor(0, getShell().handle, hwndActiveObject, iOleInPlaceFrame.getAddress(), inPlaceActiveObject);\n    }\n    int handle = menubar.getShell().handle;\n    if (hmenuShared == 0 && holemenu == 0) {\n        \n        hmenuShared = menubar.handle;\n    }\n    if (hmenuShared == 0)\n        return COM.E_FAIL;\n    OS.SetMenu(handle, hmenuShared);\n    OS.DrawMenuBar(handle);\n    return COM.OleSetMenuDescriptor(holemenu, handle, hwndActiveObject, iOleInPlaceFrame.getAddress(), inPlaceActiveObject);\n}",
			"comments":"// re-instate the original menu - this occurs on deactivation\n",
			"methodName":"private int SetMenu(int hmenuShared, int holemenu, int hwndActiveObject)"
		},
		"public int method7(int[] args)":{
			"methodBody":"{\n    return SetBorderSpace(args[0]);\n}",
			"comments":"",
			"methodName":"public int method7(int[] args)"
		},
		"private int GetWindow(int phwnd)":{
			"methodBody":"{\n    if (phwnd != 0) {\n        COM.MoveMemory(phwnd, new int[] { handle }, 4);\n    }\n    return COM.S_OK;\n}",
			"comments":"",
			"methodName":"private int GetWindow(int phwnd)"
		},
		"public int method6(int[] args)":{
			"methodBody":"{\n    return RequestBorderSpace(args[0]);\n}",
			"comments":"",
			"methodName":"public int method6(int[] args)"
		},
		"public int method9(int[] args)":{
			"methodBody":"{\n    return InsertMenus(args[0], args[1]);\n}",
			"comments":"",
			"methodName":"public int method9(int[] args)"
		},
		"int Release()":{
			"methodBody":"{\n    refCount--;\n    if (refCount == 0) {\n        disposeCOMInterfaces();\n        COM.CoFreeUnusedLibraries();\n    }\n    return refCount;\n}",
			"comments":"/**\n* Decrement the count of references to this instance\n*\n* @return the current reference count\n*/\n",
			"methodName":"int Release()"
		},
		"public int method8(int[] args)":{
			"methodBody":"{\n    return SetActiveObject(args[0], args[1]);\n}",
			"comments":"",
			"methodName":"public int method8(int[] args)"
		},
		"public int method14(int[] args)":{
			"methodBody":"{\n    return TranslateAccelerator(args[0], args[1]);\n}",
			"comments":"// method12 SetStatusText - not implemented\n// method13 EnableModeless - not implemented\n",
			"methodName":"public int method14(int[] args)"
		},
		"public void handleEvent(Event e)":{
			"methodBody":"{\n    switch(e.type) {\n        case SWT.Dispose:\n            onDispose(e);\n            break;\n        case SWT.Resize:\n        case SWT.Move:\n            onResize(e);\n            break;\n        default:\n            OLE.error(SWT.ERROR_NOT_IMPLEMENTED);\n    }\n}",
			"comments":"",
			"methodName":"public void handleEvent(Event e)"
		},
		"public MenuItem[] getFileMenus()":{
			"methodBody":"{\n    return fileMenuItems;\n}",
			"comments":"/**\n*\n* Returns the application menu items that will appear in the File location when an OLE Document\n* is in-place activated.\n*\n* <p>When an OLE Document is in-place active, the Document provides its own menus but the application\n* is given the opportunity to merge some of its menus into the menubar.  The application\n* is allowed to insert its menus in three locations: File (far left), Container(middle) and Window\n* (far right just before Help).  The OLE Document retains control of the Edit, Object and Help\n* menu locations.  Note that an application can insert more than one menu into a single location.\n*\n* @return the application menu items that will appear in the File location when an OLE Document\n*         is in-place activated.\n*\n*/\n",
			"methodName":"public MenuItem[] getFileMenus()"
		},
		"static int getMsgProc(int code, int wParam, int lParam)":{
			"methodBody":"{\n    Display display = Display.getCurrent();\n    if (display == null)\n        return 0;\n    Integer hHook = (Integer) display.getData(HHOOK);\n    if (hHook == null)\n        return 0;\n    if (code < 0) {\n        return OS.CallNextHookEx(hHook.intValue(), code, wParam, lParam);\n    }\n    MSG msg = (MSG) display.getData(HHOOKMSG);\n    OS.MoveMemory(msg, lParam, MSG.sizeof);\n    int message = msg.message;\n    if (OS.WM_KEYFIRST <= message && message <= OS.WM_KEYLAST) {\n        if (display != null) {\n            Widget widget = null;\n            int hwnd = msg.hwnd;\n            while (hwnd != 0) {\n                widget = display.findWidget(hwnd);\n                if (widget != null)\n                    break;\n                hwnd = OS.GetParent(hwnd);\n            }\n            if (widget != null && widget instanceof OleClientSite) {\n                OleClientSite site = (OleClientSite) widget;\n                if (site.handle == hwnd) {\n                    boolean consumed = false;\n                    \n                    int thread = OS.GetWindowThreadProcessId(msg.hwnd, null);\n                    GUITHREADINFO lpgui = new GUITHREADINFO();\n                    lpgui.cbSize = GUITHREADINFO.sizeof;\n                    boolean rc = OS.GetGUIThreadInfo(thread, lpgui);\n                    int mask = OS.GUI_INMENUMODE | OS.GUI_INMOVESIZE | OS.GUI_POPUPMENUMODE | OS.GUI_SYSTEMMENUMODE;\n                    if (!rc || (lpgui.flags & mask) == 0) {\n                        OleFrame frame = site.frame;\n                        consumed = frame.translateOleAccelerator(msg);\n                    }\n                    \n                    if (!consumed) {\n                        int hwndOld = msg.hwnd;\n                        msg.hwnd = site.handle;\n                        consumed = OS.DispatchMessage(msg) == 1;\n                        msg.hwnd = hwndOld;\n                    }\n                    if (consumed) {\n                        \n                        \n                        msg.message = OS.WM_NULL;\n                        msg.wParam = msg.lParam = 0;\n                        OS.MoveMemory(lParam, msg, MSG.sizeof);\n                        return 0;\n                    }\n                }\n            }\n        }\n    }\n    return OS.CallNextHookEx(hHook.intValue(), code, wParam, lParam);\n}",
			"comments":"/* Allow activeX control to translate accelerators except when a menu is active. */\n/* Allow OleClientSite to process key events before activeX control */\n// In order to prevent this message from also being processed\n// by the application, zero out message, wParam and lParam\n",
			"methodName":"static int getMsgProc(int code, int wParam, int lParam)"
		},
		"private int GetBorder(int lprectBorder)":{
			"methodBody":"{\n    \n    if (lprectBorder == 0)\n        return COM.E_INVALIDARG;\n    RECT rectBorder = new RECT();\n    \n    OS.GetClientRect(handle, rectBorder);\n    OS.MoveMemory(lprectBorder, rectBorder, RECT.sizeof);\n    return COM.S_OK;\n}",
			"comments":"/*\nThe IOleInPlaceUIWindow::GetBorder function, when called on a document or frame window\nobject, returns the outer rectangle (relative to the window) where the object can put\ntoolbars or similar controls.\n*/\n// Coordinates must be relative to the window\n",
			"methodName":"private int GetBorder(int lprectBorder)"
		},
		"int SetActiveObject(int pActiveObject, int pszObjName)":{
			"methodBody":"{\n    if (objIOleInPlaceActiveObject != null) {\n        objIOleInPlaceActiveObject.Release();\n        objIOleInPlaceActiveObject = null;\n    }\n    if (pActiveObject != 0) {\n        objIOleInPlaceActiveObject = new IOleInPlaceActiveObject(pActiveObject);\n        objIOleInPlaceActiveObject.AddRef();\n    }\n    return COM.S_OK;\n}",
			"comments":"",
			"methodName":"int SetActiveObject(int pActiveObject, int pszObjName)"
		},
		"public int method11(int[] args)":{
			"methodBody":"{\n    return RemoveMenus(args[0]);\n}",
			"comments":"",
			"methodName":"public int method11(int[] args)"
		},
		"public void run()":{
			"methodBody":"{\n    if (hHook != 0)\n        OS.UnhookWindowsHookEx(hHook);\n    if (callback != null)\n        callback.dispose();\n}",
			"comments":"",
			"methodName":"public void run()"
		},
		"public int method10(int[] args)":{
			"methodBody":"{\n    return SetMenu(args[0], args[1], args[2]);\n}",
			"comments":"",
			"methodName":"public int method10(int[] args)"
		},
		"private int QueryInterface(int riid, int ppvObject)":{
			"methodBody":"{\n    \n    if (riid == 0 || ppvObject == 0)\n        return COM.E_INVALIDARG;\n    GUID guid = new GUID();\n    COM.MoveMemory(guid, riid, GUID.sizeof);\n    if (COM.IsEqualGUID(guid, COM.IIDIUnknown) || COM.IsEqualGUID(guid, COM.IIDIOleInPlaceFrame)) {\n        COM.MoveMemory(ppvObject, new int[] { iOleInPlaceFrame.getAddress() }, 4);\n        AddRef();\n        return COM.S_OK;\n    }\n    COM.MoveMemory(ppvObject, new int[] { 0 }, 4);\n    return COM.E_NOINTERFACE;\n}",
			"comments":"//\timplements IUnknown, IOleInPlaceFrame, IOleContainer, IOleInPlaceUIWindow\n",
			"methodName":"private int QueryInterface(int riid, int ppvObject)"
		},
		"public MenuItem[] getWindowMenus()":{
			"methodBody":"{\n    return windowMenuItems;\n}",
			"comments":"/**\n*\n* Returns the application menu items that will appear in the Window location when an OLE Document\n* is in-place activated.\n*\n* <p>When an OLE Document is in-place active, the Document provides its own menus but the application\n* is given the opportunity to merge some of its menus into the menubar.  The application\n* is allowed to insert its menus in three locations: File (far left), Container(middle) and Window\n* (far right just before Help).  The OLE Document retains control of the Edit, Object and Help\n* menu locations.  Note that an application can insert more than one menu into a single location.\n*\n* @return the application menu items that will appear in the Window location when an OLE Document\n*         is in-place activated.\n*\n*/\n",
			"methodName":"public MenuItem[] getWindowMenus()"
		},
		"public int method3(int[] args)":{
			"methodBody":"{\n    return GetWindow(args[0]);\n}",
			"comments":"",
			"methodName":"public int method3(int[] args)"
		},
		"private int ContextSensitiveHelp(int fEnterMode)":{
			"methodBody":"{\n    return COM.S_OK;\n}",
			"comments":"",
			"methodName":"private int ContextSensitiveHelp(int fEnterMode)"
		},
		"void setCurrentDocument(OleClientSite doc)":{
			"methodBody":"{\n    currentdoc = doc;\n    if (currentdoc != null && objIOleInPlaceActiveObject != null) {\n        RECT lpRect = new RECT();\n        OS.GetClientRect(handle, lpRect);\n        objIOleInPlaceActiveObject.ResizeBorder(lpRect, iOleInPlaceFrame.getAddress(), true);\n    }\n}",
			"comments":"",
			"methodName":"void setCurrentDocument(OleClientSite doc)"
		},
		"public int method2(int[] args)":{
			"methodBody":"{\n    return Release();\n}",
			"comments":"",
			"methodName":"public int method2(int[] args)"
		},
		"private void releaseObjectInterfaces()":{
			"methodBody":"{\n    if (objIOleInPlaceActiveObject != null) {\n        objIOleInPlaceActiveObject.Release();\n    }\n    objIOleInPlaceActiveObject = null;\n}",
			"comments":"",
			"methodName":"private void releaseObjectInterfaces()"
		},
		"private void disposeCOMInterfaces()":{
			"methodBody":"{\n    if (iUnknown != null)\n        iUnknown.dispose();\n    iUnknown = null;\n    if (iOleInPlaceFrame != null)\n        iOleInPlaceFrame.dispose();\n    iOleInPlaceFrame = null;\n}",
			"comments":"",
			"methodName":"private void disposeCOMInterfaces()"
		},
		"private int SetBorderSpace(int pborderwidths)":{
			"methodBody":"{\n    \n    if (objIOleInPlaceActiveObject == null)\n        return COM.S_OK;\n    RECT borderwidth = new RECT();\n    if (pborderwidths == 0 || currentdoc == null)\n        return COM.S_OK;\n    COM.MoveMemory(borderwidth, pborderwidths, RECT.sizeof);\n    currentdoc.setBorderSpace(borderwidth);\n    return COM.S_OK;\n}",
			"comments":"// A Control/Document can :\n// Use its own toolbars, requesting border space of a specific size, or,\n// Use no toolbars, but force the container to remove its toolbars by passing a\n//   valid BORDERWIDTHS structure containing nothing but zeros in the pborderwidths parameter, or,\n// Use no toolbars but allow the in-place container to leave its toolbars up by\n//   passing NULL as the pborderwidths parameter.\n",
			"methodName":"private int SetBorderSpace(int pborderwidths)"
		},
		"private static void initCheckFocus(final Display display)":{
			"methodBody":"{\n    if (display.getData(CHECK_FOCUS) != null)\n        return;\n    display.setData(CHECK_FOCUS, CHECK_FOCUS);\n    final int time = 50;\n    final Runnable[] timer = new Runnable[1];\n    final Control[] lastFocus = new Control[1];\n    timer[0] = new Runnable() {\n\n        public void run() {\n            if (lastFocus[0] instanceof OleClientSite && !lastFocus[0].isDisposed()) {\n                \n                int hwnd = OS.GetFocus();\n                while (hwnd != 0) {\n                    int ownerHwnd = OS.GetWindow(hwnd, OS.GW_OWNER);\n                    if (ownerHwnd != 0) {\n                        display.timerExec(time, timer[0]);\n                        return;\n                    }\n                    hwnd = OS.GetParent(hwnd);\n                }\n            }\n            if (lastFocus[0] == null || lastFocus[0].isDisposed() || !lastFocus[0].isFocusControl()) {\n                Control currentFocus = display.getFocusControl();\n                if (currentFocus instanceof OleFrame) {\n                    OleFrame frame = (OleFrame) currentFocus;\n                    currentFocus = frame.getCurrentDocument();\n                }\n                if (lastFocus[0] != currentFocus) {\n                    Event event = new Event();\n                    if (lastFocus[0] instanceof OleClientSite && !lastFocus[0].isDisposed()) {\n                        lastFocus[0].notifyListeners(SWT.FocusOut, event);\n                    }\n                    if (currentFocus instanceof OleClientSite && !currentFocus.isDisposed()) {\n                        currentFocus.notifyListeners(SWT.FocusIn, event);\n                    }\n                }\n                lastFocus[0] = currentFocus;\n            }\n            display.timerExec(time, timer[0]);\n        }\n    };\n    display.timerExec(time, timer[0]);\n}",
			"comments":"// ignore popup menus and dialogs\n",
			"methodName":"private static void initCheckFocus(final Display display)"
		},
		"public int method1(int[] args)":{
			"methodBody":"{\n    return AddRef();\n}",
			"comments":"",
			"methodName":"public int method1(int[] args)"
		},
		"public MenuItem[] getContainerMenus()":{
			"methodBody":"{\n    return containerMenuItems;\n}",
			"comments":"/**\n*\n* Returns the application menu items that will appear in the Container location when an OLE Document\n* is in-place activated.\n*\n* <p>When an OLE Document is in-place active, the Document provides its own menus but the application\n* is given the opportunity to merge some of its menus into the menubar.  The application\n* is allowed to insert its menus in three locations: File (far left), Container(middle) and Window\n* (far right just before Help).  The OLE Document retains control of the Edit, Object and Help\n* menu locations.  Note that an application can insert more than one menu into a single location.\n*\n* @return the application menu items that will appear in the Container location when an OLE Document\n*         is in-place activated.\n*\n*/\n",
			"methodName":"public MenuItem[] getContainerMenus()"
		},
		"public int method0(int[] args)":{
			"methodBody":"{\n    return QueryInterface(args[0], args[1]);\n}",
			"comments":"",
			"methodName":"public int method0(int[] args)"
		},
		"public void setContainerMenus(MenuItem[] containerMenus)":{
			"methodBody":"{\n    containerMenuItems = containerMenus;\n}",
			"comments":"/**\n*\n* Specify the menu items that should appear in the Container location when an OLE Document\n* is in-place activated.\n*\n* <p>When an OLE Document is in-place active, the Document provides its own menus but the application\n* is given the opportunity to merge some of its menus into the menubar.  The application\n* is allowed to insert its menus in three locations: File (far left), Container(middle) and Window\n* (far right just before Help).  The OLE Document retains control of the Edit, Object and Help\n* menu locations.  Note that an application can insert more than one menu into a single location.\n*\n* <p>This method must be called before in place activation of the OLE Document.  After the Document\n* is activated, the menu bar will not be modified until a subsequent activation.\n*\n* @param containerMenus an array of top level MenuItems to be inserted into the Container location of\n*        the menubar\n*/\n",
			"methodName":"public void setContainerMenus(MenuItem[] containerMenus)"
		},
		"private int InsertMenus(int hmenuShared, int lpMenuWidths)":{
			"methodBody":"{\n    \n    Menu menubar = getShell().getMenuBar();\n    if (menubar == null || menubar.isDisposed()) {\n        COM.MoveMemory(lpMenuWidths, new int[] { 0 }, 4);\n        return COM.S_OK;\n    }\n    int hMenu = menubar.handle;\n    \n    \n    MENUITEMINFO lpmii = new MENUITEMINFO();\n    int hHeap = OS.GetProcessHeap();\n    int cch = 128;\n    int byteCount = cch * TCHAR.sizeof;\n    int pszText = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, byteCount);\n    lpmii.cbSize = MENUITEMINFO.sizeof;\n    lpmii.fMask = OS.MIIM_STATE | OS.MIIM_ID | OS.MIIM_TYPE | OS.MIIM_SUBMENU | OS.MIIM_DATA;\n    lpmii.dwTypeData = pszText;\n    lpmii.cch = cch;\n    \n    \n    int fileMenuCount = 0;\n    int newindex = 0;\n    if (this.fileMenuItems != null) {\n        for (int i = 0; i < this.fileMenuItems.length; i++) {\n            MenuItem item = this.fileMenuItems[i];\n            if (item != null) {\n                int index = item.getParent().indexOf(item);\n                \n                lpmii.cch = cch;\n                \n                if (OS.GetMenuItemInfo(hMenu, index, true, lpmii)) {\n                    if (OS.InsertMenuItem(hmenuShared, newindex, true, lpmii)) {\n                        \n                        fileMenuCount++;\n                        newindex++;\n                    }\n                }\n            }\n        }\n    }\n    \n    COM.MoveMemory(lpMenuWidths, new int[] { fileMenuCount }, 4);\n    \n    \n    int containerMenuCount = 0;\n    if (this.containerMenuItems != null) {\n        for (int i = 0; i < this.containerMenuItems.length; i++) {\n            MenuItem item = this.containerMenuItems[i];\n            if (item != null) {\n                int index = item.getParent().indexOf(item);\n                \n                lpmii.cch = cch;\n                \n                if (OS.GetMenuItemInfo(hMenu, index, true, lpmii)) {\n                    if (OS.InsertMenuItem(hmenuShared, newindex, true, lpmii)) {\n                        \n                        containerMenuCount++;\n                        newindex++;\n                    }\n                }\n            }\n        }\n    }\n    \n    COM.MoveMemory(lpMenuWidths + 8, new int[] { containerMenuCount }, 4);\n    \n    \n    int windowMenuCount = 0;\n    if (this.windowMenuItems != null) {\n        for (int i = 0; i < this.windowMenuItems.length; i++) {\n            MenuItem item = this.windowMenuItems[i];\n            if (item != null) {\n                int index = item.getParent().indexOf(item);\n                \n                lpmii.cch = cch;\n                \n                if (OS.GetMenuItemInfo(hMenu, index, true, lpmii)) {\n                    if (OS.InsertMenuItem(hmenuShared, newindex, true, lpmii)) {\n                        \n                        windowMenuCount++;\n                        newindex++;\n                    }\n                }\n            }\n        }\n    }\n    \n    COM.MoveMemory(lpMenuWidths + 16, new int[] { windowMenuCount }, 4);\n    \n    if (pszText != 0)\n        OS.HeapFree(hHeap, 0, pszText);\n    return COM.S_OK;\n}",
			"comments":"// locate menu bar\n// Create a holder for menu information.  This will be passed down to\n// the OS and the OS will fill in the requested information for each menu.\n// Loop over all \"File-like\" menus in the menubar and get information about the\n// item from the OS.\n// lpmii.cch gets updated by GetMenuItemInfo to indicate the\n// exact number of characters in name.  Reset it to our max size\n// before each call.\n// keep track of the number of items\n// copy the menu item count information to the pointer\n// Loop over all \"Container-like\" menus in the menubar and get information about the\n// item from the OS.\n// lpmii.cch gets updated by GetMenuItemInfo to indicate the\n// exact nuber of characters in name.  Reset it to a large number\n// before each call.\n// keep track of the number of items\n// copy the menu item count information to the pointer\n// Loop over all \"Window-like\" menus in the menubar and get information about the\n// item from the OS.\n// lpmii.cch gets updated by GetMenuItemInfo to indicate the\n// exact nuber of characters in name.  Reset it to a large number\n// before each call.\n// keep track of the number of items\n// copy the menu item count information to the pointer\n// free resources used in querying the OS\n",
			"methodName":"private int InsertMenus(int hmenuShared, int lpMenuWidths)"
		}
	},
	"ClassORInterfaceName":[
		"OleFrame"
	]
}
