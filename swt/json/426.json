{
	"variables":[
		"handle",
		"data",
		"isGCCreated",
		"profile",
		"appName",
		"keyName",
		"length",
		"buf",
		"nullBuf",
		"n",
		"deviceNames",
		"nameCount",
		"index",
		"i",
		"newNames",
		"printerList",
		"p",
		"device",
		"driver",
		"commaIndex",
		"deviceName",
		"length",
		"buf",
		"nullBuf",
		"n",
		"commaIndex",
		"driver",
		"defaultPrinter",
		"driver",
		"device",
		"lpInitData",
		"buffer",
		"hHeap",
		"mask",
		"di",
		"hHeap",
		"lpszDocName",
		"buffer",
		"byteCount",
		"lpszOutput",
		"buffer",
		"byteCount",
		"rc",
		"rc",
		"dpiX",
		"dpiY",
		"width",
		"height",
		"width",
		"height",
		"printX",
		"printY",
		"printWidth",
		"printHeight",
		"paperWidth",
		"paperHeight",
		"hTrim",
		"vTrim",
		"profile",
		"appName",
		"keyName",
		"length",
		"OS",
		"profile",
		"nullBuf",
		"buf",
		"length",
		"n",
		"i",
		"n",
		"i",
		"buf",
		"i",
		"nameCount",
		"deviceNames",
		"deviceNames",
		"System",
		"deviceNames",
		"newNames",
		"deviceNames",
		"deviceNames",
		"newNames",
		"deviceNames",
		"nameCount",
		"buf",
		"index",
		"i",
		"index",
		"nameCount",
		"index",
		"i",
		"nameCount",
		"p",
		"nameCount",
		"p",
		"deviceNames",
		"p",
		"OS",
		"profile",
		"device",
		"nullBuf",
		"buf",
		"length",
		"buf",
		"commaIndex",
		"commaIndex",
		"length",
		"commaIndex",
		"commaIndex",
		"length",
		"driver",
		"buf",
		"commaIndex",
		"printerList",
		"p",
		"driver",
		"device",
		"printerList",
		"length",
		"OS",
		"appName",
		"keyName",
		"nullBuf",
		"buf",
		"length",
		"n",
		"buf",
		"commaIndex",
		"commaIndex",
		"length",
		"commaIndex",
		"commaIndex",
		"length",
		"deviceName",
		"buf",
		"commaIndex",
		"OS",
		"profile",
		"deviceName",
		"nullBuf",
		"buf",
		"length",
		"commaIndex",
		"buf",
		"commaIndex",
		"commaIndex",
		"length",
		"commaIndex",
		"commaIndex",
		"length",
		"driver",
		"buf",
		"commaIndex",
		"driver",
		"deviceName",
		"data",
		"data",
		"data",
		"data",
		"defaultPrinter",
		"SWT",
		"SWT",
		"data",
		"defaultPrinter",
		"data",
		"defaultPrinter",
		"data",
		"data",
		"data",
		"deviceData",
		"data",
		"data",
		"data",
		"OS",
		"buffer",
		"buffer",
		"lpInitData",
		"OS",
		"hHeap",
		"OS",
		"buffer",
		"OS",
		"lpInitData",
		"buffer",
		"buffer",
		"handle",
		"OS",
		"driver",
		"device",
		"lpInitData",
		"lpInitData",
		"OS",
		"hHeap",
		"lpInitData",
		"handle",
		"SWT",
		"SWT",
		"handle",
		"SWT",
		"SWT",
		"data",
		"isGCCreated",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"data",
		"mask",
		"data",
		"data",
		"SWT",
		"OS",
		"data",
		"SWT",
		"data",
		"data",
		"OS",
		"handle",
		"OS",
		"isGCCreated",
		"handle",
		"data",
		"isGCCreated",
		"di",
		"DOCINFO",
		"OS",
		"jobName",
		"jobName",
		"jobName",
		"buffer",
		"TCHAR",
		"lpszDocName",
		"OS",
		"hHeap",
		"OS",
		"byteCount",
		"OS",
		"lpszDocName",
		"buffer",
		"byteCount",
		"di",
		"lpszDocName",
		"data",
		"data",
		"data",
		"buffer",
		"TCHAR",
		"lpszOutput",
		"OS",
		"hHeap",
		"OS",
		"byteCount",
		"OS",
		"lpszOutput",
		"buffer",
		"byteCount",
		"di",
		"lpszOutput",
		"OS",
		"handle",
		"di",
		"lpszDocName",
		"OS",
		"hHeap",
		"lpszDocName",
		"lpszOutput",
		"OS",
		"hHeap",
		"lpszOutput",
		"rc",
		"OS",
		"handle",
		"OS",
		"handle",
		"OS",
		"handle",
		"rc",
		"OS",
		"handle",
		"rc",
		"OS",
		"handle",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"dpiX",
		"dpiY",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"width",
		"height",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"width",
		"height",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"paperWidth",
		"printWidth",
		"paperHeight",
		"printHeight",
		"x",
		"printX",
		"y",
		"printY",
		"width",
		"hTrim",
		"height",
		"vTrim",
		"data",
		"handle",
		"SWT",
		"SWT",
		"data",
		"handle",
		"OS",
		"handle",
		"handle",
		"length",
		"length",
		"length",
		"driver",
		"name",
		"ERROR_NO_HANDLES",
		"driver",
		"driver",
		"name",
		"name",
		"driver",
		"name",
		"otherData",
		"length",
		"HEAP_ZERO_MEMORY",
		"length",
		"length",
		"ERROR_NO_HANDLES",
		"ERROR_NO_HANDLES",
		"ERROR_INVALID_ARGUMENT",
		"LEFT_TO_RIGHT",
		"RIGHT_TO_LEFT",
		"style",
		"layout",
		"style",
		"RIGHT_TO_LEFT",
		"LAYOUT_RTL",
		"style",
		"LEFT_TO_RIGHT",
		"device",
		"hFont",
		"OBJ_FONT",
		"cbSize",
		"sizeof",
		"sizeof",
		"HEAP_ZERO_MEMORY",
		"lpszDocName",
		"printToFile",
		"fileName",
		"fileName",
		"sizeof",
		"HEAP_ZERO_MEMORY",
		"lpszOutput",
		"LOGPIXELSX",
		"LOGPIXELSY",
		"PHYSICALWIDTH",
		"PHYSICALHEIGHT",
		"HORZRES",
		"VERTRES",
		"PHYSICALOFFSETX",
		"PHYSICALOFFSETY",
		"HORZRES",
		"VERTRES",
		"PHYSICALWIDTH",
		"PHYSICALHEIGHT",
		"ERROR_DEVICE_DISPOSED",
		"data",
		"data",
		"deviceData",
		"data",
		"hDC",
		"data",
		"jobName",
		"x",
		"y",
		"width",
		"height"
	],
	"extendORImplementFiles":[
		"Device"
	],
	"package":[
		"org.eclipse.swt.printing"
	],
	"import":[
		"org.eclipse.swt",
		"org.eclipse.swt.graphics",
		"org.eclipse.swt.internal.win32"
	],
	"methods":[
		"getPrinterList",
		"getDefaultPrinterData",
		"checkNull",
		"create",
		"internal_new_GC",
		"internal_dispose_GC",
		"startJob",
		"endJob",
		"cancelJob",
		"startPage",
		"endPage",
		"getDPI",
		"getBounds",
		"getClientArea",
		"computeTrim",
		"getPrinterData",
		"checkDevice",
		"release",
		"destroy",
		"GetProfileString",
		"tcharAt",
		"arraycopy",
		"toString",
		"GetProfileString",
		"tcharAt",
		"toString",
		"GetProfileString",
		"tcharAt",
		"toString",
		"GetProfileString",
		"tcharAt",
		"toString",
		"getDefaultPrinterData",
		"error",
		"checkNull",
		"GetProcessHeap",
		"HeapAlloc",
		"MoveMemory",
		"CreateDC",
		"HeapFree",
		"error",
		"error",
		"error",
		"GetCurrentObject",
		"checkDevice",
		"GetProcessHeap",
		"length",
		"length",
		"HeapAlloc",
		"MoveMemory",
		"length",
		"HeapAlloc",
		"MoveMemory",
		"StartDoc",
		"HeapFree",
		"HeapFree",
		"checkDevice",
		"EndDoc",
		"checkDevice",
		"AbortDoc",
		"checkDevice",
		"StartPage",
		"AbortDoc",
		"checkDevice",
		"EndPage",
		"checkDevice",
		"GetDeviceCaps",
		"GetDeviceCaps",
		"checkDevice",
		"GetDeviceCaps",
		"GetDeviceCaps",
		"checkDevice",
		"GetDeviceCaps",
		"GetDeviceCaps",
		"checkDevice",
		"GetDeviceCaps",
		"GetDeviceCaps",
		"GetDeviceCaps",
		"GetDeviceCaps",
		"GetDeviceCaps",
		"GetDeviceCaps",
		"error",
		"release",
		"DeleteDC",
		"TCHAR",
		"TCHAR",
		"TCHAR",
		"TCHAR",
		"TCHAR",
		"TCHAR",
		"PrinterData",
		"TCHAR",
		"TCHAR",
		"TCHAR",
		"PrinterData",
		"PrinterData",
		"TCHAR",
		"TCHAR",
		"DOCINFO",
		"TCHAR",
		"TCHAR",
		"Point",
		"Rectangle",
		"Rectangle",
		"Rectangle"
	],
	"methodsBody":{
		"protected void create(DeviceData deviceData)":{
			"methodBody":"{\n    data = (PrinterData) deviceData;\n    \n    TCHAR driver = new TCHAR(0, data.driver, true);\n    TCHAR device = new TCHAR(0, data.name, true);\n    int lpInitData = 0;\n    byte[] buffer = data.otherData;\n    int hHeap = OS.GetProcessHeap();\n    if (buffer != null && buffer.length != 0) {\n        lpInitData = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, buffer.length);\n        OS.MoveMemory(lpInitData, buffer, buffer.length);\n    }\n    handle = OS.CreateDC(driver, device, 0, lpInitData);\n    if (lpInitData != 0)\n        OS.HeapFree(hHeap, 0, lpInitData);\n    if (handle == 0)\n        SWT.error(SWT.ERROR_NO_HANDLES);\n}",
			"comments":"/**\n* Creates the printer handle.\n* This method is called internally by the instance creation\n* mechanism of the <code>Device</code> class.\n* @param deviceData the device data\n*/\n/* Use the character encoding for the default locale */\n",
			"methodName":"protected void create(DeviceData deviceData)"
		},
		"public void endJob()":{
			"methodBody":"{\n    checkDevice();\n    OS.EndDoc(handle);\n}",
			"comments":"/**\n* Ends the current print job.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #startJob\n* @see #startPage\n* @see #endPage\n*/\n",
			"methodName":"public void endJob()"
		},
		"public Rectangle getBounds()":{
			"methodBody":"{\n    checkDevice();\n    int width = OS.GetDeviceCaps(handle, OS.PHYSICALWIDTH);\n    int height = OS.GetDeviceCaps(handle, OS.PHYSICALHEIGHT);\n    return new Rectangle(0, 0, width, height);\n}",
			"comments":"/**\n* Returns a rectangle describing the receiver's size and location.\n* For a printer, this is the size of a page, in pixels.\n*\n* @return the bounding rectangle\n*\n* @exception SWTException <ul>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #getClientArea\n* @see #computeTrim\n*/\n",
			"methodName":"public Rectangle getBounds()"
		},
		"public void endPage()":{
			"methodBody":"{\n    checkDevice();\n    OS.EndPage(handle);\n}",
			"comments":"/**\n* Ends the current page.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #startPage\n* @see #startJob\n* @see #endJob\n*/\n",
			"methodName":"public void endPage()"
		},
		"public static PrinterData[] getPrinterList()":{
			"methodBody":"{\n    int length = 1024;\n    \n    TCHAR buf = new TCHAR(0, length);\n    TCHAR nullBuf = new TCHAR(0, 1);\n    int n = OS.GetProfileString(profile, null, nullBuf, buf, length);\n    if (n == 0)\n        return new PrinterData[0];\n    String[] deviceNames = new String[5];\n    int nameCount = 0;\n    int index = 0;\n    for (int i = 0; i < n; i++) {\n        if (buf.tcharAt(i) == 0) {\n            if (nameCount == deviceNames.length) {\n                String[] newNames = new String[deviceNames.length + 5];\n                System.arraycopy(deviceNames, 0, newNames, 0, deviceNames.length);\n                deviceNames = newNames;\n            }\n            deviceNames[nameCount] = buf.toString(index, i - index);\n            nameCount++;\n            index = i + 1;\n        }\n    }\n    PrinterData[] printerList = new PrinterData[nameCount];\n    for (int p = 0; p < nameCount; p++) {\n        String device = deviceNames[p];\n        \n        String driver = \"\";\n        if (OS.GetProfileString(profile, new TCHAR(0, device, true), nullBuf, buf, length) > 0) {\n            int commaIndex = 0;\n            while (buf.tcharAt(commaIndex) != ',' && commaIndex < length) commaIndex++;\n            if (commaIndex < length) {\n                driver = buf.toString(0, commaIndex);\n            }\n        }\n        printerList[p] = new PrinterData(driver, device);\n    }\n    return printerList;\n}",
			"comments":"/**\n* Returns an array of <code>PrinterData</code> objects\n* representing all available printers.\n*\n* @return the list of available printers\n*/\n/* Use the character encoding for the default locale */\n//$NON-NLS-1$\n",
			"methodName":"public static PrinterData[] getPrinterList()"
		},
		"public boolean startPage()":{
			"methodBody":"{\n    checkDevice();\n    int rc = OS.StartPage(handle);\n    if (rc <= 0)\n        OS.AbortDoc(handle);\n    return rc > 0;\n}",
			"comments":"/**\n* Starts a page and returns true if the page started successfully\n* and false otherwise.\n* <p>\n* After calling startJob, this method may be called any number of times\n* along with a matching endPage.\n* </p>\n*\n* @return true if the page started successfully and false otherwise.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #endPage\n* @see #startJob\n* @see #endJob\n*/\n",
			"methodName":"public boolean startPage()"
		},
		"protected void destroy()":{
			"methodBody":"{\n    if (handle != 0)\n        OS.DeleteDC(handle);\n    handle = 0;\n}",
			"comments":"/**\n* Destroys the printer handle.\n* This method is called internally by the dispose\n* mechanism of the <code>Device</code> class.\n*/\n",
			"methodName":"protected void destroy()"
		},
		"public Point getDPI()":{
			"methodBody":"{\n    checkDevice();\n    int dpiX = OS.GetDeviceCaps(handle, OS.LOGPIXELSX);\n    int dpiY = OS.GetDeviceCaps(handle, OS.LOGPIXELSY);\n    return new Point(dpiX, dpiY);\n}",
			"comments":"/**\n* Returns a point whose x coordinate is the horizontal\n* dots per inch of the printer, and whose y coordinate\n* is the vertical dots per inch of the printer.\n*\n* @return the horizontal and vertical DPI\n*\n* @exception SWTException <ul>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public Point getDPI()"
		},
		"public Rectangle getClientArea()":{
			"methodBody":"{\n    checkDevice();\n    int width = OS.GetDeviceCaps(handle, OS.HORZRES);\n    int height = OS.GetDeviceCaps(handle, OS.VERTRES);\n    return new Rectangle(0, 0, width, height);\n}",
			"comments":"/**\n* Returns a rectangle which describes the area of the\n* receiver which is capable of displaying data.\n* For a printer, this is the size of the printable area\n* of a page, in pixels.\n*\n* @return the client area\n*\n* @exception SWTException <ul>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #getBounds\n* @see #computeTrim\n*/\n",
			"methodName":"public Rectangle getClientArea()"
		},
		"public Rectangle computeTrim(int x, int y, int width, int height)":{
			"methodBody":"{\n    checkDevice();\n    int printX = -OS.GetDeviceCaps(handle, OS.PHYSICALOFFSETX);\n    int printY = -OS.GetDeviceCaps(handle, OS.PHYSICALOFFSETY);\n    int printWidth = OS.GetDeviceCaps(handle, OS.HORZRES);\n    int printHeight = OS.GetDeviceCaps(handle, OS.VERTRES);\n    int paperWidth = OS.GetDeviceCaps(handle, OS.PHYSICALWIDTH);\n    int paperHeight = OS.GetDeviceCaps(handle, OS.PHYSICALHEIGHT);\n    int hTrim = paperWidth - printWidth;\n    int vTrim = paperHeight - printHeight;\n    return new Rectangle(x + printX, y + printY, width + hTrim, height + vTrim);\n}",
			"comments":"/**\n* Given a desired <em>client area</em> for the receiver\n* (as described by the arguments), returns the bounding\n* rectangle which would be required to produce that client\n* area.\n* <p>\n* In other words, it returns a rectangle such that, if the\n* receiver's bounds were set to that rectangle, the area\n* of the receiver which is capable of displaying data\n* (that is, not covered by the \"trimmings\") would be the\n* rectangle described by the arguments (relative to the\n* receiver's parent).\n* </p>\n* Note that there is no setBounds for a printer. This method\n* is usually used by passing in the client area (the 'printable\n* area') of the printer. It can also be useful to pass in 0, 0, 0, 0.\n*\n* @param x the desired x coordinate of the client area\n* @param y the desired y coordinate of the client area\n* @param width the desired width of the client area\n* @param height the desired height of the client area\n* @return the required bounds to produce the given client area\n*\n* @exception SWTException <ul>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #getBounds\n* @see #getClientArea\n*/\n",
			"methodName":"public Rectangle computeTrim(int x, int y, int width, int height)"
		},
		"public void internal_dispose_GC(int hDC, GCData data)":{
			"methodBody":"{\n    if (data != null)\n        isGCCreated = false;\n}",
			"comments":"/**\n* Invokes platform specific functionality to dispose a GC handle.\n* <p>\n* <b>IMPORTANT:</b> This method is <em>not</em> part of the public\n* API for <code>Printer</code>. It is marked public only so that it\n* can be shared within the packages provided by SWT. It is not\n* available on all platforms, and should never be called from\n* application code.\n* </p>\n*\n* @param hDC the platform specific GC handle\n* @param data the platform specific GC data\n*/\n",
			"methodName":"public void internal_dispose_GC(int hDC, GCData data)"
		},
		"public PrinterData getPrinterData()":{
			"methodBody":"{\n    return data;\n}",
			"comments":"/**\n* Returns a <code>PrinterData</code> object representing the\n* target printer for this print job.\n*\n* @return a PrinterData object describing the receiver\n*/\n",
			"methodName":"public PrinterData getPrinterData()"
		},
		"public int internal_new_GC(GCData data)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_NO_HANDLES);\n    if (data != null) {\n        if (isGCCreated)\n            SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n        int mask = SWT.LEFT_TO_RIGHT | SWT.RIGHT_TO_LEFT;\n        if ((data.style & mask) != 0) {\n            data.layout = (data.style & SWT.RIGHT_TO_LEFT) != 0 ? OS.LAYOUT_RTL : 0;\n        } else {\n            data.style |= SWT.LEFT_TO_RIGHT;\n        }\n        data.device = this;\n        data.hFont = OS.GetCurrentObject(handle, OS.OBJ_FONT);\n        isGCCreated = true;\n    }\n    return handle;\n}",
			"comments":"/**\n* Invokes platform specific functionality to allocate a new GC handle.\n* <p>\n* <b>IMPORTANT:</b> This method is <em>not</em> part of the public\n* API for <code>Printer</code>. It is marked public only so that it\n* can be shared within the packages provided by SWT. It is not\n* available on all platforms, and should never be called from\n* application code.\n* </p>\n*\n* @param data the platform specific GC data\n* @return the platform specific GC handle\n*/\n",
			"methodName":"public int internal_new_GC(GCData data)"
		},
		"protected void checkDevice()":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_DEVICE_DISPOSED);\n}",
			"comments":"/**\n* Checks the validity of this device.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"protected void checkDevice()"
		},
		"protected void release()":{
			"methodBody":"{\n    super.release();\n    data = null;\n}",
			"comments":"/**\n* Releases any internal state prior to destroying this printer.\n* This method is called internally by the dispose\n* mechanism of the <code>Device</code> class.\n*/\n",
			"methodName":"protected void release()"
		},
		"static DeviceData checkNull(PrinterData data)":{
			"methodBody":"{\n    if (data == null)\n        data = new PrinterData();\n    if (data.driver == null || data.name == null) {\n        PrinterData defaultPrinter = getDefaultPrinterData();\n        if (defaultPrinter == null)\n            SWT.error(SWT.ERROR_NO_HANDLES);\n        data.driver = defaultPrinter.driver;\n        data.name = defaultPrinter.name;\n    }\n    return data;\n}",
			"comments":"",
			"methodName":"static DeviceData checkNull(PrinterData data)"
		},
		"public static PrinterData getDefaultPrinterData()":{
			"methodBody":"{\n    String deviceName = null;\n    int length = 1024;\n    \n    TCHAR buf = new TCHAR(0, length);\n    TCHAR nullBuf = new TCHAR(0, 1);\n    int n = OS.GetProfileString(appName, keyName, nullBuf, buf, length);\n    if (n == 0)\n        return null;\n    int commaIndex = 0;\n    while (buf.tcharAt(commaIndex) != ',' && commaIndex < length) commaIndex++;\n    if (commaIndex < length) {\n        deviceName = buf.toString(0, commaIndex);\n    }\n    \n    String driver = \"\";\n    if (OS.GetProfileString(profile, new TCHAR(0, deviceName, true), nullBuf, buf, length) > 0) {\n        commaIndex = 0;\n        while (buf.tcharAt(commaIndex) != ',' && commaIndex < length) commaIndex++;\n        if (commaIndex < length) {\n            driver = buf.toString(0, commaIndex);\n        }\n    }\n    return new PrinterData(driver, deviceName);\n}",
			"comments":"/**\n* Returns a <code>PrinterData</code> object representing\n* the default printer or <code>null</code> if there is no\n* printer available on the System.\n*\n* @return the default printer data or null\n*\n* @since 2.1\n*/\n/* Use the character encoding for the default locale */\n//$NON-NLS-1$\n",
			"methodName":"public static PrinterData getDefaultPrinterData()"
		},
		"public boolean startJob(String jobName)":{
			"methodBody":"{\n    checkDevice();\n    DOCINFO di = new DOCINFO();\n    di.cbSize = DOCINFO.sizeof;\n    int hHeap = OS.GetProcessHeap();\n    int lpszDocName = 0;\n    if (jobName != null && jobName.length() != 0) {\n        \n        TCHAR buffer = new TCHAR(0, jobName, true);\n        int byteCount = buffer.length() * TCHAR.sizeof;\n        lpszDocName = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, byteCount);\n        OS.MoveMemory(lpszDocName, buffer, byteCount);\n        di.lpszDocName = lpszDocName;\n    }\n    int lpszOutput = 0;\n    if (data.printToFile && data.fileName != null) {\n        \n        TCHAR buffer = new TCHAR(0, data.fileName, true);\n        int byteCount = buffer.length() * TCHAR.sizeof;\n        lpszOutput = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, byteCount);\n        OS.MoveMemory(lpszOutput, buffer, byteCount);\n        di.lpszOutput = lpszOutput;\n    }\n    int rc = OS.StartDoc(handle, di);\n    if (lpszDocName != 0)\n        OS.HeapFree(hHeap, 0, lpszDocName);\n    if (lpszOutput != 0)\n        OS.HeapFree(hHeap, 0, lpszOutput);\n    return rc > 0;\n}",
			"comments":"/**\n* Starts a print job and returns true if the job started successfully\n* and false otherwise.\n* <p>\n* This must be the first method called to initiate a print job,\n* followed by any number of startPage/endPage calls, followed by\n* endJob. Calling startPage, endPage, or endJob before startJob\n* will result in undefined behavior.\n* </p>\n*\n* @param jobName the name of the print job to start\n* @return true if the job started successfully and false otherwise.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #startPage\n* @see #endPage\n* @see #endJob\n*/\n/* Use the character encoding for the default locale */\n/* Use the character encoding for the default locale */\n",
			"methodName":"public boolean startJob(String jobName)"
		},
		"public void cancelJob()":{
			"methodBody":"{\n    checkDevice();\n    OS.AbortDoc(handle);\n}",
			"comments":"/**\n* Cancels a print job in progress.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void cancelJob()"
		}
	},
	"ClassORInterfaceName":[
		"Printer"
	]
}
