{
	"variables":[
		"objIDispatch",
		"exceptionDescription",
		"objITypeInfo",
		"ppv",
		"result",
		"ppv",
		"result",
		"file",
		"rc",
		"doc",
		"rc",
		"ppVarDesc",
		"rc",
		"vardesc",
		"data",
		"vt",
		"ppFuncDesc",
		"rc",
		"funcdesc",
		"data",
		"names",
		"i",
		"vt",
		"pTypedesc",
		"vt2",
		"wParamFlags",
		"vt",
		"ppTypeAttr",
		"rc",
		"typeattr",
		"name",
		"rc",
		"names",
		"count",
		"rc",
		"newNames",
		"rgdispid",
		"result",
		"pVarResult",
		"result",
		"pVarResult",
		"result",
		"pVarResult",
		"result",
		"pVarResult",
		"result",
		"pVarResult",
		"result",
		"pVarResult",
		"result",
		"pDispParams",
		"offset",
		"i",
		"offset",
		"i",
		"excepInfo",
		"pArgErr",
		"pVarResultAddress",
		"result",
		"offset",
		"i",
		"length",
		"result",
		"result",
		"result",
		"size",
		"buffer",
		"rgvarg2",
		"rgdispidNamedArgs",
		"dwFlags",
		"pVarResult",
		"result",
		"rgdispidNamedArgs",
		"dwFlags",
		"i",
		"pVarResult",
		"result",
		"idispatch",
		"OLE",
		"OLE",
		"objIDispatch",
		"idispatch",
		"objIDispatch",
		"objIDispatch",
		"COM",
		"ppv",
		"result",
		"OLE",
		"objITypeInfo",
		"ppv",
		"objITypeInfo",
		"clientSite",
		"OLE",
		"OLE",
		"objIDispatch",
		"clientSite",
		"objIDispatch",
		"COM",
		"ppv",
		"result",
		"OLE",
		"objITypeInfo",
		"ppv",
		"objITypeInfo",
		"objIDispatch",
		"objIDispatch",
		"objIDispatch",
		"objITypeInfo",
		"objITypeInfo",
		"objITypeInfo",
		"objIDispatch",
		"objITypeInfo",
		"objITypeInfo",
		"dispId",
		"file",
		"rc",
		"OLE",
		"file",
		"objITypeInfo",
		"objITypeInfo",
		"dispId",
		"doc",
		"rc",
		"OLE",
		"doc",
		"objITypeInfo",
		"objITypeInfo",
		"index",
		"ppVarDesc",
		"rc",
		"OLE",
		"COM",
		"vardesc",
		"ppVarDesc",
		"VARDESC",
		"data",
		"vardesc",
		"data",
		"vardesc",
		"data",
		"vardesc",
		"data",
		"OLE",
		"COM",
		"vt",
		"vardesc",
		"data",
		"vt",
		"data",
		"vardesc",
		"data",
		"vardesc",
		"data",
		"vardesc",
		"data",
		"vardesc",
		"objITypeInfo",
		"ppVarDesc",
		"data",
		"objITypeInfo",
		"objITypeInfo",
		"index",
		"ppFuncDesc",
		"rc",
		"OLE",
		"COM",
		"funcdesc",
		"ppFuncDesc",
		"FUNCDESC",
		"data",
		"funcdesc",
		"data",
		"funcdesc",
		"data",
		"funcdesc",
		"data",
		"funcdesc",
		"data",
		"funcdesc",
		"data",
		"funcdesc",
		"data",
		"funcdesc",
		"data",
		"funcdesc",
		"funcdesc",
		"funcdesc",
		"names",
		"data",
		"names",
		"data",
		"funcdesc",
		"i",
		"data",
		"i",
		"data",
		"i",
		"names",
		"i",
		"data",
		"i",
		"names",
		"i",
		"COM",
		"vt",
		"funcdesc",
		"i",
		"vt",
		"OLE",
		"COM",
		"pTypedesc",
		"funcdesc",
		"i",
		"COM",
		"vt2",
		"pTypedesc",
		"vt",
		"vt2",
		"COM",
		"data",
		"i",
		"vt",
		"COM",
		"wParamFlags",
		"funcdesc",
		"i",
		"data",
		"i",
		"wParamFlags",
		"data",
		"funcdesc",
		"data",
		"OLE",
		"COM",
		"vt",
		"funcdesc",
		"data",
		"vt",
		"objITypeInfo",
		"ppFuncDesc",
		"data",
		"objITypeInfo",
		"objITypeInfo",
		"ppTypeAttr",
		"rc",
		"OLE",
		"COM",
		"typeattr",
		"ppTypeAttr",
		"TYPEATTR",
		"objITypeInfo",
		"ppTypeAttr",
		"typeattr",
		"objITypeInfo",
		"objITypeInfo",
		"dispId",
		"name",
		"rc",
		"OLE",
		"name",
		"objITypeInfo",
		"maxSize",
		"objITypeInfo",
		"dispId",
		"names",
		"maxSize",
		"count",
		"rc",
		"OLE",
		"count",
		"System",
		"names",
		"newNames",
		"count",
		"newNames",
		"names",
		"objIDispatch",
		"names",
		"names",
		"COM",
		"rgdispid",
		"result",
		"COM",
		"rgdispid",
		"exceptionDescription",
		"dispIdMember",
		"COM",
		"pVarResult",
		"result",
		"OLE",
		"pVarResult",
		"dispIdMember",
		"COM",
		"rgvarg",
		"pVarResult",
		"result",
		"OLE",
		"pVarResult",
		"dispIdMember",
		"COM",
		"rgvarg",
		"rgdispidNamedArgs",
		"pVarResult",
		"result",
		"OLE",
		"pVarResult",
		"dispIdMember",
		"COM",
		"pVarResult",
		"result",
		"COM",
		"pVarResult",
		"dispIdMember",
		"COM",
		"rgvarg",
		"pVarResult",
		"result",
		"COM",
		"pVarResult",
		"dispIdMember",
		"COM",
		"rgvarg",
		"rgdispidNamedArgs",
		"pVarResult",
		"result",
		"COM",
		"pVarResult",
		"objIDispatch",
		"COM",
		"rgvarg",
		"rgvarg",
		"pDispParams",
		"rgvarg",
		"pDispParams",
		"OS",
		"COM",
		"COM",
		"Variant",
		"rgvarg",
		"rgvarg",
		"i",
		"i",
		"rgvarg",
		"i",
		"pDispParams",
		"offset",
		"offset",
		"Variant",
		"rgdispidNamedArgs",
		"rgdispidNamedArgs",
		"pDispParams",
		"rgdispidNamedArgs",
		"pDispParams",
		"OS",
		"COM",
		"COM",
		"rgdispidNamedArgs",
		"rgdispidNamedArgs",
		"i",
		"i",
		"COM",
		"pDispParams",
		"offset",
		"rgdispidNamedArgs",
		"i",
		"offset",
		"pVarResult",
		"pVarResultAddress",
		"OS",
		"OS",
		"OS",
		"Variant",
		"objIDispatch",
		"dispIdMember",
		"COM",
		"wFlags",
		"pDispParams",
		"pVarResultAddress",
		"excepInfo",
		"pArgErr",
		"pVarResultAddress",
		"pVarResult",
		"pVarResultAddress",
		"COM",
		"pVarResultAddress",
		"OS",
		"pVarResultAddress",
		"pDispParams",
		"OS",
		"pDispParams",
		"pDispParams",
		"rgvarg",
		"i",
		"length",
		"i",
		"COM",
		"pDispParams",
		"offset",
		"offset",
		"Variant",
		"OS",
		"pDispParams",
		"result",
		"excepInfo",
		"result",
		"dispIdMember",
		"COM",
		"result",
		"COM",
		"OLE",
		"OLE",
		"result",
		"dispIdMember",
		"COM",
		"rgvarg",
		"result",
		"COM",
		"OLE",
		"OLE",
		"result",
		"dispIdMember",
		"COM",
		"rgvarg",
		"rgdispidNamedArgs",
		"result",
		"COM",
		"OLE",
		"OLE",
		"result",
		"hResult",
		"COM",
		"exceptionDescription",
		"hResult",
		"COM",
		"excepInfo",
		"COM",
		"excepInfo",
		"size",
		"COM",
		"buffer",
		"excepInfo",
		"size",
		"exceptionDescription",
		"buffer",
		"exceptionDescription",
		"excepInfo",
		"exceptionDescription",
		"excepInfo",
		"excepInfo",
		"exceptionDescription",
		"excepInfo",
		"exceptionDescription",
		"hResult",
		"excepInfo",
		"COM",
		"excepInfo",
		"excepInfo",
		"COM",
		"excepInfo",
		"excepInfo",
		"COM",
		"excepInfo",
		"rgvarg",
		"COM",
		"COM",
		"rgvarg",
		"COM",
		"COM",
		"dwFlags",
		"COM",
		"dispIdMember",
		"dwFlags",
		"rgvarg2",
		"rgdispidNamedArgs",
		"pVarResult",
		"result",
		"COM",
		"COM",
		"COM",
		"i",
		"rgvarg",
		"i",
		"rgvarg",
		"i",
		"COM",
		"COM",
		"dwFlags",
		"COM",
		"dispIdMember",
		"dwFlags",
		"rgvarg",
		"rgdispidNamedArgs",
		"pVarResult",
		"result",
		"COM",
		"ERROR_INVALID_INTERFACE_ADDRESS",
		"LOCALE_USER_DEFAULT",
		"S_OK",
		"ERROR_INVALID_INTERFACE_ADDRESS",
		"LOCALE_USER_DEFAULT",
		"S_OK",
		"S_OK",
		"S_OK",
		"S_OK",
		"sizeof",
		"id",
		"memid",
		"name",
		"memid",
		"type",
		"elemdescVar_tdesc_vt",
		"type",
		"VT_PTR",
		"elemdescVar_tdesc_union",
		"type",
		"flags",
		"wVarFlags",
		"kind",
		"varkind",
		"description",
		"memid",
		"helpFile",
		"memid",
		"S_OK",
		"sizeof",
		"id",
		"memid",
		"optionalArgCount",
		"cParamsOpt",
		"invokeKind",
		"invkind",
		"funcKind",
		"funckind",
		"flags",
		"wFuncFlags",
		"callingConvention",
		"callconv",
		"documentation",
		"memid",
		"helpFile",
		"memid",
		"memid",
		"cParams",
		"length",
		"name",
		"args",
		"cParams",
		"length",
		"args",
		"args",
		"length",
		"name",
		"args",
		"lprgelemdescParam",
		"VT_PTR",
		"lprgelemdescParam",
		"VT_BYREF",
		"type",
		"args",
		"lprgelemdescParam",
		"flags",
		"args",
		"returnType",
		"elemdescFunc_tdesc_vt",
		"returnType",
		"VT_PTR",
		"elemdescFunc_tdesc_union",
		"returnType",
		"S_OK",
		"sizeof",
		"S_OK",
		"S_OK",
		"length",
		"length",
		"LOCALE_USER_DEFAULT",
		"S_OK",
		"DISPATCH_PROPERTYGET",
		"S_OK",
		"DISPATCH_PROPERTYGET",
		"S_OK",
		"DISPATCH_PROPERTYGET",
		"S_OK",
		"DISPATCH_METHOD",
		"S_OK",
		"DISPATCH_METHOD",
		"S_OK",
		"DISPATCH_METHOD",
		"S_OK",
		"E_FAIL",
		"length",
		"cArgs",
		"length",
		"rgvarg",
		"GMEM_FIXED",
		"GMEM_ZEROINIT",
		"sizeof",
		"length",
		"length",
		"rgvarg",
		"sizeof",
		"length",
		"cNamedArgs",
		"length",
		"rgdispidNamedArgs",
		"GMEM_FIXED",
		"GMEM_ZEROINIT",
		"length",
		"length",
		"rgdispidNamedArgs",
		"GMEM_FIXED",
		"GMEM_ZEROINIT",
		"sizeof",
		"LOCALE_USER_DEFAULT",
		"rgdispidNamedArgs",
		"rgdispidNamedArgs",
		"rgvarg",
		"length",
		"rgvarg",
		"sizeof",
		"rgvarg",
		"DISPATCH_METHOD",
		"S_OK",
		"ERROR_ACTION_NOT_PERFORMED",
		"DISPATCH_METHOD",
		"S_OK",
		"ERROR_ACTION_NOT_PERFORMED",
		"DISPATCH_METHOD",
		"S_OK",
		"ERROR_ACTION_NOT_PERFORMED",
		"S_OK",
		"DISP_E_EXCEPTION",
		"bstrDescription",
		"bstrDescription",
		"bstrDescription",
		"wCode",
		"wCode",
		"scode",
		"scode",
		"bstrDescription",
		"bstrDescription",
		"bstrHelpFile",
		"bstrHelpFile",
		"bstrSource",
		"bstrSource",
		"DISPID_PROPERTYPUT",
		"DISPATCH_PROPERTYPUT",
		"VT_BYREF",
		"VT_BYREF",
		"DISPATCH_PROPERTYPUTREF",
		"S_OK",
		"DISPID_PROPERTYPUT",
		"DISPATCH_PROPERTYPUT",
		"length",
		"VT_BYREF",
		"VT_BYREF",
		"DISPATCH_PROPERTYPUTREF",
		"S_OK",
		"idispatch",
		"clientSite",
		"dispId",
		"dispId",
		"index",
		"index",
		"dispId",
		"dispId",
		"maxSize",
		"names",
		"dispIdMember",
		"dispIdMember",
		"rgvarg",
		"dispIdMember",
		"rgvarg",
		"rgdispidNamedArgs",
		"dispIdMember",
		"dispIdMember",
		"rgvarg",
		"dispIdMember",
		"rgvarg",
		"rgdispidNamedArgs",
		"dispIdMember",
		"wFlags",
		"rgvarg",
		"rgdispidNamedArgs",
		"pVarResult",
		"dispIdMember",
		"dispIdMember",
		"rgvarg",
		"dispIdMember",
		"rgvarg",
		"rgdispidNamedArgs",
		"hResult",
		"excepInfo",
		"dispIdMember",
		"rgvarg",
		"dispIdMember",
		"rgvarg"
	],
	"extendORImplementFiles":[],
	"package":[
		"org.eclipse.swt.ole.win32"
	],
	"import":[
		"org.eclipse.swt.internal.ole.win32",
		"org.eclipse.swt.internal.win32"
	],
	"methods":[
		"dispose",
		"getAddress",
		"getHelpFile",
		"getDocumentation",
		"getPropertyDescription",
		"getFunctionDescription",
		"getTypeInfoAttributes",
		"getName",
		"getNames",
		"getIDsOfNames",
		"getLastError",
		"getProperty",
		"getProperty",
		"getProperty",
		"invoke",
		"invoke",
		"invoke",
		"invoke",
		"invokeNoReply",
		"invokeNoReply",
		"invokeNoReply",
		"manageExcepinfo",
		"setProperty",
		"setProperty",
		"error",
		"AddRef",
		"GetTypeInfo",
		"AddRef",
		"error",
		"getAutomationObject",
		"GetTypeInfo",
		"AddRef",
		"Release",
		"Release",
		"getAddress",
		"GetDocumentation",
		"GetDocumentation",
		"GetVarDesc",
		"MoveMemory",
		"getName",
		"MoveMemory",
		"getDocumentation",
		"getHelpFile",
		"ReleaseVarDesc",
		"GetFuncDesc",
		"MoveMemory",
		"getDocumentation",
		"getHelpFile",
		"getNames",
		"MoveMemory",
		"MoveMemory",
		"MoveMemory",
		"MoveMemory",
		"MoveMemory",
		"ReleaseFuncDesc",
		"GetTypeAttr",
		"MoveMemory",
		"ReleaseTypeAttr",
		"GetDocumentation",
		"GetNames",
		"arraycopy",
		"GetIDsOfNames",
		"invoke",
		"invoke",
		"invoke",
		"invoke",
		"invoke",
		"invoke",
		"GlobalAlloc",
		"getData",
		"GlobalAlloc",
		"MoveMemory",
		"GlobalAlloc",
		"Invoke",
		"setData",
		"VariantClear",
		"GlobalFree",
		"GlobalFree",
		"VariantClear",
		"GlobalFree",
		"manageExcepinfo",
		"invoke",
		"error",
		"invoke",
		"error",
		"invoke",
		"error",
		"SysStringByteLen",
		"MoveMemory",
		"SysFreeString",
		"SysFreeString",
		"SysFreeString",
		"getType",
		"invoke",
		"getType",
		"invoke",
		"ITypeInfo",
		"ITypeInfo",
		"VARDESC",
		"OlePropertyDescription",
		"FUNCDESC",
		"OleFunctionDescription",
		"OleParameterDescription",
		"TYPEATTR",
		"GUID",
		"Variant",
		"Variant",
		"Variant",
		"Variant",
		"Variant",
		"Variant",
		"DISPPARAMS",
		"EXCEPINFO",
		"GUID",
		"String",
		"Variant",
		"Variant"
	],
	"methodsBody":{
		"public String getLastError()":{
			"methodBody":"{\n    return exceptionDescription;\n}",
			"comments":"/**\n* Returns a description of the last error encountered.\n*\n* @return a description of the last error encountered\n*/\n",
			"methodName":"public String getLastError()"
		},
		"public Variant invoke(int dispIdMember, Variant[] rgvarg, int[] rgdispidNamedArgs)":{
			"methodBody":"{\n    Variant pVarResult = new Variant();\n    int result = invoke(dispIdMember, COM.DISPATCH_METHOD, rgvarg, rgdispidNamedArgs, pVarResult);\n    return (result == COM.S_OK) ? pVarResult : null;\n}",
			"comments":"/**\n* Invokes a method on the OLE Object; the method has optional parameters.  It is not\n* necessary to specify all the optional parameters, only include the parameters for which\n* you are providing values.\n*\n* @param dispIdMember the ID of the method as specified by the IDL of the ActiveX Control; the\n*        value for the ID can be obtained using OleAutomation.getIDsOfNames\n*\n* @param rgvarg an array of arguments for the method.  All arguments are considered to be\n*        read only unless the Variant is a By Reference Variant type.\n*\n* @param rgdispidNamedArgs an array of identifiers for the arguments specified in rgvarg; the\n*        parameter IDs must be in the same order as their corresponding values;\n*        all arguments must have an identifier - identifiers can be obtained using\n*        OleAutomation.getIDsOfNames\n*\n* @return the result of the method or null if the method failed to give result information\n*/\n",
			"methodName":"public Variant invoke(int dispIdMember, Variant[] rgvarg, int[] rgdispidNamedArgs)"
		},
		"public void dispose()":{
			"methodBody":"{\n    if (objIDispatch != null) {\n        objIDispatch.Release();\n    }\n    objIDispatch = null;\n    if (objITypeInfo != null) {\n        objITypeInfo.Release();\n    }\n    objITypeInfo = null;\n}",
			"comments":"/**\n* Disposes the automation object.\n* <p>\n* This method releases the IDispatch interface on the OLE Document or ActiveX Control.\n* Do not use the OleAutomation object after it has been disposed.\n*/\n",
			"methodName":"public void dispose()"
		},
		"public String getDocumentation(int dispId)":{
			"methodBody":"{\n    if (objITypeInfo == null)\n        return null;\n    String[] doc = new String[1];\n    int rc = objITypeInfo.GetDocumentation(dispId, null, doc, null, null);\n    if (rc == OLE.S_OK)\n        return doc[0];\n    return null;\n}",
			"comments":"",
			"methodName":"public String getDocumentation(int dispId)"
		},
		"public void invokeNoReply(int dispIdMember)":{
			"methodBody":"{\n    int result = invoke(dispIdMember, COM.DISPATCH_METHOD, null, null, null);\n    if (result != COM.S_OK)\n        OLE.error(OLE.ERROR_ACTION_NOT_PERFORMED, result);\n}",
			"comments":"/**\n* Invokes a method on the OLE Object; the method has no parameters.  In the early days of OLE,\n* the IDispatch interface was not well defined and some applications (mainly Word) did not support\n* a return value.  For these applications, call this method instead of calling\n* <code>public void invoke(int dispIdMember)</code>.\n*\n* @param dispIdMember the ID of the method as specified by the IDL of the ActiveX Control; the\n*        value for the ID can be obtained using OleAutomation.getIDsOfNames\n*\n* @exception SWTException <ul>\n*\t\t<li>ERROR_ACTION_NOT_PERFORMED when method invocation fails\n*\t</ul>\n*/\n",
			"methodName":"public void invokeNoReply(int dispIdMember)"
		},
		"public boolean setProperty(int dispIdMember, Variant rgvarg)":{
			"methodBody":"{\n    Variant[] rgvarg2 = new Variant[] { rgvarg };\n    int[] rgdispidNamedArgs = new int[] { COM.DISPID_PROPERTYPUT };\n    int dwFlags = COM.DISPATCH_PROPERTYPUT;\n    if ((rgvarg.getType() & COM.VT_BYREF) == COM.VT_BYREF)\n        dwFlags = COM.DISPATCH_PROPERTYPUTREF;\n    Variant pVarResult = new Variant();\n    int result = invoke(dispIdMember, dwFlags, rgvarg2, rgdispidNamedArgs, pVarResult);\n    return (result == COM.S_OK);\n}",
			"comments":"/**\n* Sets the property specified by the dispIdMember to a new value.\n*\n* @param dispIdMember the ID of the property as specified by the IDL of the ActiveX Control; the\n*                     value for the ID can be obtained using OleAutomation.getIDsOfNames\n* @param rgvarg the new value of the property\n*\n* @return true if the operation was successful\n*/\n",
			"methodName":"public boolean setProperty(int dispIdMember, Variant rgvarg)"
		},
		"public String getHelpFile(int dispId)":{
			"methodBody":"{\n    if (objITypeInfo == null)\n        return null;\n    String[] file = new String[1];\n    int rc = objITypeInfo.GetDocumentation(dispId, null, null, null, file);\n    if (rc == OLE.S_OK)\n        return file[0];\n    return null;\n}",
			"comments":"",
			"methodName":"public String getHelpFile(int dispId)"
		},
		"public int[] getIDsOfNames(String[] names)":{
			"methodBody":"{\n    int[] rgdispid = new int[names.length];\n    int result = objIDispatch.GetIDsOfNames(new GUID(), names, names.length, COM.LOCALE_USER_DEFAULT, rgdispid);\n    if (result != COM.S_OK)\n        return null;\n    return rgdispid;\n}",
			"comments":"/**\n* Returns the positive integer values (IDs) that are associated with the specified names by the\n* IDispatch implementor.  If you are trying to get the names of the parameters in a method, the first\n* String in the names array must be the name of the method followed by the names of the parameters.\n*\n* @param names an array of names for which you require the identifiers\n*\n* @return positive integer values that are associated with the specified names in the same\n*         order as the names where provided; or null if the names are unknown\n*/\n",
			"methodName":"public int[] getIDsOfNames(String[] names)"
		},
		"public Variant invoke(int dispIdMember, Variant[] rgvarg)":{
			"methodBody":"{\n    Variant pVarResult = new Variant();\n    int result = invoke(dispIdMember, COM.DISPATCH_METHOD, rgvarg, null, pVarResult);\n    return (result == COM.S_OK) ? pVarResult : null;\n}",
			"comments":"/**\n* Invokes a method on the OLE Object; the method has no optional parameters.\n*\n* @param dispIdMember the ID of the method as specified by the IDL of the ActiveX Control; the\n*        value for the ID can be obtained using OleAutomation.getIDsOfNames\n*\n* @param rgvarg an array of arguments for the method.  All arguments are considered to be\n*        read only unless the Variant is a By Reference Variant type.\n*\n* @return the result of the method or null if the method failed to give result information\n*/\n",
			"methodName":"public Variant invoke(int dispIdMember, Variant[] rgvarg)"
		},
		"public OlePropertyDescription getPropertyDescription(int index)":{
			"methodBody":"{\n    if (objITypeInfo == null)\n        return null;\n    int[] ppVarDesc = new int[1];\n    int rc = objITypeInfo.GetVarDesc(index, ppVarDesc);\n    if (rc != OLE.S_OK)\n        return null;\n    VARDESC vardesc = new VARDESC();\n    COM.MoveMemory(vardesc, ppVarDesc[0], VARDESC.sizeof);\n    OlePropertyDescription data = new OlePropertyDescription();\n    data.id = vardesc.memid;\n    data.name = getName(vardesc.memid);\n    data.type = vardesc.elemdescVar_tdesc_vt;\n    if (data.type == OLE.VT_PTR) {\n        short[] vt = new short[1];\n        COM.MoveMemory(vt, vardesc.elemdescVar_tdesc_union + 4, 2);\n        data.type = vt[0];\n    }\n    data.flags = vardesc.wVarFlags;\n    data.kind = vardesc.varkind;\n    data.description = getDocumentation(vardesc.memid);\n    data.helpFile = getHelpFile(vardesc.memid);\n    objITypeInfo.ReleaseVarDesc(ppVarDesc[0]);\n    return data;\n}",
			"comments":"",
			"methodName":"public OlePropertyDescription getPropertyDescription(int index)"
		},
		"public OleFunctionDescription getFunctionDescription(int index)":{
			"methodBody":"{\n    if (objITypeInfo == null)\n        return null;\n    int[] ppFuncDesc = new int[1];\n    int rc = objITypeInfo.GetFuncDesc(index, ppFuncDesc);\n    if (rc != OLE.S_OK)\n        return null;\n    FUNCDESC funcdesc = new FUNCDESC();\n    COM.MoveMemory(funcdesc, ppFuncDesc[0], FUNCDESC.sizeof);\n    OleFunctionDescription data = new OleFunctionDescription();\n    data.id = funcdesc.memid;\n    data.optionalArgCount = funcdesc.cParamsOpt;\n    data.invokeKind = funcdesc.invkind;\n    data.funcKind = funcdesc.funckind;\n    data.flags = funcdesc.wFuncFlags;\n    data.callingConvention = funcdesc.callconv;\n    data.documentation = getDocumentation(funcdesc.memid);\n    data.helpFile = getHelpFile(funcdesc.memid);\n    String[] names = getNames(funcdesc.memid, funcdesc.cParams + 1);\n    if (names.length > 0) {\n        data.name = names[0];\n    }\n    data.args = new OleParameterDescription[funcdesc.cParams];\n    for (int i = 0; i < data.args.length; i++) {\n        data.args[i] = new OleParameterDescription();\n        if (names.length > i + 1) {\n            data.args[i].name = names[i + 1];\n        }\n        short[] vt = new short[1];\n        COM.MoveMemory(vt, funcdesc.lprgelemdescParam + i * 16 + 4, 2);\n        if (vt[0] == OLE.VT_PTR) {\n            int[] pTypedesc = new int[1];\n            COM.MoveMemory(pTypedesc, funcdesc.lprgelemdescParam + i * 16, 4);\n            short[] vt2 = new short[1];\n            COM.MoveMemory(vt2, pTypedesc[0] + 4, 2);\n            vt[0] = (short) (vt2[0] | COM.VT_BYREF);\n        }\n        data.args[i].type = vt[0];\n        short[] wParamFlags = new short[1];\n        COM.MoveMemory(wParamFlags, funcdesc.lprgelemdescParam + i * 16 + 12, 2);\n        data.args[i].flags = wParamFlags[0];\n    }\n    data.returnType = funcdesc.elemdescFunc_tdesc_vt;\n    if (data.returnType == OLE.VT_PTR) {\n        short[] vt = new short[1];\n        COM.MoveMemory(vt, funcdesc.elemdescFunc_tdesc_union + 4, 2);\n        data.returnType = vt[0];\n    }\n    objITypeInfo.ReleaseFuncDesc(ppFuncDesc[0]);\n    return data;\n}",
			"comments":"",
			"methodName":"public OleFunctionDescription getFunctionDescription(int index)"
		},
		"public String getName(int dispId)":{
			"methodBody":"{\n    if (objITypeInfo == null)\n        return null;\n    String[] name = new String[1];\n    int rc = objITypeInfo.GetDocumentation(dispId, name, null, null, null);\n    if (rc == OLE.S_OK)\n        return name[0];\n    return null;\n}",
			"comments":"",
			"methodName":"public String getName(int dispId)"
		},
		"public TYPEATTR getTypeInfoAttributes()":{
			"methodBody":"{\n    if (objITypeInfo == null)\n        return null;\n    int[] ppTypeAttr = new int[1];\n    int rc = objITypeInfo.GetTypeAttr(ppTypeAttr);\n    if (rc != OLE.S_OK)\n        return null;\n    TYPEATTR typeattr = new TYPEATTR();\n    COM.MoveMemory(typeattr, ppTypeAttr[0], TYPEATTR.sizeof);\n    objITypeInfo.ReleaseTypeAttr(ppTypeAttr[0]);\n    return typeattr;\n}",
			"comments":"",
			"methodName":"public TYPEATTR getTypeInfoAttributes()"
		},
		"public Variant getProperty(int dispIdMember)":{
			"methodBody":"{\n    Variant pVarResult = new Variant();\n    int result = invoke(dispIdMember, COM.DISPATCH_PROPERTYGET, null, null, pVarResult);\n    return (result == OLE.S_OK) ? pVarResult : null;\n}",
			"comments":"/**\n* Returns the value of the property specified by the dispIdMember.\n*\n* @param dispIdMember the ID of the property as specified by the IDL of the ActiveX Control; the\n*        value for the ID can be obtained using OleAutomation.getIDsOfNames\n*\n* @return the value of the property specified by the dispIdMember or null\n*/\n",
			"methodName":"public Variant getProperty(int dispIdMember)"
		},
		"public void invokeNoReply(int dispIdMember, Variant[] rgvarg)":{
			"methodBody":"{\n    int result = invoke(dispIdMember, COM.DISPATCH_METHOD, rgvarg, null, null);\n    if (result != COM.S_OK)\n        OLE.error(OLE.ERROR_ACTION_NOT_PERFORMED, result);\n}",
			"comments":"/**\n* Invokes a method on the OLE Object; the method has no optional parameters.  In the early days of OLE,\n* the IDispatch interface was not well defined and some applications (mainly Word) did not support\n* a return value.  For these applications, call this method instead of calling\n* <code>public void invoke(int dispIdMember, Variant[] rgvarg)</code>.\n*\n* @param dispIdMember the ID of the method as specified by the IDL of the ActiveX Control; the\n*        value for the ID can be obtained using OleAutomation.getIDsOfNames\n*\n* @param rgvarg an array of arguments for the method.  All arguments are considered to be\n*        read only unless the Variant is a By Reference Variant type.\n*\n* @exception SWTException <ul>\n*\t\t<li>ERROR_ACTION_NOT_PERFORMED when method invocation fails\n*\t</ul>\n*/\n",
			"methodName":"public void invokeNoReply(int dispIdMember, Variant[] rgvarg)"
		},
		"private void manageExcepinfo(int hResult, EXCEPINFO excepInfo)":{
			"methodBody":"{\n    if (hResult == COM.S_OK) {\n        \n        exceptionDescription = \"No Error\";\n        return;\n    }\n    \n    if (hResult == COM.DISP_E_EXCEPTION) {\n        if (excepInfo.bstrDescription != 0) {\n            int size = COM.SysStringByteLen(excepInfo.bstrDescription);\n            char[] buffer = new char[(size + 1) / 2];\n            COM.MoveMemory(buffer, excepInfo.bstrDescription, size);\n            exceptionDescription = new String(buffer);\n        } else {\n            \n            exceptionDescription = \"OLE Automation Error Exception \";\n            if (excepInfo.wCode != 0) {\n                \n                exceptionDescription += \"code = \" + excepInfo.wCode;\n            } else if (excepInfo.scode != 0) {\n                \n                exceptionDescription += \"code = \" + excepInfo.scode;\n            }\n        }\n    } else {\n        \n        exceptionDescription = \"OLE Automation Error HResult : \" + hResult;\n    }\n    \n    if (excepInfo.bstrDescription != 0)\n        COM.SysFreeString(excepInfo.bstrDescription);\n    if (excepInfo.bstrHelpFile != 0)\n        COM.SysFreeString(excepInfo.bstrHelpFile);\n    if (excepInfo.bstrSource != 0)\n        COM.SysFreeString(excepInfo.bstrSource);\n}",
			"comments":"//$NON-NLS-1$\n// extract exception info\n//$NON-NLS-1$\n//$NON-NLS-1$\n//$NON-NLS-1$\n//$NON-NLS-1$\n// cleanup EXCEPINFO struct\n",
			"methodName":"private void manageExcepinfo(int hResult, EXCEPINFO excepInfo)"
		},
		"public boolean setProperty(int dispIdMember, Variant[] rgvarg)":{
			"methodBody":"{\n    int[] rgdispidNamedArgs = new int[] { COM.DISPID_PROPERTYPUT };\n    int dwFlags = COM.DISPATCH_PROPERTYPUT;\n    for (int i = 0; i < rgvarg.length; i++) {\n        if ((rgvarg[i].getType() & COM.VT_BYREF) == COM.VT_BYREF)\n            dwFlags = COM.DISPATCH_PROPERTYPUTREF;\n    }\n    Variant pVarResult = new Variant();\n    int result = invoke(dispIdMember, dwFlags, rgvarg, rgdispidNamedArgs, pVarResult);\n    return (result == COM.S_OK);\n}",
			"comments":"/**\n* Sets the property specified by the dispIdMember to a new value.\n*\n* @param dispIdMember the ID of the property as specified by the IDL of the ActiveX Control; the\n*                     value for the ID can be obtained using OleAutomation.getIDsOfNames\n* @param rgvarg an array of arguments for the method.  All arguments are considered to be\n*                     read only unless the Variant is a By Reference Variant type.\n*\n* @return true if the operation was successful\n*\n* @since 2.0\n*/\n",
			"methodName":"public boolean setProperty(int dispIdMember, Variant[] rgvarg)"
		},
		"public String[] getNames(int dispId, int maxSize)":{
			"methodBody":"{\n    if (objITypeInfo == null)\n        return new String[0];\n    String[] names = new String[maxSize];\n    int[] count = new int[1];\n    int rc = objITypeInfo.GetNames(dispId, names, maxSize, count);\n    if (rc == OLE.S_OK) {\n        String[] newNames = new String[count[0]];\n        System.arraycopy(names, 0, newNames, 0, count[0]);\n        return newNames;\n    }\n    return new String[0];\n}",
			"comments":"",
			"methodName":"public String[] getNames(int dispId, int maxSize)"
		},
		"int getAddress()":{
			"methodBody":"{\n    return objIDispatch.getAddress();\n}",
			"comments":"",
			"methodName":"int getAddress()"
		},
		"private int invoke(int dispIdMember, int wFlags, Variant[] rgvarg, int[] rgdispidNamedArgs, Variant pVarResult)":{
			"methodBody":"{\n    \n    if (objIDispatch == null)\n        return COM.E_FAIL;\n    \n    DISPPARAMS pDispParams = new DISPPARAMS();\n    \n    if (rgvarg != null && rgvarg.length > 0) {\n        pDispParams.cArgs = rgvarg.length;\n        pDispParams.rgvarg = OS.GlobalAlloc(COM.GMEM_FIXED | COM.GMEM_ZEROINIT, Variant.sizeof * rgvarg.length);\n        int offset = 0;\n        for (int i = rgvarg.length - 1; i >= 0; i--) {\n            rgvarg[i].getData(pDispParams.rgvarg + offset);\n            offset += Variant.sizeof;\n        }\n    }\n    \n    if (rgdispidNamedArgs != null && rgdispidNamedArgs.length > 0) {\n        pDispParams.cNamedArgs = rgdispidNamedArgs.length;\n        pDispParams.rgdispidNamedArgs = OS.GlobalAlloc(COM.GMEM_FIXED | COM.GMEM_ZEROINIT, 4 * rgdispidNamedArgs.length);\n        int offset = 0;\n        for (int i = rgdispidNamedArgs.length; i > 0; i--) {\n            COM.MoveMemory(pDispParams.rgdispidNamedArgs + offset, new int[] { rgdispidNamedArgs[i - 1] }, 4);\n            offset += 4;\n        }\n    }\n    \n    EXCEPINFO excepInfo = new EXCEPINFO();\n    int[] pArgErr = new int[1];\n    int pVarResultAddress = 0;\n    if (pVarResult != null)\n        pVarResultAddress = OS.GlobalAlloc(OS.GMEM_FIXED | OS.GMEM_ZEROINIT, Variant.sizeof);\n    int result = objIDispatch.Invoke(dispIdMember, new GUID(), COM.LOCALE_USER_DEFAULT, wFlags, pDispParams, pVarResultAddress, excepInfo, pArgErr);\n    if (pVarResultAddress != 0) {\n        pVarResult.setData(pVarResultAddress);\n        COM.VariantClear(pVarResultAddress);\n        OS.GlobalFree(pVarResultAddress);\n    }\n    \n    if (pDispParams.rgdispidNamedArgs != 0) {\n        OS.GlobalFree(pDispParams.rgdispidNamedArgs);\n    }\n    if (pDispParams.rgvarg != 0) {\n        int offset = 0;\n        for (int i = 0, length = rgvarg.length; i < length; i++) {\n            COM.VariantClear(pDispParams.rgvarg + offset);\n            offset += Variant.sizeof;\n        }\n        OS.GlobalFree(pDispParams.rgvarg);\n    }\n    \n    manageExcepinfo(result, excepInfo);\n    return result;\n}",
			"comments":"// get the IDispatch interface for the control\n// create a DISPPARAMS structure for the input parameters\n// store arguments in rgvarg\n// if arguments have ids, store the ids in rgdispidNamedArgs\n// invoke the method\n// free the Dispparams resources\n// save error string and cleanup EXCEPINFO\n",
			"methodName":"private int invoke(int dispIdMember, int wFlags, Variant[] rgvarg, int[] rgdispidNamedArgs, Variant pVarResult)"
		},
		"public Variant invoke(int dispIdMember)":{
			"methodBody":"{\n    Variant pVarResult = new Variant();\n    int result = invoke(dispIdMember, COM.DISPATCH_METHOD, null, null, pVarResult);\n    return (result == COM.S_OK) ? pVarResult : null;\n}",
			"comments":"/**\n* Invokes a method on the OLE Object; the method has no parameters.\n*\n* @param dispIdMember the ID of the method as specified by the IDL of the ActiveX Control; the\n*        value for the ID can be obtained using OleAutomation.getIDsOfNames\n*\n* @return the result of the method or null if the method failed to give result information\n*/\n",
			"methodName":"public Variant invoke(int dispIdMember)"
		},
		"public Variant getProperty(int dispIdMember, Variant[] rgvarg, int[] rgdispidNamedArgs)":{
			"methodBody":"{\n    Variant pVarResult = new Variant();\n    int result = invoke(dispIdMember, COM.DISPATCH_PROPERTYGET, rgvarg, rgdispidNamedArgs, pVarResult);\n    return (result == OLE.S_OK) ? pVarResult : null;\n}",
			"comments":"/**\n* Returns the value of the property specified by the dispIdMember.\n*\n* @param dispIdMember the ID of the property as specified by the IDL of the ActiveX Control; the\n*        value for the ID can be obtained using OleAutomation.getIDsOfNames\n*\n* @param rgvarg an array of arguments for the method.  All arguments are considered to be\n*        read only unless the Variant is a By Reference Variant type.\n*\n* @param rgdispidNamedArgs an array of identifiers for the arguments specified in rgvarg; the\n*        parameter IDs must be in the same order as their corresponding values;\n*        all arguments must have an identifier - identifiers can be obtained using\n*        OleAutomation.getIDsOfNames\n*\n* @return the value of the property specified by the dispIdMember or null\n*\n* @since 2.0\n*/\n",
			"methodName":"public Variant getProperty(int dispIdMember, Variant[] rgvarg, int[] rgdispidNamedArgs)"
		},
		"public Variant getProperty(int dispIdMember, Variant[] rgvarg)":{
			"methodBody":"{\n    Variant pVarResult = new Variant();\n    int result = invoke(dispIdMember, COM.DISPATCH_PROPERTYGET, rgvarg, null, pVarResult);\n    return (result == OLE.S_OK) ? pVarResult : null;\n}",
			"comments":"/**\n* Returns the value of the property specified by the dispIdMember.\n*\n* @param dispIdMember the ID of the property as specified by the IDL of the ActiveX Control; the\n*        value for the ID can be obtained using OleAutomation.getIDsOfNames\n*\n* @param rgvarg an array of arguments for the method.  All arguments are considered to be\n*        read only unless the Variant is a By Reference Variant type.\n*\n* @return the value of the property specified by the dispIdMember or null\n*\n* @since 2.0\n*/\n",
			"methodName":"public Variant getProperty(int dispIdMember, Variant[] rgvarg)"
		},
		"public void invokeNoReply(int dispIdMember, Variant[] rgvarg, int[] rgdispidNamedArgs)":{
			"methodBody":"{\n    int result = invoke(dispIdMember, COM.DISPATCH_METHOD, rgvarg, rgdispidNamedArgs, null);\n    if (result != COM.S_OK)\n        OLE.error(OLE.ERROR_ACTION_NOT_PERFORMED, result);\n}",
			"comments":"/**\n* Invokes a method on the OLE Object; the method has optional parameters.  It is not\n* necessary to specify all the optional parameters, only include the parameters for which\n* you are providing values.  In the early days of OLE, the IDispatch interface was not well\n* defined and some applications (mainly Word) did not support a return value.  For these\n* applications, call this method instead of calling\n* <code>public void invoke(int dispIdMember, Variant[] rgvarg, int[] rgdispidNamedArgs)</code>.\n*\n* @param dispIdMember the ID of the method as specified by the IDL of the ActiveX Control; the\n*        value for the ID can be obtained using OleAutomation.getIDsOfNames\n*\n* @param rgvarg an array of arguments for the method.  All arguments are considered to be\n*        read only unless the Variant is a By Reference Variant type.\n*\n* @param rgdispidNamedArgs an array of identifiers for the arguments specified in rgvarg; the\n*        parameter IDs must be in the same order as their corresponding values;\n*        all arguments must have an identifier - identifiers can be obtained using\n*        OleAutomation.getIDsOfNames\n*\n* @exception SWTException <ul>\n*\t\t<li>ERROR_ACTION_NOT_PERFORMED when method invocation fails\n*\t</ul>\n*/\n",
			"methodName":"public void invokeNoReply(int dispIdMember, Variant[] rgvarg, int[] rgdispidNamedArgs)"
		}
	},
	"ClassORInterfaceName":[
		"OleAutomation"
	]
}
