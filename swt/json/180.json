{
	"variables":[
		"font",
		"text",
		"segmentsText",
		"lineSpacing",
		"ascent",
		"descent",
		"alignment",
		"wrapWidth",
		"orientation",
		"tabs",
		"segments",
		"styles",
		"allRuns",
		"runs",
		"lineOffset",
		"lineY",
		"lineWidth",
		"mLangFontLink2",
		"LTR_MARK",
		"RTL_MARK",
		"SCRIPT_VISATTR_SIZEOF",
		"GOFFSET_SIZEOF",
		"CLSID_CMultiLanguage",
		"IID_IMLangFontLink2",
		"style",
		"start",
		"length",
		"lineBreak",
		"softBreak",
		"tab",
		"analysis",
		"psc",
		"glyphs",
		"glyphCount",
		"clusters",
		"visAttrs",
		"advances",
		"goffsets",
		"width",
		"ascent",
		"descent",
		"leading",
		"x",
		"psla",
		"fallbackFont",
		"hHeap",
		"ppv",
		"chars",
		"hHeap",
		"logFont",
		"hDC",
		"srcHdc",
		"i",
		"run",
		"logAttr",
		"properties",
		"lineWidth",
		"lineStart",
		"lineCount",
		"i",
		"run",
		"ch",
		"tabsLength",
		"j",
		"tabX",
		"lastTabWidth",
		"next",
		"start",
		"piDx",
		"width",
		"maxWidth",
		"firstStart",
		"firstIndice",
		"langID",
		"pRun",
		"newRun",
		"newAllRuns",
		"lineRunCount",
		"line",
		"ascent",
		"descent",
		"lineRuns",
		"i",
		"run",
		"lptm",
		"lastRun",
		"j",
		"length",
		"hdc",
		"hasSelection",
		"foreground",
		"state",
		"rect",
		"selBrush",
		"selPen",
		"rop2",
		"dwRop",
		"clip",
		"line",
		"drawX",
		"drawY",
		"lineRuns",
		"baseline",
		"i",
		"lineHeight",
		"alignmentX",
		"i",
		"run",
		"end",
		"fullSelection",
		"bg",
		"drawRunY",
		"hBrush",
		"oldBrush",
		"partialSelection",
		"selStart",
		"selEnd",
		"cChars",
		"gGlyphs",
		"piX",
		"runX",
		"i",
		"run",
		"end",
		"fg",
		"fullSelection",
		"drawRunY",
		"newPen",
		"oldPen",
		"underlineY",
		"strikeoutY",
		"partialSelection",
		"selStart",
		"selEnd",
		"cChars",
		"gGlyphs",
		"piX",
		"runX",
		"oldPen",
		"underlineY",
		"strikeoutY",
		"i",
		"run",
		"width",
		"line",
		"length",
		"left",
		"right",
		"top",
		"bottom",
		"lineIndex",
		"isRTL",
		"i",
		"run",
		"runEnd",
		"runLead",
		"runTrail",
		"cx",
		"piX",
		"cx",
		"piX",
		"length",
		"i",
		"x",
		"y",
		"width",
		"height",
		"length",
		"line",
		"hDC",
		"srcHdc",
		"lptm",
		"ascent",
		"descent",
		"leading",
		"aveCharWidth",
		"height",
		"lineRuns",
		"i",
		"run",
		"offsets",
		"i",
		"length",
		"line",
		"lineRuns",
		"result",
		"width",
		"i",
		"run",
		"end",
		"runOffset",
		"cChars",
		"gGlyphs",
		"piX",
		"length",
		"step",
		"logAttr",
		"properties",
		"i",
		"run",
		"isComplex",
		"letterOrDigit",
		"previousLetterOrDigit",
		"line",
		"lineCount",
		"lineRuns",
		"width",
		"i",
		"run",
		"cChars",
		"cGlyphs",
		"xRun",
		"piCP",
		"piTrailing",
		"nSegments",
		"length",
		"oldChars",
		"newChars",
		"charCount",
		"segmentCount",
		"separator",
		"length",
		"i",
		"length",
		"scriptControl",
		"scriptState",
		"MAX_ITEM",
		"hHeap",
		"pItems",
		"pcItems",
		"chars",
		"runs",
		"count",
		"start",
		"end",
		"itemIndex",
		"styleIndex",
		"runs",
		"scriptItem",
		"item",
		"itemLimit",
		"styleLimit",
		"item",
		"result",
		"length",
		"bidiLevels",
		"i",
		"lastRun",
		"log2vis",
		"result",
		"i",
		"i",
		"tmp",
		"mask",
		"mask",
		"i",
		"length",
		"low",
		"high",
		"index",
		"item",
		"count",
		"i",
		"newStyles",
		"item",
		"newItem",
		"item",
		"item",
		"i",
		"hr",
		"fp",
		"glyphs",
		"i",
		"buffer",
		"chars",
		"maxGlyphs",
		"hHeap",
		"dwCodePages",
		"cchCodePages",
		"hNewFont",
		"hFont",
		"abc",
		"lptm",
		"i",
		"nSegments",
		"length",
		"i",
		"nSegments",
		"length",
		"i",
		"OS",
		"CLSID_CMultiLanguage",
		"OS",
		"IID_IMLangFontLink2",
		"OS",
		"psc",
		"OS",
		"psc",
		"OS",
		"hHeap",
		"psc",
		"psc",
		"glyphs",
		"OS",
		"hHeap",
		"glyphs",
		"glyphs",
		"glyphCount",
		"clusters",
		"OS",
		"hHeap",
		"clusters",
		"clusters",
		"visAttrs",
		"OS",
		"hHeap",
		"visAttrs",
		"visAttrs",
		"advances",
		"OS",
		"hHeap",
		"advances",
		"advances",
		"goffsets",
		"OS",
		"hHeap",
		"goffsets",
		"goffsets",
		"psla",
		"OS",
		"hHeap",
		"psla",
		"psla",
		"fallbackFont",
		"mLangFontLink2",
		"OS",
		"mLangFontLink2",
		"fallbackFont",
		"fallbackFont",
		"width",
		"ascent",
		"descent",
		"x",
		"lineBreak",
		"softBreak",
		"device",
		"device",
		"Device",
		"device",
		"SWT",
		"SWT",
		"device",
		"wrapWidth",
		"ascent",
		"descent",
		"lineSpacing",
		"orientation",
		"SWT",
		"styles",
		"styles",
		"styles",
		"text",
		"OS",
		"OS",
		"CLSID_CMultiLanguage",
		"OS",
		"IID_IMLangFontLink2",
		"ppv",
		"OS",
		"mLangFontLink2",
		"ppv",
		"device",
		"device",
		"run",
		"run",
		"segmentsText",
		"run",
		"run",
		"run",
		"chars",
		"OS",
		"run",
		"OS",
		"hHeap",
		"OS",
		"SCRIPT_LOGATTR",
		"chars",
		"OS",
		"chars",
		"chars",
		"run",
		"run",
		"item",
		"OS",
		"OS",
		"item",
		"LOGFONT",
		"logFont",
		"item",
		"OS",
		"hDC",
		"item",
		"hDC",
		"item",
		"SWT",
		"SWT",
		"runs",
		"gc",
		"gc",
		"device",
		"OS",
		"hDC",
		"allRuns",
		"i",
		"allRuns",
		"i",
		"allRuns",
		"i",
		"OS",
		"srcHdc",
		"run",
		"srcHdc",
		"run",
		"i",
		"allRuns",
		"i",
		"allRuns",
		"i",
		"run",
		"segmentsText",
		"run",
		"ch",
		"run",
		"tabs",
		"tabs",
		"j",
		"j",
		"tabsLength",
		"j",
		"tabs",
		"j",
		"lineWidth",
		"run",
		"tabs",
		"j",
		"lineWidth",
		"j",
		"tabsLength",
		"tabs",
		"tabsLength",
		"tabsLength",
		"tabs",
		"tabsLength",
		"tabs",
		"tabsLength",
		"tabs",
		"lastTabWidth",
		"tabX",
		"lineWidth",
		"tabX",
		"lastTabWidth",
		"run",
		"tabX",
		"lineWidth",
		"run",
		"run",
		"allRuns",
		"i",
		"next",
		"segmentsText",
		"next",
		"run",
		"next",
		"i",
		"wrapWidth",
		"lineWidth",
		"run",
		"wrapWidth",
		"run",
		"run",
		"OS",
		"run",
		"run",
		"run",
		"run",
		"run",
		"run",
		"piDx",
		"wrapWidth",
		"lineWidth",
		"width",
		"piDx",
		"start",
		"maxWidth",
		"width",
		"piDx",
		"start",
		"start",
		"i",
		"i",
		"lineStart",
		"run",
		"start",
		"OS",
		"logAttr",
		"run",
		"start",
		"SCRIPT_LOGATTR",
		"SCRIPT_LOGATTR",
		"logAttr",
		"logAttr",
		"start",
		"start",
		"i",
		"lineStart",
		"run",
		"logAttr",
		"logAttr",
		"OS",
		"properties",
		"device",
		"run",
		"SCRIPT_PROPERTIES",
		"properties",
		"allRuns",
		"i",
		"OS",
		"properties",
		"device",
		"pRun",
		"SCRIPT_PROPERTIES",
		"properties",
		"langID",
		"langID",
		"OS",
		"properties",
		"OS",
		"pRun",
		"OS",
		"logAttr",
		"pRun",
		"pRun",
		"SCRIPT_LOGATTR",
		"SCRIPT_LOGATTR",
		"logAttr",
		"start",
		"start",
		"i",
		"lineStart",
		"run",
		"allRuns",
		"i",
		"start",
		"run",
		"start",
		"i",
		"lineStart",
		"run",
		"run",
		"allRuns",
		"i",
		"start",
		"i",
		"lineStart",
		"i",
		"firstIndice",
		"run",
		"allRuns",
		"i",
		"start",
		"Math",
		"firstStart",
		"run",
		"start",
		"run",
		"OS",
		"logAttr",
		"run",
		"start",
		"SCRIPT_LOGATTR",
		"SCRIPT_LOGATTR",
		"logAttr",
		"start",
		"start",
		"start",
		"run",
		"newRun",
		"run",
		"start",
		"newRun",
		"run",
		"start",
		"newRun",
		"run",
		"newRun",
		"run",
		"run",
		"run",
		"start",
		"OS",
		"srcHdc",
		"run",
		"srcHdc",
		"run",
		"OS",
		"srcHdc",
		"newRun",
		"srcHdc",
		"newRun",
		"allRuns",
		"System",
		"allRuns",
		"newAllRuns",
		"i",
		"System",
		"allRuns",
		"i",
		"newAllRuns",
		"i",
		"allRuns",
		"i",
		"allRuns",
		"newAllRuns",
		"allRuns",
		"i",
		"newRun",
		"i",
		"allRuns",
		"run",
		"run",
		"lineWidth",
		"run",
		"run",
		"lineStart",
		"i",
		"lineWidth",
		"lineCount",
		"lineWidth",
		"runs",
		"lineCount",
		"lineOffset",
		"lineCount",
		"lineY",
		"lineCount",
		"lineCount",
		"Math",
		"Math",
		"allRuns",
		"i",
		"allRuns",
		"i",
		"allRuns",
		"i",
		"lineRuns",
		"lineRunCount",
		"run",
		"lineWidth",
		"run",
		"ascent",
		"Math",
		"ascent",
		"run",
		"descent",
		"Math",
		"descent",
		"run",
		"run",
		"i",
		"allRuns",
		"lineRunCount",
		"i",
		"allRuns",
		"OS",
		"OS",
		"srcHdc",
		"run",
		"OS",
		"srcHdc",
		"lptm",
		"run",
		"lptm",
		"run",
		"lptm",
		"ascent",
		"Math",
		"ascent",
		"run",
		"descent",
		"Math",
		"descent",
		"run",
		"runs",
		"line",
		"lineRunCount",
		"System",
		"lineRuns",
		"runs",
		"line",
		"lineRunCount",
		"runs",
		"line",
		"lineRunCount",
		"runs",
		"line",
		"runs",
		"line",
		"line",
		"lineWidth",
		"lineWidth",
		"wrapWidth",
		"alignment",
		"SWT",
		"lineWidth",
		"wrapWidth",
		"line",
		"SWT",
		"lineWidth",
		"wrapWidth",
		"line",
		"j",
		"runs",
		"line",
		"j",
		"runs",
		"line",
		"j",
		"lineWidth",
		"lineWidth",
		"runs",
		"line",
		"j",
		"line",
		"lineY",
		"line",
		"lineY",
		"line",
		"ascent",
		"descent",
		"lineSpacing",
		"lineOffset",
		"line",
		"lastRun",
		"lastRun",
		"lineRunCount",
		"lineWidth",
		"ascent",
		"Math",
		"descent",
		"Math",
		"srcHdc",
		"OS",
		"srcHdc",
		"gc",
		"device",
		"hDC",
		"device",
		"font",
		"text",
		"segmentsText",
		"tabs",
		"styles",
		"runs",
		"lineOffset",
		"lineY",
		"lineWidth",
		"mLangFontLink2",
		"OS",
		"mLangFontLink2",
		"mLangFontLink2",
		"OS",
		"device",
		"device",
		"device",
		"gc",
		"x",
		"y",
		"gc",
		"gc",
		"SWT",
		"SWT",
		"gc",
		"SWT",
		"SWT",
		"selectionForeground",
		"selectionForeground",
		"SWT",
		"SWT",
		"selectionBackground",
		"selectionBackground",
		"SWT",
		"SWT",
		"text",
		"length",
		"gc",
		"selectionStart",
		"selectionEnd",
		"selectionStart",
		"selectionEnd",
		"hasSelection",
		"selectionStart",
		"Math",
		"Math",
		"selectionStart",
		"length",
		"selectionEnd",
		"Math",
		"Math",
		"selectionEnd",
		"length",
		"selectionForeground",
		"selectionForeground",
		"device",
		"SWT",
		"selectionBackground",
		"selectionBackground",
		"device",
		"SWT",
		"selectionStart",
		"selectionStart",
		"selectionEnd",
		"selectionEnd",
		"OS",
		"hdc",
		"OS",
		"hdc",
		"hasSelection",
		"selBrush",
		"OS",
		"selectionBackground",
		"selPen",
		"OS",
		"OS",
		"selectionForeground",
		"OS",
		"rop2",
		"OS",
		"hdc",
		"OS",
		"OS",
		"hdc",
		"rop2",
		"rop2",
		"OS",
		"hdc",
		"rop2",
		"OS",
		"OS",
		"OS",
		"OS",
		"hdc",
		"OS",
		"gc",
		"line",
		"runs",
		"line",
		"x",
		"y",
		"lineY",
		"line",
		"wrapWidth",
		"alignment",
		"SWT",
		"drawX",
		"wrapWidth",
		"lineWidth",
		"line",
		"SWT",
		"drawX",
		"wrapWidth",
		"lineWidth",
		"line",
		"drawX",
		"clip",
		"clip",
		"drawX",
		"lineWidth",
		"line",
		"clip",
		"runs",
		"line",
		"Math",
		"i",
		"lineRuns",
		"i",
		"baseline",
		"Math",
		"baseline",
		"lineRuns",
		"i",
		"lineY",
		"line",
		"lineY",
		"line",
		"drawX",
		"i",
		"lineRuns",
		"i",
		"lineRuns",
		"i",
		"run",
		"drawX",
		"clip",
		"clip",
		"drawX",
		"run",
		"clip",
		"run",
		"run",
		"run",
		"run",
		"hasSelection",
		"selectionStart",
		"run",
		"selectionEnd",
		"end",
		"fullSelection",
		"OS",
		"hdc",
		"selBrush",
		"OS",
		"hdc",
		"drawX",
		"drawY",
		"run",
		"lineHeight",
		"dwRop",
		"run",
		"run",
		"run",
		"drawY",
		"baseline",
		"run",
		"OS",
		"bg",
		"OS",
		"hdc",
		"hBrush",
		"OS",
		"hdc",
		"drawX",
		"drawRunY",
		"run",
		"run",
		"run",
		"dwRop",
		"OS",
		"hdc",
		"oldBrush",
		"OS",
		"hBrush",
		"hasSelection",
		"selectionStart",
		"end",
		"run",
		"selectionEnd",
		"partialSelection",
		"OS",
		"hdc",
		"selBrush",
		"Math",
		"selectionStart",
		"run",
		"run",
		"Math",
		"selectionEnd",
		"end",
		"run",
		"run",
		"run",
		"OS",
		"selStart",
		"cChars",
		"gGlyphs",
		"run",
		"run",
		"run",
		"run",
		"piX",
		"orientation",
		"SWT",
		"run",
		"piX",
		"piX",
		"rect",
		"drawX",
		"runX",
		"rect",
		"drawY",
		"OS",
		"selEnd",
		"cChars",
		"gGlyphs",
		"run",
		"run",
		"run",
		"run",
		"piX",
		"runX",
		"orientation",
		"SWT",
		"run",
		"piX",
		"piX",
		"rect",
		"drawX",
		"runX",
		"rect",
		"drawY",
		"lineHeight",
		"OS",
		"hdc",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"dwRop",
		"drawX",
		"run",
		"drawX",
		"alignmentX",
		"i",
		"lineRuns",
		"i",
		"lineRuns",
		"i",
		"run",
		"drawX",
		"clip",
		"clip",
		"drawX",
		"run",
		"clip",
		"run",
		"run",
		"run",
		"run",
		"run",
		"foreground",
		"hasSelection",
		"selectionStart",
		"run",
		"selectionEnd",
		"end",
		"fullSelection",
		"fg",
		"selectionForeground",
		"run",
		"run",
		"fg",
		"run",
		"OS",
		"hdc",
		"fg",
		"hdc",
		"run",
		"OS",
		"hdc",
		"run",
		"drawY",
		"baseline",
		"run",
		"OS",
		"hdc",
		"run",
		"drawX",
		"drawRunY",
		"run",
		"run",
		"run",
		"run",
		"run",
		"run",
		"run",
		"run",
		"hasSelection",
		"fg",
		"selectionForeground",
		"selPen",
		"OS",
		"OS",
		"fg",
		"OS",
		"hdc",
		"newPen",
		"run",
		"drawY",
		"baseline",
		"OS",
		"hdc",
		"drawX",
		"underlineY",
		"OS",
		"hdc",
		"drawX",
		"run",
		"underlineY",
		"run",
		"drawRunY",
		"run",
		"run",
		"OS",
		"hdc",
		"drawX",
		"strikeoutY",
		"OS",
		"hdc",
		"drawX",
		"run",
		"strikeoutY",
		"OS",
		"hdc",
		"oldPen",
		"hasSelection",
		"fg",
		"selectionForeground",
		"OS",
		"newPen",
		"hasSelection",
		"selectionStart",
		"end",
		"run",
		"selectionEnd",
		"fullSelection",
		"partialSelection",
		"fg",
		"selectionForeground",
		"OS",
		"hdc",
		"selectionForeground",
		"Math",
		"selectionStart",
		"run",
		"run",
		"Math",
		"selectionEnd",
		"end",
		"run",
		"run",
		"run",
		"OS",
		"selStart",
		"cChars",
		"gGlyphs",
		"run",
		"run",
		"run",
		"run",
		"piX",
		"orientation",
		"SWT",
		"run",
		"piX",
		"piX",
		"rect",
		"drawX",
		"runX",
		"rect",
		"drawY",
		"OS",
		"selEnd",
		"cChars",
		"gGlyphs",
		"run",
		"run",
		"run",
		"run",
		"piX",
		"runX",
		"orientation",
		"SWT",
		"run",
		"piX",
		"piX",
		"rect",
		"drawX",
		"runX",
		"rect",
		"drawY",
		"lineHeight",
		"OS",
		"hdc",
		"run",
		"drawX",
		"drawRunY",
		"OS",
		"rect",
		"run",
		"run",
		"run",
		"run",
		"run",
		"run",
		"run",
		"run",
		"OS",
		"hdc",
		"selPen",
		"run",
		"drawY",
		"baseline",
		"OS",
		"hdc",
		"rect",
		"underlineY",
		"OS",
		"hdc",
		"rect",
		"underlineY",
		"run",
		"drawRunY",
		"run",
		"run",
		"OS",
		"hdc",
		"rect",
		"strikeoutY",
		"OS",
		"hdc",
		"rect",
		"strikeoutY",
		"OS",
		"hdc",
		"oldPen",
		"drawX",
		"run",
		"OS",
		"hdc",
		"state",
		"selBrush",
		"OS",
		"selBrush",
		"selPen",
		"OS",
		"selPen",
		"allRuns",
		"i",
		"allRuns",
		"i",
		"allRuns",
		"i",
		"run",
		"allRuns",
		"runs",
		"segmentsText",
		"alignment",
		"ascent",
		"wrapWidth",
		"width",
		"wrapWidth",
		"line",
		"runs",
		"line",
		"width",
		"Math",
		"width",
		"lineWidth",
		"line",
		"width",
		"lineY",
		"lineY",
		"text",
		"length",
		"start",
		"end",
		"start",
		"Math",
		"Math",
		"start",
		"length",
		"end",
		"Math",
		"Math",
		"end",
		"length",
		"start",
		"start",
		"end",
		"end",
		"orientation",
		"SWT",
		"i",
		"allRuns",
		"i",
		"allRuns",
		"i",
		"run",
		"run",
		"run",
		"lineIndex",
		"runEnd",
		"start",
		"run",
		"end",
		"run",
		"run",
		"run",
		"run",
		"start",
		"start",
		"runEnd",
		"run",
		"OS",
		"start",
		"run",
		"run",
		"run",
		"run",
		"run",
		"run",
		"run",
		"piX",
		"cx",
		"isRTL",
		"run",
		"piX",
		"piX",
		"run",
		"isRTL",
		"runTrail",
		"run",
		"cx",
		"runLead",
		"run",
		"cx",
		"run",
		"end",
		"end",
		"runEnd",
		"run",
		"run",
		"OS",
		"end",
		"run",
		"run",
		"run",
		"run",
		"run",
		"run",
		"run",
		"piX",
		"cx",
		"isRTL",
		"run",
		"piX",
		"piX",
		"run",
		"isRTL",
		"runLead",
		"run",
		"cx",
		"runTrail",
		"run",
		"cx",
		"left",
		"Math",
		"left",
		"runLead",
		"right",
		"Math",
		"right",
		"runTrail",
		"top",
		"Math",
		"top",
		"lineY",
		"run",
		"lineIndex",
		"lineIndex",
		"bottom",
		"Math",
		"bottom",
		"lineY",
		"run",
		"lineIndex",
		"lineIndex",
		"left",
		"top",
		"right",
		"left",
		"bottom",
		"top",
		"descent",
		"font",
		"item",
		"item",
		"item",
		"item",
		"item",
		"device",
		"text",
		"offset",
		"offset",
		"length",
		"SWT",
		"SWT",
		"offset",
		"offset",
		"i",
		"allRuns",
		"i",
		"allRuns",
		"i",
		"offset",
		"allRuns",
		"i",
		"orientation",
		"SWT",
		"lineIndex",
		"lineIndex",
		"runs",
		"SWT",
		"SWT",
		"lineY",
		"lineIndex",
		"lineWidth",
		"lineIndex",
		"lineY",
		"lineIndex",
		"y",
		"wrapWidth",
		"alignment",
		"SWT",
		"x",
		"wrapWidth",
		"width",
		"SWT",
		"x",
		"wrapWidth",
		"width",
		"x",
		"y",
		"width",
		"height",
		"runs",
		"text",
		"offset",
		"offset",
		"length",
		"SWT",
		"SWT",
		"offset",
		"offset",
		"line",
		"runs",
		"line",
		"lineOffset",
		"line",
		"offset",
		"line",
		"runs",
		"lineIndex",
		"lineIndex",
		"runs",
		"SWT",
		"SWT",
		"device",
		"OS",
		"hDC",
		"OS",
		"text",
		"OS",
		"srcHdc",
		"font",
		"font",
		"device",
		"OS",
		"srcHdc",
		"lptm",
		"lptm",
		"Math",
		"lptm",
		"lptm",
		"Math",
		"lptm",
		"runs",
		"lineIndex",
		"i",
		"lineRuns",
		"i",
		"lineRuns",
		"i",
		"srcHdc",
		"run",
		"OS",
		"srcHdc",
		"run",
		"OS",
		"srcHdc",
		"lptm",
		"ascent",
		"Math",
		"ascent",
		"lptm",
		"descent",
		"Math",
		"descent",
		"lptm",
		"height",
		"Math",
		"height",
		"lptm",
		"leading",
		"Math",
		"leading",
		"lptm",
		"aveCharWidth",
		"lptm",
		"lptm",
		"ascent",
		"lptm",
		"descent",
		"lptm",
		"height",
		"lptm",
		"leading",
		"lptm",
		"aveCharWidth",
		"lineRuns",
		"srcHdc",
		"OS",
		"srcHdc",
		"device",
		"hDC",
		"FontMetrics",
		"lptm",
		"lineOffset",
		"i",
		"offsets",
		"i",
		"offsets",
		"i",
		"lineOffset",
		"i",
		"offsets",
		"text",
		"offset",
		"offset",
		"length",
		"SWT",
		"SWT",
		"length",
		"segmentsText",
		"offset",
		"offset",
		"line",
		"line",
		"runs",
		"line",
		"lineOffset",
		"line",
		"offset",
		"line",
		"Math",
		"line",
		"runs",
		"runs",
		"line",
		"offset",
		"length",
		"result",
		"lineWidth",
		"line",
		"lineY",
		"line",
		"i",
		"lineRuns",
		"i",
		"lineRuns",
		"i",
		"run",
		"run",
		"run",
		"offset",
		"offset",
		"end",
		"run",
		"trailing",
		"offset",
		"length",
		"width",
		"run",
		"result",
		"width",
		"lineY",
		"line",
		"offset",
		"run",
		"run",
		"run",
		"OS",
		"runOffset",
		"trailing",
		"cChars",
		"gGlyphs",
		"run",
		"run",
		"run",
		"run",
		"piX",
		"orientation",
		"SWT",
		"result",
		"width",
		"run",
		"piX",
		"lineY",
		"line",
		"result",
		"width",
		"piX",
		"lineY",
		"line",
		"width",
		"run",
		"result",
		"result",
		"wrapWidth",
		"alignment",
		"SWT",
		"result",
		"wrapWidth",
		"lineWidth",
		"line",
		"SWT",
		"result",
		"wrapWidth",
		"lineWidth",
		"line",
		"result",
		"offset",
		"movement",
		"text",
		"offset",
		"offset",
		"length",
		"SWT",
		"SWT",
		"forward",
		"offset",
		"length",
		"length",
		"forward",
		"offset",
		"forward",
		"movement",
		"SWT",
		"offset",
		"step",
		"length",
		"segmentsText",
		"offset",
		"offset",
		"forward",
		"allRuns",
		"offset",
		"offset",
		"step",
		"allRuns",
		"i",
		"run",
		"offset",
		"offset",
		"run",
		"run",
		"run",
		"run",
		"run",
		"run",
		"run",
		"OS",
		"properties",
		"device",
		"run",
		"SCRIPT_PROPERTIES",
		"properties",
		"properties",
		"isComplex",
		"run",
		"run",
		"offset",
		"offset",
		"run",
		"run",
		"isComplex",
		"OS",
		"logAttr",
		"run",
		"offset",
		"run",
		"SCRIPT_LOGATTR",
		"SCRIPT_LOGATTR",
		"movement",
		"SWT",
		"properties",
		"logAttr",
		"logAttr",
		"offset",
		"offset",
		"SWT",
		"properties",
		"logAttr",
		"logAttr",
		"offset",
		"offset",
		"Compatibility",
		"segmentsText",
		"offset",
		"Compatibility",
		"segmentsText",
		"offset",
		"letterOrDigit",
		"previousLetterOrDigit",
		"letterOrDigit",
		"Compatibility",
		"segmentsText",
		"offset",
		"offset",
		"offset",
		"offset",
		"step",
		"i",
		"step",
		"i",
		"i",
		"allRuns",
		"offset",
		"offset",
		"length",
		"forward",
		"text",
		"point",
		"SWT",
		"SWT",
		"point",
		"point",
		"trailing",
		"trailing",
		"trailing",
		"SWT",
		"SWT",
		"runs",
		"line",
		"line",
		"lineCount",
		"line",
		"lineY",
		"line",
		"y",
		"line",
		"Math",
		"line",
		"runs",
		"wrapWidth",
		"alignment",
		"SWT",
		"x",
		"wrapWidth",
		"lineWidth",
		"line",
		"SWT",
		"x",
		"wrapWidth",
		"lineWidth",
		"line",
		"runs",
		"line",
		"x",
		"lineWidth",
		"line",
		"x",
		"lineWidth",
		"line",
		"x",
		"x",
		"i",
		"lineRuns",
		"i",
		"lineRuns",
		"i",
		"run",
		"run",
		"run",
		"width",
		"run",
		"x",
		"run",
		"trailing",
		"trailing",
		"x",
		"width",
		"run",
		"run",
		"run",
		"run",
		"x",
		"width",
		"orientation",
		"SWT",
		"xRun",
		"run",
		"xRun",
		"OS",
		"xRun",
		"cChars",
		"cGlyphs",
		"run",
		"run",
		"run",
		"run",
		"piCP",
		"piTrailing",
		"trailing",
		"trailing",
		"piTrailing",
		"run",
		"piCP",
		"width",
		"run",
		"trailing",
		"trailing",
		"lineOffset",
		"line",
		"orientation",
		"offset",
		"movement",
		"segments",
		"segments",
		"text",
		"segments",
		"nSegments",
		"text",
		"text",
		"length",
		"text",
		"nSegments",
		"segments",
		"segments",
		"length",
		"text",
		"length",
		"text",
		"length",
		"oldChars",
		"length",
		"nSegments",
		"orientation",
		"SWT",
		"RTL_MARK",
		"LTR_MARK",
		"charCount",
		"length",
		"segmentCount",
		"nSegments",
		"charCount",
		"segments",
		"segmentCount",
		"newChars",
		"charCount",
		"segmentCount",
		"separator",
		"newChars",
		"charCount",
		"segmentCount",
		"oldChars",
		"charCount",
		"segmentCount",
		"nSegments",
		"segments",
		"segmentCount",
		"charCount",
		"newChars",
		"charCount",
		"segmentCount",
		"separator",
		"newChars",
		"Math",
		"charCount",
		"segmentCount",
		"newChars",
		"lineSpacing",
		"text",
		"offset",
		"offset",
		"length",
		"SWT",
		"SWT",
		"i",
		"styles",
		"i",
		"styles",
		"i",
		"offset",
		"styles",
		"i",
		"tabs",
		"text",
		"wrapWidth",
		"device",
		"segmentsText",
		"segmentsText",
		"length",
		"orientation",
		"SWT",
		"scriptState",
		"scriptState",
		"OS",
		"OS",
		"hHeap",
		"OS",
		"MAX_ITEM",
		"SCRIPT_ITEM",
		"length",
		"segmentsText",
		"length",
		"chars",
		"OS",
		"chars",
		"length",
		"MAX_ITEM",
		"scriptControl",
		"scriptState",
		"pItems",
		"pcItems",
		"pItems",
		"pcItems",
		"OS",
		"hHeap",
		"pItems",
		"runs",
		"segmentsText",
		"itemCount",
		"styles",
		"start",
		"end",
		"item",
		"start",
		"item",
		"styles",
		"styleIndex",
		"runs",
		"count",
		"item",
		"OS",
		"scriptItem",
		"items",
		"itemIndex",
		"SCRIPT_ITEM",
		"SCRIPT_ITEM",
		"item",
		"scriptItem",
		"scriptItem",
		"OS",
		"scriptItem",
		"items",
		"itemIndex",
		"SCRIPT_ITEM",
		"SCRIPT_ITEM",
		"scriptItem",
		"styles",
		"styleIndex",
		"styleLimit",
		"itemLimit",
		"styleIndex",
		"start",
		"styleLimit",
		"itemLimit",
		"styleLimit",
		"itemIndex",
		"start",
		"itemLimit",
		"item",
		"start",
		"item",
		"item",
		"end",
		"OS",
		"scriptItem",
		"items",
		"itemCount",
		"SCRIPT_ITEM",
		"SCRIPT_ITEM",
		"item",
		"scriptItem",
		"runs",
		"count",
		"item",
		"runs",
		"count",
		"count",
		"System",
		"runs",
		"result",
		"count",
		"result",
		"runs",
		"runs",
		"length",
		"runs",
		"length",
		"i",
		"length",
		"i",
		"bidiLevels",
		"i",
		"runs",
		"i",
		"runs",
		"length",
		"lastRun",
		"lastRun",
		"bidiLevels",
		"length",
		"length",
		"OS",
		"length",
		"bidiLevels",
		"log2vis",
		"length",
		"i",
		"length",
		"i",
		"result",
		"log2vis",
		"i",
		"runs",
		"i",
		"orientation",
		"SWT",
		"i",
		"length",
		"i",
		"result",
		"i",
		"result",
		"i",
		"result",
		"length",
		"i",
		"result",
		"length",
		"i",
		"tmp",
		"result",
		"SWT",
		"SWT",
		"SWT",
		"alignment",
		"mask",
		"alignment",
		"alignment",
		"SWT",
		"alignment",
		"SWT",
		"alignment",
		"SWT",
		"alignment",
		"SWT",
		"alignment",
		"ascent",
		"SWT",
		"SWT",
		"ascent",
		"ascent",
		"descent",
		"SWT",
		"SWT",
		"descent",
		"descent",
		"font",
		"font",
		"SWT",
		"SWT",
		"font",
		"font",
		"font",
		"font",
		"SWT",
		"SWT",
		"orientation",
		"mask",
		"orientation",
		"orientation",
		"SWT",
		"orientation",
		"SWT",
		"orientation",
		"orientation",
		"segments",
		"segments",
		"segments",
		"i",
		"i",
		"segments",
		"i",
		"i",
		"segments",
		"i",
		"i",
		"segments",
		"segments",
		"spacing",
		"SWT",
		"SWT",
		"spacing",
		"spacing",
		"text",
		"length",
		"start",
		"end",
		"start",
		"Math",
		"Math",
		"start",
		"length",
		"end",
		"Math",
		"Math",
		"end",
		"length",
		"styles",
		"high",
		"low",
		"high",
		"low",
		"start",
		"styles",
		"index",
		"high",
		"index",
		"low",
		"index",
		"high",
		"high",
		"styles",
		"styles",
		"high",
		"item",
		"start",
		"styles",
		"high",
		"end",
		"style",
		"item",
		"style",
		"item",
		"styles",
		"i",
		"i",
		"styles",
		"i",
		"styles",
		"i",
		"item",
		"start",
		"newStyles",
		"count",
		"item",
		"newItem",
		"start",
		"newItem",
		"style",
		"newStyles",
		"count",
		"newItem",
		"styles",
		"i",
		"end",
		"newItem",
		"newItem",
		"end",
		"newItem",
		"styles",
		"i",
		"newStyles",
		"count",
		"newItem",
		"i",
		"styles",
		"i",
		"styles",
		"i",
		"item",
		"end",
		"end",
		"styles",
		"i",
		"i",
		"styles",
		"i",
		"end",
		"i",
		"styles",
		"i",
		"styles",
		"i",
		"item",
		"end",
		"newStyles",
		"count",
		"item",
		"newStyles",
		"count",
		"styles",
		"count",
		"System",
		"newStyles",
		"styles",
		"count",
		"styles",
		"newStyles",
		"tabs",
		"tabs",
		"tabs",
		"i",
		"i",
		"tabs",
		"i",
		"i",
		"tabs",
		"i",
		"i",
		"tabs",
		"tabs",
		"text",
		"SWT",
		"SWT",
		"text",
		"text",
		"styles",
		"styles",
		"styles",
		"styles",
		"text",
		"width",
		"width",
		"SWT",
		"SWT",
		"width",
		"width",
		"OS",
		"hdc",
		"run",
		"chars",
		"chars",
		"maxGlyphs",
		"run",
		"run",
		"run",
		"run",
		"glyphCount",
		"run",
		"glyphCount",
		"hr",
		"OS",
		"fp",
		"SCRIPT_FONTPROPERTIES",
		"OS",
		"hdc",
		"run",
		"fp",
		"glyphCount",
		"OS",
		"glyphs",
		"run",
		"glyphs",
		"i",
		"i",
		"glyphs",
		"i",
		"glyphs",
		"i",
		"fp",
		"i",
		"glyphs",
		"run",
		"OS",
		"run",
		"glyphCount",
		"OS",
		"run",
		"glyphCount",
		"run",
		"run",
		"segmentsText",
		"run",
		"run",
		"run",
		"chars",
		"chars",
		"OS",
		"run",
		"OS",
		"hHeap",
		"OS",
		"maxGlyphs",
		"run",
		"OS",
		"hHeap",
		"OS",
		"maxGlyphs",
		"run",
		"OS",
		"hHeap",
		"OS",
		"maxGlyphs",
		"SCRIPT_VISATTR_SIZEOF",
		"run",
		"OS",
		"hHeap",
		"OS",
		"hdc",
		"run",
		"chars",
		"buffer",
		"maxGlyphs",
		"mLangFontLink2",
		"OS",
		"mLangFontLink2",
		"chars",
		"chars",
		"dwCodePages",
		"cchCodePages",
		"OS",
		"mLangFontLink2",
		"hdc",
		"dwCodePages",
		"chars",
		"hNewFont",
		"OS",
		"OS",
		"hdc",
		"hNewFont",
		"hdc",
		"run",
		"chars",
		"buffer",
		"maxGlyphs",
		"run",
		"hNewFont",
		"OS",
		"mLangFontLink2",
		"hNewFont",
		"OS",
		"hdc",
		"hFont",
		"OS",
		"hdc",
		"run",
		"chars",
		"chars",
		"maxGlyphs",
		"run",
		"run",
		"run",
		"run",
		"buffer",
		"run",
		"buffer",
		"run",
		"OS",
		"hHeap",
		"OS",
		"run",
		"run",
		"OS",
		"hHeap",
		"OS",
		"run",
		"GOFFSET_SIZEOF",
		"OS",
		"hdc",
		"run",
		"run",
		"run",
		"run",
		"run",
		"run",
		"run",
		"abc",
		"run",
		"abc",
		"abc",
		"abc",
		"OS",
		"OS",
		"hdc",
		"lptm",
		"run",
		"lptm",
		"run",
		"lptm",
		"run",
		"lptm",
		"offset",
		"step",
		"segments",
		"segments",
		"i",
		"segments",
		"i",
		"segments",
		"i",
		"offset",
		"offset",
		"step",
		"offset",
		"segments",
		"offset",
		"segments",
		"nSegments",
		"offset",
		"text",
		"length",
		"offset",
		"nSegments",
		"segments",
		"segments",
		"length",
		"offset",
		"i",
		"nSegments",
		"offset",
		"i",
		"segments",
		"i",
		"i",
		"offset",
		"offset",
		"segments",
		"offset",
		"segments",
		"nSegments",
		"offset",
		"text",
		"length",
		"offset",
		"nSegments",
		"segments",
		"segments",
		"length",
		"offset",
		"i",
		"nSegments",
		"offset",
		"segments",
		"i",
		"i",
		"offset",
		"offset",
		"ERROR_NULL_ARGUMENT",
		"device",
		"LEFT_TO_RIGHT",
		"CLSCTX_INPROC_SERVER",
		"S_OK",
		"tracking",
		"psla",
		"length",
		"start",
		"start",
		"length",
		"psla",
		"HEAP_ZERO_MEMORY",
		"sizeof",
		"length",
		"length",
		"analysis",
		"psla",
		"fallbackFont",
		"IsUnicode",
		"fallbackFont",
		"sizeof",
		"ERROR_GRAPHIC_DISPOSED",
		"handle",
		"length",
		"length",
		"length",
		"start",
		"tab",
		"length",
		"width",
		"width",
		"lineBreak",
		"lineBreak",
		"length",
		"start",
		"length",
		"width",
		"tab",
		"length",
		"analysis",
		"length",
		"glyphCount",
		"advances",
		"clusters",
		"visAttrs",
		"psla",
		"sizeof",
		"sizeof",
		"fSoftBreak",
		"fWhiteSpace",
		"tab",
		"fSoftBreak",
		"fWhiteSpace",
		"scripts",
		"eScript",
		"analysis",
		"sizeof",
		"langid",
		"scripts",
		"eScript",
		"analysis",
		"sizeof",
		"langid",
		"LANG_NEUTRAL",
		"langid",
		"LANG_NEUTRAL",
		"psla",
		"length",
		"sizeof",
		"sizeof",
		"fWhiteSpace",
		"length",
		"tab",
		"length",
		"psla",
		"sizeof",
		"sizeof",
		"fWhiteSpace",
		"length",
		"start",
		"start",
		"length",
		"length",
		"style",
		"style",
		"analysis",
		"analysis",
		"length",
		"length",
		"length",
		"length",
		"softBreak",
		"lineBreak",
		"width",
		"lineBreak",
		"lineWidth",
		"ascent",
		"descent",
		"length",
		"length",
		"width",
		"ascent",
		"descent",
		"lineBreak",
		"length",
		"length",
		"IsUnicode",
		"ascent",
		"tmAscent",
		"descent",
		"tmDescent",
		"ascent",
		"descent",
		"lineWidth",
		"CENTER",
		"lineWidth",
		"RIGHT",
		"lineWidth",
		"length",
		"x",
		"width",
		"start",
		"length",
		"ascent",
		"descent",
		"tracking",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"handle",
		"COLOR_LIST_SELECTION_TEXT",
		"COLOR_LIST_SELECTION",
		"handle",
		"BS_SOLID",
		"handle",
		"IsWinCE",
		"R2_COPYPEN",
		"R2_XORPEN",
		"PATINVERT",
		"PATCOPY",
		"TRANSPARENT",
		"length",
		"CENTER",
		"RIGHT",
		"x",
		"width",
		"x",
		"ascent",
		"length",
		"ascent",
		"length",
		"length",
		"x",
		"width",
		"width",
		"x",
		"lineBreak",
		"softBreak",
		"start",
		"length",
		"start",
		"width",
		"style",
		"background",
		"style",
		"handle",
		"background",
		"style",
		"ascent",
		"width",
		"ascent",
		"descent",
		"start",
		"start",
		"start",
		"start",
		"length",
		"glyphCount",
		"clusters",
		"visAttrs",
		"advances",
		"analysis",
		"RIGHT_TO_LEFT",
		"width",
		"left",
		"top",
		"clusters",
		"visAttrs",
		"advances",
		"analysis",
		"RIGHT_TO_LEFT",
		"width",
		"right",
		"bottom",
		"left",
		"top",
		"right",
		"left",
		"bottom",
		"top",
		"width",
		"length",
		"length",
		"x",
		"width",
		"width",
		"x",
		"tab",
		"lineBreak",
		"softBreak",
		"start",
		"length",
		"start",
		"handle",
		"style",
		"foreground",
		"style",
		"handle",
		"foreground",
		"style",
		"ascent",
		"psc",
		"analysis",
		"glyphs",
		"glyphCount",
		"advances",
		"goffsets",
		"style",
		"underline",
		"style",
		"strikeout",
		"style",
		"handle",
		"BS_SOLID",
		"underline",
		"style",
		"width",
		"strikeout",
		"style",
		"leading",
		"ascent",
		"width",
		"handle",
		"start",
		"handle",
		"handle",
		"start",
		"start",
		"start",
		"length",
		"glyphCount",
		"clusters",
		"visAttrs",
		"advances",
		"analysis",
		"RIGHT_TO_LEFT",
		"width",
		"left",
		"top",
		"clusters",
		"visAttrs",
		"advances",
		"analysis",
		"RIGHT_TO_LEFT",
		"width",
		"right",
		"bottom",
		"psc",
		"ETO_CLIPPED",
		"analysis",
		"glyphs",
		"glyphCount",
		"advances",
		"goffsets",
		"style",
		"underline",
		"style",
		"strikeout",
		"style",
		"underline",
		"style",
		"left",
		"right",
		"strikeout",
		"style",
		"leading",
		"ascent",
		"left",
		"right",
		"width",
		"length",
		"length",
		"length",
		"RIGHT_TO_LEFT",
		"length",
		"start",
		"length",
		"lineBreak",
		"start",
		"x",
		"x",
		"width",
		"start",
		"tab",
		"start",
		"length",
		"glyphCount",
		"clusters",
		"visAttrs",
		"advances",
		"analysis",
		"width",
		"fRTL",
		"analysis",
		"x",
		"x",
		"start",
		"width",
		"tab",
		"start",
		"length",
		"glyphCount",
		"clusters",
		"visAttrs",
		"advances",
		"analysis",
		"width",
		"fRTL",
		"analysis",
		"x",
		"x",
		"lineBreak",
		"lineBreak",
		"fallbackFont",
		"fallbackFont",
		"style",
		"font",
		"style",
		"handle",
		"font",
		"style",
		"font",
		"handle",
		"font",
		"systemFont",
		"ERROR_INVALID_RANGE",
		"length",
		"start",
		"uBidiLevel",
		"s",
		"analysis",
		"RIGHT_TO_LEFT",
		"length",
		"ERROR_INVALID_RANGE",
		"CENTER",
		"RIGHT",
		"length",
		"ERROR_INVALID_RANGE",
		"length",
		"length",
		"length",
		"ERROR_INVALID_RANGE",
		"IsUnicode",
		"handle",
		"systemFont",
		"tmAscent",
		"tmAscent",
		"ascent",
		"tmDescent",
		"tmDescent",
		"descent",
		"ascent",
		"descent",
		"length",
		"tmAscent",
		"tmDescent",
		"tmHeight",
		"tmInternalLeading",
		"tmAveCharWidth",
		"tmAscent",
		"tmDescent",
		"tmHeight",
		"tmInternalLeading",
		"tmAveCharWidth",
		"length",
		"length",
		"length",
		"ERROR_INVALID_RANGE",
		"length",
		"length",
		"length",
		"start",
		"length",
		"start",
		"tab",
		"width",
		"start",
		"length",
		"glyphCount",
		"clusters",
		"visAttrs",
		"advances",
		"analysis",
		"RIGHT_TO_LEFT",
		"width",
		"width",
		"CENTER",
		"x",
		"RIGHT",
		"x",
		"ERROR_INVALID_RANGE",
		"MOVEMENT_CHAR",
		"length",
		"start",
		"start",
		"length",
		"lineBreak",
		"softBreak",
		"start",
		"tab",
		"start",
		"scripts",
		"eScript",
		"analysis",
		"sizeof",
		"fNeedsCaretInfo",
		"fNeedsWordBreaking",
		"start",
		"start",
		"length",
		"psla",
		"start",
		"sizeof",
		"sizeof",
		"MOVEMENT_CLUSTER",
		"fNeedsCaretInfo",
		"fInvalid",
		"fCharStop",
		"MOVEMENT_WORD",
		"fNeedsWordBreaking",
		"fInvalid",
		"fWordStop",
		"length",
		"ERROR_NULL_ARGUMENT",
		"x",
		"y",
		"length",
		"ERROR_INVALID_ARGUMENT",
		"length",
		"length",
		"CENTER",
		"RIGHT",
		"length",
		"lineBreak",
		"softBreak",
		"start",
		"width",
		"tab",
		"width",
		"start",
		"length",
		"glyphCount",
		"RIGHT_TO_LEFT",
		"width",
		"clusters",
		"visAttrs",
		"advances",
		"analysis",
		"start",
		"width",
		"length",
		"RIGHT_TO_LEFT",
		"length",
		"ERROR_INVALID_RANGE",
		"length",
		"start",
		"style",
		"RIGHT_TO_LEFT",
		"uBidiLevel",
		"fArabicNumContext",
		"HEAP_ZERO_MEMORY",
		"sizeof",
		"length",
		"start",
		"style",
		"style",
		"sizeof",
		"sizeof",
		"analysis",
		"a",
		"a",
		"sizeof",
		"sizeof",
		"iCharPos",
		"start",
		"length",
		"start",
		"start",
		"sizeof",
		"sizeof",
		"analysis",
		"a",
		"length",
		"length",
		"uBidiLevel",
		"s",
		"analysis",
		"lineBreak",
		"softBreak",
		"RIGHT_TO_LEFT",
		"LEFT",
		"CENTER",
		"RIGHT",
		"LEFT",
		"LEFT",
		"RIGHT",
		"RIGHT",
		"alignment",
		"ERROR_INVALID_ARGUMENT",
		"ascent",
		"ascent",
		"ERROR_INVALID_ARGUMENT",
		"descent",
		"descent",
		"ERROR_INVALID_ARGUMENT",
		"font",
		"font",
		"font",
		"LEFT_TO_RIGHT",
		"RIGHT_TO_LEFT",
		"LEFT_TO_RIGHT",
		"LEFT_TO_RIGHT",
		"orientation",
		"orientation",
		"segments",
		"segments",
		"length",
		"segments",
		"length",
		"length",
		"segments",
		"length",
		"segments",
		"ERROR_INVALID_ARGUMENT",
		"lineSpacing",
		"lineSpacing",
		"length",
		"start",
		"length",
		"start",
		"start",
		"style",
		"style",
		"length",
		"length",
		"start",
		"start",
		"style",
		"start",
		"start",
		"style",
		"style",
		"length",
		"start",
		"start",
		"start",
		"length",
		"start",
		"length",
		"tabs",
		"tabs",
		"length",
		"tabs",
		"length",
		"length",
		"tabs",
		"length",
		"tabs",
		"ERROR_NULL_ARGUMENT",
		"text",
		"text",
		"start",
		"ERROR_INVALID_ARGUMENT",
		"wrapWidth",
		"wrapWidth",
		"psc",
		"length",
		"analysis",
		"glyphs",
		"clusters",
		"visAttrs",
		"glyphCount",
		"USP_E_SCRIPT_NOT_IN_FONT",
		"cBytes",
		"sizeof",
		"psc",
		"glyphs",
		"length",
		"length",
		"wgDefault",
		"length",
		"psc",
		"psc",
		"psc",
		"glyphCount",
		"length",
		"start",
		"start",
		"length",
		"length",
		"glyphs",
		"HEAP_ZERO_MEMORY",
		"clusters",
		"HEAP_ZERO_MEMORY",
		"visAttrs",
		"HEAP_ZERO_MEMORY",
		"psc",
		"HEAP_ZERO_MEMORY",
		"length",
		"S_OK",
		"fallbackFont",
		"psc",
		"length",
		"analysis",
		"glyphs",
		"clusters",
		"visAttrs",
		"glyphCount",
		"advances",
		"HEAP_ZERO_MEMORY",
		"glyphCount",
		"goffsets",
		"HEAP_ZERO_MEMORY",
		"glyphCount",
		"psc",
		"glyphs",
		"glyphCount",
		"visAttrs",
		"analysis",
		"advances",
		"goffsets",
		"width",
		"IsUnicode",
		"ascent",
		"tmAscent",
		"descent",
		"tmDescent",
		"leading",
		"tmInternalLeading",
		"length",
		"length",
		"length",
		"length",
		"device",
		"run",
		"hDC",
		"item",
		"gc",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"selectionStart",
		"selectionEnd",
		"selectionForeground",
		"selectionBackground",
		"start",
		"end",
		"item",
		"offset",
		"lineIndex",
		"offset",
		"lineIndex",
		"offset",
		"trailing",
		"offset",
		"movement",
		"offset",
		"movement",
		"forward",
		"point",
		"trailing",
		"x",
		"y",
		"trailing",
		"offset",
		"movement",
		"offset",
		"items",
		"itemCount",
		"runs",
		"alignment",
		"ascent",
		"descent",
		"font",
		"orientation",
		"segments",
		"spacing",
		"style",
		"start",
		"end",
		"tabs",
		"text",
		"width",
		"hdc",
		"run",
		"chars",
		"glyphCount",
		"maxGlyphs",
		"hdc",
		"run",
		"offset",
		"step",
		"offset",
		"offset"
	],
	"extendORImplementFiles":[
		"Resource"
	],
	"package":[
		"org.eclipse.swt.graphics"
	],
	"import":[
		"org.eclipse.swt.internal",
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt"
	],
	"methods":[
		"free",
		"breakRun",
		"checkItem",
		"checkLayout",
		"computeRuns",
		"dispose",
		"draw",
		"draw",
		"freeRuns",
		"getAlignment",
		"getAscent",
		"getBounds",
		"getBounds",
		"getDescent",
		"getFont",
		"getItemFont",
		"getLevel",
		"getLineBounds",
		"getLineCount",
		"getLineIndex",
		"getLineMetrics",
		"getLineOffsets",
		"getLocation",
		"getNextOffset",
		"_getOffset",
		"getOffset",
		"getOffset",
		"getOrientation",
		"getPreviousOffset",
		"getSegments",
		"getSegmentsText",
		"getSpacing",
		"getStyle",
		"getTabs",
		"getText",
		"getWidth",
		"isDisposed",
		"itemize",
		"merge",
		"reorder",
		"setAlignment",
		"setAscent",
		"setDescent",
		"setFont",
		"setOrientation",
		"setSegments",
		"setSpacing",
		"setStyle",
		"setTabs",
		"setText",
		"setWidth",
		"shape",
		"shape",
		"validadeOffset",
		"toString",
		"translateOffset",
		"untranslateOffset",
		"IIDFromString",
		"toCharArray",
		"IIDFromString",
		"toCharArray",
		"GetProcessHeap",
		"ScriptFreeCache",
		"HeapFree",
		"HeapFree",
		"HeapFree",
		"HeapFree",
		"HeapFree",
		"HeapFree",
		"HeapFree",
		"VtblCall",
		"getDevice",
		"error",
		"OleInitialize",
		"CoCreateInstance",
		"new_Object",
		"getChars",
		"GetProcessHeap",
		"HeapAlloc",
		"ScriptBreak",
		"GetObject",
		"free",
		"SelectObject",
		"getItemFont",
		"shape",
		"isDisposed",
		"error",
		"internal_new_GC",
		"CreateCompatibleDC",
		"itemize",
		"SelectObject",
		"getItemFont",
		"shape",
		"charAt",
		"charAt",
		"free",
		"ScriptGetLogicalWidths",
		"breakRun",
		"MoveMemory",
		"MoveMemory",
		"MoveMemory",
		"breakRun",
		"MoveMemory",
		"max",
		"breakRun",
		"MoveMemory",
		"free",
		"SelectObject",
		"getItemFont",
		"shape",
		"SelectObject",
		"getItemFont",
		"shape",
		"arraycopy",
		"arraycopy",
		"max",
		"max",
		"max",
		"max",
		"SelectObject",
		"getItemFont",
		"GetTextMetrics",
		"max",
		"max",
		"arraycopy",
		"reorder",
		"max",
		"max",
		"DeleteDC",
		"internal_dispose_GC",
		"freeRuns",
		"VtblCall",
		"OleUninitialize",
		"dispose_Object",
		"draw",
		"checkLayout",
		"computeRuns",
		"error",
		"isDisposed",
		"error",
		"isDisposed",
		"error",
		"isDisposed",
		"error",
		"length",
		"min",
		"max",
		"min",
		"max",
		"getSystemColor",
		"getSystemColor",
		"translateOffset",
		"translateOffset",
		"GetTextColor",
		"SaveDC",
		"CreateSolidBrush",
		"CreatePen",
		"SetROP2",
		"SetROP2",
		"GetROP2",
		"SetBkMode",
		"getClipping",
		"max",
		"max",
		"SelectObject",
		"PatBlt",
		"CreateSolidBrush",
		"SelectObject",
		"PatBlt",
		"SelectObject",
		"DeleteObject",
		"SelectObject",
		"max",
		"min",
		"ScriptCPtoX",
		"ScriptCPtoX",
		"PatBlt",
		"SetTextColor",
		"checkItem",
		"SelectObject",
		"getItemFont",
		"ScriptTextOut",
		"CreatePen",
		"SelectObject",
		"MoveToEx",
		"LineTo",
		"MoveToEx",
		"LineTo",
		"SelectObject",
		"DeleteObject",
		"SetTextColor",
		"max",
		"min",
		"ScriptCPtoX",
		"ScriptCPtoX",
		"ScriptTextOut",
		"SelectObject",
		"MoveToEx",
		"LineTo",
		"MoveToEx",
		"LineTo",
		"SelectObject",
		"RestoreDC",
		"DeleteObject",
		"DeleteObject",
		"free",
		"checkLayout",
		"checkLayout",
		"checkLayout",
		"computeRuns",
		"max",
		"checkLayout",
		"computeRuns",
		"length",
		"min",
		"max",
		"min",
		"max",
		"translateOffset",
		"translateOffset",
		"ScriptCPtoX",
		"ScriptCPtoX",
		"min",
		"max",
		"min",
		"max",
		"checkLayout",
		"checkLayout",
		"checkLayout",
		"computeRuns",
		"length",
		"error",
		"translateOffset",
		"checkLayout",
		"computeRuns",
		"error",
		"checkLayout",
		"computeRuns",
		"checkLayout",
		"computeRuns",
		"length",
		"error",
		"translateOffset",
		"checkLayout",
		"computeRuns",
		"error",
		"internal_new_GC",
		"CreateCompatibleDC",
		"length",
		"SelectObject",
		"GetTextMetrics",
		"max",
		"max",
		"checkItem",
		"SelectObject",
		"getItemFont",
		"GetTextMetrics",
		"max",
		"max",
		"max",
		"max",
		"DeleteDC",
		"internal_dispose_GC",
		"win32_new",
		"checkLayout",
		"computeRuns",
		"untranslateOffset",
		"checkLayout",
		"computeRuns",
		"length",
		"error",
		"length",
		"translateOffset",
		"min",
		"ScriptCPtoX",
		"checkLayout",
		"_getOffset",
		"computeRuns",
		"length",
		"error",
		"length",
		"translateOffset",
		"validadeOffset",
		"untranslateOffset",
		"untranslateOffset",
		"MoveMemory",
		"breakRun",
		"MoveMemory",
		"untranslateOffset",
		"untranslateOffset",
		"untranslateOffset",
		"isLetterOrDigit",
		"charAt",
		"isLetterOrDigit",
		"charAt",
		"isWhitespace",
		"charAt",
		"untranslateOffset",
		"validadeOffset",
		"length",
		"checkLayout",
		"error",
		"getOffset",
		"checkLayout",
		"computeRuns",
		"error",
		"min",
		"untranslateOffset",
		"untranslateOffset",
		"ScriptXtoCP",
		"untranslateOffset",
		"untranslateOffset",
		"checkLayout",
		"checkLayout",
		"_getOffset",
		"checkLayout",
		"length",
		"getChars",
		"min",
		"checkLayout",
		"checkLayout",
		"length",
		"error",
		"checkLayout",
		"checkLayout",
		"checkLayout",
		"getSegmentsText",
		"length",
		"GetProcessHeap",
		"HeapAlloc",
		"getChars",
		"ScriptItemize",
		"merge",
		"HeapFree",
		"length",
		"MoveMemory",
		"MoveMemory",
		"translateOffset",
		"MoveMemory",
		"arraycopy",
		"ScriptLayout",
		"checkLayout",
		"checkLayout",
		"error",
		"freeRuns",
		"checkLayout",
		"error",
		"freeRuns",
		"checkLayout",
		"isDisposed",
		"error",
		"equals",
		"freeRuns",
		"checkLayout",
		"freeRuns",
		"checkLayout",
		"freeRuns",
		"checkLayout",
		"error",
		"freeRuns",
		"checkLayout",
		"length",
		"min",
		"max",
		"min",
		"max",
		"equals",
		"freeRuns",
		"arraycopy",
		"checkLayout",
		"freeRuns",
		"checkLayout",
		"error",
		"equals",
		"freeRuns",
		"length",
		"checkLayout",
		"error",
		"freeRuns",
		"ScriptShape",
		"ScriptGetFontProperties",
		"MoveMemory",
		"ScriptFreeCache",
		"MoveMemory",
		"getChars",
		"GetProcessHeap",
		"HeapAlloc",
		"HeapAlloc",
		"HeapAlloc",
		"HeapAlloc",
		"shape",
		"VtblCall",
		"VtblCall",
		"SelectObject",
		"shape",
		"VtblCall",
		"SelectObject",
		"ScriptShape",
		"HeapAlloc",
		"HeapAlloc",
		"ScriptPlace",
		"GetTextMetrics",
		"translateOffset",
		"isDisposed",
		"length",
		"length",
		"StyleItem",
		"StyleItem",
		"LOGFONTW",
		"LOGFONTA",
		"SCRIPT_LOGATTR",
		"SCRIPT_PROPERTIES",
		"StyleItem",
		"TEXTMETRICW",
		"TEXTMETRICA",
		"RECT",
		"Rectangle",
		"Rectangle",
		"Rectangle",
		"Rectangle",
		"Rectangle",
		"TEXTMETRICW",
		"TEXTMETRICA",
		"Point",
		"Point",
		"Point",
		"Point",
		"Point",
		"SCRIPT_LOGATTR",
		"SCRIPT_PROPERTIES",
		"String",
		"SCRIPT_CONTROL",
		"SCRIPT_STATE",
		"SCRIPT_ITEM",
		"StyleItem",
		"SCRIPT_ANALYSIS",
		"StyleItem",
		"StyleItem",
		"StyleItem",
		"StyleItem",
		"StyleItem",
		"SCRIPT_FONTPROPERTIES",
		"TEXTMETRICW",
		"TEXTMETRICA"
	],
	"methodsBody":{
		"int translateOffset(int offset)":{
			"methodBody":"{\n    if (segments == null)\n        return offset;\n    int nSegments = segments.length;\n    if (nSegments <= 1)\n        return offset;\n    int length = text.length();\n    if (length == 0)\n        return offset;\n    if (nSegments == 2) {\n        if (segments[0] == 0 && segments[1] == length)\n            return offset;\n    }\n    for (int i = 0; i < nSegments && offset - i >= segments[i]; i++) {\n        offset++;\n    }\n    return offset;\n}",
			"comments":"",
			"methodName":"int translateOffset(int offset)"
		},
		"public void setOrientation(int orientation)":{
			"methodBody":"{\n    checkLayout();\n    int mask = SWT.LEFT_TO_RIGHT | SWT.RIGHT_TO_LEFT;\n    orientation &= mask;\n    if (orientation == 0)\n        return;\n    if ((orientation & SWT.LEFT_TO_RIGHT) != 0)\n        orientation = SWT.LEFT_TO_RIGHT;\n    if (this.orientation == orientation)\n        return;\n    this.orientation = orientation;\n    freeRuns();\n}",
			"comments":"/**\n* Sets the orientation of the receiver, which must be one\n* of <code>SWT.LEFT_TO_RIGHT</code> or <code>SWT.RIGHT_TO_LEFT</code>.\n* <p>\n*\n* @param orientation new orientation style\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void setOrientation(int orientation)"
		},
		"void checkItem(int hDC, StyleItem item)":{
			"methodBody":"{\n    if (item.fallbackFont != 0) {\n        \n        LOGFONT logFont = OS.IsUnicode ? (LOGFONT) new LOGFONTW() : new LOGFONTA();\n        if (OS.GetObject(item.fallbackFont, LOGFONT.sizeof, logFont) == 0) {\n            item.free();\n            OS.SelectObject(hDC, getItemFont(item));\n            shape(hDC, item);\n        }\n    }\n}",
			"comments":"/*\n* Feature in Windows. The fallback font returned by the MLang service\n* can be disposed by some other client running in the same thread.\n* For example, disposing a Browser widget internally releases all fonts\n* in the MLang cache. The fix is to use GetObject() to detect if the\n* font was disposed and reshape the run.\n*/\n",
			"methodName":"void checkItem(int hDC, StyleItem item)"
		},
		"public void setAscent(int ascent)":{
			"methodBody":"{\n    checkLayout();\n    if (ascent < -1)\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    if (this.ascent == ascent)\n        return;\n    freeRuns();\n    this.ascent = ascent;\n}",
			"comments":"/**\n* Sets the ascent of the receiver. The ascent is distance in pixels\n* from the baseline to the top of the line and it is applied to all\n* lines. The default value is <code>-1</code> which means that the\n* ascent is calculated from the line fonts.\n*\n* @param ascent the new ascent\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the ascent is less than <code>-1</code></li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #setDescent(int)\n* @see #getLineMetrics(int)\n*/\n",
			"methodName":"public void setAscent(int ascent)"
		},
		"StyleItem[] itemize()":{
			"methodBody":"{\n    segmentsText = getSegmentsText();\n    int length = segmentsText.length();\n    SCRIPT_CONTROL scriptControl = new SCRIPT_CONTROL();\n    SCRIPT_STATE scriptState = new SCRIPT_STATE();\n    final int MAX_ITEM = length + 1;\n    if ((orientation & SWT.RIGHT_TO_LEFT) != 0) {\n        scriptState.uBidiLevel = 1;\n        scriptState.fArabicNumContext = true;\n    }\n    int hHeap = OS.GetProcessHeap();\n    int pItems = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, MAX_ITEM * SCRIPT_ITEM.sizeof);\n    int[] pcItems = new int[1];\n    char[] chars = new char[length];\n    segmentsText.getChars(0, length, chars, 0);\n    OS.ScriptItemize(chars, length, MAX_ITEM, scriptControl, scriptState, pItems, pcItems);\n    \n    StyleItem[] runs = merge(pItems, pcItems[0]);\n    OS.HeapFree(hHeap, 0, pItems);\n    return runs;\n}",
			"comments":"/*\n*  Itemize the receiver text\n*/\n//\tif (hr == E_OUTOFMEMORY) //TODO handle it\n",
			"methodName":"StyleItem[] itemize()"
		},
		"public int getLevel(int offset)":{
			"methodBody":"{\n    checkLayout();\n    computeRuns(null);\n    int length = text.length();\n    if (!(0 <= offset && offset <= length))\n        SWT.error(SWT.ERROR_INVALID_RANGE);\n    offset = translateOffset(offset);\n    for (int i = 1; i < allRuns.length; i++) {\n        if (allRuns[i].start > offset) {\n            return allRuns[i - 1].analysis.s.uBidiLevel;\n        }\n    }\n    return (orientation & SWT.RIGHT_TO_LEFT) != 0 ? 1 : 0;\n}",
			"comments":"/**\n* Returns the embedding level for the specified character offset. The\n* embedding level is usually used to determine the directionality of a\n* character in bidirectional text.\n*\n* @param offset the charecter offset\n* @return the embedding level\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the character offset is out of range</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n*/\n",
			"methodName":"public int getLevel(int offset)"
		},
		"public void setSpacing(int spacing)":{
			"methodBody":"{\n    checkLayout();\n    if (spacing < 0)\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    if (this.lineSpacing == spacing)\n        return;\n    freeRuns();\n    this.lineSpacing = spacing;\n}",
			"comments":"/**\n* Sets the line spacing of the receiver.  The line spacing\n* is the space left between lines.\n*\n* @param spacing the new line spacing\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the spacing is negative</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void setSpacing(int spacing)"
		},
		"public void setTabs(int[] tabs)":{
			"methodBody":"{\n    checkLayout();\n    if (this.tabs == null && tabs == null)\n        return;\n    if (this.tabs != null && tabs != null) {\n        if (this.tabs.length == tabs.length) {\n            int i;\n            for (i = 0; i < tabs.length; i++) {\n                if (this.tabs[i] != tabs[i])\n                    break;\n            }\n            if (i == tabs.length)\n                return;\n        }\n    }\n    freeRuns();\n    this.tabs = tabs;\n}",
			"comments":"/**\n* Sets the receiver's tab list. Each value in the tab list specifies\n* the space in pixels from the origin of the text layout to the respective\n* tab stop.  The last tab stop width is repeated continuously.\n*\n* @param tabs the new tab list\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void setTabs(int[] tabs)"
		},
		"public void setStyle(TextStyle style, int start, int end)":{
			"methodBody":"{\n    checkLayout();\n    int length = text.length();\n    if (length == 0)\n        return;\n    if (start > end)\n        return;\n    start = Math.min(Math.max(0, start), length - 1);\n    end = Math.min(Math.max(0, end), length - 1);\n    int low = -1;\n    int high = styles.length;\n    while (high - low > 1) {\n        int index = (high + low) / 2;\n        if (start <= styles[index].start) {\n            high = index;\n        } else {\n            low = index;\n        }\n    }\n    if (0 <= high && high < styles.length) {\n        StyleItem item = styles[high];\n        if (item.start == start && styles[high + 1].start - 1 == end) {\n            if (style == null) {\n                if (item.style == null)\n                    return;\n            } else {\n                if (style.equals(item.style))\n                    return;\n            }\n        }\n    }\n    freeRuns();\n    int count = 0, i;\n    StyleItem[] newStyles = new StyleItem[styles.length + 2];\n    for (i = 0; i < styles.length; i++) {\n        StyleItem item = styles[i];\n        if (item.start >= start)\n            break;\n        newStyles[count++] = item;\n    }\n    StyleItem newItem = new StyleItem();\n    newItem.start = start;\n    newItem.style = style;\n    newStyles[count++] = newItem;\n    if (styles[i].start > end) {\n        newItem = new StyleItem();\n        newItem.start = end + 1;\n        newItem.style = styles[i - 1].style;\n        newStyles[count++] = newItem;\n    } else {\n        for (; i < styles.length; i++) {\n            StyleItem item = styles[i];\n            if (item.start > end)\n                break;\n        }\n        if (end != styles[i].start - 1) {\n            i--;\n            styles[i].start = end + 1;\n        }\n    }\n    for (; i < styles.length; i++) {\n        StyleItem item = styles[i];\n        if (item.start > end)\n            newStyles[count++] = item;\n    }\n    if (newStyles.length != count) {\n        styles = new StyleItem[count];\n        System.arraycopy(newStyles, 0, styles, 0, count);\n    } else {\n        styles = newStyles;\n    }\n}",
			"comments":"/**\n* Sets the style of the receiver for the specified range.  Styles previously\n* set for that range will be overwritten.  The start and end offsets are\n* inclusive and will be clamped if out of range.\n*\n* @param style the style\n* @param start the start offset\n* @param end the end offset\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void setStyle(TextStyle style, int start, int end)"
		},
		"public void setSegments(int[] segments)":{
			"methodBody":"{\n    checkLayout();\n    if (this.segments == null && segments == null)\n        return;\n    if (this.segments != null && segments != null) {\n        if (this.segments.length == segments.length) {\n            int i;\n            for (i = 0; i < segments.length; i++) {\n                if (this.segments[i] != segments[i])\n                    break;\n            }\n            if (i == segments.length)\n                return;\n        }\n    }\n    freeRuns();\n    this.segments = segments;\n}",
			"comments":"/**\n* Sets the offsets of the receiver's text segments. Text segments are used to\n* override the default behaviour of the bidirectional algorithm.\n* Bidirectional reordering can happen within a text segment but not\n* between two adjacent segments.\n* Each text segment is determined by two consecutive offsets in the\n* <code>segments</code> arrays. The first element of the array should\n* always be zero and the last one should always be equals to length of\n* the text.\n* <p>\n*\n* @param segments the text segments offset\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void setSegments(int[] segments)"
		},
		"public int getNextOffset(int offset, int movement)":{
			"methodBody":"{\n    checkLayout();\n    return _getOffset(offset, movement, true);\n}",
			"comments":"/**\n* Returns the next offset for the specified offset and movement\n* type.  The movement is one of <code>SWT.MOVEMENT_CHAR</code>,\n* <code>SWT.MOVEMENT_CLUSTER</code> or <code>SWT.MOVEMENT_WORD</code>.\n*\n* @param offset the start offset\n* @param movement the movement type\n* @return the next offset\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the offset is out of range</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #getPreviousOffset(int, int)\n*/\n",
			"methodName":"public int getNextOffset(int offset, int movement)"
		},
		"void breakRun(StyleItem run)":{
			"methodBody":"{\n    if (run.psla != 0)\n        return;\n    char[] chars = new char[run.length];\n    segmentsText.getChars(run.start, run.start + run.length, chars, 0);\n    int hHeap = OS.GetProcessHeap();\n    run.psla = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, SCRIPT_LOGATTR.sizeof * chars.length);\n    OS.ScriptBreak(chars, chars.length, run.analysis, run.psla);\n}",
			"comments":"",
			"methodName":"void breakRun(StyleItem run)"
		},
		"StyleItem[] reorder(StyleItem[] runs)":{
			"methodBody":"{\n    int length = runs.length;\n    if (length <= 1)\n        return runs;\n    byte[] bidiLevels = new byte[length];\n    for (int i = 0; i < length; i++) {\n        bidiLevels[i] = (byte) (runs[i].analysis.s.uBidiLevel & 0x1F);\n    }\n    \n    StyleItem lastRun = runs[length - 1];\n    if (lastRun.lineBreak && !lastRun.softBreak) {\n        bidiLevels[length - 1] = 0;\n    }\n    int[] log2vis = new int[length];\n    OS.ScriptLayout(length, bidiLevels, null, log2vis);\n    StyleItem[] result = new StyleItem[length];\n    for (int i = 0; i < length; i++) {\n        result[log2vis[i]] = runs[i];\n    }\n    if ((orientation & SWT.RIGHT_TO_LEFT) != 0) {\n        for (int i = 0; i < (length - 1) / 2; i++) {\n            StyleItem tmp = result[i];\n            result[i] = result[length - i - 2];\n            result[length - i - 2] = tmp;\n        }\n    }\n    return result;\n}",
			"comments":"/*\n*  Reorder the run\n*/\n/*\n* Feature in Windows.  If the orientation is RTL Uniscribe will\n* resolve the level of line breaks to 1, this can cause the line\n* break to be reorder to the middle of the line. The fix is to set\n* the level to zero to prevent it to be reordered.\n*/\n",
			"methodName":"StyleItem[] reorder(StyleItem[] runs)"
		},
		"public int getOffset(Point point, int[] trailing)":{
			"methodBody":"{\n    checkLayout();\n    if (point == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    return getOffset(point.x, point.y, trailing);\n}",
			"comments":"/**\n* Returns the character offset for the specified point.\n* For a typical character, the trailing argument will be filled in to\n* indicate whether the point is closer to the leading edge (0) or\n* the trailing edge (1).  When the point is over a cluster composed\n* of multiple characters, the trailing argument will be filled with the\n* position of the character in the cluster that is closest to\n* the point.\n*\n* @param point the point\n* @param trailing the trailing buffer\n* @return the character offset\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the trailing length is less than <code>1</code></li>\n*    <li>ERROR_NULL_ARGUMENT - if the point is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #getLocation(int, boolean)\n*/\n",
			"methodName":"public int getOffset(Point point, int[] trailing)"
		},
		"public Rectangle getBounds(int start, int end)":{
			"methodBody":"{\n    checkLayout();\n    computeRuns(null);\n    int length = text.length();\n    if (length == 0)\n        return new Rectangle(0, 0, 0, 0);\n    if (start > end)\n        return new Rectangle(0, 0, 0, 0);\n    start = Math.min(Math.max(0, start), length - 1);\n    end = Math.min(Math.max(0, end), length - 1);\n    start = translateOffset(start);\n    end = translateOffset(end);\n    int left = 0x7fffffff, right = 0;\n    int top = 0x7fffffff, bottom = 0;\n    int lineIndex = 0;\n    boolean isRTL = (orientation & SWT.RIGHT_TO_LEFT) != 0;\n    for (int i = 0; i < allRuns.length - 1; i++) {\n        StyleItem run = allRuns[i];\n        int runEnd = run.start + run.length;\n        if (run.lineBreak)\n            lineIndex++;\n        if (runEnd <= start)\n            continue;\n        if (run.start > end)\n            break;\n        int runLead = run.x;\n        int runTrail = run.x + run.width;\n        if (run.start <= start && start < runEnd) {\n            int cx = 0;\n            if (!run.tab) {\n                int[] piX = new int[1];\n                OS.ScriptCPtoX(start - run.start, false, run.length, run.glyphCount, run.clusters, run.visAttrs, run.advances, run.analysis, piX);\n                cx = isRTL ? run.width - piX[0] : piX[0];\n            }\n            if (run.analysis.fRTL ^ isRTL) {\n                runTrail = run.x + cx;\n            } else {\n                runLead = run.x + cx;\n            }\n        }\n        if (run.start <= end && end < runEnd) {\n            int cx = run.width;\n            if (!run.tab) {\n                int[] piX = new int[1];\n                OS.ScriptCPtoX(end - run.start, true, run.length, run.glyphCount, run.clusters, run.visAttrs, run.advances, run.analysis, piX);\n                cx = isRTL ? run.width - piX[0] : piX[0];\n            }\n            if (run.analysis.fRTL ^ isRTL) {\n                runLead = run.x + cx;\n            } else {\n                runTrail = run.x + cx;\n            }\n        }\n        left = Math.min(left, runLead);\n        right = Math.max(right, runTrail);\n        top = Math.min(top, lineY[run.lineBreak ? lineIndex - 1 : lineIndex]);\n        bottom = Math.max(bottom, lineY[run.lineBreak ? lineIndex : lineIndex + 1]);\n    }\n    return new Rectangle(left, top, right - left, bottom - top);\n}",
			"comments":"/**\n* Returns the bounds for the specified range of characters. The\n* bounds is the smallest rectangle that encompasses all characters\n* in the range. The start and end offsets are inclusive and will be\n* clamped if out of range.\n*\n* @param start the start offset\n* @param end the end offset\n* @return the bounds of the character range\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public Rectangle getBounds(int start, int end)"
		},
		"StyleItem[] merge(int items, int itemCount)":{
			"methodBody":"{\n    int count = 0, start = 0, end = segmentsText.length(), itemIndex = 0, styleIndex = 0;\n    StyleItem[] runs = new StyleItem[itemCount + styles.length];\n    SCRIPT_ITEM scriptItem = new SCRIPT_ITEM();\n    while (start < end) {\n        StyleItem item = new StyleItem();\n        item.start = start;\n        item.style = styles[styleIndex].style;\n        runs[count++] = item;\n        OS.MoveMemory(scriptItem, items + itemIndex * SCRIPT_ITEM.sizeof, SCRIPT_ITEM.sizeof);\n        item.analysis = scriptItem.a;\n        scriptItem.a = new SCRIPT_ANALYSIS();\n        OS.MoveMemory(scriptItem, items + (itemIndex + 1) * SCRIPT_ITEM.sizeof, SCRIPT_ITEM.sizeof);\n        int itemLimit = scriptItem.iCharPos;\n        int styleLimit = translateOffset(styles[styleIndex + 1].start);\n        if (styleLimit <= itemLimit) {\n            styleIndex++;\n            start = styleLimit;\n        }\n        if (itemLimit <= styleLimit) {\n            itemIndex++;\n            start = itemLimit;\n        }\n        item.length = start - item.start;\n    }\n    StyleItem item = new StyleItem();\n    item.start = end;\n    OS.MoveMemory(scriptItem, items + itemCount * SCRIPT_ITEM.sizeof, SCRIPT_ITEM.sizeof);\n    item.analysis = scriptItem.a;\n    runs[count++] = item;\n    if (runs.length != count) {\n        StyleItem[] result = new StyleItem[count];\n        System.arraycopy(runs, 0, result, 0, count);\n        return result;\n    }\n    return runs;\n}",
			"comments":"/*\n*  Merge styles ranges and script items\n*/\n",
			"methodName":"StyleItem[] merge(int items, int itemCount)"
		},
		"public void draw(GC gc, int x, int y)":{
			"methodBody":"{\n    draw(gc, x, y, -1, -1, null, null);\n}",
			"comments":"/**\n* Draws the receiver's text using the specified GC at the specified\n* point.\n*\n* @param gc the GC to draw\n* @param x the x coordinate of the top left corner of the rectangular area where the text is to be drawn\n* @param y the y coordinate of the top left corner of the rectangular area where the text is to be drawn\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the gc is null</li>\n* </ul>\n*/\n",
			"methodName":"public void draw(GC gc, int x, int y)"
		},
		"public Font getFont()":{
			"methodBody":"{\n    checkLayout();\n    return font;\n}",
			"comments":"/**\n* Returns the default font currently being used by the receiver\n* to draw and measure text.\n*\n* @return the receiver's font\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public Font getFont()"
		},
		"public int getLineIndex(int offset)":{
			"methodBody":"{\n    checkLayout();\n    computeRuns(null);\n    int length = text.length();\n    if (!(0 <= offset && offset <= length))\n        SWT.error(SWT.ERROR_INVALID_RANGE);\n    offset = translateOffset(offset);\n    for (int line = 0; line < runs.length; line++) {\n        if (lineOffset[line + 1] > offset) {\n            return line;\n        }\n    }\n    return runs.length - 1;\n}",
			"comments":"/**\n* Returns the index of the line that contains the specified\n* character offset.\n*\n* @param offset the character offset\n* @return the line index\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the character offset is out of range</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public int getLineIndex(int offset)"
		},
		"public Rectangle getBounds()":{
			"methodBody":"{\n    checkLayout();\n    computeRuns(null);\n    int width = 0;\n    if (wrapWidth != -1) {\n        width = wrapWidth;\n    } else {\n        for (int line = 0; line < runs.length; line++) {\n            width = Math.max(width, lineWidth[line]);\n        }\n    }\n    return new Rectangle(0, 0, width, lineY[lineY.length - 1]);\n}",
			"comments":"/**\n* Returns the bounds of the receiver.\n*\n* @return the bounds of the receiver\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public Rectangle getBounds()"
		},
		"String getSegmentsText()":{
			"methodBody":"{\n    if (segments == null)\n        return text;\n    int nSegments = segments.length;\n    if (nSegments <= 1)\n        return text;\n    int length = text.length();\n    if (length == 0)\n        return text;\n    if (nSegments == 2) {\n        if (segments[0] == 0 && segments[1] == length)\n            return text;\n    }\n    char[] oldChars = new char[length];\n    text.getChars(0, length, oldChars, 0);\n    char[] newChars = new char[length + nSegments];\n    int charCount = 0, segmentCount = 0;\n    char separator = orientation == SWT.RIGHT_TO_LEFT ? RTL_MARK : LTR_MARK;\n    while (charCount < length) {\n        if (segmentCount < nSegments && charCount == segments[segmentCount]) {\n            newChars[charCount + segmentCount++] = separator;\n        } else {\n            newChars[charCount + segmentCount] = oldChars[charCount++];\n        }\n    }\n    if (segmentCount < nSegments) {\n        segments[segmentCount] = charCount;\n        newChars[charCount + segmentCount++] = separator;\n    }\n    return new String(newChars, 0, Math.min(charCount + segmentCount, newChars.length));\n}",
			"comments":"",
			"methodName":"String getSegmentsText()"
		},
		"public int getDescent()":{
			"methodBody":"{\n    checkLayout();\n    return descent;\n}",
			"comments":"/**\n* Returns the descent of the receiver.\n*\n* @return the descent\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #getAscent()\n* @see #setAscent(int)\n* @see #setDescent(int)\n* @see #getLineMetrics(int)\n*/\n",
			"methodName":"public int getDescent()"
		},
		"public int[] getSegments()":{
			"methodBody":"{\n    checkLayout();\n    return segments;\n}",
			"comments":"/**\n* Returns the text segments offsets of the receiver.\n*\n* @return the text segments offsets\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public int[] getSegments()"
		},
		"int _getOffset(int offset, int movement, boolean forward)":{
			"methodBody":"{\n    computeRuns(null);\n    int length = text.length();\n    if (!(0 <= offset && offset <= length))\n        SWT.error(SWT.ERROR_INVALID_RANGE);\n    if (forward && offset == length)\n        return length;\n    if (!forward && offset == 0)\n        return 0;\n    int step = forward ? 1 : -1;\n    if ((movement & SWT.MOVEMENT_CHAR) != 0)\n        return offset + step;\n    length = segmentsText.length();\n    offset = translateOffset(offset);\n    SCRIPT_LOGATTR logAttr = new SCRIPT_LOGATTR();\n    SCRIPT_PROPERTIES properties = new SCRIPT_PROPERTIES();\n    int i = forward ? 0 : allRuns.length - 1;\n    offset = validadeOffset(offset, step);\n    do {\n        StyleItem run = allRuns[i];\n        if (run.start <= offset && offset < run.start + run.length) {\n            if (run.lineBreak && !run.softBreak)\n                return untranslateOffset(run.start);\n            if (run.tab)\n                return untranslateOffset(run.start);\n            OS.MoveMemory(properties, device.scripts[run.analysis.eScript], SCRIPT_PROPERTIES.sizeof);\n            boolean isComplex = properties.fNeedsCaretInfo || properties.fNeedsWordBreaking;\n            if (isComplex)\n                breakRun(run);\n            while (run.start <= offset && offset < run.start + run.length) {\n                if (isComplex) {\n                    OS.MoveMemory(logAttr, run.psla + ((offset - run.start) * SCRIPT_LOGATTR.sizeof), SCRIPT_LOGATTR.sizeof);\n                }\n                switch(movement) {\n                    case SWT.MOVEMENT_CLUSTER:\n                        {\n                            if (properties.fNeedsCaretInfo) {\n                                if (!logAttr.fInvalid && logAttr.fCharStop)\n                                    return untranslateOffset(offset);\n                            } else {\n                                return untranslateOffset(offset);\n                            }\n                            break;\n                        }\n                    case SWT.MOVEMENT_WORD:\n                        {\n                            if (properties.fNeedsWordBreaking) {\n                                if (!logAttr.fInvalid && logAttr.fWordStop)\n                                    return untranslateOffset(offset);\n                            } else {\n                                if (offset > 0) {\n                                    boolean letterOrDigit = Compatibility.isLetterOrDigit(segmentsText.charAt(offset));\n                                    boolean previousLetterOrDigit = Compatibility.isLetterOrDigit(segmentsText.charAt(offset - 1));\n                                    if (letterOrDigit != previousLetterOrDigit || !letterOrDigit) {\n                                        if (!Compatibility.isWhitespace(segmentsText.charAt(offset))) {\n                                            return untranslateOffset(offset);\n                                        }\n                                    }\n                                }\n                            }\n                            break;\n                        }\n                }\n                offset = validadeOffset(offset, step);\n            }\n        }\n        i += step;\n    } while (0 <= i && i < allRuns.length - 1 && 0 <= offset && offset < length);\n    return forward ? text.length() : 0;\n}",
			"comments":"",
			"methodName":"int _getOffset(int offset, int movement, boolean forward)"
		},
		"public TextStyle getStyle(int offset)":{
			"methodBody":"{\n    checkLayout();\n    int length = text.length();\n    if (!(0 <= offset && offset < length))\n        SWT.error(SWT.ERROR_INVALID_RANGE);\n    for (int i = 1; i < styles.length; i++) {\n        if (styles[i].start > offset) {\n            return styles[i - 1].style;\n        }\n    }\n    return null;\n}",
			"comments":"/**\n* Gets the style of the receiver at the specified character offset.\n*\n* @param offset the text offset\n* @return the style or <code>null</code> if not set\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the character offset is out of range</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public TextStyle getStyle(int offset)"
		},
		"public void setFont(Font font)":{
			"methodBody":"{\n    checkLayout();\n    if (font != null && font.isDisposed())\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    if (this.font == font)\n        return;\n    if (font != null && font.equals(this.font))\n        return;\n    freeRuns();\n    this.font = font;\n}",
			"comments":"/**\n* Sets the default font which will be used by the receiver\n* to draw and measure text. If the\n* argument is null, then a default font appropriate\n* for the platform will be used instead. Note that a text\n* style can override the default font.\n*\n* @param font the new font for the receiver, or null to indicate a default font\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the font has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void setFont(Font font)"
		},
		"public String getText()":{
			"methodBody":"{\n    checkLayout();\n    return text;\n}",
			"comments":"/**\n* Gets the receiver's text, which will be an empty\n* string if it has never been set.\n*\n* @return the receiver's text\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public String getText()"
		},
		"public void setWidth(int width)":{
			"methodBody":"{\n    checkLayout();\n    if (width < -1 || width == 0)\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    if (this.wrapWidth == width)\n        return;\n    freeRuns();\n    this.wrapWidth = width;\n}",
			"comments":"/**\n* Sets the line width of the receiver, which determines how\n* text should be wrapped and aligned. The default value is\n* <code>-1</code> which means wrapping is disabled.\n*\n* @param width the new width\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the width is <code>0</code> or less than <code>-1</code></li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #setAlignment(int)\n*/\n",
			"methodName":"public void setWidth(int width)"
		},
		"public int getOrientation()":{
			"methodBody":"{\n    checkLayout();\n    return orientation;\n}",
			"comments":"/**\n* Returns the orientation of the receiver.\n*\n* @return the orientation style\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public int getOrientation()"
		},
		"boolean shape(int hdc, StyleItem run, char[] chars, int[] glyphCount, int maxGlyphs)":{
			"methodBody":"{\n    int hr = OS.ScriptShape(hdc, run.psc, chars, chars.length, maxGlyphs, run.analysis, run.glyphs, run.clusters, run.visAttrs, glyphCount);\n    run.glyphCount = glyphCount[0];\n    if (hr != OS.USP_E_SCRIPT_NOT_IN_FONT) {\n        SCRIPT_FONTPROPERTIES fp = new SCRIPT_FONTPROPERTIES();\n        fp.cBytes = SCRIPT_FONTPROPERTIES.sizeof;\n        OS.ScriptGetFontProperties(hdc, run.psc, fp);\n        short[] glyphs = new short[glyphCount[0]];\n        OS.MoveMemory(glyphs, run.glyphs, glyphs.length * 2);\n        int i;\n        for (i = 0; i < glyphs.length; i++) {\n            if (glyphs[i] == fp.wgDefault)\n                break;\n        }\n        if (i == glyphs.length)\n            return true;\n    }\n    if (run.psc != 0) {\n        OS.ScriptFreeCache(run.psc);\n        glyphCount[0] = 0;\n        OS.MoveMemory(run.psc, glyphCount, 4);\n    }\n    run.glyphCount = 0;\n    return false;\n}",
			"comments":"",
			"methodName":"boolean shape(int hdc, StyleItem run, char[] chars, int[] glyphCount, int maxGlyphs)"
		},
		"public int getSpacing()":{
			"methodBody":"{\n    checkLayout();\n    return lineSpacing;\n}",
			"comments":"/**\n* Returns the line spacing of the receiver.\n*\n* @return the line spacing\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public int getSpacing()"
		},
		"public void setText(String text)":{
			"methodBody":"{\n    checkLayout();\n    if (text == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (text.equals(this.text))\n        return;\n    freeRuns();\n    this.text = text;\n    styles = new StyleItem[2];\n    styles[0] = new StyleItem();\n    styles[1] = new StyleItem();\n    styles[1].start = text.length();\n}",
			"comments":"/**\n* Sets the receiver's text.\n*\n* @param text the new text\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the text is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void setText(String text)"
		},
		"public Point getLocation(int offset, boolean trailing)":{
			"methodBody":"{\n    checkLayout();\n    computeRuns(null);\n    int length = text.length();\n    if (!(0 <= offset && offset <= length))\n        SWT.error(SWT.ERROR_INVALID_RANGE);\n    length = segmentsText.length();\n    offset = translateOffset(offset);\n    int line;\n    for (line = 0; line < runs.length; line++) {\n        if (lineOffset[line + 1] > offset)\n            break;\n    }\n    line = Math.min(line, runs.length - 1);\n    StyleItem[] lineRuns = runs[line];\n    Point result = null;\n    if (offset == length) {\n        result = new Point(lineWidth[line], lineY[line]);\n    } else {\n        int width = 0;\n        for (int i = 0; i < lineRuns.length; i++) {\n            StyleItem run = lineRuns[i];\n            int end = run.start + run.length;\n            if (run.start <= offset && offset < end) {\n                if (run.tab) {\n                    if (trailing || (offset == length))\n                        width += run.width;\n                    result = new Point(width, lineY[line]);\n                } else {\n                    int runOffset = offset - run.start;\n                    int cChars = run.length;\n                    int gGlyphs = run.glyphCount;\n                    int[] piX = new int[1];\n                    OS.ScriptCPtoX(runOffset, trailing, cChars, gGlyphs, run.clusters, run.visAttrs, run.advances, run.analysis, piX);\n                    if ((orientation & SWT.RIGHT_TO_LEFT) != 0) {\n                        result = new Point(width + (run.width - piX[0]), lineY[line]);\n                    } else {\n                        result = new Point(width + piX[0], lineY[line]);\n                    }\n                }\n                break;\n            }\n            width += run.width;\n        }\n    }\n    if (result == null)\n        result = new Point(0, 0);\n    if (wrapWidth != -1) {\n        switch(alignment) {\n            case SWT.CENTER:\n                result.x += (wrapWidth - lineWidth[line]) / 2;\n                break;\n            case SWT.RIGHT:\n                result.x += wrapWidth - lineWidth[line];\n                break;\n        }\n    }\n    return result;\n}",
			"comments":"/**\n* Returns the location for the specified character offset. The\n* <code>trailing</code> argument indicates whether the offset\n* corresponds to the leading or trailing edge of the cluster.\n*\n* @param offset the character offset\n* @param trailing the trailing flag\n* @return the location of the character offset\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #getOffset(Point, int[])\n* @see #getOffset(int, int, int[])\n*/\n",
			"methodName":"public Point getLocation(int offset, boolean trailing)"
		},
		"public Rectangle getLineBounds(int lineIndex)":{
			"methodBody":"{\n    checkLayout();\n    computeRuns(null);\n    if (!(0 <= lineIndex && lineIndex < runs.length))\n        SWT.error(SWT.ERROR_INVALID_RANGE);\n    int x = 0, y = lineY[lineIndex];\n    int width = lineWidth[lineIndex], height = lineY[lineIndex + 1] - y;\n    if (wrapWidth != -1) {\n        switch(alignment) {\n            case SWT.CENTER:\n                x = (wrapWidth - width) / 2;\n                break;\n            case SWT.RIGHT:\n                x = wrapWidth - width;\n                break;\n        }\n    }\n    return new Rectangle(x, y, width, height);\n}",
			"comments":"/**\n* Returns the bounds of the line for the specified line index.\n*\n* @param lineIndex the line index\n* @return the line bounds\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the line index is out of range</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public Rectangle getLineBounds(int lineIndex)"
		},
		"public void draw(GC gc, int x, int y, int selectionStart, int selectionEnd, Color selectionForeground, Color selectionBackground)":{
			"methodBody":"{\n    checkLayout();\n    computeRuns(gc);\n    if (gc == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (gc.isDisposed())\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    if (selectionForeground != null && selectionForeground.isDisposed())\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    if (selectionBackground != null && selectionBackground.isDisposed())\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    int length = text.length();\n    if (length == 0)\n        return;\n    int hdc = gc.handle;\n    boolean hasSelection = selectionStart <= selectionEnd && selectionStart != -1 && selectionEnd != -1;\n    if (hasSelection) {\n        selectionStart = Math.min(Math.max(0, selectionStart), length - 1);\n        selectionEnd = Math.min(Math.max(0, selectionEnd), length - 1);\n        if (selectionForeground == null)\n            selectionForeground = device.getSystemColor(SWT.COLOR_LIST_SELECTION_TEXT);\n        if (selectionBackground == null)\n            selectionBackground = device.getSystemColor(SWT.COLOR_LIST_SELECTION);\n        selectionStart = translateOffset(selectionStart);\n        selectionEnd = translateOffset(selectionEnd);\n    }\n    int foreground = OS.GetTextColor(hdc);\n    int state = OS.SaveDC(hdc);\n    RECT rect = new RECT();\n    int selBrush = 0, selPen = 0;\n    if (hasSelection) {\n        selBrush = OS.CreateSolidBrush(selectionBackground.handle);\n        selPen = OS.CreatePen(OS.BS_SOLID, 1, selectionForeground.handle);\n    }\n    int rop2 = 0;\n    if (OS.IsWinCE) {\n        rop2 = OS.SetROP2(hdc, OS.R2_COPYPEN);\n        OS.SetROP2(hdc, rop2);\n    } else {\n        rop2 = OS.GetROP2(hdc);\n    }\n    int dwRop = rop2 == OS.R2_XORPEN ? OS.PATINVERT : OS.PATCOPY;\n    OS.SetBkMode(hdc, OS.TRANSPARENT);\n    Rectangle clip = gc.getClipping();\n    for (int line = 0; line < runs.length; line++) {\n        int drawX = x, drawY = y + lineY[line];\n        if (wrapWidth != -1) {\n            switch(alignment) {\n                case SWT.CENTER:\n                    drawX += (wrapWidth - lineWidth[line]) / 2;\n                    break;\n                case SWT.RIGHT:\n                    drawX += wrapWidth - lineWidth[line];\n                    break;\n            }\n        }\n        if (drawX > clip.x + clip.width)\n            continue;\n        if (drawX + lineWidth[line] < clip.x)\n            continue;\n        StyleItem[] lineRuns = runs[line];\n        int baseline = Math.max(0, this.ascent);\n        for (int i = 0; i < lineRuns.length; i++) {\n            baseline = Math.max(baseline, lineRuns[i].ascent);\n        }\n        int lineHeight = lineY[line + 1] - lineY[line];\n        int alignmentX = drawX;\n        for (int i = 0; i < lineRuns.length; i++) {\n            StyleItem run = lineRuns[i];\n            if (run.length == 0)\n                continue;\n            if (drawX > clip.x + clip.width)\n                break;\n            if (drawX + run.width >= clip.x) {\n                if (!run.lineBreak || run.softBreak) {\n                    int end = run.start + run.length - 1;\n                    boolean fullSelection = hasSelection && selectionStart <= run.start && selectionEnd >= end;\n                    if (fullSelection) {\n                        OS.SelectObject(hdc, selBrush);\n                        OS.PatBlt(hdc, drawX, drawY, run.width, lineHeight, dwRop);\n                    } else {\n                        if (run.style != null && run.style.background != null) {\n                            int bg = run.style.background.handle;\n                            int drawRunY = drawY + (baseline - run.ascent);\n                            int hBrush = OS.CreateSolidBrush(bg);\n                            int oldBrush = OS.SelectObject(hdc, hBrush);\n                            OS.PatBlt(hdc, drawX, drawRunY, run.width, run.ascent + run.descent, dwRop);\n                            OS.SelectObject(hdc, oldBrush);\n                            OS.DeleteObject(hBrush);\n                        }\n                        boolean partialSelection = hasSelection && !(selectionStart > end || run.start > selectionEnd);\n                        if (partialSelection) {\n                            OS.SelectObject(hdc, selBrush);\n                            int selStart = Math.max(selectionStart, run.start) - run.start;\n                            int selEnd = Math.min(selectionEnd, end) - run.start;\n                            int cChars = run.length;\n                            int gGlyphs = run.glyphCount;\n                            int[] piX = new int[1];\n                            OS.ScriptCPtoX(selStart, false, cChars, gGlyphs, run.clusters, run.visAttrs, run.advances, run.analysis, piX);\n                            int runX = (orientation & SWT.RIGHT_TO_LEFT) != 0 ? run.width - piX[0] : piX[0];\n                            rect.left = drawX + runX;\n                            rect.top = drawY;\n                            OS.ScriptCPtoX(selEnd, true, cChars, gGlyphs, run.clusters, run.visAttrs, run.advances, run.analysis, piX);\n                            runX = (orientation & SWT.RIGHT_TO_LEFT) != 0 ? run.width - piX[0] : piX[0];\n                            rect.right = drawX + runX;\n                            rect.bottom = drawY + lineHeight;\n                            OS.PatBlt(hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, dwRop);\n                        }\n                    }\n                }\n            }\n            drawX += run.width;\n        }\n        drawX = alignmentX;\n        for (int i = 0; i < lineRuns.length; i++) {\n            StyleItem run = lineRuns[i];\n            if (run.length == 0)\n                continue;\n            if (drawX > clip.x + clip.width)\n                break;\n            if (drawX + run.width >= clip.x) {\n                if (!run.tab && (!run.lineBreak || run.softBreak)) {\n                    int end = run.start + run.length - 1;\n                    int fg = foreground;\n                    boolean fullSelection = hasSelection && selectionStart <= run.start && selectionEnd >= end;\n                    if (fullSelection) {\n                        fg = selectionForeground.handle;\n                    } else {\n                        if (run.style != null && run.style.foreground != null)\n                            fg = run.style.foreground.handle;\n                    }\n                    OS.SetTextColor(hdc, fg);\n                    checkItem(hdc, run);\n                    OS.SelectObject(hdc, getItemFont(run));\n                    int drawRunY = drawY + (baseline - run.ascent);\n                    OS.ScriptTextOut(hdc, run.psc, drawX, drawRunY, 0, null, run.analysis, 0, 0, run.glyphs, run.glyphCount, run.advances, null, run.goffsets);\n                    if ((run.style != null) && (run.style.underline || run.style.strikeout)) {\n                        int newPen = hasSelection && fg == selectionForeground.handle ? selPen : OS.CreatePen(OS.BS_SOLID, 1, fg);\n                        int oldPen = OS.SelectObject(hdc, newPen);\n                        if (run.style.underline) {\n                            int underlineY = drawY + baseline + 1;\n                            OS.MoveToEx(hdc, drawX, underlineY, 0);\n                            OS.LineTo(hdc, drawX + run.width, underlineY);\n                        }\n                        if (run.style.strikeout) {\n                            int strikeoutY = drawRunY + run.leading + run.ascent / 2;\n                            OS.MoveToEx(hdc, drawX, strikeoutY, 0);\n                            OS.LineTo(hdc, drawX + run.width, strikeoutY);\n                        }\n                        OS.SelectObject(hdc, oldPen);\n                        if (!hasSelection || fg != selectionForeground.handle)\n                            OS.DeleteObject(newPen);\n                    }\n                    boolean partialSelection = hasSelection && !(selectionStart > end || run.start > selectionEnd);\n                    if (!fullSelection && partialSelection && fg != selectionForeground.handle) {\n                        OS.SetTextColor(hdc, selectionForeground.handle);\n                        int selStart = Math.max(selectionStart, run.start) - run.start;\n                        int selEnd = Math.min(selectionEnd, end) - run.start;\n                        int cChars = run.length;\n                        int gGlyphs = run.glyphCount;\n                        int[] piX = new int[1];\n                        OS.ScriptCPtoX(selStart, false, cChars, gGlyphs, run.clusters, run.visAttrs, run.advances, run.analysis, piX);\n                        int runX = (orientation & SWT.RIGHT_TO_LEFT) != 0 ? run.width - piX[0] : piX[0];\n                        rect.left = drawX + runX;\n                        rect.top = drawY;\n                        OS.ScriptCPtoX(selEnd, true, cChars, gGlyphs, run.clusters, run.visAttrs, run.advances, run.analysis, piX);\n                        runX = (orientation & SWT.RIGHT_TO_LEFT) != 0 ? run.width - piX[0] : piX[0];\n                        rect.right = drawX + runX;\n                        rect.bottom = drawY + lineHeight;\n                        OS.ScriptTextOut(hdc, run.psc, drawX, drawRunY, OS.ETO_CLIPPED, rect, run.analysis, 0, 0, run.glyphs, run.glyphCount, run.advances, null, run.goffsets);\n                        if ((run.style != null) && (run.style.underline || run.style.strikeout)) {\n                            int oldPen = OS.SelectObject(hdc, selPen);\n                            if (run.style.underline) {\n                                int underlineY = drawY + baseline + 1;\n                                OS.MoveToEx(hdc, rect.left, underlineY, 0);\n                                OS.LineTo(hdc, rect.right, underlineY);\n                            }\n                            if (run.style.strikeout) {\n                                int strikeoutY = drawRunY + run.leading + run.ascent / 2;\n                                OS.MoveToEx(hdc, rect.left, strikeoutY, 0);\n                                OS.LineTo(hdc, rect.right, strikeoutY);\n                            }\n                            OS.SelectObject(hdc, oldPen);\n                        }\n                    }\n                }\n            }\n            drawX += run.width;\n        }\n    }\n    OS.RestoreDC(hdc, state);\n    if (selBrush != 0)\n        OS.DeleteObject(selBrush);\n    if (selPen != 0)\n        OS.DeleteObject(selPen);\n}",
			"comments":"/**\n* Draws the receiver's text using the specified GC at the specified\n* point.\n*\n* @param gc the GC to draw\n* @param x the x coordinate of the top left corner of the rectangular area where the text is to be drawn\n* @param y the y coordinate of the top left corner of the rectangular area where the text is to be drawn\n* @param selectionStart the offset where the selections starts, or -1 indicating no selection\n* @param selectionEnd the offset where the selections ends, or -1 indicating no selection\n* @param selectionForeground selection foreground, or NULL to use the system default color\n* @param selectionBackground selection background, or NULL to use the system default color\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the gc is null</li>\n* </ul>\n*/\n",
			"methodName":"public void draw(GC gc, int x, int y, int selectionStart, int selectionEnd, Color selectionForeground, Color selectionBackground)"
		},
		"public int getAscent()":{
			"methodBody":"{\n    checkLayout();\n    return ascent;\n}",
			"comments":"/**\n* Returns the ascent of the receiver.\n*\n* @return the ascent\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #getDescent()\n* @see #setDescent(int)\n* @see #setAscent(int)\n* @see #getLineMetrics(int)\n*/\n",
			"methodName":"public int getAscent()"
		},
		"public int getWidth()":{
			"methodBody":"{\n    checkLayout();\n    return wrapWidth;\n}",
			"comments":"/**\n* Returns the width of the receiver.\n*\n* @return the width\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public int getWidth()"
		},
		"int validadeOffset(int offset, int step)":{
			"methodBody":"{\n    offset += step;\n    if (segments != null && segments.length > 2) {\n        for (int i = 0; i < segments.length; i++) {\n            if (translateOffset(segments[i]) - 1 == offset) {\n                offset += step;\n                break;\n            }\n        }\n    }\n    return offset;\n}",
			"comments":"",
			"methodName":"int validadeOffset(int offset, int step)"
		},
		"public boolean isDisposed()":{
			"methodBody":"{\n    return device == null;\n}",
			"comments":"/**\n* Returns <code>true</code> if the text layout has been disposed,\n* and <code>false</code> otherwise.\n* <p>\n* This method gets the dispose state for the text layout.\n* When a text layout has been disposed, it is an error to\n* invoke any other method using the text layout.\n*\n* @return <code>true</code> when the text layout is disposed and <code>false</code> otherwise\n*/\n",
			"methodName":"public boolean isDisposed()"
		},
		"public FontMetrics getLineMetrics(int lineIndex)":{
			"methodBody":"{\n    checkLayout();\n    computeRuns(null);\n    if (!(0 <= lineIndex && lineIndex < runs.length))\n        SWT.error(SWT.ERROR_INVALID_RANGE);\n    int hDC = device.internal_new_GC(null);\n    int srcHdc = OS.CreateCompatibleDC(hDC);\n    TEXTMETRIC lptm = OS.IsUnicode ? (TEXTMETRIC) new TEXTMETRICW() : new TEXTMETRICA();\n    if (text.length() == 0) {\n        OS.SelectObject(srcHdc, font != null ? font.handle : device.systemFont);\n        OS.GetTextMetrics(srcHdc, lptm);\n        lptm.tmAscent = Math.max(lptm.tmAscent, this.ascent);\n        lptm.tmDescent = Math.max(lptm.tmDescent, this.descent);\n    } else {\n        int ascent = this.ascent, descent = this.descent, leading = 0, aveCharWidth = 0, height = 0;\n        StyleItem[] lineRuns = runs[lineIndex];\n        for (int i = 0; i < lineRuns.length; i++) {\n            StyleItem run = lineRuns[i];\n            checkItem(srcHdc, run);\n            OS.SelectObject(srcHdc, getItemFont(run));\n            OS.GetTextMetrics(srcHdc, lptm);\n            ascent = Math.max(ascent, lptm.tmAscent);\n            descent = Math.max(descent, lptm.tmDescent);\n            height = Math.max(height, lptm.tmHeight);\n            leading = Math.max(leading, lptm.tmInternalLeading);\n            aveCharWidth += lptm.tmAveCharWidth;\n        }\n        lptm.tmAscent = ascent;\n        lptm.tmDescent = descent;\n        lptm.tmHeight = height;\n        lptm.tmInternalLeading = leading;\n        lptm.tmAveCharWidth = aveCharWidth / lineRuns.length;\n    }\n    if (srcHdc != 0)\n        OS.DeleteDC(srcHdc);\n    device.internal_dispose_GC(hDC, null);\n    return FontMetrics.win32_new(lptm);\n}",
			"comments":"/**\n* Returns the font metrics for the specified line index.\n*\n* @param lineIndex the line index\n* @return the font metrics\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the line index is out of range</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public FontMetrics getLineMetrics(int lineIndex)"
		},
		"public void setDescent(int descent)":{
			"methodBody":"{\n    checkLayout();\n    if (descent < -1)\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    if (this.descent == descent)\n        return;\n    freeRuns();\n    this.descent = descent;\n}",
			"comments":"/**\n* Sets the descent of the receiver. The descent is distance in pixels\n* from the baseline to the bottom of the line and it is applied to all\n* lines. The default value is <code>-1</code> which means that the\n* descent is calculated from the line fonts.\n*\n* @param descent the new descent\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the descent is less than <code>-1</code></li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #setAscent(int)\n* @see #getLineMetrics(int)\n*/\n",
			"methodName":"public void setDescent(int descent)"
		},
		"public int[] getTabs()":{
			"methodBody":"{\n    checkLayout();\n    return tabs;\n}",
			"comments":"/**\n* Returns the tab list of the receiver.\n*\n* @return the tab list\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public int[] getTabs()"
		},
		"public String toString()":{
			"methodBody":"{\n    if (isDisposed())\n        return \"TextLayout {*DISPOSED*}\";\n    return \"TextLayout {}\";\n}",
			"comments":"/**\n* Returns a string containing a concise, human-readable\n* description of the receiver.\n*\n* @return a string representation of the receiver\n*/\n",
			"methodName":"public String toString()"
		},
		"public int getLineCount()":{
			"methodBody":"{\n    checkLayout();\n    computeRuns(null);\n    return runs.length;\n}",
			"comments":"/**\n* Returns the receiver's line count. This includes lines caused\n* by wrapping.\n*\n* @return the line count\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public int getLineCount()"
		},
		"void checkLayout()":{
			"methodBody":"{\n    if (isDisposed())\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n}",
			"comments":"",
			"methodName":"void checkLayout()"
		},
		"public int getAlignment()":{
			"methodBody":"{\n    checkLayout();\n    return alignment;\n}",
			"comments":"/**\n* Returns the receiver's horizontal text alignment, which will be one\n* of <code>SWT.LEFT</code>, <code>SWT.CENTER</code> or\n* <code>SWT.RIGHT</code>.\n*\n* @return the alignment used to positioned text horizontally\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public int getAlignment()"
		},
		"public int getOffset(int x, int y, int[] trailing)":{
			"methodBody":"{\n    checkLayout();\n    computeRuns(null);\n    if (trailing != null && trailing.length < 1)\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    int line;\n    int lineCount = runs.length;\n    for (line = 0; line < lineCount; line++) {\n        if (lineY[line + 1] > y)\n            break;\n    }\n    line = Math.min(line, runs.length - 1);\n    if (wrapWidth != -1) {\n        switch(alignment) {\n            case SWT.CENTER:\n                x -= (wrapWidth - lineWidth[line]) / 2;\n                break;\n            case SWT.RIGHT:\n                x -= wrapWidth - lineWidth[line];\n                break;\n        }\n    }\n    StyleItem[] lineRuns = runs[line];\n    if (x >= lineWidth[line])\n        x = lineWidth[line] - 1;\n    if (x < 0)\n        x = 0;\n    int width = 0;\n    for (int i = 0; i < lineRuns.length; i++) {\n        StyleItem run = lineRuns[i];\n        if (run.lineBreak && !run.softBreak)\n            return untranslateOffset(run.start);\n        if (width + run.width > x) {\n            if (run.tab) {\n                if (trailing != null)\n                    trailing[0] = x < (width + run.width / 2) ? 0 : 1;\n                return untranslateOffset(run.start);\n            }\n            int cChars = run.length;\n            int cGlyphs = run.glyphCount;\n            int xRun = x - width;\n            int[] piCP = new int[1];\n            int[] piTrailing = new int[1];\n            if ((orientation & SWT.RIGHT_TO_LEFT) != 0) {\n                xRun = run.width - xRun;\n            }\n            OS.ScriptXtoCP(xRun, cChars, cGlyphs, run.clusters, run.visAttrs, run.advances, run.analysis, piCP, piTrailing);\n            if (trailing != null)\n                trailing[0] = piTrailing[0];\n            return untranslateOffset(run.start + piCP[0]);\n        }\n        width += run.width;\n    }\n    if (trailing != null)\n        trailing[0] = 0;\n    return untranslateOffset(lineOffset[line + 1]);\n}",
			"comments":"/**\n* Returns the character offset for the specified point.\n* For a typical character, the trailing argument will be filled in to\n* indicate whether the point is closer to the leading edge (0) or\n* the trailing edge (1).  When the point is over a cluster composed\n* of multiple characters, the trailing argument will be filled with the\n* position of the character in the cluster that is closest to\n* the point.\n*\n* @param x the x coordinate of the point\n* @param y the y coordinate of the point\n* @param trailing the trailing buffer\n* @return the character offset\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the trailing length is less than <code>1</code></li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #getLocation(int, boolean)\n*/\n",
			"methodName":"public int getOffset(int x, int y, int[] trailing)"
		},
		"void freeRuns()":{
			"methodBody":"{\n    if (allRuns == null)\n        return;\n    for (int i = 0; i < allRuns.length; i++) {\n        StyleItem run = allRuns[i];\n        run.free();\n    }\n    allRuns = null;\n    runs = null;\n    segmentsText = null;\n}",
			"comments":"",
			"methodName":"void freeRuns()"
		},
		"public void dispose()":{
			"methodBody":"{\n    if (device == null)\n        return;\n    freeRuns();\n    font = null;\n    text = null;\n    segmentsText = null;\n    tabs = null;\n    styles = null;\n    runs = null;\n    lineOffset = null;\n    lineY = null;\n    lineWidth = null;\n    if (mLangFontLink2 != 0) {\n        \n        OS.VtblCall(2, mLangFontLink2);\n        mLangFontLink2 = 0;\n    }\n    OS.OleUninitialize();\n    if (device.tracking)\n        device.dispose_Object(this);\n    device = null;\n}",
			"comments":"/**\n* Disposes of the operating system resources associated with\n* the text layout. Applications must dispose of all allocated text layouts.\n*/\n/* Release() */\n",
			"methodName":"public void dispose()"
		},
		"public int[] getLineOffsets()":{
			"methodBody":"{\n    checkLayout();\n    computeRuns(null);\n    int[] offsets = new int[lineOffset.length];\n    for (int i = 0; i < offsets.length; i++) {\n        offsets[i] = untranslateOffset(lineOffset[i]);\n    }\n    return offsets;\n}",
			"comments":"/**\n* Returns the line offsets.  Each value in the array is the\n* offset for the first character in a line except for the last\n* value, which contains the length of the text.\n*\n* @return the line offsets\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public int[] getLineOffsets()"
		},
		"void computeRuns(GC gc)":{
			"methodBody":"{\n    if (runs != null)\n        return;\n    int hDC = gc != null ? gc.handle : device.internal_new_GC(null);\n    int srcHdc = OS.CreateCompatibleDC(hDC);\n    allRuns = itemize();\n    for (int i = 0; i < allRuns.length - 1; i++) {\n        StyleItem run = allRuns[i];\n        OS.SelectObject(srcHdc, getItemFont(run));\n        shape(srcHdc, run);\n    }\n    SCRIPT_LOGATTR logAttr = new SCRIPT_LOGATTR();\n    SCRIPT_PROPERTIES properties = new SCRIPT_PROPERTIES();\n    int lineWidth = 0, lineStart = 0, lineCount = 1;\n    for (int i = 0; i < allRuns.length - 1; i++) {\n        StyleItem run = allRuns[i];\n        if (run.length == 1) {\n            char ch = segmentsText.charAt(run.start);\n            switch(ch) {\n                case '\\t':\n                    {\n                        run.tab = true;\n                        if (tabs == null)\n                            break;\n                        int tabsLength = tabs.length, j;\n                        for (j = 0; j < tabsLength; j++) {\n                            if (tabs[j] > lineWidth) {\n                                run.width = tabs[j] - lineWidth;\n                                break;\n                            }\n                        }\n                        if (j == tabsLength) {\n                            int tabX = tabs[tabsLength - 1];\n                            int lastTabWidth = tabsLength > 1 ? tabs[tabsLength - 1] - tabs[tabsLength - 2] : tabs[0];\n                            if (lastTabWidth > 0) {\n                                while (tabX <= lineWidth) tabX += lastTabWidth;\n                                run.width = tabX - lineWidth;\n                            }\n                        }\n                        break;\n                    }\n                case '\\n':\n                    {\n                        run.lineBreak = true;\n                        break;\n                    }\n                case '\\r':\n                    {\n                        run.lineBreak = true;\n                        StyleItem next = allRuns[i + 1];\n                        if (next.length != 0 && segmentsText.charAt(next.start) == '\\n') {\n                            run.length += 1;\n                            next.free();\n                            i++;\n                        }\n                        break;\n                    }\n            }\n        }\n        if (wrapWidth != -1 && lineWidth + run.width > wrapWidth && !run.tab) {\n            int start = 0;\n            int[] piDx = new int[run.length];\n            OS.ScriptGetLogicalWidths(run.analysis, run.length, run.glyphCount, run.advances, run.clusters, run.visAttrs, piDx);\n            int width = 0, maxWidth = wrapWidth - lineWidth;\n            while (width + piDx[start] < maxWidth) {\n                width += piDx[start++];\n            }\n            int firstStart = start;\n            int firstIndice = i;\n            while (i >= lineStart) {\n                breakRun(run);\n                while (start >= 0) {\n                    OS.MoveMemory(logAttr, run.psla + (start * SCRIPT_LOGATTR.sizeof), SCRIPT_LOGATTR.sizeof);\n                    if (logAttr.fSoftBreak || logAttr.fWhiteSpace)\n                        break;\n                    start--;\n                }\n                \n                if (start == 0 && i != lineStart && !run.tab) {\n                    if (logAttr.fSoftBreak && !logAttr.fWhiteSpace) {\n                        OS.MoveMemory(properties, device.scripts[run.analysis.eScript], SCRIPT_PROPERTIES.sizeof);\n                        int langID = properties.langid;\n                        StyleItem pRun = allRuns[i - 1];\n                        OS.MoveMemory(properties, device.scripts[pRun.analysis.eScript], SCRIPT_PROPERTIES.sizeof);\n                        if (properties.langid == langID || langID == OS.LANG_NEUTRAL || properties.langid == OS.LANG_NEUTRAL) {\n                            breakRun(pRun);\n                            OS.MoveMemory(logAttr, pRun.psla + ((pRun.length - 1) * SCRIPT_LOGATTR.sizeof), SCRIPT_LOGATTR.sizeof);\n                            if (!logAttr.fWhiteSpace)\n                                start = -1;\n                        }\n                    }\n                }\n                if (start >= 0 || i == lineStart)\n                    break;\n                run = allRuns[--i];\n                start = run.length - 1;\n            }\n            if (start == 0 && i != lineStart && !run.tab) {\n                run = allRuns[--i];\n            } else if (start <= 0 && i == lineStart) {\n                i = firstIndice;\n                run = allRuns[i];\n                start = Math.max(1, firstStart);\n            }\n            breakRun(run);\n            while (start < run.length) {\n                OS.MoveMemory(logAttr, run.psla + (start * SCRIPT_LOGATTR.sizeof), SCRIPT_LOGATTR.sizeof);\n                if (!logAttr.fWhiteSpace)\n                    break;\n                start++;\n            }\n            if (0 < start && start < run.length) {\n                StyleItem newRun = new StyleItem();\n                newRun.start = run.start + start;\n                newRun.length = run.length - start;\n                newRun.style = run.style;\n                newRun.analysis = run.analysis;\n                run.free();\n                run.length = start;\n                OS.SelectObject(srcHdc, getItemFont(run));\n                shape(srcHdc, run);\n                OS.SelectObject(srcHdc, getItemFont(newRun));\n                shape(srcHdc, newRun);\n                StyleItem[] newAllRuns = new StyleItem[allRuns.length + 1];\n                System.arraycopy(allRuns, 0, newAllRuns, 0, i + 1);\n                System.arraycopy(allRuns, i + 1, newAllRuns, i + 2, allRuns.length - i - 1);\n                allRuns = newAllRuns;\n                allRuns[i + 1] = newRun;\n            }\n            if (i != allRuns.length - 2) {\n                run.softBreak = run.lineBreak = true;\n            }\n        }\n        lineWidth += run.width;\n        if (run.lineBreak) {\n            lineStart = i + 1;\n            lineWidth = 0;\n            lineCount++;\n        }\n    }\n    lineWidth = 0;\n    runs = new StyleItem[lineCount][];\n    lineOffset = new int[lineCount + 1];\n    lineY = new int[lineCount + 1];\n    this.lineWidth = new int[lineCount];\n    int lineRunCount = 0, line = 0;\n    int ascent = Math.max(0, this.ascent);\n    int descent = Math.max(0, this.descent);\n    StyleItem[] lineRuns = new StyleItem[allRuns.length];\n    for (int i = 0; i < allRuns.length; i++) {\n        StyleItem run = allRuns[i];\n        lineRuns[lineRunCount++] = run;\n        lineWidth += run.width;\n        ascent = Math.max(ascent, run.ascent);\n        descent = Math.max(descent, run.descent);\n        if (run.lineBreak || i == allRuns.length - 1) {\n            \n            if (lineRunCount == 1 && i == allRuns.length - 1) {\n                TEXTMETRIC lptm = OS.IsUnicode ? (TEXTMETRIC) new TEXTMETRICW() : new TEXTMETRICA();\n                OS.SelectObject(srcHdc, getItemFont(run));\n                OS.GetTextMetrics(srcHdc, lptm);\n                run.ascent = lptm.tmAscent;\n                run.descent = lptm.tmDescent;\n                ascent = Math.max(ascent, run.ascent);\n                descent = Math.max(descent, run.descent);\n            }\n            runs[line] = new StyleItem[lineRunCount];\n            System.arraycopy(lineRuns, 0, runs[line], 0, lineRunCount);\n            StyleItem lastRun = runs[line][lineRunCount - 1];\n            runs[line] = reorder(runs[line]);\n            this.lineWidth[line] = lineWidth;\n            lineWidth = 0;\n            if (wrapWidth != -1) {\n                switch(alignment) {\n                    case SWT.CENTER:\n                        lineWidth = (wrapWidth - this.lineWidth[line]) / 2;\n                        break;\n                    case SWT.RIGHT:\n                        lineWidth = wrapWidth - this.lineWidth[line];\n                        break;\n                }\n            }\n            for (int j = 0; j < runs[line].length; j++) {\n                runs[line][j].x = lineWidth;\n                lineWidth += runs[line][j].width;\n            }\n            line++;\n            lineY[line] = lineY[line - 1] + ascent + descent + lineSpacing;\n            lineOffset[line] = lastRun.start + lastRun.length;\n            lineRunCount = lineWidth = 0;\n            ascent = Math.max(0, this.ascent);\n            descent = Math.max(0, this.descent);\n        }\n    }\n    if (srcHdc != 0)\n        OS.DeleteDC(srcHdc);\n    if (gc == null)\n        device.internal_dispose_GC(hDC, null);\n}",
			"comments":"/*\n*  Compute the runs: itemize, shape, place, and reorder the runs.\n* \tBreak paragraphs into lines, wraps the text, and initialize caches.\n*/\n/*\n*  Bug in Windows. For some reason Uniscribe sets the fSoftBreak flag for the first letter\n*  after a letter with an accent. This cause a break line to be set in the middle of a word.\n*  The fix is to detect the case and ignore fSoftBreak forcing the algorithm keep searching.\n*/\n/* Update the run metrics if the last run is a hard break. */\n",
			"methodName":"void computeRuns(GC gc)"
		},
		"void free()":{
			"methodBody":"{\n    int hHeap = OS.GetProcessHeap();\n    if (psc != 0) {\n        OS.ScriptFreeCache(psc);\n        OS.HeapFree(hHeap, 0, psc);\n        psc = 0;\n    }\n    if (glyphs != 0) {\n        OS.HeapFree(hHeap, 0, glyphs);\n        glyphs = 0;\n        glyphCount = 0;\n    }\n    if (clusters != 0) {\n        OS.HeapFree(hHeap, 0, clusters);\n        clusters = 0;\n    }\n    if (visAttrs != 0) {\n        OS.HeapFree(hHeap, 0, visAttrs);\n        visAttrs = 0;\n    }\n    if (advances != 0) {\n        OS.HeapFree(hHeap, 0, advances);\n        advances = 0;\n    }\n    if (goffsets != 0) {\n        OS.HeapFree(hHeap, 0, goffsets);\n        goffsets = 0;\n    }\n    if (psla != 0) {\n        OS.HeapFree(hHeap, 0, psla);\n        psla = 0;\n    }\n    if (fallbackFont != 0) {\n        if (mLangFontLink2 != 0) {\n            \n            OS.VtblCall(8, mLangFontLink2, fallbackFont);\n        }\n        fallbackFont = 0;\n    }\n    width = ascent = descent = x = 0;\n    lineBreak = softBreak = false;\n}",
			"comments":"/* ReleaseFont() */\n",
			"methodName":"void free()"
		},
		"public void setAlignment(int alignment)":{
			"methodBody":"{\n    checkLayout();\n    int mask = SWT.LEFT | SWT.CENTER | SWT.RIGHT;\n    alignment &= mask;\n    if (alignment == 0)\n        return;\n    if ((alignment & SWT.LEFT) != 0)\n        alignment = SWT.LEFT;\n    if ((alignment & SWT.RIGHT) != 0)\n        alignment = SWT.RIGHT;\n    this.alignment = alignment;\n}",
			"comments":"/**\n* Sets the text alignment for the receiver. The alignment controls\n* how a line of text is positioned horizontally. The argument should\n* be one of <code>SWT.LEFT</code>, <code>SWT.RIGHT</code> or <code>SWT.CENTER</code>.\n* <p>\n* The default alignment is <code>SWT.LEFT</code>.  Note that the receiver's\n* width must be set in order to use <code>SWT.RIGHT</code> or <code>SWT.CENTER</code>\n* alignment.\n*</p>\n*\n* @param alignment the new alignment\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #setWidth(int)\n*/\n",
			"methodName":"public void setAlignment(int alignment)"
		},
		"int getItemFont(StyleItem item)":{
			"methodBody":"{\n    if (item.fallbackFont != 0)\n        return item.fallbackFont;\n    if (item.style != null && item.style.font != null) {\n        return item.style.font.handle;\n    }\n    if (this.font != null) {\n        return this.font.handle;\n    }\n    return device.systemFont;\n}",
			"comments":"",
			"methodName":"int getItemFont(StyleItem item)"
		},
		"public int getPreviousOffset(int offset, int movement)":{
			"methodBody":"{\n    checkLayout();\n    return _getOffset(offset, movement, false);\n}",
			"comments":"/**\n* Returns the previous offset for the specified offset and movement\n* type.  The movement is one of <code>SWT.MOVEMENT_CHAR</code>,\n* <code>SWT.MOVEMENT_CLUSTER</code> or <code>SWT.MOVEMENT_WORD</code>.\n*\n* @param offset the start offset\n* @param movement the movement type\n* @return the previous offset\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the offset is out of range</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #getNextOffset(int, int)\n*/\n",
			"methodName":"public int getPreviousOffset(int offset, int movement)"
		},
		"void shape(final int hdc, final StyleItem run)":{
			"methodBody":"{\n    int[] buffer = new int[1];\n    char[] chars = new char[run.length];\n    segmentsText.getChars(run.start, run.start + run.length, chars, 0);\n    int maxGlyphs = (chars.length * 3 / 2) + 16;\n    int hHeap = OS.GetProcessHeap();\n    run.glyphs = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, maxGlyphs * 2);\n    run.clusters = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, maxGlyphs * 2);\n    run.visAttrs = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, maxGlyphs * SCRIPT_VISATTR_SIZEOF);\n    run.psc = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, 4);\n    if (!shape(hdc, run, chars, buffer, maxGlyphs)) {\n        if (mLangFontLink2 != 0) {\n            int[] dwCodePages = new int[1];\n            int[] cchCodePages = new int[1];\n            \n            OS.VtblCall(4, mLangFontLink2, chars, chars.length, 0, dwCodePages, cchCodePages);\n            int[] hNewFont = new int[1];\n            \n            if (OS.VtblCall(10, mLangFontLink2, hdc, dwCodePages[0], chars[0], hNewFont) == OS.S_OK) {\n                int hFont = OS.SelectObject(hdc, hNewFont[0]);\n                if (shape(hdc, run, chars, buffer, maxGlyphs)) {\n                    run.fallbackFont = hNewFont[0];\n                } else {\n                    \n                    OS.VtblCall(8, mLangFontLink2, hNewFont[0]);\n                    OS.SelectObject(hdc, hFont);\n                    OS.ScriptShape(hdc, run.psc, chars, chars.length, maxGlyphs, run.analysis, run.glyphs, run.clusters, run.visAttrs, buffer);\n                    run.glyphCount = buffer[0];\n                }\n            }\n        }\n    }\n    int[] abc = new int[3];\n    run.advances = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, run.glyphCount * 4);\n    run.goffsets = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, run.glyphCount * GOFFSET_SIZEOF);\n    OS.ScriptPlace(hdc, run.psc, run.glyphs, run.glyphCount, run.visAttrs, run.analysis, run.advances, run.goffsets, abc);\n    run.width = abc[0] + abc[1] + abc[2];\n    TEXTMETRIC lptm = OS.IsUnicode ? (TEXTMETRIC) new TEXTMETRICW() : new TEXTMETRICA();\n    OS.GetTextMetrics(hdc, lptm);\n    run.ascent = lptm.tmAscent;\n    run.descent = lptm.tmDescent;\n    run.leading = lptm.tmInternalLeading;\n}",
			"comments":"/*\n* Generate glyphs for one Run.\n*/\n/* GetStrCodePages() */\n/* MapFont() */\n/* ReleaseFont() */\n",
			"methodName":"void shape(final int hdc, final StyleItem run)"
		},
		"int untranslateOffset(int offset)":{
			"methodBody":"{\n    if (segments == null)\n        return offset;\n    int nSegments = segments.length;\n    if (nSegments <= 1)\n        return offset;\n    int length = text.length();\n    if (length == 0)\n        return offset;\n    if (nSegments == 2) {\n        if (segments[0] == 0 && segments[1] == length)\n            return offset;\n    }\n    for (int i = 0; i < nSegments && offset > segments[i]; i++) {\n        offset--;\n    }\n    return offset;\n}",
			"comments":"",
			"methodName":"int untranslateOffset(int offset)"
		}
	},
	"ClassORInterfaceName":[
		"TextLayout",
		"StyleItem"
	]
}
