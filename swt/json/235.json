{
	"variables":[
		"BMPFileHeaderSize",
		"BMPHeaderFixedSize",
		"importantColors",
		"pelsPerMeter",
		"sp",
		"end",
		"dp",
		"size",
		"left",
		"i",
		"n",
		"theByte",
		"sp",
		"end",
		"dp",
		"size",
		"left",
		"i",
		"n",
		"theByte",
		"sp",
		"se",
		"dp",
		"de",
		"x",
		"y",
		"len",
		"i",
		"theByte",
		"i",
		"sp",
		"se",
		"dp",
		"de",
		"x",
		"y",
		"len",
		"i",
		"theByte",
		"i",
		"header",
		"infoHeaderSize",
		"width",
		"height",
		"bitCount",
		"stride",
		"data",
		"height",
		"dataSize",
		"data",
		"cmp",
		"compressedSize",
		"compressed",
		"header",
		"fileHeader",
		"infoHeader",
		"width",
		"height",
		"bitCount",
		"palette",
		"data",
		"xPelsPerMeter",
		"yPelsPerMeter",
		"type",
		"depth",
		"numColors",
		"buf",
		"bytesOffset",
		"colors",
		"i",
		"n",
		"bytes",
		"offset",
		"i",
		"col",
		"totalSize",
		"bpl",
		"bmpBpl",
		"imageBpl",
		"buf",
		"srcOffset",
		"data",
		"buf2",
		"buf2Offset",
		"y",
		"lineSize",
		"bmpBpl",
		"bpl",
		"linesPerBuf",
		"buf",
		"data",
		"imageBpl",
		"dataIndex",
		"y",
		"count",
		"bufOffset",
		"i",
		"wIndex",
		"y",
		"tmp",
		"count",
		"bufOffset",
		"i",
		"rgbs",
		"numCols",
		"comp",
		"pal",
		"headersSize",
		"fileHeader",
		"out",
		"data",
		"i1",
		"i2",
		"i",
		"index",
		"b",
		"comp",
		"src",
		"srcOffset",
		"numBytes",
		"dest",
		"last",
		"comp",
		"src",
		"srcOffset",
		"numBytes",
		"dest",
		"last",
		"SWT",
		"SWT",
		"srcOffset",
		"srcOffset",
		"numBytes",
		"sp",
		"end",
		"left",
		"end",
		"sp",
		"left",
		"left",
		"n",
		"n",
		"left",
		"n",
		"src",
		"sp",
		"n",
		"src",
		"sp",
		"n",
		"n",
		"n",
		"left",
		"n",
		"n",
		"dest",
		"dp",
		"dp",
		"dest",
		"dp",
		"src",
		"sp",
		"dp",
		"sp",
		"size",
		"dest",
		"dp",
		"dp",
		"dest",
		"dp",
		"n",
		"n",
		"dp",
		"i",
		"n",
		"i",
		"i",
		"dest",
		"dp",
		"src",
		"sp",
		"dp",
		"sp",
		"size",
		"n",
		"n",
		"dest",
		"dp",
		"dp",
		"size",
		"left",
		"end",
		"sp",
		"left",
		"left",
		"left",
		"theByte",
		"src",
		"sp",
		"n",
		"n",
		"left",
		"n",
		"src",
		"sp",
		"n",
		"theByte",
		"dest",
		"dp",
		"n",
		"n",
		"dp",
		"dest",
		"dp",
		"theByte",
		"dp",
		"sp",
		"n",
		"size",
		"dest",
		"dp",
		"dp",
		"last",
		"dest",
		"dp",
		"dp",
		"dest",
		"dp",
		"dp",
		"size",
		"size",
		"srcOffset",
		"srcOffset",
		"numBytes",
		"sp",
		"end",
		"left",
		"end",
		"sp",
		"left",
		"left",
		"n",
		"n",
		"left",
		"n",
		"src",
		"sp",
		"n",
		"src",
		"sp",
		"n",
		"n",
		"left",
		"n",
		"n",
		"dest",
		"dp",
		"dp",
		"dest",
		"dp",
		"src",
		"sp",
		"dp",
		"sp",
		"size",
		"dest",
		"dp",
		"dp",
		"dest",
		"dp",
		"src",
		"sp",
		"dp",
		"sp",
		"size",
		"dest",
		"dp",
		"dp",
		"dest",
		"dp",
		"n",
		"dp",
		"i",
		"n",
		"i",
		"i",
		"dest",
		"dp",
		"src",
		"sp",
		"dp",
		"sp",
		"size",
		"n",
		"n",
		"dest",
		"dp",
		"dp",
		"size",
		"left",
		"end",
		"sp",
		"left",
		"left",
		"left",
		"theByte",
		"src",
		"sp",
		"n",
		"n",
		"left",
		"n",
		"src",
		"sp",
		"n",
		"theByte",
		"dest",
		"dp",
		"n",
		"dp",
		"dest",
		"dp",
		"theByte",
		"dp",
		"sp",
		"n",
		"size",
		"dest",
		"dp",
		"dp",
		"last",
		"dest",
		"dp",
		"dp",
		"dest",
		"dp",
		"dp",
		"size",
		"size",
		"cmp",
		"src",
		"src",
		"stride",
		"dest",
		"dest",
		"SWT",
		"SWT",
		"cmp",
		"src",
		"src",
		"stride",
		"dest",
		"dest",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"numBytes",
		"destSize",
		"sp",
		"se",
		"src",
		"sp",
		"sp",
		"len",
		"len",
		"src",
		"sp",
		"sp",
		"len",
		"y",
		"x",
		"dp",
		"y",
		"stride",
		"dp",
		"de",
		"x",
		"src",
		"sp",
		"sp",
		"y",
		"src",
		"sp",
		"sp",
		"dp",
		"y",
		"stride",
		"x",
		"dp",
		"de",
		"len",
		"x",
		"len",
		"len",
		"len",
		"len",
		"se",
		"sp",
		"len",
		"de",
		"dp",
		"i",
		"len",
		"i",
		"dest",
		"dp",
		"src",
		"sp",
		"dp",
		"sp",
		"sp",
		"sp",
		"len",
		"x",
		"len",
		"len",
		"len",
		"src",
		"sp",
		"sp",
		"len",
		"de",
		"dp",
		"i",
		"len",
		"i",
		"dest",
		"dp",
		"theByte",
		"dp",
		"numBytes",
		"destSize",
		"sp",
		"se",
		"src",
		"sp",
		"sp",
		"len",
		"len",
		"src",
		"sp",
		"sp",
		"len",
		"y",
		"x",
		"dp",
		"y",
		"stride",
		"dp",
		"de",
		"x",
		"src",
		"sp",
		"sp",
		"y",
		"src",
		"sp",
		"sp",
		"dp",
		"y",
		"stride",
		"x",
		"dp",
		"de",
		"len",
		"se",
		"sp",
		"len",
		"de",
		"dp",
		"i",
		"len",
		"i",
		"dest",
		"dp",
		"src",
		"sp",
		"dp",
		"sp",
		"sp",
		"sp",
		"x",
		"len",
		"src",
		"sp",
		"sp",
		"len",
		"de",
		"dp",
		"i",
		"len",
		"i",
		"dest",
		"dp",
		"theByte",
		"dp",
		"x",
		"len",
		"stream",
		"header",
		"stream",
		"header",
		"header",
		"header",
		"header",
		"header",
		"header",
		"header",
		"infoHeaderSize",
		"BMPHeaderFixedSize",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"width",
		"bitCount",
		"stride",
		"stride",
		"infoHeader",
		"stride",
		"data",
		"stride",
		"height",
		"data",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"height",
		"stride",
		"dataSize",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"cmp",
		"inputStream",
		"data",
		"dataSize",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"e",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"compressedSize",
		"inputStream",
		"compressed",
		"compressedSize",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"e",
		"compressed",
		"data",
		"stride",
		"cmp",
		"data",
		"header",
		"inputStream",
		"header",
		"inputStream",
		"header",
		"inputStream",
		"header",
		"inputStream",
		"header",
		"inputStream",
		"SWT",
		"SWT",
		"e",
		"header",
		"SWT",
		"SWT",
		"header",
		"BMPHeaderFixedSize",
		"inputStream",
		"infoHeader",
		"SWT",
		"SWT",
		"e",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"inputStream",
		"fileHeader",
		"inputStream",
		"fileHeader",
		"inputStream",
		"SWT",
		"SWT",
		"e",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"xPelsPerMeter",
		"yPelsPerMeter",
		"SWT",
		"SWT",
		"ImageData",
		"width",
		"height",
		"bitCount",
		"palette",
		"data",
		"type",
		"infoHeader",
		"infoHeader",
		"depth",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"numColors",
		"numColors",
		"depth",
		"numColors",
		"numColors",
		"numColors",
		"inputStream",
		"buf",
		"buf",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"e",
		"buf",
		"numColors",
		"depth",
		"depth",
		"numColors",
		"i",
		"numColors",
		"i",
		"colors",
		"i",
		"bytes",
		"bytesOffset",
		"bytes",
		"bytesOffset",
		"bytes",
		"bytesOffset",
		"bytesOffset",
		"colors",
		"pal",
		"pal",
		"pal",
		"n",
		"i",
		"n",
		"i",
		"pal",
		"i",
		"bytes",
		"offset",
		"col",
		"bytes",
		"offset",
		"col",
		"bytes",
		"offset",
		"col",
		"offset",
		"bytes",
		"comp",
		"image",
		"out",
		"image",
		"image",
		"bpl",
		"image",
		"bmpBpl",
		"imageBpl",
		"image",
		"image",
		"totalSize",
		"image",
		"y",
		"y",
		"comp",
		"data",
		"srcOffset",
		"bpl",
		"buf",
		"y",
		"buf2Offset",
		"lineSize",
		"buf2",
		"out",
		"buf2",
		"buf2Offset",
		"buf2Offset",
		"System",
		"buf",
		"buf2",
		"buf2Offset",
		"lineSize",
		"buf2Offset",
		"lineSize",
		"totalSize",
		"lineSize",
		"srcOffset",
		"imageBpl",
		"buf2Offset",
		"out",
		"buf2",
		"buf2Offset",
		"SWT",
		"SWT",
		"e",
		"totalSize",
		"image",
		"image",
		"bmpBpl",
		"bpl",
		"bmpBpl",
		"linesPerBuf",
		"bmpBpl",
		"image",
		"image",
		"imageBpl",
		"image",
		"image",
		"y",
		"image",
		"y",
		"linesPerBuf",
		"image",
		"y",
		"linesPerBuf",
		"count",
		"count",
		"linesPerBuf",
		"i",
		"count",
		"i",
		"wIndex",
		"bpl",
		"wIndex",
		"buf",
		"bufOffset",
		"wIndex",
		"data",
		"dataIndex",
		"wIndex",
		"buf",
		"bufOffset",
		"wIndex",
		"data",
		"dataIndex",
		"wIndex",
		"bufOffset",
		"bmpBpl",
		"dataIndex",
		"imageBpl",
		"out",
		"buf",
		"bufOffset",
		"y",
		"image",
		"y",
		"linesPerBuf",
		"image",
		"y",
		"tmp",
		"linesPerBuf",
		"tmp",
		"linesPerBuf",
		"i",
		"count",
		"i",
		"System",
		"data",
		"dataIndex",
		"buf",
		"bufOffset",
		"bpl",
		"bufOffset",
		"bmpBpl",
		"dataIndex",
		"imageBpl",
		"out",
		"buf",
		"bufOffset",
		"SWT",
		"SWT",
		"e",
		"bmpBpl",
		"image",
		"image",
		"image",
		"image",
		"image",
		"image",
		"image",
		"SWT",
		"SWT",
		"comp",
		"comp",
		"image",
		"comp",
		"image",
		"SWT",
		"SWT",
		"image",
		"image",
		"image",
		"image",
		"pal",
		"SWT",
		"SWT",
		"numCols",
		"rgbs",
		"pal",
		"SWT",
		"SWT",
		"numCols",
		"pal",
		"rgbs",
		"pal",
		"BMPFileHeaderSize",
		"BMPHeaderFixedSize",
		"fileHeader",
		"fileHeader",
		"fileHeader",
		"fileHeader",
		"fileHeader",
		"headersSize",
		"rgbs",
		"fileHeader",
		"rgbs",
		"image",
		"out",
		"comp",
		"out",
		"fileHeader",
		"fileHeader",
		"data",
		"outputStream",
		"fileHeader",
		"outputStream",
		"fileHeader",
		"outputStream",
		"fileHeader",
		"outputStream",
		"fileHeader",
		"outputStream",
		"fileHeader",
		"SWT",
		"SWT",
		"e",
		"outputStream",
		"BMPHeaderFixedSize",
		"outputStream",
		"image",
		"outputStream",
		"image",
		"outputStream",
		"outputStream",
		"image",
		"outputStream",
		"comp",
		"outputStream",
		"data",
		"outputStream",
		"pelsPerMeter",
		"outputStream",
		"pelsPerMeter",
		"outputStream",
		"numCols",
		"outputStream",
		"importantColors",
		"SWT",
		"SWT",
		"e",
		"numCols",
		"outputStream",
		"rgbs",
		"SWT",
		"SWT",
		"e",
		"outputStream",
		"data",
		"SWT",
		"SWT",
		"e",
		"height",
		"stride",
		"i",
		"height",
		"i",
		"index",
		"stride",
		"index",
		"data",
		"index",
		"i1",
		"data",
		"index",
		"i1",
		"data",
		"index",
		"i2",
		"data",
		"index",
		"i2",
		"b",
		"i1",
		"stride",
		"i2",
		"stride",
		"ERROR_INVALID_IMAGE",
		"length",
		"length",
		"ERROR_INVALID_IMAGE",
		"length",
		"length",
		"ERROR_INVALID_IMAGE",
		"ERROR_INVALID_IMAGE",
		"ERROR_INVALID_IMAGE",
		"ERROR_IO",
		"ERROR_INVALID_IMAGE",
		"ERROR_IO",
		"ERROR_IO",
		"ERROR_INVALID_IMAGE",
		"ERROR_IO",
		"ERROR_IO",
		"compression",
		"importantColors",
		"pelsPerMeter",
		"compression",
		"compression",
		"IMAGE_BMP_RLE",
		"IMAGE_BMP",
		"length",
		"ERROR_INVALID_IMAGE",
		"ERROR_IO",
		"colors",
		"length",
		"colors",
		"length",
		"colors",
		"colors",
		"blue",
		"green",
		"red",
		"width",
		"depth",
		"bytesPerLine",
		"height",
		"data",
		"height",
		"length",
		"ERROR_IO",
		"width",
		"depth",
		"data",
		"bytesPerLine",
		"height",
		"depth",
		"height",
		"height",
		"height",
		"height",
		"ERROR_IO",
		"height",
		"depth",
		"depth",
		"depth",
		"depth",
		"depth",
		"depth",
		"ERROR_UNSUPPORTED_DEPTH",
		"compression",
		"depth",
		"depth",
		"ERROR_INVALID_IMAGE",
		"palette",
		"depth",
		"depth",
		"depth",
		"isDirect",
		"ERROR_INVALID_IMAGE",
		"isDirect",
		"ERROR_INVALID_IMAGE",
		"length",
		"colors",
		"length",
		"length",
		"ERROR_IO",
		"width",
		"height",
		"depth",
		"length",
		"x",
		"y",
		"ERROR_IO",
		"ERROR_IO",
		"ERROR_IO",
		"comp",
		"src",
		"srcOffset",
		"numBytes",
		"dest",
		"last",
		"src",
		"srcOffset",
		"numBytes",
		"dest",
		"last",
		"src",
		"srcOffset",
		"numBytes",
		"dest",
		"last",
		"src",
		"dest",
		"stride",
		"cmp",
		"src",
		"numBytes",
		"stride",
		"dest",
		"destSize",
		"src",
		"numBytes",
		"stride",
		"dest",
		"destSize",
		"stream",
		"e",
		"infoHeader",
		"infoHeader",
		"stride",
		"e",
		"e",
		"e",
		"e",
		"e",
		"infoHeader",
		"e",
		"bytes",
		"numColors",
		"pal",
		"image",
		"out",
		"comp",
		"e",
		"image",
		"out",
		"e",
		"image",
		"e",
		"e",
		"e",
		"e",
		"data",
		"stride",
		"height"
	],
	"extendORImplementFiles":[
		"FileFormat"
	],
	"package":[
		"org.eclipse.swt.internal.image"
	],
	"import":[
		"org.eclipse.swt",
		"org.eclipse.swt.graphics",
		"java.io"
	],
	"methods":[
		"compress",
		"compressRLE4Data",
		"compressRLE8Data",
		"decompressData",
		"decompressRLE4Data",
		"decompressRLE8Data",
		"isFileFormat",
		"loadData",
		"loadData",
		"loadFileHeader",
		"loadFromByteStream",
		"loadPalette",
		"paletteFromBytes",
		"paletteToBytes",
		"unloadData",
		"unloadDataNoCompression",
		"unloadIntoByteStream",
		"flipScanLines",
		"compressRLE8Data",
		"compressRLE4Data",
		"error",
		"decompressRLE8Data",
		"error",
		"decompressRLE4Data",
		"error",
		"error",
		"read",
		"unread",
		"loadData",
		"flipScanLines",
		"read",
		"error",
		"error",
		"read",
		"error",
		"error",
		"decompressData",
		"readShort",
		"readInt",
		"readShort",
		"readShort",
		"readInt",
		"error",
		"error",
		"loadFileHeader",
		"read",
		"error",
		"loadPalette",
		"getPosition",
		"skip",
		"getPosition",
		"error",
		"loadData",
		"internal_new",
		"read",
		"error",
		"error",
		"paletteFromBytes",
		"unloadDataNoCompression",
		"compress",
		"write",
		"arraycopy",
		"write",
		"error",
		"write",
		"arraycopy",
		"write",
		"error",
		"error",
		"error",
		"error",
		"error",
		"paletteToBytes",
		"unloadData",
		"toByteArray",
		"writeShort",
		"writeInt",
		"writeShort",
		"writeShort",
		"writeInt",
		"error",
		"writeInt",
		"writeInt",
		"writeInt",
		"writeShort",
		"writeShort",
		"writeInt",
		"writeInt",
		"writeInt",
		"writeInt",
		"writeInt",
		"writeInt",
		"error",
		"write",
		"error",
		"write",
		"error",
		"Point",
		"Point",
		"PaletteData",
		"PaletteData",
		"PaletteData",
		"RGB",
		"PaletteData",
		"ByteArrayOutputStream"
	],
	"methodsBody":{
		"ImageData[] loadFromByteStream()":{
			"methodBody":"{\n    int[] fileHeader = loadFileHeader();\n    byte[] infoHeader = new byte[BMPHeaderFixedSize];\n    try {\n        inputStream.read(infoHeader);\n    } catch (Exception e) {\n        SWT.error(SWT.ERROR_IO, e);\n    }\n    int width = (infoHeader[4] & 0xFF) | ((infoHeader[5] & 0xFF) << 8) | ((infoHeader[6] & 0xFF) << 16) | ((infoHeader[7] & 0xFF) << 24);\n    int height = (infoHeader[8] & 0xFF) | ((infoHeader[9] & 0xFF) << 8) | ((infoHeader[10] & 0xFF) << 16) | ((infoHeader[11] & 0xFF) << 24);\n    int bitCount = (infoHeader[14] & 0xFF) | ((infoHeader[15] & 0xFF) << 8);\n    PaletteData palette = loadPalette(infoHeader);\n    if (inputStream.getPosition() < fileHeader[4]) {\n        \n        try {\n            inputStream.skip(fileHeader[4] - inputStream.getPosition());\n        } catch (IOException e) {\n            SWT.error(SWT.ERROR_IO, e);\n        }\n    }\n    byte[] data = loadData(infoHeader);\n    this.compression = (infoHeader[16] & 0xFF) | ((infoHeader[17] & 0xFF) << 8) | ((infoHeader[18] & 0xFF) << 16) | ((infoHeader[19] & 0xFF) << 24);\n    this.importantColors = (infoHeader[36] & 0xFF) | ((infoHeader[37] & 0xFF) << 8) | ((infoHeader[38] & 0xFF) << 16) | ((infoHeader[39] & 0xFF) << 24);\n    int xPelsPerMeter = (infoHeader[24] & 0xFF) | ((infoHeader[25] & 0xFF) << 8) | ((infoHeader[26] & 0xFF) << 16) | ((infoHeader[27] & 0xFF) << 24);\n    int yPelsPerMeter = (infoHeader[28] & 0xFF) | ((infoHeader[29] & 0xFF) << 8) | ((infoHeader[30] & 0xFF) << 16) | ((infoHeader[31] & 0xFF) << 24);\n    this.pelsPerMeter = new Point(xPelsPerMeter, yPelsPerMeter);\n    int type = (this.compression == 1) || (this.compression == 2) ? SWT.IMAGE_BMP_RLE : SWT.IMAGE_BMP;\n    return new ImageData[] { ImageData.internal_new(width, height, bitCount, palette, 4, data, 0, null, null, -1, -1, type, 0, 0, 0, 0) };\n}",
			"comments":"// Seek to the specified offset\n/*BMP_RLE8_COMPRESSION*/\n/*BMP_RLE4_COMPRESSION*/\n",
			"methodName":"ImageData[] loadFromByteStream()"
		},
		"int compressRLE8Data(byte[] src, int srcOffset, int numBytes, byte[] dest, boolean last)":{
			"methodBody":"{\n    int sp = srcOffset, end = srcOffset + numBytes, dp = 0;\n    int size = 0, left, i, n;\n    byte theByte;\n    while (sp < end) {\n        \n        left = end - sp - 1;\n        if (left > 254)\n            left = 254;\n        for (n = 0; n < left; n++) {\n            if (src[sp + n] == src[sp + n + 1])\n                break;\n        }\n        \n        if (n == left)\n            n++;\n        \n        switch(n) {\n            case 0:\n                break;\n            case 2:\n                \n                dest[dp] = 1;\n                dp++;\n                dest[dp] = src[sp];\n                dp++;\n                sp++;\n                size += 2;\n            \n            case 1:\n                \n                dest[dp] = 1;\n                dp++;\n                dest[dp] = src[sp];\n                dp++;\n                sp++;\n                size += 2;\n                break;\n            default:\n                dest[dp] = 0;\n                dp++;\n                dest[dp] = (byte) n;\n                dp++;\n                for (i = n; i > 0; i--) {\n                    dest[dp] = src[sp];\n                    dp++;\n                    sp++;\n                }\n                size += 2 + n;\n                if ((n & 1) != 0) {\n                    \n                    dest[dp] = 0;\n                    dp++;\n                    size++;\n                }\n                break;\n        }\n        \n        left = end - sp;\n        if (left > 0) {\n            if (left > 255)\n                left = 255;\n            theByte = src[sp];\n            for (n = 1; n < left; n++) {\n                if (src[sp + n] != theByte)\n                    break;\n            }\n            dest[dp] = (byte) n;\n            dp++;\n            dest[dp] = theByte;\n            dp++;\n            sp += n;\n            size += 2;\n        }\n    }\n    \n    dest[dp] = 0;\n    dp++;\n    if (last) {\n        dest[dp] = 1;\n        dp++;\n    } else {\n        dest[dp] = 0;\n        dp++;\n    }\n    size += 2;\n    return size;\n}",
			"comments":"/* find two consecutive bytes that are the same in the next 256 */\n/* if there is only one more byte in the scan line, include it */\n/* store the intervening data */\n/* handled separately because 0,2 is a command */\n/* don't break, fall through */\n/* handled separately because 0,1 is a command */\n/* pad to word */\n/* find the length of the next run (up to 255) and store it */\n/* store the end of line or end of bitmap codes */\n",
			"methodName":"int compressRLE8Data(byte[] src, int srcOffset, int numBytes, byte[] dest, boolean last)"
		},
		"PaletteData paletteFromBytes(byte[] bytes, int numColors)":{
			"methodBody":"{\n    int bytesOffset = 0;\n    RGB[] colors = new RGB[numColors];\n    for (int i = 0; i < numColors; i++) {\n        colors[i] = new RGB(bytes[bytesOffset + 2] & 0xFF, bytes[bytesOffset + 1] & 0xFF, bytes[bytesOffset] & 0xFF);\n        bytesOffset += 4;\n    }\n    return new PaletteData(colors);\n}",
			"comments":"",
			"methodName":"PaletteData paletteFromBytes(byte[] bytes, int numColors)"
		},
		"void decompressData(byte[] src, byte[] dest, int stride, int cmp)":{
			"methodBody":"{\n    if (cmp == 1) {\n        \n        if (decompressRLE8Data(src, src.length, stride, dest, dest.length) <= 0)\n            SWT.error(SWT.ERROR_INVALID_IMAGE);\n        return;\n    }\n    if (cmp == 2) {\n        \n        if (decompressRLE4Data(src, src.length, stride, dest, dest.length) <= 0)\n            SWT.error(SWT.ERROR_INVALID_IMAGE);\n        return;\n    }\n    SWT.error(SWT.ERROR_INVALID_IMAGE);\n}",
			"comments":"// BMP_RLE8_COMPRESSION\n// BMP_RLE4_COMPRESSION\n",
			"methodName":"void decompressData(byte[] src, byte[] dest, int stride, int cmp)"
		},
		"byte[] loadData(byte[] infoHeader, int stride)":{
			"methodBody":"{\n    int height = (infoHeader[8] & 0xFF) | ((infoHeader[9] & 0xFF) << 8) | ((infoHeader[10] & 0xFF) << 16) | ((infoHeader[11] & 0xFF) << 24);\n    int dataSize = height * stride;\n    byte[] data = new byte[dataSize];\n    int cmp = (infoHeader[16] & 0xFF) | ((infoHeader[17] & 0xFF) << 8) | ((infoHeader[18] & 0xFF) << 16) | ((infoHeader[19] & 0xFF) << 24);\n    if (cmp == 0) {\n        \n        try {\n            if (inputStream.read(data) != dataSize)\n                SWT.error(SWT.ERROR_INVALID_IMAGE);\n        } catch (IOException e) {\n            SWT.error(SWT.ERROR_IO, e);\n        }\n    } else {\n        int compressedSize = (infoHeader[20] & 0xFF) | ((infoHeader[21] & 0xFF) << 8) | ((infoHeader[22] & 0xFF) << 16) | ((infoHeader[23] & 0xFF) << 24);\n        byte[] compressed = new byte[compressedSize];\n        try {\n            if (inputStream.read(compressed) != compressedSize)\n                SWT.error(SWT.ERROR_INVALID_IMAGE);\n        } catch (IOException e) {\n            SWT.error(SWT.ERROR_IO, e);\n        }\n        decompressData(compressed, data, stride, cmp);\n    }\n    return data;\n}",
			"comments":"// BMP_NO_COMPRESSION\n",
			"methodName":"byte[] loadData(byte[] infoHeader, int stride)"
		},
		"int[] loadFileHeader()":{
			"methodBody":"{\n    int[] header = new int[5];\n    try {\n        header[0] = inputStream.readShort();\n        header[1] = inputStream.readInt();\n        header[2] = inputStream.readShort();\n        header[3] = inputStream.readShort();\n        header[4] = inputStream.readInt();\n    } catch (IOException e) {\n        SWT.error(SWT.ERROR_IO, e);\n    }\n    if (header[0] != 0x4D42)\n        SWT.error(SWT.ERROR_INVALID_IMAGE);\n    return header;\n}",
			"comments":"",
			"methodName":"int[] loadFileHeader()"
		},
		"void flipScanLines(byte[] data, int stride, int height)":{
			"methodBody":"{\n    int i1 = 0;\n    int i2 = (height - 1) * stride;\n    for (int i = 0; i < height / 2; i++) {\n        for (int index = 0; index < stride; index++) {\n            byte b = data[index + i1];\n            data[index + i1] = data[index + i2];\n            data[index + i2] = b;\n        }\n        i1 += stride;\n        i2 -= stride;\n    }\n}",
			"comments":"",
			"methodName":"void flipScanLines(byte[] data, int stride, int height)"
		},
		"static byte[] paletteToBytes(PaletteData pal)":{
			"methodBody":"{\n    int n = pal.colors == null ? 0 : (pal.colors.length < 256 ? pal.colors.length : 256);\n    byte[] bytes = new byte[n * 4];\n    int offset = 0;\n    for (int i = 0; i < n; i++) {\n        RGB col = pal.colors[i];\n        bytes[offset] = (byte) col.blue;\n        bytes[offset + 1] = (byte) col.green;\n        bytes[offset + 2] = (byte) col.red;\n        offset += 4;\n    }\n    return bytes;\n}",
			"comments":"/**\n* Answer a byte array containing the BMP representation of\n* the given device independent palette.\n*/\n",
			"methodName":"static byte[] paletteToBytes(PaletteData pal)"
		},
		"int unloadDataNoCompression(ImageData image, OutputStream out)":{
			"methodBody":"{\n    int bmpBpl = 0;\n    try {\n        int bpl = (image.width * image.depth + 7) / 8;\n        \n        bmpBpl = (bpl + 3) / 4 * 4;\n        int linesPerBuf = 32678 / bmpBpl;\n        byte[] buf = new byte[linesPerBuf * bmpBpl];\n        byte[] data = image.data;\n        int imageBpl = image.bytesPerLine;\n        \n        int dataIndex = imageBpl * (image.height - 1);\n        if (image.depth == 16) {\n            for (int y = 0; y < image.height; y += linesPerBuf) {\n                int count = image.height - y;\n                if (linesPerBuf < count)\n                    count = linesPerBuf;\n                int bufOffset = 0;\n                for (int i = 0; i < count; i++) {\n                    for (int wIndex = 0; wIndex < bpl; wIndex += 2) {\n                        buf[bufOffset + wIndex + 1] = data[dataIndex + wIndex + 1];\n                        buf[bufOffset + wIndex] = data[dataIndex + wIndex];\n                    }\n                    bufOffset += bmpBpl;\n                    dataIndex -= imageBpl;\n                }\n                out.write(buf, 0, bufOffset);\n            }\n        } else {\n            for (int y = 0; y < image.height; y += linesPerBuf) {\n                int tmp = image.height - y;\n                int count = tmp < linesPerBuf ? tmp : linesPerBuf;\n                int bufOffset = 0;\n                for (int i = 0; i < count; i++) {\n                    System.arraycopy(data, dataIndex, buf, bufOffset, bpl);\n                    bufOffset += bmpBpl;\n                    dataIndex -= imageBpl;\n                }\n                out.write(buf, 0, bufOffset);\n            }\n        }\n    } catch (IOException e) {\n        SWT.error(SWT.ERROR_IO, e);\n    }\n    return bmpBpl * image.height;\n}",
			"comments":"/**\n* Prepare the given image's data for unloading into a byte stream\n* using no compression strategy.\n* Answer the number of bytes written.\n*/\n// BMP pads scanlines to multiples of 4 bytes\n// Start at last line\n",
			"methodName":"int unloadDataNoCompression(ImageData image, OutputStream out)"
		},
		"int compressRLE4Data(byte[] src, int srcOffset, int numBytes, byte[] dest, boolean last)":{
			"methodBody":"{\n    int sp = srcOffset, end = srcOffset + numBytes, dp = 0;\n    int size = 0, left, i, n;\n    byte theByte;\n    while (sp < end) {\n        \n        left = end - sp - 1;\n        if (left > 127)\n            left = 127;\n        for (n = 0; n < left; n++) {\n            if (src[sp + n] == src[sp + n + 1])\n                break;\n        }\n        \n        if (n < 127 && n == left)\n            n++;\n        \n        switch(n) {\n            case 0:\n                break;\n            case 1:\n                \n                dest[dp] = 2;\n                dp++;\n                \n                dest[dp] = src[sp];\n                dp++;\n                sp++;\n                size += 2;\n                break;\n            default:\n                dest[dp] = 0;\n                dp++;\n                dest[dp] = (byte) (n + n);\n                dp++;\n                \n                for (i = n; i > 0; i--) {\n                    dest[dp] = src[sp];\n                    dp++;\n                    sp++;\n                }\n                size += 2 + n;\n                if ((n & 1) != 0) {\n                    \n                    dest[dp] = 0;\n                    dp++;\n                    size++;\n                }\n                break;\n        }\n        \n        left = end - sp;\n        if (left > 0) {\n            if (left > 127)\n                left = 127;\n            theByte = src[sp];\n            for (n = 1; n < left; n++) {\n                if (src[sp + n] != theByte)\n                    break;\n            }\n            dest[dp] = (byte) (n + n);\n            dp++;\n            \n            dest[dp] = theByte;\n            dp++;\n            sp += n;\n            size += 2;\n        }\n    }\n    \n    dest[dp] = 0;\n    dp++;\n    if (last) {\n        dest[dp] = 1;\n        dp++;\n    } else {\n        dest[dp] = 0;\n        dp++;\n    }\n    size += 2;\n    return size;\n}",
			"comments":"/* find two consecutive bytes that are the same in the next 128 */\n/* if there is only one more byte in the scan line, include it */\n/* store the intervening data */\n/* handled separately because 0,2 is a command */\n/* 1 byte == 2 pixels */\n/* n bytes = n*2 pixels */\n/* pad to word */\n/* find the length of the next run (up to 127) and store it */\n/* n bytes = n*2 pixels */\n/* store the end of line or end of bitmap codes */\n",
			"methodName":"int compressRLE4Data(byte[] src, int srcOffset, int numBytes, byte[] dest, boolean last)"
		},
		"int decompressRLE4Data(byte[] src, int numBytes, int stride, byte[] dest, int destSize)":{
			"methodBody":"{\n    int sp = 0;\n    int se = numBytes;\n    int dp = 0;\n    int de = destSize;\n    int x = 0, y = 0;\n    while (sp < se) {\n        int len = src[sp] & 0xFF;\n        sp++;\n        if (len == 0) {\n            len = src[sp] & 0xFF;\n            sp++;\n            switch(len) {\n                case 0:\n                    \n                    y++;\n                    x = 0;\n                    dp = y * stride;\n                    if (dp >= de)\n                        return -1;\n                    break;\n                case 1:\n                    \n                    return 1;\n                case 2:\n                    \n                    x += src[sp] & 0xFF;\n                    sp++;\n                    y += src[sp] & 0xFF;\n                    sp++;\n                    dp = y * stride + x / 2;\n                    if (dp >= de)\n                        return -1;\n                    break;\n                default:\n                    \n                    if ((len & 1) != 0)\n                        \n                        return -1;\n                    x += len;\n                    len = len / 2;\n                    if (len > (se - sp))\n                        return -1;\n                    if (len > (de - dp))\n                        return -1;\n                    for (int i = 0; i < len; i++) {\n                        dest[dp] = src[sp];\n                        dp++;\n                        sp++;\n                    }\n                    if ((sp & 1) != 0)\n                        sp++;\n                    \n                    break;\n            }\n        } else {\n            if ((len & 1) != 0)\n                return -1;\n            x += len;\n            len = len / 2;\n            byte theByte = src[sp];\n            sp++;\n            if (len > (de - dp))\n                return -1;\n            for (int i = 0; i < len; i++) {\n                dest[dp] = theByte;\n                dp++;\n            }\n        }\n    }\n    return 1;\n}",
			"comments":"/* end of line */\n/* end of bitmap */\n/* delta */\n/* absolute mode run */\n/* odd run lengths not currently supported */\n/* word align sp? */\n",
			"methodName":"int decompressRLE4Data(byte[] src, int numBytes, int stride, byte[] dest, int destSize)"
		},
		"boolean isFileFormat(LEDataInputStream stream)":{
			"methodBody":"{\n    try {\n        byte[] header = new byte[18];\n        stream.read(header);\n        stream.unread(header);\n        int infoHeaderSize = (header[14] & 0xFF) | ((header[15] & 0xFF) << 8) | ((header[16] & 0xFF) << 16) | ((header[17] & 0xFF) << 24);\n        return header[0] == 0x42 && header[1] == 0x4D && infoHeaderSize >= BMPHeaderFixedSize;\n    } catch (Exception e) {\n        return false;\n    }\n}",
			"comments":"",
			"methodName":"boolean isFileFormat(LEDataInputStream stream)"
		},
		"int decompressRLE8Data(byte[] src, int numBytes, int stride, byte[] dest, int destSize)":{
			"methodBody":"{\n    int sp = 0;\n    int se = numBytes;\n    int dp = 0;\n    int de = destSize;\n    int x = 0, y = 0;\n    while (sp < se) {\n        int len = src[sp] & 0xFF;\n        sp++;\n        if (len == 0) {\n            len = src[sp] & 0xFF;\n            sp++;\n            switch(len) {\n                case 0:\n                    \n                    y++;\n                    x = 0;\n                    dp = y * stride;\n                    if (dp >= de)\n                        return -1;\n                    break;\n                case 1:\n                    \n                    return 1;\n                case 2:\n                    \n                    x += src[sp] & 0xFF;\n                    sp++;\n                    y += src[sp] & 0xFF;\n                    sp++;\n                    dp = y * stride + x;\n                    if (dp >= de)\n                        return -1;\n                    break;\n                default:\n                    \n                    if (len > (se - sp))\n                        return -1;\n                    if (len > (de - dp))\n                        return -1;\n                    for (int i = 0; i < len; i++) {\n                        dest[dp] = src[sp];\n                        dp++;\n                        sp++;\n                    }\n                    if ((sp & 1) != 0)\n                        sp++;\n                    \n                    x += len;\n                    break;\n            }\n        } else {\n            byte theByte = src[sp];\n            sp++;\n            if (len > (de - dp))\n                return -1;\n            for (int i = 0; i < len; i++) {\n                dest[dp] = theByte;\n                dp++;\n            }\n            x += len;\n        }\n    }\n    return 1;\n}",
			"comments":"/* end of line */\n/* end of bitmap */\n/* delta */\n/* absolute mode run */\n/* word align sp? */\n",
			"methodName":"int decompressRLE8Data(byte[] src, int numBytes, int stride, byte[] dest, int destSize)"
		},
		"void unloadIntoByteStream(ImageData image)":{
			"methodBody":"{\n    byte[] rgbs;\n    int numCols;\n    if (!((image.depth == 1) || (image.depth == 4) || (image.depth == 8) || (image.depth == 16) || (image.depth == 24) || (image.depth == 32)))\n        SWT.error(SWT.ERROR_UNSUPPORTED_DEPTH);\n    int comp = this.compression;\n    if (!((comp == 0) || ((comp == 1) && (image.depth == 8)) || ((comp == 2) && (image.depth == 4))))\n        SWT.error(SWT.ERROR_INVALID_IMAGE);\n    PaletteData pal = image.palette;\n    if ((image.depth == 16) || (image.depth == 24) || (image.depth == 32)) {\n        if (!pal.isDirect)\n            SWT.error(SWT.ERROR_INVALID_IMAGE);\n        numCols = 0;\n        rgbs = null;\n    } else {\n        if (pal.isDirect)\n            SWT.error(SWT.ERROR_INVALID_IMAGE);\n        numCols = pal.colors.length;\n        rgbs = paletteToBytes(pal);\n    }\n    \n    int headersSize = BMPFileHeaderSize + BMPHeaderFixedSize;\n    int[] fileHeader = new int[5];\n    \n    fileHeader[0] = 0x4D42;\n    \n    fileHeader[1] = 0;\n    \n    fileHeader[2] = 0;\n    \n    fileHeader[3] = 0;\n    \n    fileHeader[4] = headersSize;\n    if (rgbs != null) {\n        fileHeader[4] += rgbs.length;\n    }\n    \n    \n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n    unloadData(image, out, comp);\n    byte[] data = out.toByteArray();\n    \n    fileHeader[1] = fileHeader[4] + data.length;\n    \n    try {\n        outputStream.writeShort(fileHeader[0]);\n        outputStream.writeInt(fileHeader[1]);\n        outputStream.writeShort(fileHeader[2]);\n        outputStream.writeShort(fileHeader[3]);\n        outputStream.writeInt(fileHeader[4]);\n    } catch (IOException e) {\n        SWT.error(SWT.ERROR_IO, e);\n    }\n    try {\n        outputStream.writeInt(BMPHeaderFixedSize);\n        outputStream.writeInt(image.width);\n        outputStream.writeInt(image.height);\n        outputStream.writeShort(1);\n        outputStream.writeShort((short) image.depth);\n        outputStream.writeInt(comp);\n        outputStream.writeInt(data.length);\n        outputStream.writeInt(pelsPerMeter.x);\n        outputStream.writeInt(pelsPerMeter.y);\n        outputStream.writeInt(numCols);\n        outputStream.writeInt(importantColors);\n    } catch (IOException e) {\n        SWT.error(SWT.ERROR_IO, e);\n    }\n    \n    if (numCols > 0) {\n        try {\n            outputStream.write(rgbs);\n        } catch (IOException e) {\n            SWT.error(SWT.ERROR_IO, e);\n        }\n    }\n    \n    try {\n        outputStream.write(data);\n    } catch (IOException e) {\n        SWT.error(SWT.ERROR_IO, e);\n    }\n}",
			"comments":"/**\n* Unload a DeviceIndependentImage using Windows .BMP format into the given\n* byte stream.\n*/\n// Fill in file header, except for bfsize, which is done later.\n// Signature\n// File size - filled in later\n// Reserved 1\n// Reserved 2\n// Offset to data\n// Prepare data. This is done first so we don't have to try to rewind\n// the stream and fill in the details later.\n// Calculate file size\n// Write the headers\n// Unload palette\n// Unload the data\n",
			"methodName":"void unloadIntoByteStream(ImageData image)"
		},
		"PaletteData loadPalette(byte[] infoHeader)":{
			"methodBody":"{\n    int depth = (infoHeader[14] & 0xFF) | ((infoHeader[15] & 0xFF) << 8);\n    if (depth <= 8) {\n        int numColors = (infoHeader[32] & 0xFF) | ((infoHeader[33] & 0xFF) << 8) | ((infoHeader[34] & 0xFF) << 16) | ((infoHeader[35] & 0xFF) << 24);\n        if (numColors == 0) {\n            numColors = 1 << depth;\n        } else {\n            if (numColors > 256)\n                numColors = 256;\n        }\n        byte[] buf = new byte[numColors * 4];\n        try {\n            if (inputStream.read(buf) != buf.length)\n                SWT.error(SWT.ERROR_INVALID_IMAGE);\n        } catch (IOException e) {\n            SWT.error(SWT.ERROR_IO, e);\n        }\n        return paletteFromBytes(buf, numColors);\n    }\n    if (depth == 16)\n        return new PaletteData(0x7C00, 0x3E0, 0x1F);\n    if (depth == 24)\n        return new PaletteData(0xFF, 0xFF00, 0xFF0000);\n    return new PaletteData(0xFF00, 0xFF0000, 0xFF000000);\n}",
			"comments":"",
			"methodName":"PaletteData loadPalette(byte[] infoHeader)"
		},
		"byte[] loadData(byte[] infoHeader)":{
			"methodBody":"{\n    int width = (infoHeader[4] & 0xFF) | ((infoHeader[5] & 0xFF) << 8) | ((infoHeader[6] & 0xFF) << 16) | ((infoHeader[7] & 0xFF) << 24);\n    int height = (infoHeader[8] & 0xFF) | ((infoHeader[9] & 0xFF) << 8) | ((infoHeader[10] & 0xFF) << 16) | ((infoHeader[11] & 0xFF) << 24);\n    int bitCount = (infoHeader[14] & 0xFF) | ((infoHeader[15] & 0xFF) << 8);\n    int stride = (width * bitCount + 7) / 8;\n    \n    stride = (stride + 3) / 4 * 4;\n    byte[] data = loadData(infoHeader, stride);\n    flipScanLines(data, stride, height);\n    return data;\n}",
			"comments":"// Round up to 4 byte multiple\n",
			"methodName":"byte[] loadData(byte[] infoHeader)"
		},
		"int compress(int comp, byte[] src, int srcOffset, int numBytes, byte[] dest, boolean last)":{
			"methodBody":"{\n    if (comp == 1) {\n        \n        return compressRLE8Data(src, srcOffset, numBytes, dest, last);\n    }\n    if (comp == 2) {\n        \n        return compressRLE4Data(src, srcOffset, numBytes, dest, last);\n    }\n    SWT.error(SWT.ERROR_INVALID_IMAGE);\n    return 0;\n}",
			"comments":"/**\n* Compress numBytes bytes of image data from src, storing in dest\n* (starting at 0), using the technique specified by comp.\n* If last is true, this indicates the last line of the image.\n* Answer the size of the compressed data.\n*/\n// BMP_RLE8_COMPRESSION\n// BMP_RLE4_COMPRESSION\n",
			"methodName":"int compress(int comp, byte[] src, int srcOffset, int numBytes, byte[] dest, boolean last)"
		},
		"int unloadData(ImageData image, OutputStream out, int comp)":{
			"methodBody":"{\n    int totalSize = 0;\n    try {\n        if (comp == 0)\n            return unloadDataNoCompression(image, out);\n        int bpl = (image.width * image.depth + 7) / 8;\n        \n        int bmpBpl = (bpl + 3) / 4 * 4;\n        int imageBpl = image.bytesPerLine;\n        \n        byte[] buf = new byte[bmpBpl * 2];\n        \n        int srcOffset = imageBpl * (image.height - 1);\n        byte[] data = image.data;\n        totalSize = 0;\n        byte[] buf2 = new byte[32768];\n        int buf2Offset = 0;\n        for (int y = image.height - 1; y >= 0; y--) {\n            int lineSize = compress(comp, data, srcOffset, bpl, buf, y == 0);\n            if (buf2Offset + lineSize > buf2.length) {\n                out.write(buf2, 0, buf2Offset);\n                buf2Offset = 0;\n            }\n            System.arraycopy(buf, 0, buf2, buf2Offset, lineSize);\n            buf2Offset += lineSize;\n            totalSize += lineSize;\n            srcOffset -= imageBpl;\n        }\n        if (buf2Offset > 0)\n            out.write(buf2, 0, buf2Offset);\n    } catch (IOException e) {\n        SWT.error(SWT.ERROR_IO, e);\n    }\n    return totalSize;\n}",
			"comments":"/**\n* Unload the given image's data into the given byte stream\n* using the given compression strategy.\n* Answer the number of bytes written.\n*/\n// BMP pads scanlines to multiples of 4 bytes\n// Compression can actually take twice as much space, in worst case\n// Start at last line\n",
			"methodName":"int unloadData(ImageData image, OutputStream out, int comp)"
		}
	},
	"ClassORInterfaceName":[
		"WinBMPFileFormat"
	]
}
