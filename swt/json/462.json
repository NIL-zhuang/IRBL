{
	"variables":[
		"parent",
		"increment",
		"pageIncrement",
		"typedListener",
		"hwnd",
		"type",
		"info",
		"rect",
		"x",
		"y",
		"width",
		"height",
		"info",
		"hwnd",
		"type",
		"info",
		"hwnd",
		"type",
		"info",
		"hwnd",
		"type",
		"rect",
		"width",
		"height",
		"info",
		"hwnd",
		"type",
		"hwnd",
		"type",
		"flags",
		"info",
		"hwnd",
		"type",
		"info",
		"hwnd",
		"type",
		"result",
		"bar",
		"both",
		"info",
		"hwnd",
		"type",
		"info",
		"hwnd",
		"type",
		"info",
		"hwnd",
		"type",
		"isVisible",
		"info",
		"hwnd",
		"type",
		"max",
		"hwnd",
		"type",
		"info",
		"code",
		"event",
		"parent",
		"style",
		"parent",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"SWT",
		"typedListener",
		"style",
		"SWT",
		"SWT",
		"increment",
		"pageIncrement",
		"SWT",
		"OS",
		"info",
		"SCROLLINFO",
		"info",
		"OS",
		"OS",
		"info",
		"info",
		"info",
		"OS",
		"hwnd",
		"type",
		"info",
		"OS",
		"hwnd",
		"type",
		"parent",
		"OS",
		"parent",
		"rect",
		"style",
		"SWT",
		"y",
		"rect",
		"rect",
		"width",
		"rect",
		"rect",
		"height",
		"OS",
		"OS",
		"x",
		"rect",
		"rect",
		"width",
		"OS",
		"OS",
		"height",
		"rect",
		"rect",
		"x",
		"y",
		"width",
		"height",
		"state",
		"DISABLED",
		"increment",
		"info",
		"SCROLLINFO",
		"info",
		"OS",
		"OS",
		"hwnd",
		"type",
		"info",
		"info",
		"info",
		"SCROLLINFO",
		"info",
		"OS",
		"OS",
		"hwnd",
		"type",
		"info",
		"info",
		"pageIncrement",
		"parent",
		"info",
		"SCROLLINFO",
		"info",
		"OS",
		"OS",
		"hwnd",
		"type",
		"info",
		"info",
		"parent",
		"OS",
		"parent",
		"rect",
		"style",
		"SWT",
		"width",
		"rect",
		"rect",
		"height",
		"OS",
		"OS",
		"width",
		"OS",
		"OS",
		"height",
		"rect",
		"rect",
		"width",
		"height",
		"info",
		"SCROLLINFO",
		"info",
		"OS",
		"OS",
		"hwnd",
		"type",
		"info",
		"info",
		"info",
		"info",
		"state",
		"HIDDEN",
		"parent",
		"parent",
		"parent",
		"parent",
		"parent",
		"parent",
		"parent",
		"parent",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"eventTable",
		"SWT",
		"listener",
		"style",
		"SWT",
		"OS",
		"OS",
		"OS",
		"enabled",
		"OS",
		"OS",
		"OS",
		"hwnd",
		"type",
		"flags",
		"enabled",
		"state",
		"DISABLED",
		"state",
		"DISABLED",
		"value",
		"increment",
		"value",
		"value",
		"info",
		"SCROLLINFO",
		"info",
		"OS",
		"OS",
		"OS",
		"hwnd",
		"type",
		"info",
		"value",
		"info",
		"info",
		"info",
		"value",
		"hwnd",
		"type",
		"info",
		"value",
		"info",
		"SCROLLINFO",
		"info",
		"OS",
		"OS",
		"OS",
		"hwnd",
		"type",
		"info",
		"info",
		"value",
		"info",
		"info",
		"value",
		"hwnd",
		"type",
		"info",
		"value",
		"pageIncrement",
		"value",
		"state",
		"DISABLED",
		"HIDDEN",
		"fRedraw",
		"OS",
		"hwnd",
		"flags",
		"info",
		"fRedraw",
		"state",
		"HIDDEN",
		"OS",
		"flags",
		"OS",
		"bar",
		"parent",
		"OS",
		"bar",
		"parent",
		"bar",
		"bar",
		"OS",
		"hwnd",
		"both",
		"OS",
		"flags",
		"state",
		"DISABLED",
		"OS",
		"OS",
		"hwnd",
		"flags",
		"OS",
		"result",
		"info",
		"SCROLLINFO",
		"info",
		"OS",
		"info",
		"selection",
		"hwnd",
		"type",
		"info",
		"value",
		"info",
		"SCROLLINFO",
		"info",
		"OS",
		"OS",
		"OS",
		"OS",
		"hwnd",
		"type",
		"info",
		"info",
		"value",
		"info",
		"info",
		"hwnd",
		"type",
		"info",
		"minimum",
		"maximum",
		"thumb",
		"increment",
		"pageIncrement",
		"increment",
		"pageIncrement",
		"info",
		"SCROLLINFO",
		"info",
		"OS",
		"OS",
		"OS",
		"OS",
		"info",
		"selection",
		"info",
		"minimum",
		"info",
		"maximum",
		"info",
		"thumb",
		"info",
		"info",
		"hwnd",
		"type",
		"info",
		"state",
		"HIDDEN",
		"isVisible",
		"visible",
		"OS",
		"info",
		"SCROLLINFO",
		"info",
		"OS",
		"OS",
		"visible",
		"info",
		"OS",
		"OS",
		"hwnd",
		"type",
		"info",
		"info",
		"info",
		"info",
		"info",
		"info",
		"OS",
		"hwnd",
		"type",
		"info",
		"info",
		"max",
		"OS",
		"hwnd",
		"type",
		"info",
		"state",
		"visible",
		"state",
		"HIDDEN",
		"state",
		"HIDDEN",
		"OS",
		"hwnd",
		"type",
		"visible",
		"state",
		"DISABLED",
		"info",
		"SCROLLINFO",
		"info",
		"OS",
		"OS",
		"OS",
		"hwnd",
		"type",
		"info",
		"info",
		"info",
		"info",
		"OS",
		"hwnd",
		"type",
		"OS",
		"visible",
		"SWT",
		"SWT",
		"wParam",
		"code",
		"OS",
		"code",
		"OS",
		"event",
		"SWT",
		"OS",
		"event",
		"SWT",
		"OS",
		"event",
		"SWT",
		"OS",
		"event",
		"SWT",
		"OS",
		"event",
		"SWT",
		"OS",
		"event",
		"SWT",
		"OS",
		"event",
		"SWT",
		"OS",
		"event",
		"SWT",
		"SWT",
		"event",
		"parent",
		"ERROR_NULL_ARGUMENT",
		"Selection",
		"DefaultSelection",
		"HORIZONTAL",
		"VERTICAL",
		"ERROR_THREAD_INVALID_ACCESS",
		"IsWinCE",
		"cbSize",
		"sizeof",
		"fMask",
		"SIF_RANGE",
		"SIF_PAGE",
		"nPage",
		"nMax",
		"nMin",
		"HORIZONTAL",
		"bottom",
		"top",
		"right",
		"left",
		"SM_CYHSCROLL",
		"right",
		"left",
		"SM_CXVSCROLL",
		"bottom",
		"top",
		"cbSize",
		"sizeof",
		"fMask",
		"SIF_RANGE",
		"nMax",
		"cbSize",
		"sizeof",
		"fMask",
		"SIF_RANGE",
		"nMin",
		"cbSize",
		"sizeof",
		"fMask",
		"SIF_POS",
		"nPos",
		"HORIZONTAL",
		"right",
		"left",
		"SM_CYHSCROLL",
		"SM_CXVSCROLL",
		"bottom",
		"top",
		"cbSize",
		"sizeof",
		"fMask",
		"SIF_PAGE",
		"nPage",
		"nPage",
		"nPage",
		"horizontalBar",
		"horizontalBar",
		"verticalBar",
		"verticalBar",
		"ERROR_NULL_ARGUMENT",
		"Selection",
		"DefaultSelection",
		"VERTICAL",
		"SB_VERT",
		"SB_HORZ",
		"IsWinCE",
		"ESB_ENABLE_BOTH",
		"ESB_DISABLE_BOTH",
		"cbSize",
		"sizeof",
		"fMask",
		"SIF_RANGE",
		"SIF_DISABLENOSCROLL",
		"nMin",
		"nPage",
		"nMax",
		"cbSize",
		"sizeof",
		"fMask",
		"SIF_RANGE",
		"SIF_DISABLENOSCROLL",
		"nMax",
		"nPage",
		"nMin",
		"IsWinCE",
		"SB_HORZ",
		"SB_VERT",
		"SB_BOTH",
		"IsWinCE",
		"ESB_DISABLE_BOTH",
		"cbSize",
		"sizeof",
		"fMask",
		"SIF_POS",
		"nPos",
		"cbSize",
		"sizeof",
		"fMask",
		"SIF_PAGE",
		"SIF_RANGE",
		"SIF_DISABLENOSCROLL",
		"nPage",
		"nPage",
		"nPage",
		"increment",
		"pageIncrement",
		"cbSize",
		"sizeof",
		"fMask",
		"SIF_POS",
		"SIF_PAGE",
		"SIF_RANGE",
		"SIF_DISABLENOSCROLL",
		"nPos",
		"nMin",
		"nMax",
		"nPage",
		"nPage",
		"nPage",
		"IsWinCE",
		"cbSize",
		"sizeof",
		"fMask",
		"SIF_RANGE",
		"SIF_PAGE",
		"fMask",
		"SIF_DISABLENOSCROLL",
		"nPage",
		"nMax",
		"nMin",
		"nMax",
		"nMax",
		"nMax",
		"cbSize",
		"sizeof",
		"fMask",
		"SIF_RANGE",
		"SIF_PAGE",
		"nMax",
		"nMin",
		"nPage",
		"ESB_ENABLE_BOTH",
		"Show",
		"Hide",
		"SB_ENDSCROLL",
		"SB_THUMBPOSITION",
		"detail",
		"NONE",
		"SB_THUMBTRACK",
		"detail",
		"DRAG",
		"SB_TOP",
		"detail",
		"HOME",
		"SB_BOTTOM",
		"detail",
		"END",
		"SB_LINEDOWN",
		"detail",
		"ARROW_DOWN",
		"SB_LINEUP",
		"detail",
		"ARROW_UP",
		"SB_PAGEDOWN",
		"detail",
		"PAGE_DOWN",
		"SB_PAGEUP",
		"detail",
		"PAGE_UP",
		"Selection",
		"parent",
		"style",
		"listener",
		"style",
		"listener",
		"enabled",
		"value",
		"value",
		"value",
		"value",
		"hwnd",
		"flags",
		"info",
		"fRedraw",
		"selection",
		"value",
		"selection",
		"minimum",
		"maximum",
		"thumb",
		"increment",
		"pageIncrement",
		"visible",
		"wParam",
		"lParam"
	],
	"extendORImplementFiles":[
		"Widget"
	],
	"package":[
		"org.eclipse.swt.widgets"
	],
	"import":[
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt",
		"org.eclipse.swt.graphics",
		"org.eclipse.swt.events"
	],
	"methods":[
		"addSelectionListener",
		"checkStyle",
		"createWidget",
		"dispose",
		"getBounds",
		"getEnabled",
		"getIncrement",
		"getMaximum",
		"getMinimum",
		"getPageIncrement",
		"getParent",
		"getSelection",
		"getSize",
		"getThumb",
		"getVisible",
		"hwndScrollBar",
		"isEnabled",
		"isVisible",
		"releaseChild",
		"releaseWidget",
		"removeSelectionListener",
		"scrollBarType",
		"setEnabled",
		"setIncrement",
		"setMaximum",
		"setMinimum",
		"setPageIncrement",
		"SetScrollInfo",
		"setSelection",
		"setThumb",
		"setValues",
		"setVisible",
		"wmScrollChild",
		"checkStyle",
		"createWidget",
		"checkWidget",
		"error",
		"addListener",
		"addListener",
		"checkBits",
		"isDisposed",
		"isValidThread",
		"error",
		"hwndScrollBar",
		"scrollBarType",
		"dispose",
		"SetScrollInfo",
		"ShowScrollBar",
		"forceResize",
		"GetClientRect",
		"scrolledHandle",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"checkWidget",
		"checkWidget",
		"checkWidget",
		"hwndScrollBar",
		"scrollBarType",
		"GetScrollInfo",
		"checkWidget",
		"hwndScrollBar",
		"scrollBarType",
		"GetScrollInfo",
		"checkWidget",
		"checkWidget",
		"checkWidget",
		"hwndScrollBar",
		"scrollBarType",
		"GetScrollInfo",
		"checkWidget",
		"forceResize",
		"GetClientRect",
		"scrolledHandle",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"checkWidget",
		"hwndScrollBar",
		"scrollBarType",
		"GetScrollInfo",
		"checkWidget",
		"scrolledHandle",
		"checkWidget",
		"getEnabled",
		"isEnabled",
		"checkWidget",
		"getVisible",
		"isVisible",
		"releaseChild",
		"releaseWidget",
		"checkWidget",
		"error",
		"unhook",
		"unhook",
		"checkWidget",
		"hwndScrollBar",
		"scrollBarType",
		"EnableScrollBar",
		"checkWidget",
		"checkWidget",
		"hwndScrollBar",
		"scrollBarType",
		"GetScrollInfo",
		"SetScrollInfo",
		"checkWidget",
		"hwndScrollBar",
		"scrollBarType",
		"GetScrollInfo",
		"SetScrollInfo",
		"checkWidget",
		"SetScrollInfo",
		"getVerticalBar",
		"getHorizontalBar",
		"getVisible",
		"ShowScrollBar",
		"EnableScrollBar",
		"checkWidget",
		"hwndScrollBar",
		"scrollBarType",
		"SetScrollInfo",
		"checkWidget",
		"hwndScrollBar",
		"scrollBarType",
		"GetScrollInfo",
		"SetScrollInfo",
		"checkWidget",
		"hwndScrollBar",
		"scrollBarType",
		"SetScrollInfo",
		"checkWidget",
		"hwndScrollBar",
		"scrollBarType",
		"GetScrollInfo",
		"SetScrollInfo",
		"SetScrollInfo",
		"hwndScrollBar",
		"scrollBarType",
		"ShowScrollBar",
		"GetScrollInfo",
		"EnableScrollBar",
		"sendEvent",
		"sendEvent",
		"TypedListener",
		"SCROLLINFO",
		"RECT",
		"Rectangle",
		"SCROLLINFO",
		"SCROLLINFO",
		"SCROLLINFO",
		"RECT",
		"Point",
		"SCROLLINFO",
		"SCROLLINFO",
		"SCROLLINFO",
		"SCROLLINFO",
		"SCROLLINFO",
		"SCROLLINFO",
		"SCROLLINFO",
		"SCROLLINFO",
		"Event"
	],
	"methodsBody":{
		"public int getPageIncrement()":{
			"methodBody":"{\n    checkWidget();\n    return pageIncrement;\n}",
			"comments":"/**\n* Returns the amount that the receiver's value will be\n* modified by when the page increment/decrement areas\n* are selected.\n*\n* @return the page increment\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getPageIncrement()"
		},
		"public void setValues(int selection, int minimum, int maximum, int thumb, int increment, int pageIncrement)":{
			"methodBody":"{\n    checkWidget();\n    if (minimum < 0)\n        return;\n    if (maximum < 0)\n        return;\n    if (thumb < 1)\n        return;\n    if (increment < 1)\n        return;\n    if (pageIncrement < 1)\n        return;\n    this.increment = increment;\n    this.pageIncrement = pageIncrement;\n    SCROLLINFO info = new SCROLLINFO();\n    info.cbSize = SCROLLINFO.sizeof;\n    info.fMask = OS.SIF_POS | OS.SIF_PAGE | OS.SIF_RANGE | OS.SIF_DISABLENOSCROLL;\n    info.nPos = selection;\n    info.nMin = minimum;\n    info.nMax = maximum;\n    info.nPage = thumb;\n    if (info.nPage != 0)\n        info.nPage++;\n    int hwnd = hwndScrollBar(), type = scrollBarType();\n    SetScrollInfo(hwnd, type, info, true);\n}",
			"comments":"/**\n* Sets the receiver's selection, minimum value, maximum\n* value, thumb, increment and page increment all at once.\n* <p>\n* Note: This is equivalent to setting the values individually\n* using the appropriate methods, but may be implemented in a\n* more efficient fashion on some platforms.\n* </p>\n*\n* @param selection the new selection value\n* @param minimum the new minimum value\n* @param maximum the new maximum value\n* @param thumb the new thumb value\n* @param increment the new increment value\n* @param pageIncrement the new pageIncrement value\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setValues(int selection, int minimum, int maximum, int thumb, int increment, int pageIncrement)"
		},
		"public Scrollable getParent()":{
			"methodBody":"{\n    checkWidget();\n    return parent;\n}",
			"comments":"/**\n* Returns the receiver's parent, which must be a Scrollable.\n*\n* @return the receiver's parent\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Scrollable getParent()"
		},
		"int hwndScrollBar()":{
			"methodBody":"{\n    return parent.scrolledHandle();\n}",
			"comments":"",
			"methodName":"int hwndScrollBar()"
		},
		"public void setPageIncrement(int value)":{
			"methodBody":"{\n    checkWidget();\n    if (value < 1)\n        return;\n    pageIncrement = value;\n}",
			"comments":"/**\n* Sets the amount that the receiver's value will be\n* modified by when the page increment/decrement areas\n* are selected to the argument, which must be at least\n* one.\n*\n* @param value the page increment (must be greater than zero)\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setPageIncrement(int value)"
		},
		"public int getMaximum()":{
			"methodBody":"{\n    checkWidget();\n    SCROLLINFO info = new SCROLLINFO();\n    info.cbSize = SCROLLINFO.sizeof;\n    info.fMask = OS.SIF_RANGE;\n    int hwnd = hwndScrollBar();\n    int type = scrollBarType();\n    OS.GetScrollInfo(hwnd, type, info);\n    return info.nMax;\n}",
			"comments":"/**\n* Returns the maximum value which the receiver will allow.\n*\n* @return the maximum\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getMaximum()"
		},
		"public boolean isEnabled()":{
			"methodBody":"{\n    checkWidget();\n    return getEnabled() && parent.isEnabled();\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver is enabled and all\n* of the receiver's ancestors are enabled, and <code>false</code>\n* otherwise. A disabled control is typically not selectable from the\n* user interface and draws with an inactive or \"grayed\" look.\n*\n* @return the receiver's enabled state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #getEnabled\n*/\n",
			"methodName":"public boolean isEnabled()"
		},
		"public int getSelection()":{
			"methodBody":"{\n    checkWidget();\n    SCROLLINFO info = new SCROLLINFO();\n    info.cbSize = SCROLLINFO.sizeof;\n    info.fMask = OS.SIF_POS;\n    int hwnd = hwndScrollBar();\n    int type = scrollBarType();\n    OS.GetScrollInfo(hwnd, type, info);\n    return info.nPos;\n}",
			"comments":"/**\n* Returns the single 'selection' that is the receiver's value.\n*\n* @return the selection\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getSelection()"
		},
		"public void setThumb(int value)":{
			"methodBody":"{\n    checkWidget();\n    if (value < 1)\n        return;\n    SCROLLINFO info = new SCROLLINFO();\n    info.cbSize = SCROLLINFO.sizeof;\n    int hwnd = hwndScrollBar(), type = scrollBarType();\n    info.fMask = OS.SIF_PAGE | OS.SIF_RANGE | OS.SIF_DISABLENOSCROLL;\n    OS.GetScrollInfo(hwnd, type, info);\n    info.nPage = value;\n    if (info.nPage != 0)\n        info.nPage++;\n    SetScrollInfo(hwnd, type, info, true);\n}",
			"comments":"/**\n* Sets the size of the receiver's thumb relative to the\n* difference between its maximum and minimum values.  This new\n* value will be ignored if it is less than one, and will be\n* clamped if it exceeds the receiver's current range.\n*\n* @param value the new thumb value, which must be at least one and not\n* larger than the size of the current range\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setThumb(int value)"
		},
		"int scrollBarType()":{
			"methodBody":"{\n    if ((style & SWT.VERTICAL) != 0)\n        return OS.SB_VERT;\n    \n    return OS.SB_HORZ;\n}",
			"comments":"/*\n* This line is intentionally commented.  There should\n* only ever be HORIZONTAL and VERTICAL scroll bars.\n* The commented code reminds us that this is the case\n* and that the default style is HORIZONTAL.\n*/\n//\tif ((style & SWT.HORIZONTAL) != 0) return OS.SB_HORZ;\n",
			"methodName":"int scrollBarType()"
		},
		"static int checkStyle(int style)":{
			"methodBody":"{\n    return checkBits(style, SWT.HORIZONTAL, SWT.VERTICAL, 0, 0, 0, 0);\n}",
			"comments":"",
			"methodName":"static int checkStyle(int style)"
		},
		"public void setEnabled(boolean enabled)":{
			"methodBody":"{\n    checkWidget();\n    \n    if (!OS.IsWinCE) {\n        int hwnd = hwndScrollBar(), type = scrollBarType();\n        int flags = enabled ? OS.ESB_ENABLE_BOTH : OS.ESB_DISABLE_BOTH;\n        OS.EnableScrollBar(hwnd, type, flags);\n        if (enabled) {\n            state &= ~DISABLED;\n        } else {\n            state |= DISABLED;\n        }\n    }\n}",
			"comments":"/**\n* Enables the receiver if the argument is <code>true</code>,\n* and disables it otherwise. A disabled control is typically\n* not selectable from the user interface and draws with an\n* inactive or \"grayed\" look.\n*\n* @param enabled the new enabled state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* This line is intentionally commented.  Currently\n* always show scrollbar as being enabled and visible.\n*/\n//\tif (OS.IsWinCE) error (SWT.ERROR_NOT_IMPLEMENTED);\n",
			"methodName":"public void setEnabled(boolean enabled)"
		},
		"public void removeSelectionListener(SelectionListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.Selection, listener);\n    eventTable.unhook(SWT.DefaultSelection, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when the receiver's value changes.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see SelectionListener\n* @see #addSelectionListener\n*/\n",
			"methodName":"public void removeSelectionListener(SelectionListener listener)"
		},
		"void createWidget()":{
			"methodBody":"{\n    increment = 1;\n    pageIncrement = 10;\n\n}",
			"comments":"/*\n* Do not set the intial values of the maximum\n* or the thumb.  These values normally default\n* to 100 and 10 but may have been set already\n* by the widget that owns the scroll bar.  For\n* example, a scroll bar that is created for a\n* list widget, setting these defaults would\n* override the initial values provided by the\n* list widget.\n*/\n",
			"methodName":"void createWidget()"
		},
		"public boolean getEnabled()":{
			"methodBody":"{\n    checkWidget();\n    return (state & DISABLED) == 0;\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver is enabled, and\n* <code>false</code> otherwise. A disabled control is typically\n* not selectable from the user interface and draws with an\n* inactive or \"grayed\" look.\n*\n* @return the receiver's enabled state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #isEnabled\n*/\n",
			"methodName":"public boolean getEnabled()"
		},
		"public int getIncrement()":{
			"methodBody":"{\n    checkWidget();\n    return increment;\n}",
			"comments":"/**\n* Returns the amount that the receiver's value will be\n* modified by when the up/down (or right/left) arrows\n* are pressed.\n*\n* @return the increment\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getIncrement()"
		},
		"public void setVisible(boolean visible)":{
			"methodBody":"{\n    checkWidget();\n    boolean isVisible = (state & HIDDEN) == 0;\n    if (isVisible == visible)\n        return;\n    \n    if (OS.IsWinCE) {\n        SCROLLINFO info = new SCROLLINFO();\n        info.cbSize = SCROLLINFO.sizeof;\n        int hwnd = hwndScrollBar(), type = scrollBarType();\n        info.fMask = OS.SIF_RANGE | OS.SIF_PAGE;\n        if (visible)\n            info.fMask |= OS.SIF_DISABLENOSCROLL;\n        OS.GetScrollInfo(hwnd, type, info);\n        if (info.nPage == info.nMax - info.nMin + 1) {\n            \n            int max = info.nMax;\n            info.nMax++;\n            OS.SetScrollInfo(hwnd, type, info, false);\n            info.nMax = max;\n            OS.SetScrollInfo(hwnd, type, info, true);\n        } else {\n        \n        \n        }\n        return;\n    }\n    \n    state = visible ? state & ~HIDDEN : state | HIDDEN;\n    int hwnd = hwndScrollBar(), type = scrollBarType();\n    if (OS.ShowScrollBar(hwnd, type, visible)) {\n        \n        if ((state & DISABLED) == 0) {\n            SCROLLINFO info = new SCROLLINFO();\n            info.cbSize = SCROLLINFO.sizeof;\n            info.fMask = OS.SIF_RANGE | OS.SIF_PAGE;\n            OS.GetScrollInfo(hwnd, type, info);\n            if (info.nMax - info.nMin - info.nPage >= 0) {\n                OS.EnableScrollBar(hwnd, type, OS.ESB_ENABLE_BOTH);\n            }\n        }\n        sendEvent(visible ? SWT.Show : SWT.Hide);\n    \n    }\n}",
			"comments":"/**\n* Marks the receiver as visible if the argument is <code>true</code>,\n* and marks it invisible otherwise.\n* <p>\n* If one of the receiver's ancestors is not visible or some\n* other condition makes the receiver not visible, marking\n* it visible may not actually cause it to be displayed.\n* </p>\n*\n* @param visible the new visibility state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* On Windows CE, use SIF_DISABLENOSCROLL to show and\n* hide the scroll bar when the page size is equal to\n* the range.\n*/\n/*\n* Bug in Windows.  When the only changed flag to\n* SetScrollInfo () is OS.SIF_DISABLENOSCROLL,\n* Windows does not update the scroll bar state.\n* The fix is to increase and then decrease the\n* maximum, causing Windows to honour the flag.\n*/\n/*\n* This line is intentionally commented.  Currently\n* always show scrollbar as being enabled and visible.\n*/\n//\t\t\tif (OS.IsWinCE) error (SWT.ERROR_NOT_IMPLEMENTED);\n/*\n* Set the state bits before calling ShowScrollBar ()\n* because hiding and showing the scroll bar can cause\n* WM_SIZE messages when the client area is resized.\n* Setting the state before the call means that code\n* that runs during WM_SIZE that queries the visibility\n* of the scroll bar will get the correct value.\n*/\n/*\n* Bug in Windows.  For some reason, when the widget\n* is a standard scroll bar, and SetScrollInfo () is\n* called with SIF_RANGE or SIF_PAGE while the widget\n* is not visible, the widget is incorrectly disabled\n* even though the values for SIF_RANGE and SIF_PAGE,\n* when set for a visible scroll bar would not disable\n* the scroll bar.  The fix is to enable the scroll bar\n* when not disabled by the application and the current\n* scroll bar ranges would cause the scroll bar to be\n* enabled had they been set when the scroll bar was\n* visible.\n*/\n// widget could be disposed at this point\n",
			"methodName":"public void setVisible(boolean visible)"
		},
		"public void dispose()":{
			"methodBody":"{\n    if (isDisposed())\n        return;\n    if (!isValidThread())\n        error(SWT.ERROR_THREAD_INVALID_ACCESS);\n    int hwnd = hwndScrollBar(), type = scrollBarType();\n    super.dispose();\n    if (OS.IsWinCE) {\n        SCROLLINFO info = new SCROLLINFO();\n        info.cbSize = SCROLLINFO.sizeof;\n        info.fMask = OS.SIF_RANGE | OS.SIF_PAGE;\n        info.nPage = 101;\n        info.nMax = 100;\n        info.nMin = 0;\n        OS.SetScrollInfo(hwnd, type, info, true);\n    } else {\n        OS.ShowScrollBar(hwnd, type, false);\n    }\n}",
			"comments":"",
			"methodName":"public void dispose()"
		},
		"public Point getSize()":{
			"methodBody":"{\n    checkWidget();\n    parent.forceResize();\n    RECT rect = new RECT();\n    OS.GetClientRect(parent.scrolledHandle(), rect);\n    int width, height;\n    if ((style & SWT.HORIZONTAL) != 0) {\n        width = rect.right - rect.left;\n        height = OS.GetSystemMetrics(OS.SM_CYHSCROLL);\n    } else {\n        width = OS.GetSystemMetrics(OS.SM_CXVSCROLL);\n        height = rect.bottom - rect.top;\n    }\n    return new Point(width, height);\n}",
			"comments":"/**\n* Returns a point describing the receiver's size. The\n* x coordinate of the result is the width of the receiver.\n* The y coordinate of the result is the height of the\n* receiver.\n*\n* @return the receiver's size\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Point getSize()"
		},
		"public int getMinimum()":{
			"methodBody":"{\n    checkWidget();\n    SCROLLINFO info = new SCROLLINFO();\n    info.cbSize = SCROLLINFO.sizeof;\n    info.fMask = OS.SIF_RANGE;\n    int hwnd = hwndScrollBar();\n    int type = scrollBarType();\n    OS.GetScrollInfo(hwnd, type, info);\n    return info.nMin;\n}",
			"comments":"/**\n* Returns the minimum value which the receiver will allow.\n*\n* @return the minimum\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getMinimum()"
		},
		"LRESULT wmScrollChild(int wParam, int lParam)":{
			"methodBody":"{\n    \n    int code = wParam & 0xFFFF;\n    if (code == OS.SB_ENDSCROLL)\n        return null;\n    \n    Event event = new Event();\n    switch(code) {\n        case OS.SB_THUMBPOSITION:\n            event.detail = SWT.NONE;\n            break;\n        case OS.SB_THUMBTRACK:\n            event.detail = SWT.DRAG;\n            break;\n        case OS.SB_TOP:\n            event.detail = SWT.HOME;\n            break;\n        case OS.SB_BOTTOM:\n            event.detail = SWT.END;\n            break;\n        case OS.SB_LINEDOWN:\n            event.detail = SWT.ARROW_DOWN;\n            break;\n        case OS.SB_LINEUP:\n            event.detail = SWT.ARROW_UP;\n            break;\n        case OS.SB_PAGEDOWN:\n            event.detail = SWT.PAGE_DOWN;\n            break;\n        case OS.SB_PAGEUP:\n            event.detail = SWT.PAGE_UP;\n            break;\n    }\n    sendEvent(SWT.Selection, event);\n    \n    return null;\n}",
			"comments":"/* Do nothing when scrolling is ending */\n/*\n* Send the event because WM_HSCROLL and\n* WM_VSCROLL are sent from a modal message\n* loop in Windows that is active when the\n* user is scrolling.\n*/\n// the widget could be destroyed at this point\n",
			"methodName":"LRESULT wmScrollChild(int wParam, int lParam)"
		},
		"void releaseWidget()":{
			"methodBody":"{\n    super.releaseWidget();\n    parent = null;\n}",
			"comments":"",
			"methodName":"void releaseWidget()"
		},
		"public boolean getVisible()":{
			"methodBody":"{\n    checkWidget();\n    return (state & HIDDEN) == 0;\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver is visible, and\n* <code>false</code> otherwise.\n* <p>\n* If one of the receiver's ancestors is not visible or some\n* other condition makes the receiver not visible, this method\n* may still indicate that it is considered visible even though\n* it may not actually be showing.\n* </p>\n*\n* @return the receiver's visibility state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public boolean getVisible()"
		},
		"public void setMinimum(int value)":{
			"methodBody":"{\n    checkWidget();\n    if (value < 0)\n        return;\n    SCROLLINFO info = new SCROLLINFO();\n    info.cbSize = SCROLLINFO.sizeof;\n    int hwnd = hwndScrollBar(), type = scrollBarType();\n    info.fMask = OS.SIF_RANGE | OS.SIF_DISABLENOSCROLL;\n    OS.GetScrollInfo(hwnd, type, info);\n    if (info.nMax - value - info.nPage < 1)\n        return;\n    info.nMin = value;\n    SetScrollInfo(hwnd, type, info, true);\n}",
			"comments":"/**\n* Sets the minimum value. If this value is negative or greater\n* than or equal to the maximum, the value is ignored. If necessary,\n* first the thumb and then the selection are adjusted to fit within\n* the new range.\n*\n* @param value the new minimum\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setMinimum(int value)"
		},
		"public void setIncrement(int value)":{
			"methodBody":"{\n    checkWidget();\n    if (value < 1)\n        return;\n    increment = value;\n}",
			"comments":"/**\n* Sets the amount that the receiver's value will be\n* modified by when the up/down (or right/left) arrows\n* are pressed to the argument, which must be at least\n* one.\n*\n* @param value the new increment (must be greater than zero)\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setIncrement(int value)"
		},
		"public void setSelection(int selection)":{
			"methodBody":"{\n    checkWidget();\n    SCROLLINFO info = new SCROLLINFO();\n    info.cbSize = SCROLLINFO.sizeof;\n    int hwnd = hwndScrollBar(), type = scrollBarType();\n    info.fMask = OS.SIF_POS;\n    info.nPos = selection;\n    SetScrollInfo(hwnd, type, info, true);\n}",
			"comments":"/**\n* Sets the single <em>selection</em> that is the receiver's\n* value to the argument which must be greater than or equal\n* to zero.\n*\n* @param selection the new selection (must be zero or greater)\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setSelection(int selection)"
		},
		"boolean SetScrollInfo(int hwnd, int flags, SCROLLINFO info, boolean fRedraw)":{
			"methodBody":"{\n    \n    if ((state & (DISABLED | HIDDEN)) != 0)\n        fRedraw = false;\n    boolean result = OS.SetScrollInfo(hwnd, flags, info, fRedraw);\n    \n    if ((state & HIDDEN) != 0) {\n        \n        if (!OS.IsWinCE) {\n            ScrollBar bar = null;\n            switch(flags) {\n                case OS.SB_HORZ:\n                    bar = parent.getVerticalBar();\n                    break;\n                case OS.SB_VERT:\n                    bar = parent.getHorizontalBar();\n                    break;\n            }\n            boolean both = bar != null && !bar.getVisible();\n            OS.ShowScrollBar(hwnd, both ? OS.SB_BOTH : flags, false);\n        }\n    }\n    \n    if ((state & DISABLED) != 0) {\n        \n        if (!OS.IsWinCE) {\n            OS.EnableScrollBar(hwnd, flags, OS.ESB_DISABLE_BOTH);\n        }\n    }\n    return result;\n}",
			"comments":"/*\n* Bug in Windows.  For some reason, when SetScrollInfo()\n* is used with SIF_POS and the scroll bar is hidden,\n* the opposite scroll bar is incorrectly made visible\n* so that the next time the parent is resized (or another\n* scroll bar operation is performed), the opposite scroll\n* bar draws.  The fix is to hide both scroll bars.\n*/\n/*\n* Bug in Windows.  For some reason, when the widget\n* is a standard scroll bar, and SetScrollInfo() is\n* called with SIF_RANGE or SIF_PAGE, the widget is\n* incorrectly made visible so that the next time the\n* parent is resized (or another scroll bar operation\n* is performed), the scroll bar draws.  The fix is\n* to hide the scroll bar (again) when already hidden.\n*/\n/*\n* This line is intentionally commented.  Currently\n* always show scrollbar as being enabled and visible.\n*/\n//\t\tif (OS.IsWinCE) error (SWT.ERROR_NOT_IMPLEMENTED);\n/*\n* Feature in Windows.  Using SIF_DISABLENOSCROLL,\n* SetScrollInfo () can change enabled and disabled\n* state of the scroll bar causing a scroll bar that\n* was disabled by the application to become enabled.\n* The fix is to disable the scroll bar (again) when\n* the application has disabled the scroll bar.\n*/\n/*\n* This line is intentionally commented.  Currently\n* always show scrollbar as being enabled and visible.\n*/\n//\t\tif (OS.IsWinCE) error (SWT.ERROR_NOT_IMPLEMENTED);\n",
			"methodName":"boolean SetScrollInfo(int hwnd, int flags, SCROLLINFO info, boolean fRedraw)"
		},
		"public int getThumb()":{
			"methodBody":"{\n    checkWidget();\n    SCROLLINFO info = new SCROLLINFO();\n    info.cbSize = SCROLLINFO.sizeof;\n    info.fMask = OS.SIF_PAGE;\n    int hwnd = hwndScrollBar();\n    int type = scrollBarType();\n    OS.GetScrollInfo(hwnd, type, info);\n    if (info.nPage != 0)\n        --info.nPage;\n    return info.nPage;\n}",
			"comments":"/**\n* Answers the size of the receiver's thumb relative to the\n* difference between its maximum and minimum values.\n*\n* @return the thumb value\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see ScrollBar\n*/\n",
			"methodName":"public int getThumb()"
		},
		"void releaseChild()":{
			"methodBody":"{\n    super.releaseChild();\n    if (parent.horizontalBar == this)\n        parent.horizontalBar = null;\n    if (parent.verticalBar == this)\n        parent.verticalBar = null;\n}",
			"comments":"",
			"methodName":"void releaseChild()"
		},
		"public void setMaximum(int value)":{
			"methodBody":"{\n    checkWidget();\n    if (value < 0)\n        return;\n    SCROLLINFO info = new SCROLLINFO();\n    info.cbSize = SCROLLINFO.sizeof;\n    int hwnd = hwndScrollBar(), type = scrollBarType();\n    info.fMask = OS.SIF_RANGE | OS.SIF_DISABLENOSCROLL;\n    OS.GetScrollInfo(hwnd, type, info);\n    if (value - info.nMin - info.nPage < 1)\n        return;\n    info.nMax = value;\n    SetScrollInfo(hwnd, type, info, true);\n}",
			"comments":"/**\n* Sets the maximum. If this value is negative or less than or\n* equal to the minimum, the value is ignored. If necessary, first\n* the thumb and then the selection are adjusted to fit within the\n* new range.\n*\n* @param value the new maximum\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setMaximum(int value)"
		},
		"public void addSelectionListener(SelectionListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.Selection, typedListener);\n    addListener(SWT.DefaultSelection, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when the receiver's value changes, by sending\n* it one of the messages defined in the <code>SelectionListener</code>\n* interface.\n* <p>\n* When <code>widgetSelected</code> is called, the event object detail field contains one of the following values:\n* <code>SWT.NONE</code> - for the end of a drag.\n* <code>SWT.DRAG</code>.\n* <code>SWT.HOME</code>.\n* <code>SWT.END</code>.\n* <code>SWT.ARROW_DOWN</code>.\n* <code>SWT.ARROW_UP</code>.\n* <code>SWT.PAGE_DOWN</code>.\n* <code>SWT.PAGE_UP</code>.\n* <code>widgetDefaultSelected</code> is not called.\n* </p>\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see SelectionListener\n* @see #removeSelectionListener\n* @see SelectionEvent\n*/\n",
			"methodName":"public void addSelectionListener(SelectionListener listener)"
		},
		"Rectangle getBounds()":{
			"methodBody":"{\n    \n    parent.forceResize();\n    RECT rect = new RECT();\n    OS.GetClientRect(parent.scrolledHandle(), rect);\n    int x = 0, y = 0, width, height;\n    if ((style & SWT.HORIZONTAL) != 0) {\n        y = rect.bottom - rect.top;\n        width = rect.right - rect.left;\n        height = OS.GetSystemMetrics(OS.SM_CYHSCROLL);\n    } else {\n        x = rect.right - rect.left;\n        width = OS.GetSystemMetrics(OS.SM_CXVSCROLL);\n        height = rect.bottom - rect.top;\n    }\n    return new Rectangle(x, y, width, height);\n}",
			"comments":"/*\n* Not currently used.\n*/\n//\tcheckWidget ();\n",
			"methodName":"Rectangle getBounds()"
		},
		"public boolean isVisible()":{
			"methodBody":"{\n    checkWidget();\n    return getVisible() && parent.isVisible();\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver is visible and all\n* of the receiver's ancestors are visible and <code>false</code>\n* otherwise.\n*\n* @return the receiver's visibility state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #getVisible\n*/\n",
			"methodName":"public boolean isVisible()"
		}
	},
	"ClassORInterfaceName":[
		"ScrollBar"
	]
}
