{
	"variables":[
		"restartInterval",
		"frameHeader",
		"imageWidth",
		"imageHeight",
		"interleavedMcuCols",
		"interleavedMcuRows",
		"maxV",
		"maxH",
		"progressive",
		"samplePrecision",
		"nComponents",
		"frameComponents",
		"componentIds",
		"imageComponents",
		"dataUnit",
		"dataUnits",
		"precedingDCs",
		"scanHeader",
		"dataBuffer",
		"currentBitCount",
		"bufferCurrentPosition",
		"restartsToGo",
		"nextRestartNumber",
		"acHuffmanTables",
		"dcHuffmanTables",
		"quantizationTables",
		"currentByte",
		"encoderQFactor",
		"eobrun",
		"DCTSIZE",
		"DCTSIZESQR",
		"FIX_0_899976223",
		"FIX_1_961570560",
		"FIX_2_053119869",
		"FIX_0_298631336",
		"FIX_1_847759065",
		"FIX_1_175875602",
		"FIX_3_072711026",
		"FIX_0_765366865",
		"FIX_2_562915447",
		"FIX_0_541196100",
		"FIX_0_390180644",
		"FIX_1_501321110",
		"APP0",
		"APP15",
		"COM",
		"DAC",
		"DHP",
		"DHT",
		"DNL",
		"DRI",
		"DQT",
		"EOI",
		"EXP",
		"JPG",
		"JPG0",
		"JPG13",
		"RST0",
		"RST1",
		"RST2",
		"RST3",
		"RST4",
		"RST5",
		"RST6",
		"RST7",
		"SOF0",
		"SOF1",
		"SOF2",
		"SOF3",
		"SOF5",
		"SOF6",
		"SOF7",
		"SOF9",
		"SOF10",
		"SOF11",
		"SOF13",
		"SOF14",
		"SOF15",
		"SOI",
		"SOS",
		"TEM",
		"TQI",
		"HI",
		"VI",
		"CW",
		"CH",
		"DC",
		"AC",
		"ID_Y",
		"ID_CB",
		"ID_CR",
		"ExtendTest",
		"ExtendOffset",
		"ZigZag8x8",
		"CrRTable",
		"CbBTable",
		"CrGTable",
		"CbGTable",
		"RYTable",
		"GYTable",
		"BYTable",
		"RCbTable",
		"GCbTable",
		"BCbTable",
		"RCrTable",
		"GCrTable",
		"BCrTable",
		"NBitsTable",
		"srcWidth",
		"srcHeight",
		"vhFactor",
		"frameComponent",
		"i",
		"yPos",
		"srcOfs",
		"dstOfs",
		"yPos",
		"destRowIndex",
		"xPos",
		"sum",
		"iv",
		"srcIndex",
		"ih",
		"yPos",
		"destRowIndex",
		"xPos",
		"sum",
		"iv",
		"srcIndex",
		"ih",
		"iComp",
		"imageComponent",
		"hFactor",
		"vFactor",
		"componentWidth",
		"componentHeight",
		"compressedWidth",
		"compressedHeight",
		"delta",
		"yPos",
		"dstOfs",
		"dataValue",
		"i",
		"srcOfs",
		"yPos",
		"dstOfs",
		"rgbs",
		"paletteSize",
		"yComp",
		"cbComp",
		"crComp",
		"srcWidth",
		"srcHeight",
		"i",
		"color",
		"r",
		"g",
		"b",
		"n",
		"bSize",
		"dataYComp",
		"dataCbComp",
		"dataCrComp",
		"origData",
		"bytesPerLine",
		"maxScanlineByte",
		"yPos",
		"xPos",
		"srcIndex",
		"dstIndex",
		"value2",
		"value1",
		"rgbs",
		"paletteSize",
		"yComp",
		"cbComp",
		"crComp",
		"srcWidth",
		"srcHeight",
		"i",
		"color",
		"r",
		"g",
		"b",
		"n",
		"dstWidth",
		"dstHeight",
		"stride",
		"bSize",
		"dataYComp",
		"dataCbComp",
		"dataCrComp",
		"origData",
		"yPos",
		"srcRowIndex",
		"dstRowIndex",
		"xPos",
		"value",
		"dstIndex",
		"srcWidth",
		"srcHeight",
		"bSize",
		"dataYComp",
		"dataCbComp",
		"dataCrComp",
		"palette",
		"buffer",
		"redMask",
		"greenMask",
		"blueMask",
		"redShift",
		"greenShift",
		"blueShift",
		"yPos",
		"dstRowIndex",
		"xPos",
		"pixel",
		"dstDataIndex",
		"r",
		"g",
		"b",
		"yPos",
		"dstRowIndex",
		"xPos",
		"pixel",
		"dstDataIndex",
		"rgb",
		"r",
		"g",
		"b",
		"compWidth",
		"bytesPerLine",
		"data",
		"yComp",
		"destIndex",
		"i",
		"srcIndex",
		"j",
		"y",
		"bSize",
		"rgbData",
		"destIndex",
		"yComp",
		"cbComp",
		"crComp",
		"compWidth",
		"v",
		"srcIndex",
		"i",
		"y",
		"cb",
		"cr",
		"r",
		"g",
		"b",
		"sParams",
		"acTable",
		"k",
		"rs",
		"r",
		"s",
		"bits",
		"sParams",
		"acTable",
		"k",
		"rs",
		"r",
		"s",
		"bits",
		"sParams",
		"acTable",
		"k",
		"zzIndex",
		"rs",
		"r",
		"s",
		"zeros",
		"zzIndex",
		"bit",
		"zeros",
		"zzIndex",
		"bit",
		"bit",
		"sParams",
		"dcTable",
		"lastDC",
		"bit",
		"nBits",
		"bits",
		"diff",
		"qTable",
		"i",
		"zzIndex",
		"compIds",
		"compIdsIndex",
		"i",
		"iComp",
		"scanComponent",
		"frameComponent",
		"hi",
		"vi",
		"compWidth",
		"ivi",
		"ihi",
		"index",
		"i",
		"temp",
		"nComponentsInScan",
		"mcuRowsInScan",
		"mcusPerRow",
		"scanComponent",
		"frameComponent",
		"hi",
		"vi",
		"mcuWidth",
		"mcuHeight",
		"first",
		"start",
		"end",
		"approxBit",
		"ymcu",
		"xmcu",
		"i",
		"maxCodes",
		"minCodes",
		"valPtrs",
		"huffVals",
		"code",
		"j",
		"power2m1",
		"code",
		"codeBuffer",
		"abs",
		"sParams",
		"acTable",
		"ehCodes",
		"ehSizes",
		"r",
		"k",
		"acValue",
		"absACValue",
		"nBits",
		"rs",
		"nBits",
		"rs",
		"sParams",
		"dcTable",
		"lastDC",
		"dcValue",
		"diff",
		"absDiff",
		"nBits",
		"nBits",
		"nComponentsInScan",
		"iComp",
		"frameComponent",
		"hi",
		"vi",
		"ivi",
		"ihi",
		"ymcu",
		"xmcu",
		"iComp",
		"frameComponent",
		"hi",
		"vi",
		"upH",
		"upV",
		"component",
		"compWidth",
		"compHeight",
		"upCompWidth",
		"upCompHeight",
		"rgbs",
		"src",
		"dest",
		"compImage",
		"frameComponent",
		"hi",
		"vi",
		"compWidth",
		"srcIndex",
		"destIndex",
		"i",
		"col",
		"row",
		"rIndex",
		"tmp0",
		"tmp7",
		"tmp1",
		"tmp6",
		"tmp2",
		"tmp5",
		"tmp3",
		"tmp4",
		"tmp10",
		"tmp13",
		"tmp11",
		"tmp12",
		"z1",
		"scaleFactor1",
		"scaleFactor2",
		"n",
		"z2",
		"z3",
		"z4",
		"z5",
		"col",
		"c0",
		"c1",
		"c2",
		"c3",
		"c4",
		"c5",
		"c6",
		"c7",
		"tmp0",
		"tmp7",
		"tmp1",
		"tmp6",
		"tmp2",
		"tmp5",
		"tmp3",
		"tmp4",
		"tmp10",
		"tmp13",
		"tmp11",
		"tmp12",
		"scaleFactor1",
		"scaleFactor2",
		"n",
		"z1",
		"z2",
		"z3",
		"z4",
		"z5",
		"appn",
		"dht",
		"dhtTables",
		"i",
		"dhtTable",
		"dqt",
		"currentTables",
		"dqtTablesKeys",
		"dqtTablesValues",
		"i",
		"index",
		"dri",
		"nBits",
		"power2",
		"i",
		"i",
		"i",
		"x2",
		"row",
		"rIndex",
		"dcVal",
		"i",
		"z2",
		"z3",
		"z1",
		"tmp2",
		"tmp3",
		"tmp0",
		"tmp1",
		"tmp10",
		"tmp13",
		"tmp11",
		"tmp12",
		"z4",
		"z5",
		"descaleFactor1",
		"descaleFactor2",
		"col",
		"c0",
		"c1",
		"c2",
		"c3",
		"c4",
		"c5",
		"c6",
		"c7",
		"dcVal",
		"z2",
		"z3",
		"z1",
		"tmp2",
		"tmp3",
		"tmp0",
		"tmp1",
		"tmp10",
		"tmp13",
		"tmp11",
		"tmp12",
		"z4",
		"z5",
		"descaleFactor1",
		"descaleFactor2",
		"soi",
		"soi",
		"mcuWidth",
		"mcuHeight",
		"i",
		"frameComponent",
		"bufferSize",
		"progressiveScanCount",
		"done",
		"imageData",
		"delta",
		"unreadBuffer",
		"jpegSegment",
		"ymcu",
		"xmcu",
		"iComp",
		"frameComponent",
		"hi",
		"vi",
		"compWidth",
		"ivi",
		"ihi",
		"index",
		"imageData",
		"nextByte",
		"jpegSegment",
		"sof",
		"marker",
		"qTable",
		"i",
		"zzIndex",
		"data",
		"absData",
		"qValue",
		"q2",
		"v",
		"i",
		"byteArray",
		"entries",
		"i",
		"byteArray",
		"jpegSegment",
		"delta",
		"compImage",
		"frameComponent",
		"compWidth",
		"destIndex",
		"srcIndex",
		"i",
		"col",
		"x",
		"appn",
		"chromDQT",
		"jpegDQTKeys",
		"jpegDQTValues",
		"i",
		"lumDQT",
		"i",
		"frameLength",
		"scanLength",
		"precision",
		"frameParams",
		"scanParams",
		"mcuWidth",
		"mcuHeight",
		"dhtTables",
		"i",
		"dhtTable",
		"allTables",
		"j",
		"huffmanTable",
		"image",
		"image",
		"maxV",
		"maxH",
		"imageComponents",
		"nComponents",
		"i",
		"nComponents",
		"i",
		"frameComponent",
		"frameComponents",
		"componentIds",
		"i",
		"imageComponents",
		"i",
		"frameComponent",
		"CW",
		"frameComponent",
		"CH",
		"frameComponent",
		"frameComponents",
		"componentIds",
		"ID_Y",
		"yPos",
		"srcHeight",
		"yPos",
		"yPos",
		"srcWidth",
		"yPos",
		"frameComponent",
		"CW",
		"System",
		"dataYComp",
		"srcOfs",
		"imageComponents",
		"ID_Y",
		"dstOfs",
		"srcWidth",
		"frameComponent",
		"frameComponents",
		"componentIds",
		"ID_CB",
		"yPos",
		"srcHeight",
		"maxV",
		"yPos",
		"yPos",
		"frameComponent",
		"CW",
		"xPos",
		"srcWidth",
		"maxH",
		"xPos",
		"iv",
		"maxV",
		"iv",
		"yPos",
		"maxV",
		"iv",
		"srcWidth",
		"xPos",
		"maxH",
		"ih",
		"maxH",
		"ih",
		"sum",
		"dataCbComp",
		"srcIndex",
		"ih",
		"imageComponents",
		"ID_CB",
		"destRowIndex",
		"xPos",
		"sum",
		"vhFactor",
		"frameComponent",
		"frameComponents",
		"componentIds",
		"ID_CR",
		"yPos",
		"srcHeight",
		"maxV",
		"yPos",
		"yPos",
		"frameComponent",
		"CW",
		"xPos",
		"srcWidth",
		"maxH",
		"xPos",
		"iv",
		"maxV",
		"iv",
		"yPos",
		"maxV",
		"iv",
		"srcWidth",
		"xPos",
		"maxH",
		"ih",
		"maxH",
		"ih",
		"sum",
		"dataCrComp",
		"srcIndex",
		"ih",
		"imageComponents",
		"ID_CR",
		"destRowIndex",
		"xPos",
		"sum",
		"vhFactor",
		"iComp",
		"nComponents",
		"iComp",
		"imageComponents",
		"iComp",
		"frameComponent",
		"frameComponents",
		"componentIds",
		"iComp",
		"frameComponent",
		"HI",
		"frameComponent",
		"VI",
		"frameComponent",
		"CW",
		"frameComponent",
		"CH",
		"srcWidth",
		"maxH",
		"hFactor",
		"srcHeight",
		"maxV",
		"vFactor",
		"compressedWidth",
		"componentWidth",
		"componentWidth",
		"compressedWidth",
		"yPos",
		"compressedHeight",
		"yPos",
		"yPos",
		"componentWidth",
		"delta",
		"imageComponent",
		"dstOfs",
		"i",
		"delta",
		"i",
		"imageComponent",
		"dstOfs",
		"i",
		"dataValue",
		"compressedHeight",
		"componentHeight",
		"compressedHeight",
		"componentWidth",
		"compressedHeight",
		"yPos",
		"componentHeight",
		"yPos",
		"yPos",
		"componentWidth",
		"System",
		"imageComponent",
		"srcOfs",
		"imageComponent",
		"dstOfs",
		"componentWidth",
		"image",
		"rgbs",
		"paletteSize",
		"paletteSize",
		"paletteSize",
		"image",
		"image",
		"i",
		"paletteSize",
		"i",
		"rgbs",
		"i",
		"color",
		"color",
		"color",
		"RYTable",
		"r",
		"GYTable",
		"g",
		"BYTable",
		"b",
		"yComp",
		"i",
		"n",
		"n",
		"n",
		"yComp",
		"i",
		"n",
		"RCbTable",
		"r",
		"GCbTable",
		"g",
		"BCbTable",
		"b",
		"cbComp",
		"i",
		"n",
		"n",
		"n",
		"cbComp",
		"i",
		"n",
		"RCrTable",
		"r",
		"GCrTable",
		"g",
		"BCrTable",
		"b",
		"crComp",
		"i",
		"n",
		"n",
		"n",
		"crComp",
		"i",
		"srcWidth",
		"srcHeight",
		"bSize",
		"bSize",
		"bSize",
		"image",
		"image",
		"srcWidth",
		"yPos",
		"srcHeight",
		"yPos",
		"xPos",
		"maxScanlineByte",
		"xPos",
		"yPos",
		"bytesPerLine",
		"xPos",
		"yPos",
		"srcWidth",
		"xPos",
		"origData",
		"srcIndex",
		"value2",
		"value2",
		"value2",
		"dataYComp",
		"dstIndex",
		"yComp",
		"value1",
		"dataCbComp",
		"dstIndex",
		"cbComp",
		"value1",
		"dataCrComp",
		"dstIndex",
		"crComp",
		"value1",
		"dataYComp",
		"dstIndex",
		"yComp",
		"value2",
		"dataCbComp",
		"dstIndex",
		"cbComp",
		"value2",
		"dataCrComp",
		"dstIndex",
		"crComp",
		"value2",
		"image",
		"dataYComp",
		"dataCbComp",
		"dataCrComp",
		"image",
		"rgbs",
		"paletteSize",
		"paletteSize",
		"paletteSize",
		"image",
		"image",
		"i",
		"paletteSize",
		"i",
		"rgbs",
		"i",
		"color",
		"color",
		"color",
		"RYTable",
		"r",
		"GYTable",
		"g",
		"BYTable",
		"b",
		"yComp",
		"i",
		"n",
		"n",
		"n",
		"yComp",
		"i",
		"n",
		"RCbTable",
		"r",
		"GCbTable",
		"g",
		"BCbTable",
		"b",
		"cbComp",
		"i",
		"n",
		"n",
		"n",
		"cbComp",
		"i",
		"n",
		"RCrTable",
		"r",
		"GCrTable",
		"g",
		"BCrTable",
		"b",
		"crComp",
		"i",
		"n",
		"n",
		"n",
		"crComp",
		"i",
		"image",
		"srcHeight",
		"srcWidth",
		"dstWidth",
		"dstHeight",
		"bSize",
		"bSize",
		"bSize",
		"image",
		"yPos",
		"srcHeight",
		"yPos",
		"yPos",
		"stride",
		"yPos",
		"dstWidth",
		"xPos",
		"srcWidth",
		"xPos",
		"origData",
		"srcRowIndex",
		"xPos",
		"dstRowIndex",
		"xPos",
		"dataYComp",
		"dstIndex",
		"yComp",
		"value",
		"dataCbComp",
		"dstIndex",
		"cbComp",
		"value",
		"dataCrComp",
		"dstIndex",
		"crComp",
		"value",
		"image",
		"dataYComp",
		"dataCbComp",
		"dataCrComp",
		"image",
		"image",
		"image",
		"image",
		"SWT",
		"SWT",
		"image",
		"image",
		"srcWidth",
		"srcHeight",
		"bSize",
		"bSize",
		"bSize",
		"image",
		"srcWidth",
		"palette",
		"palette",
		"palette",
		"palette",
		"palette",
		"palette",
		"palette",
		"yPos",
		"srcHeight",
		"yPos",
		"image",
		"yPos",
		"srcWidth",
		"buffer",
		"yPos",
		"srcWidth",
		"xPos",
		"srcWidth",
		"xPos",
		"buffer",
		"xPos",
		"dstRowIndex",
		"xPos",
		"pixel",
		"redMask",
		"r",
		"redShift",
		"r",
		"redShift",
		"r",
		"redShift",
		"pixel",
		"greenMask",
		"g",
		"greenShift",
		"g",
		"greenShift",
		"g",
		"greenShift",
		"pixel",
		"blueMask",
		"b",
		"blueShift",
		"b",
		"blueShift",
		"b",
		"blueShift",
		"dataYComp",
		"dstDataIndex",
		"RYTable",
		"r",
		"GYTable",
		"g",
		"BYTable",
		"b",
		"dataCbComp",
		"dstDataIndex",
		"RCbTable",
		"r",
		"GCbTable",
		"g",
		"BCbTable",
		"b",
		"dataCrComp",
		"dstDataIndex",
		"RCrTable",
		"r",
		"GCrTable",
		"g",
		"BCrTable",
		"b",
		"yPos",
		"srcHeight",
		"yPos",
		"image",
		"yPos",
		"srcWidth",
		"buffer",
		"yPos",
		"srcWidth",
		"xPos",
		"srcWidth",
		"xPos",
		"buffer",
		"xPos",
		"dstRowIndex",
		"xPos",
		"palette",
		"pixel",
		"rgb",
		"rgb",
		"rgb",
		"dataYComp",
		"dstDataIndex",
		"RYTable",
		"r",
		"GYTable",
		"g",
		"BYTable",
		"b",
		"dataCbComp",
		"dstDataIndex",
		"RCbTable",
		"r",
		"GCbTable",
		"g",
		"BCbTable",
		"b",
		"dataCrComp",
		"dstDataIndex",
		"RCrTable",
		"r",
		"GCrTable",
		"g",
		"BCrTable",
		"b",
		"image",
		"dataYComp",
		"dataCbComp",
		"dataCrComp",
		"frameComponents",
		"componentIds",
		"ID_Y",
		"CW",
		"imageWidth",
		"bytesPerLine",
		"imageHeight",
		"imageComponents",
		"ID_Y",
		"i",
		"imageHeight",
		"i",
		"i",
		"compWidth",
		"j",
		"bytesPerLine",
		"j",
		"yComp",
		"srcIndex",
		"y",
		"y",
		"y",
		"y",
		"j",
		"imageWidth",
		"y",
		"data",
		"destIndex",
		"y",
		"srcIndex",
		"destIndex",
		"data",
		"imageWidth",
		"imageHeight",
		"nComponents",
		"bSize",
		"imageComponents",
		"ID_Y",
		"imageComponents",
		"ID_CB",
		"imageComponents",
		"ID_CR",
		"frameComponents",
		"componentIds",
		"ID_Y",
		"CW",
		"v",
		"imageHeight",
		"v",
		"v",
		"compWidth",
		"i",
		"imageWidth",
		"i",
		"yComp",
		"srcIndex",
		"cbComp",
		"srcIndex",
		"crComp",
		"srcIndex",
		"y",
		"CrRTable",
		"cr",
		"y",
		"CbGTable",
		"cb",
		"CrGTable",
		"cr",
		"y",
		"CbBTable",
		"cb",
		"r",
		"r",
		"r",
		"r",
		"g",
		"g",
		"g",
		"g",
		"b",
		"b",
		"b",
		"b",
		"rgbData",
		"destIndex",
		"b",
		"rgbData",
		"destIndex",
		"g",
		"rgbData",
		"destIndex",
		"r",
		"destIndex",
		"srcIndex",
		"rgbData",
		"scanHeader",
		"componentIds",
		"iComp",
		"acHuffmanTables",
		"sParams",
		"AC",
		"k",
		"acTable",
		"rs",
		"rs",
		"s",
		"r",
		"k",
		"k",
		"r",
		"s",
		"dataUnit",
		"ZigZag8x8",
		"k",
		"bits",
		"s",
		"k",
		"eobrun",
		"eobrun",
		"scanHeader",
		"componentIds",
		"iComp",
		"acHuffmanTables",
		"sParams",
		"AC",
		"start",
		"k",
		"end",
		"acTable",
		"rs",
		"rs",
		"s",
		"r",
		"k",
		"eobrun",
		"r",
		"r",
		"k",
		"r",
		"s",
		"dataUnit",
		"ZigZag8x8",
		"k",
		"bits",
		"s",
		"approxBit",
		"k",
		"scanHeader",
		"componentIds",
		"iComp",
		"acHuffmanTables",
		"sParams",
		"AC",
		"start",
		"k",
		"end",
		"eobrun",
		"k",
		"end",
		"ZigZag8x8",
		"k",
		"dataUnit",
		"zzIndex",
		"dataUnit",
		"zzIndex",
		"dataUnit",
		"zzIndex",
		"approxBit",
		"k",
		"eobrun",
		"acTable",
		"rs",
		"rs",
		"s",
		"r",
		"zeros",
		"k",
		"end",
		"ZigZag8x8",
		"k",
		"dataUnit",
		"zzIndex",
		"dataUnit",
		"zzIndex",
		"dataUnit",
		"zzIndex",
		"approxBit",
		"zeros",
		"k",
		"eobrun",
		"r",
		"r",
		"s",
		"ZigZag8x8",
		"k",
		"zeros",
		"r",
		"dataUnit",
		"zzIndex",
		"k",
		"end",
		"dataUnit",
		"zzIndex",
		"dataUnit",
		"zzIndex",
		"dataUnit",
		"zzIndex",
		"approxBit",
		"zeros",
		"k",
		"zzIndex",
		"ZigZag8x8",
		"k",
		"bit",
		"dataUnit",
		"zzIndex",
		"approxBit",
		"dataUnit",
		"zzIndex",
		"approxBit",
		"k",
		"ac",
		"bit",
		"ac",
		"ac",
		"approxBit",
		"ac",
		"bit",
		"ac",
		"ac",
		"approxBit",
		"ac",
		"scanHeader",
		"componentIds",
		"iComp",
		"dcHuffmanTables",
		"sParams",
		"DC",
		"progressive",
		"first",
		"lastDC",
		"dataUnit",
		"bit",
		"approxBit",
		"lastDC",
		"precedingDCs",
		"iComp",
		"dcTable",
		"nBits",
		"nBits",
		"bits",
		"nBits",
		"lastDC",
		"lastDC",
		"diff",
		"precedingDCs",
		"iComp",
		"lastDC",
		"progressive",
		"lastDC",
		"lastDC",
		"approxBit",
		"dataUnit",
		"lastDC",
		"quantizationTables",
		"frameComponents",
		"componentIds",
		"iComp",
		"TQI",
		"i",
		"dataUnit",
		"i",
		"ZigZag8x8",
		"i",
		"dataUnit",
		"zzIndex",
		"dataUnit",
		"zzIndex",
		"qTable",
		"i",
		"nComponents",
		"i",
		"nComponents",
		"i",
		"compIds",
		"compIdsIndex",
		"i",
		"compIdsIndex",
		"compIds",
		"compIds",
		"compIds",
		"compIds",
		"compIds",
		"compIds",
		"compIds",
		"compIds",
		"compIds",
		"iComp",
		"nComponentsInScan",
		"iComp",
		"iComp",
		"scanHeader",
		"componentIds",
		"scanComponent",
		"scanComponent",
		"frameComponents",
		"componentIds",
		"scanComponent",
		"frameComponent",
		"HI",
		"frameComponent",
		"VI",
		"nComponentsInScan",
		"hi",
		"vi",
		"frameComponent",
		"CW",
		"ivi",
		"vi",
		"ivi",
		"ihi",
		"hi",
		"ihi",
		"progressive",
		"ymcu",
		"vi",
		"ivi",
		"compWidth",
		"xmcu",
		"hi",
		"ihi",
		"dataUnit",
		"dataUnits",
		"scanComponent",
		"index",
		"dataUnit",
		"dataUnit",
		"dataUnits",
		"scanComponent",
		"index",
		"dataUnit",
		"i",
		"dataUnit",
		"i",
		"dataUnit",
		"i",
		"progressive",
		"scanHeader",
		"dataUnit",
		"scanComponent",
		"first",
		"approxBit",
		"progressive",
		"dataUnit",
		"scanComponent",
		"scanHeader",
		"first",
		"dataUnit",
		"scanComponent",
		"start",
		"end",
		"approxBit",
		"dataUnit",
		"scanComponent",
		"start",
		"end",
		"approxBit",
		"loader",
		"dataUnit",
		"dataUnit",
		"System",
		"temp",
		"dataUnit",
		"progressive",
		"progressive",
		"loader",
		"dataUnit",
		"scanComponent",
		"dataUnit",
		"dataUnit",
		"scanComponent",
		"xmcu",
		"ymcu",
		"hi",
		"ihi",
		"vi",
		"ivi",
		"progressive",
		"scanHeader",
		"SWT",
		"SWT",
		"scanHeader",
		"interleavedMcuRows",
		"interleavedMcuCols",
		"nComponentsInScan",
		"scanHeader",
		"componentIds",
		"scanComponent",
		"scanComponent",
		"frameComponents",
		"componentIds",
		"scanComponent",
		"frameComponent",
		"HI",
		"frameComponent",
		"VI",
		"DCTSIZE",
		"maxH",
		"hi",
		"DCTSIZE",
		"maxV",
		"vi",
		"mcusPerRow",
		"imageWidth",
		"mcuWidth",
		"mcuWidth",
		"mcuRowsInScan",
		"imageHeight",
		"mcuHeight",
		"mcuHeight",
		"scanHeader",
		"scanHeader",
		"scanHeader",
		"scanHeader",
		"restartsToGo",
		"restartInterval",
		"nextRestartNumber",
		"ymcu",
		"mcuRowsInScan",
		"ymcu",
		"xmcu",
		"mcusPerRow",
		"xmcu",
		"restartInterval",
		"restartsToGo",
		"restartsToGo",
		"xmcu",
		"ymcu",
		"nComponentsInScan",
		"first",
		"start",
		"end",
		"approxBit",
		"huffmanTable",
		"huffmanTable",
		"huffmanTable",
		"huffmanTable",
		"code",
		"maxCodes",
		"i",
		"code",
		"code",
		"i",
		"valPtrs",
		"i",
		"j",
		"j",
		"code",
		"minCodes",
		"i",
		"huffVals",
		"j",
		"nBits",
		"SWT",
		"SWT",
		"huffCode",
		"power2m1",
		"nBits",
		"nBits",
		"currentBitCount",
		"codeBuffer",
		"code",
		"codeBuffer",
		"code",
		"codeBuffer",
		"code",
		"codeBuffer",
		"code",
		"nBits",
		"currentBitCount",
		"abs",
		"abs",
		"abs",
		"abs",
		"currentByte",
		"codeBuffer",
		"currentByte",
		"codeBuffer",
		"currentByte",
		"codeBuffer",
		"currentBitCount",
		"nBits",
		"currentBitCount",
		"nBits",
		"currentBitCount",
		"currentByte",
		"codeBuffer",
		"currentByte",
		"currentByte",
		"codeBuffer",
		"currentBitCount",
		"currentByte",
		"codeBuffer",
		"bufferCurrentPosition",
		"dataBuffer",
		"bufferCurrentPosition",
		"byteValue",
		"bufferCurrentPosition",
		"byteValue",
		"scanHeader",
		"iComp",
		"acHuffmanTables",
		"sParams",
		"AC",
		"acTable",
		"acTable",
		"k",
		"k",
		"dataUnit",
		"ZigZag8x8",
		"k",
		"acValue",
		"k",
		"ehCodes",
		"ehSizes",
		"r",
		"r",
		"ehCodes",
		"ehSizes",
		"r",
		"acValue",
		"acValue",
		"absACValue",
		"absACValue",
		"absACValue",
		"NBitsTable",
		"absACValue",
		"r",
		"nBits",
		"ehCodes",
		"rs",
		"ehSizes",
		"rs",
		"absACValue",
		"nBits",
		"NBitsTable",
		"acValue",
		"r",
		"nBits",
		"ehCodes",
		"rs",
		"ehSizes",
		"rs",
		"acValue",
		"nBits",
		"r",
		"scanHeader",
		"iComp",
		"dcHuffmanTables",
		"sParams",
		"DC",
		"precedingDCs",
		"iComp",
		"dataUnit",
		"dcValue",
		"lastDC",
		"precedingDCs",
		"iComp",
		"dcValue",
		"diff",
		"diff",
		"NBitsTable",
		"absDiff",
		"dcTable",
		"nBits",
		"dcTable",
		"nBits",
		"absDiff",
		"nBits",
		"NBitsTable",
		"diff",
		"dcTable",
		"nBits",
		"dcTable",
		"nBits",
		"nBits",
		"diff",
		"nBits",
		"scanHeader",
		"dataUnit",
		"iComp",
		"nComponentsInScan",
		"iComp",
		"frameComponents",
		"componentIds",
		"iComp",
		"frameComponent",
		"HI",
		"frameComponent",
		"VI",
		"ivi",
		"vi",
		"ivi",
		"ihi",
		"hi",
		"ihi",
		"dataUnit",
		"iComp",
		"xmcu",
		"ymcu",
		"ihi",
		"ivi",
		"dataUnit",
		"dataUnit",
		"iComp",
		"dataUnit",
		"iComp",
		"dataUnit",
		"iComp",
		"ymcu",
		"interleavedMcuRows",
		"ymcu",
		"xmcu",
		"interleavedMcuCols",
		"xmcu",
		"xmcu",
		"ymcu",
		"currentBitCount",
		"currentByte",
		"iComp",
		"nComponents",
		"iComp",
		"frameComponents",
		"componentIds",
		"iComp",
		"frameComponent",
		"HI",
		"frameComponent",
		"VI",
		"maxH",
		"hi",
		"maxV",
		"vi",
		"upH",
		"upV",
		"imageComponents",
		"iComp",
		"frameComponent",
		"CW",
		"frameComponent",
		"CH",
		"compWidth",
		"upH",
		"compHeight",
		"upV",
		"compWidth",
		"compHeight",
		"rgbs",
		"component",
		"src",
		"upCompWidth",
		"upCompHeight",
		"imageComponents",
		"iComp",
		"dest",
		"diff",
		"ExtendTest",
		"t",
		"diff",
		"ExtendOffset",
		"t",
		"diff",
		"imageComponents",
		"iComp",
		"frameComponents",
		"componentIds",
		"iComp",
		"frameComponent",
		"HI",
		"frameComponent",
		"VI",
		"frameComponent",
		"CW",
		"ymcu",
		"vi",
		"ivi",
		"compWidth",
		"DCTSIZE",
		"xmcu",
		"hi",
		"ihi",
		"DCTSIZE",
		"i",
		"DCTSIZE",
		"i",
		"col",
		"DCTSIZE",
		"col",
		"dataUnit",
		"destIndex",
		"compImage",
		"srcIndex",
		"col",
		"destIndex",
		"srcIndex",
		"compWidth",
		"row",
		"row",
		"row",
		"DCTSIZE",
		"dataUnit",
		"rIndex",
		"dataUnit",
		"rIndex",
		"dataUnit",
		"rIndex",
		"dataUnit",
		"rIndex",
		"dataUnit",
		"rIndex",
		"dataUnit",
		"rIndex",
		"dataUnit",
		"rIndex",
		"dataUnit",
		"rIndex",
		"dataUnit",
		"rIndex",
		"dataUnit",
		"rIndex",
		"dataUnit",
		"rIndex",
		"dataUnit",
		"rIndex",
		"dataUnit",
		"rIndex",
		"dataUnit",
		"rIndex",
		"dataUnit",
		"rIndex",
		"dataUnit",
		"rIndex",
		"tmp0",
		"tmp3",
		"tmp0",
		"tmp3",
		"tmp1",
		"tmp2",
		"tmp1",
		"tmp2",
		"dataUnit",
		"rIndex",
		"tmp10",
		"tmp11",
		"dataUnit",
		"rIndex",
		"tmp10",
		"tmp11",
		"tmp12",
		"tmp13",
		"FIX_0_541196100",
		"ExtendTest",
		"ExtendTest",
		"z1",
		"tmp13",
		"FIX_0_765366865",
		"scaleFactor1",
		"dataUnit",
		"rIndex",
		"n",
		"scaleFactor2",
		"n",
		"n",
		"scaleFactor2",
		"dataUnit",
		"rIndex",
		"n",
		"z1",
		"tmp12",
		"FIX_1_847759065",
		"scaleFactor1",
		"dataUnit",
		"rIndex",
		"n",
		"scaleFactor2",
		"n",
		"n",
		"scaleFactor2",
		"dataUnit",
		"rIndex",
		"z1",
		"tmp4",
		"tmp7",
		"tmp5",
		"tmp6",
		"tmp4",
		"tmp6",
		"tmp5",
		"tmp7",
		"z3",
		"z4",
		"FIX_1_175875602",
		"tmp4",
		"tmp4",
		"FIX_0_298631336",
		"tmp5",
		"tmp5",
		"FIX_2_053119869",
		"tmp6",
		"tmp6",
		"FIX_3_072711026",
		"tmp7",
		"tmp7",
		"FIX_1_501321110",
		"z1",
		"z1",
		"FIX_0_899976223",
		"z2",
		"z2",
		"FIX_2_562915447",
		"z3",
		"z3",
		"FIX_1_961570560",
		"z4",
		"z4",
		"FIX_0_390180644",
		"z3",
		"z3",
		"z5",
		"z4",
		"z4",
		"z5",
		"n",
		"tmp4",
		"z1",
		"z3",
		"scaleFactor1",
		"dataUnit",
		"rIndex",
		"n",
		"scaleFactor2",
		"n",
		"n",
		"scaleFactor2",
		"dataUnit",
		"rIndex",
		"n",
		"tmp5",
		"z2",
		"z4",
		"scaleFactor1",
		"dataUnit",
		"rIndex",
		"n",
		"scaleFactor2",
		"n",
		"n",
		"scaleFactor2",
		"dataUnit",
		"rIndex",
		"n",
		"tmp6",
		"z2",
		"z3",
		"scaleFactor1",
		"dataUnit",
		"rIndex",
		"n",
		"scaleFactor2",
		"n",
		"n",
		"scaleFactor2",
		"dataUnit",
		"rIndex",
		"n",
		"tmp7",
		"z1",
		"z4",
		"scaleFactor1",
		"dataUnit",
		"rIndex",
		"n",
		"scaleFactor2",
		"n",
		"n",
		"scaleFactor2",
		"dataUnit",
		"rIndex",
		"col",
		"col",
		"col",
		"col",
		"col",
		"col",
		"col",
		"col",
		"col",
		"col",
		"dataUnit",
		"c0",
		"dataUnit",
		"c7",
		"dataUnit",
		"c0",
		"dataUnit",
		"c7",
		"dataUnit",
		"c1",
		"dataUnit",
		"c6",
		"dataUnit",
		"c1",
		"dataUnit",
		"c6",
		"dataUnit",
		"c2",
		"dataUnit",
		"c5",
		"dataUnit",
		"c2",
		"dataUnit",
		"c5",
		"dataUnit",
		"c3",
		"dataUnit",
		"c4",
		"dataUnit",
		"c3",
		"dataUnit",
		"c4",
		"tmp0",
		"tmp3",
		"tmp0",
		"tmp3",
		"tmp1",
		"tmp2",
		"tmp1",
		"tmp2",
		"ExtendTest",
		"ExtendTest",
		"tmp10",
		"tmp11",
		"scaleFactor1",
		"dataUnit",
		"c0",
		"n",
		"scaleFactor2",
		"n",
		"n",
		"scaleFactor2",
		"dataUnit",
		"c0",
		"n",
		"tmp10",
		"tmp11",
		"scaleFactor1",
		"dataUnit",
		"c4",
		"n",
		"scaleFactor2",
		"n",
		"n",
		"scaleFactor2",
		"dataUnit",
		"c4",
		"tmp12",
		"tmp13",
		"FIX_0_541196100",
		"scaleFactor1",
		"ExtendTest",
		"scaleFactor2",
		"ExtendTest",
		"n",
		"z1",
		"tmp13",
		"FIX_0_765366865",
		"scaleFactor1",
		"dataUnit",
		"c2",
		"n",
		"scaleFactor2",
		"n",
		"n",
		"scaleFactor2",
		"dataUnit",
		"c2",
		"n",
		"z1",
		"tmp12",
		"FIX_1_847759065",
		"scaleFactor1",
		"dataUnit",
		"c6",
		"n",
		"scaleFactor2",
		"n",
		"n",
		"scaleFactor2",
		"dataUnit",
		"c6",
		"z1",
		"tmp4",
		"tmp7",
		"tmp5",
		"tmp6",
		"tmp4",
		"tmp6",
		"tmp5",
		"tmp7",
		"z3",
		"z4",
		"FIX_1_175875602",
		"tmp4",
		"tmp4",
		"FIX_0_298631336",
		"tmp5",
		"tmp5",
		"FIX_2_053119869",
		"tmp6",
		"tmp6",
		"FIX_3_072711026",
		"tmp7",
		"tmp7",
		"FIX_1_501321110",
		"z1",
		"z1",
		"FIX_0_899976223",
		"z2",
		"z2",
		"FIX_2_562915447",
		"z3",
		"z3",
		"FIX_1_961570560",
		"z4",
		"z4",
		"FIX_0_390180644",
		"z3",
		"z3",
		"z5",
		"z4",
		"z4",
		"z5",
		"n",
		"tmp4",
		"z1",
		"z3",
		"scaleFactor1",
		"dataUnit",
		"c7",
		"n",
		"scaleFactor2",
		"n",
		"n",
		"scaleFactor2",
		"dataUnit",
		"c7",
		"n",
		"tmp5",
		"z2",
		"z4",
		"scaleFactor1",
		"dataUnit",
		"c5",
		"n",
		"scaleFactor2",
		"n",
		"n",
		"scaleFactor2",
		"dataUnit",
		"c5",
		"n",
		"tmp6",
		"z2",
		"z3",
		"scaleFactor1",
		"dataUnit",
		"c3",
		"n",
		"scaleFactor2",
		"n",
		"n",
		"scaleFactor2",
		"dataUnit",
		"c3",
		"n",
		"tmp7",
		"z1",
		"z4",
		"scaleFactor1",
		"dataUnit",
		"c1",
		"n",
		"scaleFactor2",
		"n",
		"n",
		"scaleFactor2",
		"dataUnit",
		"c1",
		"inputStream",
		"appn",
		"SWT",
		"SWT",
		"inputStream",
		"inputStream",
		"inputStream",
		"dht",
		"SWT",
		"SWT",
		"acHuffmanTables",
		"acHuffmanTables",
		"dcHuffmanTables",
		"dcHuffmanTables",
		"dht",
		"i",
		"dhtTables",
		"i",
		"dhtTables",
		"i",
		"dhtTable",
		"dcHuffmanTables",
		"dhtTable",
		"dhtTable",
		"acHuffmanTables",
		"dhtTable",
		"dhtTable",
		"inputStream",
		"inputStream",
		"quantizationTables",
		"currentTables",
		"currentTables",
		"dqt",
		"dqt",
		"i",
		"dqtTablesKeys",
		"i",
		"dqtTablesKeys",
		"i",
		"currentTables",
		"index",
		"dqtTablesValues",
		"i",
		"quantizationTables",
		"currentTables",
		"inputStream",
		"dri",
		"SWT",
		"SWT",
		"restartInterval",
		"dri",
		"NBitsTable",
		"NBitsTable",
		"i",
		"NBitsTable",
		"i",
		"i",
		"power2",
		"nBits",
		"power2",
		"NBitsTable",
		"i",
		"nBits",
		"RYTable",
		"GYTable",
		"BYTable",
		"RCbTable",
		"GCbTable",
		"BCbTable",
		"RCrTable",
		"BCbTable",
		"GCrTable",
		"BCrTable",
		"i",
		"i",
		"RYTable",
		"i",
		"i",
		"GYTable",
		"i",
		"i",
		"BYTable",
		"i",
		"i",
		"RCbTable",
		"i",
		"i",
		"GCbTable",
		"i",
		"i",
		"BCbTable",
		"i",
		"i",
		"GCrTable",
		"i",
		"i",
		"BCrTable",
		"i",
		"i",
		"CrRTable",
		"CbBTable",
		"CrGTable",
		"CbGTable",
		"i",
		"i",
		"i",
		"CrRTable",
		"i",
		"x2",
		"CbBTable",
		"i",
		"x2",
		"CrGTable",
		"i",
		"x2",
		"CbGTable",
		"i",
		"x2",
		"row",
		"row",
		"row",
		"DCTSIZE",
		"dataUnit",
		"rIndex",
		"dataUnit",
		"rIndex",
		"rIndex",
		"i",
		"rIndex",
		"i",
		"dataUnit",
		"i",
		"dcVal",
		"dataUnit",
		"rIndex",
		"dataUnit",
		"rIndex",
		"z2",
		"z3",
		"FIX_0_541196100",
		"z1",
		"z3",
		"FIX_1_847759065",
		"z1",
		"z2",
		"FIX_0_765366865",
		"dataUnit",
		"rIndex",
		"dataUnit",
		"rIndex",
		"dataUnit",
		"rIndex",
		"dataUnit",
		"rIndex",
		"tmp0",
		"tmp3",
		"tmp0",
		"tmp3",
		"tmp1",
		"tmp2",
		"tmp1",
		"tmp2",
		"tmp0",
		"dataUnit",
		"rIndex",
		"tmp1",
		"dataUnit",
		"rIndex",
		"tmp2",
		"dataUnit",
		"rIndex",
		"tmp3",
		"dataUnit",
		"rIndex",
		"z1",
		"tmp0",
		"tmp3",
		"z2",
		"tmp1",
		"tmp2",
		"z3",
		"tmp0",
		"tmp2",
		"tmp1",
		"tmp3",
		"z3",
		"z4",
		"FIX_1_175875602",
		"tmp0",
		"tmp0",
		"FIX_0_298631336",
		"tmp1",
		"tmp1",
		"FIX_2_053119869",
		"tmp2",
		"tmp2",
		"FIX_3_072711026",
		"tmp3",
		"tmp3",
		"FIX_1_501321110",
		"z1",
		"z1",
		"FIX_0_899976223",
		"z2",
		"z2",
		"FIX_2_562915447",
		"z3",
		"z3",
		"FIX_1_961570560",
		"z4",
		"z4",
		"FIX_0_390180644",
		"z3",
		"z3",
		"z5",
		"z4",
		"z4",
		"z5",
		"tmp0",
		"tmp0",
		"z1",
		"z3",
		"tmp1",
		"tmp1",
		"z2",
		"z4",
		"tmp2",
		"tmp2",
		"z2",
		"z3",
		"tmp3",
		"tmp3",
		"z1",
		"z4",
		"ExtendTest",
		"ExtendTest",
		"dataUnit",
		"rIndex",
		"tmp10",
		"tmp3",
		"descaleFactor1",
		"descaleFactor2",
		"dataUnit",
		"rIndex",
		"tmp10",
		"tmp3",
		"descaleFactor1",
		"descaleFactor2",
		"dataUnit",
		"rIndex",
		"tmp11",
		"tmp2",
		"descaleFactor1",
		"descaleFactor2",
		"dataUnit",
		"rIndex",
		"tmp11",
		"tmp2",
		"descaleFactor1",
		"descaleFactor2",
		"dataUnit",
		"rIndex",
		"tmp12",
		"tmp1",
		"descaleFactor1",
		"descaleFactor2",
		"dataUnit",
		"rIndex",
		"tmp12",
		"tmp1",
		"descaleFactor1",
		"descaleFactor2",
		"dataUnit",
		"rIndex",
		"tmp13",
		"tmp0",
		"descaleFactor1",
		"descaleFactor2",
		"dataUnit",
		"rIndex",
		"tmp13",
		"tmp0",
		"descaleFactor1",
		"descaleFactor2",
		"col",
		"col",
		"col",
		"col",
		"col",
		"col",
		"col",
		"col",
		"col",
		"col",
		"dataUnit",
		"col",
		"dataUnit",
		"c0",
		"dataUnit",
		"c0",
		"dcVal",
		"dataUnit",
		"c1",
		"dcVal",
		"dataUnit",
		"c2",
		"dcVal",
		"dataUnit",
		"c3",
		"dcVal",
		"dataUnit",
		"c4",
		"dcVal",
		"dataUnit",
		"c5",
		"dcVal",
		"dataUnit",
		"c6",
		"dcVal",
		"dataUnit",
		"c7",
		"dcVal",
		"dataUnit",
		"c2",
		"dataUnit",
		"c6",
		"z2",
		"z3",
		"FIX_0_541196100",
		"z1",
		"z3",
		"FIX_1_847759065",
		"z1",
		"z2",
		"FIX_0_765366865",
		"dataUnit",
		"c0",
		"dataUnit",
		"c4",
		"dataUnit",
		"c0",
		"dataUnit",
		"c4",
		"tmp0",
		"tmp3",
		"tmp0",
		"tmp3",
		"tmp1",
		"tmp2",
		"tmp1",
		"tmp2",
		"tmp0",
		"dataUnit",
		"c7",
		"tmp1",
		"dataUnit",
		"c5",
		"tmp2",
		"dataUnit",
		"c3",
		"tmp3",
		"dataUnit",
		"c1",
		"z1",
		"tmp0",
		"tmp3",
		"z2",
		"tmp1",
		"tmp2",
		"z3",
		"tmp0",
		"tmp2",
		"tmp1",
		"tmp3",
		"z3",
		"z4",
		"FIX_1_175875602",
		"tmp0",
		"tmp0",
		"FIX_0_298631336",
		"tmp1",
		"tmp1",
		"FIX_2_053119869",
		"tmp2",
		"tmp2",
		"FIX_3_072711026",
		"tmp3",
		"tmp3",
		"FIX_1_501321110",
		"z1",
		"z1",
		"FIX_0_899976223",
		"z2",
		"z2",
		"FIX_2_562915447",
		"z3",
		"z3",
		"FIX_1_961570560",
		"z4",
		"z4",
		"FIX_0_390180644",
		"z3",
		"z3",
		"z5",
		"z4",
		"z4",
		"z5",
		"tmp0",
		"tmp0",
		"z1",
		"z3",
		"tmp1",
		"tmp1",
		"z2",
		"z4",
		"tmp2",
		"tmp2",
		"z2",
		"z3",
		"tmp3",
		"tmp3",
		"z1",
		"z4",
		"ExtendTest",
		"ExtendTest",
		"dataUnit",
		"c0",
		"tmp10",
		"tmp3",
		"descaleFactor1",
		"descaleFactor2",
		"dataUnit",
		"c7",
		"tmp10",
		"tmp3",
		"descaleFactor1",
		"descaleFactor2",
		"dataUnit",
		"c1",
		"tmp11",
		"tmp2",
		"descaleFactor1",
		"descaleFactor2",
		"dataUnit",
		"c6",
		"tmp11",
		"tmp2",
		"descaleFactor1",
		"descaleFactor2",
		"dataUnit",
		"c2",
		"tmp12",
		"tmp1",
		"descaleFactor1",
		"descaleFactor2",
		"dataUnit",
		"c5",
		"tmp12",
		"tmp1",
		"descaleFactor1",
		"descaleFactor2",
		"dataUnit",
		"c3",
		"tmp13",
		"tmp0",
		"descaleFactor1",
		"descaleFactor2",
		"dataUnit",
		"c4",
		"tmp13",
		"tmp0",
		"descaleFactor1",
		"descaleFactor2",
		"stream",
		"stream",
		"soi",
		"soi",
		"dataUnit",
		"col",
		"dataUnit",
		"col",
		"dataUnit",
		"col",
		"dataUnit",
		"col",
		"dataUnit",
		"col",
		"dataUnit",
		"col",
		"dataUnit",
		"col",
		"dataUnit",
		"rIndex",
		"dataUnit",
		"rIndex",
		"dataUnit",
		"rIndex",
		"dataUnit",
		"rIndex",
		"dataUnit",
		"rIndex",
		"dataUnit",
		"rIndex",
		"dataUnit",
		"rIndex",
		"inputStream",
		"soi",
		"SWT",
		"SWT",
		"restartInterval",
		"frameHeader",
		"inputStream",
		"frameHeader",
		"SWT",
		"SWT",
		"imageWidth",
		"frameHeader",
		"imageHeight",
		"frameHeader",
		"maxH",
		"frameHeader",
		"maxV",
		"frameHeader",
		"maxH",
		"DCTSIZE",
		"maxV",
		"DCTSIZE",
		"interleavedMcuCols",
		"imageWidth",
		"mcuWidth",
		"mcuWidth",
		"interleavedMcuRows",
		"imageHeight",
		"mcuHeight",
		"mcuHeight",
		"progressive",
		"frameHeader",
		"samplePrecision",
		"frameHeader",
		"nComponents",
		"frameHeader",
		"frameComponents",
		"frameHeader",
		"componentIds",
		"frameHeader",
		"imageComponents",
		"nComponents",
		"progressive",
		"dataUnits",
		"nComponents",
		"dataUnit",
		"i",
		"nComponents",
		"i",
		"frameComponents",
		"componentIds",
		"i",
		"frameComponent",
		"CW",
		"frameComponent",
		"CH",
		"imageComponents",
		"i",
		"bufferSize",
		"progressive",
		"dataUnits",
		"i",
		"bufferSize",
		"scanHeader",
		"inputStream",
		"scanHeader",
		"SWT",
		"SWT",
		"done",
		"precedingDCs",
		"progressive",
		"loader",
		"loader",
		"loader",
		"imageData",
		"progressiveScanCount",
		"progressiveScanCount",
		"bufferCurrentPosition",
		"delta",
		"delta",
		"System",
		"dataBuffer",
		"bufferCurrentPosition",
		"unreadBuffer",
		"delta",
		"inputStream",
		"unreadBuffer",
		"SWT",
		"SWT",
		"e",
		"jpegSegment",
		"jpegSegment",
		"EOI",
		"done",
		"scanHeader",
		"inputStream",
		"scanHeader",
		"SWT",
		"SWT",
		"progressive",
		"ymcu",
		"interleavedMcuRows",
		"ymcu",
		"xmcu",
		"interleavedMcuCols",
		"xmcu",
		"iComp",
		"nComponents",
		"iComp",
		"frameComponents",
		"componentIds",
		"iComp",
		"frameComponent",
		"HI",
		"frameComponent",
		"VI",
		"frameComponent",
		"CW",
		"ivi",
		"vi",
		"ivi",
		"ihi",
		"hi",
		"ihi",
		"ymcu",
		"vi",
		"ivi",
		"compWidth",
		"xmcu",
		"hi",
		"ihi",
		"dataUnit",
		"dataUnits",
		"iComp",
		"index",
		"dataUnit",
		"iComp",
		"dataUnit",
		"dataUnit",
		"iComp",
		"xmcu",
		"ymcu",
		"hi",
		"ihi",
		"vi",
		"ivi",
		"progressive",
		"loader",
		"loader",
		"loader",
		"imageData",
		"progressiveScanCount",
		"imageData",
		"ImageData",
		"imageWidth",
		"imageHeight",
		"nComponents",
		"samplePrecision",
		"nComponents",
		"SWT",
		"currentBitCount",
		"currentBitCount",
		"currentByte",
		"currentByte",
		"currentByte",
		"bufferCurrentPosition",
		"bufferCurrentPosition",
		"bufferCurrentPosition",
		"currentByte",
		"dataBuffer",
		"bufferCurrentPosition",
		"currentBitCount",
		"bufferCurrentPosition",
		"currentBitCount",
		"nextByte",
		"dataBuffer",
		"nextByte",
		"dataBuffer",
		"bufferCurrentPosition",
		"currentByte",
		"nextByte",
		"bufferCurrentPosition",
		"currentBitCount",
		"currentByte",
		"currentByte",
		"currentByte",
		"nextByte",
		"DNL",
		"SWT",
		"SWT",
		"currentBitCount",
		"currentByte",
		"currentByte",
		"currentByte",
		"bufferCurrentPosition",
		"bufferCurrentPosition",
		"bufferCurrentPosition",
		"currentByte",
		"dataBuffer",
		"bufferCurrentPosition",
		"currentByte",
		"currentByte",
		"bufferCurrentPosition",
		"bufferCurrentPosition",
		"bufferCurrentPosition",
		"currentByte",
		"dataBuffer",
		"bufferCurrentPosition",
		"currentByte",
		"RST0",
		"nextRestartNumber",
		"SWT",
		"SWT",
		"bufferCurrentPosition",
		"bufferCurrentPosition",
		"bufferCurrentPosition",
		"currentByte",
		"dataBuffer",
		"bufferCurrentPosition",
		"currentBitCount",
		"restartsToGo",
		"restartInterval",
		"nextRestartNumber",
		"nextRestartNumber",
		"precedingDCs",
		"eobrun",
		"inputStream",
		"jpegSegment",
		"jpegSegment",
		"sof",
		"jpegSegment",
		"jpegSegment",
		"marker",
		"SOI",
		"SWT",
		"SWT",
		"EOI",
		"SOS",
		"jpegSegment",
		"DQT",
		"DHT",
		"DAC",
		"DRI",
		"APP0",
		"COM",
		"inputStream",
		"quantizationTables",
		"frameComponents",
		"componentIds",
		"iComp",
		"TQI",
		"i",
		"dataUnit",
		"i",
		"ZigZag8x8",
		"i",
		"dataUnit",
		"zzIndex",
		"data",
		"data",
		"data",
		"qTable",
		"i",
		"qValue",
		"absData",
		"q2",
		"absData",
		"qValue",
		"dataUnit",
		"zzIndex",
		"absData",
		"qValue",
		"data",
		"dataUnit",
		"zzIndex",
		"absData",
		"dataUnit",
		"zzIndex",
		"absData",
		"i",
		"nBits",
		"i",
		"v",
		"v",
		"v",
		"dataBuffer",
		"dataBuffer",
		"inputStream",
		"dataBuffer",
		"SWT",
		"SWT",
		"e",
		"currentBitCount",
		"bufferCurrentPosition",
		"dataBuffer",
		"dataBuffer",
		"outputStream",
		"dataBuffer",
		"bufferCurrentPosition",
		"SWT",
		"SWT",
		"e",
		"bufferCurrentPosition",
		"byteStream",
		"byteArray",
		"byteArray",
		"byteStream",
		"byteArray",
		"byteArray",
		"byteArray",
		"byteStream",
		"byteArray",
		"byteArray",
		"SWT",
		"SWT",
		"e",
		"nComponents",
		"i",
		"i",
		"entries",
		"i",
		"i",
		"i",
		"i",
		"entries",
		"byteArray",
		"byteStream",
		"byteArray",
		"byteArray",
		"SWT",
		"SWT",
		"byteArray",
		"byteArray",
		"byteArray",
		"SWT",
		"SWT",
		"jpegSegment",
		"byteStream",
		"delta",
		"SWT",
		"SWT",
		"e",
		"imageComponents",
		"iComp",
		"frameComponents",
		"componentIds",
		"iComp",
		"frameComponent",
		"CW",
		"ymcu",
		"vi",
		"ivi",
		"compWidth",
		"DCTSIZE",
		"xmcu",
		"hi",
		"ihi",
		"DCTSIZE",
		"i",
		"DCTSIZE",
		"i",
		"col",
		"DCTSIZE",
		"col",
		"dataUnit",
		"srcIndex",
		"x",
		"x",
		"x",
		"x",
		"compImage",
		"destIndex",
		"col",
		"x",
		"srcIndex",
		"destIndex",
		"compWidth",
		"outputStream",
		"SWT",
		"SWT",
		"appn",
		"outputStream",
		"SWT",
		"SWT",
		"quantizationTables",
		"JPEGQuantizationTable",
		"chromDQT",
		"encoderQFactor",
		"chromDQT",
		"chromDQT",
		"i",
		"jpegDQTKeys",
		"i",
		"quantizationTables",
		"jpegDQTKeys",
		"i",
		"jpegDQTValues",
		"i",
		"JPEGQuantizationTable",
		"lumDQT",
		"encoderQFactor",
		"jpegDQTKeys",
		"lumDQT",
		"jpegDQTValues",
		"lumDQT",
		"i",
		"jpegDQTKeys",
		"i",
		"quantizationTables",
		"jpegDQTKeys",
		"i",
		"jpegDQTValues",
		"i",
		"lumDQT",
		"outputStream",
		"SWT",
		"SWT",
		"chromDQT",
		"outputStream",
		"SWT",
		"SWT",
		"image",
		"frameLength",
		"frameParams",
		"frameParams",
		"scanParams",
		"scanParams",
		"scanLength",
		"nComponents",
		"precision",
		"frameLength",
		"frameParams",
		"frameParams",
		"frameParams",
		"frameParams",
		"scanParams",
		"scanParams",
		"scanParams",
		"scanParams",
		"scanLength",
		"nComponents",
		"precision",
		"imageWidth",
		"image",
		"imageHeight",
		"image",
		"frameHeader",
		"frameHeader",
		"SOF0",
		"frameHeader",
		"frameLength",
		"frameHeader",
		"precision",
		"frameHeader",
		"imageWidth",
		"frameHeader",
		"imageHeight",
		"frameHeader",
		"nComponents",
		"frameHeader",
		"frameParams",
		"frameHeader",
		"frameHeader",
		"frameHeader",
		"outputStream",
		"SWT",
		"SWT",
		"frameComponents",
		"frameParams",
		"componentIds",
		"frameHeader",
		"maxH",
		"frameHeader",
		"maxV",
		"frameHeader",
		"maxH",
		"DCTSIZE",
		"maxV",
		"DCTSIZE",
		"interleavedMcuCols",
		"imageWidth",
		"mcuWidth",
		"mcuWidth",
		"interleavedMcuRows",
		"imageHeight",
		"mcuHeight",
		"mcuHeight",
		"acHuffmanTables",
		"dcHuffmanTables",
		"JPEGHuffmanTable",
		"JPEGHuffmanTable",
		"JPEGHuffmanTable",
		"JPEGHuffmanTable",
		"i",
		"dhtTables",
		"i",
		"dhtTables",
		"i",
		"dhtTable",
		"outputStream",
		"SWT",
		"SWT",
		"dhtTable",
		"j",
		"allTables",
		"j",
		"allTables",
		"j",
		"huffmanTable",
		"dcHuffmanTables",
		"huffmanTable",
		"huffmanTable",
		"acHuffmanTables",
		"huffmanTable",
		"huffmanTable",
		"precedingDCs",
		"scanHeader",
		"scanHeader",
		"SOS",
		"scanHeader",
		"scanLength",
		"scanHeader",
		"nComponents",
		"scanHeader",
		"scanHeader",
		"scanHeader",
		"scanParams",
		"scanHeader",
		"scanHeader",
		"outputStream",
		"SWT",
		"SWT",
		"image",
		"currentByte",
		"currentBitCount",
		"outputStream",
		"SWT",
		"SWT",
		"width",
		"height",
		"length",
		"width",
		"height",
		"red",
		"green",
		"blue",
		"data",
		"bytesPerLine",
		"length",
		"width",
		"height",
		"red",
		"green",
		"blue",
		"width",
		"data",
		"depth",
		"ERROR_UNSUPPORTED_DEPTH",
		"width",
		"height",
		"palette",
		"isDirect",
		"redMask",
		"greenMask",
		"blueMask",
		"redShift",
		"greenShift",
		"blueShift",
		"red",
		"green",
		"blue",
		"componentParameters",
		"componentParameters",
		"componentParameters",
		"componentParameters",
		"length",
		"length",
		"length",
		"length",
		"componentParameters",
		"length",
		"ERROR_INVALID_IMAGE",
		"componentParameters",
		"ERROR_INVALID_IMAGE",
		"componentParameters",
		"ehCodes",
		"ehCodeLengths",
		"componentParameters",
		"ehCodes",
		"ehCodeLengths",
		"ehCodes",
		"ehCodeLengths",
		"data",
		"ERROR_INVALID_IMAGE",
		"ERROR_INVALID_IMAGE",
		"length",
		"length",
		"ERROR_INVALID_IMAGE",
		"length",
		"reference",
		"ERROR_INVALID_IMAGE",
		"ERROR_INVALID_IMAGE",
		"componentParameters",
		"componentIdentifiers",
		"ERROR_INVALID_IMAGE",
		"ERROR_IO",
		"ERROR_INVALID_IMAGE",
		"IMAGE_JPEG",
		"ERROR_INVALID_IMAGE",
		"ERROR_INVALID_IMAGE",
		"reference",
		"ERROR_INVALID_IMAGE",
		"length",
		"ERROR_IO",
		"ERROR_IO",
		"ERROR_IO",
		"length",
		"ERROR_INVALID_IMAGE",
		"ERROR_INVALID_IMAGE",
		"ERROR_IO",
		"ERROR_IO",
		"ERROR_IO",
		"length",
		"length",
		"ERROR_IO",
		"ERROR_IO",
		"depth",
		"width",
		"height",
		"componentParameters",
		"componentIdentifiers",
		"ERROR_IO",
		"componentIdentifiers",
		"length",
		"ERROR_IO",
		"length",
		"componentParameters",
		"ERROR_IO",
		"ERROR_IO",
		"image",
		"dataYComp",
		"dataCbComp",
		"dataCrComp",
		"image",
		"image",
		"image",
		"image",
		"dataUnit",
		"iComp",
		"dataUnit",
		"iComp",
		"start",
		"end",
		"approxBit",
		"dataUnit",
		"iComp",
		"start",
		"end",
		"approxBit",
		"ac",
		"approxBit",
		"dataUnit",
		"iComp",
		"first",
		"approxBit",
		"dataUnit",
		"iComp",
		"xmcu",
		"ymcu",
		"nComponentsInScan",
		"first",
		"start",
		"end",
		"approxBit",
		"huffmanTable",
		"huffCode",
		"nBits",
		"byteValue",
		"dataUnit",
		"iComp",
		"dataUnit",
		"iComp",
		"xmcu",
		"ymcu",
		"diff",
		"t",
		"dataUnit",
		"iComp",
		"xmcu",
		"ymcu",
		"ihi",
		"ivi",
		"dataUnit",
		"dataUnit",
		"stream",
		"e",
		"dataUnit",
		"col",
		"dataUnit",
		"rIndex",
		"e",
		"dataUnit",
		"iComp",
		"nBits",
		"e",
		"e",
		"byteStream",
		"e",
		"byteStream",
		"e",
		"dataUnit",
		"iComp",
		"xmcu",
		"ymcu",
		"hi",
		"ihi",
		"vi",
		"ivi",
		"image"
	],
	"extendORImplementFiles":[
		"FileFormat"
	],
	"package":[
		"org.eclipse.swt.internal.image"
	],
	"import":[
		"org.eclipse.swt",
		"org.eclipse.swt.graphics",
		"java.io"
	],
	"methods":[
		"compress",
		"convert4BitRGBToYCbCr",
		"convert8BitRGBToYCbCr",
		"convertCMYKToRGB",
		"convertImageToYCbCr",
		"convertMultiRGBToYCbCr",
		"convertYToRGB",
		"convertYCbCrToRGB",
		"convertYIQToRGB",
		"decodeACCoefficients",
		"decodeACFirstCoefficients",
		"decodeACRefineCoefficients",
		"refineAC",
		"decodeDCCoefficient",
		"dequantize",
		"decodeImageComponents",
		"decodeMCUAtXAndY",
		"decodeScan",
		"decodeUsingTable",
		"emit",
		"emitByte",
		"encodeACCoefficients",
		"encodeDCCoefficients",
		"encodeMCUAtXAndY",
		"encodeScan",
		"expandImageComponents",
		"extendBy",
		"extractData",
		"forwardDCT",
		"getAPP0",
		"getCOM",
		"getDAC",
		"getDHT",
		"getDNL",
		"getDQT",
		"getDRI",
		"initialize",
		"initializeBitCountTable",
		"initializeRGBYCbCrTables",
		"initializeYCbCrRGBTables",
		"inverseDCT",
		"isFileFormat",
		"isZeroInColumn",
		"isZeroInRow",
		"loadFromByteStream",
		"createImageData",
		"nextBit",
		"processRestartInterval",
		"processTables",
		"quantizeData",
		"receive",
		"resetInputBuffer",
		"resetOutputBuffer",
		"seekUnspecifiedMarker",
		"setUpPalette",
		"skipSegmentFrom",
		"storeData",
		"unloadIntoByteStream",
		"initialize",
		"arraycopy",
		"arraycopy",
		"getRGBs",
		"compress",
		"getRGBs",
		"compress",
		"convert4BitRGBToYCbCr",
		"convert8BitRGBToYCbCr",
		"convertMultiRGBToYCbCr",
		"error",
		"getPixels",
		"getPixels",
		"getRGB",
		"compress",
		"expandImageComponents",
		"decodeUsingTable",
		"receive",
		"extendBy",
		"decodeUsingTable",
		"receive",
		"receive",
		"extendBy",
		"refineAC",
		"decodeUsingTable",
		"refineAC",
		"receive",
		"receive",
		"refineAC",
		"nextBit",
		"nextBit",
		"nextBit",
		"decodeUsingTable",
		"receive",
		"extendBy",
		"convertYCbCrToRGB",
		"convertYIQToRGB",
		"convertCMYKToRGB",
		"convertYToRGB",
		"isDCProgressiveScan",
		"decodeDCCoefficient",
		"decodeACCoefficients",
		"isACProgressiveScan",
		"decodeACFirstCoefficients",
		"decodeACRefineCoefficients",
		"hasListeners",
		"arraycopy",
		"hasListeners",
		"dequantize",
		"inverseDCT",
		"storeData",
		"verifyProgressiveScan",
		"error",
		"getNumberOfImageComponents",
		"isFirstScan",
		"getStartOfSpectralSelection",
		"getEndOfSpectralSelection",
		"getApproxBitPositionLow",
		"processRestartInterval",
		"decodeMCUAtXAndY",
		"getDhMaxCodes",
		"getDhMinCodes",
		"getDhValPtrs",
		"getDhValues",
		"nextBit",
		"nextBit",
		"error",
		"emitByte",
		"emitByte",
		"emitByte",
		"resetOutputBuffer",
		"emitByte",
		"emit",
		"emit",
		"emit",
		"emit",
		"emit",
		"emit",
		"emit",
		"emit",
		"emit",
		"emit",
		"getNumberOfImageComponents",
		"extractData",
		"forwardDCT",
		"quantizeData",
		"encodeDCCoefficients",
		"encodeACCoefficients",
		"encodeMCUAtXAndY",
		"emitByte",
		"resetOutputBuffer",
		"scaledTo",
		"verify",
		"error",
		"verify",
		"error",
		"getAllTables",
		"getTableClass",
		"getTableIdentifier",
		"getTableIdentifier",
		"getQuantizationTablesKeys",
		"getQuantizationTablesValues",
		"verify",
		"error",
		"getRestartInterval",
		"initializeRGBYCbCrTables",
		"initializeYCbCrRGBTables",
		"initializeBitCountTable",
		"isZeroInRow",
		"isZeroInColumn",
		"unread",
		"verify",
		"verify",
		"error",
		"processTables",
		"verify",
		"error",
		"getSamplesPerLine",
		"getNumberOfLines",
		"getMaxHFactor",
		"getMaxVFactor",
		"isProgressive",
		"getSamplePrecision",
		"getNumberOfImageComponents",
		"processTables",
		"verify",
		"error",
		"resetInputBuffer",
		"decodeScan",
		"hasListeners",
		"createImageData",
		"notifyListeners",
		"arraycopy",
		"unread",
		"error",
		"processTables",
		"getSegmentMarker",
		"verify",
		"error",
		"dequantize",
		"inverseDCT",
		"storeData",
		"createImageData",
		"hasListeners",
		"notifyListeners",
		"internal_new",
		"setUpPalette",
		"decodeImageComponents",
		"resetInputBuffer",
		"resetInputBuffer",
		"getDNL",
		"error",
		"resetInputBuffer",
		"resetInputBuffer",
		"error",
		"resetInputBuffer",
		"seekUnspecifiedMarker",
		"verify",
		"getSegmentMarker",
		"error",
		"getDQT",
		"getDHT",
		"getDAC",
		"getDRI",
		"getAPP0",
		"getCOM",
		"skipSegmentFrom",
		"nextBit",
		"read",
		"error",
		"write",
		"error",
		"read",
		"read",
		"unread",
		"error",
		"read",
		"error",
		"error",
		"getSegmentLength",
		"skip",
		"error",
		"writeToStream",
		"error",
		"writeToStream",
		"error",
		"defaultChrominanceTable",
		"scaleBy",
		"getQuantizationTablesKeys",
		"getQuantizationTablesValues",
		"defaultLuminanceTable",
		"scaleBy",
		"getQuantizationTablesKeys",
		"getQuantizationTablesValues",
		"writeToStream",
		"error",
		"writeToStream",
		"error",
		"setSegmentMarker",
		"setSegmentLength",
		"setSamplePrecision",
		"setSamplesPerLine",
		"setNumberOfLines",
		"setNumberOfImageComponents",
		"initializeContents",
		"writeToStream",
		"error",
		"getMaxHFactor",
		"getMaxVFactor",
		"getDefaultDCLuminanceTable",
		"getDefaultDCChrominanceTable",
		"getDefaultACLuminanceTable",
		"getDefaultACChrominanceTable",
		"writeToStream",
		"error",
		"getAllTables",
		"getTableClass",
		"getTableIdentifier",
		"getTableIdentifier",
		"setSegmentMarker",
		"setSegmentLength",
		"setNumberOfImageComponents",
		"setStartOfSpectralSelection",
		"setEndOfSpectralSelection",
		"initializeContents",
		"writeToStream",
		"error",
		"convertImageToYCbCr",
		"resetOutputBuffer",
		"encodeScan",
		"writeToStream",
		"error",
		"RGB",
		"RGB",
		"RGB",
		"RGB",
		"RGB",
		"RGB",
		"RGB",
		"RGB",
		"RGB",
		"RGB",
		"RGB",
		"RGB",
		"RGB",
		"RGB",
		"RGB",
		"RGB",
		"ImageData",
		"PaletteData",
		"JPEGAppn",
		"JPEGComment",
		"JPEGArithmeticConditioningTable",
		"JPEGHuffmanTable",
		"JPEGRestartInterval",
		"JPEGQuantizationTable",
		"JPEGRestartInterval",
		"JPEGStartOfImage",
		"JPEGStartOfImage",
		"JPEGFrameHeader",
		"JPEGScanHeader",
		"ImageLoaderEvent",
		"JPEGScanHeader",
		"ImageLoaderEvent",
		"JPEGFrameHeader",
		"JPEGSegment",
		"RGB",
		"PaletteData",
		"PaletteData",
		"JPEGSegment",
		"JPEGStartOfImage",
		"JPEGAppn",
		"JPEGFrameHeader",
		"JPEGScanHeader",
		"JPEGEndOfImage"
	],
	"methodsBody":{
		"void expandImageComponents()":{
			"methodBody":"{\n    for (int iComp = 0; iComp < nComponents; iComp++) {\n        int[] frameComponent = frameComponents[componentIds[iComp]];\n        int hi = frameComponent[HI];\n        int vi = frameComponent[VI];\n        int upH = maxH / hi;\n        int upV = maxV / vi;\n        if ((upH * upV) > 1) {\n            byte[] component = imageComponents[iComp];\n            int compWidth = frameComponent[CW];\n            int compHeight = frameComponent[CH];\n            int upCompWidth = compWidth * upH;\n            int upCompHeight = compHeight * upV;\n            RGB[] rgbs = new RGB[] { new RGB(0, 0, 0), new RGB(0x80, 0, 0), new RGB(0, 0x80, 0), new RGB(0x80, 0x80, 0), new RGB(0, 0, 0x80), new RGB(0x80, 0, 0x80), new RGB(0, 0x80, 0x80), new RGB(0xC0, 0xC0, 0xC0), new RGB(0x80, 0x80, 0x80), new RGB(0xFF, 0, 0), new RGB(0, 0xFF, 0), new RGB(0xFF, 0xFF, 0), new RGB(0, 0, 0xFF), new RGB(0xFF, 0, 0xFF), new RGB(0, 0xFF, 0xFF), new RGB(0xFF, 0xFF, 0xFF) };\n            ImageData src = new ImageData(compWidth, compHeight, 8, new PaletteData(rgbs), 4, component);\n            ImageData dest = src.scaledTo(upCompWidth, upCompHeight);\n            imageComponents[iComp] = dest.data;\n        }\n    }\n}",
			"comments":"",
			"methodName":"void expandImageComponents()"
		},
		"void resetInputBuffer()":{
			"methodBody":"{\n    if (dataBuffer == null) {\n        dataBuffer = new byte[512];\n    }\n    try {\n        inputStream.read(dataBuffer);\n    } catch (IOException e) {\n        SWT.error(SWT.ERROR_IO, e);\n    }\n    currentBitCount = 0;\n    bufferCurrentPosition = -1;\n}",
			"comments":"",
			"methodName":"void resetInputBuffer()"
		},
		"void encodeScan()":{
			"methodBody":"{\n    for (int ymcu = 0; ymcu < interleavedMcuRows; ymcu++) {\n        for (int xmcu = 0; xmcu < interleavedMcuCols; xmcu++) {\n            encodeMCUAtXAndY(xmcu, ymcu);\n        }\n    }\n    if (currentBitCount != 0) {\n        emitByte((byte) currentByte);\n    }\n    resetOutputBuffer();\n}",
			"comments":"",
			"methodName":"void encodeScan()"
		},
		"ImageData createImageData()":{
			"methodBody":"{\n    return ImageData.internal_new(imageWidth, imageHeight, nComponents * samplePrecision, setUpPalette(), nComponents == 1 ? 4 : 1, decodeImageComponents(), 0, null, null, -1, -1, SWT.IMAGE_JPEG, 0, 0, 0, 0);\n}",
			"comments":"",
			"methodName":"ImageData createImageData()"
		},
		"static void skipSegmentFrom(LEDataInputStream byteStream)":{
			"methodBody":"{\n    try {\n        byte[] byteArray = new byte[4];\n        JPEGSegment jpegSegment = new JPEGSegment(byteArray);\n        if (byteStream.read(byteArray) != byteArray.length) {\n            SWT.error(SWT.ERROR_INVALID_IMAGE);\n        }\n        if (!(byteArray[0] == -1 && byteArray[1] != 0 && byteArray[1] != -1)) {\n            SWT.error(SWT.ERROR_INVALID_IMAGE);\n        }\n        int delta = jpegSegment.getSegmentLength() - 2;\n        byteStream.skip(delta);\n    } catch (Exception e) {\n        SWT.error(SWT.ERROR_IO, e);\n    }\n}",
			"comments":"",
			"methodName":"static void skipSegmentFrom(LEDataInputStream byteStream)"
		},
		"void getDRI()":{
			"methodBody":"{\n    JPEGRestartInterval dri = new JPEGRestartInterval(inputStream);\n    if (!dri.verify()) {\n        SWT.error(SWT.ERROR_INVALID_IMAGE);\n    }\n    restartInterval = dri.getRestartInterval();\n}",
			"comments":"",
			"methodName":"void getDRI()"
		},
		"boolean isFileFormat(LEDataInputStream stream)":{
			"methodBody":"{\n    try {\n        JPEGStartOfImage soi = new JPEGStartOfImage(stream);\n        stream.unread(soi.reference);\n        \n        return soi.verify();\n    } catch (Exception e) {\n        return false;\n    }\n}",
			"comments":"// we no longer check for appN\n",
			"methodName":"boolean isFileFormat(LEDataInputStream stream)"
		},
		"void decodeScan()":{
			"methodBody":"{\n    if (progressive && !scanHeader.verifyProgressiveScan()) {\n        SWT.error(SWT.ERROR_INVALID_IMAGE);\n    }\n    int nComponentsInScan = scanHeader.getNumberOfImageComponents();\n    int mcuRowsInScan = interleavedMcuRows;\n    int mcusPerRow = interleavedMcuCols;\n    if (nComponentsInScan == 1) {\n        \n        int scanComponent = 0;\n        while (scanHeader.componentParameters[componentIds[scanComponent]] == null) {\n            scanComponent++;\n        }\n        int[] frameComponent = frameComponents[componentIds[scanComponent]];\n        int hi = frameComponent[HI];\n        int vi = frameComponent[VI];\n        int mcuWidth = DCTSIZE * maxH / hi;\n        int mcuHeight = DCTSIZE * maxV / vi;\n        mcusPerRow = (imageWidth + mcuWidth - 1) / mcuWidth;\n        mcuRowsInScan = (imageHeight + mcuHeight - 1) / mcuHeight;\n    }\n    boolean first = scanHeader.isFirstScan();\n    int start = scanHeader.getStartOfSpectralSelection();\n    int end = scanHeader.getEndOfSpectralSelection();\n    int approxBit = scanHeader.getApproxBitPositionLow();\n    restartsToGo = restartInterval;\n    nextRestartNumber = 0;\n    for (int ymcu = 0; ymcu < mcuRowsInScan; ymcu++) {\n        for (int xmcu = 0; xmcu < mcusPerRow; xmcu++) {\n            if (restartInterval != 0) {\n                if (restartsToGo == 0)\n                    processRestartInterval();\n                restartsToGo--;\n            }\n            decodeMCUAtXAndY(xmcu, ymcu, nComponentsInScan, first, start, end, approxBit);\n        }\n    }\n}",
			"comments":"// Non-interleaved.\n",
			"methodName":"void decodeScan()"
		},
		"void unloadIntoByteStream(ImageData image)":{
			"methodBody":"{\n    if (!new JPEGStartOfImage().writeToStream(outputStream)) {\n        SWT.error(SWT.ERROR_IO);\n    }\n    JPEGAppn appn = new JPEGAppn(new byte[] { (byte) 0xFF, (byte) 0xE0, 0, 0x10, 0x4A, 0x46, 0x49, 0x46, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0 });\n    if (!appn.writeToStream(outputStream)) {\n        SWT.error(SWT.ERROR_IO);\n    }\n    quantizationTables = new int[4][];\n    JPEGQuantizationTable chromDQT = JPEGQuantizationTable.defaultChrominanceTable();\n    chromDQT.scaleBy(encoderQFactor);\n    int[] jpegDQTKeys = chromDQT.getQuantizationTablesKeys();\n    int[][] jpegDQTValues = chromDQT.getQuantizationTablesValues();\n    for (int i = 0; i < jpegDQTKeys.length; i++) {\n        quantizationTables[jpegDQTKeys[i]] = jpegDQTValues[i];\n    }\n    JPEGQuantizationTable lumDQT = JPEGQuantizationTable.defaultLuminanceTable();\n    lumDQT.scaleBy(encoderQFactor);\n    jpegDQTKeys = lumDQT.getQuantizationTablesKeys();\n    jpegDQTValues = lumDQT.getQuantizationTablesValues();\n    for (int i = 0; i < jpegDQTKeys.length; i++) {\n        quantizationTables[jpegDQTKeys[i]] = jpegDQTValues[i];\n    }\n    if (!lumDQT.writeToStream(outputStream)) {\n        SWT.error(SWT.ERROR_IO);\n    }\n    if (!chromDQT.writeToStream(outputStream)) {\n        SWT.error(SWT.ERROR_IO);\n    }\n    int frameLength, scanLength, precision;\n    int[][] frameParams, scanParams;\n    if (image.depth == 1) {\n        frameLength = 11;\n        frameParams = new int[1][];\n        frameParams[0] = new int[] { 1, 1, 1, 0, 0 };\n        scanParams = new int[1][];\n        scanParams[0] = new int[] { 0, 0 };\n        scanLength = 8;\n        nComponents = 1;\n        precision = 1;\n    } else {\n        frameLength = 17;\n        frameParams = new int[3][];\n        frameParams[0] = new int[] { 0, 2, 2, 0, 0 };\n        frameParams[1] = new int[] { 1, 1, 1, 0, 0 };\n        frameParams[2] = new int[] { 1, 1, 1, 0, 0 };\n        scanParams = new int[3][];\n        scanParams[0] = new int[] { 0, 0 };\n        scanParams[1] = new int[] { 1, 1 };\n        scanParams[2] = new int[] { 1, 1 };\n        scanLength = 12;\n        nComponents = 3;\n        precision = 8;\n    }\n    imageWidth = image.width;\n    imageHeight = image.height;\n    frameHeader = new JPEGFrameHeader(new byte[19]);\n    frameHeader.setSegmentMarker(SOF0);\n    frameHeader.setSegmentLength(frameLength);\n    frameHeader.setSamplePrecision(precision);\n    frameHeader.setSamplesPerLine(imageWidth);\n    frameHeader.setNumberOfLines(imageHeight);\n    frameHeader.setNumberOfImageComponents(nComponents);\n    frameHeader.componentParameters = frameParams;\n    frameHeader.componentIdentifiers = new int[] { 0, 1, 2 };\n    frameHeader.initializeContents();\n    if (!frameHeader.writeToStream(outputStream)) {\n        SWT.error(SWT.ERROR_IO);\n    }\n    frameComponents = frameParams;\n    componentIds = frameHeader.componentIdentifiers;\n    maxH = frameHeader.getMaxHFactor();\n    maxV = frameHeader.getMaxVFactor();\n    int mcuWidth = maxH * DCTSIZE;\n    int mcuHeight = maxV * DCTSIZE;\n    interleavedMcuCols = (imageWidth + mcuWidth - 1) / mcuWidth;\n    interleavedMcuRows = (imageHeight + mcuHeight - 1) / mcuHeight;\n    acHuffmanTables = new JPEGHuffmanTable[4];\n    dcHuffmanTables = new JPEGHuffmanTable[4];\n    JPEGHuffmanTable[] dhtTables = new JPEGHuffmanTable[] { JPEGHuffmanTable.getDefaultDCLuminanceTable(), JPEGHuffmanTable.getDefaultDCChrominanceTable(), JPEGHuffmanTable.getDefaultACLuminanceTable(), JPEGHuffmanTable.getDefaultACChrominanceTable() };\n    for (int i = 0; i < dhtTables.length; i++) {\n        JPEGHuffmanTable dhtTable = dhtTables[i];\n        if (!dhtTable.writeToStream(outputStream)) {\n            SWT.error(SWT.ERROR_IO);\n        }\n        JPEGHuffmanTable[] allTables = dhtTable.getAllTables();\n        for (int j = 0; j < allTables.length; j++) {\n            JPEGHuffmanTable huffmanTable = allTables[j];\n            if (huffmanTable.getTableClass() == 0) {\n                dcHuffmanTables[huffmanTable.getTableIdentifier()] = huffmanTable;\n            } else {\n                acHuffmanTables[huffmanTable.getTableIdentifier()] = huffmanTable;\n            }\n        }\n    }\n    precedingDCs = new int[4];\n    scanHeader = new JPEGScanHeader(new byte[14]);\n    scanHeader.setSegmentMarker(SOS);\n    scanHeader.setSegmentLength(scanLength);\n    scanHeader.setNumberOfImageComponents(nComponents);\n    scanHeader.setStartOfSpectralSelection(0);\n    scanHeader.setEndOfSpectralSelection(63);\n    scanHeader.componentParameters = scanParams;\n    scanHeader.initializeContents();\n    if (!scanHeader.writeToStream(outputStream)) {\n        SWT.error(SWT.ERROR_IO);\n    }\n    convertImageToYCbCr(image);\n    resetOutputBuffer();\n    currentByte = 0;\n    currentBitCount = 0;\n    encodeScan();\n    if (!new JPEGEndOfImage().writeToStream(outputStream)) {\n        SWT.error(SWT.ERROR_IO);\n    }\n}",
			"comments":"",
			"methodName":"void unloadIntoByteStream(ImageData image)"
		},
		"void processRestartInterval()":{
			"methodBody":"{\n    do {\n        bufferCurrentPosition++;\n        if (bufferCurrentPosition > 511) {\n            resetInputBuffer();\n            bufferCurrentPosition = 0;\n        }\n        currentByte = dataBuffer[bufferCurrentPosition] & 0xFF;\n    } while (currentByte != 0xFF);\n    while (currentByte == 0xFF) {\n        bufferCurrentPosition++;\n        if (bufferCurrentPosition > 511) {\n            resetInputBuffer();\n            bufferCurrentPosition = 0;\n        }\n        currentByte = dataBuffer[bufferCurrentPosition] & 0xFF;\n    }\n    if (currentByte != ((RST0 + nextRestartNumber) % 256)) {\n        SWT.error(SWT.ERROR_INVALID_IMAGE);\n    }\n    bufferCurrentPosition++;\n    if (bufferCurrentPosition > 511) {\n        resetInputBuffer();\n        bufferCurrentPosition = 0;\n    }\n    currentByte = dataBuffer[bufferCurrentPosition] & 0xFF;\n    currentBitCount = 8;\n    restartsToGo = restartInterval;\n    nextRestartNumber = (nextRestartNumber + 1) % 8;\n    precedingDCs = new int[4];\n    eobrun = 0;\n}",
			"comments":"",
			"methodName":"void processRestartInterval()"
		},
		"byte[] convertYCbCrToRGB()":{
			"methodBody":"{\n    \n    int bSize = imageWidth * imageHeight * nComponents;\n    byte[] rgbData = new byte[bSize];\n    int destIndex = 0;\n    expandImageComponents();\n    byte[] yComp = imageComponents[ID_Y];\n    byte[] cbComp = imageComponents[ID_CB];\n    byte[] crComp = imageComponents[ID_CR];\n    int compWidth = frameComponents[componentIds[ID_Y]][CW];\n    for (int v = 0; v < imageHeight; v++) {\n        int srcIndex = v * compWidth;\n        for (int i = 0; i < imageWidth; i++) {\n            int y = yComp[srcIndex] & 0xFF;\n            int cb = cbComp[srcIndex] & 0xFF;\n            int cr = crComp[srcIndex] & 0xFF;\n            int r = y + CrRTable[cr];\n            int g = y + ((CbGTable[cb] + CrGTable[cr]) / 65536);\n            int b = y + CbBTable[cb];\n            if (r < 0) {\n                r = 0;\n            } else {\n                if (r > 255)\n                    r = 255;\n            }\n            if (g < 0) {\n                g = 0;\n            } else {\n                if (g > 255)\n                    g = 255;\n            }\n            if (b < 0) {\n                b = 0;\n            } else {\n                if (b > 255)\n                    b = 255;\n            }\n            rgbData[destIndex] = (byte) b;\n            rgbData[destIndex + 1] = (byte) g;\n            rgbData[destIndex + 2] = (byte) r;\n            destIndex += 3;\n            srcIndex++;\n        }\n    }\n    return rgbData;\n}",
			"comments":"/**\n* Convert existing image components into an RGB format.\n* YCbCr is defined per CCIR 601-1, except that Cb and Cr are\n* normalized to the range 0..MAXJSAMPLE rather than -0.5 .. 0.5.\n* The conversion equations to be implemented are therefore\n* \tR = Y                + 1.40200 * Cr\n* \tG = Y - 0.34414 * Cb - 0.71414 * Cr\n* \tB = Y + 1.77200 * Cb\n* where Cb and Cr represent the incoming values less MAXJSAMPLE/2.\n* (These numbers are derived from TIFF 6.0 section 21, dated 3-June-92.)\n*\n* To avoid floating-point arithmetic, we represent the fractional constants\n* as integers scaled up by 2^16 (about 4 digits precision); we have to divide\n* the products by 2^16, with appropriate rounding, to get the correct answer.\n* Notice that Y, being an integral input, does not contribute any fraction\n* so it need not participate in the rounding.\n*\n* For even more speed, we avoid doing any multiplications in the inner loop\n* by precalculating the constants times Cb and Cr for all possible values.\n* For 8-bit JSAMPLEs this is very reasonable (only 256 entries per table);\n* for 12-bit samples it is still acceptable.  It's not very reasonable for\n* 16-bit samples, but if you want lossless storage you shouldn't be changing\n* colorspace anyway.\n* The Cr=>R and Cb=>B values can be rounded to integers in advance; the\n* values for the G calculation are left scaled up, since we must add them\n* together before rounding.\n*/\n",
			"methodName":"byte[] convertYCbCrToRGB()"
		},
		"void compress(ImageData image, byte[] dataYComp, byte[] dataCbComp, byte[] dataCrComp)":{
			"methodBody":"{\n    int srcWidth = image.width;\n    int srcHeight = image.height;\n    int vhFactor = maxV * maxH;\n    int[] frameComponent;\n    imageComponents = new byte[nComponents][];\n    for (int i = 0; i < nComponents; i++) {\n        frameComponent = frameComponents[componentIds[i]];\n        imageComponents[i] = new byte[frameComponent[CW] * frameComponent[CH]];\n    }\n    frameComponent = frameComponents[componentIds[ID_Y]];\n    for (int yPos = 0; yPos < srcHeight; yPos++) {\n        int srcOfs = yPos * srcWidth;\n        int dstOfs = yPos * frameComponent[CW];\n        System.arraycopy(dataYComp, srcOfs, imageComponents[ID_Y], dstOfs, srcWidth);\n    }\n    frameComponent = frameComponents[componentIds[ID_CB]];\n    for (int yPos = 0; yPos < srcHeight / maxV; yPos++) {\n        int destRowIndex = yPos * frameComponent[CW];\n        for (int xPos = 0; xPos < srcWidth / maxH; xPos++) {\n            int sum = 0;\n            for (int iv = 0; iv < maxV; iv++) {\n                int srcIndex = (yPos * maxV + iv) * srcWidth + (xPos * maxH);\n                for (int ih = 0; ih < maxH; ih++) {\n                    sum += dataCbComp[srcIndex + ih] & 0xFF;\n                }\n            }\n            imageComponents[ID_CB][destRowIndex + xPos] = (byte) (sum / vhFactor);\n        }\n    }\n    frameComponent = frameComponents[componentIds[ID_CR]];\n    for (int yPos = 0; yPos < srcHeight / maxV; yPos++) {\n        int destRowIndex = yPos * frameComponent[CW];\n        for (int xPos = 0; xPos < srcWidth / maxH; xPos++) {\n            int sum = 0;\n            for (int iv = 0; iv < maxV; iv++) {\n                int srcIndex = (yPos * maxV + iv) * srcWidth + (xPos * maxH);\n                for (int ih = 0; ih < maxH; ih++) {\n                    sum += dataCrComp[srcIndex + ih] & 0xFF;\n                }\n            }\n            imageComponents[ID_CR][destRowIndex + xPos] = (byte) (sum / vhFactor);\n        }\n    }\n    for (int iComp = 0; iComp < nComponents; iComp++) {\n        byte[] imageComponent = imageComponents[iComp];\n        frameComponent = frameComponents[componentIds[iComp]];\n        int hFactor = frameComponent[HI];\n        int vFactor = frameComponent[VI];\n        int componentWidth = frameComponent[CW];\n        int componentHeight = frameComponent[CH];\n        int compressedWidth = srcWidth / (maxH / hFactor);\n        int compressedHeight = srcHeight / (maxV / vFactor);\n        if (compressedWidth < componentWidth) {\n            int delta = componentWidth - compressedWidth;\n            for (int yPos = 0; yPos < compressedHeight; yPos++) {\n                int dstOfs = ((yPos + 1) * componentWidth - delta);\n                int dataValue = imageComponent[dstOfs - 1] & 0xFF;\n                for (int i = 0; i < delta; i++) {\n                    imageComponent[dstOfs + i] = (byte) dataValue;\n                }\n            }\n        }\n        if (compressedHeight < componentHeight) {\n            int srcOfs = (compressedHeight - 1) * componentWidth;\n            for (int yPos = compressedHeight; yPos <= componentHeight; yPos++) {\n                int dstOfs = (yPos - 1) * componentWidth;\n                System.arraycopy(imageComponent, srcOfs, imageComponent, dstOfs, componentWidth);\n            }\n        }\n    }\n}",
			"comments":"",
			"methodName":"void compress(ImageData image, byte[] dataYComp, byte[] dataCbComp, byte[] dataCrComp)"
		},
		"void decodeACCoefficients(int[] dataUnit, int iComp)":{
			"methodBody":"{\n    int[] sParams = scanHeader.componentParameters[componentIds[iComp]];\n    JPEGHuffmanTable acTable = acHuffmanTables[sParams[AC]];\n    int k = 1;\n    while (k < 64) {\n        int rs = decodeUsingTable(acTable);\n        int r = rs >> 4;\n        int s = rs & 0xF;\n        if (s == 0) {\n            if (r == 15) {\n                k += 16;\n            } else {\n                break;\n            }\n        } else {\n            k += r;\n            int bits = receive(s);\n            dataUnit[ZigZag8x8[k]] = extendBy(bits, s);\n            k++;\n        }\n    }\n}",
			"comments":"",
			"methodName":"void decodeACCoefficients(int[] dataUnit, int iComp)"
		},
		"void decodeACRefineCoefficients(int[] dataUnit, int iComp, int start, int end, int approxBit)":{
			"methodBody":"{\n    int[] sParams = scanHeader.componentParameters[componentIds[iComp]];\n    JPEGHuffmanTable acTable = acHuffmanTables[sParams[AC]];\n    int k = start;\n    while (k <= end) {\n        if (eobrun > 0) {\n            while (k <= end) {\n                int zzIndex = ZigZag8x8[k];\n                if (dataUnit[zzIndex] != 0) {\n                    dataUnit[zzIndex] = refineAC(dataUnit[zzIndex], approxBit);\n                }\n                k++;\n            }\n            eobrun--;\n        } else {\n            int rs = decodeUsingTable(acTable);\n            int r = rs >> 4;\n            int s = rs & 0xF;\n            if (s == 0) {\n                if (r == 15) {\n                    int zeros = 0;\n                    while (zeros < 16 && k <= end) {\n                        int zzIndex = ZigZag8x8[k];\n                        if (dataUnit[zzIndex] != 0) {\n                            dataUnit[zzIndex] = refineAC(dataUnit[zzIndex], approxBit);\n                        } else {\n                            zeros++;\n                        }\n                        k++;\n                    }\n                } else {\n                    eobrun = (1 << r) + receive(r);\n                }\n            } else {\n                int bit = receive(s);\n                int zeros = 0;\n                int zzIndex = ZigZag8x8[k];\n                while ((zeros < r || dataUnit[zzIndex] != 0) && k <= end) {\n                    if (dataUnit[zzIndex] != 0) {\n                        dataUnit[zzIndex] = refineAC(dataUnit[zzIndex], approxBit);\n                    } else {\n                        zeros++;\n                    }\n                    k++;\n                    zzIndex = ZigZag8x8[k];\n                }\n                if (bit != 0) {\n                    dataUnit[zzIndex] = 1 << approxBit;\n                } else {\n                    dataUnit[zzIndex] = -1 << approxBit;\n                }\n                k++;\n            }\n        }\n    }\n}",
			"comments":"",
			"methodName":"void decodeACRefineCoefficients(int[] dataUnit, int iComp, int start, int end, int approxBit)"
		},
		"void getDQT()":{
			"methodBody":"{\n    JPEGQuantizationTable dqt = new JPEGQuantizationTable(inputStream);\n    int[][] currentTables = quantizationTables;\n    if (currentTables == null) {\n        currentTables = new int[4][];\n    }\n    int[] dqtTablesKeys = dqt.getQuantizationTablesKeys();\n    int[][] dqtTablesValues = dqt.getQuantizationTablesValues();\n    for (int i = 0; i < dqtTablesKeys.length; i++) {\n        int index = dqtTablesKeys[i];\n        currentTables[index] = dqtTablesValues[i];\n    }\n    quantizationTables = currentTables;\n}",
			"comments":"",
			"methodName":"void getDQT()"
		},
		"static void initializeBitCountTable()":{
			"methodBody":"{\n    int nBits = 1;\n    int power2 = 2;\n    NBitsTable = new int[2048];\n    NBitsTable[0] = 0;\n    for (int i = 1; i < NBitsTable.length; i++) {\n        if (!(i < power2)) {\n            nBits++;\n            power2 *= 2;\n        }\n        NBitsTable[i] = nBits;\n    }\n}",
			"comments":"",
			"methodName":"static void initializeBitCountTable()"
		},
		"int extendBy(int diff, int t)":{
			"methodBody":"{\n    if (diff < ExtendTest[t]) {\n        return diff + ExtendOffset[t];\n    } else {\n        return diff;\n    }\n}",
			"comments":"",
			"methodName":"int extendBy(int diff, int t)"
		},
		"void encodeMCUAtXAndY(int xmcu, int ymcu)":{
			"methodBody":"{\n    int nComponentsInScan = scanHeader.getNumberOfImageComponents();\n    dataUnit = new int[64];\n    for (int iComp = 0; iComp < nComponentsInScan; iComp++) {\n        int[] frameComponent = frameComponents[componentIds[iComp]];\n        int hi = frameComponent[HI];\n        int vi = frameComponent[VI];\n        for (int ivi = 0; ivi < vi; ivi++) {\n            for (int ihi = 0; ihi < hi; ihi++) {\n                extractData(dataUnit, iComp, xmcu, ymcu, ihi, ivi);\n                forwardDCT(dataUnit);\n                quantizeData(dataUnit, iComp);\n                encodeDCCoefficients(dataUnit, iComp);\n                encodeACCoefficients(dataUnit, iComp);\n            }\n        }\n    }\n}",
			"comments":"",
			"methodName":"void encodeMCUAtXAndY(int xmcu, int ymcu)"
		},
		"JPEGSegment processTables()":{
			"methodBody":"{\n    while (true) {\n        JPEGSegment jpegSegment = seekUnspecifiedMarker(inputStream);\n        if (jpegSegment == null)\n            return null;\n        JPEGFrameHeader sof = new JPEGFrameHeader(jpegSegment.reference);\n        if (sof.verify()) {\n            return jpegSegment;\n        }\n        int marker = jpegSegment.getSegmentMarker();\n        switch(marker) {\n            case \n            SOI:\n                SWT.error(SWT.ERROR_INVALID_IMAGE);\n            case EOI:\n            case SOS:\n                return jpegSegment;\n            case DQT:\n                getDQT();\n                break;\n            case DHT:\n                getDHT();\n                break;\n            case DAC:\n                getDAC();\n                break;\n            case DRI:\n                getDRI();\n                break;\n            case APP0:\n                getAPP0();\n                break;\n            case COM:\n                getCOM();\n                break;\n            default:\n                skipSegmentFrom(inputStream);\n        }\n    }\n}",
			"comments":"/* Process all markers until a frame header, scan header, or EOI is found. */\n// there should only be one SOI per file\n",
			"methodName":"JPEGSegment processTables()"
		},
		"int receive(int nBits)":{
			"methodBody":"{\n    int v = 0;\n    for (int i = 0; i < nBits; i++) {\n        v = v * 2 + nextBit();\n    }\n    return v;\n}",
			"comments":"",
			"methodName":"int receive(int nBits)"
		},
		"void emit(int huffCode, int nBits)":{
			"methodBody":"{\n    if (nBits == 0) {\n        SWT.error(SWT.ERROR_INVALID_IMAGE);\n    }\n    int[] power2m1 = new int[] { 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131125 };\n    int code = (huffCode & power2m1[nBits - 1]) << (24 - nBits - currentBitCount);\n    byte[] codeBuffer = new byte[4];\n    codeBuffer[0] = (byte) (code % 256);\n    codeBuffer[1] = (byte) ((code / 256) % 256);\n    codeBuffer[2] = (byte) ((code / 65536) % 256);\n    codeBuffer[3] = (byte) ((code / 16777216) % 256);\n    int abs = nBits - (8 - currentBitCount);\n    if (abs < 0)\n        abs = -abs;\n    if ((abs / 8) > 0) {\n        currentByte += codeBuffer[2];\n        emitByte((byte) currentByte);\n        emitByte(codeBuffer[1]);\n        currentByte = codeBuffer[0];\n        currentBitCount += nBits - 16;\n    } else {\n        currentBitCount += nBits;\n        if (currentBitCount >= 8) {\n            currentByte += codeBuffer[2];\n            emitByte((byte) currentByte);\n            currentByte = codeBuffer[1];\n            currentBitCount -= 8;\n        } else {\n            currentByte += codeBuffer[2];\n        }\n    }\n}",
			"comments":"",
			"methodName":"void emit(int huffCode, int nBits)"
		},
		"void extractData(int[] dataUnit, int iComp, int xmcu, int ymcu, int ihi, int ivi)":{
			"methodBody":"{\n    byte[] compImage = imageComponents[iComp];\n    int[] frameComponent = frameComponents[componentIds[iComp]];\n    int hi = frameComponent[HI];\n    int vi = frameComponent[VI];\n    int compWidth = frameComponent[CW];\n    int srcIndex = ((ymcu * vi + ivi) * compWidth * DCTSIZE) + ((xmcu * hi + ihi) * DCTSIZE);\n    int destIndex = 0;\n    for (int i = 0; i < DCTSIZE; i++) {\n        for (int col = 0; col < DCTSIZE; col++) {\n            dataUnit[destIndex] = (compImage[srcIndex + col] & 0xFF) - 128;\n            destIndex++;\n        }\n        srcIndex += compWidth;\n    }\n}",
			"comments":"",
			"methodName":"void extractData(int[] dataUnit, int iComp, int xmcu, int ymcu, int ihi, int ivi)"
		},
		"void decodeDCCoefficient(int[] dataUnit, int iComp, boolean first, int approxBit)":{
			"methodBody":"{\n    int[] sParams = scanHeader.componentParameters[componentIds[iComp]];\n    JPEGHuffmanTable dcTable = dcHuffmanTables[sParams[DC]];\n    int lastDC = 0;\n    if (progressive && !first) {\n        int bit = nextBit();\n        lastDC = dataUnit[0] + (bit << approxBit);\n    } else {\n        lastDC = precedingDCs[iComp];\n        int nBits = decodeUsingTable(dcTable);\n        if (nBits != 0) {\n            int bits = receive(nBits);\n            int diff = extendBy(bits, nBits);\n            lastDC = lastDC + diff;\n            precedingDCs[iComp] = lastDC;\n        }\n        if (progressive) {\n            lastDC = lastDC << approxBit;\n        }\n    }\n    dataUnit[0] = lastDC;\n}",
			"comments":"",
			"methodName":"void decodeDCCoefficient(int[] dataUnit, int iComp, boolean first, int approxBit)"
		},
		"void getCOM()":{
			"methodBody":"{\n    new JPEGComment(inputStream);\n}",
			"comments":"",
			"methodName":"void getCOM()"
		},
		"static void initialize()":{
			"methodBody":"{\n    initializeRGBYCbCrTables();\n    initializeYCbCrRGBTables();\n    initializeBitCountTable();\n}",
			"comments":"",
			"methodName":"static void initialize()"
		},
		"void convertImageToYCbCr(ImageData image)":{
			"methodBody":"{\n    switch(image.depth) {\n        case 4:\n            convert4BitRGBToYCbCr(image);\n            return;\n        case 8:\n            convert8BitRGBToYCbCr(image);\n            return;\n        case 16:\n        case 24:\n        case 32:\n            convertMultiRGBToYCbCr(image);\n            return;\n        default:\n            SWT.error(SWT.ERROR_UNSUPPORTED_DEPTH);\n    }\n    return;\n}",
			"comments":"",
			"methodName":"void convertImageToYCbCr(ImageData image)"
		},
		"void decodeACFirstCoefficients(int[] dataUnit, int iComp, int start, int end, int approxBit)":{
			"methodBody":"{\n    if (eobrun > 0) {\n        eobrun--;\n        return;\n    }\n    int[] sParams = scanHeader.componentParameters[componentIds[iComp]];\n    JPEGHuffmanTable acTable = acHuffmanTables[sParams[AC]];\n    int k = start;\n    while (k <= end) {\n        int rs = decodeUsingTable(acTable);\n        int r = rs >> 4;\n        int s = rs & 0xF;\n        if (s == 0) {\n            if (r == 15) {\n                k += 16;\n            } else {\n                eobrun = (1 << r) + receive(r) - 1;\n                break;\n            }\n        } else {\n            k += r;\n            int bits = receive(s);\n            dataUnit[ZigZag8x8[k]] = extendBy(bits, s) << approxBit;\n            k++;\n        }\n    }\n}",
			"comments":"",
			"methodName":"void decodeACFirstCoefficients(int[] dataUnit, int iComp, int start, int end, int approxBit)"
		},
		"void getDNL()":{
			"methodBody":"{\n    new JPEGRestartInterval(inputStream);\n}",
			"comments":"",
			"methodName":"void getDNL()"
		},
		"byte[] decodeImageComponents()":{
			"methodBody":"{\n    int[] compIds = new int[nComponents];\n    int compIdsIndex = 0;\n    for (int i = 0; i < nComponents; i++) {\n        compIds[compIdsIndex] = i + 1;\n        compIdsIndex++;\n    }\n    if ((compIds.length == 3) && (compIds[0] == 1) && (compIds[1] == 2) && (compIds[2] == 3)) {\n        return convertYCbCrToRGB();\n    }\n    if ((compIds.length == 3) && (compIds[0] == 1) && (compIds[1] == 4) && (compIds[2] == 5)) {\n        return convertYIQToRGB();\n    }\n    if (compIds.length == 4) {\n        return convertCMYKToRGB();\n    }\n    return convertYToRGB();\n}",
			"comments":"",
			"methodName":"byte[] decodeImageComponents()"
		},
		"void encodeACCoefficients(int[] dataUnit, int iComp)":{
			"methodBody":"{\n    int[] sParams = scanHeader.componentParameters[iComp];\n    JPEGHuffmanTable acTable = acHuffmanTables[sParams[AC]];\n    int[] ehCodes = acTable.ehCodes;\n    byte[] ehSizes = acTable.ehCodeLengths;\n    int r = 0;\n    int k = 1;\n    while (k < 64) {\n        k++;\n        int acValue = dataUnit[ZigZag8x8[k - 1]];\n        if (acValue == 0) {\n            if (k == 64) {\n                emit(ehCodes[0], ehSizes[0] & 0xFF);\n            } else {\n                r++;\n            }\n        } else {\n            while (r > 15) {\n                emit(ehCodes[0xF0], ehSizes[0xF0] & 0xFF);\n                r -= 16;\n            }\n            if (acValue < 0) {\n                int absACValue = acValue;\n                if (absACValue < 0)\n                    absACValue = -absACValue;\n                int nBits = NBitsTable[absACValue];\n                int rs = r * 16 + nBits;\n                emit(ehCodes[rs], ehSizes[rs] & 0xFF);\n                emit(0xFFFFFF - absACValue, nBits);\n            } else {\n                int nBits = NBitsTable[acValue];\n                int rs = r * 16 + nBits;\n                emit(ehCodes[rs], ehSizes[rs] & 0xFF);\n                emit(acValue, nBits);\n            }\n            r = 0;\n        }\n    }\n}",
			"comments":"",
			"methodName":"void encodeACCoefficients(int[] dataUnit, int iComp)"
		},
		"int decodeUsingTable(JPEGHuffmanTable huffmanTable)":{
			"methodBody":"{\n    int i = 0;\n    int[] maxCodes = huffmanTable.getDhMaxCodes();\n    int[] minCodes = huffmanTable.getDhMinCodes();\n    int[] valPtrs = huffmanTable.getDhValPtrs();\n    int[] huffVals = huffmanTable.getDhValues();\n    int code = nextBit();\n    while (code > maxCodes[i]) {\n        code = code * 2 + nextBit();\n        i++;\n    }\n    int j = valPtrs[i];\n    j = j + code - minCodes[i];\n    return huffVals[j];\n}",
			"comments":"",
			"methodName":"int decodeUsingTable(JPEGHuffmanTable huffmanTable)"
		},
		"void getAPP0()":{
			"methodBody":"{\n    JPEGAppn appn = new JPEGAppn(inputStream);\n    if (!appn.verify()) {\n        SWT.error(SWT.ERROR_INVALID_IMAGE);\n    }\n}",
			"comments":"",
			"methodName":"void getAPP0()"
		},
		"void quantizeData(int[] dataUnit, int iComp)":{
			"methodBody":"{\n    int[] qTable = quantizationTables[frameComponents[componentIds[iComp]][TQI]];\n    for (int i = 0; i < dataUnit.length; i++) {\n        int zzIndex = ZigZag8x8[i];\n        int data = dataUnit[zzIndex];\n        int absData = data < 0 ? 0 - data : data;\n        int qValue = qTable[i];\n        int q2 = qValue / 2;\n        absData += q2;\n        if (absData < qValue) {\n            dataUnit[zzIndex] = 0;\n        } else {\n            absData /= qValue;\n            if (data >= 0) {\n                dataUnit[zzIndex] = absData;\n            } else {\n                dataUnit[zzIndex] = 0 - absData;\n            }\n        }\n    }\n}",
			"comments":"",
			"methodName":"void quantizeData(int[] dataUnit, int iComp)"
		},
		"int refineAC(int ac, int approxBit)":{
			"methodBody":"{\n    if (ac > 0) {\n        int bit = nextBit();\n        if (bit != 0) {\n            ac = ac + (1 << approxBit);\n        }\n    } else if (ac < 0) {\n        int bit = nextBit();\n        if (bit != 0) {\n            ac = ac + (-1 << approxBit);\n        }\n    }\n    return ac;\n}",
			"comments":"",
			"methodName":"int refineAC(int ac, int approxBit)"
		},
		"boolean isZeroInColumn(int[] dataUnit, int col)":{
			"methodBody":"{\n    return (dataUnit[col + 8] + dataUnit[col + 16] + dataUnit[col + 24] + dataUnit[col + 32] + dataUnit[col + 40] + dataUnit[col + 48] + dataUnit[col + 56]) == 0;\n}",
			"comments":"",
			"methodName":"boolean isZeroInColumn(int[] dataUnit, int col)"
		},
		"void resetOutputBuffer()":{
			"methodBody":"{\n    if (dataBuffer == null) {\n        dataBuffer = new byte[512];\n    } else {\n        try {\n            outputStream.write(dataBuffer, 0, bufferCurrentPosition);\n        } catch (IOException e) {\n            SWT.error(SWT.ERROR_IO, e);\n        }\n    }\n    bufferCurrentPosition = 0;\n}",
			"comments":"",
			"methodName":"void resetOutputBuffer()"
		},
		"void forwardDCT(int[] dataUnit)":{
			"methodBody":"{\n    for (int row = 0; row < 8; row++) {\n        int rIndex = row * DCTSIZE;\n        int tmp0 = dataUnit[rIndex] + dataUnit[rIndex + 7];\n        int tmp7 = dataUnit[rIndex] - dataUnit[rIndex + 7];\n        int tmp1 = dataUnit[rIndex + 1] + dataUnit[rIndex + 6];\n        int tmp6 = dataUnit[rIndex + 1] - dataUnit[rIndex + 6];\n        int tmp2 = dataUnit[rIndex + 2] + dataUnit[rIndex + 5];\n        int tmp5 = dataUnit[rIndex + 2] - dataUnit[rIndex + 5];\n        int tmp3 = dataUnit[rIndex + 3] + dataUnit[rIndex + 4];\n        int tmp4 = dataUnit[rIndex + 3] - dataUnit[rIndex + 4];\n        \n        int tmp10 = tmp0 + tmp3;\n        int tmp13 = tmp0 - tmp3;\n        int tmp11 = tmp1 + tmp2;\n        int tmp12 = tmp1 - tmp2;\n        dataUnit[rIndex] = (tmp10 + tmp11) * 4;\n        dataUnit[rIndex + 4] = (tmp10 - tmp11) * 4;\n        int z1 = (tmp12 + tmp13) * FIX_0_541196100;\n        int scaleFactor1 = ExtendTest[11];\n        int scaleFactor2 = ExtendTest[12];\n        int n = z1 + (tmp13 * FIX_0_765366865) + scaleFactor1;\n        dataUnit[rIndex + 2] = n / scaleFactor2;\n        if ((n < 0) && (n % scaleFactor2 != 0))\n            dataUnit[rIndex + 2]--;\n        n = z1 + (tmp12 * (0 - FIX_1_847759065)) + scaleFactor1;\n        dataUnit[rIndex + 6] = n / scaleFactor2;\n        if ((n < 0) && (n % scaleFactor2 != 0))\n            dataUnit[rIndex + 6]--;\n        \n        z1 = tmp4 + tmp7;\n        int z2 = tmp5 + tmp6;\n        int z3 = tmp4 + tmp6;\n        int z4 = tmp5 + tmp7;\n        \n        int z5 = (z3 + z4) * FIX_1_175875602;\n        \n        tmp4 = tmp4 * FIX_0_298631336;\n        \n        tmp5 = tmp5 * FIX_2_053119869;\n        \n        tmp6 = tmp6 * FIX_3_072711026;\n        \n        tmp7 = tmp7 * FIX_1_501321110;\n        \n        z1 = z1 * (0 - FIX_0_899976223);\n        \n        z2 = z2 * (0 - FIX_2_562915447);\n        \n        z3 = z3 * (0 - FIX_1_961570560);\n        \n        z4 = z4 * (0 - FIX_0_390180644);\n        z3 = z3 + z5;\n        z4 = z4 + z5;\n        n = tmp4 + z1 + z3 + scaleFactor1;\n        dataUnit[rIndex + 7] = n / scaleFactor2;\n        if ((n < 0) && (n % scaleFactor2 != 0))\n            dataUnit[rIndex + 7]--;\n        n = tmp5 + z2 + z4 + scaleFactor1;\n        dataUnit[rIndex + 5] = n / scaleFactor2;\n        if ((n < 0) && (n % scaleFactor2 != 0))\n            dataUnit[rIndex + 5]--;\n        n = tmp6 + z2 + z3 + scaleFactor1;\n        dataUnit[rIndex + 3] = n / scaleFactor2;\n        if ((n < 0) && (n % scaleFactor2 != 0))\n            dataUnit[rIndex + 3]--;\n        n = tmp7 + z1 + z4 + scaleFactor1;\n        dataUnit[rIndex + 1] = n / scaleFactor2;\n        if ((n < 0) && (n % scaleFactor2 != 0))\n            dataUnit[rIndex + 1]--;\n    }\n    \n    for (int col = 0; col < 8; col++) {\n        int c0 = col;\n        int c1 = col + 8;\n        int c2 = col + 16;\n        int c3 = col + 24;\n        int c4 = col + 32;\n        int c5 = col + 40;\n        int c6 = col + 48;\n        int c7 = col + 56;\n        int tmp0 = dataUnit[c0] + dataUnit[c7];\n        int tmp7 = dataUnit[c0] - dataUnit[c7];\n        int tmp1 = dataUnit[c1] + dataUnit[c6];\n        int tmp6 = dataUnit[c1] - dataUnit[c6];\n        int tmp2 = dataUnit[c2] + dataUnit[c5];\n        int tmp5 = dataUnit[c2] - dataUnit[c5];\n        int tmp3 = dataUnit[c3] + dataUnit[c4];\n        int tmp4 = dataUnit[c3] - dataUnit[c4];\n        \n        int tmp10 = tmp0 + tmp3;\n        int tmp13 = tmp0 - tmp3;\n        int tmp11 = tmp1 + tmp2;\n        int tmp12 = tmp1 - tmp2;\n        int scaleFactor1 = ExtendTest[5];\n        int scaleFactor2 = ExtendTest[6];\n        int n = tmp10 + tmp11 + scaleFactor1;\n        dataUnit[c0] = n / scaleFactor2;\n        if ((n < 0) && (n % scaleFactor2 != 0))\n            dataUnit[c0]--;\n        n = tmp10 - tmp11 + scaleFactor1;\n        dataUnit[c4] = n / scaleFactor2;\n        if ((n < 0) && (n % scaleFactor2 != 0))\n            dataUnit[c4]--;\n        int z1 = (tmp12 + tmp13) * FIX_0_541196100;\n        scaleFactor1 = ExtendTest[18];\n        scaleFactor2 = ExtendTest[19];\n        n = z1 + (tmp13 * FIX_0_765366865) + scaleFactor1;\n        dataUnit[c2] = n / scaleFactor2;\n        if ((n < 0) && (n % scaleFactor2 != 0))\n            dataUnit[c2]--;\n        n = z1 + (tmp12 * (0 - FIX_1_847759065)) + scaleFactor1;\n        dataUnit[c6] = n / scaleFactor2;\n        if ((n < 0) && (n % scaleFactor2 != 0))\n            dataUnit[c6]--;\n        \n        z1 = tmp4 + tmp7;\n        int z2 = tmp5 + tmp6;\n        int z3 = tmp4 + tmp6;\n        int z4 = tmp5 + tmp7;\n        \n        int z5 = (z3 + z4) * FIX_1_175875602;\n        \n        tmp4 = tmp4 * FIX_0_298631336;\n        \n        tmp5 = tmp5 * FIX_2_053119869;\n        \n        tmp6 = tmp6 * FIX_3_072711026;\n        \n        tmp7 = tmp7 * FIX_1_501321110;\n        \n        z1 = z1 * (0 - FIX_0_899976223);\n        \n        z2 = z2 * (0 - FIX_2_562915447);\n        \n        z3 = z3 * (0 - FIX_1_961570560);\n        \n        z4 = z4 * (0 - FIX_0_390180644);\n        z3 = z3 + z5;\n        z4 = z4 + z5;\n        n = tmp4 + z1 + z3 + scaleFactor1;\n        dataUnit[c7] = n / scaleFactor2;\n        if ((n < 0) && (n % scaleFactor2 != 0))\n            dataUnit[c7]--;\n        n = tmp5 + z2 + z4 + scaleFactor1;\n        dataUnit[c5] = n / scaleFactor2;\n        if ((n < 0) && (n % scaleFactor2 != 0))\n            dataUnit[c5]--;\n        n = tmp6 + z2 + z3 + scaleFactor1;\n        dataUnit[c3] = n / scaleFactor2;\n        if ((n < 0) && (n % scaleFactor2 != 0))\n            dataUnit[c3]--;\n        n = tmp7 + z1 + z4 + scaleFactor1;\n        dataUnit[c1] = n / scaleFactor2;\n        if ((n < 0) && (n % scaleFactor2 != 0))\n            dataUnit[c1]--;\n    }\n}",
			"comments":"/**\n* Even part per LL&M figure 1 --- note that published figure\n* is faulty; rotator 'sqrt(2)*c1' should be 'sqrt(2)*c6'.\n*/\n/**\n* Odd part per figure 8 --- note paper omits factor of sqrt(2).\n* cK represents cos(K*pi/16).\n* i0..i3 in the paper are tmp4..tmp7 here.\n*/\n// sqrt(2) * c3\n// sqrt(2) * (-c1+c3+c5-c7)\n// sqrt(2) * ( c1+c3-c5+c7)\n// sqrt(2) * ( c1+c3+c5-c7)\n// sqrt(2) * ( c1+c3-c5-c7)\n// sqrt(2) * (c7-c3)\n// sqrt(2) * (-c1-c3)\n// sqrt(2) * (-c3-c5)\n// sqrt(2) * (c5-c3)\n/**\n* Pass 2: process columns.\n* Note that we must descale the results by a factor of 8 == 2**3,\n* and also undo the PASS1_BITS scaling.\n*/\n/**\n* Even part per LL&M figure 1 --- note that published figure\n* is faulty; rotator 'sqrt(2)*c1' should be 'sqrt(2)*c6'.\n*/\n/**\n* Odd part per figure 8 --- note paper omits factor of sqrt(2).\n* cK represents cos(K*pi/16).\n* i0..i3 in the paper are tmp4..tmp7 here.\n*/\n// sqrt(2) * c3\n// sqrt(2) * (-c1+c3+c5-c7)\n// sqrt(2) * ( c1+c3-c5+c7)\n// sqrt(2) * ( c1+c3+c5-c7)\n// sqrt(2) * ( c1+c3-c5-c7)\n// sqrt(2) * (c7-c3)\n// sqrt(2) * (-c1-c3)\n// sqrt(2) * (-c3-c5)\n// sqrt(2) * (c5-c3)\n",
			"methodName":"void forwardDCT(int[] dataUnit)"
		},
		"boolean isZeroInRow(int[] dataUnit, int rIndex)":{
			"methodBody":"{\n    return (dataUnit[rIndex + 1] + dataUnit[rIndex + 2] + dataUnit[rIndex + 3] + dataUnit[rIndex + 4] + dataUnit[rIndex + 5] + dataUnit[rIndex + 6] + dataUnit[rIndex + 7]) == 0;\n}",
			"comments":"",
			"methodName":"boolean isZeroInRow(int[] dataUnit, int rIndex)"
		},
		"void emitByte(byte byteValue)":{
			"methodBody":"{\n    if (bufferCurrentPosition >= 512) {\n        resetOutputBuffer();\n    }\n    dataBuffer[bufferCurrentPosition] = byteValue;\n    bufferCurrentPosition++;\n    if (byteValue == -1) {\n        emitByte((byte) 0);\n    }\n}",
			"comments":"",
			"methodName":"void emitByte(byte byteValue)"
		},
		"static void initializeRGBYCbCrTables()":{
			"methodBody":"{\n    RYTable = new int[256];\n    GYTable = new int[256];\n    BYTable = new int[256];\n    RCbTable = new int[256];\n    GCbTable = new int[256];\n    BCbTable = new int[256];\n    RCrTable = BCbTable;\n    GCrTable = new int[256];\n    BCrTable = new int[256];\n    for (int i = 0; i < 256; i++) {\n        RYTable[i] = i * 19595;\n        GYTable[i] = i * 38470;\n        BYTable[i] = i * 7471 + 32768;\n        RCbTable[i] = i * -11059;\n        GCbTable[i] = i * -21709;\n        BCbTable[i] = i * 32768 + 8388608;\n        GCrTable[i] = i * -27439;\n        BCrTable[i] = i * -5329;\n    }\n}",
			"comments":"",
			"methodName":"static void initializeRGBYCbCrTables()"
		},
		"void convert8BitRGBToYCbCr(ImageData image)":{
			"methodBody":"{\n    RGB[] rgbs = image.getRGBs();\n    int paletteSize = rgbs.length;\n    byte[] yComp = new byte[paletteSize];\n    byte[] cbComp = new byte[paletteSize];\n    byte[] crComp = new byte[paletteSize];\n    int srcWidth = image.width;\n    int srcHeight = image.height;\n    for (int i = 0; i < paletteSize; i++) {\n        RGB color = rgbs[i];\n        int r = color.red;\n        int g = color.green;\n        int b = color.blue;\n        int n = RYTable[r] + GYTable[g] + BYTable[b];\n        yComp[i] = (byte) (n / 65536);\n        if ((n < 0) && (n % 65536 != 0))\n            yComp[i]--;\n        n = RCbTable[r] + GCbTable[g] + BCbTable[b];\n        cbComp[i] = (byte) (n / 65536);\n        if ((n < 0) && (n % 65536 != 0))\n            cbComp[i]--;\n        n = RCrTable[r] + GCrTable[g] + BCrTable[b];\n        crComp[i] = (byte) (n / 65536);\n        if ((n < 0) && (n % 65536 != 0))\n            crComp[i]--;\n    }\n    int dstWidth = image.width;\n    int dstHeight = srcHeight;\n    int stride = (srcWidth + 3) / 4 * 4;\n    int bSize = dstWidth * dstHeight;\n    byte[] dataYComp = new byte[bSize];\n    byte[] dataCbComp = new byte[bSize];\n    byte[] dataCrComp = new byte[bSize];\n    byte[] origData = image.data;\n    for (int yPos = 0; yPos < srcHeight; yPos++) {\n        int srcRowIndex = yPos * stride;\n        int dstRowIndex = yPos * dstWidth;\n        for (int xPos = 0; xPos < srcWidth; xPos++) {\n            int value = origData[srcRowIndex + xPos] & 0xFF;\n            int dstIndex = dstRowIndex + xPos;\n            dataYComp[dstIndex] = yComp[value];\n            dataCbComp[dstIndex] = cbComp[value];\n            dataCrComp[dstIndex] = crComp[value];\n        }\n    }\n    compress(image, dataYComp, dataCbComp, dataCrComp);\n}",
			"comments":"",
			"methodName":"void convert8BitRGBToYCbCr(ImageData image)"
		},
		"void inverseDCT(int[] dataUnit)":{
			"methodBody":"{\n    for (int row = 0; row < 8; row++) {\n        int rIndex = row * DCTSIZE;\n        \n        if (isZeroInRow(dataUnit, rIndex)) {\n            int dcVal = dataUnit[rIndex] * 4;\n            for (int i = rIndex; i < rIndex + 8; i++) {\n                dataUnit[i] = dcVal;\n            }\n        } else {\n            \n            int z2 = dataUnit[rIndex + 2];\n            int z3 = dataUnit[rIndex + 6];\n            int z1 = (z2 + z3) * FIX_0_541196100;\n            int tmp2 = z1 + (z3 * (0 - FIX_1_847759065));\n            int tmp3 = z1 + (z2 * FIX_0_765366865);\n            int tmp0 = (dataUnit[rIndex] + dataUnit[rIndex + 4]) * 8192;\n            int tmp1 = (dataUnit[rIndex] - dataUnit[rIndex + 4]) * 8192;\n            int tmp10 = tmp0 + tmp3;\n            int tmp13 = tmp0 - tmp3;\n            int tmp11 = tmp1 + tmp2;\n            int tmp12 = tmp1 - tmp2;\n            \n            tmp0 = dataUnit[rIndex + 7];\n            tmp1 = dataUnit[rIndex + 5];\n            tmp2 = dataUnit[rIndex + 3];\n            tmp3 = dataUnit[rIndex + 1];\n            z1 = tmp0 + tmp3;\n            z2 = tmp1 + tmp2;\n            z3 = tmp0 + tmp2;\n            int z4 = tmp1 + tmp3;\n            int z5 = (z3 + z4) * FIX_1_175875602;\n            \n            tmp0 = tmp0 * FIX_0_298631336;\n            \n            tmp1 = tmp1 * FIX_2_053119869;\n            \n            tmp2 = tmp2 * FIX_3_072711026;\n            \n            tmp3 = tmp3 * FIX_1_501321110;\n            \n            z1 = z1 * (0 - FIX_0_899976223);\n            \n            z2 = z2 * (0 - FIX_2_562915447);\n            \n            z3 = z3 * (0 - FIX_1_961570560);\n            \n            z4 = z4 * (0 - FIX_0_390180644);\n            \n            z3 = z3 + z5;\n            z4 = z4 + z5;\n            tmp0 = tmp0 + z1 + z3;\n            tmp1 = tmp1 + z2 + z4;\n            tmp2 = tmp2 + z2 + z3;\n            tmp3 = tmp3 + z1 + z4;\n            int descaleFactor1 = ExtendTest[11];\n            int descaleFactor2 = ExtendTest[12];\n            dataUnit[rIndex] = (tmp10 + tmp3 + descaleFactor1) / descaleFactor2;\n            dataUnit[rIndex + 7] = (tmp10 - tmp3 + descaleFactor1) / descaleFactor2;\n            dataUnit[rIndex + 1] = (tmp11 + tmp2 + descaleFactor1) / descaleFactor2;\n            dataUnit[rIndex + 6] = (tmp11 - tmp2 + descaleFactor1) / descaleFactor2;\n            dataUnit[rIndex + 2] = (tmp12 + tmp1 + descaleFactor1) / descaleFactor2;\n            dataUnit[rIndex + 5] = (tmp12 - tmp1 + descaleFactor1) / descaleFactor2;\n            dataUnit[rIndex + 3] = (tmp13 + tmp0 + descaleFactor1) / descaleFactor2;\n            dataUnit[rIndex + 4] = (tmp13 - tmp0 + descaleFactor1) / descaleFactor2;\n        }\n    }\n    \n    for (int col = 0; col < 8; col++) {\n        int c0 = col;\n        int c1 = col + 8;\n        int c2 = col + 16;\n        int c3 = col + 24;\n        int c4 = col + 32;\n        int c5 = col + 40;\n        int c6 = col + 48;\n        int c7 = col + 56;\n        if (isZeroInColumn(dataUnit, col)) {\n            int dcVal = (dataUnit[c0] + 16) / 32;\n            dataUnit[c0] = dcVal;\n            dataUnit[c1] = dcVal;\n            dataUnit[c2] = dcVal;\n            dataUnit[c3] = dcVal;\n            dataUnit[c4] = dcVal;\n            dataUnit[c5] = dcVal;\n            dataUnit[c6] = dcVal;\n            dataUnit[c7] = dcVal;\n        } else {\n            \n            int z2 = dataUnit[c2];\n            int z3 = dataUnit[c6];\n            int z1 = (z2 + z3) * FIX_0_541196100;\n            int tmp2 = z1 + (z3 * (0 - FIX_1_847759065));\n            int tmp3 = z1 + (z2 * FIX_0_765366865);\n            int tmp0 = (dataUnit[c0] + dataUnit[c4]) * 8192;\n            int tmp1 = (dataUnit[c0] - dataUnit[c4]) * 8192;\n            int tmp10 = tmp0 + tmp3;\n            int tmp13 = tmp0 - tmp3;\n            int tmp11 = tmp1 + tmp2;\n            int tmp12 = tmp1 - tmp2;\n            \n            tmp0 = dataUnit[c7];\n            tmp1 = dataUnit[c5];\n            tmp2 = dataUnit[c3];\n            tmp3 = dataUnit[c1];\n            z1 = tmp0 + tmp3;\n            z2 = tmp1 + tmp2;\n            z3 = tmp0 + tmp2;\n            int z4 = tmp1 + tmp3;\n            int z5 = (z3 + z4) * FIX_1_175875602;\n            \n            tmp0 = tmp0 * FIX_0_298631336;\n            \n            tmp1 = tmp1 * FIX_2_053119869;\n            \n            tmp2 = tmp2 * FIX_3_072711026;\n            \n            tmp3 = tmp3 * FIX_1_501321110;\n            \n            z1 = z1 * (0 - FIX_0_899976223);\n            \n            z2 = z2 * (0 - FIX_2_562915447);\n            \n            z3 = z3 * (0 - FIX_1_961570560);\n            \n            z4 = z4 * (0 - FIX_0_390180644);\n            \n            z3 = z3 + z5;\n            z4 = z4 + z5;\n            tmp0 = tmp0 + z1 + z3;\n            tmp1 = tmp1 + z2 + z4;\n            tmp2 = tmp2 + z2 + z3;\n            tmp3 = tmp3 + z1 + z4;\n            \n            int descaleFactor1 = ExtendTest[18];\n            int descaleFactor2 = ExtendTest[19];\n            dataUnit[c0] = (tmp10 + tmp3 + descaleFactor1) / descaleFactor2;\n            dataUnit[c7] = (tmp10 - tmp3 + descaleFactor1) / descaleFactor2;\n            dataUnit[c1] = (tmp11 + tmp2 + descaleFactor1) / descaleFactor2;\n            dataUnit[c6] = (tmp11 - tmp2 + descaleFactor1) / descaleFactor2;\n            dataUnit[c2] = (tmp12 + tmp1 + descaleFactor1) / descaleFactor2;\n            dataUnit[c5] = (tmp12 - tmp1 + descaleFactor1) / descaleFactor2;\n            dataUnit[c3] = (tmp13 + tmp0 + descaleFactor1) / descaleFactor2;\n            dataUnit[c4] = (tmp13 - tmp0 + descaleFactor1) / descaleFactor2;\n        }\n    }\n}",
			"comments":"/**\n* Due to quantization, we will usually find that many of the input\n* coefficients are zero, especially the AC terms.  We can exploit this\n* by short-circuiting the IDCT calculation for any row in which all\n* the AC terms are zero.  In that case each output is equal to the\n* DC coefficient (with scale factor as needed).\n* With typical images and quantization tables, half or more of the\n* row DCT calculations can be simplified this way.\n*/\n/**\n* Even part: reverse the even part of the forward DCT.\n* The rotator is sqrt(2)*c(-6).\n*/\n/**\n* Odd part per figure 8; the matrix is unitary and hence its\n* transpose is its inverse. i0..i3 are y7,y5,y3,y1 respectively.\n*/\n/* sqrt(2) * c3 */\n/* sqrt(2) * (-c1+c3+c5-c7) */\n/* sqrt(2) * ( c1+c3-c5+c7) */\n/* sqrt(2) * ( c1+c3+c5-c7) */\n/* sqrt(2) * ( c1+c3-c5-c7) */\n/* sqrt(2) * (c7-c3) */\n/* sqrt(2) * (-c1-c3) */\n/* sqrt(2) * (-c3-c5) */\n/* sqrt(2) * (c5-c3) */\n/**\n* Pass 2: process columns.\n* Note that we must descale the results by a factor of 8 == 2**3,\n* and also undo the PASS1_BITS scaling.\n*/\n/**\n* Even part: reverse the even part of the forward DCT.\n* The rotator is sqrt(2)*c(-6).\n*/\n/**\n* Odd part per figure 8; the matrix is unitary and hence its\n* transpose is its inverse. i0..i3 are y7,y5,y3,y1 respectively.\n*/\n/* sqrt(2) * c3 */\n/* sqrt(2) * (-c1+c3+c5-c7) */\n/* sqrt(2) * ( c1+c3-c5+c7) */\n/* sqrt(2) * ( c1+c3+c5-c7) */\n/* sqrt(2) * ( c1+c3-c5-c7) */\n/* sqrt(2) * (c7-c3) */\n/* sqrt(2) * (-c1-c3) */\n/* sqrt(2) * (-c3-c5) */\n/* sqrt(2) * (c5-c3) */\n/* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */\n",
			"methodName":"void inverseDCT(int[] dataUnit)"
		},
		"ImageData[] loadFromByteStream()":{
			"methodBody":"{\n    JPEGStartOfImage soi = new JPEGStartOfImage(inputStream);\n    if (!soi.verify())\n        SWT.error(SWT.ERROR_INVALID_IMAGE);\n    restartInterval = 0;\n    \n    processTables();\n    \n    frameHeader = new JPEGFrameHeader(inputStream);\n    if (!frameHeader.verify())\n        SWT.error(SWT.ERROR_INVALID_IMAGE);\n    imageWidth = frameHeader.getSamplesPerLine();\n    imageHeight = frameHeader.getNumberOfLines();\n    maxH = frameHeader.getMaxHFactor();\n    maxV = frameHeader.getMaxVFactor();\n    int mcuWidth = maxH * DCTSIZE;\n    int mcuHeight = maxV * DCTSIZE;\n    interleavedMcuCols = (imageWidth + mcuWidth - 1) / mcuWidth;\n    interleavedMcuRows = (imageHeight + mcuHeight - 1) / mcuHeight;\n    progressive = frameHeader.isProgressive();\n    samplePrecision = frameHeader.getSamplePrecision();\n    nComponents = frameHeader.getNumberOfImageComponents();\n    frameComponents = frameHeader.componentParameters;\n    componentIds = frameHeader.componentIdentifiers;\n    imageComponents = new byte[nComponents][];\n    if (progressive) {\n        \n        dataUnits = new int[nComponents][][];\n    } else {\n        \n        dataUnit = new int[8 * 8];\n    }\n    for (int i = 0; i < nComponents; i++) {\n        int[] frameComponent = frameComponents[componentIds[i]];\n        int bufferSize = frameComponent[CW] * frameComponent[CH];\n        imageComponents[i] = new byte[bufferSize];\n        if (progressive) {\n            dataUnits[i] = new int[bufferSize][];\n        }\n    }\n    \n    processTables();\n    \n    scanHeader = new JPEGScanHeader(inputStream);\n    if (!scanHeader.verify())\n        SWT.error(SWT.ERROR_INVALID_IMAGE);\n    \n    int progressiveScanCount = 0;\n    boolean done = false;\n    while (!done) {\n        resetInputBuffer();\n        precedingDCs = new int[4];\n        decodeScan();\n        if (progressive && loader.hasListeners()) {\n            ImageData imageData = createImageData();\n            loader.notifyListeners(new ImageLoaderEvent(loader, imageData, progressiveScanCount, false));\n            progressiveScanCount++;\n        }\n        \n        int delta = 512 - bufferCurrentPosition - 1;\n        if (delta > 0) {\n            byte[] unreadBuffer = new byte[delta];\n            System.arraycopy(dataBuffer, bufferCurrentPosition + 1, unreadBuffer, 0, delta);\n            try {\n                inputStream.unread(unreadBuffer);\n            } catch (IOException e) {\n                SWT.error(SWT.ERROR_IO, e);\n            }\n        }\n        \n        JPEGSegment jpegSegment = processTables();\n        if (jpegSegment == null || jpegSegment.getSegmentMarker() == EOI) {\n            done = true;\n        } else {\n            scanHeader = new JPEGScanHeader(inputStream);\n            if (!scanHeader.verify())\n                SWT.error(SWT.ERROR_INVALID_IMAGE);\n        }\n    }\n    if (progressive) {\n        for (int ymcu = 0; ymcu < interleavedMcuRows; ymcu++) {\n            for (int xmcu = 0; xmcu < interleavedMcuCols; xmcu++) {\n                for (int iComp = 0; iComp < nComponents; iComp++) {\n                    int[] frameComponent = frameComponents[componentIds[iComp]];\n                    int hi = frameComponent[HI];\n                    int vi = frameComponent[VI];\n                    int compWidth = frameComponent[CW];\n                    for (int ivi = 0; ivi < vi; ivi++) {\n                        for (int ihi = 0; ihi < hi; ihi++) {\n                            int index = (ymcu * vi + ivi) * compWidth + xmcu * hi + ihi;\n                            dataUnit = dataUnits[iComp][index];\n                            dequantize(dataUnit, iComp);\n                            inverseDCT(dataUnit);\n                            storeData(dataUnit, iComp, xmcu, ymcu, hi, ihi, vi, ivi);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    ImageData imageData = createImageData();\n    if (progressive && loader.hasListeners()) {\n        loader.notifyListeners(new ImageLoaderEvent(loader, imageData, progressiveScanCount, true));\n    }\n    return new ImageData[] { imageData };\n}",
			"comments":"/* Process the tables preceding the frame header. */\n/* Start of Frame. */\n// Progressive jpeg: need to keep all of the data units.\n// Sequential jpeg: only need one data unit.\n/* Process the tables preceding the scan header. */\n/* Start of Scan. */\n/* Process scan(s) and further tables until EOI. */\n/* Unread any buffered data before looking for tables again. */\n/* Process the tables preceding the next scan header. */\n",
			"methodName":"ImageData[] loadFromByteStream()"
		},
		"void convertMultiRGBToYCbCr(ImageData image)":{
			"methodBody":"{\n    int srcWidth = image.width;\n    int srcHeight = image.height;\n    int bSize = srcWidth * srcHeight;\n    byte[] dataYComp = new byte[bSize];\n    byte[] dataCbComp = new byte[bSize];\n    byte[] dataCrComp = new byte[bSize];\n    PaletteData palette = image.palette;\n    int[] buffer = new int[srcWidth];\n    if (palette.isDirect) {\n        int redMask = palette.redMask;\n        int greenMask = palette.greenMask;\n        int blueMask = palette.blueMask;\n        int redShift = palette.redShift;\n        int greenShift = palette.greenShift;\n        int blueShift = palette.blueShift;\n        for (int yPos = 0; yPos < srcHeight; yPos++) {\n            image.getPixels(0, yPos, srcWidth, buffer, 0);\n            int dstRowIndex = yPos * srcWidth;\n            for (int xPos = 0; xPos < srcWidth; xPos++) {\n                int pixel = buffer[xPos];\n                int dstDataIndex = dstRowIndex + xPos;\n                int r = pixel & redMask;\n                r = (redShift < 0) ? r >>> -redShift : r << redShift;\n                int g = pixel & greenMask;\n                g = (greenShift < 0) ? g >>> -greenShift : g << greenShift;\n                int b = pixel & blueMask;\n                b = (blueShift < 0) ? b >>> -blueShift : b << blueShift;\n                dataYComp[dstDataIndex] = (byte) ((RYTable[r] + GYTable[g] + BYTable[b]) / 65536);\n                dataCbComp[dstDataIndex] = (byte) ((RCbTable[r] + GCbTable[g] + BCbTable[b]) / 65536);\n                dataCrComp[dstDataIndex] = (byte) ((RCrTable[r] + GCrTable[g] + BCrTable[b]) / 65536);\n            }\n        }\n    } else {\n        for (int yPos = 0; yPos < srcHeight; yPos++) {\n            image.getPixels(0, yPos, srcWidth, buffer, 0);\n            int dstRowIndex = yPos * srcWidth;\n            for (int xPos = 0; xPos < srcWidth; xPos++) {\n                int pixel = buffer[xPos];\n                int dstDataIndex = dstRowIndex + xPos;\n                RGB rgb = palette.getRGB(pixel);\n                int r = rgb.red;\n                int g = rgb.green;\n                int b = rgb.blue;\n                dataYComp[dstDataIndex] = (byte) ((RYTable[r] + GYTable[g] + BYTable[b]) / 65536);\n                dataCbComp[dstDataIndex] = (byte) ((RCbTable[r] + GCbTable[g] + BCbTable[b]) / 65536);\n                dataCrComp[dstDataIndex] = (byte) ((RCrTable[r] + GCrTable[g] + BCrTable[b]) / 65536);\n            }\n        }\n    }\n    compress(image, dataYComp, dataCbComp, dataCrComp);\n}",
			"comments":"",
			"methodName":"void convertMultiRGBToYCbCr(ImageData image)"
		},
		"byte[] convertYIQToRGB()":{
			"methodBody":"{\n    \n    return new byte[0];\n}",
			"comments":"/* Unsupported CMYK format. Answer an empty byte array. */\n",
			"methodName":"byte[] convertYIQToRGB()"
		},
		"void storeData(int[] dataUnit, int iComp, int xmcu, int ymcu, int hi, int ihi, int vi, int ivi)":{
			"methodBody":"{\n    byte[] compImage = imageComponents[iComp];\n    int[] frameComponent = frameComponents[componentIds[iComp]];\n    int compWidth = frameComponent[CW];\n    int destIndex = ((ymcu * vi + ivi) * compWidth * DCTSIZE) + ((xmcu * hi + ihi) * DCTSIZE);\n    int srcIndex = 0;\n    for (int i = 0; i < DCTSIZE; i++) {\n        for (int col = 0; col < DCTSIZE; col++) {\n            int x = dataUnit[srcIndex] + 128;\n            if (x < 0) {\n                x = 0;\n            } else {\n                if (x > 255)\n                    x = 255;\n            }\n            compImage[destIndex + col] = (byte) x;\n            srcIndex++;\n        }\n        destIndex += compWidth;\n    }\n}",
			"comments":"",
			"methodName":"void storeData(int[] dataUnit, int iComp, int xmcu, int ymcu, int hi, int ihi, int vi, int ivi)"
		},
		"byte[] convertYToRGB()":{
			"methodBody":"{\n    int compWidth = frameComponents[componentIds[ID_Y]][CW];\n    int bytesPerLine = (((imageWidth * 8 + 7) / 8) + 3) / 4 * 4;\n    byte[] data = new byte[bytesPerLine * imageHeight];\n    byte[] yComp = imageComponents[ID_Y];\n    int destIndex = 0;\n    for (int i = 0; i < imageHeight; i++) {\n        int srcIndex = i * compWidth;\n        for (int j = 0; j < bytesPerLine; j++) {\n            int y = yComp[srcIndex] & 0xFF;\n            if (y < 0) {\n                y = 0;\n            } else {\n                if (y > 255)\n                    y = 255;\n            }\n            if (j >= imageWidth) {\n                y = 0;\n            }\n            data[destIndex] = (byte) y;\n            srcIndex++;\n            destIndex++;\n        }\n    }\n    return data;\n}",
			"comments":"",
			"methodName":"byte[] convertYToRGB()"
		},
		"void getDAC()":{
			"methodBody":"{\n    new JPEGArithmeticConditioningTable(inputStream);\n}",
			"comments":"",
			"methodName":"void getDAC()"
		},
		"static void initializeYCbCrRGBTables()":{
			"methodBody":"{\n    CrRTable = new int[256];\n    CbBTable = new int[256];\n    CrGTable = new int[256];\n    CbGTable = new int[256];\n    for (int i = 0; i < 256; i++) {\n        int x2 = 2 * i - 255;\n        CrRTable[i] = (45941 * x2 + 32768) / 65536;\n        CbBTable[i] = (58065 * x2 + 32768) / 65536;\n        CrGTable[i] = -23401 * x2;\n        CbGTable[i] = -11277 * x2 + 32768;\n    }\n}",
			"comments":"",
			"methodName":"static void initializeYCbCrRGBTables()"
		},
		"PaletteData setUpPalette()":{
			"methodBody":"{\n    if (nComponents == 1) {\n        RGB[] entries = new RGB[256];\n        for (int i = 0; i < 256; i++) {\n            entries[i] = new RGB(i, i, i);\n        }\n        return new PaletteData(entries);\n    }\n    return new PaletteData(0xFF, 0xFF00, 0xFF0000);\n}",
			"comments":"",
			"methodName":"PaletteData setUpPalette()"
		},
		"void encodeDCCoefficients(int[] dataUnit, int iComp)":{
			"methodBody":"{\n    int[] sParams = scanHeader.componentParameters[iComp];\n    JPEGHuffmanTable dcTable = dcHuffmanTables[sParams[DC]];\n    int lastDC = precedingDCs[iComp];\n    int dcValue = dataUnit[0];\n    int diff = dcValue - lastDC;\n    precedingDCs[iComp] = dcValue;\n    if (diff < 0) {\n        int absDiff = 0 - diff;\n        int nBits = NBitsTable[absDiff];\n        emit(dcTable.ehCodes[nBits], dcTable.ehCodeLengths[nBits]);\n        emit(0xFFFFFF - absDiff, nBits);\n    } else {\n        int nBits = NBitsTable[diff];\n        emit(dcTable.ehCodes[nBits], dcTable.ehCodeLengths[nBits]);\n        if (nBits != 0) {\n            emit(diff, nBits);\n        }\n    }\n}",
			"comments":"",
			"methodName":"void encodeDCCoefficients(int[] dataUnit, int iComp)"
		},
		"byte[] convertCMYKToRGB()":{
			"methodBody":"{\n    \n    return new byte[0];\n}",
			"comments":"/* Unsupported CMYK format. Answer an empty byte array. */\n",
			"methodName":"byte[] convertCMYKToRGB()"
		},
		"void decodeMCUAtXAndY(int xmcu, int ymcu, int nComponentsInScan, boolean first, int start, int end, int approxBit)":{
			"methodBody":"{\n    for (int iComp = 0; iComp < nComponentsInScan; iComp++) {\n        int scanComponent = iComp;\n        while (scanHeader.componentParameters[componentIds[scanComponent]] == null) {\n            scanComponent++;\n        }\n        int[] frameComponent = frameComponents[componentIds[scanComponent]];\n        int hi = frameComponent[HI];\n        int vi = frameComponent[VI];\n        if (nComponentsInScan == 1) {\n            hi = 1;\n            vi = 1;\n        }\n        int compWidth = frameComponent[CW];\n        for (int ivi = 0; ivi < vi; ivi++) {\n            for (int ihi = 0; ihi < hi; ihi++) {\n                if (progressive) {\n                    \n                    \n                    int index = (ymcu * vi + ivi) * compWidth + xmcu * hi + ihi;\n                    dataUnit = dataUnits[scanComponent][index];\n                    if (dataUnit == null) {\n                        dataUnit = new int[64];\n                        dataUnits[scanComponent][index] = dataUnit;\n                    }\n                } else {\n                    \n                    for (int i = 0; i < dataUnit.length; i++) {\n                        dataUnit[i] = 0;\n                    }\n                }\n                if (!progressive || scanHeader.isDCProgressiveScan()) {\n                    decodeDCCoefficient(dataUnit, scanComponent, first, approxBit);\n                }\n                if (!progressive) {\n                    decodeACCoefficients(dataUnit, scanComponent);\n                } else {\n                    if (scanHeader.isACProgressiveScan()) {\n                        if (first) {\n                            decodeACFirstCoefficients(dataUnit, scanComponent, start, end, approxBit);\n                        } else {\n                            decodeACRefineCoefficients(dataUnit, scanComponent, start, end, approxBit);\n                        }\n                    }\n                    if (loader.hasListeners()) {\n                        \n                        \n                        \n                        int[] temp = dataUnit;\n                        dataUnit = new int[64];\n                        System.arraycopy(temp, 0, dataUnit, 0, 64);\n                    }\n                }\n                if (!progressive || (progressive && loader.hasListeners())) {\n                    dequantize(dataUnit, scanComponent);\n                    inverseDCT(dataUnit);\n                    storeData(dataUnit, scanComponent, xmcu, ymcu, hi, ihi, vi, ivi);\n                }\n            }\n        }\n    }\n}",
			"comments":"// Progressive: First scan - create a new data unit.\n// Subsequent scans - refine the existing data unit.\n// Sequential: Clear and reuse the data unit buffer.\n// Dequantization, IDCT, up-sampling and color conversion\n// are done on a copy of the coefficient data in order to\n// display the image incrementally.\n",
			"methodName":"void decodeMCUAtXAndY(int xmcu, int ymcu, int nComponentsInScan, boolean first, int start, int end, int approxBit)"
		},
		"void getDHT()":{
			"methodBody":"{\n    JPEGHuffmanTable dht = new JPEGHuffmanTable(inputStream);\n    if (!dht.verify()) {\n        SWT.error(SWT.ERROR_INVALID_IMAGE);\n    }\n    if (acHuffmanTables == null) {\n        acHuffmanTables = new JPEGHuffmanTable[4];\n    }\n    if (dcHuffmanTables == null) {\n        dcHuffmanTables = new JPEGHuffmanTable[4];\n    }\n    JPEGHuffmanTable[] dhtTables = dht.getAllTables();\n    for (int i = 0; i < dhtTables.length; i++) {\n        JPEGHuffmanTable dhtTable = dhtTables[i];\n        if (dhtTable.getTableClass() == 0) {\n            dcHuffmanTables[dhtTable.getTableIdentifier()] = dhtTable;\n        } else {\n            acHuffmanTables[dhtTable.getTableIdentifier()] = dhtTable;\n        }\n    }\n}",
			"comments":"",
			"methodName":"void getDHT()"
		},
		"static JPEGSegment seekUnspecifiedMarker(LEDataInputStream byteStream)":{
			"methodBody":"{\n    byte[] byteArray = new byte[2];\n    try {\n        while (true) {\n            if (byteStream.read(byteArray, 0, 1) != 1)\n                return null;\n            if (byteArray[0] == (byte) 0xFF) {\n                if (byteStream.read(byteArray, 1, 1) != 1)\n                    return null;\n                if (byteArray[1] != (byte) 0xFF && byteArray[1] != 0) {\n                    byteStream.unread(byteArray);\n                    return new JPEGSegment(byteArray);\n                }\n            }\n        }\n    } catch (IOException e) {\n        SWT.error(SWT.ERROR_IO, e);\n    }\n    return null;\n}",
			"comments":"",
			"methodName":"static JPEGSegment seekUnspecifiedMarker(LEDataInputStream byteStream)"
		},
		"void convert4BitRGBToYCbCr(ImageData image)":{
			"methodBody":"{\n    RGB[] rgbs = image.getRGBs();\n    int paletteSize = rgbs.length;\n    byte[] yComp = new byte[paletteSize];\n    byte[] cbComp = new byte[paletteSize];\n    byte[] crComp = new byte[paletteSize];\n    int srcWidth = image.width;\n    int srcHeight = image.height;\n    for (int i = 0; i < paletteSize; i++) {\n        RGB color = rgbs[i];\n        int r = color.red;\n        int g = color.green;\n        int b = color.blue;\n        int n = RYTable[r] + GYTable[g] + BYTable[b];\n        yComp[i] = (byte) (n / 65536);\n        if ((n < 0) && (n % 65536 != 0))\n            yComp[i]--;\n        n = RCbTable[r] + GCbTable[g] + BCbTable[b];\n        cbComp[i] = (byte) (n / 65536);\n        if ((n < 0) && (n % 65536 != 0))\n            cbComp[i]--;\n        n = RCrTable[r] + GCrTable[g] + BCrTable[b];\n        crComp[i] = (byte) (n / 65536);\n        if ((n < 0) && (n % 65536 != 0))\n            crComp[i]--;\n    }\n    int bSize = srcWidth * srcHeight;\n    byte[] dataYComp = new byte[bSize];\n    byte[] dataCbComp = new byte[bSize];\n    byte[] dataCrComp = new byte[bSize];\n    byte[] origData = image.data;\n    int bytesPerLine = image.bytesPerLine;\n    int maxScanlineByte = srcWidth / 2;\n    for (int yPos = 0; yPos < srcHeight; yPos++) {\n        for (int xPos = 0; xPos < maxScanlineByte; xPos++) {\n            int srcIndex = yPos * bytesPerLine + xPos;\n            int dstIndex = yPos * srcWidth + (xPos * 2);\n            int value2 = origData[srcIndex] & 0xFF;\n            int value1 = value2 / 16;\n            value2 = value2 % 16;\n            dataYComp[dstIndex] = yComp[value1];\n            dataCbComp[dstIndex] = cbComp[value1];\n            dataCrComp[dstIndex] = crComp[value1];\n            dataYComp[dstIndex + 1] = yComp[value2];\n            dataCbComp[dstIndex + 1] = cbComp[value2];\n            dataCrComp[dstIndex + 1] = crComp[value2];\n        }\n    }\n    compress(image, dataYComp, dataCbComp, dataCrComp);\n}",
			"comments":"",
			"methodName":"void convert4BitRGBToYCbCr(ImageData image)"
		},
		"int nextBit()":{
			"methodBody":"{\n    if (currentBitCount != 0) {\n        currentBitCount--;\n        currentByte *= 2;\n        if (currentByte > 255) {\n            currentByte -= 256;\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n    bufferCurrentPosition++;\n    if (bufferCurrentPosition >= 512) {\n        resetInputBuffer();\n        bufferCurrentPosition = 0;\n    }\n    currentByte = dataBuffer[bufferCurrentPosition] & 0xFF;\n    currentBitCount = 8;\n    byte nextByte;\n    if (bufferCurrentPosition == 511) {\n        resetInputBuffer();\n        currentBitCount = 8;\n        nextByte = dataBuffer[0];\n    } else {\n        nextByte = dataBuffer[bufferCurrentPosition + 1];\n    }\n    if (currentByte == 0xFF) {\n        if (nextByte == 0) {\n            bufferCurrentPosition++;\n            currentBitCount--;\n            currentByte *= 2;\n            if (currentByte > 255) {\n                currentByte -= 256;\n                return 1;\n            } else {\n                return 0;\n            }\n        } else {\n            if ((nextByte & 0xFF) + 0xFF00 == DNL) {\n                getDNL();\n                return 0;\n            } else {\n                SWT.error(SWT.ERROR_INVALID_IMAGE);\n                return 0;\n            }\n        }\n    } else {\n        currentBitCount--;\n        currentByte *= 2;\n        if (currentByte > 255) {\n            currentByte -= 256;\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n}",
			"comments":"",
			"methodName":"int nextBit()"
		},
		"void dequantize(int[] dataUnit, int iComp)":{
			"methodBody":"{\n    int[] qTable = quantizationTables[frameComponents[componentIds[iComp]][TQI]];\n    for (int i = 0; i < dataUnit.length; i++) {\n        int zzIndex = ZigZag8x8[i];\n        dataUnit[zzIndex] = dataUnit[zzIndex] * qTable[i];\n    }\n}",
			"comments":"",
			"methodName":"void dequantize(int[] dataUnit, int iComp)"
		}
	},
	"ClassORInterfaceName":[
		"JPEGFileFormat"
	]
}
