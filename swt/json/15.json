{
	"variables":[
		"frame",
		"site",
		"auto",
		"back",
		"forward",
		"navigate",
		"delaySetText",
		"location",
		"size",
		"addressBar",
		"menuBar",
		"statusBar",
		"toolBar",
		"info",
		"globalDispatch",
		"html",
		"closeWindowListeners",
		"locationListeners",
		"openWindowListeners",
		"progressListeners",
		"statusTextListeners",
		"titleListeners",
		"visibilityWindowListeners",
		"BeforeNavigate2",
		"CommandStateChange",
		"DocumentComplete",
		"NavigateComplete2",
		"NewWindow2",
		"OnMenuBar",
		"OnStatusBar",
		"OnToolBar",
		"OnVisible",
		"ProgressChange",
		"RegisterAsBrowser",
		"StatusTextChange",
		"TitleChange",
		"WindowClosing",
		"WindowSetHeight",
		"WindowSetLeft",
		"WindowSetResizable",
		"WindowSetTop",
		"WindowSetWidth",
		"CSC_NAVIGATEFORWARD",
		"CSC_NAVIGATEBACK",
		"INET_E_DEFAULT_ACTION",
		"READYSTATE_COMPLETE",
		"URLPOLICY_ALLOW",
		"URLPOLICY_DISALLOW",
		"URLZONE_LOCAL_MACHINE",
		"URLZONE_INTRANET",
		"URLACTION_ACTIVEX_MIN",
		"URLACTION_ACTIVEX_MAX",
		"URLACTION_ACTIVEX_RUN",
		"URLACTION_JAVA_MIN",
		"URLPOLICY_JAVA_LOW",
		"URLACTION_JAVA_MAX",
		"DISPID_AMBIENT_DLCONTROL",
		"DLCTL_DLIMAGES",
		"DLCTL_VIDEOS",
		"DLCTL_BGSOUNDS",
		"DLCTL_NO_SCRIPTS",
		"DLCTL_NO_JAVA",
		"DLCTL_NO_RUNACTIVEXCTLS",
		"DLCTL_NO_DLACTIVEXCTLS",
		"DLCTL_DOWNLOADONLY",
		"DLCTL_NO_FRAMEDOWNLOAD",
		"DLCTL_RESYNCHRONIZE",
		"DLCTL_PRAGMA_NO_CACHE",
		"DLCTL_FORCEOFFLINE",
		"DLCTL_NO_CLIENTPULL",
		"DLCTL_SILENT",
		"DOCHOSTUIFLAG_THEME",
		"DOCHOSTUIFLAG_NO3DBORDER",
		"DOCHOSTUIFLAG_NO3DOUTERBORDER",
		"ABOUT_BLANK",
		"URL_DIRECTOR",
		"PACKAGE_PREFIX",
		"listener",
		"oleListener",
		"varResult",
		"url",
		"newEvent",
		"i",
		"cancel",
		"pCancel",
		"enabled",
		"varResult",
		"command",
		"varResult",
		"dispatch",
		"url",
		"runnable",
		"charCount",
		"chars",
		"byteCount",
		"UTF8BOM",
		"hGlobal",
		"ppstm",
		"rgdispid",
		"pVarResult",
		"dispatchDocument",
		"ppvObject",
		"result",
		"persistStreamInit",
		"stream",
		"variant",
		"top",
		"locationEvent",
		"i",
		"progressEvent",
		"i",
		"varResult",
		"dispatch",
		"cancel",
		"pCancel",
		"newEvent",
		"i",
		"browser",
		"doit",
		"variant",
		"iDispatch",
		"ppDisp",
		"byref",
		"arg0",
		"arg0",
		"arg0",
		"arg1",
		"visible",
		"newEvent",
		"rgdispid",
		"pVarResult",
		"i",
		"i",
		"arg1",
		"nProgress",
		"arg2",
		"nProgressMax",
		"newEvent",
		"i",
		"arg1",
		"text",
		"newEvent",
		"i",
		"arg1",
		"title",
		"newEvent",
		"i",
		"newEvent",
		"i",
		"cancel",
		"pCancel",
		"arg1",
		"arg1",
		"arg1",
		"arg1",
		"arguments",
		"i",
		"variant",
		"rgdispid",
		"newCloseWindowListeners",
		"newLocationListeners",
		"newOpenWindowListeners",
		"newProgressListeners",
		"newStatusTextListeners",
		"newTitleListeners",
		"newVisibilityWindowListeners",
		"rgdispid",
		"pVarResult",
		"name",
		"index",
		"rgdispid",
		"dispIdMember",
		"pVarResult",
		"document",
		"ihtmlWindow2",
		"rgvarg",
		"rgdispidNamedArgs",
		"rgdispid",
		"pVarResult",
		"rgdispid",
		"pVarResult",
		"result",
		"rgdispid",
		"index",
		"i",
		"newCloseWindowListeners",
		"index",
		"i",
		"newLocationListeners",
		"index",
		"i",
		"newOpenWindowListeners",
		"index",
		"i",
		"newProgressListeners",
		"index",
		"i",
		"newStatusTextListeners",
		"index",
		"i",
		"newTitleListeners",
		"index",
		"i",
		"newVisibilityWindowListeners",
		"blankLoading",
		"rgdispid",
		"pVarResult",
		"rgvarg",
		"rgdispidNamedArgs",
		"pVarResult",
		"result",
		"rgdispid",
		"rgvarg",
		"rgdispidNamedArgs",
		"rgdispid",
		"rgdispid",
		"rgvarg",
		"rgdispidNamedArgs",
		"pVarResult",
		"result",
		"rgdispid",
		"parent",
		"style",
		"SWT",
		"info",
		"Browser",
		"style",
		"SWT",
		"info",
		"Browser",
		"frame",
		"SWT",
		"site",
		"frame",
		"SWT",
		"SWT",
		"SWT",
		"site",
		"OLE",
		"auto",
		"site",
		"e",
		"SWT",
		"auto",
		"auto",
		"auto",
		"SWT",
		"frame",
		"SWT",
		"SWT",
		"e",
		"e",
		"SWT",
		"listener",
		"SWT",
		"listener",
		"site",
		"SWT",
		"listener",
		"site",
		"SWT",
		"listener",
		"event",
		"BeforeNavigate2",
		"event",
		"varResult",
		"Browser",
		"newEvent",
		"newEvent",
		"Browser",
		"newEvent",
		"url",
		"newEvent",
		"i",
		"locationListeners",
		"i",
		"locationListeners",
		"i",
		"newEvent",
		"event",
		"cancel",
		"cancel",
		"COM",
		"pCancel",
		"newEvent",
		"COM",
		"COM",
		"CommandStateChange",
		"event",
		"varResult",
		"varResult",
		"event",
		"enabled",
		"varResult",
		"command",
		"CSC_NAVIGATEBACK",
		"back",
		"enabled",
		"CSC_NAVIGATEFORWARD",
		"forward",
		"enabled",
		"DocumentComplete",
		"event",
		"varResult",
		"varResult",
		"event",
		"varResult",
		"html",
		"url",
		"ABOUT_BLANK",
		"html",
		"html",
		"charCount",
		"html",
		"charCount",
		"chars",
		"html",
		"OS",
		"OS",
		"chars",
		"charCount",
		"OS",
		"OS",
		"UTF8BOM",
		"byteCount",
		"hGlobal",
		"OS",
		"hGlobal",
		"UTF8BOM",
		"UTF8BOM",
		"OS",
		"OS",
		"chars",
		"charCount",
		"hGlobal",
		"UTF8BOM",
		"byteCount",
		"OS",
		"hGlobal",
		"ppstm",
		"OS",
		"auto",
		"auto",
		"rgdispid",
		"pVarResult",
		"dispatchDocument",
		"COM",
		"ppvObject",
		"result",
		"OS",
		"ppvObject",
		"persistStreamInit",
		"OS",
		"persistStreamInit",
		"ppstm",
		"persistStreamInit",
		"pVarResult",
		"ppstm",
		"stream",
		"OS",
		"hGlobal",
		"delaySetText",
		"delaySetText",
		"runnable",
		"runnable",
		"auto",
		"variant",
		"Browser",
		"locationEvent",
		"locationEvent",
		"Browser",
		"locationEvent",
		"url",
		"locationEvent",
		"top",
		"dispatch",
		"i",
		"locationListeners",
		"i",
		"locationListeners",
		"i",
		"locationEvent",
		"globalDispatch",
		"dispatch",
		"globalDispatch",
		"globalDispatch",
		"Browser",
		"progressEvent",
		"progressEvent",
		"Browser",
		"i",
		"progressListeners",
		"i",
		"progressListeners",
		"i",
		"progressEvent",
		"NavigateComplete2",
		"event",
		"varResult",
		"globalDispatch",
		"globalDispatch",
		"dispatch",
		"NewWindow2",
		"event",
		"cancel",
		"Browser",
		"newEvent",
		"newEvent",
		"Browser",
		"newEvent",
		"i",
		"openWindowListeners",
		"i",
		"openWindowListeners",
		"i",
		"newEvent",
		"newEvent",
		"browser",
		"browser",
		"doit",
		"browser",
		"variant",
		"event",
		"ppDisp",
		"byref",
		"COM",
		"byref",
		"iDispatch",
		"newEvent",
		"COM",
		"pCancel",
		"doit",
		"COM",
		"COM",
		"OnMenuBar",
		"event",
		"menuBar",
		"arg0",
		"OnStatusBar",
		"event",
		"statusBar",
		"arg0",
		"OnToolBar",
		"event",
		"toolBar",
		"arg0",
		"toolBar",
		"addressBar",
		"menuBar",
		"OnVisible",
		"event",
		"arg1",
		"Browser",
		"newEvent",
		"newEvent",
		"Browser",
		"visible",
		"addressBar",
		"auto",
		"auto",
		"rgdispid",
		"pVarResult",
		"pVarResult",
		"OLE",
		"addressBar",
		"pVarResult",
		"newEvent",
		"addressBar",
		"newEvent",
		"menuBar",
		"newEvent",
		"statusBar",
		"newEvent",
		"toolBar",
		"newEvent",
		"location",
		"newEvent",
		"size",
		"i",
		"visibilityWindowListeners",
		"i",
		"visibilityWindowListeners",
		"i",
		"newEvent",
		"location",
		"size",
		"i",
		"visibilityWindowListeners",
		"i",
		"visibilityWindowListeners",
		"i",
		"newEvent",
		"ProgressChange",
		"event",
		"arg1",
		"OLE",
		"arg1",
		"event",
		"arg2",
		"OLE",
		"arg2",
		"Browser",
		"newEvent",
		"newEvent",
		"Browser",
		"newEvent",
		"nProgress",
		"newEvent",
		"nProgressMax",
		"nProgress",
		"i",
		"progressListeners",
		"i",
		"progressListeners",
		"i",
		"newEvent",
		"StatusTextChange",
		"event",
		"arg1",
		"OLE",
		"arg1",
		"Browser",
		"newEvent",
		"newEvent",
		"Browser",
		"newEvent",
		"text",
		"i",
		"statusTextListeners",
		"i",
		"statusTextListeners",
		"i",
		"newEvent",
		"TitleChange",
		"event",
		"arg1",
		"OLE",
		"arg1",
		"Browser",
		"newEvent",
		"newEvent",
		"Browser",
		"newEvent",
		"title",
		"i",
		"titleListeners",
		"i",
		"titleListeners",
		"i",
		"newEvent",
		"WindowClosing",
		"Browser",
		"newEvent",
		"newEvent",
		"Browser",
		"i",
		"closeWindowListeners",
		"i",
		"closeWindowListeners",
		"i",
		"newEvent",
		"event",
		"cancel",
		"COM",
		"pCancel",
		"COM",
		"WindowSetHeight",
		"size",
		"size",
		"event",
		"size",
		"arg1",
		"WindowSetLeft",
		"location",
		"location",
		"event",
		"location",
		"arg1",
		"WindowSetTop",
		"location",
		"location",
		"event",
		"location",
		"arg1",
		"WindowSetWidth",
		"size",
		"size",
		"event",
		"size",
		"arg1",
		"event",
		"i",
		"arguments",
		"i",
		"arguments",
		"i",
		"site",
		"BeforeNavigate2",
		"oleListener",
		"site",
		"CommandStateChange",
		"oleListener",
		"site",
		"DocumentComplete",
		"oleListener",
		"site",
		"NavigateComplete2",
		"oleListener",
		"site",
		"NewWindow2",
		"oleListener",
		"site",
		"OnMenuBar",
		"oleListener",
		"site",
		"OnStatusBar",
		"oleListener",
		"site",
		"OnToolBar",
		"oleListener",
		"site",
		"OnVisible",
		"oleListener",
		"site",
		"ProgressChange",
		"oleListener",
		"site",
		"StatusTextChange",
		"oleListener",
		"site",
		"TitleChange",
		"oleListener",
		"site",
		"WindowClosing",
		"oleListener",
		"site",
		"WindowSetHeight",
		"oleListener",
		"site",
		"WindowSetLeft",
		"oleListener",
		"site",
		"WindowSetTop",
		"oleListener",
		"site",
		"WindowSetWidth",
		"oleListener",
		"auto",
		"RegisterAsBrowser",
		"variant",
		"variant",
		"variant",
		"auto",
		"rgdispid",
		"auto",
		"rgdispid",
		"variant",
		"variant",
		"listener",
		"SWT",
		"SWT",
		"closeWindowListeners",
		"System",
		"closeWindowListeners",
		"newCloseWindowListeners",
		"closeWindowListeners",
		"closeWindowListeners",
		"newCloseWindowListeners",
		"closeWindowListeners",
		"closeWindowListeners",
		"listener",
		"listener",
		"SWT",
		"SWT",
		"locationListeners",
		"System",
		"locationListeners",
		"newLocationListeners",
		"locationListeners",
		"locationListeners",
		"newLocationListeners",
		"locationListeners",
		"locationListeners",
		"listener",
		"listener",
		"SWT",
		"SWT",
		"openWindowListeners",
		"System",
		"openWindowListeners",
		"newOpenWindowListeners",
		"openWindowListeners",
		"openWindowListeners",
		"newOpenWindowListeners",
		"openWindowListeners",
		"openWindowListeners",
		"listener",
		"listener",
		"SWT",
		"SWT",
		"progressListeners",
		"System",
		"progressListeners",
		"newProgressListeners",
		"progressListeners",
		"progressListeners",
		"newProgressListeners",
		"progressListeners",
		"progressListeners",
		"listener",
		"listener",
		"SWT",
		"SWT",
		"statusTextListeners",
		"System",
		"statusTextListeners",
		"newStatusTextListeners",
		"statusTextListeners",
		"statusTextListeners",
		"newStatusTextListeners",
		"statusTextListeners",
		"statusTextListeners",
		"listener",
		"listener",
		"SWT",
		"SWT",
		"titleListeners",
		"System",
		"titleListeners",
		"newTitleListeners",
		"titleListeners",
		"titleListeners",
		"newTitleListeners",
		"titleListeners",
		"titleListeners",
		"listener",
		"listener",
		"SWT",
		"SWT",
		"visibilityWindowListeners",
		"System",
		"visibilityWindowListeners",
		"newVisibilityWindowListeners",
		"visibilityWindowListeners",
		"visibilityWindowListeners",
		"newVisibilityWindowListeners",
		"visibilityWindowListeners",
		"visibilityWindowListeners",
		"listener",
		"back",
		"auto",
		"auto",
		"rgdispid",
		"pVarResult",
		"pVarResult",
		"OLE",
		"name",
		"name",
		"index",
		"PACKAGE_PREFIX",
		"SWT",
		"SWT",
		"script",
		"SWT",
		"SWT",
		"auto",
		"rgdispid",
		"auto",
		"dispIdMember",
		"pVarResult",
		"pVarResult",
		"COM",
		"pVarResult",
		"pVarResult",
		"rgdispid",
		"document",
		"dispIdMember",
		"rgdispid",
		"pVarResult",
		"document",
		"dispIdMember",
		"pVarResult",
		"pVarResult",
		"document",
		"rgdispid",
		"ihtmlWindow2",
		"rgvarg",
		"script",
		"rgdispidNamedArgs",
		"rgdispid",
		"pVarResult",
		"ihtmlWindow2",
		"rgdispid",
		"rgvarg",
		"rgdispidNamedArgs",
		"rgvarg",
		"ihtmlWindow2",
		"pVarResult",
		"pVarResult",
		"forward",
		"auto",
		"auto",
		"rgdispid",
		"pVarResult",
		"pVarResult",
		"OLE",
		"back",
		"forward",
		"auto",
		"auto",
		"rgdispid",
		"pVarResult",
		"pVarResult",
		"OLE",
		"pVarResult",
		"pVarResult",
		"result",
		"auto",
		"auto",
		"rgdispid",
		"listener",
		"SWT",
		"SWT",
		"closeWindowListeners",
		"i",
		"closeWindowListeners",
		"i",
		"listener",
		"closeWindowListeners",
		"i",
		"index",
		"i",
		"index",
		"closeWindowListeners",
		"closeWindowListeners",
		"closeWindowListeners",
		"System",
		"closeWindowListeners",
		"newCloseWindowListeners",
		"index",
		"System",
		"closeWindowListeners",
		"index",
		"newCloseWindowListeners",
		"index",
		"closeWindowListeners",
		"index",
		"closeWindowListeners",
		"newCloseWindowListeners",
		"listener",
		"SWT",
		"SWT",
		"locationListeners",
		"i",
		"locationListeners",
		"i",
		"listener",
		"locationListeners",
		"i",
		"index",
		"i",
		"index",
		"locationListeners",
		"locationListeners",
		"locationListeners",
		"System",
		"locationListeners",
		"newLocationListeners",
		"index",
		"System",
		"locationListeners",
		"index",
		"newLocationListeners",
		"index",
		"locationListeners",
		"index",
		"locationListeners",
		"newLocationListeners",
		"listener",
		"SWT",
		"SWT",
		"openWindowListeners",
		"i",
		"openWindowListeners",
		"i",
		"listener",
		"openWindowListeners",
		"i",
		"index",
		"i",
		"index",
		"openWindowListeners",
		"openWindowListeners",
		"openWindowListeners",
		"System",
		"openWindowListeners",
		"newOpenWindowListeners",
		"index",
		"System",
		"openWindowListeners",
		"index",
		"newOpenWindowListeners",
		"index",
		"openWindowListeners",
		"index",
		"openWindowListeners",
		"newOpenWindowListeners",
		"listener",
		"SWT",
		"SWT",
		"progressListeners",
		"i",
		"progressListeners",
		"i",
		"listener",
		"progressListeners",
		"i",
		"index",
		"i",
		"index",
		"progressListeners",
		"progressListeners",
		"progressListeners",
		"System",
		"progressListeners",
		"newProgressListeners",
		"index",
		"System",
		"progressListeners",
		"index",
		"newProgressListeners",
		"index",
		"progressListeners",
		"index",
		"progressListeners",
		"newProgressListeners",
		"listener",
		"SWT",
		"SWT",
		"statusTextListeners",
		"i",
		"statusTextListeners",
		"i",
		"listener",
		"statusTextListeners",
		"i",
		"index",
		"i",
		"index",
		"statusTextListeners",
		"statusTextListeners",
		"statusTextListeners",
		"System",
		"statusTextListeners",
		"newStatusTextListeners",
		"index",
		"System",
		"statusTextListeners",
		"index",
		"newStatusTextListeners",
		"index",
		"statusTextListeners",
		"index",
		"statusTextListeners",
		"newStatusTextListeners",
		"listener",
		"SWT",
		"SWT",
		"titleListeners",
		"i",
		"titleListeners",
		"i",
		"listener",
		"titleListeners",
		"i",
		"index",
		"i",
		"index",
		"titleListeners",
		"titleListeners",
		"titleListeners",
		"System",
		"titleListeners",
		"newTitleListeners",
		"index",
		"System",
		"titleListeners",
		"index",
		"newTitleListeners",
		"index",
		"titleListeners",
		"index",
		"titleListeners",
		"newTitleListeners",
		"listener",
		"SWT",
		"SWT",
		"visibilityWindowListeners",
		"i",
		"visibilityWindowListeners",
		"i",
		"listener",
		"visibilityWindowListeners",
		"i",
		"index",
		"i",
		"index",
		"visibilityWindowListeners",
		"visibilityWindowListeners",
		"visibilityWindowListeners",
		"System",
		"visibilityWindowListeners",
		"newVisibilityWindowListeners",
		"index",
		"System",
		"visibilityWindowListeners",
		"index",
		"newVisibilityWindowListeners",
		"index",
		"visibilityWindowListeners",
		"index",
		"visibilityWindowListeners",
		"newVisibilityWindowListeners",
		"html",
		"SWT",
		"SWT",
		"html",
		"blankLoading",
		"navigate",
		"rgdispid",
		"auto",
		"auto",
		"rgdispid",
		"pVarResult",
		"delaySetText",
		"pVarResult",
		"READYSTATE_COMPLETE",
		"pVarResult",
		"rgdispid",
		"auto",
		"auto",
		"rgdispid",
		"rgdispid",
		"auto",
		"navigate",
		"rgvarg",
		"ABOUT_BLANK",
		"rgdispidNamedArgs",
		"rgdispid",
		"auto",
		"rgdispid",
		"rgvarg",
		"rgdispidNamedArgs",
		"rgvarg",
		"pVarResult",
		"pVarResult",
		"OLE",
		"pVarResult",
		"result",
		"url",
		"SWT",
		"SWT",
		"html",
		"url",
		"navigate",
		"auto",
		"rgvarg",
		"ABOUT_BLANK",
		"rgdispidNamedArgs",
		"rgdispid",
		"auto",
		"rgdispid",
		"rgvarg",
		"rgdispidNamedArgs",
		"rgvarg",
		"auto",
		"auto",
		"rgdispid",
		"auto",
		"navigate",
		"rgvarg",
		"url",
		"rgdispidNamedArgs",
		"rgdispid",
		"auto",
		"rgdispid",
		"rgvarg",
		"rgdispidNamedArgs",
		"rgvarg",
		"pVarResult",
		"pVarResult",
		"OLE",
		"pVarResult",
		"result",
		"auto",
		"auto",
		"rgdispid",
		"BORDER",
		"DOCHOSTUIFLAG_THEME",
		"BORDER",
		"DOCHOSTUIFLAG_NO3DOUTERBORDER",
		"NONE",
		"NONE",
		"ERROR_NO_HANDLES",
		"OLEIVERB_INPLACEACTIVATE",
		"type",
		"Dispose",
		"Resize",
		"KeyDown",
		"KeyUp",
		"type",
		"Dispose",
		"Resize",
		"KeyDown",
		"KeyUp",
		"type",
		"arguments",
		"display",
		"widget",
		"location",
		"doit",
		"length",
		"arguments",
		"doit",
		"VARIANT_FALSE",
		"VARIANT_TRUE",
		"arguments",
		"arguments",
		"arguments",
		"arguments",
		"CP_UTF8",
		"GMEM_FIXED",
		"length",
		"length",
		"CP_UTF8",
		"length",
		"S_OK",
		"IIDIPersistStreamInit",
		"S_OK",
		"S_OK",
		"display",
		"widget",
		"location",
		"top",
		"length",
		"display",
		"widget",
		"length",
		"arguments",
		"arguments",
		"display",
		"widget",
		"required",
		"length",
		"browser",
		"auto",
		"arguments",
		"required",
		"VARIANT_FALSE",
		"VARIANT_TRUE",
		"arguments",
		"arguments",
		"arguments",
		"arguments",
		"display",
		"widget",
		"VT_BOOL",
		"addressBar",
		"menuBar",
		"statusBar",
		"toolBar",
		"location",
		"size",
		"length",
		"length",
		"arguments",
		"VT_I4",
		"arguments",
		"VT_I4",
		"display",
		"widget",
		"current",
		"total",
		"length",
		"arguments",
		"VT_BSTR",
		"display",
		"widget",
		"text",
		"length",
		"arguments",
		"VT_BSTR",
		"display",
		"widget",
		"title",
		"length",
		"display",
		"widget",
		"length",
		"arguments",
		"VARIANT_FALSE",
		"arguments",
		"y",
		"arguments",
		"x",
		"arguments",
		"y",
		"arguments",
		"x",
		"arguments",
		"length",
		"ERROR_NULL_ARGUMENT",
		"length",
		"length",
		"length",
		"ERROR_NULL_ARGUMENT",
		"length",
		"length",
		"length",
		"ERROR_NULL_ARGUMENT",
		"length",
		"length",
		"length",
		"ERROR_NULL_ARGUMENT",
		"length",
		"length",
		"length",
		"ERROR_NULL_ARGUMENT",
		"length",
		"length",
		"length",
		"ERROR_NULL_ARGUMENT",
		"length",
		"length",
		"length",
		"ERROR_NULL_ARGUMENT",
		"length",
		"length",
		"length",
		"VT_EMPTY",
		"ERROR_INVALID_SUBCLASS",
		"ERROR_NULL_ARGUMENT",
		"VT_EMPTY",
		"VT_EMPTY",
		"VT_BSTR",
		"ERROR_NULL_ARGUMENT",
		"length",
		"length",
		"length",
		"length",
		"length",
		"ERROR_NULL_ARGUMENT",
		"length",
		"length",
		"length",
		"length",
		"length",
		"ERROR_NULL_ARGUMENT",
		"length",
		"length",
		"length",
		"length",
		"length",
		"ERROR_NULL_ARGUMENT",
		"length",
		"length",
		"length",
		"length",
		"length",
		"ERROR_NULL_ARGUMENT",
		"length",
		"length",
		"length",
		"length",
		"length",
		"ERROR_NULL_ARGUMENT",
		"length",
		"length",
		"length",
		"length",
		"length",
		"ERROR_NULL_ARGUMENT",
		"length",
		"length",
		"length",
		"length",
		"length",
		"ERROR_NULL_ARGUMENT",
		"html",
		"html",
		"VT_EMPTY",
		"ERROR_NULL_ARGUMENT",
		"VT_EMPTY",
		"parent",
		"style",
		"e",
		"e",
		"event",
		"listener",
		"listener",
		"listener",
		"listener",
		"listener",
		"listener",
		"listener",
		"script",
		"listener",
		"listener",
		"listener",
		"listener",
		"listener",
		"listener",
		"listener",
		"html",
		"url"
	],
	"extendORImplementFiles":[
		"Composite"
	],
	"package":[
		"org.eclipse.swt.browser"
	],
	"import":[
		"org.eclipse.swt",
		"org.eclipse.swt.graphics",
		"org.eclipse.swt.internal.ole.win32",
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt.ole.win32",
		"org.eclipse.swt.widgets"
	],
	"methods":[
		"handleEvent",
		"handleEvent",
		"run",
		"addCloseWindowListener",
		"addLocationListener",
		"addOpenWindowListener",
		"addProgressListener",
		"addStatusTextListener",
		"addTitleListener",
		"addVisibilityWindowListener",
		"back",
		"checkSubclass",
		"execute",
		"forward",
		"isBackEnabled",
		"isForwardEnabled",
		"getUrl",
		"refresh",
		"removeCloseWindowListener",
		"removeLocationListener",
		"removeOpenWindowListener",
		"removeProgressListener",
		"removeStatusTextListener",
		"removeTitleListener",
		"removeVisibilityWindowListener",
		"setText",
		"setUrl",
		"stop",
		"dispose",
		"error",
		"doVerb",
		"dispose",
		"setBounds",
		"getClientArea",
		"notifyListeners",
		"addListener",
		"addListener",
		"addListener",
		"addListener",
		"getString",
		"getDisplay",
		"changing",
		"getByRef",
		"MoveMemory",
		"getInt",
		"getBoolean",
		"getDispatch",
		"getString",
		"equals",
		"isDisposed",
		"length",
		"getChars",
		"WideCharToMultiByte",
		"GlobalAlloc",
		"MoveMemory",
		"WideCharToMultiByte",
		"CreateStreamOnHGlobal",
		"getIDsOfNames",
		"getProperty",
		"getDispatch",
		"QueryInterface",
		"InitNew",
		"Load",
		"Release",
		"dispose",
		"Release",
		"GlobalFree",
		"asyncExec",
		"getDisplay",
		"run",
		"getDispatch",
		"getDisplay",
		"getAddress",
		"getAddress",
		"changed",
		"getAddress",
		"getDisplay",
		"completed",
		"getDispatch",
		"getAddress",
		"getByRef",
		"getDisplay",
		"open",
		"isDisposed",
		"getDispatch",
		"getByRef",
		"MoveMemory",
		"getAddress",
		"MoveMemory",
		"getBoolean",
		"getBoolean",
		"getBoolean",
		"getBoolean",
		"getDisplay",
		"getIDsOfNames",
		"getProperty",
		"getType",
		"getBoolean",
		"show",
		"hide",
		"getType",
		"getInt",
		"getType",
		"getInt",
		"getDisplay",
		"changed",
		"getType",
		"getString",
		"getDisplay",
		"changed",
		"getType",
		"getString",
		"getDisplay",
		"changed",
		"getDisplay",
		"close",
		"getByRef",
		"MoveMemory",
		"dispose",
		"getInt",
		"getInt",
		"getInt",
		"getInt",
		"dispose",
		"addEventListener",
		"addEventListener",
		"addEventListener",
		"addEventListener",
		"addEventListener",
		"addEventListener",
		"addEventListener",
		"addEventListener",
		"addEventListener",
		"addEventListener",
		"addEventListener",
		"addEventListener",
		"addEventListener",
		"addEventListener",
		"addEventListener",
		"addEventListener",
		"addEventListener",
		"setProperty",
		"dispose",
		"getIDsOfNames",
		"setProperty",
		"dispose",
		"checkWidget",
		"error",
		"arraycopy",
		"checkWidget",
		"error",
		"arraycopy",
		"checkWidget",
		"error",
		"arraycopy",
		"checkWidget",
		"error",
		"arraycopy",
		"checkWidget",
		"error",
		"arraycopy",
		"checkWidget",
		"error",
		"arraycopy",
		"checkWidget",
		"error",
		"arraycopy",
		"checkWidget",
		"getIDsOfNames",
		"invoke",
		"getType",
		"getName",
		"getClass",
		"lastIndexOf",
		"equals",
		"substring",
		"error",
		"checkWidget",
		"error",
		"getIDsOfNames",
		"getProperty",
		"getType",
		"getAutomation",
		"dispose",
		"getIDsOfNames",
		"getProperty",
		"getAutomation",
		"dispose",
		"dispose",
		"getIDsOfNames",
		"invoke",
		"dispose",
		"dispose",
		"dispose",
		"checkWidget",
		"getIDsOfNames",
		"invoke",
		"getType",
		"checkWidget",
		"checkWidget",
		"checkWidget",
		"getIDsOfNames",
		"getProperty",
		"getType",
		"getString",
		"dispose",
		"checkWidget",
		"getIDsOfNames",
		"invoke",
		"checkWidget",
		"error",
		"arraycopy",
		"arraycopy",
		"checkWidget",
		"error",
		"arraycopy",
		"arraycopy",
		"checkWidget",
		"error",
		"arraycopy",
		"arraycopy",
		"checkWidget",
		"error",
		"arraycopy",
		"arraycopy",
		"checkWidget",
		"error",
		"arraycopy",
		"arraycopy",
		"checkWidget",
		"error",
		"arraycopy",
		"arraycopy",
		"checkWidget",
		"error",
		"arraycopy",
		"arraycopy",
		"checkWidget",
		"error",
		"getIDsOfNames",
		"getProperty",
		"getInt",
		"dispose",
		"getIDsOfNames",
		"invoke",
		"getIDsOfNames",
		"invoke",
		"dispose",
		"getType",
		"dispose",
		"checkWidget",
		"error",
		"endsWith",
		"getIDsOfNames",
		"invoke",
		"dispose",
		"getIDsOfNames",
		"invoke",
		"getIDsOfNames",
		"invoke",
		"dispose",
		"getType",
		"dispose",
		"checkWidget",
		"getIDsOfNames",
		"invoke",
		"OleFrame",
		"WebSite",
		"OleAutomation",
		"Listener",
		"OleListener",
		"LocationEvent",
		"Runnable",
		"IPersistStreamInit",
		"IUnknown",
		"Variant",
		"LocationEvent",
		"ProgressEvent",
		"WindowEvent",
		"Variant",
		"WindowEvent",
		"ProgressEvent",
		"StatusTextEvent",
		"TitleEvent",
		"WindowEvent",
		"Point",
		"Point",
		"Point",
		"Point",
		"Variant",
		"Variant",
		"Variant",
		"Variant",
		"Variant",
		"Variant"
	],
	"methodsBody":{
		"public void addTitleListener(TitleListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    TitleListener[] newTitleListeners = new TitleListener[titleListeners.length + 1];\n    System.arraycopy(titleListeners, 0, newTitleListeners, 0, titleListeners.length);\n    titleListeners = newTitleListeners;\n    titleListeners[titleListeners.length - 1] = listener;\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will be\n* notified when the title of the current document is available\n* or has changed.\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*    <li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public void addTitleListener(TitleListener listener)"
		},
		"public void stop()":{
			"methodBody":"{\n    checkWidget();\n    \n    int[] rgdispid = auto.getIDsOfNames(new String[] { \"Stop\" });\n    auto.invoke(rgdispid[0]);\n}",
			"comments":"/**\n* Stop any loading and rendering activity.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*    <li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n* </ul>\n*\n* @since 3.0\n*/\n//$NON-NLS-1$\n",
			"methodName":"public void stop()"
		},
		"public void removeOpenWindowListener(OpenWindowListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (openWindowListeners.length == 0)\n        return;\n    int index = -1;\n    for (int i = 0; i < openWindowListeners.length; i++) {\n        if (listener == openWindowListeners[i]) {\n            index = i;\n            break;\n        }\n    }\n    if (index == -1)\n        return;\n    if (openWindowListeners.length == 1) {\n        openWindowListeners = new OpenWindowListener[0];\n        return;\n    }\n    OpenWindowListener[] newOpenWindowListeners = new OpenWindowListener[openWindowListeners.length - 1];\n    System.arraycopy(openWindowListeners, 0, newOpenWindowListeners, 0, index);\n    System.arraycopy(openWindowListeners, index + 1, newOpenWindowListeners, index, openWindowListeners.length - index - 1);\n    openWindowListeners = newOpenWindowListeners;\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when a new window needs to be created.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*    <li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public void removeOpenWindowListener(OpenWindowListener listener)"
		},
		"public void addProgressListener(ProgressListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    ProgressListener[] newProgressListeners = new ProgressListener[progressListeners.length + 1];\n    System.arraycopy(progressListeners, 0, newProgressListeners, 0, progressListeners.length);\n    progressListeners = newProgressListeners;\n    progressListeners[progressListeners.length - 1] = listener;\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will be\n* notified when a progress is made during the loading of the current\n* URL or when the loading of the current URL has been completed.\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*    <li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public void addProgressListener(ProgressListener listener)"
		},
		"public void refresh()":{
			"methodBody":"{\n    checkWidget();\n    \n    int[] rgdispid = auto.getIDsOfNames(new String[] { \"Refresh\" });\n    auto.invoke(rgdispid[0]);\n}",
			"comments":"/**\n* Refresh the current page.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*    <li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n* </ul>\n*\n* @since 3.0\n*/\n//$NON-NLS-1$\n",
			"methodName":"public void refresh()"
		},
		"public void addOpenWindowListener(OpenWindowListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    OpenWindowListener[] newOpenWindowListeners = new OpenWindowListener[openWindowListeners.length + 1];\n    System.arraycopy(openWindowListeners, 0, newOpenWindowListeners, 0, openWindowListeners.length);\n    openWindowListeners = newOpenWindowListeners;\n    openWindowListeners[openWindowListeners.length - 1] = listener;\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will be\n* notified when a new window needs to be created.\n* <p>\n* This notification occurs when a javascript command such as\n* <code>window.open</code> gets executed by a <code>Browser</code>.\n* </p>\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*    <li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public void addOpenWindowListener(OpenWindowListener listener)"
		},
		"protected void checkSubclass()":{
			"methodBody":"{\n    String name = getClass().getName();\n    int index = name.lastIndexOf('.');\n    if (!name.substring(0, index + 1).equals(PACKAGE_PREFIX)) {\n        SWT.error(SWT.ERROR_INVALID_SUBCLASS);\n    }\n}",
			"comments":"",
			"methodName":"protected void checkSubclass()"
		},
		"public boolean setText(String html)":{
			"methodBody":"{\n    checkWidget();\n    if (html == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    \n    boolean blankLoading = this.html != null;\n    this.html = html;\n    if (blankLoading)\n        return true;\n    \n    int[] rgdispid;\n    if (navigate) {\n        \n        \n        rgdispid = auto.getIDsOfNames(new String[] { \"ReadyState\" });\n        Variant pVarResult = auto.getProperty(rgdispid[0]);\n        if (pVarResult == null)\n            return false;\n        delaySetText = pVarResult.getInt() != READYSTATE_COMPLETE;\n        pVarResult.dispose();\n        \n        rgdispid = auto.getIDsOfNames(new String[] { \"Stop\" });\n        auto.invoke(rgdispid[0]);\n    }\n    \n    rgdispid = auto.getIDsOfNames(new String[] { \"Navigate\", \"URL\" });\n    navigate = true;\n    Variant[] rgvarg = new Variant[1];\n    rgvarg[0] = new Variant(ABOUT_BLANK);\n    int[] rgdispidNamedArgs = new int[1];\n    rgdispidNamedArgs[0] = rgdispid[1];\n    Variant pVarResult = auto.invoke(rgdispid[0], rgvarg, rgdispidNamedArgs);\n    rgvarg[0].dispose();\n    if (pVarResult == null)\n        return false;\n    boolean result = pVarResult.getType() == OLE.VT_EMPTY;\n    pVarResult.dispose();\n    return result;\n}",
			"comments":"/**\n* Renders HTML.\n*\n* <p>\n* The html parameter is Unicode encoded since it is a java <code>String</code>.\n* As a result, the HTML meta tag charset should not be set. The charset is implied\n* by the <code>String</code> itself.\n*\n* @param html the HTML content to be rendered\n*\n* @return true if the operation was successful and false otherwise.\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the html is null</li>\n* </ul>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*    <li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n* </ul>\n*\n* @see #setUrl\n*\n* @since 3.0\n*/\n/*\n* If the html field is non-null then the about:blank page is already being\n* loaded, so no Stop or Navigate is required.  Just set the html that is to\n* be shown.\n*/\n/*\n* Navigate to the blank page and insert the given html when\n* receiving the next DocumentComplete notification.  See the\n* MSDN article \"Loading HTML content from a Stream\".\n*\n* Note.  Stop any pending request.  This is required to avoid displaying a\n* blank page as a result of consecutive calls to setUrl and/or setText.\n* The previous request would otherwise render the new html content and\n* reset the html field before the browser actually navigates to the blank\n* page as requested below.\n*\n* Feature in Internet Explorer.  Stopping pending requests when no request\n* is pending causes a default page 'Action cancelled' to be displayed.  The\n* workaround is to not invoke 'stop' when no request has been set since\n* that instance was created.\n*/\n/*\n* Stopping the loading of a page causes DocumentComplete events from previous\n* requests to be received before the DocumentComplete for this page.  In such\n* cases we must be sure to not set the html into the browser too soon, since\n* doing so could result in its page being cleared out by a subsequent\n* DocumentComplete.  The Browser's ReadyState can be used to determine whether\n* these extra events will be received or not.\n*/\n//$NON-NLS-1$\n//$NON-NLS-1$\n//$NON-NLS-1$ //$NON-NLS-2$\n",
			"methodName":"public boolean setText(String html)"
		},
		"public void handleEvent(OleEvent event)":{
			"methodBody":"{\n    switch(event.type) {\n        case BeforeNavigate2:\n            {\n                Variant varResult = event.arguments[1];\n                String url = varResult.getString();\n                LocationEvent newEvent = new LocationEvent(Browser.this);\n                newEvent.display = getDisplay();\n                newEvent.widget = Browser.this;\n                newEvent.location = url;\n                newEvent.doit = true;\n                for (int i = 0; i < locationListeners.length; i++) locationListeners[i].changing(newEvent);\n                Variant cancel = event.arguments[6];\n                if (cancel != null) {\n                    int pCancel = cancel.getByRef();\n                    COM.MoveMemory(pCancel, new short[] { newEvent.doit ? COM.VARIANT_FALSE : COM.VARIANT_TRUE }, 2);\n                }\n                break;\n            }\n        case CommandStateChange:\n            {\n                boolean enabled = false;\n                Variant varResult = event.arguments[0];\n                int command = varResult.getInt();\n                varResult = event.arguments[1];\n                enabled = varResult.getBoolean();\n                switch(command) {\n                    case CSC_NAVIGATEBACK:\n                        back = enabled;\n                        break;\n                    case CSC_NAVIGATEFORWARD:\n                        forward = enabled;\n                        break;\n                }\n                break;\n            }\n        case DocumentComplete:\n            {\n                Variant varResult = event.arguments[0];\n                IDispatch dispatch = varResult.getDispatch();\n                varResult = event.arguments[1];\n                String url = varResult.getString();\n                if (html != null && url.equals(ABOUT_BLANK)) {\n                    Runnable runnable = new Runnable() {\n\n                        public void run() {\n                            if (isDisposed() || html == null)\n                                return;\n                            int charCount = html.length();\n                            char[] chars = new char[charCount];\n                            html.getChars(0, charCount, chars, 0);\n                            html = null;\n                            int byteCount = OS.WideCharToMultiByte(OS.CP_UTF8, 0, chars, charCount, null, 0, null, null);\n                            \n                            byte[] UTF8BOM = { (byte) 0xEF, (byte) 0xBB, (byte) 0xBF };\n                            int hGlobal = OS.GlobalAlloc(OS.GMEM_FIXED, UTF8BOM.length + byteCount);\n                            if (hGlobal != 0) {\n                                OS.MoveMemory(hGlobal, UTF8BOM, UTF8BOM.length);\n                                OS.WideCharToMultiByte(OS.CP_UTF8, 0, chars, charCount, hGlobal + UTF8BOM.length, byteCount, null, null);\n                                int[] ppstm = new int[1];\n                                \n                                if (OS.CreateStreamOnHGlobal(hGlobal, true, ppstm) == OS.S_OK) {\n                                    \n                                    int[] rgdispid = auto.getIDsOfNames(new String[] { \"Document\" });\n                                    Variant pVarResult = auto.getProperty(rgdispid[0]);\n                                    IDispatch dispatchDocument = pVarResult.getDispatch();\n                                    int[] ppvObject = new int[1];\n                                    int result = dispatchDocument.QueryInterface(COM.IIDIPersistStreamInit, ppvObject);\n                                    if (result == OS.S_OK) {\n                                        IPersistStreamInit persistStreamInit = new IPersistStreamInit(ppvObject[0]);\n                                        if (persistStreamInit.InitNew() == OS.S_OK) {\n                                            persistStreamInit.Load(ppstm[0]);\n                                        }\n                                        persistStreamInit.Release();\n                                    }\n                                    pVarResult.dispose();\n                                    \n                                    \n                                    IUnknown stream = new IUnknown(ppstm[0]);\n                                    stream.Release();\n                                } else {\n                                    OS.GlobalFree(hGlobal);\n                                }\n                            }\n                        }\n                    };\n                    if (delaySetText) {\n                        delaySetText = false;\n                        getDisplay().asyncExec(runnable);\n                    } else {\n                        runnable.run();\n                    }\n                } else {\n                    Variant variant = new Variant(auto);\n                    IDispatch top = variant.getDispatch();\n                    LocationEvent locationEvent = new LocationEvent(Browser.this);\n                    locationEvent.display = getDisplay();\n                    locationEvent.widget = Browser.this;\n                    locationEvent.location = url;\n                    locationEvent.top = top.getAddress() == dispatch.getAddress();\n                    for (int i = 0; i < locationListeners.length; i++) locationListeners[i].changed(locationEvent);\n                    \n                    if (globalDispatch != 0 && dispatch.getAddress() == globalDispatch) {\n                        \n                        globalDispatch = 0;\n                        ProgressEvent progressEvent = new ProgressEvent(Browser.this);\n                        progressEvent.display = getDisplay();\n                        progressEvent.widget = Browser.this;\n                        for (int i = 0; i < progressListeners.length; i++) progressListeners[i].completed(progressEvent);\n                    }\n                }\n                \n                break;\n            }\n        case NavigateComplete2:\n            {\n                Variant varResult = event.arguments[0];\n                IDispatch dispatch = varResult.getDispatch();\n                if (globalDispatch == 0)\n                    globalDispatch = dispatch.getAddress();\n                break;\n            }\n        case NewWindow2:\n            {\n                Variant cancel = event.arguments[1];\n                int pCancel = cancel.getByRef();\n                WindowEvent newEvent = new WindowEvent(Browser.this);\n                newEvent.display = getDisplay();\n                newEvent.widget = Browser.this;\n                newEvent.required = false;\n                for (int i = 0; i < openWindowListeners.length; i++) openWindowListeners[i].open(newEvent);\n                Browser browser = newEvent.browser;\n                boolean doit = browser != null && !browser.isDisposed();\n                if (doit) {\n                    Variant variant = new Variant(browser.auto);\n                    IDispatch iDispatch = variant.getDispatch();\n                    Variant ppDisp = event.arguments[0];\n                    int byref = ppDisp.getByRef();\n                    if (byref != 0)\n                        COM.MoveMemory(byref, new int[] { iDispatch.getAddress() }, 4);\n                \n                \n                \n                }\n                if (newEvent.required) {\n                    COM.MoveMemory(pCancel, new short[] { doit ? COM.VARIANT_FALSE : COM.VARIANT_TRUE }, 2);\n                }\n                break;\n            }\n        case OnMenuBar:\n            {\n                Variant arg0 = event.arguments[0];\n                menuBar = arg0.getBoolean();\n                break;\n            }\n        case OnStatusBar:\n            {\n                Variant arg0 = event.arguments[0];\n                statusBar = arg0.getBoolean();\n                break;\n            }\n        case OnToolBar:\n            {\n                Variant arg0 = event.arguments[0];\n                toolBar = arg0.getBoolean();\n                \n                if (!toolBar) {\n                    addressBar = false;\n                    menuBar = false;\n                }\n                break;\n            }\n        case OnVisible:\n            {\n                Variant arg1 = event.arguments[0];\n                boolean visible = arg1.getBoolean();\n                WindowEvent newEvent = new WindowEvent(Browser.this);\n                newEvent.display = getDisplay();\n                newEvent.widget = Browser.this;\n                if (visible) {\n                    if (addressBar) {\n                        \n                        \n                        int[] rgdispid = auto.getIDsOfNames(new String[] { \"AddressBar\" });\n                        Variant pVarResult = auto.getProperty(rgdispid[0]);\n                        if (pVarResult != null && pVarResult.getType() == OLE.VT_BOOL)\n                            addressBar = pVarResult.getBoolean();\n                    }\n                    newEvent.addressBar = addressBar;\n                    newEvent.menuBar = menuBar;\n                    newEvent.statusBar = statusBar;\n                    newEvent.toolBar = toolBar;\n                    newEvent.location = location;\n                    newEvent.size = size;\n                    for (int i = 0; i < visibilityWindowListeners.length; i++) {\n                        visibilityWindowListeners[i].show(newEvent);\n                    }\n                    location = null;\n                    size = null;\n                } else {\n                    for (int i = 0; i < visibilityWindowListeners.length; i++) visibilityWindowListeners[i].hide(newEvent);\n                }\n                break;\n            }\n        case ProgressChange:\n            {\n                Variant arg1 = event.arguments[0];\n                \n                int nProgress = arg1.getType() != OLE.VT_I4 ? 0 : arg1.getInt();\n                Variant arg2 = event.arguments[1];\n                int nProgressMax = arg2.getType() != OLE.VT_I4 ? 0 : arg2.getInt();\n                ProgressEvent newEvent = new ProgressEvent(Browser.this);\n                newEvent.display = getDisplay();\n                newEvent.widget = Browser.this;\n                newEvent.current = nProgress;\n                newEvent.total = nProgressMax;\n                if (nProgress != -1) {\n                    for (int i = 0; i < progressListeners.length; i++) progressListeners[i].changed(newEvent);\n                }\n                break;\n            }\n        case StatusTextChange:\n            {\n                Variant arg1 = event.arguments[0];\n                if (arg1.getType() == OLE.VT_BSTR) {\n                    String text = arg1.getString();\n                    StatusTextEvent newEvent = new StatusTextEvent(Browser.this);\n                    newEvent.display = getDisplay();\n                    newEvent.widget = Browser.this;\n                    newEvent.text = text;\n                    for (int i = 0; i < statusTextListeners.length; i++) statusTextListeners[i].changed(newEvent);\n                }\n                break;\n            }\n        case TitleChange:\n            {\n                Variant arg1 = event.arguments[0];\n                if (arg1.getType() == OLE.VT_BSTR) {\n                    String title = arg1.getString();\n                    TitleEvent newEvent = new TitleEvent(Browser.this);\n                    newEvent.display = getDisplay();\n                    newEvent.widget = Browser.this;\n                    newEvent.title = title;\n                    for (int i = 0; i < titleListeners.length; i++) titleListeners[i].changed(newEvent);\n                }\n                break;\n            }\n        case WindowClosing:\n            {\n                WindowEvent newEvent = new WindowEvent(Browser.this);\n                newEvent.display = getDisplay();\n                newEvent.widget = Browser.this;\n                for (int i = 0; i < closeWindowListeners.length; i++) closeWindowListeners[i].close(newEvent);\n                Variant cancel = event.arguments[1];\n                int pCancel = cancel.getByRef();\n                COM.MoveMemory(pCancel, new short[] { COM.VARIANT_FALSE }, 2);\n                dispose();\n                break;\n            }\n        case WindowSetHeight:\n            {\n                if (size == null)\n                    size = new Point(0, 0);\n                Variant arg1 = event.arguments[0];\n                size.y = arg1.getInt();\n                break;\n            }\n        case WindowSetLeft:\n            {\n                if (location == null)\n                    location = new Point(0, 0);\n                Variant arg1 = event.arguments[0];\n                location.x = arg1.getInt();\n                break;\n            }\n        case WindowSetTop:\n            {\n                if (location == null)\n                    location = new Point(0, 0);\n                Variant arg1 = event.arguments[0];\n                location.y = arg1.getInt();\n                break;\n            }\n        case WindowSetWidth:\n            {\n                if (size == null)\n                    size = new Point(0, 0);\n                Variant arg1 = event.arguments[0];\n                size.x = arg1.getInt();\n                break;\n            }\n    }\n    \n    Variant[] arguments = event.arguments;\n    for (int i = 0; i < arguments.length; i++) arguments[i].dispose();\n}",
			"comments":"/*\n* Note. Internet Explorer appears to treat the data loaded with\n* nsIPersistStreamInit.Load as if it were encoded using the default\n* local charset.  There does not seem to be an API to set the\n* desired charset explicitely in this case.  The fix is to\n* prepend the UTF-8 Byte Order Mark signature to the data.\n*/\n/*\n* Note.  CreateStreamOnHGlobal is called with the flag fDeleteOnRelease.\n* If the call succeeds the buffer hGlobal is freed automatically\n* when the IStream object is released. If the call fails, free the buffer\n* hGlobal.\n*/\n//$NON-NLS-1$\n/*\n* This code is intentionally commented.  The IDispatch obtained from a Variant\n* did not increase the reference count for the enclosed interface.\n*/\n//dispatchDocument.Release();\n/*\n* This code is intentionally commented.  A Variant constructed from an\n* OleAutomation object does not increase its reference count.  The IDispatch\n* obtained from this Variant did not increase the reference count for the\n* OleAutomation instance either.\n*/\n//top.Release();\n//variant.dispose();\n/*\n* Note.  The completion of the page loading is detected as\n* described in the MSDN article \"Determine when a page is\n* done loading in WebBrowser Control\".\n*/\n/* final document complete */\n/*\n* This code is intentionally commented.  This IDispatch was received\n* as an argument from the OleEvent and it will be disposed along with\n* the other arguments.\n*/\n//dispatch.Release();\n/*\n* This code is intentionally commented.  A Variant constructed from an\n* OleAutomation object does not increase its reference count.  The IDispatch\n* obtained from this Variant did not increase the reference count for the\n* OleAutomation instance either.\n*/\n//variant.dispose();\n//iDispatch.Release();\n/*\n* Feature in Internet Explorer.  OnToolBar FALSE is emitted\n* when both tool bar, address bar and menu bar must not be visible.\n* OnToolBar TRUE is emitted when either of tool bar, address bar\n* or menu bar is visible.\n*/\n/*\n* Bug in Internet Explorer.  There is no distinct notification for\n* the address bar.  If neither address, menu or tool bars are visible,\n* OnToolBar FALSE is emitted. For some reason, querying the value of\n* AddressBar in this case returns true even though it should not be\n* set visible.  The workaround is to only query the value of AddressBar\n* when OnToolBar FALSE has not been emitted.\n*/\n//$NON-NLS-1$\n// may be -1\n/*\n* Dispose all arguments passed in the OleEvent.  This must be\n* done to properly release any IDispatch reference that was\n* automatically addRef'ed when constructing the OleEvent.\n*/\n",
			"methodName":"public void handleEvent(OleEvent event)"
		},
		"public void addCloseWindowListener(CloseWindowListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    CloseWindowListener[] newCloseWindowListeners = new CloseWindowListener[closeWindowListeners.length + 1];\n    System.arraycopy(closeWindowListeners, 0, newCloseWindowListeners, 0, closeWindowListeners.length);\n    closeWindowListeners = newCloseWindowListeners;\n    closeWindowListeners[closeWindowListeners.length - 1] = listener;\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will be\n* notified when the window hosting the receiver should be closed.\n* <p>\n* This notification occurs when a javascript command such as\n* <code>window.close</code> gets executed by a <code>Browser</code>.\n* </p>\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*    <li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public void addCloseWindowListener(CloseWindowListener listener)"
		},
		"public void removeStatusTextListener(StatusTextListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (statusTextListeners.length == 0)\n        return;\n    int index = -1;\n    for (int i = 0; i < statusTextListeners.length; i++) {\n        if (listener == statusTextListeners[i]) {\n            index = i;\n            break;\n        }\n    }\n    if (index == -1)\n        return;\n    if (statusTextListeners.length == 1) {\n        statusTextListeners = new StatusTextListener[0];\n        return;\n    }\n    StatusTextListener[] newStatusTextListeners = new StatusTextListener[statusTextListeners.length - 1];\n    System.arraycopy(statusTextListeners, 0, newStatusTextListeners, 0, index);\n    System.arraycopy(statusTextListeners, index + 1, newStatusTextListeners, index, statusTextListeners.length - index - 1);\n    statusTextListeners = newStatusTextListeners;\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when the status text is changed.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*    <li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public void removeStatusTextListener(StatusTextListener listener)"
		},
		"public void removeProgressListener(ProgressListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (progressListeners.length == 0)\n        return;\n    int index = -1;\n    for (int i = 0; i < progressListeners.length; i++) {\n        if (listener == progressListeners[i]) {\n            index = i;\n            break;\n        }\n    }\n    if (index == -1)\n        return;\n    if (progressListeners.length == 1) {\n        progressListeners = new ProgressListener[0];\n        return;\n    }\n    ProgressListener[] newProgressListeners = new ProgressListener[progressListeners.length - 1];\n    System.arraycopy(progressListeners, 0, newProgressListeners, 0, index);\n    System.arraycopy(progressListeners, index + 1, newProgressListeners, index, progressListeners.length - index - 1);\n    progressListeners = newProgressListeners;\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when a progress is made during the loading of the current\n* URL or when the loading of the current URL has been completed.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*    <li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public void removeProgressListener(ProgressListener listener)"
		},
		"public boolean setUrl(String url)":{
			"methodBody":"{\n    checkWidget();\n    if (url == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    html = null;\n    \n    if (url.endsWith(\".xml\")) {\n        \n        if (!navigate) {\n            \n            int[] rgdispid = auto.getIDsOfNames(new String[] { \"Navigate\", \"URL\" });\n            Variant[] rgvarg = new Variant[1];\n            rgvarg[0] = new Variant(ABOUT_BLANK);\n            int[] rgdispidNamedArgs = new int[1];\n            rgdispidNamedArgs[0] = rgdispid[1];\n            auto.invoke(rgdispid[0], rgvarg, rgdispidNamedArgs);\n            rgvarg[0].dispose();\n        }\n        \n        int[] rgdispid = auto.getIDsOfNames(new String[] { \"Stop\" });\n        auto.invoke(rgdispid[0]);\n    }\n    \n    int[] rgdispid = auto.getIDsOfNames(new String[] { \"Navigate\", \"URL\" });\n    navigate = true;\n    Variant[] rgvarg = new Variant[1];\n    rgvarg[0] = new Variant(url);\n    int[] rgdispidNamedArgs = new int[1];\n    rgdispidNamedArgs[0] = rgdispid[1];\n    Variant pVarResult = auto.invoke(rgdispid[0], rgvarg, rgdispidNamedArgs);\n    rgvarg[0].dispose();\n    if (pVarResult == null)\n        return false;\n    boolean result = pVarResult.getType() == OLE.VT_EMPTY;\n    pVarResult.dispose();\n    return result;\n}",
			"comments":"/**\n* Loads a URL.\n*\n* @param url the URL to be loaded\n*\n* @return true if the operation was successful and false otherwise.\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the url is null</li>\n* </ul>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*    <li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n* </ul>\n*\n* @see #getUrl\n*\n* @since 3.0\n*/\n/*\n* Bug in Internet Explorer.  For some reason, Navigating to an xml document before\n* a previous Navigate has completed will leave the Browser in a bad state if the\n* Navigate to the xml document does not complete.  This bad state causes a GP when\n* the parent window is eventually disposed.  The workaround is to issue a Stop before\n* navigating to any xml document.\n*/\n//$NON-NLS-1$\n/*\n* Feature in Internet Explorer.  Stopping pending requests when no request has been\n* issued causes a default 'Action cancelled' page to be displayed.  Since Stop must\n* be issued here, the workaround is to first Navigate to the about:blank page before\n* issuing Stop so that the 'Action cancelled' page is not displayed.\n*/\n//$NON-NLS-1$ //$NON-NLS-2$\n//$NON-NLS-1$\n//$NON-NLS-1$ //$NON-NLS-2$\n",
			"methodName":"public boolean setUrl(String url)"
		},
		"public boolean forward()":{
			"methodBody":"{\n    checkWidget();\n    if (!forward)\n        return false;\n    \n    int[] rgdispid = auto.getIDsOfNames(new String[] { \"GoForward\" });\n    Variant pVarResult = auto.invoke(rgdispid[0]);\n    return pVarResult != null && pVarResult.getType() == OLE.VT_EMPTY;\n}",
			"comments":"/**\n* Navigate to the next session history item.\n*\n* @return <code>true</code> if the operation was successful and <code>false</code> otherwise\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*    <li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n* </ul>\n*\n* @see #back\n*\n* @since 3.0\n*/\n//$NON-NLS-1$\n",
			"methodName":"public boolean forward()"
		},
		"public boolean isBackEnabled()":{
			"methodBody":"{\n    checkWidget();\n    return back;\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver can navigate to the\n* previous session history item, and <code>false</code> otherwise.\n*\n* @return the receiver's back command enabled state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #back\n*/\n",
			"methodName":"public boolean isBackEnabled()"
		},
		"public void removeTitleListener(TitleListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (titleListeners.length == 0)\n        return;\n    int index = -1;\n    for (int i = 0; i < titleListeners.length; i++) {\n        if (listener == titleListeners[i]) {\n            index = i;\n            break;\n        }\n    }\n    if (index == -1)\n        return;\n    if (titleListeners.length == 1) {\n        titleListeners = new TitleListener[0];\n        return;\n    }\n    TitleListener[] newTitleListeners = new TitleListener[titleListeners.length - 1];\n    System.arraycopy(titleListeners, 0, newTitleListeners, 0, index);\n    System.arraycopy(titleListeners, index + 1, newTitleListeners, index, titleListeners.length - index - 1);\n    titleListeners = newTitleListeners;\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when the title of the current document is available\n* or has changed.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*    <li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public void removeTitleListener(TitleListener listener)"
		},
		"public void handleEvent(Event e)":{
			"methodBody":"{\n    switch(e.type) {\n        case SWT.Dispose:\n            {\n                if (auto != null)\n                    auto.dispose();\n                auto = null;\n                break;\n            }\n        case SWT.Resize:\n            {\n                frame.setBounds(getClientArea());\n                break;\n            }\n        case SWT.KeyDown:\n        case SWT.KeyUp:\n            {\n                notifyListeners(e.type, e);\n                break;\n            }\n    }\n}",
			"comments":"",
			"methodName":"public void handleEvent(Event e)"
		},
		"public boolean back()":{
			"methodBody":"{\n    checkWidget();\n    if (!back)\n        return false;\n    \n    int[] rgdispid = auto.getIDsOfNames(new String[] { \"GoBack\" });\n    Variant pVarResult = auto.invoke(rgdispid[0]);\n    return pVarResult != null && pVarResult.getType() == OLE.VT_EMPTY;\n}",
			"comments":"/**\n* Navigate to the previous session history item.\n*\n* @return <code>true</code> if the operation was successful and <code>false</code> otherwise\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*    <li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n* </ul>\n*\n* @see #forward\n*\n* @since 3.0\n*/\n//$NON-NLS-1$\n",
			"methodName":"public boolean back()"
		},
		"public void removeVisibilityWindowListener(VisibilityWindowListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (visibilityWindowListeners.length == 0)\n        return;\n    int index = -1;\n    for (int i = 0; i < visibilityWindowListeners.length; i++) {\n        if (listener == visibilityWindowListeners[i]) {\n            index = i;\n            break;\n        }\n    }\n    if (index == -1)\n        return;\n    if (visibilityWindowListeners.length == 1) {\n        visibilityWindowListeners = new VisibilityWindowListener[0];\n        return;\n    }\n    VisibilityWindowListener[] newVisibilityWindowListeners = new VisibilityWindowListener[visibilityWindowListeners.length - 1];\n    System.arraycopy(visibilityWindowListeners, 0, newVisibilityWindowListeners, 0, index);\n    System.arraycopy(visibilityWindowListeners, index + 1, newVisibilityWindowListeners, index, visibilityWindowListeners.length - index - 1);\n    visibilityWindowListeners = newVisibilityWindowListeners;\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when a window hosting the receiver needs to be displayed\n* or hidden.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*    <li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public void removeVisibilityWindowListener(VisibilityWindowListener listener)"
		},
		"public boolean execute(String script)":{
			"methodBody":"{\n    checkWidget();\n    if (script == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    \n    \n    int[] rgdispid = auto.getIDsOfNames(new String[] { \"Document\" });\n    int dispIdMember = rgdispid[0];\n    Variant pVarResult = auto.getProperty(dispIdMember);\n    if (pVarResult == null || pVarResult.getType() == COM.VT_EMPTY)\n        return false;\n    OleAutomation document = pVarResult.getAutomation();\n    pVarResult.dispose();\n    \n    \n    rgdispid = document.getIDsOfNames(new String[] { \"parentWindow\" });\n    dispIdMember = rgdispid[0];\n    pVarResult = document.getProperty(dispIdMember);\n    OleAutomation ihtmlWindow2 = pVarResult.getAutomation();\n    pVarResult.dispose();\n    document.dispose();\n    \n    rgdispid = ihtmlWindow2.getIDsOfNames(new String[] { \"execScript\", \"code\" });\n    Variant[] rgvarg = new Variant[1];\n    rgvarg[0] = new Variant(script);\n    int[] rgdispidNamedArgs = new int[1];\n    rgdispidNamedArgs[0] = rgdispid[1];\n    pVarResult = ihtmlWindow2.invoke(rgdispid[0], rgvarg, rgdispidNamedArgs);\n    rgvarg[0].dispose();\n    ihtmlWindow2.dispose();\n    if (pVarResult == null)\n        return false;\n    pVarResult.dispose();\n    return true;\n}",
			"comments":"/**\n* Execute the specified script.\n*\n* <p>\n* Execute a script containing javascript commands in the context of the current document.\n*\n* @param script the script with javascript commands\n*\n* @return <code>true</code> if the operation was successful and <code>false</code> otherwise\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the script is null</li>\n* </ul>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*    <li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n* </ul>\n*\n* @since 3.1\n*/\n/* get IHTMLDocument2 */\n//$NON-NLS-1$\n/* get IHTMLWindow2 */\n//$NON-NLS-1$\n//$NON-NLS-1$  //$NON-NLS-2$\n",
			"methodName":"public boolean execute(String script)"
		},
		"public void run()":{
			"methodBody":"{\n    if (isDisposed() || html == null)\n        return;\n    int charCount = html.length();\n    char[] chars = new char[charCount];\n    html.getChars(0, charCount, chars, 0);\n    html = null;\n    int byteCount = OS.WideCharToMultiByte(OS.CP_UTF8, 0, chars, charCount, null, 0, null, null);\n    \n    byte[] UTF8BOM = { (byte) 0xEF, (byte) 0xBB, (byte) 0xBF };\n    int hGlobal = OS.GlobalAlloc(OS.GMEM_FIXED, UTF8BOM.length + byteCount);\n    if (hGlobal != 0) {\n        OS.MoveMemory(hGlobal, UTF8BOM, UTF8BOM.length);\n        OS.WideCharToMultiByte(OS.CP_UTF8, 0, chars, charCount, hGlobal + UTF8BOM.length, byteCount, null, null);\n        int[] ppstm = new int[1];\n        \n        if (OS.CreateStreamOnHGlobal(hGlobal, true, ppstm) == OS.S_OK) {\n            \n            int[] rgdispid = auto.getIDsOfNames(new String[] { \"Document\" });\n            Variant pVarResult = auto.getProperty(rgdispid[0]);\n            IDispatch dispatchDocument = pVarResult.getDispatch();\n            int[] ppvObject = new int[1];\n            int result = dispatchDocument.QueryInterface(COM.IIDIPersistStreamInit, ppvObject);\n            if (result == OS.S_OK) {\n                IPersistStreamInit persistStreamInit = new IPersistStreamInit(ppvObject[0]);\n                if (persistStreamInit.InitNew() == OS.S_OK) {\n                    persistStreamInit.Load(ppstm[0]);\n                }\n                persistStreamInit.Release();\n            }\n            pVarResult.dispose();\n            \n            \n            IUnknown stream = new IUnknown(ppstm[0]);\n            stream.Release();\n        } else {\n            OS.GlobalFree(hGlobal);\n        }\n    }\n}",
			"comments":"/*\n* Note. Internet Explorer appears to treat the data loaded with\n* nsIPersistStreamInit.Load as if it were encoded using the default\n* local charset.  There does not seem to be an API to set the\n* desired charset explicitely in this case.  The fix is to\n* prepend the UTF-8 Byte Order Mark signature to the data.\n*/\n/*\n* Note.  CreateStreamOnHGlobal is called with the flag fDeleteOnRelease.\n* If the call succeeds the buffer hGlobal is freed automatically\n* when the IStream object is released. If the call fails, free the buffer\n* hGlobal.\n*/\n//$NON-NLS-1$\n/*\n* This code is intentionally commented.  The IDispatch obtained from a Variant\n* did not increase the reference count for the enclosed interface.\n*/\n//dispatchDocument.Release();\n",
			"methodName":"public void run()"
		},
		"public void addVisibilityWindowListener(VisibilityWindowListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    VisibilityWindowListener[] newVisibilityWindowListeners = new VisibilityWindowListener[visibilityWindowListeners.length + 1];\n    System.arraycopy(visibilityWindowListeners, 0, newVisibilityWindowListeners, 0, visibilityWindowListeners.length);\n    visibilityWindowListeners = newVisibilityWindowListeners;\n    visibilityWindowListeners[visibilityWindowListeners.length - 1] = listener;\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will be\n* notified when a window hosting the receiver needs to be displayed\n* or hidden.\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*    <li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public void addVisibilityWindowListener(VisibilityWindowListener listener)"
		},
		"public void addLocationListener(LocationListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    LocationListener[] newLocationListeners = new LocationListener[locationListeners.length + 1];\n    System.arraycopy(locationListeners, 0, newLocationListeners, 0, locationListeners.length);\n    locationListeners = newLocationListeners;\n    locationListeners[locationListeners.length - 1] = listener;\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will be\n* notified when the current location has changed or is about to change.\n* <p>\n* This notification typically occurs when the application navigates\n* to a new location with {@link #setUrl(String)} or when the user\n* activates a hyperlink.\n* </p>\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*    <li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public void addLocationListener(LocationListener listener)"
		},
		"public String getUrl()":{
			"methodBody":"{\n    checkWidget();\n    \n    int[] rgdispid = auto.getIDsOfNames(new String[] { \"LocationURL\" });\n    Variant pVarResult = auto.getProperty(rgdispid[0]);\n    if (pVarResult == null || pVarResult.getType() != OLE.VT_BSTR)\n        return \"\";\n    String result = pVarResult.getString();\n    pVarResult.dispose();\n    return result;\n}",
			"comments":"/**\n* Returns the current URL.\n*\n* @return the current URL or an empty <code>String</code> if there is no current URL\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*    <li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n* </ul>\n*\n* @see #setUrl\n*\n* @since 3.0\n*/\n//$NON-NLS-1$\n",
			"methodName":"public String getUrl()"
		},
		"public boolean isForwardEnabled()":{
			"methodBody":"{\n    checkWidget();\n    return forward;\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver can navigate to the\n* next session history item, and <code>false</code> otherwise.\n*\n* @return the receiver's forward command enabled state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #forward\n*/\n",
			"methodName":"public boolean isForwardEnabled()"
		},
		"public void removeCloseWindowListener(CloseWindowListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (closeWindowListeners.length == 0)\n        return;\n    int index = -1;\n    for (int i = 0; i < closeWindowListeners.length; i++) {\n        if (listener == closeWindowListeners[i]) {\n            index = i;\n            break;\n        }\n    }\n    if (index == -1)\n        return;\n    if (closeWindowListeners.length == 1) {\n        closeWindowListeners = new CloseWindowListener[0];\n        return;\n    }\n    CloseWindowListener[] newCloseWindowListeners = new CloseWindowListener[closeWindowListeners.length - 1];\n    System.arraycopy(closeWindowListeners, 0, newCloseWindowListeners, 0, index);\n    System.arraycopy(closeWindowListeners, index + 1, newCloseWindowListeners, index, closeWindowListeners.length - index - 1);\n    closeWindowListeners = newCloseWindowListeners;\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when the window hosting the receiver should be closed.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*    <li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public void removeCloseWindowListener(CloseWindowListener listener)"
		},
		"public void addStatusTextListener(StatusTextListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    StatusTextListener[] newStatusTextListeners = new StatusTextListener[statusTextListeners.length + 1];\n    System.arraycopy(statusTextListeners, 0, newStatusTextListeners, 0, statusTextListeners.length);\n    statusTextListeners = newStatusTextListeners;\n    statusTextListeners[statusTextListeners.length - 1] = listener;\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will be\n* notified when the status text is changed.\n* <p>\n* The status text is typically displayed in the status bar of\n* a browser application.\n* </p>\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*    <li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public void addStatusTextListener(StatusTextListener listener)"
		},
		"public void removeLocationListener(LocationListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (locationListeners.length == 0)\n        return;\n    int index = -1;\n    for (int i = 0; i < locationListeners.length; i++) {\n        if (listener == locationListeners[i]) {\n            index = i;\n            break;\n        }\n    }\n    if (index == -1)\n        return;\n    if (locationListeners.length == 1) {\n        locationListeners = new LocationListener[0];\n        return;\n    }\n    LocationListener[] newLocationListeners = new LocationListener[locationListeners.length - 1];\n    System.arraycopy(locationListeners, 0, newLocationListeners, 0, index);\n    System.arraycopy(locationListeners, index + 1, newLocationListeners, index, locationListeners.length - index - 1);\n    locationListeners = newLocationListeners;\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when the current location is changed or about to be changed.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*    <li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public void removeLocationListener(LocationListener listener)"
		}
	},
	"ClassORInterfaceName":[
		"Browser"
	]
}
