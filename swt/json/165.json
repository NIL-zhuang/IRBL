{
	"variables":[
		"type",
		"handle",
		"transparentPixel",
		"memGC",
		"alphaData",
		"alpha",
		"data",
		"DEFAULT_SCANLINE_PAD",
		"r",
		"hDC",
		"hdcSource",
		"hdcDest",
		"hOldSrc",
		"hOldDest",
		"r",
		"rgbBwBitmapInfo",
		"hDC",
		"hdcSource",
		"bwDC",
		"hdcBmp",
		"pbitsBW",
		"hbmBW",
		"hOldSrc",
		"hOldBw",
		"hOldBmp",
		"rect",
		"hb",
		"oldBrush",
		"iconInfo",
		"hdcMask",
		"newHbmp",
		"newHmask",
		"hOldMask",
		"newIconInfo",
		"r",
		"data",
		"palette",
		"newData",
		"rgbs",
		"i",
		"color",
		"red",
		"green",
		"blue",
		"intensity",
		"rgbs",
		"i",
		"scanline",
		"redMask",
		"greenMask",
		"blueMask",
		"redShift",
		"greenShift",
		"blueShift",
		"y",
		"offset",
		"x",
		"pixel",
		"red",
		"green",
		"blue",
		"intensity",
		"bits",
		"planes",
		"depth",
		"isDirect",
		"rgbs",
		"numColors",
		"logPalette",
		"i",
		"useBitfields",
		"bmiHeader",
		"bmi",
		"offset",
		"redMask",
		"greenMask",
		"blueMask",
		"j",
		"pBits",
		"hDib",
		"hdcSource",
		"hdcDest",
		"hOldSrc",
		"hOldDest",
		"bm",
		"imgWidth",
		"imgHeight",
		"hDC",
		"srcHdc",
		"oldSrcBitmap",
		"memHdc",
		"memDib",
		"oldMemBitmap",
		"dibBM",
		"sizeInBytes",
		"red",
		"green",
		"blue",
		"color",
		"srcData",
		"y",
		"dp",
		"x",
		"y",
		"dp",
		"ap",
		"x",
		"y",
		"dp",
		"x",
		"hHeap",
		"pixels",
		"iconInfo",
		"hBitmap",
		"bm",
		"imgWidth",
		"imgHeight",
		"img",
		"pixels",
		"hDC",
		"srcHdc",
		"oldSrcBitmap",
		"memHdc",
		"memDib",
		"oldMemBitmap",
		"dibBM",
		"srcData",
		"y",
		"dp",
		"x",
		"hHeap",
		"image",
		"hDC",
		"bm",
		"hdcMem",
		"hOldObject",
		"red",
		"green",
		"blue",
		"pBits",
		"oldValue",
		"mask",
		"color",
		"color",
		"bm",
		"info",
		"hBitmap",
		"bm",
		"depth",
		"width",
		"height",
		"info",
		"hBitmap",
		"numColors",
		"bmiHeader",
		"bmi",
		"hDC",
		"hBitmapDC",
		"hOldBitmap",
		"oldPalette",
		"hPalette",
		"imageSize",
		"data",
		"hHeap",
		"lpvBits",
		"palette",
		"rgbs",
		"srcIndex",
		"i",
		"maskData",
		"offset",
		"lpvMaskBits",
		"i",
		"maskPad",
		"bpl",
		"calcBpl",
		"imageData",
		"isDib",
		"hDC",
		"handle",
		"mustRestore",
		"data",
		"hOldBitmap",
		"dib",
		"numColors",
		"bmi",
		"bmiHeader",
		"hBitmapDC",
		"hOldBitmap",
		"oldPalette",
		"hPalette",
		"imageSize",
		"data",
		"hHeap",
		"lpvBits",
		"palette",
		"rgbs",
		"red",
		"green",
		"blue",
		"pBits",
		"oldValue",
		"mask",
		"i",
		"color",
		"colors",
		"colorIndex",
		"i",
		"srcIndex",
		"i",
		"imageData",
		"hDC",
		"bits",
		"planes",
		"depth",
		"memDC",
		"hOldBitmap",
		"bmiHeader",
		"bmi",
		"redMask",
		"greenMask",
		"blueMask",
		"offset",
		"pBits",
		"result",
		"img",
		"palette",
		"redMask",
		"greenMask",
		"blueMask",
		"newDepth",
		"newOrder",
		"newPalette",
		"img",
		"rgbs",
		"useBitfields",
		"bmiHeader",
		"bmi",
		"offset",
		"palette",
		"redMask",
		"greenMask",
		"blueMask",
		"j",
		"pBits",
		"hDib",
		"data",
		"result",
		"hDC",
		"hdcSrc",
		"hBitmap",
		"hdcDest",
		"maskData",
		"hMask",
		"info",
		"hIcon",
		"length",
		"imageData",
		"blackIndex",
		"black",
		"rgbs",
		"newRGBs",
		"i",
		"newRGBs",
		"imagePixels",
		"maskPixels",
		"y",
		"i",
		"hDC",
		"imageDC",
		"mask",
		"hDC",
		"bm",
		"hdcMem",
		"maxColors",
		"colors",
		"numColors",
		"offset",
		"image",
		"device",
		"device",
		"Device",
		"device",
		"SWT",
		"SWT",
		"device",
		"width",
		"height",
		"device",
		"device",
		"device",
		"device",
		"Device",
		"device",
		"SWT",
		"SWT",
		"device",
		"srcImage",
		"SWT",
		"SWT",
		"srcImage",
		"SWT",
		"SWT",
		"flag",
		"SWT",
		"srcImage",
		"srcImage",
		"type",
		"SWT",
		"device",
		"OS",
		"hDC",
		"OS",
		"hDC",
		"OS",
		"hdcSource",
		"srcImage",
		"handle",
		"OS",
		"hdcSource",
		"r",
		"r",
		"handle",
		"SWT",
		"SWT",
		"OS",
		"hdcDest",
		"handle",
		"OS",
		"hdcDest",
		"r",
		"r",
		"hdcSource",
		"OS",
		"OS",
		"hdcSource",
		"hOldSrc",
		"OS",
		"hdcDest",
		"hOldDest",
		"OS",
		"hdcSource",
		"OS",
		"hdcDest",
		"device",
		"hDC",
		"transparentPixel",
		"srcImage",
		"alpha",
		"srcImage",
		"srcImage",
		"alphaData",
		"srcImage",
		"System",
		"srcImage",
		"alphaData",
		"alphaData",
		"SWT",
		"OS",
		"device",
		"srcImage",
		"handle",
		"OS",
		"srcImage",
		"OS",
		"r",
		"r",
		"handle",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"device",
		"device",
		"SWT",
		"srcImage",
		"srcImage",
		"r",
		"r",
		"r",
		"r",
		"r",
		"r",
		"r",
		"r",
		"device",
		"OS",
		"hDC",
		"hdcSource",
		"SWT",
		"SWT",
		"OS",
		"hdcSource",
		"bwDC",
		"SWT",
		"SWT",
		"OS",
		"hDC",
		"hdcBmp",
		"SWT",
		"SWT",
		"OS",
		"bwDC",
		"rgbBwBitmapInfo",
		"OS",
		"pbitsBW",
		"hbmBW",
		"SWT",
		"SWT",
		"type",
		"SWT",
		"OS",
		"hdcSource",
		"srcImage",
		"handle",
		"OS",
		"hDC",
		"r",
		"r",
		"handle",
		"SWT",
		"SWT",
		"OS",
		"bwDC",
		"hbmBW",
		"OS",
		"hdcBmp",
		"handle",
		"OS",
		"bwDC",
		"r",
		"r",
		"hdcSource",
		"OS",
		"rect",
		"rect",
		"rect",
		"r",
		"rect",
		"r",
		"OS",
		"hdcBmp",
		"rect",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"hdcBmp",
		"hb",
		"OS",
		"hdcBmp",
		"r",
		"r",
		"bwDC",
		"hb",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"hdcBmp",
		"hb",
		"OS",
		"hdcBmp",
		"r",
		"r",
		"bwDC",
		"OS",
		"OS",
		"hdcBmp",
		"oldBrush",
		"OS",
		"hdcSource",
		"hOldSrc",
		"OS",
		"hdcBmp",
		"hOldBmp",
		"OS",
		"bwDC",
		"hOldBw",
		"OS",
		"hdcSource",
		"OS",
		"bwDC",
		"OS",
		"hdcBmp",
		"OS",
		"hbmBW",
		"device",
		"hDC",
		"SWT",
		"OS",
		"srcImage",
		"iconInfo",
		"OS",
		"srcImage",
		"iconInfo",
		"SWT",
		"SWT",
		"OS",
		"hDC",
		"iconInfo",
		"hOldSrc",
		"OS",
		"hdcSource",
		"iconInfo",
		"hOldSrc",
		"OS",
		"hdcSource",
		"iconInfo",
		"OS",
		"hdcSource",
		"r",
		"r",
		"newHbmp",
		"SWT",
		"SWT",
		"OS",
		"r",
		"r",
		"newHmask",
		"SWT",
		"SWT",
		"OS",
		"hdcMask",
		"newHmask",
		"iconInfo",
		"OS",
		"hdcSource",
		"iconInfo",
		"OS",
		"hdcSource",
		"iconInfo",
		"OS",
		"hdcMask",
		"r",
		"r",
		"hdcSource",
		"OS",
		"hOldBw",
		"OS",
		"bwDC",
		"hbmBW",
		"iconInfo",
		"OS",
		"hdcSource",
		"iconInfo",
		"OS",
		"bwDC",
		"r",
		"r",
		"hdcSource",
		"r",
		"OS",
		"OS",
		"hdcSource",
		"iconInfo",
		"OS",
		"bwDC",
		"r",
		"r",
		"hdcSource",
		"OS",
		"rect",
		"rect",
		"rect",
		"rect",
		"r",
		"rect",
		"r",
		"hOldBmp",
		"OS",
		"hdcBmp",
		"newHbmp",
		"OS",
		"hdcBmp",
		"rect",
		"OS",
		"OS",
		"hb",
		"OS",
		"OS",
		"OS",
		"oldBrush",
		"OS",
		"hdcBmp",
		"hb",
		"OS",
		"hdcBmp",
		"r",
		"r",
		"bwDC",
		"OS",
		"bwDC",
		"r",
		"r",
		"hdcMask",
		"OS",
		"hb",
		"OS",
		"OS",
		"OS",
		"hdcBmp",
		"hb",
		"OS",
		"hdcBmp",
		"r",
		"r",
		"bwDC",
		"OS",
		"OS",
		"hdcBmp",
		"oldBrush",
		"OS",
		"hdcSource",
		"hOldSrc",
		"OS",
		"hdcSource",
		"OS",
		"bwDC",
		"hOldBw",
		"OS",
		"bwDC",
		"OS",
		"hdcBmp",
		"hOldBmp",
		"OS",
		"hdcBmp",
		"OS",
		"hdcMask",
		"hOldMask",
		"OS",
		"hdcMask",
		"OS",
		"hbmBW",
		"device",
		"hDC",
		"newIconInfo",
		"iconInfo",
		"newIconInfo",
		"newHmask",
		"newIconInfo",
		"newHbmp",
		"handle",
		"OS",
		"newIconInfo",
		"handle",
		"SWT",
		"SWT",
		"OS",
		"newHbmp",
		"OS",
		"newHmask",
		"iconInfo",
		"OS",
		"iconInfo",
		"OS",
		"iconInfo",
		"SWT",
		"SWT",
		"device",
		"device",
		"SWT",
		"srcImage",
		"srcImage",
		"data",
		"data",
		"palette",
		"palette",
		"i",
		"rgbs",
		"i",
		"data",
		"i",
		"rgbs",
		"i",
		"color",
		"color",
		"color",
		"red",
		"red",
		"green",
		"green",
		"green",
		"green",
		"green",
		"blue",
		"color",
		"color",
		"color",
		"intensity",
		"newData",
		"rgbs",
		"i",
		"rgbs",
		"i",
		"rgbs",
		"i",
		"i",
		"i",
		"i",
		"newData",
		"r",
		"r",
		"rgbs",
		"newData",
		"data",
		"newData",
		"data",
		"data",
		"newData",
		"r",
		"palette",
		"palette",
		"palette",
		"palette",
		"palette",
		"palette",
		"y",
		"r",
		"y",
		"y",
		"newData",
		"data",
		"y",
		"r",
		"scanline",
		"x",
		"r",
		"x",
		"scanline",
		"x",
		"pixel",
		"data",
		"pixel",
		"redMask",
		"red",
		"redShift",
		"red",
		"redShift",
		"red",
		"redShift",
		"pixel",
		"greenMask",
		"green",
		"greenShift",
		"green",
		"greenShift",
		"green",
		"greenShift",
		"pixel",
		"blueMask",
		"blue",
		"blueShift",
		"blue",
		"blueShift",
		"blue",
		"blueShift",
		"red",
		"red",
		"green",
		"green",
		"green",
		"green",
		"green",
		"blue",
		"newData",
		"intensity",
		"intensity",
		"newData",
		"offset",
		"intensity",
		"newData",
		"offset",
		"offset",
		"device",
		"newData",
		"device",
		"device",
		"SWT",
		"SWT",
		"device",
		"device",
		"Device",
		"device",
		"SWT",
		"SWT",
		"bounds",
		"SWT",
		"SWT",
		"device",
		"bounds",
		"bounds",
		"device",
		"device",
		"device",
		"device",
		"Device",
		"device",
		"SWT",
		"SWT",
		"device",
		"data",
		"device",
		"device",
		"device",
		"device",
		"Device",
		"device",
		"SWT",
		"SWT",
		"source",
		"SWT",
		"SWT",
		"mask",
		"SWT",
		"SWT",
		"source",
		"mask",
		"source",
		"mask",
		"SWT",
		"SWT",
		"mask",
		"ImageData",
		"mask",
		"device",
		"source",
		"mask",
		"device",
		"device",
		"device",
		"device",
		"Device",
		"device",
		"SWT",
		"SWT",
		"device",
		"stream",
		"device",
		"device",
		"device",
		"device",
		"Device",
		"device",
		"SWT",
		"SWT",
		"device",
		"filename",
		"device",
		"device",
		"OS",
		"hDC",
		"OS",
		"OS",
		"hDC",
		"OS",
		"bits",
		"planes",
		"depth",
		"isDirect",
		"depth",
		"numColors",
		"OS",
		"device",
		"numColors",
		"logPalette",
		"rgbs",
		"numColors",
		"i",
		"numColors",
		"i",
		"rgbs",
		"i",
		"logPalette",
		"i",
		"logPalette",
		"i",
		"logPalette",
		"i",
		"OS",
		"depth",
		"depth",
		"bmiHeader",
		"BITMAPINFOHEADER",
		"bmiHeader",
		"width",
		"bmiHeader",
		"height",
		"bmiHeader",
		"bmiHeader",
		"depth",
		"useBitfields",
		"bmiHeader",
		"OS",
		"bmiHeader",
		"OS",
		"isDirect",
		"bmi",
		"BITMAPINFOHEADER",
		"useBitfields",
		"bmi",
		"BITMAPINFOHEADER",
		"rgbs",
		"OS",
		"bmi",
		"bmiHeader",
		"BITMAPINFOHEADER",
		"BITMAPINFOHEADER",
		"isDirect",
		"useBitfields",
		"depth",
		"redMask",
		"greenMask",
		"blueMask",
		"bmi",
		"offset",
		"redMask",
		"bmi",
		"offset",
		"redMask",
		"bmi",
		"offset",
		"redMask",
		"bmi",
		"offset",
		"redMask",
		"bmi",
		"offset",
		"greenMask",
		"bmi",
		"offset",
		"greenMask",
		"bmi",
		"offset",
		"greenMask",
		"bmi",
		"offset",
		"greenMask",
		"bmi",
		"offset",
		"blueMask",
		"bmi",
		"offset",
		"blueMask",
		"bmi",
		"offset",
		"blueMask",
		"bmi",
		"offset",
		"blueMask",
		"redMask",
		"greenMask",
		"blueMask",
		"bmi",
		"offset",
		"redMask",
		"bmi",
		"offset",
		"redMask",
		"bmi",
		"offset",
		"redMask",
		"bmi",
		"offset",
		"redMask",
		"bmi",
		"offset",
		"greenMask",
		"bmi",
		"offset",
		"greenMask",
		"bmi",
		"offset",
		"greenMask",
		"bmi",
		"offset",
		"greenMask",
		"bmi",
		"offset",
		"blueMask",
		"bmi",
		"offset",
		"blueMask",
		"bmi",
		"offset",
		"blueMask",
		"bmi",
		"offset",
		"blueMask",
		"SWT",
		"SWT",
		"j",
		"rgbs",
		"j",
		"bmi",
		"offset",
		"rgbs",
		"j",
		"bmi",
		"offset",
		"rgbs",
		"j",
		"bmi",
		"offset",
		"rgbs",
		"j",
		"bmi",
		"offset",
		"offset",
		"OS",
		"bmi",
		"OS",
		"pBits",
		"hDib",
		"SWT",
		"SWT",
		"OS",
		"hDC",
		"OS",
		"hDC",
		"OS",
		"hdcSource",
		"hBitmap",
		"OS",
		"hdcDest",
		"hDib",
		"OS",
		"hdcDest",
		"width",
		"height",
		"hdcSource",
		"OS",
		"OS",
		"hdcSource",
		"hOldSrc",
		"OS",
		"hdcDest",
		"hOldDest",
		"OS",
		"hdcSource",
		"OS",
		"hdcDest",
		"hDib",
		"type",
		"SWT",
		"alpha",
		"alphaData",
		"transparentPixel",
		"OS",
		"handle",
		"BITMAP",
		"bm",
		"bm",
		"bm",
		"device",
		"OS",
		"hDC",
		"OS",
		"srcHdc",
		"handle",
		"OS",
		"hDC",
		"imgWidth",
		"imgHeight",
		"memDib",
		"SWT",
		"SWT",
		"OS",
		"memHdc",
		"memDib",
		"OS",
		"memDib",
		"BITMAP",
		"dibBM",
		"dibBM",
		"dibBM",
		"OS",
		"memHdc",
		"imgWidth",
		"imgHeight",
		"srcHdc",
		"OS",
		"transparentPixel",
		"bm",
		"OS",
		"srcHdc",
		"transparentPixel",
		"color",
		"blue",
		"color",
		"green",
		"color",
		"red",
		"color",
		"bm",
		"blue",
		"transparentPixel",
		"green",
		"transparentPixel",
		"red",
		"transparentPixel",
		"blue",
		"transparentPixel",
		"green",
		"transparentPixel",
		"red",
		"transparentPixel",
		"blue",
		"transparentPixel",
		"green",
		"transparentPixel",
		"red",
		"transparentPixel",
		"OS",
		"srcHdc",
		"oldSrcBitmap",
		"OS",
		"memHdc",
		"oldMemBitmap",
		"OS",
		"srcHdc",
		"OS",
		"memHdc",
		"sizeInBytes",
		"OS",
		"srcData",
		"dibBM",
		"sizeInBytes",
		"OS",
		"memDib",
		"device",
		"hDC",
		"alpha",
		"y",
		"imgHeight",
		"y",
		"x",
		"imgWidth",
		"x",
		"srcData",
		"dp",
		"alpha",
		"dp",
		"alphaData",
		"y",
		"imgHeight",
		"y",
		"x",
		"imgWidth",
		"x",
		"srcData",
		"dp",
		"alphaData",
		"ap",
		"dp",
		"transparentPixel",
		"y",
		"imgHeight",
		"y",
		"x",
		"imgWidth",
		"x",
		"srcData",
		"dp",
		"blue",
		"srcData",
		"dp",
		"green",
		"srcData",
		"dp",
		"red",
		"srcData",
		"dp",
		"srcData",
		"dp",
		"dp",
		"OS",
		"OS",
		"hHeap",
		"OS",
		"srcData",
		"OS",
		"pixels",
		"srcData",
		"sizeInBytes",
		"Gdip",
		"imgWidth",
		"imgHeight",
		"dibBM",
		"Gdip",
		"pixels",
		"pixels",
		"Gdip",
		"handle",
		"SWT",
		"OS",
		"iconInfo",
		"OS",
		"handle",
		"iconInfo",
		"iconInfo",
		"hBitmap",
		"hBitmap",
		"iconInfo",
		"OS",
		"hBitmap",
		"BITMAP",
		"bm",
		"bm",
		"hBitmap",
		"iconInfo",
		"bm",
		"bm",
		"imgWidth",
		"imgHeight",
		"device",
		"OS",
		"hDC",
		"OS",
		"srcHdc",
		"hBitmap",
		"OS",
		"hDC",
		"imgWidth",
		"imgHeight",
		"memDib",
		"SWT",
		"SWT",
		"OS",
		"memHdc",
		"memDib",
		"OS",
		"memDib",
		"BITMAP",
		"dibBM",
		"OS",
		"memHdc",
		"imgWidth",
		"imgHeight",
		"srcHdc",
		"hBitmap",
		"iconInfo",
		"imgHeight",
		"OS",
		"OS",
		"memHdc",
		"oldMemBitmap",
		"OS",
		"memHdc",
		"dibBM",
		"dibBM",
		"OS",
		"srcData",
		"dibBM",
		"srcData",
		"OS",
		"memDib",
		"OS",
		"srcHdc",
		"iconInfo",
		"y",
		"imgHeight",
		"y",
		"x",
		"imgWidth",
		"x",
		"OS",
		"srcHdc",
		"x",
		"y",
		"srcData",
		"dp",
		"srcData",
		"dp",
		"dp",
		"OS",
		"srcHdc",
		"oldSrcBitmap",
		"OS",
		"srcHdc",
		"device",
		"hDC",
		"OS",
		"pixels",
		"OS",
		"hHeap",
		"OS",
		"srcData",
		"OS",
		"pixels",
		"srcData",
		"srcData",
		"img",
		"Gdip",
		"imgWidth",
		"imgHeight",
		"dibBM",
		"Gdip",
		"pixels",
		"img",
		"Gdip",
		"handle",
		"iconInfo",
		"OS",
		"iconInfo",
		"iconInfo",
		"OS",
		"iconInfo",
		"img",
		"pixels",
		"SWT",
		"SWT",
		"handle",
		"device",
		"memGC",
		"memGC",
		"type",
		"SWT",
		"OS",
		"data",
		"OS",
		"handle",
		"OS",
		"handle",
		"handle",
		"memGC",
		"device",
		"device",
		"device",
		"object",
		"object",
		"object",
		"device",
		"image",
		"handle",
		"image",
		"SWT",
		"SWT",
		"transparentPixel",
		"device",
		"OS",
		"handle",
		"BITMAP",
		"bm",
		"OS",
		"hDC",
		"OS",
		"hdcMem",
		"handle",
		"bm",
		"OS",
		"OS",
		"pBits",
		"bm",
		"pBits",
		"bm",
		"pBits",
		"transparentPixel",
		"bm",
		"pBits",
		"mask",
		"OS",
		"bm",
		"pBits",
		"OS",
		"hdcMem",
		"pBits",
		"oldValue",
		"OS",
		"bm",
		"pBits",
		"blue",
		"color",
		"green",
		"color",
		"red",
		"color",
		"OS",
		"hdcMem",
		"transparentPixel",
		"color",
		"blue",
		"color",
		"green",
		"color",
		"red",
		"color",
		"bm",
		"blue",
		"transparentPixel",
		"green",
		"transparentPixel",
		"red",
		"transparentPixel",
		"blue",
		"transparentPixel",
		"green",
		"transparentPixel",
		"red",
		"transparentPixel",
		"blue",
		"transparentPixel",
		"green",
		"transparentPixel",
		"red",
		"transparentPixel",
		"OS",
		"hdcMem",
		"hOldObject",
		"OS",
		"hdcMem",
		"device",
		"hDC",
		"Color",
		"device",
		"blue",
		"green",
		"red",
		"SWT",
		"SWT",
		"type",
		"SWT",
		"OS",
		"handle",
		"BITMAP",
		"bm",
		"bm",
		"bm",
		"SWT",
		"OS",
		"data",
		"data",
		"OS",
		"handle",
		"info",
		"info",
		"hBitmap",
		"hBitmap",
		"info",
		"bm",
		"OS",
		"hBitmap",
		"BITMAP",
		"bm",
		"hBitmap",
		"info",
		"bm",
		"info",
		"OS",
		"info",
		"info",
		"OS",
		"info",
		"bm",
		"bm",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"type",
		"SWT",
		"OS",
		"data",
		"OS",
		"SWT",
		"SWT",
		"OS",
		"handle",
		"info",
		"info",
		"hBitmap",
		"hBitmap",
		"info",
		"bm",
		"OS",
		"hBitmap",
		"BITMAP",
		"bm",
		"depth",
		"bm",
		"bm",
		"width",
		"bm",
		"hBitmap",
		"info",
		"bm",
		"height",
		"bm",
		"depth",
		"numColors",
		"depth",
		"bmiHeader",
		"BITMAPINFOHEADER",
		"bmiHeader",
		"width",
		"bmiHeader",
		"height",
		"bmiHeader",
		"bmiHeader",
		"depth",
		"bmiHeader",
		"OS",
		"BITMAPINFOHEADER",
		"numColors",
		"OS",
		"bmi",
		"bmiHeader",
		"BITMAPINFOHEADER",
		"device",
		"OS",
		"hDC",
		"OS",
		"hBitmapDC",
		"hBitmap",
		"depth",
		"device",
		"hPalette",
		"oldPalette",
		"OS",
		"hBitmapDC",
		"hPalette",
		"OS",
		"hBitmapDC",
		"OS",
		"SWT",
		"SWT",
		"OS",
		"hBitmapDC",
		"hBitmap",
		"height",
		"bmi",
		"OS",
		"OS",
		"bmiHeader",
		"bmi",
		"BITMAPINFOHEADER",
		"imageSize",
		"bmiHeader",
		"imageSize",
		"OS",
		"OS",
		"hHeap",
		"OS",
		"imageSize",
		"OS",
		"SWT",
		"SWT",
		"OS",
		"hBitmapDC",
		"hBitmap",
		"height",
		"lpvBits",
		"bmi",
		"OS",
		"OS",
		"data",
		"lpvBits",
		"imageSize",
		"depth",
		"numColors",
		"i",
		"numColors",
		"i",
		"rgbs",
		"i",
		"bmi",
		"srcIndex",
		"bmi",
		"srcIndex",
		"bmi",
		"srcIndex",
		"srcIndex",
		"palette",
		"rgbs",
		"depth",
		"palette",
		"depth",
		"palette",
		"depth",
		"palette",
		"SWT",
		"SWT",
		"info",
		"maskData",
		"imageSize",
		"OS",
		"SWT",
		"SWT",
		"OS",
		"hBitmapDC",
		"hBitmap",
		"height",
		"height",
		"lpvBits",
		"bmi",
		"OS",
		"OS",
		"maskData",
		"lpvBits",
		"imageSize",
		"bmiHeader",
		"bmiHeader",
		"BITMAPINFOHEADER",
		"bmiHeader",
		"width",
		"bmiHeader",
		"height",
		"bmiHeader",
		"bmiHeader",
		"bmiHeader",
		"OS",
		"bmi",
		"BITMAPINFOHEADER",
		"OS",
		"bmi",
		"bmiHeader",
		"BITMAPINFOHEADER",
		"BITMAPINFOHEADER",
		"bmi",
		"offset",
		"bmi",
		"offset",
		"bmi",
		"offset",
		"bmi",
		"offset",
		"OS",
		"hBitmapDC",
		"info",
		"OS",
		"SWT",
		"SWT",
		"OS",
		"hBitmapDC",
		"info",
		"height",
		"bmi",
		"OS",
		"OS",
		"bmiHeader",
		"bmi",
		"BITMAPINFOHEADER",
		"imageSize",
		"bmiHeader",
		"maskData",
		"imageSize",
		"OS",
		"hHeap",
		"OS",
		"imageSize",
		"OS",
		"SWT",
		"SWT",
		"OS",
		"hBitmapDC",
		"info",
		"height",
		"lpvMaskBits",
		"bmi",
		"OS",
		"OS",
		"maskData",
		"lpvMaskBits",
		"imageSize",
		"OS",
		"hHeap",
		"lpvMaskBits",
		"i",
		"maskData",
		"i",
		"maskData",
		"i",
		"imageSize",
		"height",
		"maskPad",
		"maskPad",
		"maskPad",
		"width",
		"maskPad",
		"maskPad",
		"maskPad",
		"calcBpl",
		"bpl",
		"maskData",
		"ImageData",
		"maskData",
		"width",
		"height",
		"maskPad",
		"OS",
		"hHeap",
		"lpvBits",
		"OS",
		"hBitmapDC",
		"hOldBitmap",
		"oldPalette",
		"OS",
		"hBitmapDC",
		"oldPalette",
		"OS",
		"hBitmapDC",
		"OS",
		"hBitmapDC",
		"device",
		"hDC",
		"info",
		"OS",
		"info",
		"info",
		"OS",
		"info",
		"width",
		"height",
		"depth",
		"palette",
		"data",
		"imageData",
		"maskData",
		"imageData",
		"imageData",
		"SWT",
		"bm",
		"OS",
		"handle",
		"BITMAP",
		"bm",
		"depth",
		"bm",
		"bm",
		"width",
		"bm",
		"height",
		"bm",
		"bm",
		"device",
		"OS",
		"isDib",
		"memGC",
		"memGC",
		"memGC",
		"mustRestore",
		"memGC",
		"data",
		"OS",
		"memGC",
		"data",
		"data",
		"handle",
		"hDC",
		"width",
		"height",
		"mustRestore",
		"OS",
		"memGC",
		"memGC",
		"hOldBitmap",
		"isDib",
		"isDib",
		"dib",
		"OS",
		"handle",
		"DIBSECTION",
		"dib",
		"depth",
		"isDib",
		"numColors",
		"dib",
		"numColors",
		"depth",
		"isDib",
		"bmiHeader",
		"bmiHeader",
		"BITMAPINFOHEADER",
		"bmiHeader",
		"width",
		"bmiHeader",
		"height",
		"bmiHeader",
		"bmiHeader",
		"depth",
		"bmiHeader",
		"OS",
		"bmi",
		"BITMAPINFOHEADER",
		"numColors",
		"OS",
		"bmi",
		"bmiHeader",
		"BITMAPINFOHEADER",
		"OS",
		"hDC",
		"OS",
		"hBitmapDC",
		"handle",
		"isDib",
		"depth",
		"device",
		"hPalette",
		"oldPalette",
		"OS",
		"hBitmapDC",
		"hPalette",
		"OS",
		"hBitmapDC",
		"isDib",
		"imageSize",
		"dib",
		"OS",
		"SWT",
		"SWT",
		"OS",
		"hBitmapDC",
		"handle",
		"height",
		"bmi",
		"OS",
		"OS",
		"bmiHeader",
		"bmi",
		"BITMAPINFOHEADER",
		"imageSize",
		"bmiHeader",
		"imageSize",
		"isDib",
		"OS",
		"handle",
		"OS",
		"data",
		"dib",
		"imageSize",
		"OS",
		"data",
		"bm",
		"imageSize",
		"OS",
		"OS",
		"hHeap",
		"OS",
		"imageSize",
		"OS",
		"SWT",
		"SWT",
		"OS",
		"hBitmapDC",
		"handle",
		"height",
		"lpvBits",
		"bmi",
		"OS",
		"OS",
		"data",
		"lpvBits",
		"imageSize",
		"OS",
		"hHeap",
		"lpvBits",
		"depth",
		"numColors",
		"isDib",
		"OS",
		"OS",
		"pBits",
		"bm",
		"pBits",
		"bm",
		"i",
		"numColors",
		"i",
		"pBits",
		"i",
		"bm",
		"pBits",
		"mask",
		"OS",
		"bm",
		"pBits",
		"OS",
		"hBitmapDC",
		"blue",
		"color",
		"green",
		"color",
		"red",
		"color",
		"rgbs",
		"i",
		"red",
		"green",
		"blue",
		"pBits",
		"oldValue",
		"OS",
		"bm",
		"pBits",
		"numColors",
		"OS",
		"hBitmapDC",
		"numColors",
		"colors",
		"i",
		"rgbs",
		"i",
		"rgbs",
		"i",
		"colors",
		"colorIndex",
		"colors",
		"colorIndex",
		"colors",
		"colorIndex",
		"colorIndex",
		"BITMAPINFOHEADER",
		"i",
		"numColors",
		"i",
		"rgbs",
		"i",
		"bmi",
		"srcIndex",
		"bmi",
		"srcIndex",
		"bmi",
		"srcIndex",
		"srcIndex",
		"palette",
		"rgbs",
		"depth",
		"palette",
		"depth",
		"palette",
		"depth",
		"palette",
		"SWT",
		"SWT",
		"OS",
		"hBitmapDC",
		"hOldBitmap",
		"oldPalette",
		"OS",
		"hBitmapDC",
		"oldPalette",
		"OS",
		"hBitmapDC",
		"OS",
		"handle",
		"OS",
		"handle",
		"OS",
		"hBitmapDC",
		"device",
		"hDC",
		"width",
		"height",
		"depth",
		"palette",
		"data",
		"imageData",
		"imageData",
		"alpha",
		"alpha",
		"alphaData",
		"imageData",
		"alphaData",
		"System",
		"alphaData",
		"imageData",
		"alphaData",
		"imageData",
		"SWT",
		"SWT",
		"handle",
		"width",
		"height",
		"SWT",
		"SWT",
		"device",
		"type",
		"SWT",
		"device",
		"handle",
		"OS",
		"hDC",
		"width",
		"height",
		"handle",
		"OS",
		"hDC",
		"OS",
		"OS",
		"hDC",
		"OS",
		"bits",
		"planes",
		"depth",
		"depth",
		"handle",
		"width",
		"height",
		"depth",
		"handle",
		"OS",
		"hDC",
		"OS",
		"memDC",
		"handle",
		"OS",
		"memDC",
		"width",
		"height",
		"OS",
		"OS",
		"memDC",
		"hOldBitmap",
		"OS",
		"memDC",
		"device",
		"hDC",
		"handle",
		"SWT",
		"SWT",
		"device",
		"bmiHeader",
		"BITMAPINFOHEADER",
		"bmiHeader",
		"width",
		"bmiHeader",
		"height",
		"bmiHeader",
		"bmiHeader",
		"depth",
		"OS",
		"bmiHeader",
		"OS",
		"bmiHeader",
		"OS",
		"BITMAPINFOHEADER",
		"OS",
		"OS",
		"bmi",
		"bmiHeader",
		"BITMAPINFOHEADER",
		"OS",
		"BITMAPINFOHEADER",
		"bmi",
		"offset",
		"redMask",
		"bmi",
		"offset",
		"redMask",
		"bmi",
		"offset",
		"redMask",
		"bmi",
		"offset",
		"redMask",
		"bmi",
		"offset",
		"greenMask",
		"bmi",
		"offset",
		"greenMask",
		"bmi",
		"offset",
		"greenMask",
		"bmi",
		"offset",
		"greenMask",
		"bmi",
		"offset",
		"blueMask",
		"bmi",
		"offset",
		"blueMask",
		"bmi",
		"offset",
		"blueMask",
		"bmi",
		"offset",
		"blueMask",
		"OS",
		"bmi",
		"OS",
		"pBits",
		"image",
		"image",
		"info",
		"result",
		"info",
		"result",
		"image",
		"image",
		"device",
		"OS",
		"i",
		"i",
		"SWT",
		"i",
		"i",
		"i",
		"i",
		"ImageData",
		"ImageData",
		"i",
		"i",
		"i",
		"i",
		"i",
		"i",
		"ImageData",
		"img",
		"img",
		"img",
		"i",
		"img",
		"img",
		"img",
		"i",
		"img",
		"i",
		"img",
		"i",
		"img",
		"i",
		"img",
		"i",
		"i",
		"img",
		"i",
		"i",
		"palette",
		"palette",
		"palette",
		"i",
		"ImageData",
		"i",
		"newDepth",
		"newOrder",
		"ImageData",
		"newPalette",
		"newOrder",
		"ImageData",
		"redMask",
		"greenMask",
		"blueMask",
		"newPalette",
		"redMask",
		"greenMask",
		"blueMask",
		"newPalette",
		"redMask",
		"greenMask",
		"blueMask",
		"newPalette",
		"SWT",
		"SWT",
		"newPalette",
		"i",
		"i",
		"newDepth",
		"newPalette",
		"ImageData",
		"ImageData",
		"i",
		"i",
		"i",
		"i",
		"i",
		"i",
		"redMask",
		"greenMask",
		"blueMask",
		"ImageData",
		"img",
		"img",
		"img",
		"newOrder",
		"img",
		"img",
		"newPalette",
		"newPalette",
		"newPalette",
		"i",
		"img",
		"newPalette",
		"palette",
		"i",
		"img",
		"i",
		"img",
		"i",
		"img",
		"i",
		"img",
		"i",
		"i",
		"img",
		"i",
		"OS",
		"i",
		"i",
		"bmiHeader",
		"BITMAPINFOHEADER",
		"bmiHeader",
		"i",
		"bmiHeader",
		"i",
		"bmiHeader",
		"bmiHeader",
		"i",
		"useBitfields",
		"bmiHeader",
		"OS",
		"bmiHeader",
		"OS",
		"bmiHeader",
		"rgbs",
		"rgbs",
		"i",
		"bmi",
		"BITMAPINFOHEADER",
		"useBitfields",
		"bmi",
		"BITMAPINFOHEADER",
		"rgbs",
		"OS",
		"bmi",
		"bmiHeader",
		"BITMAPINFOHEADER",
		"BITMAPINFOHEADER",
		"i",
		"useBitfields",
		"i",
		"palette",
		"palette",
		"palette",
		"i",
		"ImageData",
		"bmi",
		"offset",
		"redMask",
		"bmi",
		"offset",
		"redMask",
		"bmi",
		"offset",
		"redMask",
		"bmi",
		"offset",
		"redMask",
		"bmi",
		"offset",
		"greenMask",
		"bmi",
		"offset",
		"greenMask",
		"bmi",
		"offset",
		"greenMask",
		"bmi",
		"offset",
		"greenMask",
		"bmi",
		"offset",
		"blueMask",
		"bmi",
		"offset",
		"blueMask",
		"bmi",
		"offset",
		"blueMask",
		"bmi",
		"offset",
		"blueMask",
		"bmi",
		"offset",
		"redMask",
		"bmi",
		"offset",
		"redMask",
		"bmi",
		"offset",
		"redMask",
		"bmi",
		"offset",
		"redMask",
		"bmi",
		"offset",
		"greenMask",
		"bmi",
		"offset",
		"greenMask",
		"bmi",
		"offset",
		"greenMask",
		"bmi",
		"offset",
		"greenMask",
		"bmi",
		"offset",
		"blueMask",
		"bmi",
		"offset",
		"blueMask",
		"bmi",
		"offset",
		"blueMask",
		"bmi",
		"offset",
		"blueMask",
		"j",
		"rgbs",
		"j",
		"bmi",
		"offset",
		"rgbs",
		"j",
		"bmi",
		"offset",
		"rgbs",
		"j",
		"bmi",
		"offset",
		"rgbs",
		"j",
		"bmi",
		"offset",
		"offset",
		"OS",
		"bmi",
		"OS",
		"pBits",
		"hDib",
		"SWT",
		"SWT",
		"i",
		"i",
		"i",
		"data",
		"ImageData",
		"data",
		"i",
		"i",
		"i",
		"i",
		"OS",
		"pBits",
		"data",
		"data",
		"i",
		"SWT",
		"device",
		"OS",
		"hDC",
		"OS",
		"hdcSrc",
		"hDib",
		"OS",
		"hDC",
		"i",
		"i",
		"hBitmap",
		"SWT",
		"SWT",
		"OS",
		"hDC",
		"OS",
		"hdcDest",
		"hBitmap",
		"OS",
		"hdcDest",
		"i",
		"i",
		"hdcSrc",
		"OS",
		"device",
		"hDC",
		"ImageData",
		"i",
		"i",
		"i",
		"i",
		"OS",
		"i",
		"i",
		"maskData",
		"hMask",
		"SWT",
		"SWT",
		"OS",
		"hdcSrc",
		"hMask",
		"OS",
		"hdcSrc",
		"i",
		"i",
		"OS",
		"OS",
		"hdcSrc",
		"OS",
		"hdcDest",
		"OS",
		"hDib",
		"image",
		"result",
		"hBitmap",
		"hMask",
		"info",
		"info",
		"hBitmap",
		"info",
		"hMask",
		"OS",
		"info",
		"hIcon",
		"SWT",
		"SWT",
		"OS",
		"hBitmap",
		"OS",
		"hMask",
		"image",
		"hIcon",
		"image",
		"SWT",
		"OS",
		"image",
		"i",
		"image",
		"result",
		"hDib",
		"image",
		"hDib",
		"image",
		"SWT",
		"image",
		"i",
		"image",
		"image",
		"i",
		"i",
		"i",
		"i",
		"image",
		"length",
		"System",
		"i",
		"image",
		"length",
		"result",
		"source",
		"imageData",
		"source",
		"source",
		"source",
		"source",
		"source",
		"source",
		"rgbs",
		"System",
		"rgbs",
		"newRGBs",
		"rgbs",
		"source",
		"newRGBs",
		"rgbs",
		"source",
		"System",
		"newRGBs",
		"rgbs",
		"newRGBs",
		"newRGBs",
		"i",
		"source",
		"i",
		"rgbs",
		"i",
		"newRGBs",
		"source",
		"black",
		"rgbs",
		"newRGBs",
		"blackIndex",
		"source",
		"imageData",
		"source",
		"source",
		"source",
		"rgbs",
		"blackIndex",
		"rgbs",
		"rgbs",
		"blackIndex",
		"black",
		"blackIndex",
		"blackIndex",
		"rgbs",
		"source",
		"rgbs",
		"rgbs",
		"System",
		"rgbs",
		"newRGBs",
		"rgbs",
		"newRGBs",
		"rgbs",
		"black",
		"rgbs",
		"newRGBs",
		"blackIndex",
		"imageData",
		"source",
		"source",
		"source",
		"rgbs",
		"blackIndex",
		"System",
		"source",
		"imageData",
		"imageData",
		"imageData",
		"mask",
		"y",
		"imageData",
		"y",
		"source",
		"y",
		"imageData",
		"imagePixels",
		"mask",
		"y",
		"mask",
		"maskPixels",
		"i",
		"imagePixels",
		"i",
		"maskPixels",
		"i",
		"imagePixels",
		"i",
		"blackIndex",
		"imageData",
		"y",
		"source",
		"imagePixels",
		"imageData",
		"mask",
		"imageData",
		"mask",
		"device",
		"image",
		"imageData",
		"i",
		"SWT",
		"SWT",
		"device",
		"i",
		"handle",
		"SWT",
		"SWT",
		"type",
		"SWT",
		"memGC",
		"SWT",
		"SWT",
		"device",
		"OS",
		"hDC",
		"device",
		"hDC",
		"imageDC",
		"SWT",
		"SWT",
		"data",
		"SWT",
		"SWT",
		"data",
		"mask",
		"data",
		"data",
		"SWT",
		"OS",
		"data",
		"SWT",
		"data",
		"device",
		"data",
		"data",
		"device",
		"imageDC",
		"OS",
		"hDC",
		"handle",
		"OS",
		"SWT",
		"SWT",
		"color",
		"SWT",
		"SWT",
		"color",
		"SWT",
		"SWT",
		"transparentPixel",
		"device",
		"OS",
		"handle",
		"BITMAP",
		"bm",
		"OS",
		"hDC",
		"OS",
		"hdcMem",
		"handle",
		"bm",
		"maxColors",
		"OS",
		"SWT",
		"SWT",
		"OS",
		"hdcMem",
		"maxColors",
		"colors",
		"transparentPixel",
		"colors",
		"offset",
		"color",
		"colors",
		"offset",
		"color",
		"colors",
		"offset",
		"color",
		"OS",
		"SWT",
		"SWT",
		"OS",
		"hdcMem",
		"numColors",
		"colors",
		"OS",
		"hdcMem",
		"device",
		"hDC",
		"handle",
		"device",
		"device",
		"Device",
		"image",
		"type",
		"image",
		"handle",
		"image",
		"device",
		"image",
		"ERROR_NULL_ARGUMENT",
		"tracking",
		"ERROR_NULL_ARGUMENT",
		"device",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"IMAGE_COPY",
		"type",
		"type",
		"BITMAP",
		"handle",
		"width",
		"height",
		"ERROR_NO_HANDLES",
		"width",
		"height",
		"SRCCOPY",
		"transparentPixel",
		"alpha",
		"alphaData",
		"length",
		"alphaData",
		"alphaData",
		"length",
		"ICON",
		"IsWinCE",
		"data",
		"handle",
		"IMAGE_ICON",
		"width",
		"height",
		"ERROR_NO_HANDLES",
		"ERROR_UNSUPPORTED_FORMAT",
		"tracking",
		"IMAGE_DISABLE",
		"type",
		"type",
		"width",
		"width",
		"width",
		"width",
		"height",
		"height",
		"height",
		"height",
		"ERROR_NO_HANDLES",
		"ERROR_NO_HANDLES",
		"ERROR_NO_HANDLES",
		"DIB_RGB_COLORS",
		"ERROR_NO_HANDLES",
		"BITMAP",
		"handle",
		"width",
		"height",
		"ERROR_NO_HANDLES",
		"width",
		"height",
		"SRCCOPY",
		"left",
		"top",
		"right",
		"width",
		"bottom",
		"height",
		"COLOR_3DFACE",
		"COLOR_3DHILIGHT",
		"width",
		"height",
		"COLOR_3DSHADOW",
		"width",
		"height",
		"ICON",
		"IsWinCE",
		"handle",
		"ERROR_INVALID_IMAGE",
		"hbmColor",
		"hbmMask",
		"hbmColor",
		"width",
		"height",
		"ERROR_NO_HANDLES",
		"width",
		"height",
		"ERROR_NO_HANDLES",
		"hbmColor",
		"hbmMask",
		"hbmMask",
		"width",
		"height",
		"SRCCOPY",
		"hbmColor",
		"hbmMask",
		"width",
		"height",
		"height",
		"SRCCOPY",
		"hbmColor",
		"width",
		"height",
		"SRCCOPY",
		"left",
		"top",
		"right",
		"width",
		"bottom",
		"height",
		"COLOR_3DFACE",
		"COLOR_3DSHADOW",
		"width",
		"height",
		"width",
		"height",
		"NOTSRCCOPY",
		"width",
		"height",
		"fIcon",
		"fIcon",
		"hbmMask",
		"hbmColor",
		"ERROR_NO_HANDLES",
		"hbmColor",
		"hbmColor",
		"hbmMask",
		"ERROR_UNSUPPORTED_FORMAT",
		"tracking",
		"IMAGE_GRAY",
		"palette",
		"isDirect",
		"length",
		"transparentPixel",
		"red",
		"green",
		"blue",
		"red",
		"green",
		"blue",
		"palette",
		"length",
		"width",
		"height",
		"maskData",
		"maskData",
		"maskPad",
		"maskPad",
		"transparentPixel",
		"transparentPixel",
		"width",
		"redMask",
		"greenMask",
		"blueMask",
		"redShift",
		"greenShift",
		"blueShift",
		"height",
		"bytesPerLine",
		"width",
		"width",
		"transparentPixel",
		"transparentPixel",
		"data",
		"data",
		"tracking",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_NULL_ARGUMENT",
		"ERROR_NULL_ARGUMENT",
		"width",
		"height",
		"tracking",
		"ERROR_NULL_ARGUMENT",
		"tracking",
		"ERROR_NULL_ARGUMENT",
		"ERROR_NULL_ARGUMENT",
		"ERROR_NULL_ARGUMENT",
		"width",
		"width",
		"height",
		"height",
		"ERROR_INVALID_ARGUMENT",
		"tracking",
		"ERROR_NULL_ARGUMENT",
		"tracking",
		"ERROR_NULL_ARGUMENT",
		"tracking",
		"BITSPIXEL",
		"PLANES",
		"hPalette",
		"IsWinCE",
		"biSize",
		"sizeof",
		"biWidth",
		"biHeight",
		"biPlanes",
		"biBitCount",
		"biCompression",
		"BI_BITFIELDS",
		"biCompression",
		"BI_RGB",
		"sizeof",
		"sizeof",
		"length",
		"sizeof",
		"sizeof",
		"ERROR_UNSUPPORTED_DEPTH",
		"length",
		"blue",
		"green",
		"red",
		"DIB_RGB_COLORS",
		"ERROR_NO_HANDLES",
		"SRCCOPY",
		"BITMAP",
		"sizeof",
		"bmWidth",
		"bmHeight",
		"ERROR_NO_HANDLES",
		"sizeof",
		"bmWidthBytes",
		"bmHeight",
		"SRCCOPY",
		"bmBitsPixel",
		"bmBitsPixel",
		"bmBits",
		"HEAP_ZERO_MEMORY",
		"length",
		"bmWidthBytes",
		"PixelFormat32bppARGB",
		"ICON",
		"IsWinCE",
		"hbmColor",
		"hbmMask",
		"sizeof",
		"bmWidth",
		"hbmMask",
		"bmHeight",
		"bmHeight",
		"ERROR_NO_HANDLES",
		"sizeof",
		"hbmMask",
		"SRCCOPY",
		"bmWidthBytes",
		"bmHeight",
		"bmBits",
		"length",
		"hbmMask",
		"HEAP_ZERO_MEMORY",
		"length",
		"length",
		"bmWidthBytes",
		"PixelFormat32bppARGB",
		"hbmColor",
		"hbmColor",
		"hbmMask",
		"hbmMask",
		"ERROR_UNSUPPORTED_FORMAT",
		"ICON",
		"IsWinCE",
		"tracking",
		"device",
		"handle",
		"ERROR_GRAPHIC_DISPOSED",
		"sizeof",
		"bmBitsPixel",
		"IsWinCE",
		"bmBits",
		"bmBitsPixel",
		"bmBitsPixel",
		"bmBits",
		"bmBits",
		"bmBitsPixel",
		"ERROR_GRAPHIC_DISPOSED",
		"BITMAP",
		"sizeof",
		"bmWidth",
		"bmHeight",
		"ICON",
		"IsWinCE",
		"width",
		"height",
		"hbmColor",
		"hbmMask",
		"sizeof",
		"hbmMask",
		"bmHeight",
		"hbmColor",
		"hbmColor",
		"hbmMask",
		"hbmMask",
		"bmWidth",
		"bmHeight",
		"ERROR_UNSUPPORTED_FORMAT",
		"ERROR_GRAPHIC_DISPOSED",
		"ICON",
		"IsWinCE",
		"IsWinCE",
		"ERROR_NOT_IMPLEMENTED",
		"hbmColor",
		"hbmMask",
		"sizeof",
		"bmPlanes",
		"bmBitsPixel",
		"bmWidth",
		"hbmMask",
		"bmHeight",
		"bmHeight",
		"biSize",
		"sizeof",
		"biWidth",
		"biHeight",
		"biPlanes",
		"biBitCount",
		"biCompression",
		"BI_RGB",
		"sizeof",
		"sizeof",
		"hPalette",
		"IsWinCE",
		"ERROR_NOT_IMPLEMENTED",
		"DIB_RGB_COLORS",
		"sizeof",
		"biSizeImage",
		"HEAP_ZERO_MEMORY",
		"IsWinCE",
		"ERROR_NOT_IMPLEMENTED",
		"DIB_RGB_COLORS",
		"ERROR_UNSUPPORTED_DEPTH",
		"hbmColor",
		"IsWinCE",
		"ERROR_NOT_IMPLEMENTED",
		"DIB_RGB_COLORS",
		"biSize",
		"sizeof",
		"biWidth",
		"biHeight",
		"biPlanes",
		"biBitCount",
		"biCompression",
		"BI_RGB",
		"sizeof",
		"sizeof",
		"sizeof",
		"hbmMask",
		"IsWinCE",
		"ERROR_NOT_IMPLEMENTED",
		"hbmMask",
		"DIB_RGB_COLORS",
		"sizeof",
		"biSizeImage",
		"HEAP_ZERO_MEMORY",
		"IsWinCE",
		"ERROR_NOT_IMPLEMENTED",
		"hbmMask",
		"DIB_RGB_COLORS",
		"length",
		"hbmColor",
		"hbmColor",
		"hbmMask",
		"hbmMask",
		"maskData",
		"maskPad",
		"BITMAP",
		"sizeof",
		"bmPlanes",
		"bmBitsPixel",
		"bmWidth",
		"bmHeight",
		"bmBits",
		"handle",
		"IsWinCE",
		"data",
		"hNullBitmap",
		"handle",
		"hNullBitmap",
		"hNullBitmap",
		"handle",
		"handle",
		"handle",
		"hNullBitmap",
		"data",
		"sizeof",
		"biClrUsed",
		"biSize",
		"sizeof",
		"biWidth",
		"biHeight",
		"biPlanes",
		"biBitCount",
		"biCompression",
		"BI_RGB",
		"sizeof",
		"sizeof",
		"hPalette",
		"biSizeImage",
		"IsWinCE",
		"ERROR_NOT_IMPLEMENTED",
		"DIB_RGB_COLORS",
		"sizeof",
		"biSizeImage",
		"IsWinCE",
		"handle",
		"bmBits",
		"bmBits",
		"HEAP_ZERO_MEMORY",
		"IsWinCE",
		"ERROR_NOT_IMPLEMENTED",
		"DIB_RGB_COLORS",
		"IsWinCE",
		"bmBits",
		"bmBitsPixel",
		"bmBitsPixel",
		"bmBits",
		"bmBits",
		"length",
		"sizeof",
		"ERROR_UNSUPPORTED_DEPTH",
		"IsWinCE",
		"handle",
		"transparentPixel",
		"transparentPixel",
		"alpha",
		"alphaData",
		"length",
		"alphaData",
		"length",
		"ERROR_UNSUPPORTED_FORMAT",
		"ERROR_INVALID_ARGUMENT",
		"device",
		"BITMAP",
		"BITSPIXEL",
		"PLANES",
		"PATCOPY",
		"ERROR_NO_HANDLES",
		"biSize",
		"sizeof",
		"biWidth",
		"biHeight",
		"biPlanes",
		"biBitCount",
		"IsWinCE",
		"biCompression",
		"BI_BITFIELDS",
		"biCompression",
		"BI_RGB",
		"sizeof",
		"IsWinCE",
		"sizeof",
		"IsWinCE",
		"sizeof",
		"DIB_RGB_COLORS",
		"device",
		"data",
		"hbmColor",
		"hbmMask",
		"device",
		"IsWin95",
		"depth",
		"TRANSPARENCY_MASK",
		"depth",
		"width",
		"height",
		"palette",
		"BLIT_SRC",
		"data",
		"depth",
		"bytesPerLine",
		"width",
		"height",
		"ALPHA_OPAQUE",
		"data",
		"depth",
		"bytesPerLine",
		"width",
		"height",
		"transparentPixel",
		"transparentPixel",
		"maskPad",
		"maskPad",
		"maskData",
		"maskData",
		"alpha",
		"alpha",
		"alphaData",
		"alphaData",
		"isDirect",
		"palette",
		"palette",
		"redMask",
		"greenMask",
		"blueMask",
		"depth",
		"MSB_FIRST",
		"depth",
		"LSB_FIRST",
		"LSB_FIRST",
		"ERROR_UNSUPPORTED_DEPTH",
		"width",
		"height",
		"BLIT_SRC",
		"data",
		"depth",
		"bytesPerLine",
		"width",
		"height",
		"ALPHA_OPAQUE",
		"data",
		"depth",
		"bytesPerLine",
		"width",
		"height",
		"redMask",
		"greenMask",
		"blueMask",
		"transparentPixel",
		"transparentPixel",
		"transparentPixel",
		"maskPad",
		"maskPad",
		"maskData",
		"maskData",
		"alpha",
		"alpha",
		"alphaData",
		"alphaData",
		"palette",
		"IsWinCE",
		"depth",
		"depth",
		"biSize",
		"sizeof",
		"biWidth",
		"width",
		"biHeight",
		"height",
		"biPlanes",
		"biBitCount",
		"depth",
		"biCompression",
		"BI_BITFIELDS",
		"biCompression",
		"BI_RGB",
		"biClrUsed",
		"length",
		"isDirect",
		"palette",
		"sizeof",
		"sizeof",
		"length",
		"sizeof",
		"sizeof",
		"isDirect",
		"palette",
		"palette",
		"redMask",
		"greenMask",
		"blueMask",
		"LSB_FIRST",
		"length",
		"blue",
		"green",
		"red",
		"DIB_RGB_COLORS",
		"ERROR_NO_HANDLES",
		"data",
		"scanlinePad",
		"bytesPerLine",
		"width",
		"height",
		"depth",
		"scanlinePad",
		"length",
		"TRANSPARENCY_MASK",
		"width",
		"height",
		"ERROR_NO_HANDLES",
		"width",
		"height",
		"SRCCOPY",
		"maskData",
		"width",
		"height",
		"maskPad",
		"width",
		"height",
		"ERROR_NO_HANDLES",
		"width",
		"height",
		"DSTINVERT",
		"fIcon",
		"hbmColor",
		"hbmMask",
		"ERROR_NO_HANDLES",
		"handle",
		"type",
		"ICON",
		"IsWinCE",
		"data",
		"handle",
		"type",
		"BITMAP",
		"transparentPixel",
		"transparentPixel",
		"transparentPixel",
		"alpha",
		"alpha",
		"alpha",
		"alphaData",
		"length",
		"alphaData",
		"alphaData",
		"alphaData",
		"alphaData",
		"isDirect",
		"palette",
		"width",
		"height",
		"depth",
		"palette",
		"transparentPixel",
		"length",
		"length",
		"transparentPixel",
		"length",
		"transparentPixel",
		"length",
		"length",
		"transparentPixel",
		"transparentPixel",
		"transparentPixel",
		"width",
		"height",
		"depth",
		"length",
		"length",
		"depth",
		"length",
		"length",
		"length",
		"length",
		"width",
		"height",
		"depth",
		"data",
		"data",
		"length",
		"data",
		"width",
		"width",
		"height",
		"width",
		"width",
		"length",
		"width",
		"maskPad",
		"scanlinePad",
		"maskData",
		"data",
		"ERROR_NULL_ARGUMENT",
		"ERROR_GRAPHIC_DISPOSED",
		"BITMAP",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_NO_HANDLES",
		"LEFT_TO_RIGHT",
		"RIGHT_TO_LEFT",
		"style",
		"layout",
		"style",
		"RIGHT_TO_LEFT",
		"LAYOUT_RTL",
		"style",
		"LEFT_TO_RIGHT",
		"device",
		"image",
		"hFont",
		"systemFont",
		"IsWinCE",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"sizeof",
		"bmBitsPixel",
		"IsWinCE",
		"ERROR_NOT_IMPLEMENTED",
		"IsWinCE",
		"ERROR_NOT_IMPLEMENTED",
		"type",
		"handle",
		"device",
		"device",
		"width",
		"height",
		"device",
		"srcImage",
		"flag",
		"device",
		"bounds",
		"device",
		"data",
		"device",
		"source",
		"mask",
		"device",
		"stream",
		"device",
		"filename",
		"hDC",
		"hBitmap",
		"width",
		"height",
		"object",
		"device",
		"width",
		"height",
		"width",
		"height",
		"depth",
		"image",
		"info",
		"device",
		"image",
		"i",
		"device",
		"image",
		"source",
		"mask",
		"device",
		"i",
		"data",
		"hDC",
		"data",
		"color",
		"device",
		"type",
		"handle"
	],
	"extendORImplementFiles":[
		"Resource",
		"Drawable"
	],
	"package":[
		"org.eclipse.swt.graphics"
	],
	"import":[
		"org.eclipse.swt.internal.gdip",
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt",
		"java.io"
	],
	"methods":[
		"createDIBFromDDB",
		"createGdipImage",
		"dispose",
		"equals",
		"getBackground",
		"getBounds",
		"getImageData",
		"hashCode",
		"init",
		"createDIB",
		"GetIconInfo",
		"init",
		"init",
		"init",
		"internal_new_GC",
		"internal_dispose_GC",
		"isDisposed",
		"setBackground",
		"toString",
		"win32_new",
		"getDevice",
		"error",
		"init",
		"new_Object",
		"getDevice",
		"error",
		"error",
		"isDisposed",
		"error",
		"getBounds",
		"internal_new_GC",
		"CreateCompatibleDC",
		"CreateCompatibleDC",
		"SelectObject",
		"CreateCompatibleBitmap",
		"error",
		"SelectObject",
		"BitBlt",
		"SelectObject",
		"SelectObject",
		"DeleteDC",
		"DeleteDC",
		"internal_dispose_GC",
		"arraycopy",
		"init",
		"CopyImage",
		"error",
		"error",
		"new_Object",
		"getBounds",
		"internal_new_GC",
		"CreateCompatibleDC",
		"error",
		"CreateCompatibleDC",
		"error",
		"CreateCompatibleDC",
		"error",
		"CreateDIBSection",
		"error",
		"SelectObject",
		"CreateCompatibleBitmap",
		"error",
		"SelectObject",
		"SelectObject",
		"BitBlt",
		"FillRect",
		"GetSysColorBrush",
		"CreateSolidBrush",
		"GetSysColor",
		"SelectObject",
		"BitBlt",
		"CreateSolidBrush",
		"GetSysColor",
		"DeleteObject",
		"SelectObject",
		"BitBlt",
		"DeleteObject",
		"SelectObject",
		"SelectObject",
		"SelectObject",
		"SelectObject",
		"DeleteDC",
		"DeleteDC",
		"DeleteDC",
		"DeleteObject",
		"internal_dispose_GC",
		"GetIconInfo",
		"GetIconInfo",
		"error",
		"CreateCompatibleDC",
		"SelectObject",
		"SelectObject",
		"CreateCompatibleBitmap",
		"error",
		"CreateBitmap",
		"error",
		"SelectObject",
		"SelectObject",
		"SelectObject",
		"BitBlt",
		"SelectObject",
		"SelectObject",
		"BitBlt",
		"SelectObject",
		"BitBlt",
		"SelectObject",
		"FillRect",
		"GetSysColorBrush",
		"CreateSolidBrush",
		"GetSysColor",
		"SelectObject",
		"BitBlt",
		"BitBlt",
		"CreateSolidBrush",
		"DeleteObject",
		"SelectObject",
		"BitBlt",
		"DeleteObject",
		"SelectObject",
		"SelectObject",
		"DeleteDC",
		"SelectObject",
		"DeleteDC",
		"SelectObject",
		"DeleteDC",
		"SelectObject",
		"DeleteDC",
		"DeleteObject",
		"internal_dispose_GC",
		"CreateIconIndirect",
		"error",
		"DeleteObject",
		"DeleteObject",
		"DeleteObject",
		"DeleteObject",
		"error",
		"new_Object",
		"getBounds",
		"getImageData",
		"getRGBs",
		"getPixels",
		"init",
		"new_Object",
		"error",
		"getDevice",
		"error",
		"error",
		"init",
		"new_Object",
		"getDevice",
		"error",
		"init",
		"new_Object",
		"getDevice",
		"error",
		"error",
		"error",
		"error",
		"convertMask",
		"init",
		"new_Object",
		"getDevice",
		"error",
		"init",
		"new_Object",
		"getDevice",
		"error",
		"init",
		"new_Object",
		"GetDeviceCaps",
		"GetDeviceCaps",
		"GetPaletteEntries",
		"MoveMemory",
		"error",
		"CreateDIBSection",
		"error",
		"CreateCompatibleDC",
		"CreateCompatibleDC",
		"SelectObject",
		"SelectObject",
		"BitBlt",
		"SelectObject",
		"SelectObject",
		"DeleteDC",
		"DeleteDC",
		"GetObject",
		"internal_new_GC",
		"CreateCompatibleDC",
		"SelectObject",
		"CreateCompatibleDC",
		"createDIB",
		"error",
		"SelectObject",
		"GetObject",
		"BitBlt",
		"GetDIBColorTable",
		"SelectObject",
		"SelectObject",
		"DeleteObject",
		"DeleteObject",
		"MoveMemory",
		"DeleteObject",
		"internal_dispose_GC",
		"GetProcessHeap",
		"HeapAlloc",
		"MoveMemory",
		"Bitmap_new",
		"Bitmap_new",
		"GetIconInfo",
		"GetIconInfo",
		"GetObject",
		"internal_new_GC",
		"CreateCompatibleDC",
		"SelectObject",
		"CreateCompatibleDC",
		"createDIB",
		"error",
		"SelectObject",
		"GetObject",
		"BitBlt",
		"SelectObject",
		"DeleteObject",
		"MoveMemory",
		"DeleteObject",
		"SelectObject",
		"GetPixel",
		"SelectObject",
		"DeleteObject",
		"internal_dispose_GC",
		"GetProcessHeap",
		"HeapAlloc",
		"MoveMemory",
		"Bitmap_new",
		"Bitmap_new",
		"DeleteObject",
		"DeleteObject",
		"error",
		"isDisposed",
		"dispose",
		"DestroyIcon",
		"DeleteObject",
		"dispose_Object",
		"isDisposed",
		"error",
		"internal_new_GC",
		"GetObject",
		"CreateCompatibleDC",
		"SelectObject",
		"MoveMemory",
		"MoveMemory",
		"GetPixel",
		"MoveMemory",
		"GetDIBColorTable",
		"SelectObject",
		"DeleteDC",
		"internal_dispose_GC",
		"win32_new",
		"isDisposed",
		"error",
		"GetObject",
		"GetIconInfo",
		"GetObject",
		"DeleteObject",
		"DeleteObject",
		"error",
		"isDisposed",
		"error",
		"error",
		"GetIconInfo",
		"GetObject",
		"MoveMemory",
		"internal_new_GC",
		"CreateCompatibleDC",
		"SelectObject",
		"SelectPalette",
		"RealizePalette",
		"error",
		"GetDIBits",
		"MoveMemory",
		"GetProcessHeap",
		"HeapAlloc",
		"error",
		"GetDIBits",
		"MoveMemory",
		"error",
		"error",
		"GetDIBits",
		"MoveMemory",
		"MoveMemory",
		"SelectObject",
		"error",
		"GetDIBits",
		"MoveMemory",
		"HeapAlloc",
		"error",
		"GetDIBits",
		"MoveMemory",
		"HeapFree",
		"convertPad",
		"HeapFree",
		"SelectObject",
		"SelectPalette",
		"RealizePalette",
		"DeleteDC",
		"internal_dispose_GC",
		"DeleteObject",
		"DeleteObject",
		"GetObject",
		"internal_new_GC",
		"isDisposed",
		"flush",
		"SelectObject",
		"createDIBFromDDB",
		"SelectObject",
		"GetObject",
		"MoveMemory",
		"CreateCompatibleDC",
		"SelectObject",
		"SelectPalette",
		"RealizePalette",
		"error",
		"GetDIBits",
		"MoveMemory",
		"MoveMemory",
		"MoveMemory",
		"GetProcessHeap",
		"HeapAlloc",
		"error",
		"GetDIBits",
		"MoveMemory",
		"HeapFree",
		"MoveMemory",
		"MoveMemory",
		"GetPixel",
		"MoveMemory",
		"GetDIBColorTable",
		"error",
		"SelectObject",
		"SelectPalette",
		"RealizePalette",
		"DeleteObject",
		"DeleteDC",
		"internal_dispose_GC",
		"arraycopy",
		"error",
		"error",
		"internal_new_GC",
		"CreateCompatibleBitmap",
		"GetDeviceCaps",
		"GetDeviceCaps",
		"createDIB",
		"CreateCompatibleDC",
		"SelectObject",
		"PatBlt",
		"SelectObject",
		"DeleteDC",
		"internal_dispose_GC",
		"error",
		"getLastError",
		"MoveMemory",
		"CreateDIBSection",
		"init",
		"getTransparencyType",
		"blit",
		"getByteOrder",
		"getByteOrder",
		"error",
		"blit",
		"getByteOrder",
		"getPixel",
		"getRGB",
		"getRGBs",
		"MoveMemory",
		"getByteOrder",
		"CreateDIBSection",
		"error",
		"convertPad",
		"MoveMemory",
		"getTransparencyType",
		"internal_new_GC",
		"CreateCompatibleDC",
		"SelectObject",
		"CreateCompatibleBitmap",
		"error",
		"CreateCompatibleDC",
		"SelectObject",
		"BitBlt",
		"internal_dispose_GC",
		"convertPad",
		"CreateBitmap",
		"error",
		"SelectObject",
		"PatBlt",
		"DeleteDC",
		"DeleteDC",
		"DeleteObject",
		"CreateIconIndirect",
		"error",
		"DeleteObject",
		"DeleteObject",
		"arraycopy",
		"getRGBs",
		"arraycopy",
		"arraycopy",
		"equals",
		"arraycopy",
		"arraycopy",
		"getPixels",
		"getPixels",
		"setPixels",
		"init",
		"error",
		"init",
		"error",
		"error",
		"internal_new_GC",
		"CreateCompatibleDC",
		"internal_dispose_GC",
		"error",
		"DeleteDC",
		"isDisposed",
		"error",
		"error",
		"isDisposed",
		"error",
		"internal_new_GC",
		"GetObject",
		"CreateCompatibleDC",
		"SelectObject",
		"error",
		"GetDIBColorTable",
		"getBlue",
		"getGreen",
		"getRed",
		"error",
		"SetDIBColorTable",
		"DeleteDC",
		"internal_dispose_GC",
		"isDisposed",
		"getDevice",
		"RECT",
		"ICONINFO",
		"RECT",
		"ICONINFO",
		"PaletteData",
		"RGB",
		"ImageData",
		"PaletteData",
		"ImageData",
		"ImageData",
		"RGB",
		"BITMAPINFOHEADER",
		"BITMAP",
		"BITMAP",
		"ICONINFO",
		"BITMAP",
		"BITMAP",
		"BITMAP",
		"BITMAP",
		"Rectangle",
		"Rectangle",
		"ICONINFO",
		"BITMAP",
		"Rectangle",
		"ICONINFO",
		"BITMAP",
		"BITMAPINFOHEADER",
		"RGB",
		"PaletteData",
		"PaletteData",
		"PaletteData",
		"PaletteData",
		"BITMAPINFOHEADER",
		"ImageData",
		"BITMAP",
		"DIBSECTION",
		"BITMAPINFOHEADER",
		"RGB",
		"RGB",
		"RGB",
		"PaletteData",
		"PaletteData",
		"PaletteData",
		"PaletteData",
		"ImageData",
		"BITMAPINFOHEADER",
		"ImageData",
		"PaletteData",
		"PaletteData",
		"PaletteData",
		"PaletteData",
		"ImageData",
		"BITMAPINFOHEADER",
		"ICONINFO",
		"ImageData",
		"RGB",
		"RGB",
		"ImageData",
		"PaletteData",
		"ImageData",
		"PaletteData",
		"BITMAP",
		"Image"
	],
	"methodsBody":{
		"public void dispose()":{
			"methodBody":"{\n    if (handle == 0)\n        return;\n    if (device.isDisposed())\n        return;\n    if (memGC != null)\n        memGC.dispose();\n    if (type == SWT.ICON) {\n        if (OS.IsWinCE)\n            data = null;\n        OS.DestroyIcon(handle);\n    } else {\n        OS.DeleteObject(handle);\n    }\n    handle = 0;\n    memGC = null;\n    if (device.tracking)\n        device.dispose_Object(this);\n    device = null;\n}",
			"comments":"/**\n* Disposes of the operating system resources associated with\n* the image. Applications must dispose of all images which\n* they allocate.\n*/\n",
			"methodName":"public void dispose()"
		},
		"static int createDIB(int width, int height, int depth)":{
			"methodBody":"{\n    BITMAPINFOHEADER bmiHeader = new BITMAPINFOHEADER();\n    bmiHeader.biSize = BITMAPINFOHEADER.sizeof;\n    bmiHeader.biWidth = width;\n    bmiHeader.biHeight = -height;\n    bmiHeader.biPlanes = 1;\n    bmiHeader.biBitCount = (short) depth;\n    if (OS.IsWinCE)\n        bmiHeader.biCompression = OS.BI_BITFIELDS;\n    else\n        bmiHeader.biCompression = OS.BI_RGB;\n    byte[] bmi = new byte[BITMAPINFOHEADER.sizeof + (OS.IsWinCE ? 12 : 0)];\n    OS.MoveMemory(bmi, bmiHeader, BITMAPINFOHEADER.sizeof);\n    \n    if (OS.IsWinCE) {\n        int redMask = 0xFF00;\n        int greenMask = 0xFF0000;\n        int blueMask = 0xFF000000;\n        \n        int offset = BITMAPINFOHEADER.sizeof;\n        bmi[offset] = (byte) ((redMask & 0xFF000000) >> 24);\n        bmi[offset + 1] = (byte) ((redMask & 0xFF0000) >> 16);\n        bmi[offset + 2] = (byte) ((redMask & 0xFF00) >> 8);\n        bmi[offset + 3] = (byte) ((redMask & 0xFF) >> 0);\n        bmi[offset + 4] = (byte) ((greenMask & 0xFF000000) >> 24);\n        bmi[offset + 5] = (byte) ((greenMask & 0xFF0000) >> 16);\n        bmi[offset + 6] = (byte) ((greenMask & 0xFF00) >> 8);\n        bmi[offset + 7] = (byte) ((greenMask & 0xFF) >> 0);\n        bmi[offset + 8] = (byte) ((blueMask & 0xFF000000) >> 24);\n        bmi[offset + 9] = (byte) ((blueMask & 0xFF0000) >> 16);\n        bmi[offset + 10] = (byte) ((blueMask & 0xFF00) >> 8);\n        bmi[offset + 11] = (byte) ((blueMask & 0xFF) >> 0);\n    }\n    int[] pBits = new int[1];\n    return OS.CreateDIBSection(0, bmi, OS.DIB_RGB_COLORS, pBits, 0, 0);\n}",
			"comments":"/* Set the rgb colors into the bitmap info */\n/* big endian */\n",
			"methodName":"static int createDIB(int width, int height, int depth)"
		},
		"int createDIBFromDDB(int hDC, int hBitmap, int width, int height)":{
			"methodBody":"{\n    \n    int bits = OS.GetDeviceCaps(hDC, OS.BITSPIXEL);\n    int planes = OS.GetDeviceCaps(hDC, OS.PLANES);\n    int depth = bits * planes;\n    \n    boolean isDirect = depth > 8;\n    RGB[] rgbs = null;\n    if (!isDirect) {\n        int numColors = 1 << depth;\n        byte[] logPalette = new byte[4 * numColors];\n        OS.GetPaletteEntries(device.hPalette, 0, numColors, logPalette);\n        rgbs = new RGB[numColors];\n        for (int i = 0; i < numColors; i++) {\n            rgbs[i] = new RGB(logPalette[i] & 0xFF, logPalette[i + 1] & 0xFF, logPalette[i + 2] & 0xFF);\n        }\n    }\n    boolean useBitfields = OS.IsWinCE && (depth == 16 || depth == 32);\n    BITMAPINFOHEADER bmiHeader = new BITMAPINFOHEADER();\n    bmiHeader.biSize = BITMAPINFOHEADER.sizeof;\n    bmiHeader.biWidth = width;\n    bmiHeader.biHeight = -height;\n    bmiHeader.biPlanes = 1;\n    bmiHeader.biBitCount = (short) depth;\n    if (useBitfields)\n        bmiHeader.biCompression = OS.BI_BITFIELDS;\n    else\n        bmiHeader.biCompression = OS.BI_RGB;\n    byte[] bmi;\n    if (isDirect)\n        bmi = new byte[BITMAPINFOHEADER.sizeof + (useBitfields ? 12 : 0)];\n    else\n        bmi = new byte[BITMAPINFOHEADER.sizeof + rgbs.length * 4];\n    OS.MoveMemory(bmi, bmiHeader, BITMAPINFOHEADER.sizeof);\n    \n    int offset = BITMAPINFOHEADER.sizeof;\n    if (isDirect) {\n        if (useBitfields) {\n            int redMask = 0;\n            int greenMask = 0;\n            int blueMask = 0;\n            switch(depth) {\n                case 16:\n                    redMask = 0x7C00;\n                    greenMask = 0x3E0;\n                    blueMask = 0x1F;\n                    \n                    bmi[offset] = (byte) ((redMask & 0xFF) >> 0);\n                    bmi[offset + 1] = (byte) ((redMask & 0xFF00) >> 8);\n                    bmi[offset + 2] = (byte) ((redMask & 0xFF0000) >> 16);\n                    bmi[offset + 3] = (byte) ((redMask & 0xFF000000) >> 24);\n                    bmi[offset + 4] = (byte) ((greenMask & 0xFF) >> 0);\n                    bmi[offset + 5] = (byte) ((greenMask & 0xFF00) >> 8);\n                    bmi[offset + 6] = (byte) ((greenMask & 0xFF0000) >> 16);\n                    bmi[offset + 7] = (byte) ((greenMask & 0xFF000000) >> 24);\n                    bmi[offset + 8] = (byte) ((blueMask & 0xFF) >> 0);\n                    bmi[offset + 9] = (byte) ((blueMask & 0xFF00) >> 8);\n                    bmi[offset + 10] = (byte) ((blueMask & 0xFF0000) >> 16);\n                    bmi[offset + 11] = (byte) ((blueMask & 0xFF000000) >> 24);\n                    break;\n                case 32:\n                    redMask = 0xFF00;\n                    greenMask = 0xFF0000;\n                    blueMask = 0xFF000000;\n                    \n                    bmi[offset] = (byte) ((redMask & 0xFF000000) >> 24);\n                    bmi[offset + 1] = (byte) ((redMask & 0xFF0000) >> 16);\n                    bmi[offset + 2] = (byte) ((redMask & 0xFF00) >> 8);\n                    bmi[offset + 3] = (byte) ((redMask & 0xFF) >> 0);\n                    bmi[offset + 4] = (byte) ((greenMask & 0xFF000000) >> 24);\n                    bmi[offset + 5] = (byte) ((greenMask & 0xFF0000) >> 16);\n                    bmi[offset + 6] = (byte) ((greenMask & 0xFF00) >> 8);\n                    bmi[offset + 7] = (byte) ((greenMask & 0xFF) >> 0);\n                    bmi[offset + 8] = (byte) ((blueMask & 0xFF000000) >> 24);\n                    bmi[offset + 9] = (byte) ((blueMask & 0xFF0000) >> 16);\n                    bmi[offset + 10] = (byte) ((blueMask & 0xFF00) >> 8);\n                    bmi[offset + 11] = (byte) ((blueMask & 0xFF) >> 0);\n                    break;\n                default:\n                    SWT.error(SWT.ERROR_UNSUPPORTED_DEPTH);\n            }\n        }\n    } else {\n        for (int j = 0; j < rgbs.length; j++) {\n            bmi[offset] = (byte) rgbs[j].blue;\n            bmi[offset + 1] = (byte) rgbs[j].green;\n            bmi[offset + 2] = (byte) rgbs[j].red;\n            bmi[offset + 3] = 0;\n            offset += 4;\n        }\n    }\n    int[] pBits = new int[1];\n    int hDib = OS.CreateDIBSection(0, bmi, OS.DIB_RGB_COLORS, pBits, 0, 0);\n    if (hDib == 0)\n        SWT.error(SWT.ERROR_NO_HANDLES);\n    \n    int hdcSource = OS.CreateCompatibleDC(hDC);\n    int hdcDest = OS.CreateCompatibleDC(hDC);\n    int hOldSrc = OS.SelectObject(hdcSource, hBitmap);\n    int hOldDest = OS.SelectObject(hdcDest, hDib);\n    OS.BitBlt(hdcDest, 0, 0, width, height, hdcSource, 0, 0, OS.SRCCOPY);\n    OS.SelectObject(hdcSource, hOldSrc);\n    OS.SelectObject(hdcDest, hOldDest);\n    OS.DeleteDC(hdcSource);\n    OS.DeleteDC(hdcDest);\n    return hDib;\n}",
			"comments":"/**\n* Create a DIB from a DDB without using GetDIBits. Note that\n* the DDB should not be selected into a HDC.\n*/\n/* Determine the DDB depth */\n/* Determine the DIB palette */\n/* Set the rgb colors into the bitmap info */\n/* little endian */\n/* big endian */\n/* Bitblt DDB into DIB */\n",
			"methodName":"int createDIBFromDDB(int hDC, int hBitmap, int width, int height)"
		},
		"public Rectangle getBounds()":{
			"methodBody":"{\n    if (isDisposed())\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    switch(type) {\n        case SWT.BITMAP:\n            BITMAP bm = new BITMAP();\n            OS.GetObject(handle, BITMAP.sizeof, bm);\n            return new Rectangle(0, 0, bm.bmWidth, bm.bmHeight);\n        case SWT.ICON:\n            if (OS.IsWinCE) {\n                return new Rectangle(0, 0, data.width, data.height);\n            } else {\n                ICONINFO info = new ICONINFO();\n                OS.GetIconInfo(handle, info);\n                int hBitmap = info.hbmColor;\n                if (hBitmap == 0)\n                    hBitmap = info.hbmMask;\n                bm = new BITMAP();\n                OS.GetObject(hBitmap, BITMAP.sizeof, bm);\n                if (hBitmap == info.hbmMask)\n                    bm.bmHeight /= 2;\n                if (info.hbmColor != 0)\n                    OS.DeleteObject(info.hbmColor);\n                if (info.hbmMask != 0)\n                    OS.DeleteObject(info.hbmMask);\n                return new Rectangle(0, 0, bm.bmWidth, bm.bmHeight);\n            }\n        default:\n            SWT.error(SWT.ERROR_UNSUPPORTED_FORMAT);\n            return null;\n    }\n}",
			"comments":"/**\n* Returns the bounds of the receiver. The rectangle will always\n* have x and y values of 0, and the width and height of the\n* image.\n*\n* @return a rectangle specifying the image's bounds\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_INVALID_IMAGE - if the image is not a bitmap or an icon</li>\n* </ul>\n*/\n",
			"methodName":"public Rectangle getBounds()"
		},
		"static int[] init(Device device, Image image, ImageData source, ImageData mask)":{
			"methodBody":"{\n    \n    ImageData imageData;\n    int blackIndex = 0;\n    if (source.palette.isDirect) {\n        imageData = new ImageData(source.width, source.height, source.depth, source.palette);\n    } else {\n        RGB black = new RGB(0, 0, 0);\n        RGB[] rgbs = source.getRGBs();\n        if (source.transparentPixel != -1) {\n            \n            RGB[] newRGBs = new RGB[rgbs.length];\n            System.arraycopy(rgbs, 0, newRGBs, 0, rgbs.length);\n            if (source.transparentPixel >= newRGBs.length) {\n                \n                rgbs = new RGB[source.transparentPixel + 1];\n                System.arraycopy(newRGBs, 0, rgbs, 0, newRGBs.length);\n                for (int i = newRGBs.length; i <= source.transparentPixel; i++) {\n                    rgbs[i] = new RGB(0, 0, 0);\n                }\n            } else {\n                newRGBs[source.transparentPixel] = black;\n                rgbs = newRGBs;\n            }\n            blackIndex = source.transparentPixel;\n            imageData = new ImageData(source.width, source.height, source.depth, new PaletteData(rgbs));\n        } else {\n            while (blackIndex < rgbs.length) {\n                if (rgbs[blackIndex].equals(black))\n                    break;\n                blackIndex++;\n            }\n            if (blackIndex == rgbs.length) {\n                \n                if ((1 << source.depth) > rgbs.length) {\n                    \n                    RGB[] newRGBs = new RGB[rgbs.length + 1];\n                    System.arraycopy(rgbs, 0, newRGBs, 0, rgbs.length);\n                    newRGBs[rgbs.length] = black;\n                    rgbs = newRGBs;\n                } else {\n                    \n                    blackIndex = -1;\n                }\n            }\n            imageData = new ImageData(source.width, source.height, source.depth, new PaletteData(rgbs));\n        }\n    }\n    if (blackIndex == -1) {\n        \n        System.arraycopy(source.data, 0, imageData.data, 0, imageData.data.length);\n    } else {\n        \n        int[] imagePixels = new int[imageData.width];\n        int[] maskPixels = new int[mask.width];\n        for (int y = 0; y < imageData.height; y++) {\n            source.getPixels(0, y, imageData.width, imagePixels, 0);\n            mask.getPixels(0, y, mask.width, maskPixels, 0);\n            for (int i = 0; i < imagePixels.length; i++) {\n                if (maskPixels[i] == 0)\n                    imagePixels[i] = blackIndex;\n            }\n            imageData.setPixels(0, y, source.width, imagePixels, 0);\n        }\n    }\n    imageData.maskPad = mask.scanlinePad;\n    imageData.maskData = mask.data;\n    return init(device, image, imageData);\n}",
			"comments":"/* Create a temporary image and locate the black pixel */\n/*\n* The source had transparency, so we can use the transparent pixel\n* for black.\n*/\n/* Grow the palette with black */\n/*\n* We didn't find black in the palette, and there is no transparent\n* pixel we can use.\n*/\n/* We can grow the palette and add black */\n/* No room to grow the palette */\n/* There was no black in the palette, so just copy the data over */\n/* Modify the source image to contain black wherever the mask is 0 */\n",
			"methodName":"static int[] init(Device device, Image image, ImageData source, ImageData mask)"
		},
		"public ImageData getImageData()":{
			"methodBody":"{\n    if (isDisposed())\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    BITMAP bm;\n    int depth, width, height;\n    switch(type) {\n        case SWT.ICON:\n            {\n                if (OS.IsWinCE)\n                    return data;\n                ICONINFO info = new ICONINFO();\n                if (OS.IsWinCE)\n                    SWT.error(SWT.ERROR_NOT_IMPLEMENTED);\n                OS.GetIconInfo(handle, info);\n                \n                int hBitmap = info.hbmColor;\n                if (hBitmap == 0)\n                    hBitmap = info.hbmMask;\n                bm = new BITMAP();\n                OS.GetObject(hBitmap, BITMAP.sizeof, bm);\n                depth = bm.bmPlanes * bm.bmBitsPixel;\n                width = bm.bmWidth;\n                if (hBitmap == info.hbmMask)\n                    bm.bmHeight /= 2;\n                height = bm.bmHeight;\n                int numColors = 0;\n                if (depth <= 8)\n                    numColors = 1 << depth;\n                \n                BITMAPINFOHEADER bmiHeader = new BITMAPINFOHEADER();\n                bmiHeader.biSize = BITMAPINFOHEADER.sizeof;\n                bmiHeader.biWidth = width;\n                bmiHeader.biHeight = -height;\n                bmiHeader.biPlanes = 1;\n                bmiHeader.biBitCount = (short) depth;\n                bmiHeader.biCompression = OS.BI_RGB;\n                byte[] bmi = new byte[BITMAPINFOHEADER.sizeof + numColors * 4];\n                OS.MoveMemory(bmi, bmiHeader, BITMAPINFOHEADER.sizeof);\n                \n                int hDC = device.internal_new_GC(null);\n                \n                int hBitmapDC = OS.CreateCompatibleDC(hDC);\n                int hOldBitmap = OS.SelectObject(hBitmapDC, hBitmap);\n                \n                int oldPalette = 0;\n                if (depth <= 8) {\n                    int hPalette = device.hPalette;\n                    if (hPalette != 0) {\n                        oldPalette = OS.SelectPalette(hBitmapDC, hPalette, false);\n                        OS.RealizePalette(hBitmapDC);\n                    }\n                }\n                \n                int imageSize;\n                \n                if (OS.IsWinCE)\n                    SWT.error(SWT.ERROR_NOT_IMPLEMENTED);\n                OS.GetDIBits(hBitmapDC, hBitmap, 0, height, 0, bmi, OS.DIB_RGB_COLORS);\n                OS.MoveMemory(bmiHeader, bmi, BITMAPINFOHEADER.sizeof);\n                imageSize = bmiHeader.biSizeImage;\n                byte[] data = new byte[imageSize];\n                \n                int hHeap = OS.GetProcessHeap();\n                int lpvBits = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, imageSize);\n                if (OS.IsWinCE)\n                    SWT.error(SWT.ERROR_NOT_IMPLEMENTED);\n                OS.GetDIBits(hBitmapDC, hBitmap, 0, height, lpvBits, bmi, OS.DIB_RGB_COLORS);\n                OS.MoveMemory(data, lpvBits, imageSize);\n                \n                PaletteData palette = null;\n                if (depth <= 8) {\n                    RGB[] rgbs = new RGB[numColors];\n                    int srcIndex = 40;\n                    for (int i = 0; i < numColors; i++) {\n                        rgbs[i] = new RGB(bmi[srcIndex + 2] & 0xFF, bmi[srcIndex + 1] & 0xFF, bmi[srcIndex] & 0xFF);\n                        srcIndex += 4;\n                    }\n                    palette = new PaletteData(rgbs);\n                } else if (depth == 16) {\n                    palette = new PaletteData(0x7C00, 0x3E0, 0x1F);\n                } else if (depth == 24) {\n                    palette = new PaletteData(0xFF, 0xFF00, 0xFF0000);\n                } else if (depth == 32) {\n                    palette = new PaletteData(0xFF00, 0xFF0000, 0xFF000000);\n                } else {\n                    SWT.error(SWT.ERROR_UNSUPPORTED_DEPTH);\n                }\n                \n                byte[] maskData = null;\n                if (info.hbmColor == 0) {\n                    \n                    maskData = new byte[imageSize];\n                    if (OS.IsWinCE)\n                        SWT.error(SWT.ERROR_NOT_IMPLEMENTED);\n                    OS.GetDIBits(hBitmapDC, hBitmap, height, height, lpvBits, bmi, OS.DIB_RGB_COLORS);\n                    OS.MoveMemory(maskData, lpvBits, imageSize);\n                } else {\n                    \n                    \n                    bmiHeader = new BITMAPINFOHEADER();\n                    bmiHeader.biSize = BITMAPINFOHEADER.sizeof;\n                    bmiHeader.biWidth = width;\n                    bmiHeader.biHeight = -height;\n                    bmiHeader.biPlanes = 1;\n                    bmiHeader.biBitCount = 1;\n                    bmiHeader.biCompression = OS.BI_RGB;\n                    bmi = new byte[BITMAPINFOHEADER.sizeof + 8];\n                    OS.MoveMemory(bmi, bmiHeader, BITMAPINFOHEADER.sizeof);\n                    \n                    int offset = BITMAPINFOHEADER.sizeof;\n                    bmi[offset + 4] = bmi[offset + 5] = bmi[offset + 6] = (byte) 0xFF;\n                    bmi[offset + 7] = 0;\n                    OS.SelectObject(hBitmapDC, info.hbmMask);\n                    \n                    if (OS.IsWinCE)\n                        SWT.error(SWT.ERROR_NOT_IMPLEMENTED);\n                    OS.GetDIBits(hBitmapDC, info.hbmMask, 0, height, 0, bmi, OS.DIB_RGB_COLORS);\n                    OS.MoveMemory(bmiHeader, bmi, BITMAPINFOHEADER.sizeof);\n                    imageSize = bmiHeader.biSizeImage;\n                    maskData = new byte[imageSize];\n                    int lpvMaskBits = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, imageSize);\n                    if (OS.IsWinCE)\n                        SWT.error(SWT.ERROR_NOT_IMPLEMENTED);\n                    OS.GetDIBits(hBitmapDC, info.hbmMask, 0, height, lpvMaskBits, bmi, OS.DIB_RGB_COLORS);\n                    OS.MoveMemory(maskData, lpvMaskBits, imageSize);\n                    OS.HeapFree(hHeap, 0, lpvMaskBits);\n                    \n                    for (int i = 0; i < maskData.length; i++) {\n                        maskData[i] ^= -1;\n                    }\n                    \n                    int maskPad;\n                    int bpl = imageSize / height;\n                    for (maskPad = 1; maskPad < 128; maskPad++) {\n                        int calcBpl = (((width + 7) / 8) + (maskPad - 1)) / maskPad * maskPad;\n                        if (calcBpl == bpl)\n                            break;\n                    }\n                    maskData = ImageData.convertPad(maskData, width, height, 1, maskPad, 2);\n                }\n                \n                OS.HeapFree(hHeap, 0, lpvBits);\n                OS.SelectObject(hBitmapDC, hOldBitmap);\n                if (oldPalette != 0) {\n                    OS.SelectPalette(hBitmapDC, oldPalette, false);\n                    OS.RealizePalette(hBitmapDC);\n                }\n                OS.DeleteDC(hBitmapDC);\n                \n                device.internal_dispose_GC(hDC, null);\n                if (info.hbmColor != 0)\n                    OS.DeleteObject(info.hbmColor);\n                if (info.hbmMask != 0)\n                    OS.DeleteObject(info.hbmMask);\n                \n                ImageData imageData = new ImageData(width, height, depth, palette, 4, data);\n                imageData.maskData = maskData;\n                imageData.maskPad = 2;\n                return imageData;\n            }\n        case SWT.BITMAP:\n            {\n                \n                bm = new BITMAP();\n                OS.GetObject(handle, BITMAP.sizeof, bm);\n                depth = bm.bmPlanes * bm.bmBitsPixel;\n                width = bm.bmWidth;\n                height = bm.bmHeight;\n                \n                boolean isDib = (bm.bmBits != 0);\n                \n                int hDC = device.internal_new_GC(null);\n                \n                int handle = this.handle;\n                if (OS.IsWinCE) {\n                    if (!isDib) {\n                        boolean mustRestore = false;\n                        if (memGC != null && !memGC.isDisposed()) {\n                            memGC.flush();\n                            mustRestore = true;\n                            GCData data = memGC.data;\n                            if (data.hNullBitmap != 0) {\n                                OS.SelectObject(memGC.handle, data.hNullBitmap);\n                                data.hNullBitmap = 0;\n                            }\n                        }\n                        handle = createDIBFromDDB(hDC, this.handle, width, height);\n                        if (mustRestore) {\n                            int hOldBitmap = OS.SelectObject(memGC.handle, this.handle);\n                            memGC.data.hNullBitmap = hOldBitmap;\n                        }\n                        isDib = true;\n                    }\n                }\n                DIBSECTION dib = null;\n                if (isDib) {\n                    dib = new DIBSECTION();\n                    OS.GetObject(handle, DIBSECTION.sizeof, dib);\n                }\n                \n                int numColors = 0;\n                if (depth <= 8) {\n                    if (isDib) {\n                        numColors = dib.biClrUsed;\n                    } else {\n                        numColors = 1 << depth;\n                    }\n                }\n                \n                byte[] bmi = null;\n                BITMAPINFOHEADER bmiHeader = null;\n                if (!isDib) {\n                    bmiHeader = new BITMAPINFOHEADER();\n                    bmiHeader.biSize = BITMAPINFOHEADER.sizeof;\n                    bmiHeader.biWidth = width;\n                    bmiHeader.biHeight = -height;\n                    bmiHeader.biPlanes = 1;\n                    bmiHeader.biBitCount = (short) depth;\n                    bmiHeader.biCompression = OS.BI_RGB;\n                    bmi = new byte[BITMAPINFOHEADER.sizeof + numColors * 4];\n                    OS.MoveMemory(bmi, bmiHeader, BITMAPINFOHEADER.sizeof);\n                }\n                \n                int hBitmapDC = OS.CreateCompatibleDC(hDC);\n                int hOldBitmap = OS.SelectObject(hBitmapDC, handle);\n                \n                int oldPalette = 0;\n                if (!isDib && depth <= 8) {\n                    int hPalette = device.hPalette;\n                    if (hPalette != 0) {\n                        oldPalette = OS.SelectPalette(hBitmapDC, hPalette, false);\n                        OS.RealizePalette(hBitmapDC);\n                    }\n                }\n                \n                int imageSize;\n                if (isDib) {\n                    imageSize = dib.biSizeImage;\n                } else {\n                    \n                    if (OS.IsWinCE)\n                        SWT.error(SWT.ERROR_NOT_IMPLEMENTED);\n                    OS.GetDIBits(hBitmapDC, handle, 0, height, 0, bmi, OS.DIB_RGB_COLORS);\n                    OS.MoveMemory(bmiHeader, bmi, BITMAPINFOHEADER.sizeof);\n                    imageSize = bmiHeader.biSizeImage;\n                }\n                byte[] data = new byte[imageSize];\n                \n                if (isDib) {\n                    if (OS.IsWinCE && this.handle != handle) {\n                        \n                        OS.MoveMemory(data, dib.bmBits, imageSize);\n                    } else {\n                        OS.MoveMemory(data, bm.bmBits, imageSize);\n                    }\n                } else {\n                    int hHeap = OS.GetProcessHeap();\n                    int lpvBits = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, imageSize);\n                    if (OS.IsWinCE)\n                        SWT.error(SWT.ERROR_NOT_IMPLEMENTED);\n                    OS.GetDIBits(hBitmapDC, handle, 0, height, lpvBits, bmi, OS.DIB_RGB_COLORS);\n                    OS.MoveMemory(data, lpvBits, imageSize);\n                    OS.HeapFree(hHeap, 0, lpvBits);\n                }\n                \n                PaletteData palette = null;\n                if (depth <= 8) {\n                    RGB[] rgbs = new RGB[numColors];\n                    if (isDib) {\n                        if (OS.IsWinCE) {\n                            \n                            int red = 0, green = 0, blue = 0;\n                            byte[] pBits = new byte[1];\n                            OS.MoveMemory(pBits, bm.bmBits, 1);\n                            byte oldValue = pBits[0];\n                            int mask = (0xFF << (8 - bm.bmBitsPixel)) & 0x00FF;\n                            for (int i = 0; i < numColors; i++) {\n                                pBits[0] = (byte) ((i << (8 - bm.bmBitsPixel)) | (pBits[0] & ~mask));\n                                OS.MoveMemory(bm.bmBits, pBits, 1);\n                                int color = OS.GetPixel(hBitmapDC, 0, 0);\n                                blue = (color & 0xFF0000) >> 16;\n                                green = (color & 0xFF00) >> 8;\n                                red = color & 0xFF;\n                                rgbs[i] = new RGB(red, green, blue);\n                            }\n                            pBits[0] = oldValue;\n                            OS.MoveMemory(bm.bmBits, pBits, 1);\n                        } else {\n                            byte[] colors = new byte[numColors * 4];\n                            OS.GetDIBColorTable(hBitmapDC, 0, numColors, colors);\n                            int colorIndex = 0;\n                            for (int i = 0; i < rgbs.length; i++) {\n                                rgbs[i] = new RGB(colors[colorIndex + 2] & 0xFF, colors[colorIndex + 1] & 0xFF, colors[colorIndex] & 0xFF);\n                                colorIndex += 4;\n                            }\n                        }\n                    } else {\n                        int srcIndex = BITMAPINFOHEADER.sizeof;\n                        for (int i = 0; i < numColors; i++) {\n                            rgbs[i] = new RGB(bmi[srcIndex + 2] & 0xFF, bmi[srcIndex + 1] & 0xFF, bmi[srcIndex] & 0xFF);\n                            srcIndex += 4;\n                        }\n                    }\n                    palette = new PaletteData(rgbs);\n                } else if (depth == 16) {\n                    palette = new PaletteData(0x7C00, 0x3E0, 0x1F);\n                } else if (depth == 24) {\n                    palette = new PaletteData(0xFF, 0xFF00, 0xFF0000);\n                } else if (depth == 32) {\n                    palette = new PaletteData(0xFF00, 0xFF0000, 0xFF000000);\n                } else {\n                    SWT.error(SWT.ERROR_UNSUPPORTED_DEPTH);\n                }\n                \n                OS.SelectObject(hBitmapDC, hOldBitmap);\n                if (oldPalette != 0) {\n                    OS.SelectPalette(hBitmapDC, oldPalette, false);\n                    OS.RealizePalette(hBitmapDC);\n                }\n                if (OS.IsWinCE) {\n                    if (handle != this.handle) {\n                        \n                        OS.DeleteObject(handle);\n                    }\n                }\n                OS.DeleteDC(hBitmapDC);\n                \n                device.internal_dispose_GC(hDC, null);\n                \n                ImageData imageData = new ImageData(width, height, depth, palette, 4, data);\n                imageData.transparentPixel = this.transparentPixel;\n                imageData.alpha = alpha;\n                if (alpha == -1 && alphaData != null) {\n                    imageData.alphaData = new byte[alphaData.length];\n                    System.arraycopy(alphaData, 0, imageData.alphaData, 0, alphaData.length);\n                }\n                return imageData;\n            }\n        default:\n            SWT.error(SWT.ERROR_UNSUPPORTED_FORMAT);\n            return null;\n    }\n}",
			"comments":"/**\n* Returns an <code>ImageData</code> based on the receiver\n* Modifications made to this <code>ImageData</code> will not\n* affect the Image.\n*\n* @return an <code>ImageData</code> containing the image's data and attributes\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_INVALID_IMAGE - if the image is not a bitmap or an icon</li>\n* </ul>\n*\n* @see ImageData\n*/\n/* Get the basic BITMAP information */\n/* Create the BITMAPINFO */\n/* Get the HDC for the device */\n/* Create the DC and select the bitmap */\n/* Select the palette if necessary */\n/* Find the size of the image and allocate data */\n/* Call with null lpBits to get the image size */\n/* Get the bitmap data */\n/* Calculate the palette */\n/* Do the mask */\n/* Do the bottom half of the mask */\n/* Do the entire mask */\n/* Create the BITMAPINFO */\n/* First color black, second color white */\n/* Call with null lpBits to get the image size */\n/* Loop to invert the mask */\n/* Make sure mask scanlinePad is 2 */\n/* Clean up */\n/* Release the HDC for the device */\n/* Construct and return the ImageData */\n/* Get the basic BITMAP information */\n/* Find out whether this is a DIB or a DDB. */\n/* Get the HDC for the device */\n/*\n* Feature in WinCE.  GetDIBits is not available in WinCE.  The\n* workaround is to create a temporary DIB from the DDB and use\n* the bmBits field of DIBSECTION to retrieve the image data.\n*/\n/* Calculate number of colors */\n/* Create the BITMAPINFO */\n/* Create the DC and select the bitmap */\n/* Select the palette if necessary */\n/* Find the size of the image and allocate data */\n/* Call with null lpBits to get the image size */\n/* Get the bitmap data */\n/* get image data from the temporary DIB */\n/* Calculate the palette */\n/*\n* Feature on WinCE.  GetDIBColorTable is not supported.\n* The workaround is to set a pixel to the desired\n* palette index and use getPixel to get the corresponding\n* RGB value.\n*/\n/* Clean up */\n/* free temporary DIB */\n/* Release the HDC for the device */\n/* Construct and return the ImageData */\n",
			"methodName":"public ImageData getImageData()"
		},
		"public static Image win32_new(Device device, int type, int handle)":{
			"methodBody":"{\n    if (device == null)\n        device = Device.getDevice();\n    Image image = new Image();\n    image.type = type;\n    image.handle = handle;\n    image.device = device;\n    return image;\n}",
			"comments":"/**\n* Invokes platform specific functionality to allocate a new image.\n* <p>\n* <b>IMPORTANT:</b> This method is <em>not</em> part of the public\n* API for <code>Image</code>. It is marked public only so that it\n* can be shared within the packages provided by SWT. It is not\n* available on all platforms, and should never be called from\n* application code.\n* </p>\n*\n* @param device the device on which to allocate the color\n* @param type the type of the image (<code>SWT.BITMAP</code> or <code>SWT.ICON</code>)\n* @param handle the OS handle for the image\n* @return a new image object containing the specified device, type and handle\n*/\n",
			"methodName":"public static Image win32_new(Device device, int type, int handle)"
		},
		"public boolean isDisposed()":{
			"methodBody":"{\n    return handle == 0;\n}",
			"comments":"/**\n* Returns <code>true</code> if the image has been disposed,\n* and <code>false</code> otherwise.\n* <p>\n* This method gets the dispose state for the image.\n* When an image has been disposed, it is an error to\n* invoke any other method using the image.\n*\n* @return <code>true</code> when the image is disposed and <code>false</code> otherwise\n*/\n",
			"methodName":"public boolean isDisposed()"
		},
		"public boolean equals(Object object)":{
			"methodBody":"{\n    if (object == this)\n        return true;\n    if (!(object instanceof Image))\n        return false;\n    Image image = (Image) object;\n    return device == image.device && handle == image.handle;\n}",
			"comments":"/**\n* Compares the argument to the receiver, and returns true\n* if they represent the <em>same</em> object using a class\n* specific comparison.\n*\n* @param object the object to compare with this object\n* @return <code>true</code> if the object is the same as this object and <code>false</code> otherwise\n*\n* @see #hashCode\n*/\n",
			"methodName":"public boolean equals(Object object)"
		},
		"public Color getBackground()":{
			"methodBody":"{\n    if (isDisposed())\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (transparentPixel == -1)\n        return null;\n    \n    int hDC = device.internal_new_GC(null);\n    \n    BITMAP bm = new BITMAP();\n    OS.GetObject(handle, BITMAP.sizeof, bm);\n    int hdcMem = OS.CreateCompatibleDC(hDC);\n    int hOldObject = OS.SelectObject(hdcMem, handle);\n    int red = 0, green = 0, blue = 0;\n    if (bm.bmBitsPixel <= 8) {\n        if (OS.IsWinCE) {\n            byte[] pBits = new byte[1];\n            OS.MoveMemory(pBits, bm.bmBits, 1);\n            byte oldValue = pBits[0];\n            int mask = (0xFF << (8 - bm.bmBitsPixel)) & 0x00FF;\n            pBits[0] = (byte) ((transparentPixel << (8 - bm.bmBitsPixel)) | (pBits[0] & ~mask));\n            OS.MoveMemory(bm.bmBits, pBits, 1);\n            int color = OS.GetPixel(hdcMem, 0, 0);\n            pBits[0] = oldValue;\n            OS.MoveMemory(bm.bmBits, pBits, 1);\n            blue = (color & 0xFF0000) >> 16;\n            green = (color & 0xFF00) >> 8;\n            red = color & 0xFF;\n        } else {\n            byte[] color = new byte[4];\n            OS.GetDIBColorTable(hdcMem, transparentPixel, 1, color);\n            blue = color[0] & 0xFF;\n            green = color[1] & 0xFF;\n            red = color[2] & 0xFF;\n        }\n    } else {\n        switch(bm.bmBitsPixel) {\n            case 16:\n                blue = (transparentPixel & 0x1F) << 3;\n                green = (transparentPixel & 0x3E0) >> 2;\n                red = (transparentPixel & 0x7C00) >> 7;\n                break;\n            case 24:\n                blue = (transparentPixel & 0xFF0000) >> 16;\n                green = (transparentPixel & 0xFF00) >> 8;\n                red = transparentPixel & 0xFF;\n                break;\n            case 32:\n                blue = (transparentPixel & 0xFF000000) >>> 24;\n                green = (transparentPixel & 0xFF0000) >> 16;\n                red = (transparentPixel & 0xFF00) >> 8;\n                break;\n            default:\n                return null;\n        }\n    }\n    OS.SelectObject(hdcMem, hOldObject);\n    OS.DeleteDC(hdcMem);\n    \n    device.internal_dispose_GC(hDC, null);\n    return Color.win32_new(device, 0x02000000 | (blue << 16) | (green << 8) | red);\n}",
			"comments":"/**\n* Returns the color to which to map the transparent pixel, or null if\n* the receiver has no transparent pixel.\n* <p>\n* There are certain uses of Images that do not support transparency\n* (for example, setting an image into a button or label). In these cases,\n* it may be desired to simulate transparency by using the background\n* color of the widget to paint the transparent pixels of the image.\n* Use this method to check which color will be used in these cases\n* in place of transparency. This value may be set with setBackground().\n* <p>\n*\n* @return the background color of the image, or null if there is no transparency in the image\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n/* Get the HDC for the device */\n/* Compute the background color */\n/* Release the HDC for the device */\n",
			"methodName":"public Color getBackground()"
		},
		"void init(Device device, int width, int height)":{
			"methodBody":"{\n    if (width <= 0 || height <= 0) {\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    }\n    this.device = device;\n    type = SWT.BITMAP;\n    int hDC = device.internal_new_GC(null);\n    handle = OS.CreateCompatibleBitmap(hDC, width, height);\n    \n    if (handle == 0) {\n        int bits = OS.GetDeviceCaps(hDC, OS.BITSPIXEL);\n        int planes = OS.GetDeviceCaps(hDC, OS.PLANES);\n        int depth = bits * planes;\n        if (depth < 16)\n            depth = 16;\n        handle = createDIB(width, height, depth);\n    }\n    if (handle != 0) {\n        int memDC = OS.CreateCompatibleDC(hDC);\n        int hOldBitmap = OS.SelectObject(memDC, handle);\n        OS.PatBlt(memDC, 0, 0, width, height, OS.PATCOPY);\n        OS.SelectObject(memDC, hOldBitmap);\n        OS.DeleteDC(memDC);\n    }\n    device.internal_dispose_GC(hDC, null);\n    if (handle == 0) {\n        SWT.error(SWT.ERROR_NO_HANDLES, null, device.getLastError());\n    }\n}",
			"comments":"/*\n* Feature in Windows.  CreateCompatibleBitmap() may fail\n* for large images.  The fix is to create a DIB section\n* in that case.\n*/\n",
			"methodName":"void init(Device device, int width, int height)"
		},
		"static int[] init(Device device, Image image, ImageData i)":{
			"methodBody":"{\n    if (image != null)\n        image.device = device;\n    \n    if ((OS.IsWin95 && i.depth == 1 && i.getTransparencyType() != SWT.TRANSPARENCY_MASK) || i.depth == 2) {\n        ImageData img = new ImageData(i.width, i.height, 4, i.palette);\n        ImageData.blit(ImageData.BLIT_SRC, i.data, i.depth, i.bytesPerLine, i.getByteOrder(), 0, 0, i.width, i.height, null, null, null, ImageData.ALPHA_OPAQUE, null, 0, 0, 0, img.data, img.depth, img.bytesPerLine, i.getByteOrder(), 0, 0, img.width, img.height, null, null, null, false, false);\n        img.transparentPixel = i.transparentPixel;\n        img.maskPad = i.maskPad;\n        img.maskData = i.maskData;\n        img.alpha = i.alpha;\n        img.alphaData = i.alphaData;\n        i = img;\n    }\n    \n    if (i.palette.isDirect) {\n        final PaletteData palette = i.palette;\n        final int redMask = palette.redMask;\n        final int greenMask = palette.greenMask;\n        final int blueMask = palette.blueMask;\n        int newDepth = i.depth;\n        int newOrder = ImageData.MSB_FIRST;\n        PaletteData newPalette = null;\n        switch(i.depth) {\n            case 8:\n                newDepth = 16;\n                newOrder = ImageData.LSB_FIRST;\n                newPalette = new PaletteData(0x7C00, 0x3E0, 0x1F);\n                break;\n            case 16:\n                newOrder = ImageData.LSB_FIRST;\n                if (!(redMask == 0x7C00 && greenMask == 0x3E0 && blueMask == 0x1F)) {\n                    newPalette = new PaletteData(0x7C00, 0x3E0, 0x1F);\n                }\n                break;\n            case 24:\n                if (!(redMask == 0xFF && greenMask == 0xFF00 && blueMask == 0xFF0000)) {\n                    newPalette = new PaletteData(0xFF, 0xFF00, 0xFF0000);\n                }\n                break;\n            case 32:\n                if (!(redMask == 0xFF00 && greenMask == 0xFF0000 && blueMask == 0xFF000000)) {\n                    newPalette = new PaletteData(0xFF00, 0xFF0000, 0xFF000000);\n                }\n                break;\n            default:\n                SWT.error(SWT.ERROR_UNSUPPORTED_DEPTH);\n        }\n        if (newPalette != null) {\n            ImageData img = new ImageData(i.width, i.height, newDepth, newPalette);\n            ImageData.blit(ImageData.BLIT_SRC, i.data, i.depth, i.bytesPerLine, i.getByteOrder(), 0, 0, i.width, i.height, redMask, greenMask, blueMask, ImageData.ALPHA_OPAQUE, null, 0, 0, 0, img.data, img.depth, img.bytesPerLine, newOrder, 0, 0, img.width, img.height, newPalette.redMask, newPalette.greenMask, newPalette.blueMask, false, false);\n            if (i.transparentPixel != -1) {\n                img.transparentPixel = newPalette.getPixel(palette.getRGB(i.transparentPixel));\n            }\n            img.maskPad = i.maskPad;\n            img.maskData = i.maskData;\n            img.alpha = i.alpha;\n            img.alphaData = i.alphaData;\n            i = img;\n        }\n    }\n    \n    RGB[] rgbs = i.palette.getRGBs();\n    boolean useBitfields = OS.IsWinCE && (i.depth == 16 || i.depth == 32);\n    BITMAPINFOHEADER bmiHeader = new BITMAPINFOHEADER();\n    bmiHeader.biSize = BITMAPINFOHEADER.sizeof;\n    bmiHeader.biWidth = i.width;\n    bmiHeader.biHeight = -i.height;\n    bmiHeader.biPlanes = 1;\n    bmiHeader.biBitCount = (short) i.depth;\n    if (useBitfields)\n        bmiHeader.biCompression = OS.BI_BITFIELDS;\n    else\n        bmiHeader.biCompression = OS.BI_RGB;\n    bmiHeader.biClrUsed = rgbs == null ? 0 : rgbs.length;\n    byte[] bmi;\n    if (i.palette.isDirect)\n        bmi = new byte[BITMAPINFOHEADER.sizeof + (useBitfields ? 12 : 0)];\n    else\n        bmi = new byte[BITMAPINFOHEADER.sizeof + rgbs.length * 4];\n    OS.MoveMemory(bmi, bmiHeader, BITMAPINFOHEADER.sizeof);\n    \n    int offset = BITMAPINFOHEADER.sizeof;\n    if (i.palette.isDirect) {\n        if (useBitfields) {\n            PaletteData palette = i.palette;\n            int redMask = palette.redMask;\n            int greenMask = palette.greenMask;\n            int blueMask = palette.blueMask;\n            \n            if (i.getByteOrder() == ImageData.LSB_FIRST) {\n                bmi[offset] = (byte) ((redMask & 0xFF) >> 0);\n                bmi[offset + 1] = (byte) ((redMask & 0xFF00) >> 8);\n                bmi[offset + 2] = (byte) ((redMask & 0xFF0000) >> 16);\n                bmi[offset + 3] = (byte) ((redMask & 0xFF000000) >> 24);\n                bmi[offset + 4] = (byte) ((greenMask & 0xFF) >> 0);\n                bmi[offset + 5] = (byte) ((greenMask & 0xFF00) >> 8);\n                bmi[offset + 6] = (byte) ((greenMask & 0xFF0000) >> 16);\n                bmi[offset + 7] = (byte) ((greenMask & 0xFF000000) >> 24);\n                bmi[offset + 8] = (byte) ((blueMask & 0xFF) >> 0);\n                bmi[offset + 9] = (byte) ((blueMask & 0xFF00) >> 8);\n                bmi[offset + 10] = (byte) ((blueMask & 0xFF0000) >> 16);\n                bmi[offset + 11] = (byte) ((blueMask & 0xFF000000) >> 24);\n            } else {\n                bmi[offset] = (byte) ((redMask & 0xFF000000) >> 24);\n                bmi[offset + 1] = (byte) ((redMask & 0xFF0000) >> 16);\n                bmi[offset + 2] = (byte) ((redMask & 0xFF00) >> 8);\n                bmi[offset + 3] = (byte) ((redMask & 0xFF) >> 0);\n                bmi[offset + 4] = (byte) ((greenMask & 0xFF000000) >> 24);\n                bmi[offset + 5] = (byte) ((greenMask & 0xFF0000) >> 16);\n                bmi[offset + 6] = (byte) ((greenMask & 0xFF00) >> 8);\n                bmi[offset + 7] = (byte) ((greenMask & 0xFF) >> 0);\n                bmi[offset + 8] = (byte) ((blueMask & 0xFF000000) >> 24);\n                bmi[offset + 9] = (byte) ((blueMask & 0xFF0000) >> 16);\n                bmi[offset + 10] = (byte) ((blueMask & 0xFF00) >> 8);\n                bmi[offset + 11] = (byte) ((blueMask & 0xFF) >> 0);\n            }\n        }\n    } else {\n        for (int j = 0; j < rgbs.length; j++) {\n            bmi[offset] = (byte) rgbs[j].blue;\n            bmi[offset + 1] = (byte) rgbs[j].green;\n            bmi[offset + 2] = (byte) rgbs[j].red;\n            bmi[offset + 3] = 0;\n            offset += 4;\n        }\n    }\n    int[] pBits = new int[1];\n    int hDib = OS.CreateDIBSection(0, bmi, OS.DIB_RGB_COLORS, pBits, 0, 0);\n    if (hDib == 0)\n        SWT.error(SWT.ERROR_NO_HANDLES);\n    \n    byte[] data = i.data;\n    if (i.scanlinePad != 4 && (i.bytesPerLine % 4 != 0)) {\n        data = ImageData.convertPad(data, i.width, i.height, i.depth, i.scanlinePad, 4);\n    }\n    OS.MoveMemory(pBits[0], data, data.length);\n    int[] result = null;\n    if (i.getTransparencyType() == SWT.TRANSPARENCY_MASK) {\n        \n        int hDC = device.internal_new_GC(null);\n        \n        int hdcSrc = OS.CreateCompatibleDC(hDC);\n        OS.SelectObject(hdcSrc, hDib);\n        int hBitmap = OS.CreateCompatibleBitmap(hDC, i.width, i.height);\n        if (hBitmap == 0)\n            SWT.error(SWT.ERROR_NO_HANDLES);\n        int hdcDest = OS.CreateCompatibleDC(hDC);\n        OS.SelectObject(hdcDest, hBitmap);\n        OS.BitBlt(hdcDest, 0, 0, i.width, i.height, hdcSrc, 0, 0, OS.SRCCOPY);\n        \n        device.internal_dispose_GC(hDC, null);\n        \n        byte[] maskData = ImageData.convertPad(i.maskData, i.width, i.height, 1, i.maskPad, 2);\n        int hMask = OS.CreateBitmap(i.width, i.height, 1, 1, maskData);\n        if (hMask == 0)\n            SWT.error(SWT.ERROR_NO_HANDLES);\n        OS.SelectObject(hdcSrc, hMask);\n        OS.PatBlt(hdcSrc, 0, 0, i.width, i.height, OS.DSTINVERT);\n        OS.DeleteDC(hdcSrc);\n        OS.DeleteDC(hdcDest);\n        OS.DeleteObject(hDib);\n        if (image == null) {\n            result = new int[] { hBitmap, hMask };\n        } else {\n            \n            ICONINFO info = new ICONINFO();\n            info.fIcon = true;\n            info.hbmColor = hBitmap;\n            info.hbmMask = hMask;\n            int hIcon = OS.CreateIconIndirect(info);\n            if (hIcon == 0)\n                SWT.error(SWT.ERROR_NO_HANDLES);\n            OS.DeleteObject(hBitmap);\n            OS.DeleteObject(hMask);\n            image.handle = hIcon;\n            image.type = SWT.ICON;\n            if (OS.IsWinCE)\n                image.data = i;\n        }\n    } else {\n        if (image == null) {\n            result = new int[] { hDib };\n        } else {\n            image.handle = hDib;\n            image.type = SWT.BITMAP;\n            image.transparentPixel = i.transparentPixel;\n            if (image.transparentPixel == -1) {\n                image.alpha = i.alpha;\n                if (i.alpha == -1 && i.alphaData != null) {\n                    int length = i.alphaData.length;\n                    image.alphaData = new byte[length];\n                    System.arraycopy(i.alphaData, 0, image.alphaData, 0, length);\n                }\n            }\n        }\n    }\n    return result;\n}",
			"comments":"/*\n* BUG in Windows 98:\n* A monochrome DIBSection will display as solid black\n* on Windows 98 machines, even though it contains the\n* correct data. The fix is to convert 1-bit ImageData\n* into 4-bit ImageData before creating the image.\n*/\n/* Windows does not support 2-bit images. Convert to 4-bit image. */\n/*\n* Windows supports 16-bit mask of (0x7C00, 0x3E0, 0x1F),\n* 24-bit mask of (0xFF0000, 0xFF00, 0xFF) and 32-bit mask\n* (0x00FF0000, 0x0000FF00, 0x000000FF) as documented in\n* MSDN BITMAPINFOHEADER.  Make sure the image is\n* Windows-supported.\n*/\n/*\n* Note on WinCE.  CreateDIBSection requires the biCompression\n* field of the BITMAPINFOHEADER to be set to BI_BITFIELDS for\n* 16 and 32 bit direct images (see MSDN for CreateDIBSection).\n* In this case, the color mask can be set to any value.  For\n* consistency, it is set to the same mask used by non WinCE\n* platforms in BI_RGB mode.\n*/\n/* Construct bitmap info header by hand */\n/* Set the rgb colors into the bitmap info */\n/*\n* The color masks must be written based on the\n* endianness of the ImageData.\n*/\n/* In case of a scanline pad other than 4, do the work to convert it */\n/* Get the HDC for the device */\n/* Create the color bitmap */\n/* Release the HDC for the device */\n/* Create the mask. Windows requires icon masks to have a scanline pad of 2. */\n/* Create the icon */\n",
			"methodName":"static int[] init(Device device, Image image, ImageData i)"
		},
		"int[] createGdipImage()":{
			"methodBody":"{\n    switch(type) {\n        case SWT.BITMAP:\n            {\n                if (alpha != -1 || alphaData != null || transparentPixel != -1) {\n                    BITMAP bm = new BITMAP();\n                    OS.GetObject(handle, BITMAP.sizeof, bm);\n                    int imgWidth = bm.bmWidth;\n                    int imgHeight = bm.bmHeight;\n                    int hDC = device.internal_new_GC(null);\n                    int srcHdc = OS.CreateCompatibleDC(hDC);\n                    int oldSrcBitmap = OS.SelectObject(srcHdc, handle);\n                    int memHdc = OS.CreateCompatibleDC(hDC);\n                    int memDib = createDIB(imgWidth, imgHeight, 32);\n                    if (memDib == 0)\n                        SWT.error(SWT.ERROR_NO_HANDLES);\n                    int oldMemBitmap = OS.SelectObject(memHdc, memDib);\n                    BITMAP dibBM = new BITMAP();\n                    OS.GetObject(memDib, BITMAP.sizeof, dibBM);\n                    int sizeInBytes = dibBM.bmWidthBytes * dibBM.bmHeight;\n                    OS.BitBlt(memHdc, 0, 0, imgWidth, imgHeight, srcHdc, 0, 0, OS.SRCCOPY);\n                    byte red = 0, green = 0, blue = 0;\n                    if (transparentPixel != -1) {\n                        if (bm.bmBitsPixel <= 8) {\n                            byte[] color = new byte[4];\n                            OS.GetDIBColorTable(srcHdc, transparentPixel, 1, color);\n                            blue = color[0];\n                            green = color[1];\n                            red = color[2];\n                        } else {\n                            switch(bm.bmBitsPixel) {\n                                case 16:\n                                    blue = (byte) ((transparentPixel & 0x1F) << 3);\n                                    green = (byte) ((transparentPixel & 0x3E0) >> 2);\n                                    red = (byte) ((transparentPixel & 0x7C00) >> 7);\n                                    break;\n                                case 24:\n                                    blue = (byte) ((transparentPixel & 0xFF0000) >> 16);\n                                    green = (byte) ((transparentPixel & 0xFF00) >> 8);\n                                    red = (byte) (transparentPixel & 0xFF);\n                                    break;\n                                case 32:\n                                    blue = (byte) ((transparentPixel & 0xFF000000) >>> 24);\n                                    green = (byte) ((transparentPixel & 0xFF0000) >> 16);\n                                    red = (byte) ((transparentPixel & 0xFF00) >> 8);\n                                    break;\n                            }\n                        }\n                    }\n                    OS.SelectObject(srcHdc, oldSrcBitmap);\n                    OS.SelectObject(memHdc, oldMemBitmap);\n                    OS.DeleteObject(srcHdc);\n                    OS.DeleteObject(memHdc);\n                    byte[] srcData = new byte[sizeInBytes];\n                    OS.MoveMemory(srcData, dibBM.bmBits, sizeInBytes);\n                    OS.DeleteObject(memDib);\n                    device.internal_dispose_GC(hDC, null);\n                    if (alpha != -1) {\n                        for (int y = 0, dp = 0; y < imgHeight; ++y) {\n                            for (int x = 0; x < imgWidth; ++x) {\n                                srcData[dp + 3] = (byte) alpha;\n                                dp += 4;\n                            }\n                        }\n                    } else if (alphaData != null) {\n                        for (int y = 0, dp = 0, ap = 0; y < imgHeight; ++y) {\n                            for (int x = 0; x < imgWidth; ++x) {\n                                srcData[dp + 3] = alphaData[ap++];\n                                dp += 4;\n                            }\n                        }\n                    } else if (transparentPixel != -1) {\n                        for (int y = 0, dp = 0; y < imgHeight; ++y) {\n                            for (int x = 0; x < imgWidth; ++x) {\n                                if (srcData[dp] == blue && srcData[dp + 1] == green && srcData[dp + 2] == red) {\n                                    srcData[dp + 3] = (byte) 0;\n                                } else {\n                                    srcData[dp + 3] = (byte) 0xFF;\n                                }\n                                dp += 4;\n                            }\n                        }\n                    }\n                    int hHeap = OS.GetProcessHeap();\n                    int pixels = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, srcData.length);\n                    OS.MoveMemory(pixels, srcData, sizeInBytes);\n                    return new int[] { Gdip.Bitmap_new(imgWidth, imgHeight, dibBM.bmWidthBytes, Gdip.PixelFormat32bppARGB, pixels), pixels };\n                }\n                return new int[] { Gdip.Bitmap_new(handle, 0), 0 };\n            }\n        case SWT.ICON:\n            {\n                \n                ICONINFO iconInfo = new ICONINFO();\n                if (OS.IsWinCE) {\n                    GetIconInfo(this, iconInfo);\n                } else {\n                    OS.GetIconInfo(handle, iconInfo);\n                }\n                int hBitmap = iconInfo.hbmColor;\n                if (hBitmap == 0)\n                    hBitmap = iconInfo.hbmMask;\n                BITMAP bm = new BITMAP();\n                OS.GetObject(hBitmap, BITMAP.sizeof, bm);\n                int imgWidth = bm.bmWidth;\n                int imgHeight = hBitmap == iconInfo.hbmMask ? bm.bmHeight / 2 : bm.bmHeight;\n                int img = 0, pixels = 0;\n                if (imgWidth > imgHeight) {\n                    int hDC = device.internal_new_GC(null);\n                    int srcHdc = OS.CreateCompatibleDC(hDC);\n                    int oldSrcBitmap = OS.SelectObject(srcHdc, hBitmap);\n                    int memHdc = OS.CreateCompatibleDC(hDC);\n                    int memDib = createDIB(imgWidth, imgHeight, 32);\n                    if (memDib == 0)\n                        SWT.error(SWT.ERROR_NO_HANDLES);\n                    int oldMemBitmap = OS.SelectObject(memHdc, memDib);\n                    BITMAP dibBM = new BITMAP();\n                    OS.GetObject(memDib, BITMAP.sizeof, dibBM);\n                    OS.BitBlt(memHdc, 0, 0, imgWidth, imgHeight, srcHdc, 0, hBitmap == iconInfo.hbmMask ? imgHeight : 0, OS.SRCCOPY);\n                    OS.SelectObject(memHdc, oldMemBitmap);\n                    OS.DeleteObject(memHdc);\n                    byte[] srcData = new byte[dibBM.bmWidthBytes * dibBM.bmHeight];\n                    OS.MoveMemory(srcData, dibBM.bmBits, srcData.length);\n                    OS.DeleteObject(memDib);\n                    OS.SelectObject(srcHdc, iconInfo.hbmMask);\n                    for (int y = 0, dp = 0; y < imgHeight; ++y) {\n                        for (int x = 0; x < imgWidth; ++x) {\n                            if (OS.GetPixel(srcHdc, x, y) != 0) {\n                                srcData[dp + 3] = (byte) 0;\n                            } else {\n                                srcData[dp + 3] = (byte) 0xFF;\n                            }\n                            dp += 4;\n                        }\n                    }\n                    OS.SelectObject(srcHdc, oldSrcBitmap);\n                    OS.DeleteObject(srcHdc);\n                    device.internal_dispose_GC(hDC, null);\n                    int hHeap = OS.GetProcessHeap();\n                    pixels = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, srcData.length);\n                    OS.MoveMemory(pixels, srcData, srcData.length);\n                    img = Gdip.Bitmap_new(imgWidth, imgHeight, dibBM.bmWidthBytes, Gdip.PixelFormat32bppARGB, pixels);\n                } else {\n                    img = Gdip.Bitmap_new(handle);\n                }\n                if (iconInfo.hbmColor == 0)\n                    OS.DeleteObject(iconInfo.hbmColor);\n                if (iconInfo.hbmMask == 0)\n                    OS.DeleteObject(iconInfo.hbmMask);\n                return new int[] { img, pixels };\n            }\n        default:\n            SWT.error(SWT.ERROR_UNSUPPORTED_FORMAT);\n    }\n    return null;\n}",
			"comments":"/*\n* Bug in GDI+. Creating a new GDI+ Bitmap from a HICON segment faults\n* when the icon width is bigger than the icon height.  The fix is to\n* detect this and create a PixelFormat32bppARGB image instead.\n*/\n",
			"methodName":"int[] createGdipImage()"
		},
		"public String toString()":{
			"methodBody":"{\n    if (isDisposed())\n        return \"Image {*DISPOSED*}\";\n    return \"Image {\" + handle + \"}\";\n}",
			"comments":"/**\n* Returns a string containing a concise, human-readable\n* description of the receiver.\n*\n* @return a string representation of the receiver\n*/\n",
			"methodName":"public String toString()"
		},
		"public int hashCode()":{
			"methodBody":"{\n    return handle;\n}",
			"comments":"/**\n* Returns an integer hash code for the receiver. Any two\n* objects that return <code>true</code> when passed to\n* <code>equals</code> must return the same value for this\n* method.\n*\n* @return the receiver's hash\n*\n* @see #equals\n*/\n",
			"methodName":"public int hashCode()"
		},
		"static void GetIconInfo(Image image, ICONINFO info)":{
			"methodBody":"{\n    int[] result = init(image.device, null, image.data);\n    info.hbmColor = result[0];\n    info.hbmMask = result[1];\n}",
			"comments":"/**\n* Feature in WinCE.  GetIconInfo is not available in WinCE.\n* The workaround is to cache the object ImageData for images\n* of type SWT.ICON. The bitmaps hbmMask and hbmColor can then\n* be reconstructed by using our version of getIconInfo.\n* This function takes an ICONINFO object and sets the fields\n* hbmMask and hbmColor with the corresponding bitmaps it has\n* created.\n* Note.  These bitmaps must be freed - as they would have to be\n* if the regular GetIconInfo had been used.\n*/\n",
			"methodName":"static void GetIconInfo(Image image, ICONINFO info)"
		},
		"public void internal_dispose_GC(int hDC, GCData data)":{
			"methodBody":"{\n    OS.DeleteDC(hDC);\n}",
			"comments":"/**\n* Invokes platform specific functionality to dispose a GC handle.\n* <p>\n* <b>IMPORTANT:</b> This method is <em>not</em> part of the public\n* API for <code>Image</code>. It is marked public only so that it\n* can be shared within the packages provided by SWT. It is not\n* available on all platforms, and should never be called from\n* application code.\n* </p>\n*\n* @param hDC the platform specific GC handle\n* @param data the platform specific GC data\n*/\n",
			"methodName":"public void internal_dispose_GC(int hDC, GCData data)"
		},
		"void init(Device device, ImageData i)":{
			"methodBody":"{\n    if (i == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    init(device, this, i);\n}",
			"comments":"",
			"methodName":"void init(Device device, ImageData i)"
		},
		"public int internal_new_GC(GCData data)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    \n    if (type != SWT.BITMAP || memGC != null) {\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    }\n    \n    int hDC = device.internal_new_GC(null);\n    int imageDC = OS.CreateCompatibleDC(hDC);\n    device.internal_dispose_GC(hDC, null);\n    if (imageDC == 0)\n        SWT.error(SWT.ERROR_NO_HANDLES);\n    if (data != null) {\n        \n        int mask = SWT.LEFT_TO_RIGHT | SWT.RIGHT_TO_LEFT;\n        if ((data.style & mask) != 0) {\n            data.layout = (data.style & SWT.RIGHT_TO_LEFT) != 0 ? OS.LAYOUT_RTL : 0;\n        } else {\n            data.style |= SWT.LEFT_TO_RIGHT;\n        }\n        data.device = device;\n        data.image = this;\n        data.hFont = device.systemFont;\n    }\n    return imageDC;\n}",
			"comments":"/**\n* Invokes platform specific functionality to allocate a new GC handle.\n* <p>\n* <b>IMPORTANT:</b> This method is <em>not</em> part of the public\n* API for <code>Image</code>. It is marked public only so that it\n* can be shared within the packages provided by SWT. It is not\n* available on all platforms, and should never be called from\n* application code.\n* </p>\n*\n* @param data the platform specific GC data\n* @return the platform specific GC handle\n*/\n/*\n* Create a new GC that can draw into the image.\n* Only supported for bitmaps.\n*/\n/* Create a compatible HDC for the device */\n/* Set the GCData fields */\n",
			"methodName":"public int internal_new_GC(GCData data)"
		},
		"public void setBackground(Color color)":{
			"methodBody":"{\n    \n    if (OS.IsWinCE)\n        return;\n    if (isDisposed())\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (color == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (color.isDisposed())\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    if (transparentPixel == -1)\n        return;\n    \n    int hDC = device.internal_new_GC(null);\n    \n    BITMAP bm = new BITMAP();\n    OS.GetObject(handle, BITMAP.sizeof, bm);\n    int hdcMem = OS.CreateCompatibleDC(hDC);\n    OS.SelectObject(hdcMem, handle);\n    int maxColors = 1 << bm.bmBitsPixel;\n    byte[] colors = new byte[maxColors * 4];\n    if (OS.IsWinCE)\n        SWT.error(SWT.ERROR_NOT_IMPLEMENTED);\n    int numColors = OS.GetDIBColorTable(hdcMem, 0, maxColors, colors);\n    int offset = transparentPixel * 4;\n    colors[offset] = (byte) color.getBlue();\n    colors[offset + 1] = (byte) color.getGreen();\n    colors[offset + 2] = (byte) color.getRed();\n    if (OS.IsWinCE)\n        SWT.error(SWT.ERROR_NOT_IMPLEMENTED);\n    OS.SetDIBColorTable(hdcMem, 0, numColors, colors);\n    OS.DeleteDC(hdcMem);\n    \n    device.internal_dispose_GC(hDC, null);\n}",
			"comments":"/**\n* Sets the color to which to map the transparent pixel.\n* <p>\n* There are certain uses of <code>Images</code> that do not support\n* transparency (for example, setting an image into a button or label).\n* In these cases, it may be desired to simulate transparency by using\n* the background color of the widget to paint the transparent pixels\n* of the image. This method specifies the color that will be used in\n* these cases. For example:\n* <pre>\n*    Button b = new Button();\n*    image.setBackground(b.getBackground());\n*    b.setImage(image);\n* </pre>\n* </p><p>\n* The image may be modified by this operation (in effect, the\n* transparent regions may be filled with the supplied color).  Hence\n* this operation is not reversible and it is not legal to call\n* this function twice or with a null argument.\n* </p><p>\n* This method has no effect if the receiver does not have a transparent\n* pixel value.\n* </p>\n*\n* @param color the color to use when a transparent pixel is specified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the color is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the color has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n/*\n* Note.  Not implemented on WinCE.\n*/\n/* Get the HDC for the device */\n/* Change the background color in the image */\n/* Release the HDC for the device */\n",
			"methodName":"public void setBackground(Color color)"
		}
	},
	"ClassORInterfaceName":[
		"Image"
	]
}
