{
	"variables":[
		"TRANSPARENCY_TYPE_PIXEL",
		"TRANSPARENCY_TYPE_ALPHAS",
		"valid",
		"gray",
		"red",
		"green",
		"blue",
		"alphas",
		"dataLength",
		"i",
		"j",
		"reference",
		"header",
		"PngIhdrChunk",
		"valid",
		"PngIhdrChunk",
		"valid",
		"paletteChunk",
		"PngIhdrChunk",
		"valid",
		"PngIhdrChunk",
		"PngIhdrChunk",
		"valid",
		"valid",
		"SWT",
		"SWT",
		"readState",
		"headerChunk",
		"readState",
		"readState",
		"readState",
		"SWT",
		"SWT",
		"readState",
		"headerChunk",
		"paletteChunk",
		"readState",
		"headerChunk",
		"header",
		"PngIhdrChunk",
		"TRANSPARENCY_TYPE_ALPHAS",
		"TRANSPARENCY_TYPE_PIXEL",
		"header",
		"PngIhdrChunk",
		"reference",
		"DATA_OFFSET",
		"reference",
		"DATA_OFFSET",
		"header",
		"PNGFileFormat",
		"gray",
		"gray",
		"PngIhdrChunk",
		"reference",
		"DATA_OFFSET",
		"reference",
		"DATA_OFFSET",
		"reference",
		"DATA_OFFSET",
		"reference",
		"DATA_OFFSET",
		"reference",
		"DATA_OFFSET",
		"reference",
		"DATA_OFFSET",
		"header",
		"red",
		"PNGFileFormat",
		"red",
		"green",
		"PNGFileFormat",
		"green",
		"blue",
		"PNGFileFormat",
		"blue",
		"red",
		"green",
		"blue",
		"SWT",
		"SWT",
		"header",
		"PngIhdrChunk",
		"SWT",
		"SWT",
		"paletteChunk",
		"i",
		"i",
		"dataLength",
		"i",
		"alphas",
		"i",
		"reference",
		"DATA_OFFSET",
		"i",
		"i",
		"j",
		"alphas",
		"j",
		"alphas",
		"j",
		"alphas",
		"COLOR_TYPE_RGB",
		"COLOR_TYPE_PALETTE",
		"COLOR_TYPE_GRAYSCALE",
		"COLOR_TYPE_RGB_WITH_ALPHA",
		"COLOR_TYPE_GRAYSCALE_WITH_ALPHA",
		"ERROR_INVALID_IMAGE",
		"readIHDR",
		"readPLTE",
		"readIDAT",
		"readIEND",
		"ERROR_INVALID_IMAGE",
		"readTRNS",
		"COLOR_TYPE_PALETTE",
		"COLOR_TYPE_GRAYSCALE",
		"COLOR_TYPE_RGB",
		"ERROR_INVALID_IMAGE",
		"COLOR_TYPE_PALETTE",
		"ERROR_INVALID_IMAGE",
		"length",
		"reference",
		"header",
		"paletteChunk",
		"readState",
		"headerChunk",
		"paletteChunk",
		"header",
		"header",
		"header",
		"paletteChunk"
	],
	"extendORImplementFiles":[
		"PngChunk"
	],
	"package":[
		"org.eclipse.swt.internal.image"
	],
	"import":[
		"org.eclipse.swt"
	],
	"methods":[
		"validateLength",
		"validate",
		"getTransparencyType",
		"getSwtTransparentPixel",
		"getAlphaValues",
		"getColorType",
		"getLength",
		"getLength",
		"getLength",
		"getLength",
		"error",
		"getMustHavePalette",
		"error",
		"validateLength",
		"validate",
		"getColorType",
		"getColorType",
		"getBitDepth",
		"compress16BitDepthTo8BitDepth",
		"getBitDepth",
		"compress16BitDepthTo8BitDepth",
		"compress16BitDepthTo8BitDepth",
		"compress16BitDepthTo8BitDepth",
		"error",
		"getColorType",
		"error",
		"getPaletteSize",
		"getLength"
	],
	"methodsBody":{
		"int getSwtTransparentPixel(PngIhdrChunk header)":{
			"methodBody":"{\n    switch(header.getColorType()) {\n        case PngIhdrChunk.COLOR_TYPE_GRAYSCALE:\n            int gray = ((reference[DATA_OFFSET] & 0xFF) << 8) + (reference[DATA_OFFSET + 1] & 0xFF);\n            if (header.getBitDepth() > 8) {\n                return PNGFileFormat.compress16BitDepthTo8BitDepth(gray);\n            }\n            return gray & 0xFF;\n        case PngIhdrChunk.COLOR_TYPE_RGB:\n            int red = ((reference[DATA_OFFSET] & 0xFF) << 8) | (reference[DATA_OFFSET + 1] & 0xFF);\n            int green = ((reference[DATA_OFFSET + 2] & 0xFF) << 8) | (reference[DATA_OFFSET + 3] & 0xFF);\n            int blue = ((reference[DATA_OFFSET + 4] & 0xFF) << 8) | (reference[DATA_OFFSET + 5] & 0xFF);\n            if (header.getBitDepth() > 8) {\n                red = PNGFileFormat.compress16BitDepthTo8BitDepth(red);\n                green = PNGFileFormat.compress16BitDepthTo8BitDepth(green);\n                blue = PNGFileFormat.compress16BitDepthTo8BitDepth(blue);\n            }\n            return (red << 16) | (green << 8) | blue;\n        default:\n            SWT.error(SWT.ERROR_INVALID_IMAGE);\n            return -1;\n    }\n}",
			"comments":"/**\n* Answer the transparent pixel RGB value.\n* This is not valid for palette color types.\n* This is not valid for alpha color types.\n* This will convert a grayscale value into\n* a palette index.\n* It will compress a 6 byte RGB into a 3 byte\n* RGB.\n*/\n",
			"methodName":"int getSwtTransparentPixel(PngIhdrChunk header)"
		},
		"byte[] getAlphaValues(PngIhdrChunk header, PngPlteChunk paletteChunk)":{
			"methodBody":"{\n    if (header.getColorType() != PngIhdrChunk.COLOR_TYPE_PALETTE) {\n        SWT.error(SWT.ERROR_INVALID_IMAGE);\n    }\n    byte[] alphas = new byte[paletteChunk.getPaletteSize()];\n    int dataLength = getLength();\n    int i = 0;\n    for (i = 0; i < dataLength; i++) {\n        alphas[i] = reference[DATA_OFFSET + i];\n    }\n    \n    for (int j = i; j < alphas.length; j++) {\n        alphas[j] = (byte) 255;\n    }\n    return alphas;\n}",
			"comments":"/**\n* Answer an array of Alpha values that correspond to the\n* colors in the palette.\n* This is only valid for the COLOR_TYPE_PALETTE color type.\n*/\n/**\n* Any palette entries which do not have a corresponding\n* alpha value in the tRNS chunk are spec'd to have an\n* alpha of 255.\n*/\n",
			"methodName":"byte[] getAlphaValues(PngIhdrChunk header, PngPlteChunk paletteChunk)"
		},
		"int getTransparencyType(PngIhdrChunk header)":{
			"methodBody":"{\n    if (header.getColorType() == PngIhdrChunk.COLOR_TYPE_PALETTE) {\n        return TRANSPARENCY_TYPE_ALPHAS;\n    }\n    return TRANSPARENCY_TYPE_PIXEL;\n}",
			"comments":"",
			"methodName":"int getTransparencyType(PngIhdrChunk header)"
		},
		"void validate(PngFileReadState readState, PngIhdrChunk headerChunk, PngPlteChunk paletteChunk)":{
			"methodBody":"{\n    if (!readState.readIHDR || (headerChunk.getMustHavePalette() && !readState.readPLTE) || readState.readIDAT || readState.readIEND) {\n        SWT.error(SWT.ERROR_INVALID_IMAGE);\n    } else {\n        readState.readTRNS = true;\n    }\n    validateLength(headerChunk, paletteChunk);\n    super.validate(readState, headerChunk);\n}",
			"comments":"/**\n* Answer whether the chunk is a valid tRNS chunk.\n*/\n",
			"methodName":"void validate(PngFileReadState readState, PngIhdrChunk headerChunk, PngPlteChunk paletteChunk)"
		},
		"void validateLength(PngIhdrChunk header, PngPlteChunk paletteChunk)":{
			"methodBody":"{\n    boolean valid;\n    switch(header.getColorType()) {\n        case PngIhdrChunk.COLOR_TYPE_RGB:\n            \n            valid = getLength() == 6;\n            break;\n        case PngIhdrChunk.COLOR_TYPE_PALETTE:\n            \n            valid = getLength() <= paletteChunk.getLength();\n            break;\n        case PngIhdrChunk.COLOR_TYPE_GRAYSCALE:\n            \n            valid = getLength() == 2;\n            break;\n        \n        case PngIhdrChunk.COLOR_TYPE_RGB_WITH_ALPHA:\n        case PngIhdrChunk.COLOR_TYPE_GRAYSCALE_WITH_ALPHA:\n        default:\n            valid = false;\n    }\n    if (!valid) {\n        SWT.error(SWT.ERROR_INVALID_IMAGE);\n    }\n}",
			"comments":"// Three 2-byte values (RGB)\n// Three 2-byte values (RGB)\n// One 2-byte value\n// Cannot use both Alpha and tRNS\n",
			"methodName":"void validateLength(PngIhdrChunk header, PngPlteChunk paletteChunk)"
		}
	},
	"ClassORInterfaceName":[
		"PngTrnsChunk"
	]
}
