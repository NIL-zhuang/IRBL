{
	"variables":[
		"BMPFileHeaderSize",
		"BMPHeaderFixedSize",
		"width",
		"height",
		"bitCount",
		"header",
		"infoHeaderSize",
		"stride",
		"data",
		"dataSize",
		"data",
		"header",
		"fileHeader",
		"infoHeader",
		"palette",
		"data",
		"type",
		"numColors",
		"buf",
		"bytesOffset",
		"colors",
		"i",
		"n",
		"bytes",
		"offset",
		"i",
		"col",
		"bmpBpl",
		"bpl",
		"linesPerBuf",
		"buf",
		"data",
		"imageBpl",
		"dataIndex",
		"y",
		"count",
		"bufOffset",
		"i",
		"wIndex",
		"y",
		"tmp",
		"count",
		"bufOffset",
		"i",
		"rgbs",
		"numCols",
		"pal",
		"headersSize",
		"fileHeader",
		"out",
		"data",
		"i1",
		"i2",
		"i",
		"index",
		"b",
		"stream",
		"header",
		"stream",
		"header",
		"header",
		"header",
		"header",
		"header",
		"header",
		"header",
		"infoHeaderSize",
		"BMPHeaderFixedSize",
		"width",
		"bitCount",
		"stride",
		"stride",
		"infoHeader",
		"stride",
		"data",
		"stride",
		"height",
		"data",
		"height",
		"stride",
		"dataSize",
		"inputStream",
		"data",
		"dataSize",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"e",
		"data",
		"header",
		"inputStream",
		"header",
		"inputStream",
		"header",
		"inputStream",
		"header",
		"inputStream",
		"header",
		"inputStream",
		"SWT",
		"SWT",
		"e",
		"header",
		"SWT",
		"SWT",
		"header",
		"BMPHeaderFixedSize",
		"inputStream",
		"infoHeader",
		"SWT",
		"SWT",
		"e",
		"width",
		"infoHeader",
		"infoHeader",
		"height",
		"infoHeader",
		"infoHeader",
		"bitCount",
		"infoHeader",
		"infoHeader",
		"infoHeader",
		"inputStream",
		"fileHeader",
		"inputStream",
		"fileHeader",
		"inputStream",
		"SWT",
		"SWT",
		"e",
		"infoHeader",
		"SWT",
		"ImageData",
		"width",
		"height",
		"bitCount",
		"palette",
		"data",
		"type",
		"bitCount",
		"bitCount",
		"numColors",
		"inputStream",
		"buf",
		"buf",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"e",
		"buf",
		"numColors",
		"bitCount",
		"bitCount",
		"numColors",
		"i",
		"numColors",
		"i",
		"colors",
		"i",
		"bytes",
		"bytesOffset",
		"bytes",
		"bytesOffset",
		"bytes",
		"bytesOffset",
		"bytesOffset",
		"colors",
		"pal",
		"pal",
		"pal",
		"n",
		"i",
		"n",
		"i",
		"pal",
		"i",
		"bytes",
		"offset",
		"col",
		"bytes",
		"offset",
		"col",
		"bytes",
		"offset",
		"col",
		"offset",
		"bytes",
		"image",
		"image",
		"bmpBpl",
		"bpl",
		"bmpBpl",
		"linesPerBuf",
		"bmpBpl",
		"image",
		"image",
		"imageBpl",
		"image",
		"image",
		"y",
		"image",
		"y",
		"linesPerBuf",
		"image",
		"y",
		"linesPerBuf",
		"count",
		"count",
		"linesPerBuf",
		"i",
		"count",
		"i",
		"wIndex",
		"bpl",
		"wIndex",
		"buf",
		"bufOffset",
		"wIndex",
		"data",
		"dataIndex",
		"wIndex",
		"buf",
		"bufOffset",
		"wIndex",
		"data",
		"dataIndex",
		"wIndex",
		"bufOffset",
		"bmpBpl",
		"dataIndex",
		"imageBpl",
		"out",
		"buf",
		"bufOffset",
		"y",
		"image",
		"y",
		"linesPerBuf",
		"image",
		"y",
		"tmp",
		"linesPerBuf",
		"tmp",
		"linesPerBuf",
		"i",
		"count",
		"i",
		"System",
		"data",
		"dataIndex",
		"buf",
		"bufOffset",
		"bpl",
		"bufOffset",
		"bmpBpl",
		"dataIndex",
		"imageBpl",
		"out",
		"buf",
		"bufOffset",
		"SWT",
		"SWT",
		"e",
		"bmpBpl",
		"image",
		"image",
		"image",
		"image",
		"image",
		"image",
		"image",
		"SWT",
		"SWT",
		"image",
		"image",
		"image",
		"image",
		"pal",
		"SWT",
		"SWT",
		"numCols",
		"rgbs",
		"pal",
		"SWT",
		"SWT",
		"numCols",
		"pal",
		"rgbs",
		"pal",
		"BMPFileHeaderSize",
		"BMPHeaderFixedSize",
		"fileHeader",
		"fileHeader",
		"fileHeader",
		"fileHeader",
		"fileHeader",
		"headersSize",
		"rgbs",
		"fileHeader",
		"rgbs",
		"image",
		"out",
		"out",
		"fileHeader",
		"fileHeader",
		"data",
		"outputStream",
		"fileHeader",
		"outputStream",
		"fileHeader",
		"outputStream",
		"fileHeader",
		"outputStream",
		"fileHeader",
		"outputStream",
		"fileHeader",
		"SWT",
		"SWT",
		"e",
		"outputStream",
		"BMPHeaderFixedSize",
		"outputStream",
		"image",
		"outputStream",
		"image",
		"outputStream",
		"outputStream",
		"image",
		"SWT",
		"SWT",
		"e",
		"numCols",
		"outputStream",
		"rgbs",
		"SWT",
		"SWT",
		"e",
		"outputStream",
		"data",
		"SWT",
		"SWT",
		"e",
		"height",
		"stride",
		"i",
		"height",
		"i",
		"index",
		"stride",
		"index",
		"data",
		"index",
		"i1",
		"data",
		"index",
		"i1",
		"data",
		"index",
		"i2",
		"data",
		"index",
		"i2",
		"b",
		"i1",
		"stride",
		"i2",
		"stride",
		"ERROR_INVALID_IMAGE",
		"ERROR_IO",
		"ERROR_IO",
		"ERROR_INVALID_IMAGE",
		"ERROR_IO",
		"ERROR_IO",
		"IMAGE_OS2_BMP",
		"length",
		"ERROR_INVALID_IMAGE",
		"ERROR_IO",
		"colors",
		"length",
		"colors",
		"length",
		"colors",
		"colors",
		"blue",
		"green",
		"red",
		"width",
		"depth",
		"data",
		"bytesPerLine",
		"height",
		"depth",
		"height",
		"height",
		"height",
		"height",
		"ERROR_IO",
		"height",
		"depth",
		"depth",
		"depth",
		"depth",
		"depth",
		"depth",
		"ERROR_UNSUPPORTED_DEPTH",
		"palette",
		"depth",
		"depth",
		"depth",
		"isDirect",
		"ERROR_INVALID_IMAGE",
		"isDirect",
		"ERROR_INVALID_IMAGE",
		"length",
		"colors",
		"length",
		"length",
		"ERROR_IO",
		"width",
		"height",
		"depth",
		"ERROR_IO",
		"ERROR_IO",
		"ERROR_IO",
		"stream",
		"e",
		"infoHeader",
		"infoHeader",
		"stride",
		"e",
		"e",
		"e",
		"e",
		"infoHeader",
		"e",
		"bytes",
		"numColors",
		"pal",
		"image",
		"out",
		"e",
		"image",
		"e",
		"e",
		"e",
		"e",
		"data",
		"stride",
		"height"
	],
	"extendORImplementFiles":[
		"FileFormat"
	],
	"package":[
		"org.eclipse.swt.internal.image"
	],
	"import":[
		"org.eclipse.swt",
		"org.eclipse.swt.graphics",
		"java.io"
	],
	"methods":[
		"isFileFormat",
		"loadData",
		"loadData",
		"loadFileHeader",
		"loadFromByteStream",
		"loadPalette",
		"paletteFromBytes",
		"paletteToBytes",
		"unloadData",
		"unloadIntoByteStream",
		"flipScanLines",
		"read",
		"unread",
		"loadData",
		"flipScanLines",
		"read",
		"error",
		"error",
		"readShort",
		"readInt",
		"readShort",
		"readShort",
		"readInt",
		"error",
		"error",
		"loadFileHeader",
		"read",
		"error",
		"loadPalette",
		"getPosition",
		"skip",
		"getPosition",
		"error",
		"loadData",
		"internal_new",
		"read",
		"error",
		"error",
		"paletteFromBytes",
		"write",
		"arraycopy",
		"write",
		"error",
		"error",
		"error",
		"error",
		"paletteToBytes",
		"unloadData",
		"toByteArray",
		"writeShort",
		"writeInt",
		"writeShort",
		"writeShort",
		"writeInt",
		"error",
		"writeInt",
		"writeShort",
		"writeShort",
		"writeShort",
		"writeShort",
		"error",
		"write",
		"error",
		"write",
		"error",
		"PaletteData",
		"PaletteData",
		"PaletteData",
		"RGB",
		"PaletteData",
		"ByteArrayOutputStream"
	],
	"methodsBody":{
		"ImageData[] loadFromByteStream()":{
			"methodBody":"{\n    int[] fileHeader = loadFileHeader();\n    byte[] infoHeader = new byte[BMPHeaderFixedSize];\n    try {\n        inputStream.read(infoHeader);\n    } catch (Exception e) {\n        SWT.error(SWT.ERROR_IO, e);\n    }\n    width = (infoHeader[4] & 0xFF) | ((infoHeader[5] & 0xFF) << 8);\n    height = (infoHeader[6] & 0xFF) | ((infoHeader[7] & 0xFF) << 8);\n    bitCount = (infoHeader[10] & 0xFF) | ((infoHeader[11] & 0xFF) << 8);\n    PaletteData palette = loadPalette(infoHeader);\n    if (inputStream.getPosition() < fileHeader[4]) {\n        \n        try {\n            inputStream.skip(fileHeader[4] - inputStream.getPosition());\n        } catch (IOException e) {\n            SWT.error(SWT.ERROR_IO, e);\n        }\n    }\n    byte[] data = loadData(infoHeader);\n    int type = SWT.IMAGE_OS2_BMP;\n    return new ImageData[] { ImageData.internal_new(width, height, bitCount, palette, 4, data, 0, null, null, -1, -1, type, 0, 0, 0, 0) };\n}",
			"comments":"// Seek to the specified offset\n",
			"methodName":"ImageData[] loadFromByteStream()"
		},
		"boolean isFileFormat(LEDataInputStream stream)":{
			"methodBody":"{\n    try {\n        byte[] header = new byte[18];\n        stream.read(header);\n        stream.unread(header);\n        int infoHeaderSize = (header[14] & 0xFF) | ((header[15] & 0xFF) << 8) | ((header[16] & 0xFF) << 16) | ((header[17] & 0xFF) << 24);\n        return header[0] == 0x42 && header[1] == 0x4D && infoHeaderSize == BMPHeaderFixedSize;\n    } catch (Exception e) {\n        return false;\n    }\n}",
			"comments":"",
			"methodName":"boolean isFileFormat(LEDataInputStream stream)"
		},
		"PaletteData paletteFromBytes(byte[] bytes, int numColors)":{
			"methodBody":"{\n    int bytesOffset = 0;\n    RGB[] colors = new RGB[numColors];\n    for (int i = 0; i < numColors; i++) {\n        colors[i] = new RGB(bytes[bytesOffset + 2] & 0xFF, bytes[bytesOffset + 1] & 0xFF, bytes[bytesOffset] & 0xFF);\n        bytesOffset += 3;\n    }\n    return new PaletteData(colors);\n}",
			"comments":"",
			"methodName":"PaletteData paletteFromBytes(byte[] bytes, int numColors)"
		},
		"void unloadIntoByteStream(ImageData image)":{
			"methodBody":"{\n    byte[] rgbs;\n    int numCols;\n    if (!((image.depth == 1) || (image.depth == 4) || (image.depth == 8) || (image.depth == 16) || (image.depth == 24) || (image.depth == 32)))\n        SWT.error(SWT.ERROR_UNSUPPORTED_DEPTH);\n    PaletteData pal = image.palette;\n    if ((image.depth == 16) || (image.depth == 24) || (image.depth == 32)) {\n        if (!pal.isDirect)\n            SWT.error(SWT.ERROR_INVALID_IMAGE);\n        numCols = 0;\n        rgbs = null;\n    } else {\n        if (pal.isDirect)\n            SWT.error(SWT.ERROR_INVALID_IMAGE);\n        numCols = pal.colors.length;\n        rgbs = paletteToBytes(pal);\n    }\n    \n    int headersSize = BMPFileHeaderSize + BMPHeaderFixedSize;\n    int[] fileHeader = new int[5];\n    \n    fileHeader[0] = 0x4D42;\n    \n    fileHeader[1] = 0;\n    \n    fileHeader[2] = 0;\n    \n    fileHeader[3] = 0;\n    \n    fileHeader[4] = headersSize;\n    if (rgbs != null) {\n        fileHeader[4] += rgbs.length;\n    }\n    \n    \n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n    unloadData(image, out);\n    byte[] data = out.toByteArray();\n    \n    fileHeader[1] = fileHeader[4] + data.length;\n    \n    try {\n        outputStream.writeShort(fileHeader[0]);\n        outputStream.writeInt(fileHeader[1]);\n        outputStream.writeShort(fileHeader[2]);\n        outputStream.writeShort(fileHeader[3]);\n        outputStream.writeInt(fileHeader[4]);\n    } catch (IOException e) {\n        SWT.error(SWT.ERROR_IO, e);\n    }\n    try {\n        outputStream.writeInt(BMPHeaderFixedSize);\n        outputStream.writeShort(image.width);\n        outputStream.writeShort(image.height);\n        outputStream.writeShort(1);\n        outputStream.writeShort((short) image.depth);\n    } catch (IOException e) {\n        SWT.error(SWT.ERROR_IO, e);\n    }\n    \n    if (numCols > 0) {\n        try {\n            outputStream.write(rgbs);\n        } catch (IOException e) {\n            SWT.error(SWT.ERROR_IO, e);\n        }\n    }\n    \n    try {\n        outputStream.write(data);\n    } catch (IOException e) {\n        SWT.error(SWT.ERROR_IO, e);\n    }\n}",
			"comments":"/**\n* Unload a DeviceIndependentImage using Windows .BMP format into the given\n* byte stream.\n*/\n// Fill in file header, except for bfsize, which is done later.\n// Signature\n// File size - filled in later\n// Reserved 1\n// Reserved 2\n// Offset to data\n// Prepare data. This is done first so we don't have to try to rewind\n// the stream and fill in the details later.\n// Calculate file size\n// Write the headers\n// Unload palette\n// Unload the data\n",
			"methodName":"void unloadIntoByteStream(ImageData image)"
		},
		"byte[] loadData(byte[] infoHeader, int stride)":{
			"methodBody":"{\n    int dataSize = height * stride;\n    byte[] data = new byte[dataSize];\n    try {\n        if (inputStream.read(data) != dataSize)\n            SWT.error(SWT.ERROR_INVALID_IMAGE);\n    } catch (IOException e) {\n        SWT.error(SWT.ERROR_IO, e);\n    }\n    return data;\n}",
			"comments":"",
			"methodName":"byte[] loadData(byte[] infoHeader, int stride)"
		},
		"PaletteData loadPalette(byte[] infoHeader)":{
			"methodBody":"{\n    if (bitCount <= 8) {\n        int numColors = 1 << bitCount;\n        byte[] buf = new byte[numColors * 3];\n        try {\n            if (inputStream.read(buf) != buf.length)\n                SWT.error(SWT.ERROR_INVALID_IMAGE);\n        } catch (IOException e) {\n            SWT.error(SWT.ERROR_IO, e);\n        }\n        return paletteFromBytes(buf, numColors);\n    }\n    if (bitCount == 16)\n        return new PaletteData(0x7C00, 0x3E0, 0x1F);\n    if (bitCount == 24)\n        return new PaletteData(0xFF, 0xFF00, 0xFF0000);\n    return new PaletteData(0xFF00, 0xFF0000, 0xFF000000);\n}",
			"comments":"",
			"methodName":"PaletteData loadPalette(byte[] infoHeader)"
		},
		"byte[] loadData(byte[] infoHeader)":{
			"methodBody":"{\n    int stride = (width * bitCount + 7) / 8;\n    \n    stride = (stride + 3) / 4 * 4;\n    byte[] data = loadData(infoHeader, stride);\n    flipScanLines(data, stride, height);\n    return data;\n}",
			"comments":"// Round up to 4 byte multiple\n",
			"methodName":"byte[] loadData(byte[] infoHeader)"
		},
		"int[] loadFileHeader()":{
			"methodBody":"{\n    int[] header = new int[5];\n    try {\n        header[0] = inputStream.readShort();\n        header[1] = inputStream.readInt();\n        header[2] = inputStream.readShort();\n        header[3] = inputStream.readShort();\n        header[4] = inputStream.readInt();\n    } catch (IOException e) {\n        SWT.error(SWT.ERROR_IO, e);\n    }\n    if (header[0] != 0x4D42)\n        SWT.error(SWT.ERROR_INVALID_IMAGE);\n    return header;\n}",
			"comments":"",
			"methodName":"int[] loadFileHeader()"
		},
		"int unloadData(ImageData image, OutputStream out)":{
			"methodBody":"{\n    int bmpBpl = 0;\n    try {\n        int bpl = (image.width * image.depth + 7) / 8;\n        \n        bmpBpl = (bpl + 3) / 4 * 4;\n        int linesPerBuf = 32678 / bmpBpl;\n        byte[] buf = new byte[linesPerBuf * bmpBpl];\n        byte[] data = image.data;\n        int imageBpl = image.bytesPerLine;\n        \n        int dataIndex = imageBpl * (image.height - 1);\n        if (image.depth == 16) {\n            for (int y = 0; y < image.height; y += linesPerBuf) {\n                int count = image.height - y;\n                if (linesPerBuf < count)\n                    count = linesPerBuf;\n                int bufOffset = 0;\n                for (int i = 0; i < count; i++) {\n                    for (int wIndex = 0; wIndex < bpl; wIndex += 2) {\n                        buf[bufOffset + wIndex + 1] = data[dataIndex + wIndex + 1];\n                        buf[bufOffset + wIndex] = data[dataIndex + wIndex];\n                    }\n                    bufOffset += bmpBpl;\n                    dataIndex -= imageBpl;\n                }\n                out.write(buf, 0, bufOffset);\n            }\n        } else {\n            for (int y = 0; y < image.height; y += linesPerBuf) {\n                int tmp = image.height - y;\n                int count = tmp < linesPerBuf ? tmp : linesPerBuf;\n                int bufOffset = 0;\n                for (int i = 0; i < count; i++) {\n                    System.arraycopy(data, dataIndex, buf, bufOffset, bpl);\n                    bufOffset += bmpBpl;\n                    dataIndex -= imageBpl;\n                }\n                out.write(buf, 0, bufOffset);\n            }\n        }\n    } catch (IOException e) {\n        SWT.error(SWT.ERROR_IO, e);\n    }\n    return bmpBpl * image.height;\n}",
			"comments":"/**\n* Unload the given image's data into the given byte stream.\n* Answer the number of bytes written.\n*/\n// BMP pads scanlines to multiples of 4 bytes\n// Start at last line\n",
			"methodName":"int unloadData(ImageData image, OutputStream out)"
		},
		"void flipScanLines(byte[] data, int stride, int height)":{
			"methodBody":"{\n    int i1 = 0;\n    int i2 = (height - 1) * stride;\n    for (int i = 0; i < height / 2; i++) {\n        for (int index = 0; index < stride; index++) {\n            byte b = data[index + i1];\n            data[index + i1] = data[index + i2];\n            data[index + i2] = b;\n        }\n        i1 += stride;\n        i2 -= stride;\n    }\n}",
			"comments":"",
			"methodName":"void flipScanLines(byte[] data, int stride, int height)"
		},
		"static byte[] paletteToBytes(PaletteData pal)":{
			"methodBody":"{\n    int n = pal.colors == null ? 0 : (pal.colors.length < 256 ? pal.colors.length : 256);\n    byte[] bytes = new byte[n * 3];\n    int offset = 0;\n    for (int i = 0; i < n; i++) {\n        RGB col = pal.colors[i];\n        bytes[offset] = (byte) col.blue;\n        bytes[offset + 1] = (byte) col.green;\n        bytes[offset + 2] = (byte) col.red;\n        offset += 3;\n    }\n    return bytes;\n}",
			"comments":"/**\n* Answer a byte array containing the BMP representation of\n* the given device independent palette.\n*/\n",
			"methodName":"static byte[] paletteToBytes(PaletteData pal)"
		}
	},
	"ClassORInterfaceName":[
		"OS2BMPFileFormat"
	]
}
