{
	"variables":[
		"filterNames",
		"filterExtensions",
		"fileNames",
		"filterPath",
		"fileName",
		"FILTER",
		"BUFFER_SIZE",
		"hHeap",
		"hwndOwner",
		"buffer3",
		"byteCount3",
		"lpstrTitle",
		"strFilter",
		"i",
		"filterName",
		"buffer4",
		"byteCount4",
		"lpstrFilter",
		"name",
		"nMaxFile",
		"byteCount",
		"lpstrFile",
		"byteCountFile",
		"path",
		"byteCount5",
		"lpstrInitialDir",
		"byteCountDir",
		"struct",
		"lpstrDefExt",
		"save",
		"oldModal",
		"display",
		"success",
		"fullPath",
		"buffer",
		"byteCount1",
		"nFileOffset",
		"index",
		"ch",
		"prefix",
		"byteCount2",
		"count",
		"start",
		"end",
		"string",
		"newFileNames",
		"separator",
		"length",
		"newFileNames",
		"parent",
		"SWT",
		"parent",
		"style",
		"fileName",
		"fileNames",
		"filterExtensions",
		"filterNames",
		"filterPath",
		"OS",
		"parent",
		"hwndOwner",
		"parent",
		"title",
		"title",
		"title",
		"buffer3",
		"TCHAR",
		"OS",
		"hHeap",
		"OS",
		"byteCount3",
		"OS",
		"lpstrTitle",
		"buffer3",
		"byteCount3",
		"filterNames",
		"filterNames",
		"filterExtensions",
		"filterExtensions",
		"i",
		"filterExtensions",
		"i",
		"filterExtensions",
		"i",
		"i",
		"filterNames",
		"filterName",
		"filterNames",
		"i",
		"strFilter",
		"strFilter",
		"filterName",
		"filterExtensions",
		"i",
		"filterExtensions",
		"strFilter",
		"strFilter",
		"FILTER",
		"FILTER",
		"strFilter",
		"buffer4",
		"TCHAR",
		"OS",
		"hHeap",
		"OS",
		"byteCount4",
		"OS",
		"lpstrFilter",
		"buffer4",
		"byteCount4",
		"fileName",
		"fileName",
		"fileName",
		"OS",
		"style",
		"SWT",
		"nMaxFile",
		"Math",
		"nMaxFile",
		"BUFFER_SIZE",
		"nMaxFile",
		"TCHAR",
		"OS",
		"hHeap",
		"OS",
		"byteCount",
		"Math",
		"name",
		"TCHAR",
		"byteCount",
		"TCHAR",
		"OS",
		"lpstrFile",
		"name",
		"byteCountFile",
		"filterPath",
		"filterPath",
		"filterPath",
		"OS",
		"TCHAR",
		"OS",
		"hHeap",
		"OS",
		"byteCount5",
		"Math",
		"path",
		"TCHAR",
		"byteCount5",
		"TCHAR",
		"OS",
		"lpstrInitialDir",
		"path",
		"byteCountDir",
		"struct",
		"OPENFILENAME",
		"struct",
		"OS",
		"OS",
		"style",
		"SWT",
		"struct",
		"OS",
		"OS",
		"struct",
		"hwndOwner",
		"struct",
		"lpstrTitle",
		"struct",
		"lpstrFile",
		"struct",
		"nMaxFile",
		"struct",
		"lpstrInitialDir",
		"struct",
		"lpstrFilter",
		"struct",
		"style",
		"SWT",
		"save",
		"lpstrDefExt",
		"OS",
		"hHeap",
		"OS",
		"TCHAR",
		"struct",
		"lpstrDefExt",
		"style",
		"SWT",
		"SWT",
		"display",
		"parent",
		"oldModal",
		"display",
		"display",
		"parent",
		"save",
		"OS",
		"struct",
		"OS",
		"struct",
		"OS",
		"OS",
		"OS",
		"lpstrFile",
		"TCHAR",
		"success",
		"save",
		"OS",
		"struct",
		"OS",
		"struct",
		"style",
		"SWT",
		"SWT",
		"display",
		"oldModal",
		"fileNames",
		"success",
		"struct",
		"buffer",
		"TCHAR",
		"OS",
		"buffer",
		"lpstrFile",
		"byteCount1",
		"struct",
		"OS",
		"nFileOffset",
		"index",
		"buffer",
		"buffer",
		"index",
		"ch",
		"ch",
		"nFileOffset",
		"index",
		"index",
		"nFileOffset",
		"nFileOffset",
		"prefix",
		"TCHAR",
		"OS",
		"prefix",
		"lpstrFile",
		"byteCount2",
		"filterPath",
		"prefix",
		"prefix",
		"fileNames",
		"style",
		"SWT",
		"nFileOffset",
		"start",
		"end",
		"buffer",
		"buffer",
		"end",
		"end",
		"buffer",
		"start",
		"end",
		"start",
		"start",
		"end",
		"count",
		"fileNames",
		"fileNames",
		"System",
		"fileNames",
		"newFileNames",
		"fileNames",
		"fileNames",
		"newFileNames",
		"fileNames",
		"count",
		"string",
		"style",
		"SWT",
		"start",
		"start",
		"buffer",
		"buffer",
		"start",
		"fileNames",
		"fileName",
		"fileNames",
		"filterPath",
		"length",
		"filterPath",
		"length",
		"separator",
		"fullPath",
		"filterPath",
		"separator",
		"fileName",
		"count",
		"fileNames",
		"count",
		"System",
		"fileNames",
		"newFileNames",
		"count",
		"fileNames",
		"newFileNames",
		"OS",
		"hHeap",
		"lpstrFile",
		"OS",
		"hHeap",
		"lpstrFilter",
		"OS",
		"hHeap",
		"lpstrInitialDir",
		"OS",
		"hHeap",
		"lpstrTitle",
		"lpstrDefExt",
		"OS",
		"hHeap",
		"lpstrDefExt",
		"fullPath",
		"fileName",
		"string",
		"filterExtensions",
		"extensions",
		"filterNames",
		"names",
		"filterPath",
		"string",
		"PRIMARY_MODAL",
		"handle",
		"sizeof",
		"HEAP_ZERO_MEMORY",
		"length",
		"length",
		"length",
		"sizeof",
		"HEAP_ZERO_MEMORY",
		"MAX_PATH",
		"MULTI",
		"sizeof",
		"HEAP_ZERO_MEMORY",
		"sizeof",
		"sizeof",
		"MAX_PATH",
		"sizeof",
		"HEAP_ZERO_MEMORY",
		"sizeof",
		"sizeof",
		"lStructSize",
		"sizeof",
		"Flags",
		"OFN_HIDEREADONLY",
		"OFN_NOCHANGEDIR",
		"MULTI",
		"Flags",
		"OFN_ALLOWMULTISELECT",
		"OFN_EXPLORER",
		"hwndOwner",
		"lpstrTitle",
		"lpstrFile",
		"nMaxFile",
		"lpstrInitialDir",
		"lpstrFilter",
		"nFilterIndex",
		"SAVE",
		"HEAP_ZERO_MEMORY",
		"sizeof",
		"lpstrDefExt",
		"APPLICATION_MODAL",
		"SYSTEM_MODAL",
		"FNERR_INVALIDFILENAME",
		"sizeof",
		"APPLICATION_MODAL",
		"SYSTEM_MODAL",
		"nMaxFile",
		"sizeof",
		"nFileOffset",
		"IsWinCE",
		"sizeof",
		"MULTI",
		"length",
		"length",
		"length",
		"MULTI",
		"length",
		"length",
		"parent",
		"parent",
		"style",
		"string",
		"extensions",
		"names",
		"string"
	],
	"extendORImplementFiles":[
		"Dialog"
	],
	"package":[
		"org.eclipse.swt.widgets"
	],
	"import":[
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt"
	],
	"methods":[
		"getFileName",
		"getFileNames",
		"getFilterExtensions",
		"getFilterNames",
		"getFilterPath",
		"open",
		"setFileName",
		"setFilterExtensions",
		"setFilterNames",
		"setFilterPath",
		"checkSubclass",
		"GetProcessHeap",
		"length",
		"HeapAlloc",
		"MoveMemory",
		"length",
		"HeapAlloc",
		"MoveMemory",
		"max",
		"HeapAlloc",
		"min",
		"length",
		"MoveMemory",
		"replace",
		"HeapAlloc",
		"min",
		"length",
		"MoveMemory",
		"HeapAlloc",
		"getDisplay",
		"getModalDialogShell",
		"setModalDialogShell",
		"GetSaveFileName",
		"GetOpenFileName",
		"CommDlgExtendedError",
		"MoveMemory",
		"GetSaveFileName",
		"GetOpenFileName",
		"setModalDialogShell",
		"length",
		"MoveMemory",
		"length",
		"tcharAt",
		"length",
		"MoveMemory",
		"toString",
		"length",
		"length",
		"tcharAt",
		"toString",
		"arraycopy",
		"length",
		"tcharAt",
		"length",
		"charAt",
		"arraycopy",
		"HeapFree",
		"HeapFree",
		"HeapFree",
		"HeapFree",
		"HeapFree",
		"TCHAR",
		"TCHAR",
		"TCHAR",
		"TCHAR",
		"OPENFILENAME",
		"TCHAR",
		"TCHAR",
		"TCHAR"
	],
	"methodsBody":{
		"public void setFileName(String string)":{
			"methodBody":"{\n    fileName = string;\n}",
			"comments":"/**\n* Set the initial filename which the dialog will\n* select by default when opened to the argument,\n* which may be null.  The name will be prefixed with\n* the filter path when one is supplied.\n*\n* @param string the file name\n*/\n",
			"methodName":"public void setFileName(String string)"
		},
		"public String[] getFilterExtensions()":{
			"methodBody":"{\n    return filterExtensions;\n}",
			"comments":"/**\n* Returns the file extensions which the dialog will\n* use to filter the files it shows.\n*\n* @return the file extensions filter\n*/\n",
			"methodName":"public String[] getFilterExtensions()"
		},
		"public String open()":{
			"methodBody":"{\n    int hHeap = OS.GetProcessHeap();\n    \n    int hwndOwner = 0;\n    if (parent != null)\n        hwndOwner = parent.handle;\n    \n    if (title == null)\n        title = \"\";\n    \n    TCHAR buffer3 = new TCHAR(0, title, true);\n    int byteCount3 = buffer3.length() * TCHAR.sizeof;\n    int lpstrTitle = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, byteCount3);\n    OS.MoveMemory(lpstrTitle, buffer3, byteCount3);\n    \n    String strFilter = \"\";\n    if (filterNames == null)\n        filterNames = new String[0];\n    if (filterExtensions == null)\n        filterExtensions = new String[0];\n    for (int i = 0; i < filterExtensions.length; i++) {\n        String filterName = filterExtensions[i];\n        if (i < filterNames.length)\n            filterName = filterNames[i];\n        strFilter = strFilter + filterName + '\\0' + filterExtensions[i] + '\\0';\n    }\n    if (filterExtensions.length == 0) {\n        strFilter = strFilter + FILTER + '\\0' + FILTER + '\\0';\n    }\n    \n    TCHAR buffer4 = new TCHAR(0, strFilter, true);\n    int byteCount4 = buffer4.length() * TCHAR.sizeof;\n    int lpstrFilter = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, byteCount4);\n    OS.MoveMemory(lpstrFilter, buffer4, byteCount4);\n    \n    if (fileName == null)\n        fileName = \"\";\n    \n    TCHAR name = new TCHAR(0, fileName, true);\n    \n    int nMaxFile = OS.MAX_PATH;\n    if ((style & SWT.MULTI) != 0)\n        nMaxFile = Math.max(nMaxFile, BUFFER_SIZE);\n    int byteCount = nMaxFile * TCHAR.sizeof;\n    int lpstrFile = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, byteCount);\n    int byteCountFile = Math.min(name.length() * TCHAR.sizeof, byteCount - TCHAR.sizeof);\n    OS.MoveMemory(lpstrFile, name, byteCountFile);\n    \n    if (filterPath == null)\n        filterPath = \"\";\n    \n    TCHAR path = new TCHAR(0, filterPath.replace('/', '\\\\'), true);\n    int byteCount5 = OS.MAX_PATH * TCHAR.sizeof;\n    int lpstrInitialDir = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, byteCount5);\n    int byteCountDir = Math.min(path.length() * TCHAR.sizeof, byteCount5 - TCHAR.sizeof);\n    OS.MoveMemory(lpstrInitialDir, path, byteCountDir);\n    \n    OPENFILENAME struct = new OPENFILENAME();\n    struct.lStructSize = OPENFILENAME.sizeof;\n    struct.Flags = OS.OFN_HIDEREADONLY | OS.OFN_NOCHANGEDIR;\n    if ((style & SWT.MULTI) != 0) {\n        struct.Flags |= OS.OFN_ALLOWMULTISELECT | OS.OFN_EXPLORER;\n    }\n    struct.hwndOwner = hwndOwner;\n    struct.lpstrTitle = lpstrTitle;\n    struct.lpstrFile = lpstrFile;\n    struct.nMaxFile = nMaxFile;\n    struct.lpstrInitialDir = lpstrInitialDir;\n    struct.lpstrFilter = lpstrFilter;\n    struct.nFilterIndex = 0;\n    \n    int lpstrDefExt = 0;\n    boolean save = (style & SWT.SAVE) != 0;\n    if (save) {\n        lpstrDefExt = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, TCHAR.sizeof);\n        struct.lpstrDefExt = lpstrDefExt;\n    }\n    \n    Shell oldModal = null;\n    Display display = null;\n    if ((style & (SWT.APPLICATION_MODAL | SWT.SYSTEM_MODAL)) != 0) {\n        display = parent.getDisplay();\n        oldModal = display.getModalDialogShell();\n        display.setModalDialogShell(parent);\n    }\n    \n    boolean success = (save) ? OS.GetSaveFileName(struct) : OS.GetOpenFileName(struct);\n    if (OS.CommDlgExtendedError() == OS.FNERR_INVALIDFILENAME) {\n        OS.MoveMemory(lpstrFile, new TCHAR(0, \"\", true), TCHAR.sizeof);\n        success = (save) ? OS.GetSaveFileName(struct) : OS.GetOpenFileName(struct);\n    }\n    \n    if ((style & (SWT.APPLICATION_MODAL | SWT.SYSTEM_MODAL)) != 0) {\n        display.setModalDialogShell(oldModal);\n    }\n    \n    fileNames = new String[0];\n    String fullPath = null;\n    if (success) {\n        \n        TCHAR buffer = new TCHAR(0, struct.nMaxFile);\n        int byteCount1 = buffer.length() * TCHAR.sizeof;\n        OS.MoveMemory(buffer, lpstrFile, byteCount1);\n        \n        int nFileOffset = struct.nFileOffset;\n        if (OS.IsWinCE && nFileOffset == 0) {\n            int index = 0;\n            while (index < buffer.length()) {\n                int ch = buffer.tcharAt(index);\n                if (ch == 0)\n                    break;\n                if (ch == '\\\\')\n                    nFileOffset = index + 1;\n                index++;\n            }\n        }\n        if (nFileOffset > 0) {\n            \n            TCHAR prefix = new TCHAR(0, nFileOffset - 1);\n            int byteCount2 = prefix.length() * TCHAR.sizeof;\n            OS.MoveMemory(prefix, lpstrFile, byteCount2);\n            filterPath = prefix.toString(0, prefix.length());\n            \n            int count = 0;\n            fileNames = new String[(style & SWT.MULTI) != 0 ? 4 : 1];\n            int start = nFileOffset;\n            do {\n                int end = start;\n                while (end < buffer.length() && buffer.tcharAt(end) != 0) end++;\n                String string = buffer.toString(start, end - start);\n                start = end;\n                if (count == fileNames.length) {\n                    String[] newFileNames = new String[fileNames.length + 4];\n                    System.arraycopy(fileNames, 0, newFileNames, 0, fileNames.length);\n                    fileNames = newFileNames;\n                }\n                fileNames[count++] = string;\n                if ((style & SWT.MULTI) == 0)\n                    break;\n                start++;\n            } while (start < buffer.length() && buffer.tcharAt(start) != 0);\n            if (fileNames.length > 0)\n                fileName = fileNames[0];\n            String separator = \"\";\n            int length = filterPath.length();\n            if (length > 0 && filterPath.charAt(length - 1) != '\\\\') {\n                separator = \"\\\\\";\n            }\n            fullPath = filterPath + separator + fileName;\n            if (count < fileNames.length) {\n                String[] newFileNames = new String[count];\n                System.arraycopy(fileNames, 0, newFileNames, 0, count);\n                fileNames = newFileNames;\n            }\n        }\n    }\n    \n    OS.HeapFree(hHeap, 0, lpstrFile);\n    OS.HeapFree(hHeap, 0, lpstrFilter);\n    OS.HeapFree(hHeap, 0, lpstrInitialDir);\n    OS.HeapFree(hHeap, 0, lpstrTitle);\n    if (lpstrDefExt != 0)\n        OS.HeapFree(hHeap, 0, lpstrDefExt);\n    \n    return fullPath;\n}",
			"comments":"/**\n* Makes the dialog visible and brings it to the front\n* of the display.\n*\n* @return a string describing the absolute path of the first selected file,\n*         or null if the dialog was cancelled or an error occurred\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the dialog has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the dialog</li>\n* </ul>\n*/\n/* Get the owner HWND for the dialog */\n/* Convert the title and copy it into lpstrTitle */\n/* Use the character encoding for the default locale */\n/* Compute filters and copy into lpstrFilter */\n/* Use the character encoding for the default locale */\n/* Convert the fileName and filterName to C strings */\n/* Use the character encoding for the default locale */\n/*\n* Copy the name into lpstrFile and ensure that the\n* last byte is NULL and the buffer does not overrun.\n*/\n/*\n* Copy the path into lpstrInitialDir and ensure that\n* the last byte is NULL and the buffer does not overrun.\n*/\n/* Use the character encoding for the default locale */\n/* Create the file dialog struct */\n/*\n* Set the default extension to an empty string.  If the\n* user fails to type an extension and this extension is\n* empty, Windows uses the current value of the filter\n* extension at the time that the dialog is closed.\n*/\n/* Make the parent shell be temporary modal */\n/*\n* Open the dialog.  If the open fails due to an invalid\n* file name, use an empty file name and open it again.\n*/\n/* Clear the temporary dialog modal parent */\n/* Set the new path, file name and filter */\n/* Use the character encoding for the default locale */\n/*\n* Bug in WinCE.  For some reason, nFileOffset and nFileExtension\n* are always zero on WinCE HPC. nFileOffset is always zero on\n* WinCE PPC when using GetSaveFileName.  nFileOffset is correctly\n* set on WinCE PPC when using OpenFileName.  The fix is to parse\n* lpstrFile to calculate nFileOffset.\n*\n* Note: WinCE does not support multi-select file dialogs.\n*/\n/* Use the character encoding for the default locale */\n/*\n* Get each file from the buffer.  Files are delimited\n* by a NULL character with 2 NULL characters at the end.\n*/\n/* Free the memory that was allocated. */\n/*\n* This code is intentionally commented.  On some\n* platforms, the owner window is repainted right\n* away when a dialog window exits.  This behavior\n* is currently unspecified.\n*/\n//\tif (hwndOwner != 0) OS.UpdateWindow (hwndOwner);\n/* Answer the full path or null */\n",
			"methodName":"public String open()"
		},
		"public void setFilterPath(String string)":{
			"methodBody":"{\n    filterPath = string;\n}",
			"comments":"/**\n* Sets the directory path that the dialog will use\n* to the argument, which may be null. File names in this\n* path will appear in the dialog, filtered according\n* to the filter extensions. If the string is null,\n* then the operating system's default filter path\n* will be used.\n* <p>\n* Note that the path string is platform dependent.\n* For convenience, either '/' or '\\' can be used\n* as a path separator.\n* </p>\n*\n* @param string the directory path\n*\n* @see #setFilterExtensions\n*/\n",
			"methodName":"public void setFilterPath(String string)"
		},
		"public String[] getFileNames()":{
			"methodBody":"{\n    return fileNames;\n}",
			"comments":"/**\n* Returns a (possibly empty) array with the paths of all files\n* that were selected in the dialog relative to the filter path.\n*\n* @return the relative paths of the files\n*/\n",
			"methodName":"public String[] getFileNames()"
		},
		"public String[] getFilterNames()":{
			"methodBody":"{\n    return filterNames;\n}",
			"comments":"/**\n* Returns the names that describe the filter extensions\n* which the dialog will use to filter the files it shows.\n*\n* @return the list of filter names\n*/\n",
			"methodName":"public String[] getFilterNames()"
		},
		"public String getFilterPath()":{
			"methodBody":"{\n    return filterPath;\n}",
			"comments":"/**\n* Returns the directory path that the dialog will use, or an empty\n* string if this is not set.  File names in this path will appear\n* in the dialog, filtered according to the filter extensions.\n*\n* @return the directory path string\n*\n* @see #setFilterExtensions\n*/\n",
			"methodName":"public String getFilterPath()"
		},
		"public void setFilterExtensions(String[] extensions)":{
			"methodBody":"{\n    filterExtensions = extensions;\n}",
			"comments":"/**\n* Set the file extensions which the dialog will\n* use to filter the files it shows to the argument,\n* which may be null.\n* <p>\n* The strings are platform specific. For example, on\n* Windows, an extension filter string is typically of\n* the form \"*.extension\", where \"*.*\" matches all files.\n* </p>\n*\n* @param extensions the file extension filter\n*/\n",
			"methodName":"public void setFilterExtensions(String[] extensions)"
		},
		"public String getFileName()":{
			"methodBody":"{\n    return fileName;\n}",
			"comments":"/**\n* Returns the path of the first file that was\n* selected in the dialog relative to the filter path, or an\n* empty string if no such file has been selected.\n*\n* @return the relative path of the file\n*/\n",
			"methodName":"public String getFileName()"
		},
		"public void setFilterNames(String[] names)":{
			"methodBody":"{\n    filterNames = names;\n}",
			"comments":"/**\n* Sets the the names that describe the filter extensions\n* which the dialog will use to filter the files it shows\n* to the argument, which may be null.\n*\n* @param names the list of filter names\n*/\n",
			"methodName":"public void setFilterNames(String[] names)"
		}
	},
	"ClassORInterfaceName":[
		"FileDialog"
	]
}
