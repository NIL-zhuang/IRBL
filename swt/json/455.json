{
	"variables":[
		"parent",
		"menu",
		"id",
		"accelerator",
		"typedListener",
		"typedListener",
		"typedListener",
		"fVirt",
		"key",
		"vKey",
		"index",
		"shell",
		"hwndShell",
		"info1",
		"info2",
		"x",
		"y",
		"width",
		"height",
		"hMenu",
		"rect1",
		"rect2",
		"x",
		"y",
		"width",
		"height",
		"hwndCB",
		"info",
		"hMenu",
		"info",
		"success",
		"index",
		"hMenu",
		"info",
		"success",
		"index",
		"items",
		"i",
		"j",
		"hwndCB",
		"info",
		"hMenu",
		"index",
		"uEnable",
		"info",
		"success",
		"bits",
		"hwndCB",
		"info",
		"info",
		"hMenu",
		"oldMenu",
		"hwndCB",
		"hMenu",
		"hMenu",
		"info",
		"index",
		"hasBitmap",
		"success",
		"cch",
		"hHeap",
		"byteCount",
		"pszText",
		"uIDNewItem",
		"uFlags",
		"lpNewItem",
		"hMenu",
		"index",
		"uCheck",
		"info",
		"success",
		"hHeap",
		"pszText",
		"success",
		"length",
		"text",
		"i",
		"j",
		"buffer",
		"byteCount",
		"hwndCB",
		"info2",
		"info",
		"hMenu",
		"hasBitmap",
		"buffer",
		"byteCount",
		"bits",
		"shell",
		"event",
		"struct",
		"data",
		"gc",
		"x",
		"struct",
		"width",
		"height",
		"rect",
		"lpcmi",
		"hMenu",
		"items",
		"i",
		"item",
		"rect",
		"parent",
		"style",
		"parent",
		"parent",
		"parent",
		"parent",
		"style",
		"parent",
		"parent",
		"index",
		"parent",
		"style",
		"parent",
		"menu",
		"menu",
		"menu",
		"display",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"SWT",
		"typedListener",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"accel",
		"accel",
		"accel",
		"accelerator",
		"OS",
		"accelerator",
		"SWT",
		"Display",
		"key",
		"vKey",
		"key",
		"vKey",
		"key",
		"key",
		"OS",
		"key",
		"OS",
		"key",
		"Display",
		"key",
		"key",
		"OS",
		"key",
		"OS",
		"key",
		"vKey",
		"OS",
		"key",
		"vKey",
		"fVirt",
		"key",
		"vKey",
		"accel",
		"key",
		"accel",
		"id",
		"accel",
		"fVirt",
		"accelerator",
		"SWT",
		"accel",
		"OS",
		"accelerator",
		"SWT",
		"accel",
		"OS",
		"accelerator",
		"SWT",
		"accel",
		"OS",
		"menu",
		"menu",
		"newParent",
		"accelerator",
		"OS",
		"parent",
		"index",
		"parent",
		"SWT",
		"parent",
		"shell",
		"parent",
		"shell",
		"info1",
		"MENUBARINFO",
		"OS",
		"hwndShell",
		"OS",
		"info1",
		"info2",
		"MENUBARINFO",
		"OS",
		"hwndShell",
		"OS",
		"index",
		"info2",
		"info2",
		"info1",
		"info2",
		"info1",
		"info2",
		"info2",
		"info2",
		"info2",
		"x",
		"y",
		"width",
		"height",
		"parent",
		"OS",
		"hMenu",
		"rect1",
		"OS",
		"hMenu",
		"index",
		"rect2",
		"rect2",
		"rect1",
		"rect2",
		"rect1",
		"rect2",
		"rect2",
		"rect2",
		"rect2",
		"x",
		"y",
		"width",
		"height",
		"OS",
		"OS",
		"parent",
		"parent",
		"info",
		"TBBUTTONINFO",
		"info",
		"OS",
		"OS",
		"hwndCB",
		"OS",
		"id",
		"info",
		"info",
		"OS",
		"parent",
		"info",
		"MENUITEMINFO",
		"info",
		"OS",
		"OS",
		"parent",
		"index",
		"SWT",
		"success",
		"OS",
		"hMenu",
		"index",
		"info",
		"success",
		"OS",
		"hMenu",
		"id",
		"info",
		"success",
		"SWT",
		"info",
		"OS",
		"OS",
		"menu",
		"style",
		"SWT",
		"parent",
		"style",
		"SWT",
		"SWT",
		"OS",
		"OS",
		"parent",
		"parent",
		"info",
		"MENUITEMINFO",
		"info",
		"OS",
		"OS",
		"hMenu",
		"id",
		"info",
		"success",
		"SWT",
		"info",
		"OS",
		"parent",
		"menu",
		"menu",
		"menu",
		"parent",
		"OS",
		"menu",
		"menu",
		"menu",
		"menu",
		"accelerator",
		"parent",
		"accelerator",
		"display",
		"parent",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"eventTable",
		"SWT",
		"listener",
		"parent",
		"index",
		"items",
		"items",
		"index",
		"index",
		"index",
		"i",
		"items",
		"i",
		"i",
		"index",
		"j",
		"items",
		"items",
		"j",
		"j",
		"accelerator",
		"accelerator",
		"parent",
		"OS",
		"OS",
		"parent",
		"parent",
		"info",
		"TBBUTTONINFO",
		"info",
		"OS",
		"OS",
		"hwndCB",
		"OS",
		"id",
		"info",
		"info",
		"OS",
		"enabled",
		"info",
		"OS",
		"OS",
		"hwndCB",
		"OS",
		"id",
		"info",
		"parent",
		"OS",
		"parent",
		"index",
		"OS",
		"enabled",
		"OS",
		"OS",
		"OS",
		"hMenu",
		"index",
		"uEnable",
		"info",
		"MENUITEMINFO",
		"info",
		"OS",
		"OS",
		"hMenu",
		"id",
		"info",
		"success",
		"SWT",
		"OS",
		"OS",
		"enabled",
		"info",
		"bits",
		"info",
		"bits",
		"info",
		"bits",
		"bits",
		"info",
		"bits",
		"success",
		"OS",
		"hMenu",
		"id",
		"info",
		"success",
		"SWT",
		"parent",
		"parent",
		"style",
		"SWT",
		"image",
		"OS",
		"OS",
		"OS",
		"parent",
		"parent",
		"info",
		"TBBUTTONINFO",
		"info",
		"OS",
		"info",
		"parent",
		"image",
		"OS",
		"hwndCB",
		"OS",
		"id",
		"info",
		"OS",
		"OS",
		"info",
		"MENUITEMINFO",
		"info",
		"OS",
		"image",
		"info",
		"OS",
		"parent",
		"OS",
		"hMenu",
		"id",
		"info",
		"parent",
		"style",
		"SWT",
		"SWT",
		"menu",
		"menu",
		"SWT",
		"menu",
		"SWT",
		"SWT",
		"menu",
		"parent",
		"SWT",
		"oldMenu",
		"menu",
		"oldMenu",
		"oldMenu",
		"menu",
		"OS",
		"OS",
		"parent",
		"OS",
		"parent",
		"menu",
		"menu",
		"OS",
		"hwndCB",
		"OS",
		"id",
		"hMenu",
		"OS",
		"SWT",
		"parent",
		"info",
		"MENUITEMINFO",
		"info",
		"OS",
		"OS",
		"hMenu",
		"index",
		"info",
		"info",
		"id",
		"index",
		"info",
		"id",
		"OS",
		"OS",
		"OS",
		"info",
		"OS",
		"OS",
		"hMenu",
		"index",
		"info",
		"hasBitmap",
		"info",
		"hasBitmap",
		"info",
		"success",
		"OS",
		"hMenu",
		"id",
		"info",
		"OS",
		"cch",
		"TCHAR",
		"OS",
		"hHeap",
		"OS",
		"byteCount",
		"info",
		"OS",
		"OS",
		"OS",
		"OS",
		"info",
		"pszText",
		"info",
		"cch",
		"success",
		"OS",
		"hMenu",
		"index",
		"info",
		"menu",
		"menu",
		"info",
		"OS",
		"info",
		"menu",
		"OS",
		"hMenu",
		"index",
		"OS",
		"OS",
		"id",
		"OS",
		"menu",
		"uFlags",
		"OS",
		"uIDNewItem",
		"menu",
		"success",
		"OS",
		"hMenu",
		"index",
		"uFlags",
		"uIDNewItem",
		"lpNewItem",
		"success",
		"info",
		"OS",
		"OS",
		"success",
		"OS",
		"hMenu",
		"index",
		"info",
		"info",
		"OS",
		"OS",
		"OS",
		"hMenu",
		"index",
		"OS",
		"OS",
		"info",
		"OS",
		"OS",
		"hMenu",
		"index",
		"OS",
		"OS",
		"success",
		"OS",
		"hMenu",
		"index",
		"info",
		"OS",
		"OS",
		"hasBitmap",
		"info",
		"OS",
		"info",
		"OS",
		"success",
		"OS",
		"hMenu",
		"id",
		"info",
		"pszText",
		"OS",
		"hHeap",
		"pszText",
		"success",
		"SWT",
		"parent",
		"style",
		"SWT",
		"value",
		"value",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"OS",
		"OS",
		"parent",
		"parent",
		"OS",
		"parent",
		"index",
		"OS",
		"selected",
		"OS",
		"OS",
		"OS",
		"hMenu",
		"index",
		"uCheck",
		"info",
		"MENUITEMINFO",
		"info",
		"OS",
		"OS",
		"hMenu",
		"id",
		"info",
		"success",
		"SWT",
		"info",
		"OS",
		"selected",
		"info",
		"OS",
		"success",
		"OS",
		"hMenu",
		"id",
		"info",
		"success",
		"SWT",
		"parent",
		"string",
		"SWT",
		"style",
		"SWT",
		"text",
		"string",
		"string",
		"OS",
		"OS",
		"OS",
		"parent",
		"string",
		"string",
		"length",
		"string",
		"length",
		"text",
		"i",
		"i",
		"length",
		"i",
		"text",
		"i",
		"text",
		"j",
		"text",
		"i",
		"j",
		"i",
		"string",
		"text",
		"j",
		"string",
		"buffer",
		"TCHAR",
		"pszText",
		"OS",
		"hHeap",
		"OS",
		"byteCount",
		"OS",
		"pszText",
		"buffer",
		"byteCount",
		"parent",
		"info2",
		"TBBUTTONINFO",
		"info2",
		"OS",
		"info2",
		"pszText",
		"success",
		"OS",
		"hwndCB",
		"OS",
		"id",
		"info2",
		"info",
		"MENUITEMINFO",
		"parent",
		"OS",
		"OS",
		"OS",
		"info",
		"OS",
		"OS",
		"hMenu",
		"id",
		"info",
		"hasBitmap",
		"info",
		"string",
		"buffer",
		"TCHAR",
		"pszText",
		"OS",
		"hHeap",
		"OS",
		"byteCount",
		"OS",
		"pszText",
		"buffer",
		"byteCount",
		"info",
		"OS",
		"info",
		"info",
		"pszText",
		"success",
		"OS",
		"hMenu",
		"id",
		"info",
		"OS",
		"OS",
		"OS",
		"hasBitmap",
		"info",
		"OS",
		"info",
		"OS",
		"success",
		"OS",
		"hMenu",
		"id",
		"info",
		"pszText",
		"OS",
		"hHeap",
		"pszText",
		"success",
		"SWT",
		"parent",
		"parent",
		"shell",
		"SWT",
		"parent",
		"SWT",
		"bits",
		"OS",
		"OS",
		"parent",
		"SWT",
		"bits",
		"OS",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"bits",
		"OS",
		"style",
		"SWT",
		"style",
		"SWT",
		"parent",
		"SWT",
		"event",
		"SWT",
		"SWT",
		"event",
		"OS",
		"struct",
		"lParam",
		"DRAWITEMSTRUCT",
		"image",
		"data",
		"display",
		"GC",
		"struct",
		"data",
		"parent",
		"SWT",
		"OS",
		"struct",
		"gc",
		"image",
		"x",
		"struct",
		"gc",
		"OS",
		"struct",
		"lParam",
		"MEASUREITEMSTRUCT",
		"image",
		"image",
		"width",
		"rect",
		"height",
		"rect",
		"lpcmi",
		"MENUINFO",
		"lpcmi",
		"OS",
		"parent",
		"OS",
		"hMenu",
		"lpcmi",
		"lpcmi",
		"OS",
		"parent",
		"i",
		"items",
		"i",
		"items",
		"i",
		"item",
		"item",
		"width",
		"Math",
		"width",
		"rect",
		"width",
		"height",
		"struct",
		"width",
		"OS",
		"struct",
		"height",
		"OS",
		"lParam",
		"struct",
		"MEASUREITEMSTRUCT",
		"parent",
		"parent",
		"parent",
		"menu",
		"cascade",
		"ERROR_NULL_ARGUMENT",
		"Arm",
		"ERROR_NULL_ARGUMENT",
		"Help",
		"ERROR_NULL_ARGUMENT",
		"Selection",
		"DefaultSelection",
		"ERROR_INVALID_SUBCLASS",
		"PUSH",
		"CHECK",
		"RADIO",
		"SEPARATOR",
		"CASCADE",
		"fVirt",
		"cmd",
		"key",
		"FVIRTKEY",
		"KEY_MASK",
		"VK_ESCAPE",
		"VK_DELETE",
		"IsWinCE",
		"key",
		"cmd",
		"fVirt",
		"ALT",
		"fVirt",
		"FALT",
		"SHIFT",
		"fVirt",
		"FSHIFT",
		"CONTROL",
		"fVirt",
		"FCONTROL",
		"IsWinCE",
		"style",
		"BAR",
		"parent",
		"menuBar",
		"handle",
		"cbSize",
		"sizeof",
		"OBJID_MENU",
		"cbSize",
		"sizeof",
		"OBJID_MENU",
		"left",
		"left",
		"top",
		"top",
		"right",
		"left",
		"bottom",
		"top",
		"handle",
		"left",
		"left",
		"top",
		"top",
		"right",
		"left",
		"bottom",
		"top",
		"IsPPC",
		"IsSP",
		"hwndCB",
		"hwndCB",
		"cbSize",
		"sizeof",
		"dwMask",
		"TBIF_STATE",
		"TB_GETBUTTONINFO",
		"fsState",
		"TBSTATE_ENABLED",
		"handle",
		"cbSize",
		"sizeof",
		"fMask",
		"MIIM_STATE",
		"IsWinCE",
		"ERROR_CANNOT_GET_ENABLED",
		"ERROR_CANNOT_GET_ENABLED",
		"fState",
		"MFS_DISABLED",
		"MFS_GRAYED",
		"SEPARATOR",
		"CHECK",
		"RADIO",
		"IsPPC",
		"IsSP",
		"hwndCB",
		"handle",
		"cbSize",
		"sizeof",
		"fMask",
		"MIIM_STATE",
		"ERROR_CANNOT_GET_SELECTION",
		"fState",
		"MFS_CHECKED",
		"IsSP",
		"ERROR_NULL_ARGUMENT",
		"Arm",
		"ERROR_NULL_ARGUMENT",
		"Help",
		"ERROR_NULL_ARGUMENT",
		"Selection",
		"DefaultSelection",
		"length",
		"length",
		"accelerator",
		"accelerator",
		"IsPPC",
		"IsSP",
		"hwndCB",
		"hwndCB",
		"cbSize",
		"sizeof",
		"dwMask",
		"TBIF_STATE",
		"TB_GETBUTTONINFO",
		"fsState",
		"TBSTATE_ENABLED",
		"fsState",
		"TBSTATE_ENABLED",
		"TB_SETBUTTONINFO",
		"handle",
		"IsWinCE",
		"MF_BYPOSITION",
		"MF_ENABLED",
		"MF_GRAYED",
		"cbSize",
		"sizeof",
		"fMask",
		"MIIM_STATE",
		"ERROR_CANNOT_SET_ENABLED",
		"MFS_DISABLED",
		"MFS_GRAYED",
		"fState",
		"fState",
		"fState",
		"fState",
		"ERROR_CANNOT_SET_ENABLED",
		"SEPARATOR",
		"IsWinCE",
		"IsPPC",
		"IsSP",
		"hwndCB",
		"hwndCB",
		"cbSize",
		"sizeof",
		"dwMask",
		"TBIF_IMAGE",
		"iImage",
		"TB_SETBUTTONINFO",
		"WIN32_VERSION",
		"cbSize",
		"sizeof",
		"fMask",
		"MIIM_BITMAP",
		"hbmpItem",
		"HBMMENU_CALLBACK",
		"handle",
		"CASCADE",
		"ERROR_MENUITEM_NOT_CASCADE",
		"ERROR_INVALID_ARGUMENT",
		"style",
		"DROP_DOWN",
		"ERROR_MENU_NOT_DROP_DOWN",
		"parent",
		"parent",
		"ERROR_INVALID_PARENT",
		"menu",
		"cascade",
		"menu",
		"IsPPC",
		"IsSP",
		"hwndCB",
		"IsPPC",
		"hwndCB",
		"handle",
		"SHCMBM_SETSUBMENU",
		"IsSP",
		"ERROR_CANNOT_SET_MENU",
		"handle",
		"cbSize",
		"sizeof",
		"fMask",
		"MIIM_DATA",
		"dwItemData",
		"dwItemData",
		"IsWinCE",
		"WIN32_VERSION",
		"fMask",
		"MIIM_BITMAP",
		"hbmpItem",
		"hbmpItem",
		"sizeof",
		"HEAP_ZERO_MEMORY",
		"fMask",
		"MIIM_STATE",
		"MIIM_ID",
		"MIIM_TYPE",
		"MIIM_DATA",
		"dwTypeData",
		"cch",
		"cascade",
		"fMask",
		"MIIM_SUBMENU",
		"hSubMenu",
		"handle",
		"MF_BYPOSITION",
		"IsWinCE",
		"MF_BYPOSITION",
		"MF_POPUP",
		"handle",
		"fMask",
		"MIIM_DATA",
		"MIIM_TYPE",
		"fState",
		"MFS_DISABLED",
		"MFS_GRAYED",
		"MF_BYPOSITION",
		"MF_GRAYED",
		"fState",
		"MFS_CHECKED",
		"MF_BYPOSITION",
		"MF_CHECKED",
		"WIN32_VERSION",
		"fMask",
		"MIIM_BITMAP",
		"hbmpItem",
		"HBMMENU_CALLBACK",
		"ERROR_CANNOT_SET_MENU",
		"RADIO",
		"Selection",
		"CHECK",
		"RADIO",
		"IsPPC",
		"IsSP",
		"hwndCB",
		"handle",
		"IsWinCE",
		"MF_BYPOSITION",
		"MF_CHECKED",
		"MF_UNCHECKED",
		"cbSize",
		"sizeof",
		"fMask",
		"MIIM_STATE",
		"ERROR_CANNOT_SET_SELECTION",
		"fState",
		"MFS_CHECKED",
		"fState",
		"MFS_CHECKED",
		"ERROR_CANNOT_SET_SELECTION",
		"ERROR_NULL_ARGUMENT",
		"SEPARATOR",
		"IsPPC",
		"IsSP",
		"hwndCB",
		"sizeof",
		"HEAP_ZERO_MEMORY",
		"hwndCB",
		"cbSize",
		"sizeof",
		"dwMask",
		"TBIF_TEXT",
		"pszText",
		"TB_SETBUTTONINFO",
		"cbSize",
		"sizeof",
		"handle",
		"IsWinCE",
		"WIN32_VERSION",
		"fMask",
		"MIIM_BITMAP",
		"hbmpItem",
		"sizeof",
		"HEAP_ZERO_MEMORY",
		"fMask",
		"MIIM_TYPE",
		"fType",
		"dwTypeData",
		"IsWinCE",
		"WIN32_VERSION",
		"fMask",
		"MIIM_BITMAP",
		"hbmpItem",
		"HBMMENU_CALLBACK",
		"ERROR_CANNOT_SET_TEXT",
		"parent",
		"style",
		"MIRRORED",
		"style",
		"LEFT_TO_RIGHT",
		"MFT_RIGHTJUSTIFY",
		"MFT_RIGHTORDER",
		"style",
		"RIGHT_TO_LEFT",
		"MFT_RIGHTJUSTIFY",
		"MFT_RIGHTORDER",
		"SEPARATOR",
		"MFT_SEPARATOR",
		"RADIO",
		"MFT_RADIOCHECK",
		"MFT_STRING",
		"CHECK",
		"RADIO",
		"NO_RADIO_GROUP",
		"Selection",
		"Selection",
		"sizeof",
		"device",
		"hDC",
		"style",
		"BAR",
		"IsWin95",
		"left",
		"top",
		"sizeof",
		"width",
		"height",
		"cbSize",
		"sizeof",
		"fMask",
		"MIM_STYLE",
		"handle",
		"dwStyle",
		"MNS_CHECKORBMP",
		"length",
		"image",
		"image",
		"width",
		"itemWidth",
		"IsWin95",
		"itemHeight",
		"sizeof",
		"parent",
		"style",
		"parent",
		"style",
		"index",
		"parent",
		"menu",
		"style",
		"index",
		"listener",
		"listener",
		"listener",
		"style",
		"accel",
		"newParent",
		"listener",
		"listener",
		"listener",
		"accelerator",
		"enabled",
		"image",
		"menu",
		"value",
		"selected",
		"string",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam"
	],
	"extendORImplementFiles":[
		"Item"
	],
	"package":[
		"org.eclipse.swt.widgets"
	],
	"import":[
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt",
		"org.eclipse.swt.graphics",
		"org.eclipse.swt.events"
	],
	"methods":[
		"addArmListener",
		"addHelpListener",
		"addSelectionListener",
		"checkSubclass",
		"checkStyle",
		"fillAccel",
		"fixMenus",
		"getAccelerator",
		"getBounds",
		"getEnabled",
		"getMenu",
		"getNameText",
		"getParent",
		"getSelection",
		"isEnabled",
		"releaseChild",
		"releaseMenu",
		"releaseWidget",
		"removeArmListener",
		"removeHelpListener",
		"removeSelectionListener",
		"selectRadio",
		"setAccelerator",
		"setEnabled",
		"setImage",
		"setMenu",
		"setRadioSelection",
		"setSelection",
		"setText",
		"widgetStyle",
		"wmCommandChild",
		"wmDrawChild",
		"wmMeasureChild",
		"checkStyle",
		"createItem",
		"getItemCount",
		"checkStyle",
		"createItem",
		"checkStyle",
		"addMenuItem",
		"checkWidget",
		"error",
		"addListener",
		"checkWidget",
		"error",
		"addListener",
		"checkWidget",
		"error",
		"addListener",
		"addListener",
		"isValidSubclass",
		"error",
		"checkBits",
		"getEnabled",
		"untranslateKey",
		"wcsToMbcs",
		"CharUpper",
		"VkKeyScan",
		"fixMenus",
		"checkWidget",
		"checkWidget",
		"indexOf",
		"GetMenuBarInfo",
		"GetMenuBarInfo",
		"GetMenuItemRect",
		"GetMenuItemRect",
		"checkWidget",
		"SendMessage",
		"indexOf",
		"error",
		"GetMenuItemInfo",
		"GetMenuItemInfo",
		"error",
		"checkWidget",
		"getNameText",
		"checkWidget",
		"checkWidget",
		"GetMenuItemInfo",
		"error",
		"getEnabled",
		"isEnabled",
		"releaseChild",
		"dispose",
		"destroyItem",
		"setMenu",
		"releaseResources",
		"releaseWidget",
		"destroyAccelerators",
		"removeMenuItem",
		"checkWidget",
		"error",
		"unhook",
		"checkWidget",
		"error",
		"unhook",
		"checkWidget",
		"error",
		"unhook",
		"unhook",
		"getItems",
		"setRadioSelection",
		"setRadioSelection",
		"setSelection",
		"checkWidget",
		"destroyAccelerators",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"indexOf",
		"EnableMenuItem",
		"GetMenuItemInfo",
		"error",
		"SetMenuItemInfo",
		"error",
		"destroyAccelerators",
		"redraw",
		"checkWidget",
		"setImage",
		"imageIndex",
		"SendMessage",
		"VERSION",
		"SetMenuItemInfo",
		"redraw",
		"checkWidget",
		"error",
		"isDisposed",
		"error",
		"error",
		"error",
		"SendMessage",
		"error",
		"GetMenuItemInfo",
		"VERSION",
		"GetMenuItemInfo",
		"SetMenuItemInfo",
		"GetProcessHeap",
		"HeapAlloc",
		"GetMenuItemInfo",
		"RemoveMenu",
		"InsertMenu",
		"SetMenuItemInfo",
		"EnableMenuItem",
		"CheckMenuItem",
		"InsertMenuItem",
		"VERSION",
		"SetMenuItemInfo",
		"HeapFree",
		"error",
		"destroyAccelerators",
		"getSelection",
		"setSelection",
		"postEvent",
		"checkWidget",
		"indexOf",
		"CheckMenuItem",
		"GetMenuItemInfo",
		"error",
		"SetMenuItemInfo",
		"error",
		"redraw",
		"checkWidget",
		"error",
		"equals",
		"setText",
		"GetProcessHeap",
		"indexOf",
		"length",
		"getChars",
		"length",
		"HeapAlloc",
		"MoveMemory",
		"SendMessage",
		"VERSION",
		"GetMenuItemInfo",
		"length",
		"HeapAlloc",
		"MoveMemory",
		"widgetStyle",
		"SetMenuItemInfo",
		"VERSION",
		"SetMenuItemInfo",
		"HeapFree",
		"error",
		"redraw",
		"setSelection",
		"getSelection",
		"getStyle",
		"setSelection",
		"getSelection",
		"selectRadio",
		"setInputState",
		"postEvent",
		"MoveMemory",
		"win32_new",
		"drawImage",
		"dispose",
		"MoveMemory",
		"getBounds",
		"GetMenuInfo",
		"getItems",
		"getBounds",
		"max",
		"MoveMemory",
		"TypedListener",
		"TypedListener",
		"TypedListener",
		"Rectangle",
		"Rectangle",
		"Rectangle",
		"MENUBARINFO",
		"Rectangle",
		"MENUBARINFO",
		"Rectangle",
		"Rectangle",
		"RECT",
		"Rectangle",
		"RECT",
		"Rectangle",
		"Rectangle",
		"TBBUTTONINFO",
		"MENUITEMINFO",
		"MENUITEMINFO",
		"TBBUTTONINFO",
		"MENUITEMINFO",
		"TBBUTTONINFO",
		"MENUITEMINFO",
		"MENUITEMINFO",
		"TCHAR",
		"MENUITEMINFO",
		"String",
		"TCHAR",
		"TBBUTTONINFO",
		"MENUITEMINFO",
		"TCHAR",
		"Event",
		"DRAWITEMSTRUCT",
		"GCData",
		"MEASUREITEMSTRUCT",
		"MENUINFO"
	],
	"methodsBody":{
		"public void setText(String string)":{
			"methodBody":"{\n    checkWidget();\n    if (string == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if ((style & SWT.SEPARATOR) != 0)\n        return;\n    if (text.equals(string))\n        return;\n    super.setText(string);\n    int hHeap = OS.GetProcessHeap();\n    int pszText = 0;\n    boolean success = false;\n    if ((OS.IsPPC || OS.IsSP) && parent.hwndCB != 0) {\n        \n        if (string.indexOf('&') != -1) {\n            int length = string.length();\n            char[] text = new char[length];\n            string.getChars(0, length, text, 0);\n            int i = 0, j = 0;\n            for (i = 0; i < length; i++) {\n                if (text[i] != '&')\n                    text[j++] = text[i];\n            }\n            if (j < i)\n                string = new String(text, 0, j);\n        }\n        \n        TCHAR buffer = new TCHAR(0, string, true);\n        int byteCount = buffer.length() * TCHAR.sizeof;\n        pszText = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, byteCount);\n        OS.MoveMemory(pszText, buffer, byteCount);\n        int hwndCB = parent.hwndCB;\n        TBBUTTONINFO info2 = new TBBUTTONINFO();\n        info2.cbSize = TBBUTTONINFO.sizeof;\n        info2.dwMask = OS.TBIF_TEXT;\n        info2.pszText = pszText;\n        success = OS.SendMessage(hwndCB, OS.TB_SETBUTTONINFO, id, info2) != 0;\n    } else {\n        MENUITEMINFO info = new MENUITEMINFO();\n        info.cbSize = MENUITEMINFO.sizeof;\n        int hMenu = parent.handle;\n        \n        boolean hasBitmap = false;\n        if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION(4, 10)) {\n            info.fMask = OS.MIIM_BITMAP;\n            OS.GetMenuItemInfo(hMenu, id, false, info);\n            hasBitmap = info.hbmpItem != 0;\n        }\n        \n        TCHAR buffer = new TCHAR(0, string, true);\n        int byteCount = buffer.length() * TCHAR.sizeof;\n        pszText = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, byteCount);\n        OS.MoveMemory(pszText, buffer, byteCount);\n        info.fMask = OS.MIIM_TYPE;\n        info.fType = widgetStyle();\n        info.dwTypeData = pszText;\n        success = OS.SetMenuItemInfo(hMenu, id, false, info);\n        \n        if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION(4, 10)) {\n            if (hasBitmap) {\n                info.fMask = OS.MIIM_BITMAP;\n                info.hbmpItem = OS.HBMMENU_CALLBACK;\n                success = OS.SetMenuItemInfo(hMenu, id, false, info);\n            }\n        }\n    }\n    if (pszText != 0)\n        OS.HeapFree(hHeap, 0, pszText);\n    if (!success)\n        error(SWT.ERROR_CANNOT_SET_TEXT);\n    parent.redraw();\n}",
			"comments":"/**\n* Sets the receiver's text. The string may include\n* the mnemonic character and accelerator text.\n* <p>\n* Mnemonics are indicated by an '&amp' that causes the next\n* character to be the mnemonic.  When the user presses a\n* key sequence that matches the mnemonic, a selection\n* event occurs. On most platforms, the mnemonic appears\n* underlined but may be emphasised in a platform specific\n* manner.  The mnemonic indicator character '&amp' can be\n* escaped by doubling it in the string, causing a single\n*'&amp' to be displayed.\n* </p>\n* <p>\n* Accelerator text is indicated by the '\\t' character.\n* On platforms that support accelerator text, the text\n* that follows the '\\t' character is displayed to the user,\n* typically indicating the key stroke that will cause\n* the item to become selected.  On most platforms, the\n* accelerator text appears right aligned in the menu.\n* Setting the accelerator text does not install the\n* accelerator key sequence. The accelerator key sequence\n* is installed using #setAccelerator.\n* </p>\n*\n* @param string the new text\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the text is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #setAccelerator\n*/\n/*\n* Bug in WinCE PPC.  Tool items on the menubar don't resize\n* correctly when the character '&' is used (even when it\n* is a sequence '&&').  The fix is to remove all '&' from\n* the string.\n*/\n/* Use the character encoding for the default locale */\n/*\n* Bug in Windows 2000.  For some reason, when MIIM_TYPE is set\n* on a menu item that also has MIIM_BITMAP, the MIIM_TYPE clears\n* the MIIM_BITMAP style.  The fix is to reset both MIIM_BITMAP.\n* Note, this does not happen on Windows 98.\n*/\n/* Use the character encoding for the default locale */\n/*\n* Restore the bitmap that was removed to work around a problem\n* in GetMenuItemInfo() and menu items that have bitmaps set with\n* MIIM_BITMAP.\n*/\n",
			"methodName":"public void setText(String string)"
		},
		"void fillAccel(ACCEL accel)":{
			"methodBody":"{\n    accel.fVirt = 0;\n    accel.cmd = accel.key = 0;\n    if (accelerator == 0 || !getEnabled())\n        return;\n    int fVirt = OS.FVIRTKEY;\n    int key = accelerator & SWT.KEY_MASK;\n    int vKey = Display.untranslateKey(key);\n    if (vKey != 0) {\n        key = vKey;\n    } else {\n        switch(key) {\n            \n            case 27:\n                key = OS.VK_ESCAPE;\n                break;\n            case 127:\n                key = OS.VK_DELETE;\n                break;\n            default:\n                {\n                    key = Display.wcsToMbcs((char) key);\n                    if (key == 0)\n                        return;\n                    if (OS.IsWinCE) {\n                        key = OS.CharUpper((short) key);\n                    } else {\n                        vKey = OS.VkKeyScan((short) key) & 0xFF;\n                        if (vKey == -1) {\n                            fVirt = 0;\n                        } else {\n                            key = vKey;\n                        }\n                    }\n                }\n        }\n    }\n    accel.key = (short) key;\n    accel.cmd = (short) id;\n    accel.fVirt = (byte) fVirt;\n    if ((accelerator & SWT.ALT) != 0)\n        accel.fVirt |= OS.FALT;\n    if ((accelerator & SWT.SHIFT) != 0)\n        accel.fVirt |= OS.FSHIFT;\n    if ((accelerator & SWT.CONTROL) != 0)\n        accel.fVirt |= OS.FCONTROL;\n}",
			"comments":"/*\n* Bug in Windows.  For some reason, VkKeyScan\n* fails to map ESC to VK_ESCAPE and DEL to\n* VK_DELETE.  The fix is to map these keys\n* as a special case.\n*/\n",
			"methodName":"void fillAccel(ACCEL accel)"
		},
		"void fixMenus(Decorations newParent)":{
			"methodBody":"{\n    if (menu != null)\n        menu.fixMenus(newParent);\n}",
			"comments":"",
			"methodName":"void fixMenus(Decorations newParent)"
		},
		"public boolean getSelection()":{
			"methodBody":"{\n    checkWidget();\n    if ((style & (SWT.CHECK | SWT.RADIO)) == 0)\n        return false;\n    if ((OS.IsPPC || OS.IsSP) && parent.hwndCB != 0)\n        return false;\n    int hMenu = parent.handle;\n    MENUITEMINFO info = new MENUITEMINFO();\n    info.cbSize = MENUITEMINFO.sizeof;\n    info.fMask = OS.MIIM_STATE;\n    boolean success = OS.GetMenuItemInfo(hMenu, id, false, info);\n    if (!success)\n        error(SWT.ERROR_CANNOT_GET_SELECTION);\n    return (info.fState & OS.MFS_CHECKED) != 0;\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver is selected,\n* and false otherwise.\n* <p>\n* When the receiver is of type <code>CHECK</code> or <code>RADIO</code>,\n* it is selected when it is checked.\n*\n* @return the selection state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public boolean getSelection()"
		},
		"LRESULT wmCommandChild(int wParam, int lParam)":{
			"methodBody":"{\n    if ((style & SWT.CHECK) != 0) {\n        setSelection(!getSelection());\n    } else {\n        if ((style & SWT.RADIO) != 0) {\n            if ((parent.getStyle() & SWT.NO_RADIO_GROUP) != 0) {\n                setSelection(!getSelection());\n            } else {\n                selectRadio();\n            }\n        }\n    }\n    Event event = new Event();\n    setInputState(event, SWT.Selection);\n    postEvent(SWT.Selection, event);\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT wmCommandChild(int wParam, int lParam)"
		},
		"protected void checkSubclass()":{
			"methodBody":"{\n    if (!isValidSubclass())\n        error(SWT.ERROR_INVALID_SUBCLASS);\n}",
			"comments":"",
			"methodName":"protected void checkSubclass()"
		},
		"public boolean isEnabled()":{
			"methodBody":"{\n    return getEnabled() && parent.isEnabled();\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver is enabled and all\n* of the receiver's ancestors are enabled, and <code>false</code>\n* otherwise. A disabled menu item is typically not selectable from the\n* user interface and draws with an inactive or \"grayed\" look.\n*\n* @return the receiver's enabled state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #getEnabled\n*/\n",
			"methodName":"public boolean isEnabled()"
		},
		"public void removeHelpListener(HelpListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.Help, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when the help events are generated for the control.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see HelpListener\n* @see #addHelpListener\n*/\n",
			"methodName":"public void removeHelpListener(HelpListener listener)"
		},
		"void selectRadio()":{
			"methodBody":"{\n    int index = 0;\n    MenuItem[] items = parent.getItems();\n    while (index < items.length && items[index] != this) index++;\n    int i = index - 1;\n    while (i >= 0 && items[i].setRadioSelection(false)) --i;\n    int j = index + 1;\n    while (j < items.length && items[j].setRadioSelection(false)) j++;\n    setSelection(true);\n}",
			"comments":"",
			"methodName":"void selectRadio()"
		},
		"static int checkStyle(int style)":{
			"methodBody":"{\n    return checkBits(style, SWT.PUSH, SWT.CHECK, SWT.RADIO, SWT.SEPARATOR, SWT.CASCADE, 0);\n}",
			"comments":"",
			"methodName":"static int checkStyle(int style)"
		},
		"public void setEnabled(boolean enabled)":{
			"methodBody":"{\n    checkWidget();\n    if ((OS.IsPPC || OS.IsSP) && parent.hwndCB != 0) {\n        int hwndCB = parent.hwndCB;\n        TBBUTTONINFO info = new TBBUTTONINFO();\n        info.cbSize = TBBUTTONINFO.sizeof;\n        info.dwMask = OS.TBIF_STATE;\n        OS.SendMessage(hwndCB, OS.TB_GETBUTTONINFO, id, info);\n        info.fsState &= ~OS.TBSTATE_ENABLED;\n        if (enabled)\n            info.fsState |= OS.TBSTATE_ENABLED;\n        OS.SendMessage(hwndCB, OS.TB_SETBUTTONINFO, id, info);\n    } else {\n        int hMenu = parent.handle;\n        if (OS.IsWinCE) {\n            int index = parent.indexOf(this);\n            if (index == -1)\n                return;\n            int uEnable = OS.MF_BYPOSITION | (enabled ? OS.MF_ENABLED : OS.MF_GRAYED);\n            OS.EnableMenuItem(hMenu, index, uEnable);\n        } else {\n            MENUITEMINFO info = new MENUITEMINFO();\n            info.cbSize = MENUITEMINFO.sizeof;\n            info.fMask = OS.MIIM_STATE;\n            boolean success = OS.GetMenuItemInfo(hMenu, id, false, info);\n            if (!success)\n                error(SWT.ERROR_CANNOT_SET_ENABLED);\n            int bits = OS.MFS_DISABLED | OS.MFS_GRAYED;\n            if (enabled) {\n                if ((info.fState & bits) == 0)\n                    return;\n                info.fState &= ~bits;\n            } else {\n                if ((info.fState & bits) == bits)\n                    return;\n                info.fState |= bits;\n            }\n            success = OS.SetMenuItemInfo(hMenu, id, false, info);\n            if (!success)\n                error(SWT.ERROR_CANNOT_SET_ENABLED);\n        }\n    }\n    parent.destroyAccelerators();\n    parent.redraw();\n}",
			"comments":"/**\n* Enables the receiver if the argument is <code>true</code>,\n* and disables it otherwise. A disabled menu item is typically\n* not selectable from the user interface and draws with an\n* inactive or \"grayed\" look.\n*\n* @param enabled the new enabled state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setEnabled(boolean enabled)"
		},
		"public void removeArmListener(ArmListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.Arm, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when the arm events are generated for the control.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see ArmListener\n* @see #addArmListener\n*/\n",
			"methodName":"public void removeArmListener(ArmListener listener)"
		},
		"public void removeSelectionListener(SelectionListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.Selection, listener);\n    eventTable.unhook(SWT.DefaultSelection, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when the control is selected.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see SelectionListener\n* @see #addSelectionListener\n*/\n",
			"methodName":"public void removeSelectionListener(SelectionListener listener)"
		},
		"public int getAccelerator()":{
			"methodBody":"{\n    checkWidget();\n    return accelerator;\n}",
			"comments":"/**\n* Returns the widget accelerator.  An accelerator is the bit-wise\n* OR of zero or more modifier masks and a key. Examples:\n* <code>SWT.CONTROL | SWT.SHIFT | 'T', SWT.ALT | SWT.F2</code>.\n* The default value is zero, indicating that the menu item does\n* not have an accelerator.\n*\n* @return the accelerator or 0\n*\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getAccelerator()"
		},
		"LRESULT wmDrawChild(int wParam, int lParam)":{
			"methodBody":"{\n    DRAWITEMSTRUCT struct = new DRAWITEMSTRUCT();\n    OS.MoveMemory(struct, lParam, DRAWITEMSTRUCT.sizeof);\n    if (image != null) {\n        GCData data = new GCData();\n        data.device = display;\n        GC gc = GC.win32_new(struct.hDC, data);\n        \n        int x = (parent.style & SWT.BAR) != 0 ? (OS.IsWin95 ? 4 : 2) : struct.left;\n        gc.drawImage(image, x, struct.top + 2);\n        gc.dispose();\n    }\n    return null;\n}",
			"comments":"/*\n* Bug in Windows.  When a bitmap is included in the\n* menu bar, the HDC seems to already include the left\n* coordinate.  The fix is to ignore this value when\n* the item is in a menu bar.\n*/\n",
			"methodName":"LRESULT wmDrawChild(int wParam, int lParam)"
		},
		"public void setMenu(Menu menu)":{
			"methodBody":"{\n    checkWidget();\n    \n    if ((style & SWT.CASCADE) == 0) {\n        error(SWT.ERROR_MENUITEM_NOT_CASCADE);\n    }\n    if (menu != null) {\n        if (menu.isDisposed())\n            error(SWT.ERROR_INVALID_ARGUMENT);\n        if ((menu.style & SWT.DROP_DOWN) == 0) {\n            error(SWT.ERROR_MENU_NOT_DROP_DOWN);\n        }\n        if (menu.parent != parent.parent) {\n            error(SWT.ERROR_INVALID_PARENT);\n        }\n    }\n    \n    Menu oldMenu = this.menu;\n    if (oldMenu == menu)\n        return;\n    if (oldMenu != null)\n        oldMenu.cascade = null;\n    this.menu = menu;\n    \n    if ((OS.IsPPC || OS.IsSP) && parent.hwndCB != 0) {\n        if (OS.IsPPC) {\n            int hwndCB = parent.hwndCB;\n            int hMenu = menu == null ? 0 : menu.handle;\n            OS.SendMessage(hwndCB, OS.SHCMBM_SETSUBMENU, id, hMenu);\n        }\n        if (OS.IsSP)\n            error(SWT.ERROR_CANNOT_SET_MENU);\n    } else {\n        \n        int hMenu = parent.handle;\n        MENUITEMINFO info = new MENUITEMINFO();\n        info.cbSize = MENUITEMINFO.sizeof;\n        info.fMask = OS.MIIM_DATA;\n        int index = 0;\n        while (OS.GetMenuItemInfo(hMenu, index, true, info)) {\n            if (info.dwItemData == id)\n                break;\n            index++;\n        }\n        if (info.dwItemData != id)\n            return;\n        boolean hasBitmap = false, success = false;\n        \n        if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION(4, 10)) {\n            info.fMask = OS.MIIM_BITMAP;\n            OS.GetMenuItemInfo(hMenu, index, true, info);\n            hasBitmap = info.hbmpItem != 0;\n            if (hasBitmap) {\n                info.hbmpItem = 0;\n                success = OS.SetMenuItemInfo(hMenu, id, false, info);\n            }\n        }\n        int cch = 128;\n        int hHeap = OS.GetProcessHeap();\n        int byteCount = cch * TCHAR.sizeof;\n        int pszText = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, byteCount);\n        info.fMask = OS.MIIM_STATE | OS.MIIM_ID | OS.MIIM_TYPE | OS.MIIM_DATA;\n        info.dwTypeData = pszText;\n        info.cch = cch;\n        success = OS.GetMenuItemInfo(hMenu, index, true, info);\n        if (menu != null) {\n            menu.cascade = this;\n            info.fMask |= OS.MIIM_SUBMENU;\n            info.hSubMenu = menu.handle;\n        }\n        OS.RemoveMenu(hMenu, index, OS.MF_BYPOSITION);\n        if (OS.IsWinCE) {\n            \n            int uIDNewItem = id;\n            int uFlags = OS.MF_BYPOSITION;\n            if (menu != null) {\n                uFlags |= OS.MF_POPUP;\n                uIDNewItem = menu.handle;\n            }\n            TCHAR lpNewItem = new TCHAR(0, \" \", true);\n            success = OS.InsertMenu(hMenu, index, uFlags, uIDNewItem, lpNewItem);\n            if (success) {\n                info.fMask = OS.MIIM_DATA | OS.MIIM_TYPE;\n                success = OS.SetMenuItemInfo(hMenu, index, true, info);\n                if ((info.fState & (OS.MFS_DISABLED | OS.MFS_GRAYED)) != 0) {\n                    OS.EnableMenuItem(hMenu, index, OS.MF_BYPOSITION | OS.MF_GRAYED);\n                }\n                if ((info.fState & OS.MFS_CHECKED) != 0) {\n                    OS.CheckMenuItem(hMenu, index, OS.MF_BYPOSITION | OS.MF_CHECKED);\n                }\n            }\n        } else {\n            success = OS.InsertMenuItem(hMenu, index, true, info);\n            \n            if (OS.WIN32_VERSION >= OS.VERSION(4, 10)) {\n                if (hasBitmap) {\n                    info.fMask = OS.MIIM_BITMAP;\n                    info.hbmpItem = OS.HBMMENU_CALLBACK;\n                    success = OS.SetMenuItemInfo(hMenu, id, false, info);\n                }\n            }\n        }\n        if (pszText != 0)\n            OS.HeapFree(hHeap, 0, pszText);\n        if (!success)\n            error(SWT.ERROR_CANNOT_SET_MENU);\n    }\n    parent.destroyAccelerators();\n}",
			"comments":"/**\n* Sets the receiver's pull down menu to the argument.\n* Only <code>CASCADE</code> menu items can have a\n* pull down menu. The sequence of key strokes, button presses\n* and/or button releases that are used to request a pull down\n* menu is platform specific.\n*\n* @param menu the new pull down menu\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_MENU_NOT_DROP_DOWN - if the menu is not a drop down menu</li>\n*    <li>ERROR_MENUITEM_NOT_CASCADE - if the menu item is not a <code>CASCADE</code></li>\n*    <li>ERROR_INVALID_ARGUMENT - if the menu has been disposed</li>\n*    <li>ERROR_INVALID_PARENT - if the menu is not in the same widget tree</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/* Check to make sure the new menu is valid */\n/* Assign the new menu */\n/* Assign the new menu in the OS */\n/*\n* Feature in Windows.  When SetMenuItemInfo () is used to\n* set a submenu and the menu item already has a submenu,\n* Windows destroys the previous menu.  This is undocumented\n* and unexpected but not necessarily wrong.  The fix is to\n* remove the item with RemoveMenu () which does not destroy\n* the submenu and then insert the item with InsertMenuItem ().\n*/\n/*\n* Bug in Windows.  When GetMenuItemInfo() is used to get the text,\n* for an item that has a bitmap set using MIIM_BITMAP, the text is\n* not returned.  This means that when SetMenuItemInfo() is used to\n* set the submenu and the current menu state, the text is lost.\n* The fix is to temporarily remove the bitmap and restore it after\n* the text and submenu have been set.\n*/\n/*\n* On WinCE, InsertMenuItem() is not available.  The fix is to\n* use SetMenuItemInfo() but this call does not set the menu item\n* state and submenu.  The fix is to use InsertMenu() to insert\n* the item, SetMenuItemInfo() to set the string and EnableMenuItem()\n* and CheckMenuItem() to set the state.\n*/\n/*\n* Restore the bitmap that was removed to work around a problem\n* in GetMenuItemInfo() and menu items that have bitmaps set with\n* MIIM_BITMAP.\n*/\n",
			"methodName":"public void setMenu(Menu menu)"
		},
		"public boolean getEnabled()":{
			"methodBody":"{\n    checkWidget();\n    if ((OS.IsPPC || OS.IsSP) && parent.hwndCB != 0) {\n        int hwndCB = parent.hwndCB;\n        TBBUTTONINFO info = new TBBUTTONINFO();\n        info.cbSize = TBBUTTONINFO.sizeof;\n        info.dwMask = OS.TBIF_STATE;\n        OS.SendMessage(hwndCB, OS.TB_GETBUTTONINFO, id, info);\n        return (info.fsState & OS.TBSTATE_ENABLED) != 0;\n    }\n    int hMenu = parent.handle;\n    MENUITEMINFO info = new MENUITEMINFO();\n    info.cbSize = MENUITEMINFO.sizeof;\n    info.fMask = OS.MIIM_STATE;\n    boolean success;\n    if (OS.IsWinCE) {\n        int index = parent.indexOf(this);\n        if (index == -1)\n            error(SWT.ERROR_CANNOT_GET_ENABLED);\n        success = OS.GetMenuItemInfo(hMenu, index, true, info);\n    } else {\n        success = OS.GetMenuItemInfo(hMenu, id, false, info);\n    }\n    if (!success)\n        error(SWT.ERROR_CANNOT_GET_ENABLED);\n    return (info.fState & (OS.MFS_DISABLED | OS.MFS_GRAYED)) == 0;\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver is enabled, and\n* <code>false</code> otherwise. A disabled menu item is typically\n* not selectable from the user interface and draws with an\n* inactive or \"grayed\" look.\n*\n* @return the receiver's enabled state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #isEnabled\n*/\n",
			"methodName":"public boolean getEnabled()"
		},
		"LRESULT wmMeasureChild(int wParam, int lParam)":{
			"methodBody":"{\n    MEASUREITEMSTRUCT struct = new MEASUREITEMSTRUCT();\n    OS.MoveMemory(struct, lParam, MEASUREITEMSTRUCT.sizeof);\n    int width = 0, height = 0;\n    if (image != null) {\n        Rectangle rect = image.getBounds();\n        width = rect.width;\n        height = rect.height;\n    } else {\n        \n        MENUINFO lpcmi = new MENUINFO();\n        lpcmi.cbSize = MENUINFO.sizeof;\n        lpcmi.fMask = OS.MIM_STYLE;\n        int hMenu = parent.handle;\n        OS.GetMenuInfo(hMenu, lpcmi);\n        if ((lpcmi.dwStyle & OS.MNS_CHECKORBMP) == 0) {\n            MenuItem[] items = parent.getItems();\n            for (int i = 0; i < items.length; i++) {\n                MenuItem item = items[i];\n                if (item.image != null) {\n                    Rectangle rect = item.image.getBounds();\n                    width = Math.max(width, rect.width);\n                }\n            }\n        }\n    }\n    if (width != 0 || height != 0) {\n        \n        struct.itemWidth = width + (OS.IsWin95 ? 4 : 2);\n        struct.itemHeight = height + 4;\n        OS.MoveMemory(lParam, struct, MEASUREITEMSTRUCT.sizeof);\n    }\n    return null;\n}",
			"comments":"/*\n* Bug in Windows.  If a menu contains items that have\n* images and can be checked, Windows does not include\n* the width of the image and the width of the check when\n* computing the width of the menu.  When the longest item\n* does not have an image, the label and the accelerator\n* text can overlap.  The fix is to use SetMenuItemInfo()\n* to indicate that all items have a bitmap and then include\n* the width of the widest bitmap in WM_MEASURECHILD.\n*/\n/*\n* Feature in Windows.  On Windows 98, it is necessary\n* to add 4 pixels to the width of the image or the image\n* and text are too close.  On other Windows platforms,\n* this causes the text of the longest item to touch the\n* accelerator text.  The fix is to add only 2 pixels in\n* this case.\n*/\n",
			"methodName":"LRESULT wmMeasureChild(int wParam, int lParam)"
		},
		"public void setAccelerator(int accelerator)":{
			"methodBody":"{\n    checkWidget();\n    if (this.accelerator == accelerator)\n        return;\n    this.accelerator = accelerator;\n    parent.destroyAccelerators();\n}",
			"comments":"/**\n* Sets the widget accelerator.  An accelerator is the bit-wise\n* OR of zero or more modifier masks and a key. Examples:\n* <code>SWT.MOD1 | SWT.MOD2 | 'T', SWT.MOD3 | SWT.F2</code>.\n* <code>SWT.CONTROL | SWT.SHIFT | 'T', SWT.ALT | SWT.F2</code>.\n* The default value is zero, indicating that the menu item does\n* not have an accelerator.\n*\n* @param accelerator an integer that is the bit-wise OR of masks and a key\n*\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setAccelerator(int accelerator)"
		},
		"public void addArmListener(ArmListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.Arm, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when the arm events are generated for the control, by sending\n* it one of the messages defined in the <code>ArmListener</code>\n* interface.\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see ArmListener\n* @see #removeArmListener\n*/\n",
			"methodName":"public void addArmListener(ArmListener listener)"
		},
		"public void addHelpListener(HelpListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.Help, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when the help events are generated for the control, by sending\n* it one of the messages defined in the <code>HelpListener</code>\n* interface.\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see HelpListener\n* @see #removeHelpListener\n*/\n",
			"methodName":"public void addHelpListener(HelpListener listener)"
		},
		"public void setSelection(boolean selected)":{
			"methodBody":"{\n    checkWidget();\n    if ((style & (SWT.CHECK | SWT.RADIO)) == 0)\n        return;\n    if ((OS.IsPPC || OS.IsSP) && parent.hwndCB != 0)\n        return;\n    int hMenu = parent.handle;\n    if (OS.IsWinCE) {\n        int index = parent.indexOf(this);\n        if (index == -1)\n            return;\n        int uCheck = OS.MF_BYPOSITION | (selected ? OS.MF_CHECKED : OS.MF_UNCHECKED);\n        OS.CheckMenuItem(hMenu, index, uCheck);\n    } else {\n        MENUITEMINFO info = new MENUITEMINFO();\n        info.cbSize = MENUITEMINFO.sizeof;\n        info.fMask = OS.MIIM_STATE;\n        boolean success = OS.GetMenuItemInfo(hMenu, id, false, info);\n        if (!success)\n            error(SWT.ERROR_CANNOT_SET_SELECTION);\n        info.fState &= ~OS.MFS_CHECKED;\n        if (selected)\n            info.fState |= OS.MFS_CHECKED;\n        success = OS.SetMenuItemInfo(hMenu, id, false, info);\n        if (!success)\n            error(SWT.ERROR_CANNOT_SET_SELECTION);\n    }\n    parent.redraw();\n}",
			"comments":"/**\n* Sets the selection state of the receiver.\n* <p>\n* When the receiver is of type <code>CHECK</code> or <code>RADIO</code>,\n* it is selected when it is checked.\n*\n* @param selected the new selection state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setSelection(boolean selected)"
		},
		"public void setImage(Image image)":{
			"methodBody":"{\n    checkWidget();\n    if ((style & SWT.SEPARATOR) != 0)\n        return;\n    super.setImage(image);\n    if (OS.IsWinCE) {\n        if ((OS.IsPPC || OS.IsSP) && parent.hwndCB != 0) {\n            int hwndCB = parent.hwndCB;\n            TBBUTTONINFO info = new TBBUTTONINFO();\n            info.cbSize = TBBUTTONINFO.sizeof;\n            info.dwMask = OS.TBIF_IMAGE;\n            info.iImage = parent.imageIndex(image);\n            OS.SendMessage(hwndCB, OS.TB_SETBUTTONINFO, id, info);\n        }\n        return;\n    }\n    if (OS.WIN32_VERSION < OS.VERSION(4, 10)) {\n        return;\n    }\n    MENUITEMINFO info = new MENUITEMINFO();\n    info.cbSize = MENUITEMINFO.sizeof;\n    info.fMask = OS.MIIM_BITMAP;\n    if (image != null)\n        info.hbmpItem = OS.HBMMENU_CALLBACK;\n    int hMenu = parent.handle;\n    OS.SetMenuItemInfo(hMenu, id, false, info);\n    parent.redraw();\n}",
			"comments":"/**\n* Sets the image the receiver will display to the argument.\n* <p>\n* Note: This operation is a hint and is not supported on\n* platforms that do not have this concept (for example, Windows NT).\n* </p>\n*\n* @param image the image to display\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setImage(Image image)"
		},
		"boolean setRadioSelection(boolean value)":{
			"methodBody":"{\n    if ((style & SWT.RADIO) == 0)\n        return false;\n    if (getSelection() != value) {\n        setSelection(value);\n        postEvent(SWT.Selection);\n    }\n    return true;\n}",
			"comments":"",
			"methodName":"boolean setRadioSelection(boolean value)"
		},
		"void releaseMenu()":{
			"methodBody":"{\n    if (!OS.IsSP)\n        setMenu(null);\n    menu = null;\n}",
			"comments":"",
			"methodName":"void releaseMenu()"
		},
		"String getNameText()":{
			"methodBody":"{\n    if ((style & SWT.SEPARATOR) != 0)\n        return \"|\";\n    return super.getNameText();\n}",
			"comments":"",
			"methodName":"String getNameText()"
		},
		"public Menu getParent()":{
			"methodBody":"{\n    checkWidget();\n    return parent;\n}",
			"comments":"/**\n* Returns the receiver's parent, which must be a <code>Menu</code>.\n*\n* @return the receiver's parent\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Menu getParent()"
		},
		"void releaseWidget()":{
			"methodBody":"{\n    if (menu != null)\n        menu.releaseResources();\n    menu = null;\n    super.releaseWidget();\n    if (accelerator != 0) {\n        parent.destroyAccelerators();\n    }\n    accelerator = 0;\n    display.removeMenuItem(this);\n    parent = null;\n}",
			"comments":"",
			"methodName":"void releaseWidget()"
		},
		"void releaseChild()":{
			"methodBody":"{\n    super.releaseChild();\n    if (menu != null)\n        menu.dispose();\n    menu = null;\n    parent.destroyItem(this);\n}",
			"comments":"",
			"methodName":"void releaseChild()"
		},
		"public void addSelectionListener(SelectionListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.Selection, typedListener);\n    addListener(SWT.DefaultSelection, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when the menu item is selected, by sending\n* it one of the messages defined in the <code>SelectionListener</code>\n* interface.\n* <p>\n* When <code>widgetSelected</code> is called, the stateMask field of the event object is valid.\n* <code>widgetDefaultSelected</code> is not called.\n* </p>\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see SelectionListener\n* @see #removeSelectionListener\n* @see SelectionEvent\n*/\n",
			"methodName":"public void addSelectionListener(SelectionListener listener)"
		},
		"int widgetStyle()":{
			"methodBody":"{\n    int bits = 0;\n    Decorations shell = parent.parent;\n    if ((shell.style & SWT.MIRRORED) != 0) {\n        if ((parent.style & SWT.LEFT_TO_RIGHT) != 0) {\n            bits |= OS.MFT_RIGHTJUSTIFY | OS.MFT_RIGHTORDER;\n        }\n    } else {\n        if ((parent.style & SWT.RIGHT_TO_LEFT) != 0) {\n            bits |= OS.MFT_RIGHTJUSTIFY | OS.MFT_RIGHTORDER;\n        }\n    }\n    if ((style & SWT.SEPARATOR) != 0)\n        return bits | OS.MFT_SEPARATOR;\n    if ((style & SWT.RADIO) != 0)\n        return bits | OS.MFT_RADIOCHECK;\n    return bits | OS.MFT_STRING;\n}",
			"comments":"",
			"methodName":"int widgetStyle()"
		},
		"Rectangle getBounds()":{
			"methodBody":"{\n    checkWidget();\n    if (OS.IsWinCE)\n        return new Rectangle(0, 0, 0, 0);\n    int index = parent.indexOf(this);\n    if (index == -1)\n        return new Rectangle(0, 0, 0, 0);\n    if ((parent.style & SWT.BAR) != 0) {\n        Decorations shell = parent.parent;\n        if (shell.menuBar != parent) {\n            return new Rectangle(0, 0, 0, 0);\n        }\n        int hwndShell = shell.handle;\n        MENUBARINFO info1 = new MENUBARINFO();\n        info1.cbSize = MENUBARINFO.sizeof;\n        if (!OS.GetMenuBarInfo(hwndShell, OS.OBJID_MENU, 1, info1)) {\n            return new Rectangle(0, 0, 0, 0);\n        }\n        MENUBARINFO info2 = new MENUBARINFO();\n        info2.cbSize = MENUBARINFO.sizeof;\n        if (!OS.GetMenuBarInfo(hwndShell, OS.OBJID_MENU, index + 1, info2)) {\n            return new Rectangle(0, 0, 0, 0);\n        }\n        int x = info2.left - info1.left;\n        int y = info2.top - info1.top;\n        int width = info2.right - info2.left;\n        int height = info2.bottom - info2.top;\n        return new Rectangle(x, y, width, height);\n    } else {\n        int hMenu = parent.handle;\n        RECT rect1 = new RECT();\n        if (!OS.GetMenuItemRect(0, hMenu, 0, rect1)) {\n            return new Rectangle(0, 0, 0, 0);\n        }\n        RECT rect2 = new RECT();\n        if (!OS.GetMenuItemRect(0, hMenu, index, rect2)) {\n            return new Rectangle(0, 0, 0, 0);\n        }\n        int x = rect2.left - rect1.left + 2;\n        int y = rect2.top - rect1.top + 2;\n        int width = rect2.right - rect2.left;\n        int height = rect2.bottom - rect2.top;\n        return new Rectangle(x, y, width, height);\n    }\n}",
			"comments":"/**\n* Returns a rectangle describing the receiver's size and location\n* relative to its parent (or its display if its parent is null).\n*\n* @return the receiver's bounding rectangle\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.1\n*/\n/*public*/\n",
			"methodName":"Rectangle getBounds()"
		},
		"public Menu getMenu()":{
			"methodBody":"{\n    checkWidget();\n    return menu;\n}",
			"comments":"/**\n* Returns the receiver's cascade menu if it has one or null\n* if it does not. Only <code>CASCADE</code> menu items can have\n* a pull down menu. The sequence of key strokes, button presses\n* and/or button releases that are used to request a pull down\n* menu is platform specific.\n*\n* @return the receiver's menu\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Menu getMenu()"
		}
	},
	"ClassORInterfaceName":[
		"MenuItem"
	]
}
