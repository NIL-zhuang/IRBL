{
	"variables":[
		"parent",
		"control",
		"toolTipText",
		"disabledImage",
		"hotImage",
		"disabledImage2",
		"id",
		"typedListener",
		"hwnd",
		"index",
		"rect",
		"hotIndex",
		"y",
		"lParam",
		"hwnd",
		"index",
		"rect",
		"width",
		"height",
		"hwnd",
		"fsState",
		"hwnd",
		"fsState",
		"hwnd",
		"index",
		"rect",
		"info",
		"hwnd",
		"imageList",
		"hotImageList",
		"disabledImageList",
		"itemRect",
		"rect",
		"index",
		"items",
		"i",
		"j",
		"changed",
		"hwnd",
		"info",
		"hwnd",
		"fsState",
		"hwnd",
		"fsState",
		"hwnd",
		"hHeap",
		"buffer",
		"byteCount",
		"pszText",
		"info",
		"hFont",
		"hwnd",
		"info",
		"hwnd",
		"info",
		"imageList",
		"hotImageList",
		"disabledImageList",
		"bounds",
		"listStyle",
		"disabled",
		"color",
		"image2",
		"hot",
		"disabled",
		"color",
		"image2",
		"hot",
		"parent",
		"style",
		"parent",
		"parent",
		"parent",
		"parent",
		"style",
		"parent",
		"parent",
		"index",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"SWT",
		"typedListener",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"parent",
		"OS",
		"OS",
		"OS",
		"hwnd",
		"OS",
		"id",
		"OS",
		"hwnd",
		"OS",
		"index",
		"rect",
		"OS",
		"hwnd",
		"OS",
		"rect",
		"rect",
		"rect",
		"dropDown",
		"rect",
		"rect",
		"y",
		"parent",
		"OS",
		"hwnd",
		"OS",
		"lParam",
		"OS",
		"hwnd",
		"OS",
		"lParam",
		"parent",
		"hotIndex",
		"OS",
		"hwnd",
		"OS",
		"hotIndex",
		"display",
		"image",
		"SWT",
		"parent",
		"OS",
		"hwnd",
		"OS",
		"id",
		"OS",
		"hwnd",
		"OS",
		"index",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"width",
		"height",
		"control",
		"disabledImage",
		"style",
		"SWT",
		"state",
		"DISABLED",
		"parent",
		"OS",
		"hwnd",
		"OS",
		"id",
		"fsState",
		"OS",
		"hotImage",
		"parent",
		"style",
		"SWT",
		"SWT",
		"parent",
		"OS",
		"hwnd",
		"OS",
		"id",
		"fsState",
		"OS",
		"toolTipText",
		"parent",
		"OS",
		"hwnd",
		"OS",
		"id",
		"OS",
		"hwnd",
		"OS",
		"index",
		"rect",
		"rect",
		"rect",
		"parent",
		"parent",
		"parent",
		"control",
		"toolTipText",
		"disabledImage",
		"hotImage",
		"disabledImage2",
		"disabledImage2",
		"disabledImage2",
		"info",
		"TBBUTTONINFO",
		"info",
		"OS",
		"OS",
		"parent",
		"OS",
		"hwnd",
		"OS",
		"id",
		"info",
		"info",
		"OS",
		"info",
		"OS",
		"parent",
		"parent",
		"parent",
		"imageList",
		"imageList",
		"info",
		"hotImageList",
		"hotImageList",
		"info",
		"disabledImageList",
		"disabledImageList",
		"info",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"eventTable",
		"SWT",
		"listener",
		"control",
		"control",
		"control",
		"itemRect",
		"itemRect",
		"control",
		"rect",
		"itemRect",
		"itemRect",
		"rect",
		"rect",
		"itemRect",
		"itemRect",
		"rect",
		"control",
		"rect",
		"rect",
		"parent",
		"index",
		"items",
		"items",
		"index",
		"index",
		"index",
		"i",
		"items",
		"i",
		"i",
		"index",
		"j",
		"items",
		"items",
		"j",
		"j",
		"control",
		"control",
		"SWT",
		"control",
		"parent",
		"SWT",
		"style",
		"SWT",
		"control",
		"parent",
		"SWT",
		"SWT",
		"parent",
		"info",
		"TBBUTTONINFO",
		"info",
		"OS",
		"OS",
		"OS",
		"hwnd",
		"OS",
		"id",
		"info",
		"control",
		"info",
		"OS",
		"changed",
		"info",
		"OS",
		"info",
		"OS",
		"state",
		"DISABLED",
		"info",
		"OS",
		"info",
		"OS",
		"info",
		"OS",
		"changed",
		"info",
		"OS",
		"info",
		"OS",
		"info",
		"OS",
		"info",
		"OS",
		"info",
		"OS",
		"changed",
		"OS",
		"hwnd",
		"OS",
		"id",
		"info",
		"OS",
		"hwnd",
		"OS",
		"OS",
		"hwnd",
		"parent",
		"OS",
		"hwnd",
		"OS",
		"id",
		"fsState",
		"OS",
		"enabled",
		"enabled",
		"fsState",
		"OS",
		"state",
		"DISABLED",
		"fsState",
		"OS",
		"state",
		"DISABLED",
		"OS",
		"hwnd",
		"OS",
		"id",
		"fsState",
		"image",
		"enabled",
		"parent",
		"style",
		"SWT",
		"image",
		"image",
		"SWT",
		"disabledImage",
		"image",
		"parent",
		"style",
		"SWT",
		"image",
		"image",
		"SWT",
		"hotImage",
		"image",
		"parent",
		"style",
		"SWT",
		"image",
		"image",
		"SWT",
		"image",
		"parent",
		"style",
		"SWT",
		"value",
		"value",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"parent",
		"OS",
		"hwnd",
		"OS",
		"id",
		"fsState",
		"OS",
		"selected",
		"selected",
		"fsState",
		"OS",
		"fsState",
		"OS",
		"OS",
		"hwnd",
		"OS",
		"id",
		"fsState",
		"style",
		"SWT",
		"SWT",
		"parent",
		"string",
		"SWT",
		"style",
		"SWT",
		"string",
		"parent",
		"OS",
		"parent",
		"string",
		"buffer",
		"TCHAR",
		"OS",
		"hHeap",
		"OS",
		"byteCount",
		"OS",
		"pszText",
		"buffer",
		"byteCount",
		"info",
		"TBBUTTONINFO",
		"info",
		"OS",
		"OS",
		"info",
		"pszText",
		"info",
		"OS",
		"string",
		"info",
		"OS",
		"OS",
		"hwnd",
		"OS",
		"id",
		"info",
		"OS",
		"hHeap",
		"pszText",
		"OS",
		"hwnd",
		"OS",
		"OS",
		"hwnd",
		"OS",
		"hFont",
		"parent",
		"toolTipText",
		"string",
		"style",
		"SWT",
		"width",
		"parent",
		"info",
		"TBBUTTONINFO",
		"info",
		"OS",
		"info",
		"width",
		"OS",
		"hwnd",
		"OS",
		"id",
		"info",
		"parent",
		"parent",
		"info",
		"TBBUTTONINFO",
		"info",
		"OS",
		"OS",
		"hwnd",
		"OS",
		"id",
		"info",
		"info",
		"OS",
		"image",
		"parent",
		"parent",
		"parent",
		"info",
		"OS",
		"image",
		"parent",
		"SWT",
		"imageList",
		"imageList",
		"display",
		"listStyle",
		"bounds",
		"bounds",
		"disabledImageList",
		"disabledImageList",
		"display",
		"listStyle",
		"bounds",
		"bounds",
		"hotImageList",
		"hotImageList",
		"display",
		"listStyle",
		"bounds",
		"bounds",
		"disabledImage",
		"disabledImage",
		"disabledImage2",
		"disabledImage2",
		"disabledImage2",
		"disabled",
		"image",
		"enabled",
		"parent",
		"disabled",
		"disabledImage2",
		"image",
		"color",
		"image",
		"hotImage",
		"style",
		"SWT",
		"SWT",
		"enabled",
		"image2",
		"hot",
		"disabled",
		"info",
		"imageList",
		"image2",
		"disabledImageList",
		"disabled",
		"hotImageList",
		"hot",
		"hot",
		"image2",
		"parent",
		"imageList",
		"parent",
		"disabledImageList",
		"parent",
		"hotImageList",
		"disabledImageList",
		"image",
		"disabledImage2",
		"disabledImage2",
		"disabledImage2",
		"disabled",
		"disabledImage",
		"disabledImage",
		"disabled",
		"image",
		"enabled",
		"parent",
		"disabled",
		"disabledImage2",
		"image",
		"color",
		"disabledImageList",
		"info",
		"disabled",
		"image",
		"hotImage",
		"style",
		"SWT",
		"SWT",
		"enabled",
		"image2",
		"hot",
		"disabled",
		"imageList",
		"imageList",
		"info",
		"image2",
		"hotImageList",
		"hotImageList",
		"info",
		"hot",
		"hot",
		"image2",
		"image",
		"info",
		"OS",
		"info",
		"OS",
		"info",
		"OS",
		"hwnd",
		"OS",
		"id",
		"info",
		"parent",
		"style",
		"SWT",
		"OS",
		"style",
		"SWT",
		"OS",
		"style",
		"SWT",
		"OS",
		"style",
		"SWT",
		"OS",
		"style",
		"SWT",
		"OS",
		"OS",
		"style",
		"SWT",
		"parent",
		"SWT",
		"SWT",
		"parent",
		"parent",
		"ERROR_NULL_ARGUMENT",
		"Selection",
		"DefaultSelection",
		"PUSH",
		"CHECK",
		"RADIO",
		"SEPARATOR",
		"DROP_DOWN",
		"ERROR_INVALID_SUBCLASS",
		"handle",
		"VK_LBUTTON",
		"TB_COMMANDTOINDEX",
		"TB_GETITEMRECT",
		"TB_GETHOTITEM",
		"top",
		"bottom",
		"top",
		"right",
		"left",
		"ignoreMouse",
		"WM_LBUTTONDOWN",
		"WM_LBUTTONUP",
		"ignoreMouse",
		"TB_SETHOTITEM",
		"IMAGE_DISABLE",
		"handle",
		"TB_COMMANDTOINDEX",
		"TB_GETITEMRECT",
		"right",
		"left",
		"bottom",
		"top",
		"left",
		"top",
		"SEPARATOR",
		"handle",
		"TB_GETSTATE",
		"TBSTATE_ENABLED",
		"CHECK",
		"RADIO",
		"handle",
		"TB_GETSTATE",
		"TBSTATE_CHECKED",
		"handle",
		"TB_COMMANDTOINDEX",
		"TB_GETITEMRECT",
		"right",
		"left",
		"cbSize",
		"sizeof",
		"dwMask",
		"TBIF_IMAGE",
		"TBIF_STYLE",
		"handle",
		"TB_GETBUTTONINFO",
		"fsStyle",
		"BTNS_SEP",
		"iImage",
		"I_IMAGENONE",
		"iImage",
		"iImage",
		"iImage",
		"ERROR_NULL_ARGUMENT",
		"Selection",
		"DefaultSelection",
		"width",
		"height",
		"x",
		"x",
		"width",
		"width",
		"y",
		"y",
		"height",
		"height",
		"x",
		"y",
		"length",
		"length",
		"ERROR_INVALID_ARGUMENT",
		"parent",
		"ERROR_INVALID_PARENT",
		"SEPARATOR",
		"control",
		"style",
		"WRAP",
		"VERTICAL",
		"handle",
		"cbSize",
		"sizeof",
		"dwMask",
		"TBIF_STYLE",
		"TBIF_STATE",
		"TB_GETBUTTONINFO",
		"fsStyle",
		"BTNS_SEP",
		"fsStyle",
		"BTNS_BUTTON",
		"fsStyle",
		"BTNS_SEP",
		"fsState",
		"TBSTATE_ENABLED",
		"fsState",
		"TBSTATE_ENABLED",
		"fsStyle",
		"BTNS_SEP",
		"fsStyle",
		"BTNS_SEP",
		"fsStyle",
		"BTNS_BUTTON",
		"fsState",
		"TBSTATE_ENABLED",
		"dwMask",
		"TBIF_IMAGE",
		"iImage",
		"I_IMAGENONE",
		"TB_SETBUTTONINFO",
		"TB_GETROWS",
		"handle",
		"TB_GETSTATE",
		"TBSTATE_ENABLED",
		"TBSTATE_ENABLED",
		"TBSTATE_ENABLED",
		"TB_SETSTATE",
		"SEPARATOR",
		"ERROR_INVALID_ARGUMENT",
		"SEPARATOR",
		"ERROR_INVALID_ARGUMENT",
		"SEPARATOR",
		"ERROR_INVALID_ARGUMENT",
		"RADIO",
		"Selection",
		"CHECK",
		"RADIO",
		"handle",
		"TB_GETSTATE",
		"TBSTATE_CHECKED",
		"TBSTATE_CHECKED",
		"TBSTATE_CHECKED",
		"TB_SETSTATE",
		"CHECK",
		"RADIO",
		"ERROR_NULL_ARGUMENT",
		"SEPARATOR",
		"handle",
		"sizeof",
		"HEAP_ZERO_MEMORY",
		"cbSize",
		"sizeof",
		"dwMask",
		"TBIF_TEXT",
		"TBIF_STYLE",
		"pszText",
		"fsStyle",
		"BTNS_AUTOSIZE",
		"fsStyle",
		"BTNS_SHOWTEXT",
		"TB_SETBUTTONINFO",
		"WM_GETFONT",
		"WM_SETFONT",
		"SEPARATOR",
		"handle",
		"cbSize",
		"sizeof",
		"dwMask",
		"TBIF_SIZE",
		"cx",
		"TB_SETBUTTONINFO",
		"handle",
		"cbSize",
		"sizeof",
		"dwMask",
		"TBIF_IMAGE",
		"TB_GETBUTTONINFO",
		"iImage",
		"I_IMAGENONE",
		"iImage",
		"I_IMAGENONE",
		"style",
		"RIGHT_TO_LEFT",
		"width",
		"height",
		"width",
		"height",
		"width",
		"height",
		"CHECK",
		"RADIO",
		"iImage",
		"iImage",
		"CHECK",
		"RADIO",
		"iImage",
		"iImage",
		"iImage",
		"I_IMAGENONE",
		"dwMask",
		"TBIF_SIZE",
		"cx",
		"TB_SETBUTTONINFO",
		"DROP_DOWN",
		"BTNS_DROPDOWN",
		"PUSH",
		"BTNS_BUTTON",
		"CHECK",
		"BTNS_CHECK",
		"RADIO",
		"BTNS_CHECK",
		"SEPARATOR",
		"BTNS_SEP",
		"BTNS_BUTTON",
		"RADIO",
		"NO_RADIO_GROUP",
		"Selection",
		"parent",
		"style",
		"parent",
		"style",
		"index",
		"listener",
		"style",
		"dropDown",
		"image",
		"color",
		"listener",
		"control",
		"enabled",
		"image",
		"image",
		"image",
		"value",
		"selected",
		"string",
		"string",
		"width",
		"enabled",
		"wParam",
		"lParam"
	],
	"extendORImplementFiles":[
		"Item"
	],
	"package":[
		"org.eclipse.swt.widgets"
	],
	"import":[
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt",
		"org.eclipse.swt.graphics",
		"org.eclipse.swt.events"
	],
	"methods":[
		"addSelectionListener",
		"checkStyle",
		"checkSubclass",
		"click",
		"createDisabledImage",
		"getBounds",
		"getControl",
		"getDisabledImage",
		"getEnabled",
		"getHotImage",
		"getParent",
		"getSelection",
		"getToolTipText",
		"getWidth",
		"isEnabled",
		"releaseChild",
		"releaseWidget",
		"releaseImages",
		"removeSelectionListener",
		"resizeControl",
		"selectRadio",
		"setControl",
		"setEnabled",
		"setDisabledImage",
		"setHotImage",
		"setImage",
		"setRadioSelection",
		"setSelection",
		"setText",
		"setToolTipText",
		"setWidth",
		"updateImages",
		"widgetStyle",
		"wmCommandChild",
		"checkStyle",
		"createItem",
		"getItemCount",
		"checkStyle",
		"createItem",
		"checkWidget",
		"error",
		"addListener",
		"addListener",
		"checkBits",
		"isValidSubclass",
		"error",
		"GetKeyState",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"checkWidget",
		"checkWidget",
		"checkWidget",
		"SendMessage",
		"checkWidget",
		"checkWidget",
		"checkWidget",
		"SendMessage",
		"checkWidget",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"checkWidget",
		"getEnabled",
		"isEnabled",
		"releaseChild",
		"destroyItem",
		"releaseWidget",
		"dispose",
		"SendMessage",
		"getImageList",
		"getHotImageList",
		"getDisabledImageList",
		"put",
		"put",
		"put",
		"checkWidget",
		"error",
		"unhook",
		"unhook",
		"isDisposed",
		"getBounds",
		"setSize",
		"getBounds",
		"setLocation",
		"getItems",
		"setRadioSelection",
		"setRadioSelection",
		"setSelection",
		"checkWidget",
		"isDisposed",
		"error",
		"error",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"InvalidateRect",
		"resizeControl",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"updateImages",
		"getEnabled",
		"checkWidget",
		"isDisposed",
		"error",
		"updateImages",
		"getEnabled",
		"getEnabled",
		"checkWidget",
		"isDisposed",
		"error",
		"updateImages",
		"getEnabled",
		"getEnabled",
		"checkWidget",
		"isDisposed",
		"error",
		"setImage",
		"updateImages",
		"getEnabled",
		"getEnabled",
		"getSelection",
		"setSelection",
		"postEvent",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"getEnabled",
		"getEnabled",
		"updateImages",
		"checkWidget",
		"error",
		"setText",
		"GetProcessHeap",
		"getCodePage",
		"length",
		"HeapAlloc",
		"MoveMemory",
		"widgetStyle",
		"length",
		"SendMessage",
		"HeapFree",
		"SendMessage",
		"SendMessage",
		"layoutItems",
		"checkWidget",
		"checkWidget",
		"SendMessage",
		"layoutItems",
		"SendMessage",
		"getImageList",
		"getHotImageList",
		"getDisabledImageList",
		"getBounds",
		"getImageListToolBar",
		"getImageListToolBarDisabled",
		"getImageListToolBarHot",
		"dispose",
		"getBackground",
		"createDisabledImage",
		"add",
		"add",
		"add",
		"setImageList",
		"setDisabledImageList",
		"setHotImageList",
		"dispose",
		"getBackground",
		"createDisabledImage",
		"put",
		"put",
		"put",
		"SendMessage",
		"layoutItems",
		"getStyle",
		"selectRadio",
		"postEvent",
		"TypedListener",
		"RECT",
		"Image",
		"RECT",
		"Rectangle",
		"RECT",
		"TBBUTTONINFO",
		"TBBUTTONINFO",
		"TCHAR",
		"TBBUTTONINFO",
		"TBBUTTONINFO",
		"TBBUTTONINFO"
	],
	"methodsBody":{
		"public void setText(String string)":{
			"methodBody":"{\n    checkWidget();\n    if (string == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if ((style & SWT.SEPARATOR) != 0)\n        return;\n    super.setText(string);\n    int hwnd = parent.handle;\n    int hHeap = OS.GetProcessHeap();\n    TCHAR buffer = new TCHAR(parent.getCodePage(), string, true);\n    int byteCount = buffer.length() * TCHAR.sizeof;\n    int pszText = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, byteCount);\n    OS.MoveMemory(pszText, buffer, byteCount);\n    TBBUTTONINFO info = new TBBUTTONINFO();\n    info.cbSize = TBBUTTONINFO.sizeof;\n    info.dwMask = OS.TBIF_TEXT | OS.TBIF_STYLE;\n    info.pszText = pszText;\n    info.fsStyle = (byte) (widgetStyle() | OS.BTNS_AUTOSIZE);\n    if (string.length() != 0)\n        info.fsStyle |= OS.BTNS_SHOWTEXT;\n    OS.SendMessage(hwnd, OS.TB_SETBUTTONINFO, id, info);\n    OS.HeapFree(hHeap, 0, pszText);\n    \n    int hFont = OS.SendMessage(hwnd, OS.WM_GETFONT, 0, 0);\n    OS.SendMessage(hwnd, OS.WM_SETFONT, hFont, 0);\n    parent.layoutItems();\n}",
			"comments":"/**\n* Sets the receiver's text. The string may include\n* the mnemonic character.\n* </p>\n* <p>\n* Mnemonics are indicated by an '&amp' that causes the next\n* character to be the mnemonic.  When the user presses a\n* key sequence that matches the mnemonic, a selection\n* event occurs. On most platforms, the mnemonic appears\n* underlined but may be emphasised in a platform specific\n* manner.  The mnemonic indicator character '&amp' can be\n* escaped by doubling it in the string, causing a single\n*'&amp' to be displayed.\n* </p>\n*\n* @param string the new text\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the text is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* Bug in Windows.  For some reason, when the font is set\n* before any tool item has text, the tool items resize to\n* a very small size.  Also, a tool item will only show text\n* when text has already been set on one item and then a new\n* item is created.  The fix is to use WM_SETFONT to force\n* the tool bar to redraw and layout.\n*/\n",
			"methodName":"public void setText(String string)"
		},
		"void click(boolean dropDown)":{
			"methodBody":"{\n    int hwnd = parent.handle;\n    if (OS.GetKeyState(OS.VK_LBUTTON) < 0)\n        return;\n    int index = OS.SendMessage(hwnd, OS.TB_COMMANDTOINDEX, id, 0);\n    RECT rect = new RECT();\n    OS.SendMessage(hwnd, OS.TB_GETITEMRECT, index, rect);\n    int hotIndex = OS.SendMessage(hwnd, OS.TB_GETHOTITEM, 0, 0);\n    \n    int y = rect.top + (rect.bottom - rect.top) / 2;\n    int lParam = (dropDown ? rect.right - 1 : rect.left) | (y << 16);\n    parent.ignoreMouse = true;\n    OS.SendMessage(hwnd, OS.WM_LBUTTONDOWN, 0, lParam);\n    OS.SendMessage(hwnd, OS.WM_LBUTTONUP, 0, lParam);\n    parent.ignoreMouse = false;\n    if (hotIndex != -1) {\n        OS.SendMessage(hwnd, OS.TB_SETHOTITEM, hotIndex, 0);\n    }\n}",
			"comments":"/*\n* In order to emulate all the processing that\n* happens when a mnemonic key is pressed, fake\n* a mouse press and release.  This will ensure\n* that radio and pull down items are handled\n* properly.\n*/\n",
			"methodName":"void click(boolean dropDown)"
		},
		"public int getWidth()":{
			"methodBody":"{\n    checkWidget();\n    int hwnd = parent.handle;\n    int index = OS.SendMessage(hwnd, OS.TB_COMMANDTOINDEX, id, 0);\n    RECT rect = new RECT();\n    OS.SendMessage(hwnd, OS.TB_GETITEMRECT, index, rect);\n    return rect.right - rect.left;\n}",
			"comments":"/**\n* Gets the width of the receiver.\n*\n* @return the width\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getWidth()"
		},
		"public Image getHotImage()":{
			"methodBody":"{\n    checkWidget();\n    return hotImage;\n}",
			"comments":"/**\n* Returns the receiver's hot image if it has one, or null\n* if it does not.\n* <p>\n* The hot image is displayed when the mouse enters the receiver.\n* </p>\n*\n* @return the receiver's hot image\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Image getHotImage()"
		},
		"public boolean getSelection()":{
			"methodBody":"{\n    checkWidget();\n    if ((style & (SWT.CHECK | SWT.RADIO)) == 0)\n        return false;\n    int hwnd = parent.handle;\n    int fsState = OS.SendMessage(hwnd, OS.TB_GETSTATE, id, 0);\n    return (fsState & OS.TBSTATE_CHECKED) != 0;\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver is selected,\n* and false otherwise.\n* <p>\n* When the receiver is of type <code>CHECK</code> or <code>RADIO</code>,\n* it is selected when it is checked (which some platforms draw as a\n* pushed in button). If the receiver is of any other type, this method\n* returns false.\n* </p>\n*\n* @return the selection state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public boolean getSelection()"
		},
		"void updateImages(boolean enabled)":{
			"methodBody":"{\n    int hwnd = parent.handle;\n    TBBUTTONINFO info = new TBBUTTONINFO();\n    info.cbSize = TBBUTTONINFO.sizeof;\n    info.dwMask = OS.TBIF_IMAGE;\n    OS.SendMessage(hwnd, OS.TB_GETBUTTONINFO, id, info);\n    if (info.iImage == OS.I_IMAGENONE && image == null)\n        return;\n    ImageList imageList = parent.getImageList();\n    ImageList hotImageList = parent.getHotImageList();\n    ImageList disabledImageList = parent.getDisabledImageList();\n    if (info.iImage == OS.I_IMAGENONE) {\n        Rectangle bounds = image.getBounds();\n        int listStyle = parent.style & SWT.RIGHT_TO_LEFT;\n        if (imageList == null) {\n            imageList = display.getImageListToolBar(listStyle, bounds.width, bounds.height);\n        }\n        if (disabledImageList == null) {\n            disabledImageList = display.getImageListToolBarDisabled(listStyle, bounds.width, bounds.height);\n        }\n        if (hotImageList == null) {\n            hotImageList = display.getImageListToolBarHot(listStyle, bounds.width, bounds.height);\n        }\n        Image disabled = disabledImage;\n        if (disabledImage == null) {\n            if (disabledImage2 != null)\n                disabledImage2.dispose();\n            disabledImage2 = null;\n            disabled = image;\n            if (!enabled) {\n                Color color = parent.getBackground();\n                disabled = disabledImage2 = createDisabledImage(image, color);\n            }\n        }\n        \n        Image image2 = image, hot = hotImage;\n        if ((style & (SWT.CHECK | SWT.RADIO)) != 0) {\n            if (!enabled)\n                image2 = hot = disabled;\n        }\n        info.iImage = imageList.add(image2);\n        disabledImageList.add(disabled);\n        hotImageList.add(hot != null ? hot : image2);\n        parent.setImageList(imageList);\n        parent.setDisabledImageList(disabledImageList);\n        parent.setHotImageList(hotImageList);\n    } else {\n        Image disabled = null;\n        if (disabledImageList != null) {\n            if (image != null) {\n                if (disabledImage2 != null)\n                    disabledImage2.dispose();\n                disabledImage2 = null;\n                disabled = disabledImage;\n                if (disabledImage == null) {\n                    disabled = image;\n                    if (!enabled) {\n                        Color color = parent.getBackground();\n                        disabled = disabledImage2 = createDisabledImage(image, color);\n                    }\n                }\n            }\n            disabledImageList.put(info.iImage, disabled);\n        }\n        \n        Image image2 = image, hot = hotImage;\n        if ((style & (SWT.CHECK | SWT.RADIO)) != 0) {\n            if (!enabled)\n                image2 = hot = disabled;\n        }\n        if (imageList != null)\n            imageList.put(info.iImage, image2);\n        if (hotImageList != null) {\n            hotImageList.put(info.iImage, hot != null ? hot : image2);\n        }\n        if (image == null)\n            info.iImage = OS.I_IMAGENONE;\n    }\n    \n    info.dwMask |= OS.TBIF_SIZE;\n    info.cx = 0;\n    OS.SendMessage(hwnd, OS.TB_SETBUTTONINFO, id, info);\n    parent.layoutItems();\n}",
			"comments":"/*\n* Bug in Windows.  When a tool item with the style\n* BTNS_CHECK or BTNS_CHECKGROUP is selected and then\n* disabled, the item does not draw using the disabled\n* image.  The fix is to assign the disabled image in\n* all image lists.\n*/\n/*\n* Bug in Windows.  When a tool item with the style\n* BTNS_CHECK or BTNS_CHECKGROUP is selected and then\n* disabled, the item does not draw using the disabled\n* image.  The fix is to use the disabled image in all\n* image lists.\n*/\n/*\n* Bug in Windows.  If the width of an item has already been\n* calculated, the tool bar control will not recalculate it to\n* include the space for the image.  The fix is to set the width\n* to zero, forcing the control recalculate the width for the item.\n*/\n",
			"methodName":"void updateImages(boolean enabled)"
		},
		"public Image getDisabledImage()":{
			"methodBody":"{\n    checkWidget();\n    return disabledImage;\n}",
			"comments":"/**\n* Returns the receiver's disabled image if it has one, or null\n* if it does not.\n* <p>\n* The disabled image is displayed when the receiver is disabled.\n* </p>\n*\n* @return the receiver's disabled image\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Image getDisabledImage()"
		},
		"LRESULT wmCommandChild(int wParam, int lParam)":{
			"methodBody":"{\n    if ((style & SWT.RADIO) != 0) {\n        if ((parent.getStyle() & SWT.NO_RADIO_GROUP) == 0) {\n            selectRadio();\n        }\n    }\n    postEvent(SWT.Selection);\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT wmCommandChild(int wParam, int lParam)"
		},
		"protected void checkSubclass()":{
			"methodBody":"{\n    if (!isValidSubclass())\n        error(SWT.ERROR_INVALID_SUBCLASS);\n}",
			"comments":"",
			"methodName":"protected void checkSubclass()"
		},
		"void resizeControl()":{
			"methodBody":"{\n    if (control != null && !control.isDisposed()) {\n        \n        Rectangle itemRect = getBounds();\n        control.setSize(itemRect.width, itemRect.height);\n        Rectangle rect = control.getBounds();\n        rect.x = itemRect.x + (itemRect.width - rect.width) / 2;\n        rect.y = itemRect.y + (itemRect.height - rect.height) / 2;\n        control.setLocation(rect.x, rect.y);\n    }\n}",
			"comments":"/*\n* Set the size and location of the control\n* separately to minimize flashing in the\n* case where the control does not resize\n* to the size that was requested.  This\n* case can occur when the control is a\n* combo box.\n*/\n",
			"methodName":"void resizeControl()"
		},
		"public boolean isEnabled()":{
			"methodBody":"{\n    checkWidget();\n    return getEnabled() && parent.isEnabled();\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver is enabled and all\n* of the receiver's ancestors are enabled, and <code>false</code>\n* otherwise. A disabled control is typically not selectable from the\n* user interface and draws with an inactive or \"grayed\" look.\n*\n* @return the receiver's enabled state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #getEnabled\n*/\n",
			"methodName":"public boolean isEnabled()"
		},
		"void selectRadio()":{
			"methodBody":"{\n    int index = 0;\n    ToolItem[] items = parent.getItems();\n    while (index < items.length && items[index] != this) index++;\n    int i = index - 1;\n    while (i >= 0 && items[i].setRadioSelection(false)) --i;\n    int j = index + 1;\n    while (j < items.length && items[j].setRadioSelection(false)) j++;\n    setSelection(true);\n}",
			"comments":"",
			"methodName":"void selectRadio()"
		},
		"static int checkStyle(int style)":{
			"methodBody":"{\n    return checkBits(style, SWT.PUSH, SWT.CHECK, SWT.RADIO, SWT.SEPARATOR, SWT.DROP_DOWN, 0);\n}",
			"comments":"",
			"methodName":"static int checkStyle(int style)"
		},
		"public ToolBar getParent()":{
			"methodBody":"{\n    checkWidget();\n    return parent;\n}",
			"comments":"/**\n* Returns the receiver's parent, which must be a <code>ToolBar</code>.\n*\n* @return the receiver's parent\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public ToolBar getParent()"
		},
		"public void setEnabled(boolean enabled)":{
			"methodBody":"{\n    checkWidget();\n    int hwnd = parent.handle;\n    int fsState = OS.SendMessage(hwnd, OS.TB_GETSTATE, id, 0);\n    \n    if (((fsState & OS.TBSTATE_ENABLED) != 0) == enabled)\n        return;\n    if (enabled) {\n        fsState |= OS.TBSTATE_ENABLED;\n        state &= ~DISABLED;\n    } else {\n        fsState &= ~OS.TBSTATE_ENABLED;\n        state |= DISABLED;\n    }\n    OS.SendMessage(hwnd, OS.TB_SETSTATE, id, fsState);\n    if (image != null)\n        updateImages(enabled && parent.getEnabled());\n}",
			"comments":"/**\n* Enables the receiver if the argument is <code>true</code>,\n* and disables it otherwise.\n* <p>\n* A disabled control is typically\n* not selectable from the user interface and draws with an\n* inactive or \"grayed\" look.\n* </p>\n*\n* @param enabled the new enabled state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* Feature in Windows.  When TB_SETSTATE is used to set the\n* state of a tool item, the item redraws even when the state\n* has not changed.  The fix is to detect this case and avoid\n* setting the state.\n*/\n",
			"methodName":"public void setEnabled(boolean enabled)"
		},
		"public void removeSelectionListener(SelectionListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.Selection, listener);\n    eventTable.unhook(SWT.DefaultSelection, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when the control is selected.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see SelectionListener\n* @see #addSelectionListener\n*/\n",
			"methodName":"public void removeSelectionListener(SelectionListener listener)"
		},
		"public boolean getEnabled()":{
			"methodBody":"{\n    checkWidget();\n    if ((style & SWT.SEPARATOR) != 0) {\n        return (state & DISABLED) == 0;\n    }\n    int hwnd = parent.handle;\n    int fsState = OS.SendMessage(hwnd, OS.TB_GETSTATE, id, 0);\n    return (fsState & OS.TBSTATE_ENABLED) != 0;\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver is enabled, and\n* <code>false</code> otherwise. A disabled control is typically\n* not selectable from the user interface and draws with an\n* inactive or \"grayed\" look.\n*\n* @return the receiver's enabled state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #isEnabled\n*/\n",
			"methodName":"public boolean getEnabled()"
		},
		"public void setHotImage(Image image)":{
			"methodBody":"{\n    checkWidget();\n    if ((style & SWT.SEPARATOR) != 0)\n        return;\n    if (image != null && image.isDisposed())\n        error(SWT.ERROR_INVALID_ARGUMENT);\n    hotImage = image;\n    updateImages(getEnabled() && parent.getEnabled());\n}",
			"comments":"/**\n* Sets the receiver's hot image to the argument, which may be\n* null indicating that no hot image should be displayed.\n* <p>\n* The hot image is displayed when the mouse enters the receiver.\n* </p>\n*\n* @param image the hot image to display on the receiver (may be null)\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the image has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setHotImage(Image image)"
		},
		"public void setDisabledImage(Image image)":{
			"methodBody":"{\n    checkWidget();\n    if ((style & SWT.SEPARATOR) != 0)\n        return;\n    if (image != null && image.isDisposed())\n        error(SWT.ERROR_INVALID_ARGUMENT);\n    disabledImage = image;\n    updateImages(getEnabled() && parent.getEnabled());\n}",
			"comments":"/**\n* Sets the receiver's disabled image to the argument, which may be\n* null indicating that no disabled image should be displayed.\n* <p>\n* The disbled image is displayed when the receiver is disabled.\n* </p>\n*\n* @param image the disabled image to display on the receiver (may be null)\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the image has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setDisabledImage(Image image)"
		},
		"public void setSelection(boolean selected)":{
			"methodBody":"{\n    checkWidget();\n    if ((style & (SWT.CHECK | SWT.RADIO)) == 0)\n        return;\n    int hwnd = parent.handle;\n    int fsState = OS.SendMessage(hwnd, OS.TB_GETSTATE, id, 0);\n    \n    if (((fsState & OS.TBSTATE_CHECKED) != 0) == selected)\n        return;\n    if (selected) {\n        fsState |= OS.TBSTATE_CHECKED;\n    } else {\n        fsState &= ~OS.TBSTATE_CHECKED;\n    }\n    OS.SendMessage(hwnd, OS.TB_SETSTATE, id, fsState);\n    \n    if ((style & (SWT.CHECK | SWT.RADIO)) != 0) {\n        if (!getEnabled() || !parent.getEnabled()) {\n            updateImages(false);\n        }\n    }\n}",
			"comments":"/**\n* Sets the selection state of the receiver.\n* <p>\n* When the receiver is of type <code>CHECK</code> or <code>RADIO</code>,\n* it is selected when it is checked (which some platforms draw as a\n* pushed in button).\n* </p>\n*\n* @param selected the new selection state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* Feature in Windows.  When TB_SETSTATE is used to set the\n* state of a tool item, the item redraws even when the state\n* has not changed.  The fix is to detect this case and avoid\n* setting the state.\n*/\n/*\n* Bug in Windows.  When a tool item with the style\n* BTNS_CHECK or BTNS_CHECKGROUP is selected and then\n* disabled, the item does not draw using the disabled\n* image.  The fix is to use the disabled image in all\n* image lists.\n*\n* NOTE: This means that the image list must be updated\n* when the selection changes in a disabled tool item.\n*/\n",
			"methodName":"public void setSelection(boolean selected)"
		},
		"public void setImage(Image image)":{
			"methodBody":"{\n    checkWidget();\n    if ((style & SWT.SEPARATOR) != 0)\n        return;\n    if (image != null && image.isDisposed())\n        error(SWT.ERROR_INVALID_ARGUMENT);\n    super.setImage(image);\n    updateImages(getEnabled() && parent.getEnabled());\n}",
			"comments":"",
			"methodName":"public void setImage(Image image)"
		},
		"boolean setRadioSelection(boolean value)":{
			"methodBody":"{\n    if ((style & SWT.RADIO) == 0)\n        return false;\n    if (getSelection() != value) {\n        setSelection(value);\n        postEvent(SWT.Selection);\n    }\n    return true;\n}",
			"comments":"",
			"methodName":"boolean setRadioSelection(boolean value)"
		},
		"public Rectangle getBounds()":{
			"methodBody":"{\n    checkWidget();\n    int hwnd = parent.handle;\n    int index = OS.SendMessage(hwnd, OS.TB_COMMANDTOINDEX, id, 0);\n    RECT rect = new RECT();\n    OS.SendMessage(hwnd, OS.TB_GETITEMRECT, index, rect);\n    int width = rect.right - rect.left;\n    int height = rect.bottom - rect.top;\n    return new Rectangle(rect.left, rect.top, width, height);\n}",
			"comments":"/**\n* Returns a rectangle describing the receiver's size and location\n* relative to its parent.\n*\n* @return the receiver's bounding rectangle\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Rectangle getBounds()"
		},
		"public Control getControl()":{
			"methodBody":"{\n    checkWidget();\n    return control;\n}",
			"comments":"/**\n* Returns the control that is used to fill the bounds of\n* the item when the items is a <code>SEPARATOR</code>.\n*\n* @return the control\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Control getControl()"
		},
		"void releaseImages()":{
			"methodBody":"{\n    TBBUTTONINFO info = new TBBUTTONINFO();\n    info.cbSize = TBBUTTONINFO.sizeof;\n    info.dwMask = OS.TBIF_IMAGE | OS.TBIF_STYLE;\n    int hwnd = parent.handle;\n    OS.SendMessage(hwnd, OS.TB_GETBUTTONINFO, id, info);\n    \n    if ((info.fsStyle & OS.BTNS_SEP) == 0 && info.iImage != OS.I_IMAGENONE) {\n        ImageList imageList = parent.getImageList();\n        ImageList hotImageList = parent.getHotImageList();\n        ImageList disabledImageList = parent.getDisabledImageList();\n        if (imageList != null)\n            imageList.put(info.iImage, null);\n        if (hotImageList != null)\n            hotImageList.put(info.iImage, null);\n        if (disabledImageList != null)\n            disabledImageList.put(info.iImage, null);\n    }\n}",
			"comments":"/*\n* Feature in Windows.  For some reason, a tool item that has\n* the style BTNS_SEP does not return I_IMAGENONE when queried\n* for an image index, despite the fact that no attempt has been\n* made to assign an image to the item.  As a result, operations\n* on an image list that use the wrong index cause random results.\n* The fix is to ensure that the tool item is not a separator\n* before using the image index.  Since separators cannot have\n* an image and one is never assigned, this is not a problem.\n*/\n",
			"methodName":"void releaseImages()"
		},
		"Image createDisabledImage(Image image, Color color)":{
			"methodBody":"{\n    \n    return new Image(display, image, SWT.IMAGE_DISABLE);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n}",
			"comments":"/*\n* In order to be consistent with the way that disabled\n* images appear in other places in the user interface,\n* use the SWT Graphics to create a disabled image instead\n* of calling DrawState().\n*/\n/*\n* This code is intentionally commented.\n*/\n//\tif (OS.IsWinCE) {\n//\t\treturn new Image (display, image, SWT.IMAGE_DISABLE);\n//\t}\n//\tRectangle rect = image.getBounds ();\n//\tImage disabled = new Image (display, rect);\n//\tGC gc = new GC (disabled);\n//\tgc.setBackground (color);\n//\tgc.fillRectangle (rect);\n//\tint hDC = gc.handle;\n//\tint hImage = image.handle;\n//\tint fuFlags = OS.DSS_DISABLED;\n//\tswitch (image.type) {\n//\t\tcase SWT.BITMAP: fuFlags |= OS.DST_BITMAP; break;\n//\t\tcase SWT.ICON: fuFlags |= OS.DST_ICON; break;\n//\t}\n//\tOS.DrawState (hDC, 0, 0, hImage, 0, 0, 0, rect.width, rect.height, fuFlags);\n//\tgc.dispose ();\n//\treturn disabled;\n",
			"methodName":"Image createDisabledImage(Image image, Color color)"
		},
		"void releaseWidget()":{
			"methodBody":"{\n    super.releaseWidget();\n    parent = null;\n    control = null;\n    toolTipText = null;\n    disabledImage = hotImage = null;\n    if (disabledImage2 != null)\n        disabledImage2.dispose();\n    disabledImage2 = null;\n}",
			"comments":"",
			"methodName":"void releaseWidget()"
		},
		"public void setControl(Control control)":{
			"methodBody":"{\n    checkWidget();\n    if (control != null) {\n        if (control.isDisposed())\n            error(SWT.ERROR_INVALID_ARGUMENT);\n        if (control.parent != parent)\n            error(SWT.ERROR_INVALID_PARENT);\n    }\n    if ((style & SWT.SEPARATOR) == 0)\n        return;\n    this.control = control;\n    \n    if ((parent.style & (SWT.WRAP | SWT.VERTICAL)) != 0) {\n        boolean changed = false;\n        int hwnd = parent.handle;\n        TBBUTTONINFO info = new TBBUTTONINFO();\n        info.cbSize = TBBUTTONINFO.sizeof;\n        info.dwMask = OS.TBIF_STYLE | OS.TBIF_STATE;\n        OS.SendMessage(hwnd, OS.TB_GETBUTTONINFO, id, info);\n        if (control == null) {\n            if ((info.fsStyle & OS.BTNS_SEP) == 0) {\n                changed = true;\n                info.fsStyle &= ~OS.BTNS_BUTTON;\n                info.fsStyle |= OS.BTNS_SEP;\n                if ((state & DISABLED) != 0) {\n                    info.fsState &= ~OS.TBSTATE_ENABLED;\n                } else {\n                    info.fsState |= OS.TBSTATE_ENABLED;\n                }\n            }\n        } else {\n            if ((info.fsStyle & OS.BTNS_SEP) != 0) {\n                changed = true;\n                info.fsStyle &= ~OS.BTNS_SEP;\n                info.fsStyle |= OS.BTNS_BUTTON;\n                info.fsState &= ~OS.TBSTATE_ENABLED;\n                info.dwMask |= OS.TBIF_IMAGE;\n                info.iImage = OS.I_IMAGENONE;\n            }\n        }\n        if (changed) {\n            OS.SendMessage(hwnd, OS.TB_SETBUTTONINFO, id, info);\n            \n            if (OS.SendMessage(hwnd, OS.TB_GETROWS, 0, 0) > 1) {\n                OS.InvalidateRect(hwnd, null, true);\n            }\n        }\n    }\n    resizeControl();\n}",
			"comments":"/**\n* Sets the control that is used to fill the bounds of\n* the item when the items is a <code>SEPARATOR</code>.\n*\n* @param control the new control\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the control has been disposed</li>\n*    <li>ERROR_INVALID_PARENT - if the control is not in the same widget tree</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* Feature in Windows.  When a tool bar wraps, tool items\n* with the style BTNS_SEP are used as wrap points.  This\n* means that controls that are placed on top of separator\n* items are not positioned properly.  Also, vertical tool\n* bars are implemented using TB_SETROWS to set the number\n* of rows.  When a control is placed on top of a separator,\n* the height of the separator does not grow.  The fix in\n* both cases is to change the tool item style from BTNS_SEP\n* to BTNS_BUTTON, causing the item to wrap like a tool item\n* button.  The new tool item button is disabled to avoid key\n* traversal and the image is set to I_IMAGENONE to avoid\n* getting the first image from the image list.\n*/\n/*\n* Bug in Windows.  When TB_SETBUTTONINFO changes the\n* style of a tool item from BTNS_SEP to BTNS_BUTTON\n* and the tool bar is wrapped, the tool bar does not\n* redraw properly.  Windows uses separator items as\n* wrap points and sometimes draws etching above or\n* below and entire row.  The fix is to redraw the\n* tool bar.\n*/\n",
			"methodName":"public void setControl(Control control)"
		},
		"public void setWidth(int width)":{
			"methodBody":"{\n    checkWidget();\n    if ((style & SWT.SEPARATOR) == 0)\n        return;\n    if (width < 0)\n        return;\n    int hwnd = parent.handle;\n    TBBUTTONINFO info = new TBBUTTONINFO();\n    info.cbSize = TBBUTTONINFO.sizeof;\n    info.dwMask = OS.TBIF_SIZE;\n    info.cx = (short) width;\n    OS.SendMessage(hwnd, OS.TB_SETBUTTONINFO, id, info);\n    parent.layoutItems();\n}",
			"comments":"/**\n* Sets the width of the receiver, for <code>SEPARATOR</code> ToolItems.\n*\n* @param width the new width\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setWidth(int width)"
		},
		"public String getToolTipText()":{
			"methodBody":"{\n    checkWidget();\n    return toolTipText;\n}",
			"comments":"/**\n* Returns the receiver's tool tip text, or null if it has not been set.\n*\n* @return the receiver's tool tip text\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public String getToolTipText()"
		},
		"void releaseChild()":{
			"methodBody":"{\n    super.releaseChild();\n    parent.destroyItem(this);\n}",
			"comments":"",
			"methodName":"void releaseChild()"
		},
		"public void addSelectionListener(SelectionListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.Selection, typedListener);\n    addListener(SWT.DefaultSelection, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when the control is selected, by sending\n* it one of the messages defined in the <code>SelectionListener</code>\n* interface.\n* <p>\n* When <code>widgetSelected</code> is called when the mouse is over the arrow portion of a drop-down tool,\n* the event object detail field contains the value <code>SWT.ARROW</code>.\n* <code>widgetDefaultSelected</code> is not called.\n* </p>\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see SelectionListener\n* @see #removeSelectionListener\n* @see SelectionEvent\n*/\n",
			"methodName":"public void addSelectionListener(SelectionListener listener)"
		},
		"int widgetStyle()":{
			"methodBody":"{\n    if ((style & SWT.DROP_DOWN) != 0)\n        return OS.BTNS_DROPDOWN;\n    if ((style & SWT.PUSH) != 0)\n        return OS.BTNS_BUTTON;\n    if ((style & SWT.CHECK) != 0)\n        return OS.BTNS_CHECK;\n    \n    if ((style & SWT.RADIO) != 0)\n        return OS.BTNS_CHECK;\n    if ((style & SWT.SEPARATOR) != 0)\n        return OS.BTNS_SEP;\n    return OS.BTNS_BUTTON;\n}",
			"comments":"/*\n* This code is intentionally commented.  In order to\n* consistently support radio tool items across platforms,\n* the platform radio behavior is not used.\n*/\n//\tif ((style & SWT.RADIO) != 0) return OS.BTNS_CHECKGROUP;\n",
			"methodName":"int widgetStyle()"
		},
		"public void setToolTipText(String string)":{
			"methodBody":"{\n    checkWidget();\n    toolTipText = string;\n}",
			"comments":"/**\n* Sets the receiver's tool tip text to the argument, which\n* may be null indicating that no tool tip text should be shown.\n*\n* @param string the new tool tip text (or null)\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setToolTipText(String string)"
		}
	},
	"ClassORInterfaceName":[
		"ToolItem"
	]
}
