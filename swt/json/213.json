{
	"variables":[
		"position",
		"in",
		"buf",
		"pos",
		"result",
		"left",
		"cacheCopied",
		"newOffset",
		"available",
		"inCopied",
		"buf",
		"buf",
		"length",
		"input",
		"input",
		"bufferSize",
		"buf",
		"bufferSize",
		"pos",
		"bufferSize",
		"buf",
		"in",
		"in",
		"in",
		"position",
		"buf",
		"buf",
		"pos",
		"in",
		"buf",
		"position",
		"pos",
		"buf",
		"buf",
		"pos",
		"in",
		"len",
		"result",
		"b",
		"off",
		"len",
		"result",
		"position",
		"result",
		"result",
		"left",
		"len",
		"left",
		"result",
		"off",
		"result",
		"result",
		"b",
		"off",
		"left",
		"buf",
		"offset",
		"offset",
		"buffer",
		"length",
		"length",
		"buffer",
		"offset",
		"offset",
		"buf",
		"pos",
		"available",
		"cacheCopied",
		"available",
		"length",
		"length",
		"available",
		"System",
		"buf",
		"pos",
		"buffer",
		"newOffset",
		"cacheCopied",
		"newOffset",
		"cacheCopied",
		"pos",
		"cacheCopied",
		"cacheCopied",
		"length",
		"length",
		"in",
		"buffer",
		"newOffset",
		"length",
		"cacheCopied",
		"inCopied",
		"inCopied",
		"cacheCopied",
		"cacheCopied",
		"inCopied",
		"cacheCopied",
		"buf",
		"buf",
		"buf",
		"buf",
		"buf",
		"buf",
		"buf",
		"buf",
		"b",
		"length",
		"pos",
		"position",
		"length",
		"pos",
		"length",
		"System",
		"b",
		"buf",
		"pos",
		"length",
		"in",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"input",
		"input",
		"bufferSize",
		"b",
		"off",
		"len",
		"buffer",
		"offset",
		"length",
		"b"
	],
	"extendORImplementFiles":[
		"InputStream"
	],
	"package":[
		"org.eclipse.swt.internal.image"
	],
	"import":[
		"java.io"
	],
	"methods":[
		"close",
		"getPosition",
		"available",
		"read",
		"read",
		"readData",
		"readInt",
		"readShort",
		"unread",
		"close",
		"available",
		"read",
		"readData",
		"readData",
		"arraycopy",
		"read",
		"read",
		"read",
		"arraycopy",
		"IllegalArgumentException",
		"IOException",
		"IOException",
		"IOException",
		"ArrayIndexOutOfBoundsException",
		"IOException"
	],
	"methodsBody":{
		"public void close() throws IOException":{
			"methodBody":"{\n    buf = null;\n    if (in != null) {\n        in.close();\n        in = null;\n    }\n}",
			"comments":"",
			"methodName":"public void close() throws IOException"
		},
		"private int readData(byte[] buffer, int offset, int length) throws IOException":{
			"methodBody":"{\n    if (buf == null)\n        throw new IOException();\n    if (offset < 0 || offset > buffer.length || length < 0 || (length > buffer.length - offset)) {\n        throw new ArrayIndexOutOfBoundsException();\n    }\n    int cacheCopied = 0;\n    int newOffset = offset;\n    \n    int available = buf.length - pos;\n    if (available > 0) {\n        cacheCopied = (available >= length) ? length : available;\n        System.arraycopy(buf, pos, buffer, newOffset, cacheCopied);\n        newOffset += cacheCopied;\n        pos += cacheCopied;\n    }\n    \n    if (cacheCopied == length)\n        return length;\n    int inCopied = in.read(buffer, newOffset, length - cacheCopied);\n    if (inCopied > 0)\n        return inCopied + cacheCopied;\n    if (cacheCopied == 0)\n        return inCopied;\n    return cacheCopied;\n}",
			"comments":"/**\n* Reads at most <code>length</code> bytes from this LEDataInputStream and\n* stores them in byte array <code>buffer</code> starting at <code>offset</code>.\n* <p>\n* Answer the number of bytes actually read or -1 if no bytes were read and\n* end of stream was encountered.  This implementation reads bytes from\n* the pushback buffer first, then the target stream if more bytes are required\n* to satisfy <code>count</code>.\n* </p>\n* @param buffer the byte array in which to store the read bytes.\n* @param offset the offset in <code>buffer</code> to store the read bytes.\n* @param length the maximum number of bytes to store in <code>buffer</code>.\n*\n* @return int the number of bytes actually read or -1 if end of stream.\n*\n* @exception java.io.IOException if an IOException occurs.\n*/\n// Are there pushback bytes available?\n// Have we copied enough?\n",
			"methodName":"private int readData(byte[] buffer, int offset, int length) throws IOException"
		},
		"public void unread(byte[] b) throws IOException":{
			"methodBody":"{\n    int length = b.length;\n    if (length > pos)\n        throw new IOException();\n    position -= length;\n    pos -= length;\n    System.arraycopy(b, 0, buf, pos, length);\n}",
			"comments":"/**\n* Push back the entire content of the given buffer <code>b</code>.\n* <p>\n* The bytes are pushed so that they would be read back b[0], b[1], etc.\n* If the push back buffer cannot handle the bytes copied from <code>b</code>,\n* an IOException will be thrown and no byte will be pushed back.\n* </p>\n*\n* @param b the byte array containing bytes to push back into the stream\n*\n* @exception \tjava.io.IOException if the pushback buffer is too small\n*/\n",
			"methodName":"public void unread(byte[] b) throws IOException"
		},
		"public short readShort() throws IOException":{
			"methodBody":"{\n    byte[] buf = new byte[2];\n    read(buf);\n    return (short) (((buf[1] & 0xFF) << 8) | (buf[0] & 0xFF));\n}",
			"comments":"/**\n* Answer a short comprised of the next\n* two bytes of the input stream.\n*/\n",
			"methodName":"public short readShort() throws IOException"
		},
		"public int available() throws IOException":{
			"methodBody":"{\n    if (buf == null)\n        throw new IOException();\n    return (buf.length - pos) + in.available();\n}",
			"comments":"/**\n* Answers how many bytes are available for reading without blocking\n*/\n",
			"methodName":"public int available() throws IOException"
		},
		"public int read(byte[] b, int off, int len) throws IOException":{
			"methodBody":"{\n    int result;\n    int left = len;\n    result = readData(b, off, len);\n    while (true) {\n        if (result == -1)\n            return -1;\n        position += result;\n        if (result == left)\n            return len;\n        left -= result;\n        off += result;\n        result = readData(b, off, left);\n    }\n}",
			"comments":"/**\n* Don't imitate the JDK behaviour of reading a random number\n* of bytes when you can actually read them all.\n*/\n",
			"methodName":"public int read(byte[] b, int off, int len) throws IOException"
		},
		"public int getPosition()":{
			"methodBody":"{\n    return position;\n}",
			"comments":"/**\n* Answer how many bytes were read.\n*/\n",
			"methodName":"public int getPosition()"
		},
		"public int read() throws IOException":{
			"methodBody":"{\n    if (buf == null)\n        throw new IOException();\n    position++;\n    if (pos < buf.length)\n        return (buf[pos++] & 0xFF);\n    return in.read();\n}",
			"comments":"/**\n* Answer the next byte of the input stream.\n*/\n",
			"methodName":"public int read() throws IOException"
		},
		"public int readInt() throws IOException":{
			"methodBody":"{\n    byte[] buf = new byte[4];\n    read(buf);\n    return ((((((buf[3] & 0xFF) << 8) | (buf[2] & 0xFF)) << 8) | (buf[1] & 0xFF)) << 8) | (buf[0] & 0xFF);\n}",
			"comments":"/**\n* Answer an integer comprised of the next\n* four bytes of the input stream.\n*/\n",
			"methodName":"public int readInt() throws IOException"
		}
	},
	"ClassORInterfaceName":[
		"LEDataInputStream"
	]
}
