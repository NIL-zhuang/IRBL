{
	"variables":[
		"text",
		"layout",
		"linkColor",
		"linkDisabledColor",
		"offsets",
		"selection",
		"ids",
		"mnemonics",
		"focusIndex",
		"font",
		"LINK_FOREGROUND",
		"LinkProc",
		"LinkClass",
		"lpWndClass",
		"typedListener",
		"width",
		"height",
		"hDC",
		"newFont",
		"oldFont",
		"buffer",
		"rect",
		"flags",
		"layoutWidth",
		"rect",
		"rect",
		"border",
		"selStart",
		"selEnd",
		"rects",
		"i",
		"rectangle",
		"event",
		"item",
		"linkStyle",
		"i",
		"point",
		"accessible",
		"rect",
		"lineCount",
		"rects",
		"lineOffsets",
		"point",
		"lineStart",
		"lineEnd",
		"index",
		"i",
		"tmp",
		"length",
		"result",
		"buffer",
		"index",
		"state",
		"linkIndex",
		"start",
		"tagStart",
		"linkStart",
		"endtagStart",
		"refStart",
		"c",
		"offset",
		"tmp",
		"mnemonic",
		"newOffsets",
		"newIDs",
		"newMnemonics",
		"mnemonic",
		"index",
		"buffer",
		"bits",
		"enabled",
		"linkStyle",
		"i",
		"point",
		"mnemonicStyle",
		"i",
		"mnemonic",
		"bits",
		"result",
		"event",
		"next",
		"code",
		"result",
		"index",
		"count",
		"code",
		"item",
		"next",
		"result",
		"code",
		"result",
		"result",
		"result",
		"x",
		"y",
		"offset",
		"oldSelectionX",
		"oldSelectionY",
		"temp",
		"rect",
		"j",
		"rects",
		"i",
		"rect",
		"result",
		"x",
		"y",
		"rects",
		"i",
		"rect",
		"event",
		"result",
		"x",
		"y",
		"oldSelection",
		"newSelection",
		"temp",
		"rect",
		"j",
		"rects",
		"i",
		"rect",
		"ps",
		"data",
		"gc",
		"width",
		"height",
		"rect",
		"result",
		"rect",
		"data",
		"gc",
		"result",
		"result",
		"rect",
		"result",
		"control",
		"rect",
		"hdr",
		"item",
		"event",
		"OS",
		"OS",
		"OS",
		"LinkClass",
		"lpWndClass",
		"LinkProc",
		"lpWndClass",
		"LinkProc",
		"parent",
		"style",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"SWT",
		"typedListener",
		"handle",
		"LinkProc",
		"OS",
		"LinkProc",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"OS",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"wHint",
		"SWT",
		"wHint",
		"wHint",
		"hHint",
		"SWT",
		"hHint",
		"hHint",
		"OS",
		"OS",
		"handle",
		"OS",
		"handle",
		"OS",
		"OS",
		"hDC",
		"newFont",
		"text",
		"OS",
		"wHint",
		"SWT",
		"flags",
		"OS",
		"rect",
		"wHint",
		"OS",
		"hDC",
		"buffer",
		"buffer",
		"rect",
		"flags",
		"width",
		"rect",
		"rect",
		"height",
		"rect",
		"newFont",
		"OS",
		"hDC",
		"oldFont",
		"OS",
		"handle",
		"hDC",
		"layout",
		"wHint",
		"layout",
		"layout",
		"width",
		"height",
		"rect",
		"layout",
		"wHint",
		"layout",
		"width",
		"rect",
		"height",
		"rect",
		"layout",
		"layoutWidth",
		"wHint",
		"SWT",
		"width",
		"wHint",
		"hHint",
		"SWT",
		"height",
		"hHint",
		"width",
		"border",
		"height",
		"border",
		"width",
		"height",
		"OS",
		"layout",
		"display",
		"linkColor",
		"display",
		"LINK_FOREGROUND",
		"linkDisabledColor",
		"Color",
		"display",
		"OS",
		"OS",
		"offsets",
		"ids",
		"mnemonics",
		"selection",
		"focusIndex",
		"text",
		"OS",
		"style",
		"SWT",
		"layout",
		"SWT",
		"gc",
		"rect",
		"selection",
		"selection",
		"selStart",
		"selEnd",
		"selStart",
		"selection",
		"selEnd",
		"selection",
		"selStart",
		"selEnd",
		"layout",
		"gc",
		"selStart",
		"selEnd",
		"focusIndex",
		"focusIndex",
		"i",
		"rects",
		"i",
		"rects",
		"i",
		"gc",
		"rectangle",
		"rectangle",
		"rectangle",
		"rectangle",
		"SWT",
		"SWT",
		"event",
		"gc",
		"event",
		"rect",
		"event",
		"rect",
		"event",
		"rect",
		"rect",
		"event",
		"rect",
		"rect",
		"SWT",
		"event",
		"event",
		"OS",
		"item",
		"OS",
		"OS",
		"item",
		"OS",
		"item",
		"enabled",
		"OS",
		"OS",
		"handle",
		"OS",
		"item",
		"item",
		"enabled",
		"linkColor",
		"linkDisabledColor",
		"linkStyle",
		"i",
		"offsets",
		"i",
		"offsets",
		"i",
		"layout",
		"linkStyle",
		"point",
		"point",
		"enabled",
		"accessible",
		"e",
		"text",
		"accessible",
		"e",
		"ACC",
		"display",
		"e",
		"rect",
		"e",
		"rect",
		"e",
		"rect",
		"e",
		"rect",
		"e",
		"e",
		"ACC",
		"e",
		"ACC",
		"e",
		"ACC",
		"e",
		"SWT",
		"e",
		"ACC",
		"e",
		"ACC",
		"layout",
		"lineCount",
		"layout",
		"offsets",
		"linkIndex",
		"point",
		"lineOffsets",
		"lineStart",
		"lineStart",
		"point",
		"lineOffsets",
		"lineEnd",
		"lineEnd",
		"lineStart",
		"lineEnd",
		"rects",
		"index",
		"layout",
		"point",
		"point",
		"rects",
		"index",
		"layout",
		"point",
		"lineOffsets",
		"lineStart",
		"rects",
		"index",
		"layout",
		"lineOffsets",
		"lineEnd",
		"point",
		"lineEnd",
		"lineStart",
		"lineStart",
		"i",
		"lineEnd",
		"i",
		"rects",
		"index",
		"layout",
		"i",
		"rects",
		"index",
		"index",
		"System",
		"rects",
		"tmp",
		"index",
		"rects",
		"tmp",
		"rects",
		"text",
		"string",
		"offsets",
		"length",
		"ids",
		"length",
		"mnemonics",
		"length",
		"length",
		"string",
		"string",
		"buffer",
		"index",
		"length",
		"Character",
		"buffer",
		"index",
		"state",
		"c",
		"tagStart",
		"index",
		"state",
		"c",
		"state",
		"c",
		"state",
		"linkStart",
		"index",
		"state",
		"Character",
		"c",
		"state",
		"c",
		"endtagStart",
		"index",
		"state",
		"state",
		"c",
		"state",
		"state",
		"c",
		"state",
		"c",
		"mnemonics",
		"linkIndex",
		"buffer",
		"start",
		"tagStart",
		"result",
		"result",
		"buffer",
		"linkStart",
		"endtagStart",
		"result",
		"offsets",
		"linkIndex",
		"offset",
		"result",
		"ids",
		"linkIndex",
		"ids",
		"linkIndex",
		"buffer",
		"linkStart",
		"endtagStart",
		"linkStart",
		"linkIndex",
		"start",
		"tagStart",
		"linkStart",
		"endtagStart",
		"refStart",
		"index",
		"state",
		"state",
		"state",
		"c",
		"state",
		"state",
		"c",
		"state",
		"state",
		"c",
		"state",
		"state",
		"c",
		"state",
		"c",
		"state",
		"refStart",
		"index",
		"state",
		"c",
		"ids",
		"linkIndex",
		"buffer",
		"refStart",
		"index",
		"refStart",
		"state",
		"Character",
		"c",
		"state",
		"c",
		"state",
		"state",
		"c",
		"state",
		"c",
		"state",
		"state",
		"index",
		"start",
		"length",
		"buffer",
		"start",
		"tagStart",
		"result",
		"buffer",
		"linkStart",
		"index",
		"result",
		"mnemonic",
		"mnemonic",
		"tmp",
		"mnemonics",
		"linkIndex",
		"mnemonic",
		"mnemonics",
		"linkIndex",
		"offsets",
		"linkIndex",
		"linkIndex",
		"System",
		"offsets",
		"newOffsets",
		"linkIndex",
		"offsets",
		"newOffsets",
		"linkIndex",
		"System",
		"ids",
		"newIDs",
		"linkIndex",
		"ids",
		"newIDs",
		"linkIndex",
		"System",
		"mnemonics",
		"newMnemonics",
		"linkIndex",
		"mnemonics",
		"newMnemonics",
		"result",
		"start",
		"index",
		"end",
		"buffer",
		"index",
		"index",
		"end",
		"buffer",
		"index",
		"result",
		"buffer",
		"index",
		"index",
		"mnemonic",
		"result",
		"result",
		"buffer",
		"index",
		"index",
		"mnemonic",
		"layout",
		"layout",
		"layout",
		"linkColor",
		"linkColor",
		"linkColor",
		"linkDisabledColor",
		"offsets",
		"ids",
		"mnemonics",
		"text",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"eventTable",
		"SWT",
		"listener",
		"string",
		"SWT",
		"string",
		"text",
		"text",
		"string",
		"OS",
		"string",
		"OS",
		"handle",
		"buffer",
		"string",
		"layout",
		"string",
		"focusIndex",
		"offsets",
		"selection",
		"selection",
		"OS",
		"handle",
		"OS",
		"offsets",
		"bits",
		"OS",
		"bits",
		"OS",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"handle",
		"enabled",
		"linkColor",
		"linkDisabledColor",
		"linkStyle",
		"i",
		"offsets",
		"i",
		"offsets",
		"i",
		"layout",
		"linkStyle",
		"point",
		"point",
		"mnemonicStyle",
		"i",
		"mnemonics",
		"i",
		"mnemonics",
		"i",
		"mnemonic",
		"layout",
		"mnemonicStyle",
		"mnemonic",
		"mnemonic",
		"bits",
		"OS",
		"OS",
		"LinkClass",
		"display",
		"LinkProc",
		"LinkProc",
		"display",
		"wParam",
		"lParam",
		"result",
		"result",
		"OS",
		"focusIndex",
		"result",
		"wParam",
		"SWT",
		"event",
		"ids",
		"focusIndex",
		"SWT",
		"event",
		"SWT",
		"OS",
		"OS",
		"next",
		"focusIndex",
		"offsets",
		"focusIndex",
		"focusIndex",
		"focusIndex",
		"wParam",
		"SWT",
		"SWT",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"code",
		"result",
		"wParam",
		"lParam",
		"result",
		"result",
		"OS",
		"item",
		"OS",
		"OS",
		"item",
		"OS",
		"index",
		"OS",
		"handle",
		"OS",
		"item",
		"item",
		"OS",
		"index",
		"item",
		"item",
		"count",
		"item",
		"code",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"index",
		"focusIndex",
		"count",
		"offsets",
		"count",
		"code",
		"OS",
		"OS",
		"OS",
		"next",
		"index",
		"count",
		"code",
		"OS",
		"next",
		"index",
		"code",
		"OS",
		"result",
		"wParam",
		"lParam",
		"result",
		"result",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"code",
		"code",
		"font",
		"font",
		"font",
		"wParam",
		"lParam",
		"result",
		"result",
		"OS",
		"wParam",
		"OS",
		"OS",
		"OS",
		"LRESULT",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"focusIndex",
		"lParam",
		"lParam",
		"layout",
		"x",
		"y",
		"selection",
		"selection",
		"selection",
		"offset",
		"selection",
		"oldSelectionX",
		"oldSelectionY",
		"oldSelectionX",
		"oldSelectionY",
		"oldSelectionX",
		"oldSelectionX",
		"oldSelectionY",
		"oldSelectionY",
		"temp",
		"layout",
		"oldSelectionX",
		"oldSelectionY",
		"rect",
		"rect",
		"rect",
		"rect",
		"j",
		"offsets",
		"j",
		"j",
		"i",
		"rects",
		"i",
		"rects",
		"i",
		"rect",
		"x",
		"y",
		"j",
		"focusIndex",
		"focusIndex",
		"j",
		"result",
		"result",
		"wParam",
		"lParam",
		"OS",
		"focusIndex",
		"result",
		"lParam",
		"lParam",
		"focusIndex",
		"i",
		"rects",
		"i",
		"rects",
		"i",
		"rect",
		"x",
		"y",
		"event",
		"ids",
		"focusIndex",
		"SWT",
		"event",
		"result",
		"result",
		"wParam",
		"lParam",
		"OS",
		"lParam",
		"lParam",
		"OS",
		"OS",
		"selection",
		"selection",
		"layout",
		"x",
		"y",
		"selection",
		"oldSelection",
		"selection",
		"oldSelection",
		"newSelection",
		"oldSelection",
		"oldSelection",
		"newSelection",
		"newSelection",
		"temp",
		"layout",
		"oldSelection",
		"newSelection",
		"rect",
		"rect",
		"rect",
		"rect",
		"j",
		"offsets",
		"j",
		"j",
		"i",
		"rects",
		"i",
		"rects",
		"i",
		"rect",
		"x",
		"y",
		"display",
		"SWT",
		"result",
		"result",
		"OS",
		"wParam",
		"lParam",
		"data",
		"ps",
		"data",
		"handle",
		"data",
		"gc",
		"ps",
		"ps",
		"ps",
		"ps",
		"width",
		"height",
		"OS",
		"rect",
		"ps",
		"ps",
		"ps",
		"ps",
		"gc",
		"rect",
		"gc",
		"LRESULT",
		"wParam",
		"lParam",
		"OS",
		"OS",
		"handle",
		"rect",
		"data",
		"display",
		"GC",
		"wParam",
		"data",
		"gc",
		"rect",
		"gc",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"OS",
		"layout",
		"Font",
		"display",
		"wParam",
		"font",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"OS",
		"OS",
		"handle",
		"rect",
		"layout",
		"rect",
		"rect",
		"result",
		"wParam",
		"lParam",
		"OS",
		"OS",
		"control",
		"OS",
		"wParam",
		"OS",
		"OS",
		"control",
		"rect",
		"OS",
		"control",
		"handle",
		"rect",
		"control",
		"wParam",
		"rect",
		"OS",
		"OS",
		"result",
		"OS",
		"OS",
		"hdr",
		"lParam",
		"NMHDR",
		"hdr",
		"OS",
		"OS",
		"OS",
		"item",
		"lParam",
		"NMLINK",
		"event",
		"ids",
		"item",
		"SWT",
		"event",
		"wParam",
		"lParam",
		"WC_LINK",
		"COMCTL32_MAJOR",
		"lpfnWndProc",
		"ERROR_NULL_ARGUMENT",
		"Selection",
		"DefaultSelection",
		"DEFAULT",
		"DEFAULT",
		"COMCTL32_MAJOR",
		"WM_GETFONT",
		"DT_CALCRECT",
		"DEFAULT",
		"DT_WORDBREAK",
		"right",
		"right",
		"left",
		"bottom",
		"height",
		"width",
		"height",
		"DEFAULT",
		"DEFAULT",
		"COMCTL32_MAJOR",
		"COLOR_GRAYTEXT",
		"COMCTL32_MAJOR",
		"MIRRORED",
		"RIGHT_TO_LEFT",
		"handle",
		"x",
		"y",
		"y",
		"x",
		"length",
		"x",
		"y",
		"width",
		"height",
		"Paint",
		"Paint",
		"gc",
		"x",
		"left",
		"y",
		"top",
		"width",
		"right",
		"left",
		"height",
		"bottom",
		"top",
		"Paint",
		"gc",
		"COMCTL32_MAJOR",
		"mask",
		"LIF_ITEMINDEX",
		"LIF_STATE",
		"stateMask",
		"LIS_ENABLED",
		"state",
		"LIS_ENABLED",
		"LM_SETITEM",
		"iLink",
		"underline",
		"length",
		"x",
		"y",
		"result",
		"childID",
		"CHILDID_SELF",
		"x",
		"x",
		"y",
		"y",
		"width",
		"width",
		"height",
		"height",
		"detail",
		"detail",
		"ROLE_LINK",
		"detail",
		"STATE_FOCUSABLE",
		"detail",
		"STATE_FOCUSED",
		"result",
		"childID",
		"CHILDID_SELF",
		"childID",
		"CHILDID_SELF",
		"x",
		"y",
		"x",
		"y",
		"x",
		"y",
		"length",
		"length",
		"ERROR_NULL_ARGUMENT",
		"Selection",
		"DefaultSelection",
		"ERROR_NULL_ARGUMENT",
		"COMCTL32_MAJOR",
		"length",
		"x",
		"y",
		"GWL_STYLE",
		"length",
		"WS_TABSTOP",
		"WS_TABSTOP",
		"GWL_STYLE",
		"underline",
		"length",
		"x",
		"y",
		"underline",
		"length",
		"WS_TABSTOP",
		"COMCTL32_MAJOR",
		"windowClass",
		"windowProc",
		"COMCTL32_MAJOR",
		"CR",
		"text",
		"Selection",
		"TAB",
		"VK_SHIFT",
		"length",
		"CR",
		"TAB",
		"WM_KEYDOWN",
		"COMCTL32_MAJOR",
		"mask",
		"LIF_ITEMINDEX",
		"LIF_STATE",
		"stateMask",
		"LIS_FOCUSED",
		"LM_GETITEM",
		"state",
		"LIS_FOCUSED",
		"iLink",
		"iLink",
		"iLink",
		"WM_GETDLGCODE",
		"length",
		"DLGC_STATIC",
		"VK_SHIFT",
		"DLGC_WANTTAB",
		"DLGC_WANTTAB",
		"WM_GETFONT",
		"COMCTL32_MAJOR",
		"VK_SPACE",
		"VK_RETURN",
		"VK_TAB",
		"ZERO",
		"COMCTL32_MAJOR",
		"COMCTL32_MAJOR",
		"x",
		"y",
		"x",
		"y",
		"x",
		"y",
		"width",
		"height",
		"length",
		"length",
		"COMCTL32_MAJOR",
		"length",
		"text",
		"Selection",
		"COMCTL32_MAJOR",
		"VK_LBUTTON",
		"y",
		"y",
		"y",
		"y",
		"x",
		"y",
		"width",
		"height",
		"length",
		"length",
		"CURSOR_HAND",
		"COMCTL32_MAJOR",
		"ps",
		"hwnd",
		"right",
		"left",
		"bottom",
		"top",
		"left",
		"top",
		"right",
		"bottom",
		"ZERO",
		"COMCTL32_MAJOR",
		"device",
		"COMCTL32_MAJOR",
		"COMCTL32_MAJOR",
		"COMCTL32_MAJOR",
		"right",
		"right",
		"COMCTL32_MAJOR",
		"TRANSPARENT",
		"handle",
		"handle",
		"NULL_BRUSH",
		"COMCTL32_MAJOR",
		"sizeof",
		"code",
		"NM_RETURN",
		"NM_CLICK",
		"sizeof",
		"text",
		"iLink",
		"Selection",
		"parent",
		"style",
		"listener",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"wHint",
		"hHint",
		"changed",
		"gc",
		"rect",
		"enabled",
		"e",
		"e",
		"e",
		"e",
		"e",
		"e",
		"e",
		"e",
		"e",
		"linkIndex",
		"string",
		"buffer",
		"start",
		"end",
		"result",
		"listener",
		"string",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam"
	],
	"extendORImplementFiles":[
		"Control"
	],
	"package":[
		"org.eclipse.swt.widgets"
	],
	"import":[
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt",
		"org.eclipse.swt.graphics",
		"org.eclipse.swt.events",
		"org.eclipse.swt.accessibility"
	],
	"methods":[
		"addSelectionListener",
		"callWindowProc",
		"computeSize",
		"createHandle",
		"createWidget",
		"drawWidget",
		"enableWidget",
		"initAccessible",
		"getName",
		"getChildAtPoint",
		"getLocation",
		"getChildCount",
		"getRole",
		"getState",
		"getDefaultAction",
		"getSelection",
		"getFocus",
		"getNameText",
		"getRectangles",
		"getText",
		"parse",
		"parseMnemonics",
		"releaseWidget",
		"removeSelectionListener",
		"setText",
		"widgetStyle",
		"windowClass",
		"windowProc",
		"WM_CHAR",
		"WM_GETDLGCODE",
		"WM_GETFONT",
		"WM_KEYDOWN",
		"WM_KILLFOCUS",
		"WM_LBUTTONDOWN",
		"WM_LBUTTONUP",
		"WM_MOUSEMOVE",
		"WM_PAINT",
		"WM_PRINTCLIENT",
		"WM_SETFOCUS",
		"WM_SETFONT",
		"WM_SIZE",
		"wmColorChild",
		"wmNotifyChild",
		"GetClassInfo",
		"checkWidget",
		"error",
		"addListener",
		"addListener",
		"CallWindowProc",
		"DefWindowProc",
		"checkWidget",
		"GetDC",
		"SendMessage",
		"SelectObject",
		"getCodePage",
		"parse",
		"DrawText",
		"length",
		"SelectObject",
		"ReleaseDC",
		"getWidth",
		"setWidth",
		"getBounds",
		"setWidth",
		"getBounds",
		"setWidth",
		"getBorderWidth",
		"createHandle",
		"win32_new",
		"GetSysColor",
		"createWidget",
		"setOrientation",
		"initAccessible",
		"drawBackground",
		"draw",
		"hasFocus",
		"getRectangles",
		"drawFocus",
		"hooks",
		"filters",
		"sendEvent",
		"SendMessage",
		"setStyle",
		"redraw",
		"enableWidget",
		"getAccessible",
		"addAccessibleListener",
		"parse",
		"addAccessibleControlListener",
		"map",
		"getParent",
		"getBounds",
		"hasFocus",
		"getMessage",
		"hasFocus",
		"hasFocus",
		"getText",
		"getLineCount",
		"getLineOffsets",
		"getBounds",
		"getBounds",
		"getBounds",
		"getLineBounds",
		"arraycopy",
		"checkWidget",
		"length",
		"getChars",
		"length",
		"toLowerCase",
		"isWhitespace",
		"parseMnemonics",
		"length",
		"parseMnemonics",
		"length",
		"isWhitespace",
		"parseMnemonics",
		"parseMnemonics",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"toString",
		"append",
		"length",
		"append",
		"releaseWidget",
		"dispose",
		"dispose",
		"checkWidget",
		"error",
		"unhook",
		"unhook",
		"checkWidget",
		"error",
		"equals",
		"getCodePage",
		"SetWindowText",
		"parse",
		"setText",
		"parse",
		"GetWindowLong",
		"SetWindowLong",
		"IsWindowEnabled",
		"setStyle",
		"setStyle",
		"redraw",
		"widgetStyle",
		"WM_CHAR",
		"sendEvent",
		"GetKeyState",
		"redraw",
		"redraw",
		"callWindowProc",
		"WM_GETDLGCODE",
		"SendMessage",
		"callWindowProc",
		"GetKeyState",
		"WM_GETFONT",
		"callWindowProc",
		"defaultFont",
		"WM_KEYDOWN",
		"WM_KILLFOCUS",
		"redraw",
		"WM_LBUTTONDOWN",
		"setFocus",
		"getOffset",
		"getBounds",
		"redraw",
		"getRectangles",
		"contains",
		"redraw",
		"WM_LBUTTONUP",
		"getRectangles",
		"contains",
		"sendEvent",
		"WM_MOUSEMOVE",
		"GetKeyState",
		"getOffset",
		"getBounds",
		"redraw",
		"getRectangles",
		"contains",
		"setCursor",
		"getSystemCursor",
		"setCursor",
		"WM_PAINT",
		"new_GC",
		"SetRect",
		"drawWidget",
		"dispose",
		"WM_PRINTCLIENT",
		"GetClientRect",
		"win32_new",
		"drawWidget",
		"dispose",
		"WM_SETFOCUS",
		"redraw",
		"setFont",
		"win32_new",
		"WM_SETFONT",
		"WM_SIZE",
		"GetClientRect",
		"setWidth",
		"redraw",
		"wmColorChild",
		"IsAppThemed",
		"findThemeControl",
		"SetBkMode",
		"GetClientRect",
		"MapWindowPoints",
		"drawThemeBackground",
		"GetStockObject",
		"MoveMemory",
		"MoveMemory",
		"sendEvent",
		"wmNotifyChild",
		"RGB",
		"TCHAR",
		"WNDCLASS",
		"TypedListener",
		"TCHAR",
		"RECT",
		"Point",
		"TextLayout",
		"Color",
		"Point",
		"Event",
		"LITEM",
		"TextStyle",
		"AccessibleAdapter",
		"AccessibleControlAdapter",
		"StringBuffer",
		"Point",
		"String",
		"String",
		"TCHAR",
		"TextStyle",
		"TextStyle",
		"Event",
		"LRESULT",
		"LITEM",
		"LRESULT",
		"LRESULT",
		"LRESULT",
		"LRESULT",
		"LRESULT",
		"Event",
		"PAINTSTRUCT",
		"GCData",
		"RECT",
		"RECT",
		"GCData",
		"RECT",
		"RECT",
		"LRESULT",
		"NMHDR",
		"NMLINK",
		"Event"
	],
	"methodsBody":{
		"public void setText(String string)":{
			"methodBody":"{\n    checkWidget();\n    if (string == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (string.equals(text))\n        return;\n    text = string;\n    if (OS.COMCTL32_MAJOR >= 6) {\n        TCHAR buffer = new TCHAR(getCodePage(), string, true);\n        OS.SetWindowText(handle, buffer);\n        parse(string);\n    } else {\n        layout.setText(parse(string));\n        focusIndex = offsets.length > 0 ? 0 : -1;\n        selection.x = selection.y = -1;\n        int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n        if (offsets.length > 0) {\n            bits |= OS.WS_TABSTOP;\n        } else {\n            bits &= ~OS.WS_TABSTOP;\n        }\n        OS.SetWindowLong(handle, OS.GWL_STYLE, bits);\n        boolean enabled = OS.IsWindowEnabled(handle);\n        TextStyle linkStyle = new TextStyle(null, enabled ? linkColor : linkDisabledColor, null);\n        linkStyle.underline = true;\n        for (int i = 0; i < offsets.length; i++) {\n            Point point = offsets[i];\n            layout.setStyle(linkStyle, point.x, point.y);\n        }\n        TextStyle mnemonicStyle = new TextStyle(null, null, null);\n        mnemonicStyle.underline = true;\n        for (int i = 0; i < mnemonics.length; i++) {\n            int mnemonic = mnemonics[i];\n            if (mnemonic != -1) {\n                layout.setStyle(mnemonicStyle, mnemonic, mnemonic);\n            }\n        }\n        redraw();\n    }\n}",
			"comments":"/**\n* Sets the receiver's text.\n* <p>\n* The string can contain both regular text and hyperlinks.  A hyperlink\n* is delimited by an anchor tag, &lt;A&gt; and &lt;/A&gt;.  Within an\n* anchor, a single HREF attribute is supported.  When a hyperlink is\n* selected, the text field of the selection event contains either the\n* text of the hyperlink or the value of its HREF, if one was specified.\n* In the rare case of identical hyperlinks within the same string, the\n* HREF tag can be used to distinguish between them.  The string may\n* include the mnemonic character and line delimiters.\n* </p>\n*\n* @param string the new text\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the text is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setText(String string)"
		},
		"public void getSelection(AccessibleControlEvent e)":{
			"methodBody":"{\n    if (hasFocus())\n        e.childID = ACC.CHILDID_SELF;\n}",
			"comments":"",
			"methodName":"public void getSelection(AccessibleControlEvent e)"
		},
		"LRESULT wmNotifyChild(int wParam, int lParam)":{
			"methodBody":"{\n    if (OS.COMCTL32_MAJOR >= 6) {\n        NMHDR hdr = new NMHDR();\n        OS.MoveMemory(hdr, lParam, NMHDR.sizeof);\n        switch(hdr.code) {\n            case OS.NM_RETURN:\n            case OS.NM_CLICK:\n                NMLINK item = new NMLINK();\n                OS.MoveMemory(item, lParam, NMLINK.sizeof);\n                Event event = new Event();\n                event.text = ids[item.iLink];\n                sendEvent(SWT.Selection, event);\n                break;\n        }\n    }\n    return super.wmNotifyChild(wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT wmNotifyChild(int wParam, int lParam)"
		},
		"int parseMnemonics(char[] buffer, int start, int end, StringBuffer result)":{
			"methodBody":"{\n    int mnemonic = -1, index = start;\n    while (index < end) {\n        if (buffer[index] == '&') {\n            if (index + 1 < end && buffer[index + 1] == '&') {\n                result.append(buffer[index]);\n                index++;\n            } else {\n                mnemonic = result.length();\n            }\n        } else {\n            result.append(buffer[index]);\n        }\n        index++;\n    }\n    return mnemonic;\n}",
			"comments":"",
			"methodName":"int parseMnemonics(char[] buffer, int start, int end, StringBuffer result)"
		},
		"void enableWidget(boolean enabled)":{
			"methodBody":"{\n    if (OS.COMCTL32_MAJOR >= 6) {\n        LITEM item = new LITEM();\n        item.mask = OS.LIF_ITEMINDEX | OS.LIF_STATE;\n        item.stateMask = OS.LIS_ENABLED;\n        item.state = enabled ? OS.LIS_ENABLED : 0;\n        while (OS.SendMessage(handle, OS.LM_SETITEM, 0, item) != 0) {\n            item.iLink++;\n        }\n    } else {\n        TextStyle linkStyle = new TextStyle(null, enabled ? linkColor : linkDisabledColor, null);\n        linkStyle.underline = true;\n        for (int i = 0; i < offsets.length; i++) {\n            Point point = offsets[i];\n            layout.setStyle(linkStyle, point.x, point.y);\n        }\n        redraw();\n    }\n    \n    super.enableWidget(enabled);\n}",
			"comments":"/*\n* Feature in Windows.  For some reason, setting\n* LIS_ENABLED state using LM_SETITEM causes the\n* SysLink to become enabled.  To be specific,\n* calling IsWindowEnabled() returns true.  The\n* fix is disable the SysLink after LM_SETITEM.\n*/\n",
			"methodName":"void enableWidget(boolean enabled)"
		},
		"public void getChildAtPoint(AccessibleControlEvent e)":{
			"methodBody":"{\n    e.childID = ACC.CHILDID_SELF;\n}",
			"comments":"",
			"methodName":"public void getChildAtPoint(AccessibleControlEvent e)"
		},
		"LRESULT wmColorChild(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.wmColorChild(wParam, lParam);\n    if (OS.COMCTL32_MAJOR >= 6 && OS.IsAppThemed()) {\n        Control control = findThemeControl();\n        if (control != null) {\n            OS.SetBkMode(wParam, OS.TRANSPARENT);\n            RECT rect = new RECT();\n            OS.GetClientRect(control.handle, rect);\n            OS.MapWindowPoints(control.handle, handle, rect, 2);\n            control.drawThemeBackground(wParam, rect);\n            return new LRESULT(OS.GetStockObject(OS.NULL_BRUSH));\n        }\n    }\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT wmColorChild(int wParam, int lParam)"
		},
		"LRESULT WM_SETFOCUS(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_SETFOCUS(wParam, lParam);\n    if (OS.COMCTL32_MAJOR < 6)\n        redraw();\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_SETFOCUS(int wParam, int lParam)"
		},
		"LRESULT WM_GETFONT(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_GETFONT(wParam, lParam);\n    if (result != null)\n        return result;\n    int code = callWindowProc(handle, OS.WM_GETFONT, wParam, lParam);\n    if (code != 0)\n        return new LRESULT(code);\n    if (font == 0)\n        font = defaultFont();\n    return new LRESULT(font);\n}",
			"comments":"",
			"methodName":"LRESULT WM_GETFONT(int wParam, int lParam)"
		},
		"public void getFocus(AccessibleControlEvent e)":{
			"methodBody":"{\n    if (hasFocus())\n        e.childID = ACC.CHILDID_SELF;\n}",
			"comments":"",
			"methodName":"public void getFocus(AccessibleControlEvent e)"
		},
		"LRESULT WM_LBUTTONUP(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_LBUTTONUP(wParam, lParam);\n    if (OS.COMCTL32_MAJOR < 6) {\n        if (focusIndex == -1)\n            return result;\n        int x = lParam & 0xFFFF;\n        int y = lParam >> 16;\n        Rectangle[] rects = getRectangles(focusIndex);\n        for (int i = 0; i < rects.length; i++) {\n            Rectangle rect = rects[i];\n            if (rect.contains(x, y)) {\n                Event event = new Event();\n                event.text = ids[focusIndex];\n                sendEvent(SWT.Selection, event);\n                return result;\n            }\n        }\n    }\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_LBUTTONUP(int wParam, int lParam)"
		},
		"LRESULT WM_PRINTCLIENT(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_PRINTCLIENT(wParam, lParam);\n    if (OS.COMCTL32_MAJOR < 6) {\n        RECT rect = new RECT();\n        OS.GetClientRect(handle, rect);\n        GCData data = new GCData();\n        data.device = display;\n        GC gc = GC.win32_new(wParam, data);\n        drawWidget(gc, rect);\n        gc.dispose();\n    }\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_PRINTCLIENT(int wParam, int lParam)"
		},
		"public void removeSelectionListener(SelectionListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.Selection, listener);\n    eventTable.unhook(SWT.DefaultSelection, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when the control is selected.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see SelectionListener\n* @see #addSelectionListener\n*/\n",
			"methodName":"public void removeSelectionListener(SelectionListener listener)"
		},
		"void createWidget()":{
			"methodBody":"{\n    super.createWidget();\n    text = \"\";\n    if (OS.COMCTL32_MAJOR < 6) {\n        if ((style & SWT.MIRRORED) != 0) {\n            layout.setOrientation(SWT.RIGHT_TO_LEFT);\n        }\n        initAccessible();\n    }\n}",
			"comments":"",
			"methodName":"void createWidget()"
		},
		"LRESULT WM_LBUTTONDOWN(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_LBUTTONDOWN(wParam, lParam);\n    if (OS.COMCTL32_MAJOR < 6) {\n        if (focusIndex != -1)\n            setFocus();\n        int x = lParam & 0xFFFF;\n        int y = lParam >> 16;\n        int offset = layout.getOffset(x, y, null);\n        int oldSelectionX = selection.x;\n        int oldSelectionY = selection.y;\n        selection.x = offset;\n        selection.y = -1;\n        if (oldSelectionX != -1 && oldSelectionY != -1) {\n            if (oldSelectionX > oldSelectionY) {\n                int temp = oldSelectionX;\n                oldSelectionX = oldSelectionY;\n                oldSelectionY = temp;\n            }\n            Rectangle rect = layout.getBounds(oldSelectionX, oldSelectionY);\n            redraw(rect.x, rect.y, rect.width, rect.height, false);\n        }\n        for (int j = 0; j < offsets.length; j++) {\n            Rectangle[] rects = getRectangles(j);\n            for (int i = 0; i < rects.length; i++) {\n                Rectangle rect = rects[i];\n                if (rect.contains(x, y)) {\n                    if (j != focusIndex) {\n                        focusIndex = j;\n                        redraw();\n                    }\n                    return result;\n                }\n            }\n        }\n    }\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_LBUTTONDOWN(int wParam, int lParam)"
		},
		"public void getRole(AccessibleControlEvent e)":{
			"methodBody":"{\n    e.detail = ACC.ROLE_LINK;\n}",
			"comments":"",
			"methodName":"public void getRole(AccessibleControlEvent e)"
		},
		"public Point computeSize(int wHint, int hHint, boolean changed)":{
			"methodBody":"{\n    checkWidget();\n    if (wHint != SWT.DEFAULT && wHint < 0)\n        wHint = 0;\n    if (hHint != SWT.DEFAULT && hHint < 0)\n        hHint = 0;\n    int width, height;\n    if (OS.COMCTL32_MAJOR >= 6) {\n        int hDC = OS.GetDC(handle);\n        int newFont = OS.SendMessage(handle, OS.WM_GETFONT, 0, 0);\n        int oldFont = OS.SelectObject(hDC, newFont);\n        TCHAR buffer = new TCHAR(getCodePage(), parse(text), false);\n        RECT rect = new RECT();\n        int flags = OS.DT_CALCRECT;\n        if (wHint != SWT.DEFAULT) {\n            flags |= OS.DT_WORDBREAK;\n            rect.right = wHint;\n        }\n        OS.DrawText(hDC, buffer, buffer.length(), rect, flags);\n        width = rect.right - rect.left;\n        height = rect.bottom;\n        if (newFont != 0)\n            OS.SelectObject(hDC, oldFont);\n        OS.ReleaseDC(handle, hDC);\n    } else {\n        int layoutWidth = layout.getWidth();\n        \n        if (wHint == 0) {\n            layout.setWidth(1);\n            Rectangle rect = layout.getBounds();\n            width = 0;\n            height = rect.height;\n        } else {\n            layout.setWidth(wHint);\n            Rectangle rect = layout.getBounds();\n            width = rect.width;\n            height = rect.height;\n        }\n        layout.setWidth(layoutWidth);\n    }\n    if (wHint != SWT.DEFAULT)\n        width = wHint;\n    if (hHint != SWT.DEFAULT)\n        height = hHint;\n    int border = getBorderWidth();\n    width += border * 2;\n    height += border * 2;\n    return new Point(width, height);\n}",
			"comments":"//TEMPORARY CODE\n",
			"methodName":"public Point computeSize(int wHint, int hHint, boolean changed)"
		},
		"public void getState(AccessibleControlEvent e)":{
			"methodBody":"{\n    e.detail = ACC.STATE_FOCUSABLE;\n    if (hasFocus())\n        e.detail |= ACC.STATE_FOCUSED;\n}",
			"comments":"",
			"methodName":"public void getState(AccessibleControlEvent e)"
		},
		"public void getChildCount(AccessibleControlEvent e)":{
			"methodBody":"{\n    e.detail = 0;\n}",
			"comments":"",
			"methodName":"public void getChildCount(AccessibleControlEvent e)"
		},
		"LRESULT WM_SETFONT(int wParam, int lParam)":{
			"methodBody":"{\n    if (OS.COMCTL32_MAJOR < 6) {\n        layout.setFont(Font.win32_new(display, wParam));\n    }\n    return super.WM_SETFONT(font = wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_SETFONT(int wParam, int lParam)"
		},
		"TCHAR windowClass()":{
			"methodBody":"{\n    return OS.COMCTL32_MAJOR >= 6 ? LinkClass : display.windowClass;\n}",
			"comments":"",
			"methodName":"TCHAR windowClass()"
		},
		"LRESULT WM_SIZE(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_SIZE(wParam, lParam);\n    if (OS.COMCTL32_MAJOR < 6) {\n        RECT rect = new RECT();\n        OS.GetClientRect(handle, rect);\n        layout.setWidth(rect.right > 0 ? rect.right : -1);\n        redraw();\n    }\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_SIZE(int wParam, int lParam)"
		},
		"LRESULT WM_CHAR(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_CHAR(wParam, lParam);\n    if (result != null)\n        return result;\n    if (OS.COMCTL32_MAJOR < 6) {\n        if (focusIndex == -1)\n            return result;\n        switch(wParam) {\n            case ' ':\n            case SWT.CR:\n                Event event = new Event();\n                event.text = ids[focusIndex];\n                sendEvent(SWT.Selection, event);\n                break;\n            case SWT.TAB:\n                boolean next = OS.GetKeyState(OS.VK_SHIFT) >= 0;\n                if (next) {\n                    if (focusIndex < offsets.length - 1) {\n                        focusIndex++;\n                        redraw();\n                    }\n                } else {\n                    if (focusIndex > 0) {\n                        focusIndex--;\n                        redraw();\n                    }\n                }\n                break;\n        }\n    } else {\n        switch(wParam) {\n            case ' ':\n            case SWT.CR:\n            case SWT.TAB:\n                \n                int code = callWindowProc(handle, OS.WM_KEYDOWN, wParam, lParam);\n                return new LRESULT(code);\n        }\n    }\n    return result;\n}",
			"comments":"/*\n* NOTE: Call the window proc with WM_KEYDOWN rather than WM_CHAR\n* so that the key that was ignored during WM_KEYDOWN is processed.\n* This allows the application to cancel an operation that is normally\n* performed in WM_KEYDOWN from WM_CHAR.\n*/\n",
			"methodName":"LRESULT WM_CHAR(int wParam, int lParam)"
		},
		"public void getLocation(AccessibleControlEvent e)":{
			"methodBody":"{\n    Rectangle rect = display.map(getParent(), null, getBounds());\n    e.x = rect.x;\n    e.y = rect.y;\n    e.width = rect.width;\n    e.height = rect.height;\n}",
			"comments":"",
			"methodName":"public void getLocation(AccessibleControlEvent e)"
		},
		"LRESULT WM_PAINT(int wParam, int lParam)":{
			"methodBody":"{\n    if (OS.COMCTL32_MAJOR >= 6) {\n        return super.WM_PAINT(wParam, lParam);\n    }\n    PAINTSTRUCT ps = new PAINTSTRUCT();\n    GCData data = new GCData();\n    data.ps = ps;\n    data.hwnd = handle;\n    GC gc = new_GC(data);\n    if (gc != null) {\n        int width = ps.right - ps.left;\n        int height = ps.bottom - ps.top;\n        if (width != 0 && height != 0) {\n            RECT rect = new RECT();\n            OS.SetRect(rect, ps.left, ps.top, ps.right, ps.bottom);\n            drawWidget(gc, rect);\n        }\n        gc.dispose();\n    }\n    return LRESULT.ZERO;\n}",
			"comments":"",
			"methodName":"LRESULT WM_PAINT(int wParam, int lParam)"
		},
		"void createHandle()":{
			"methodBody":"{\n    super.createHandle();\n    if (OS.COMCTL32_MAJOR < 6) {\n        layout = new TextLayout(display);\n        linkColor = new Color(display, LINK_FOREGROUND);\n        linkDisabledColor = Color.win32_new(display, OS.GetSysColor(OS.COLOR_GRAYTEXT));\n        offsets = new Point[0];\n        ids = new String[0];\n        mnemonics = new int[0];\n        selection = new Point(-1, -1);\n        focusIndex = -1;\n    }\n}",
			"comments":"",
			"methodName":"void createHandle()"
		},
		"LRESULT WM_MOUSEMOVE(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_MOUSEMOVE(wParam, lParam);\n    if (OS.COMCTL32_MAJOR < 6) {\n        int x = lParam & 0xFFFF;\n        int y = lParam >> 16;\n        if (OS.GetKeyState(OS.VK_LBUTTON) < 0) {\n            int oldSelection = selection.y;\n            selection.y = layout.getOffset(x, y, null);\n            if (selection.y != oldSelection) {\n                int newSelection = selection.y;\n                if (oldSelection > newSelection) {\n                    int temp = oldSelection;\n                    oldSelection = newSelection;\n                    newSelection = temp;\n                }\n                Rectangle rect = layout.getBounds(oldSelection, newSelection);\n                redraw(rect.x, rect.y, rect.width, rect.height, false);\n            }\n        } else {\n            for (int j = 0; j < offsets.length; j++) {\n                Rectangle[] rects = getRectangles(j);\n                for (int i = 0; i < rects.length; i++) {\n                    Rectangle rect = rects[i];\n                    if (rect.contains(x, y)) {\n                        setCursor(display.getSystemCursor(SWT.CURSOR_HAND));\n                        return result;\n                    }\n                }\n            }\n            setCursor(null);\n        }\n    }\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_MOUSEMOVE(int wParam, int lParam)"
		},
		"String getNameText()":{
			"methodBody":"{\n    return getText();\n}",
			"comments":"",
			"methodName":"String getNameText()"
		},
		"public void getName(AccessibleEvent e)":{
			"methodBody":"{\n    e.result = parse(text);\n}",
			"comments":"",
			"methodName":"public void getName(AccessibleEvent e)"
		},
		"LRESULT WM_KILLFOCUS(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_KILLFOCUS(wParam, lParam);\n    if (OS.COMCTL32_MAJOR < 6)\n        redraw();\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_KILLFOCUS(int wParam, int lParam)"
		},
		"void releaseWidget()":{
			"methodBody":"{\n    super.releaseWidget();\n    if (layout != null)\n        layout.dispose();\n    layout = null;\n    if (linkColor != null)\n        linkColor.dispose();\n    linkColor = null;\n    linkDisabledColor = null;\n    offsets = null;\n    ids = null;\n    mnemonics = null;\n    text = null;\n}",
			"comments":"",
			"methodName":"void releaseWidget()"
		},
		"public String getText()":{
			"methodBody":"{\n    checkWidget();\n    return text;\n}",
			"comments":"/**\n* Returns the receiver's text, which will be an empty\n* string if it has never been set or if the receiver is\n* a <code>SEPARATOR</code> label.\n*\n* @return the receiver's text\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public String getText()"
		},
		"String parse(String string)":{
			"methodBody":"{\n    int length = string.length();\n    offsets = new Point[length / 4];\n    ids = new String[length / 4];\n    mnemonics = new int[length / 4 + 1];\n    StringBuffer result = new StringBuffer();\n    char[] buffer = new char[length];\n    string.getChars(0, string.length(), buffer, 0);\n    int index = 0, state = 0, linkIndex = 0;\n    int start = 0, tagStart = 0, linkStart = 0, endtagStart = 0, refStart = 0;\n    while (index < length) {\n        char c = Character.toLowerCase(buffer[index]);\n        switch(state) {\n            case 0:\n                if (c == '<') {\n                    tagStart = index;\n                    state++;\n                }\n                break;\n            case 1:\n                if (c == 'a')\n                    state++;\n                break;\n            case 2:\n                switch(c) {\n                    case 'h':\n                        state = 7;\n                        break;\n                    case '>':\n                        linkStart = index + 1;\n                        state++;\n                        break;\n                    default:\n                        if (Character.isWhitespace(c))\n                            break;\n                        else\n                            state = 13;\n                }\n                break;\n            case 3:\n                if (c == '<') {\n                    endtagStart = index;\n                    state++;\n                }\n                break;\n            case 4:\n                state = c == '/' ? state + 1 : 3;\n                break;\n            case 5:\n                state = c == 'a' ? state + 1 : 3;\n                break;\n            case 6:\n                if (c == '>') {\n                    mnemonics[linkIndex] = parseMnemonics(buffer, start, tagStart, result);\n                    int offset = result.length();\n                    parseMnemonics(buffer, linkStart, endtagStart, result);\n                    offsets[linkIndex] = new Point(offset, result.length() - 1);\n                    if (ids[linkIndex] == null) {\n                        ids[linkIndex] = new String(buffer, linkStart, endtagStart - linkStart);\n                    }\n                    linkIndex++;\n                    start = tagStart = linkStart = endtagStart = refStart = index + 1;\n                    state = 0;\n                } else {\n                    state = 3;\n                }\n                break;\n            case 7:\n                state = c == 'r' ? state + 1 : 0;\n                break;\n            case 8:\n                state = c == 'e' ? state + 1 : 0;\n                break;\n            case 9:\n                state = c == 'f' ? state + 1 : 0;\n                break;\n            case 10:\n                state = c == '=' ? state + 1 : 0;\n                break;\n            case 11:\n                if (c == '\"') {\n                    state++;\n                    refStart = index + 1;\n                } else {\n                    state = 0;\n                }\n                break;\n            case 12:\n                if (c == '\"') {\n                    ids[linkIndex] = new String(buffer, refStart, index - refStart);\n                    state = 2;\n                }\n                break;\n            case 13:\n                if (Character.isWhitespace(c)) {\n                    state = 0;\n                } else if (c == '=') {\n                    state++;\n                }\n                break;\n            case 14:\n                state = c == '\"' ? state + 1 : 0;\n                break;\n            case 15:\n                if (c == '\"')\n                    state = 2;\n                break;\n            default:\n                state = 0;\n                break;\n        }\n        index++;\n    }\n    if (start < length) {\n        int tmp = parseMnemonics(buffer, start, tagStart, result);\n        int mnemonic = parseMnemonics(buffer, linkStart, index, result);\n        if (mnemonic == -1)\n            mnemonic = tmp;\n        mnemonics[linkIndex] = mnemonic;\n    } else {\n        mnemonics[linkIndex] = -1;\n    }\n    if (offsets.length != linkIndex) {\n        Point[] newOffsets = new Point[linkIndex];\n        System.arraycopy(offsets, 0, newOffsets, 0, linkIndex);\n        offsets = newOffsets;\n        String[] newIDs = new String[linkIndex];\n        System.arraycopy(ids, 0, newIDs, 0, linkIndex);\n        ids = newIDs;\n        int[] newMnemonics = new int[linkIndex + 1];\n        System.arraycopy(mnemonics, 0, newMnemonics, 0, linkIndex + 1);\n        mnemonics = newMnemonics;\n    }\n    return result.toString();\n}",
			"comments":"",
			"methodName":"String parse(String string)"
		},
		"LRESULT WM_GETDLGCODE(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_GETDLGCODE(wParam, lParam);\n    if (result != null)\n        return result;\n    int index, count, code = 0;\n    if (OS.COMCTL32_MAJOR >= 6) {\n        LITEM item = new LITEM();\n        item.mask = OS.LIF_ITEMINDEX | OS.LIF_STATE;\n        item.stateMask = OS.LIS_FOCUSED;\n        index = 0;\n        while (OS.SendMessage(handle, OS.LM_GETITEM, 0, item) != 0) {\n            if ((item.state & OS.LIS_FOCUSED) != 0) {\n                index = item.iLink;\n            }\n            item.iLink++;\n        }\n        count = item.iLink;\n        code = callWindowProc(handle, OS.WM_GETDLGCODE, wParam, lParam);\n    } else {\n        index = focusIndex;\n        count = offsets.length;\n    }\n    if (count == 0) {\n        return new LRESULT(code | OS.DLGC_STATIC);\n    }\n    boolean next = OS.GetKeyState(OS.VK_SHIFT) >= 0;\n    if (next && index < count - 1) {\n        return new LRESULT(code | OS.DLGC_WANTTAB);\n    }\n    if (!next && index > 0) {\n        return new LRESULT(code | OS.DLGC_WANTTAB);\n    }\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_GETDLGCODE(int wParam, int lParam)"
		},
		"public void getDefaultAction(AccessibleControlEvent e)":{
			"methodBody":"{\n    \n    e.result = SWT.getMessage(\"SWT_Press\");\n}",
			"comments":"//$NON-NLS-1$\n",
			"methodName":"public void getDefaultAction(AccessibleControlEvent e)"
		},
		"int windowProc()":{
			"methodBody":"{\n    return LinkProc != 0 ? LinkProc : display.windowProc;\n}",
			"comments":"",
			"methodName":"int windowProc()"
		},
		"void initAccessible()":{
			"methodBody":"{\n    Accessible accessible = getAccessible();\n    accessible.addAccessibleListener(new AccessibleAdapter() {\n\n        public void getName(AccessibleEvent e) {\n            e.result = parse(text);\n        }\n    });\n    accessible.addAccessibleControlListener(new AccessibleControlAdapter() {\n\n        public void getChildAtPoint(AccessibleControlEvent e) {\n            e.childID = ACC.CHILDID_SELF;\n        }\n\n        public void getLocation(AccessibleControlEvent e) {\n            Rectangle rect = display.map(getParent(), null, getBounds());\n            e.x = rect.x;\n            e.y = rect.y;\n            e.width = rect.width;\n            e.height = rect.height;\n        }\n\n        public void getChildCount(AccessibleControlEvent e) {\n            e.detail = 0;\n        }\n\n        public void getRole(AccessibleControlEvent e) {\n            e.detail = ACC.ROLE_LINK;\n        }\n\n        public void getState(AccessibleControlEvent e) {\n            e.detail = ACC.STATE_FOCUSABLE;\n            if (hasFocus())\n                e.detail |= ACC.STATE_FOCUSED;\n        }\n\n        public void getDefaultAction(AccessibleControlEvent e) {\n            \n            e.result = SWT.getMessage(\"SWT_Press\");\n        }\n\n        public void getSelection(AccessibleControlEvent e) {\n            if (hasFocus())\n                e.childID = ACC.CHILDID_SELF;\n        }\n\n        public void getFocus(AccessibleControlEvent e) {\n            if (hasFocus())\n                e.childID = ACC.CHILDID_SELF;\n        }\n    });\n}",
			"comments":"//$NON-NLS-1$\n",
			"methodName":"void initAccessible()"
		},
		"void drawWidget(GC gc, RECT rect)":{
			"methodBody":"{\n    drawBackground(gc.handle, rect);\n    int selStart = selection.x;\n    int selEnd = selection.y;\n    if (selStart > selEnd) {\n        selStart = selection.y;\n        selEnd = selection.x;\n    }\n    \n    selStart = selEnd = -1;\n    layout.draw(gc, 0, 0, selStart, selEnd, null, null);\n    if (hasFocus() && focusIndex != -1) {\n        Rectangle[] rects = getRectangles(focusIndex);\n        for (int i = 0; i < rects.length; i++) {\n            Rectangle rectangle = rects[i];\n            gc.drawFocus(rectangle.x, rectangle.y, rectangle.width, rectangle.height);\n        }\n    }\n    if (hooks(SWT.Paint) || filters(SWT.Paint)) {\n        Event event = new Event();\n        event.gc = gc;\n        event.x = rect.left;\n        event.y = rect.top;\n        event.width = rect.right - rect.left;\n        event.height = rect.bottom - rect.top;\n        sendEvent(SWT.Paint, event);\n        event.gc = null;\n    }\n}",
			"comments":"// temporary code to disable text selection\n",
			"methodName":"void drawWidget(GC gc, RECT rect)"
		},
		"public void addSelectionListener(SelectionListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.Selection, typedListener);\n    addListener(SWT.DefaultSelection, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when the control is selected, by sending\n* it one of the messages defined in the <code>SelectionListener</code>\n* interface.\n* <p>\n* <code>widgetSelected</code> is called when the control is selected.\n* <code>widgetDefaultSelected</code> is not called.\n* </p>\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see SelectionListener\n* @see #removeSelectionListener\n* @see SelectionEvent\n*/\n",
			"methodName":"public void addSelectionListener(SelectionListener listener)"
		},
		"int callWindowProc(int hwnd, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    if (handle == 0)\n        return 0;\n    if (LinkProc != 0)\n        return OS.CallWindowProc(LinkProc, hwnd, msg, wParam, lParam);\n    return OS.DefWindowProc(hwnd, msg, wParam, lParam);\n}",
			"comments":"",
			"methodName":"int callWindowProc(int hwnd, int msg, int wParam, int lParam)"
		},
		"int widgetStyle()":{
			"methodBody":"{\n    int bits = super.widgetStyle();\n    return bits | OS.WS_TABSTOP;\n}",
			"comments":"",
			"methodName":"int widgetStyle()"
		},
		"Rectangle[] getRectangles(int linkIndex)":{
			"methodBody":"{\n    int lineCount = layout.getLineCount();\n    Rectangle[] rects = new Rectangle[lineCount];\n    int[] lineOffsets = layout.getLineOffsets();\n    Point point = offsets[linkIndex];\n    int lineStart = 1;\n    while (point.x > lineOffsets[lineStart]) lineStart++;\n    int lineEnd = 1;\n    while (point.y > lineOffsets[lineEnd]) lineEnd++;\n    int index = 0;\n    if (lineStart == lineEnd) {\n        rects[index++] = layout.getBounds(point.x, point.y);\n    } else {\n        rects[index++] = layout.getBounds(point.x, lineOffsets[lineStart] - 1);\n        rects[index++] = layout.getBounds(lineOffsets[lineEnd - 1], point.y);\n        if (lineEnd - lineStart > 1) {\n            for (int i = lineStart; i < lineEnd - 1; i++) {\n                rects[index++] = layout.getLineBounds(i);\n            }\n        }\n    }\n    if (rects.length != index) {\n        Rectangle[] tmp = new Rectangle[index];\n        System.arraycopy(rects, 0, tmp, 0, index);\n        rects = tmp;\n    }\n    return rects;\n}",
			"comments":"",
			"methodName":"Rectangle[] getRectangles(int linkIndex)"
		},
		"LRESULT WM_KEYDOWN(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_KEYDOWN(wParam, lParam);\n    if (result != null)\n        return result;\n    if (OS.COMCTL32_MAJOR >= 6) {\n        switch(wParam) {\n            case OS.VK_SPACE:\n            case OS.VK_RETURN:\n            case OS.VK_TAB:\n                \n                return LRESULT.ZERO;\n        }\n    }\n    return result;\n}",
			"comments":"/*\n* Ensure that the window proc does not process VK_SPACE,\n* VK_RETURN or VK_TAB so that it can be handled in WM_CHAR.\n* This allows the application to cancel an operation that\n* is normally performed in WM_KEYDOWN from WM_CHAR.\n*/\n",
			"methodName":"LRESULT WM_KEYDOWN(int wParam, int lParam)"
		}
	},
	"ClassORInterfaceName":[
		"Link"
	]
}
