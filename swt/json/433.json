{
	"variables":[
		"noSelection",
		"ignoreModify",
		"ignoreCharacter",
		"visibleCount",
		"LIMIT",
		"CBID_LIST",
		"CBID_EDIT",
		"EditProc",
		"ListProc",
		"ComboProc",
		"ComboClass",
		"lpWndClass",
		"buffer",
		"result",
		"count",
		"buffer",
		"result",
		"typedListener",
		"typedListener",
		"typedListener",
		"hwndText",
		"hwndList",
		"width",
		"height",
		"newFont",
		"oldFont",
		"hDC",
		"count",
		"rect",
		"flags",
		"length",
		"cp",
		"buffer",
		"i",
		"result",
		"count",
		"itemHeight",
		"hwndText",
		"margins",
		"marginWidth",
		"pcbi",
		"border",
		"textHeight",
		"hwndText",
		"hwndList",
		"flags",
		"hwndText",
		"hwndList",
		"selection",
		"length",
		"buffer",
		"result",
		"count",
		"count",
		"result",
		"count",
		"result",
		"i",
		"start",
		"end",
		"length",
		"buffer",
		"pcbi",
		"result",
		"hwndText",
		"hwndFocus",
		"hwndText",
		"hwndList",
		"count",
		"i",
		"count",
		"index",
		"last",
		"buffer",
		"hwndText",
		"mbcsSize",
		"buffer",
		"hwndText",
		"hwndList",
		"length",
		"code",
		"count",
		"count",
		"count",
		"length",
		"i",
		"result",
		"index",
		"key",
		"stateMask",
		"oldText",
		"start",
		"end",
		"hwndText",
		"newStart",
		"newEnd",
		"length",
		"newStart",
		"newEnd",
		"newText",
		"buffer",
		"count",
		"selection",
		"code",
		"hwndText",
		"hwndList",
		"rect",
		"oldWidth",
		"oldHeight",
		"hwndText",
		"hwndList",
		"i",
		"codePage",
		"i",
		"string",
		"buffer",
		"code",
		"flags",
		"bits",
		"hwndText",
		"hwndList",
		"pcbi",
		"bits1",
		"bits2",
		"rect",
		"width",
		"height",
		"widthCombo",
		"heightCombo",
		"uFlags",
		"bits1",
		"start",
		"end",
		"bits",
		"index",
		"buffer",
		"rect",
		"flags",
		"newProc",
		"hwndText",
		"hwndList",
		"hwndText",
		"hwndList",
		"event",
		"hwndText",
		"mbcsSize",
		"buffer",
		"mbcsPos",
		"wcsCount",
		"bits",
		"hwndText",
		"hwndList",
		"result",
		"oldText",
		"newText",
		"length",
		"index",
		"code",
		"oldSelection",
		"result",
		"newSelection",
		"result",
		"hwndText",
		"hwndList",
		"uFlags",
		"index",
		"redraw",
		"buffer",
		"start",
		"end",
		"length",
		"result",
		"bits",
		"result",
		"call",
		"start",
		"end",
		"oldText",
		"newText",
		"length",
		"buffer",
		"length",
		"buffer",
		"byteCount",
		"buffer",
		"hHeap",
		"byteCount",
		"pszText",
		"code",
		"code",
		"index",
		"display",
		"result",
		"msg",
		"flags",
		"LIMIT",
		"OS",
		"OS",
		"ComboClass",
		"lpWndClass",
		"ComboProc",
		"lpWndClass",
		"parent",
		"style",
		"string",
		"SWT",
		"string",
		"OS",
		"handle",
		"OS",
		"buffer",
		"result",
		"OS",
		"SWT",
		"result",
		"OS",
		"SWT",
		"string",
		"SWT",
		"OS",
		"handle",
		"OS",
		"index",
		"index",
		"count",
		"SWT",
		"string",
		"OS",
		"handle",
		"OS",
		"index",
		"buffer",
		"result",
		"OS",
		"result",
		"OS",
		"SWT",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"SWT",
		"typedListener",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"handle",
		"hwnd",
		"handle",
		"OS",
		"ComboProc",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"OS",
		"handle",
		"CBID_EDIT",
		"hwnd",
		"hwndText",
		"OS",
		"EditProc",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"OS",
		"handle",
		"CBID_LIST",
		"hwnd",
		"hwndList",
		"OS",
		"ListProc",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"OS",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"hwnd",
		"handle",
		"hwnd",
		"OS",
		"handle",
		"CBID_EDIT",
		"hwnd",
		"OS",
		"handle",
		"CBID_LIST",
		"SWT",
		"style",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"style",
		"style",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"style",
		"SWT",
		"style",
		"OS",
		"handle",
		"OS",
		"wHint",
		"SWT",
		"OS",
		"handle",
		"newFont",
		"OS",
		"handle",
		"OS",
		"newFont",
		"oldFont",
		"OS",
		"hDC",
		"newFont",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"style",
		"SWT",
		"flags",
		"OS",
		"OS",
		"handle",
		"cp",
		"length",
		"OS",
		"handle",
		"buffer",
		"length",
		"OS",
		"hDC",
		"buffer",
		"length",
		"rect",
		"flags",
		"width",
		"Math",
		"width",
		"rect",
		"rect",
		"i",
		"count",
		"i",
		"length",
		"OS",
		"handle",
		"OS",
		"i",
		"length",
		"OS",
		"length",
		"buffer",
		"buffer",
		"cp",
		"length",
		"OS",
		"handle",
		"OS",
		"i",
		"buffer",
		"result",
		"OS",
		"OS",
		"hDC",
		"buffer",
		"length",
		"rect",
		"flags",
		"width",
		"Math",
		"width",
		"rect",
		"rect",
		"newFont",
		"OS",
		"hDC",
		"oldFont",
		"OS",
		"handle",
		"hDC",
		"hHint",
		"SWT",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"height",
		"count",
		"itemHeight",
		"width",
		"width",
		"DEFAULT_WIDTH",
		"height",
		"height",
		"DEFAULT_HEIGHT",
		"wHint",
		"SWT",
		"width",
		"wHint",
		"hHint",
		"SWT",
		"height",
		"hHint",
		"style",
		"SWT",
		"width",
		"OS",
		"handle",
		"CBID_EDIT",
		"hwndText",
		"OS",
		"hwndText",
		"OS",
		"margins",
		"margins",
		"width",
		"marginWidth",
		"pcbi",
		"COMBOBOXINFO",
		"style",
		"SWT",
		"OS",
		"OS",
		"handle",
		"pcbi",
		"width",
		"pcbi",
		"pcbi",
		"pcbi",
		"height",
		"pcbi",
		"pcbi",
		"pcbi",
		"OS",
		"OS",
		"width",
		"OS",
		"OS",
		"border",
		"OS",
		"handle",
		"OS",
		"style",
		"SWT",
		"height",
		"textHeight",
		"height",
		"textHeight",
		"width",
		"height",
		"OS",
		"handle",
		"OS",
		"state",
		"CANVAS",
		"OS",
		"handle",
		"CBID_EDIT",
		"hwndText",
		"EditProc",
		"EditProc",
		"OS",
		"hwndText",
		"OS",
		"OS",
		"handle",
		"CBID_LIST",
		"hwndList",
		"ListProc",
		"ListProc",
		"OS",
		"hwndList",
		"OS",
		"style",
		"SWT",
		"OS",
		"OS",
		"OS",
		"handle",
		"flags",
		"handle",
		"flags",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"OS",
		"handle",
		"CBID_EDIT",
		"hwndText",
		"display",
		"hwndText",
		"OS",
		"handle",
		"CBID_LIST",
		"hwndList",
		"display",
		"hwndList",
		"OS",
		"handle",
		"OS",
		"index",
		"selection",
		"OS",
		"handle",
		"OS",
		"SWT",
		"OS",
		"handle",
		"OS",
		"SWT",
		"OS",
		"handle",
		"OS",
		"index",
		"length",
		"OS",
		"length",
		"OS",
		"handle",
		"OS",
		"index",
		"buffer",
		"result",
		"OS",
		"buffer",
		"length",
		"OS",
		"handle",
		"OS",
		"index",
		"index",
		"count",
		"SWT",
		"SWT",
		"OS",
		"handle",
		"OS",
		"count",
		"OS",
		"SWT",
		"count",
		"OS",
		"handle",
		"OS",
		"result",
		"OS",
		"SWT",
		"result",
		"count",
		"i",
		"count",
		"i",
		"result",
		"i",
		"i",
		"result",
		"style",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"handle",
		"OS",
		"start",
		"end",
		"OS",
		"OS",
		"start",
		"start",
		"end",
		"end",
		"start",
		"end",
		"noSelection",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"length",
		"length",
		"OS",
		"handle",
		"buffer",
		"length",
		"buffer",
		"length",
		"pcbi",
		"COMBOBOXINFO",
		"style",
		"SWT",
		"OS",
		"OS",
		"handle",
		"pcbi",
		"pcbi",
		"pcbi",
		"pcbi",
		"OS",
		"handle",
		"OS",
		"result",
		"OS",
		"SWT",
		"style",
		"SWT",
		"result",
		"result",
		"OS",
		"handle",
		"CBID_EDIT",
		"hwndText",
		"LIMIT",
		"OS",
		"hwndText",
		"OS",
		"visibleCount",
		"OS",
		"hwndFocus",
		"handle",
		"hwndFocus",
		"OS",
		"handle",
		"CBID_EDIT",
		"hwndFocus",
		"hwndText",
		"OS",
		"handle",
		"CBID_LIST",
		"hwndFocus",
		"hwndList",
		"string",
		"string",
		"SWT",
		"string",
		"start",
		"i",
		"count",
		"i",
		"string",
		"i",
		"i",
		"OS",
		"handle",
		"OS",
		"start",
		"start",
		"count",
		"start",
		"string",
		"index",
		"OS",
		"handle",
		"OS",
		"last",
		"index",
		"buffer",
		"index",
		"OS",
		"index",
		"last",
		"string",
		"index",
		"index",
		"mbcsPos",
		"OS",
		"mbcsPos",
		"OS",
		"handle",
		"CBID_EDIT",
		"hwndText",
		"mbcsPos",
		"OS",
		"hwndText",
		"mbcsSize",
		"mbcsPos",
		"mbcsSize",
		"mbcsSize",
		"mbcsSize",
		"OS",
		"hwndText",
		"buffer",
		"mbcsSize",
		"OS",
		"OS",
		"buffer",
		"mbcsPos",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"CBID_EDIT",
		"hwndText",
		"display",
		"hwndText",
		"OS",
		"handle",
		"CBID_LIST",
		"hwndList",
		"display",
		"hwndList",
		"OS",
		"handle",
		"OS",
		"handle",
		"OS",
		"index",
		"code",
		"OS",
		"OS",
		"handle",
		"OS",
		"index",
		"index",
		"count",
		"SWT",
		"SWT",
		"length",
		"OS",
		"handle",
		"SWT",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"count",
		"OS",
		"handle",
		"start",
		"end",
		"OS",
		"handle",
		"OS",
		"start",
		"start",
		"end",
		"end",
		"count",
		"SWT",
		"OS",
		"handle",
		"start",
		"i",
		"end",
		"i",
		"OS",
		"handle",
		"OS",
		"start",
		"result",
		"OS",
		"SWT",
		"length",
		"OS",
		"handle",
		"SWT",
		"style",
		"SWT",
		"count",
		"OS",
		"handle",
		"OS",
		"count",
		"OS",
		"handle",
		"string",
		"SWT",
		"string",
		"index",
		"SWT",
		"index",
		"OS",
		"handle",
		"OS",
		"SWT",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"eventTable",
		"SWT",
		"listener",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"type",
		"msg",
		"wParam",
		"lParam",
		"event",
		"style",
		"SWT",
		"type",
		"SWT",
		"msg",
		"OS",
		"msg",
		"OS",
		"msg",
		"OS",
		"event",
		"SWT",
		"SWT",
		"event",
		"event",
		"msg",
		"OS",
		"key",
		"key",
		"key",
		"key",
		"key",
		"OS",
		"stateMask",
		"SWT",
		"SWT",
		"SWT",
		"OS",
		"OS",
		"OS",
		"handle",
		"CBID_EDIT",
		"hwndText",
		"OS",
		"hwndText",
		"OS",
		"start",
		"end",
		"key",
		"start",
		"end",
		"start",
		"start",
		"start",
		"OS",
		"OS",
		"OS",
		"hwndText",
		"OS",
		"start",
		"end",
		"OS",
		"hwndText",
		"OS",
		"newStart",
		"newEnd",
		"start",
		"newStart",
		"start",
		"start",
		"start",
		"Math",
		"start",
		"start",
		"end",
		"OS",
		"hwndText",
		"start",
		"length",
		"end",
		"end",
		"OS",
		"OS",
		"OS",
		"hwndText",
		"OS",
		"start",
		"end",
		"OS",
		"hwndText",
		"OS",
		"newStart",
		"newEnd",
		"end",
		"newEnd",
		"end",
		"end",
		"end",
		"Math",
		"end",
		"length",
		"key",
		"key",
		"oldText",
		"key",
		"oldText",
		"start",
		"end",
		"event",
		"newText",
		"newText",
		"oldText",
		"newText",
		"OS",
		"hwndText",
		"OS",
		"start",
		"end",
		"OS",
		"hwndText",
		"OS",
		"buffer",
		"OS",
		"handle",
		"OS",
		"index",
		"index",
		"count",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"index",
		"code",
		"OS",
		"code",
		"selection",
		"SWT",
		"background",
		"pixel",
		"pixel",
		"OS",
		"handle",
		"CBID_EDIT",
		"hwndText",
		"OS",
		"hwndText",
		"OS",
		"handle",
		"CBID_LIST",
		"hwndList",
		"OS",
		"hwndList",
		"style",
		"SWT",
		"height",
		"visibleCount",
		"OS",
		"handle",
		"rect",
		"rect",
		"rect",
		"OS",
		"handle",
		"OS",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"oldWidth",
		"width",
		"oldHeight",
		"height",
		"flags",
		"OS",
		"handle",
		"x",
		"y",
		"width",
		"height",
		"flags",
		"x",
		"y",
		"width",
		"height",
		"flags",
		"foreground",
		"pixel",
		"pixel",
		"OS",
		"handle",
		"CBID_EDIT",
		"hwndText",
		"OS",
		"hwndText",
		"OS",
		"handle",
		"CBID_LIST",
		"hwndList",
		"OS",
		"hwndList",
		"string",
		"SWT",
		"index",
		"string",
		"index",
		"items",
		"SWT",
		"i",
		"items",
		"i",
		"items",
		"i",
		"SWT",
		"OS",
		"handle",
		"OS",
		"i",
		"items",
		"i",
		"items",
		"i",
		"codePage",
		"string",
		"OS",
		"handle",
		"OS",
		"buffer",
		"code",
		"OS",
		"SWT",
		"code",
		"OS",
		"SWT",
		"SWT",
		"OS",
		"OS",
		"OS",
		"SWT",
		"SWT",
		"orientation",
		"flags",
		"orientation",
		"flags",
		"flags",
		"style",
		"flags",
		"style",
		"orientation",
		"flags",
		"OS",
		"handle",
		"OS",
		"style",
		"SWT",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"OS",
		"handle",
		"OS",
		"bits",
		"pcbi",
		"COMBOBOXINFO",
		"OS",
		"handle",
		"pcbi",
		"hwndText",
		"pcbi",
		"hwndList",
		"pcbi",
		"hwndText",
		"OS",
		"hwndText",
		"OS",
		"OS",
		"hwndText",
		"OS",
		"style",
		"SWT",
		"bits1",
		"OS",
		"OS",
		"bits2",
		"OS",
		"bits1",
		"OS",
		"OS",
		"bits2",
		"OS",
		"OS",
		"hwndText",
		"OS",
		"bits1",
		"OS",
		"hwndText",
		"OS",
		"bits2",
		"OS",
		"hwndText",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"OS",
		"handle",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"OS",
		"OS",
		"OS",
		"hwndText",
		"width",
		"height",
		"uFlags",
		"handle",
		"widthCombo",
		"heightCombo",
		"uFlags",
		"hwndText",
		"width",
		"height",
		"uFlags",
		"handle",
		"widthCombo",
		"heightCombo",
		"uFlags",
		"OS",
		"handle",
		"hwndList",
		"OS",
		"hwndList",
		"OS",
		"style",
		"SWT",
		"bits1",
		"OS",
		"bits1",
		"OS",
		"OS",
		"hwndList",
		"OS",
		"bits1",
		"selection",
		"SWT",
		"selection",
		"selection",
		"OS",
		"OS",
		"start",
		"start",
		"end",
		"end",
		"start",
		"end",
		"OS",
		"handle",
		"OS",
		"bits",
		"string",
		"SWT",
		"style",
		"SWT",
		"string",
		"index",
		"index",
		"string",
		"OS",
		"handle",
		"buffer",
		"SWT",
		"limit",
		"SWT",
		"OS",
		"handle",
		"OS",
		"limit",
		"count",
		"visibleCount",
		"count",
		"style",
		"SWT",
		"OS",
		"handle",
		"rect",
		"OS",
		"OS",
		"OS",
		"OS",
		"rect",
		"rect",
		"rect",
		"rect",
		"flags",
		"display",
		"OS",
		"handle",
		"CBID_EDIT",
		"hwndText",
		"OS",
		"hwndText",
		"OS",
		"newProc",
		"OS",
		"handle",
		"CBID_LIST",
		"hwndList",
		"OS",
		"hwndList",
		"OS",
		"newProc",
		"msg",
		"OS",
		"OS",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"msg",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"CBID_EDIT",
		"hwndText",
		"EditProc",
		"OS",
		"hwndText",
		"OS",
		"EditProc",
		"OS",
		"handle",
		"CBID_LIST",
		"hwndList",
		"ListProc",
		"OS",
		"hwndList",
		"OS",
		"ListProc",
		"event",
		"string",
		"event",
		"start",
		"event",
		"end",
		"keyEvent",
		"event",
		"keyEvent",
		"event",
		"keyEvent",
		"event",
		"keyEvent",
		"OS",
		"OS",
		"event",
		"start",
		"event",
		"end",
		"SWT",
		"event",
		"event",
		"event",
		"wcsPos",
		"OS",
		"wcsPos",
		"OS",
		"handle",
		"CBID_EDIT",
		"hwndText",
		"wcsPos",
		"OS",
		"hwndText",
		"mbcsSize",
		"mbcsSize",
		"OS",
		"hwndText",
		"buffer",
		"mbcsSize",
		"mbcsPos",
		"mbcsSize",
		"wcsPos",
		"wcsCount",
		"OS",
		"buffer",
		"mbcsPos",
		"mbcsPos",
		"wcsCount",
		"mbcsPos",
		"OS",
		"OS",
		"OS",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"bits",
		"OS",
		"ComboClass",
		"ComboProc",
		"handle",
		"hwnd",
		"handle",
		"OS",
		"handle",
		"CBID_EDIT",
		"OS",
		"handle",
		"CBID_LIST",
		"hwndText",
		"hwnd",
		"hwndText",
		"hwndList",
		"hwnd",
		"hwndList",
		"msg",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"hwnd",
		"hwndText",
		"result",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"result",
		"result",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"msg",
		"OS",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"wParam",
		"newText",
		"wParam",
		"wParam",
		"newText",
		"wParam",
		"newText",
		"newText",
		"oldText",
		"OS",
		"handle",
		"oldText",
		"newText",
		"newText",
		"newText",
		"length",
		"newText",
		"newText",
		"oldText",
		"newText",
		"index",
		"index",
		"wParam",
		"handle",
		"OS",
		"index",
		"lParam",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"code",
		"OS",
		"style",
		"SWT",
		"wParam",
		"lParam",
		"OS",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"oldSelection",
		"newSelection",
		"SWT",
		"LRESULT",
		"SWT",
		"LRESULT",
		"result",
		"style",
		"SWT",
		"wParam",
		"lParam",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"CBID_EDIT",
		"hwndText",
		"OS",
		"hwndText",
		"OS",
		"handle",
		"CBID_LIST",
		"hwndList",
		"OS",
		"hwndList",
		"OS",
		"OS",
		"OS",
		"OS",
		"handle",
		"uFlags",
		"result",
		"style",
		"SWT",
		"style",
		"SWT",
		"wParam",
		"lParam",
		"OS",
		"handle",
		"OS",
		"index",
		"OS",
		"OS",
		"handle",
		"length",
		"buffer",
		"length",
		"OS",
		"handle",
		"buffer",
		"length",
		"start",
		"end",
		"OS",
		"handle",
		"OS",
		"start",
		"end",
		"redraw",
		"drawCount",
		"OS",
		"handle",
		"redraw",
		"wParam",
		"lParam",
		"result",
		"buffer",
		"OS",
		"handle",
		"buffer",
		"start",
		"end",
		"OS",
		"handle",
		"OS",
		"bits",
		"redraw",
		"result",
		"ignoreCharacter",
		"hwnd",
		"wParam",
		"lParam",
		"result",
		"result",
		"wParam",
		"SWT",
		"LRESULT",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"LRESULT",
		"result",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"msg",
		"OS",
		"OS",
		"OS",
		"hwndText",
		"OS",
		"start",
		"end",
		"start",
		"end",
		"newText",
		"call",
		"OS",
		"OS",
		"hwndText",
		"OS",
		"start",
		"end",
		"newText",
		"OS",
		"OS",
		"OS",
		"hwndText",
		"OS",
		"ignoreModify",
		"OS",
		"hwndText",
		"OS",
		"start",
		"end",
		"OS",
		"EditProc",
		"hwndText",
		"msg",
		"wParam",
		"lParam",
		"OS",
		"hwndText",
		"length",
		"start",
		"end",
		"length",
		"OS",
		"hwndText",
		"buffer",
		"length",
		"newText",
		"buffer",
		"start",
		"end",
		"start",
		"newText",
		"OS",
		"EditProc",
		"hwndText",
		"msg",
		"wParam",
		"lParam",
		"ignoreModify",
		"OS",
		"end",
		"OS",
		"hwndText",
		"oldText",
		"OS",
		"OS",
		"lParam",
		"OS",
		"lParam",
		"length",
		"buffer",
		"TCHAR",
		"OS",
		"buffer",
		"lParam",
		"byteCount",
		"newText",
		"buffer",
		"length",
		"newText",
		"newText",
		"oldText",
		"oldText",
		"newText",
		"newText",
		"newText",
		"start",
		"end",
		"newText",
		"LRESULT",
		"newText",
		"oldText",
		"call",
		"OS",
		"EditProc",
		"hwndText",
		"msg",
		"wParam",
		"lParam",
		"newText",
		"msg",
		"OS",
		"OS",
		"buffer",
		"TCHAR",
		"OS",
		"hHeap",
		"OS",
		"byteCount",
		"OS",
		"pszText",
		"buffer",
		"byteCount",
		"OS",
		"EditProc",
		"hwndText",
		"msg",
		"wParam",
		"pszText",
		"OS",
		"hHeap",
		"pszText",
		"code",
		"OS",
		"hwndText",
		"OS",
		"buffer",
		"LRESULT",
		"wParam",
		"code",
		"OS",
		"ignoreModify",
		"noSelection",
		"SWT",
		"LRESULT",
		"noSelection",
		"OS",
		"OS",
		"handle",
		"OS",
		"index",
		"OS",
		"OS",
		"handle",
		"OS",
		"index",
		"SWT",
		"LRESULT",
		"SWT",
		"OS",
		"SWT",
		"LRESULT",
		"OS",
		"style",
		"SWT",
		"SWT",
		"LRESULT",
		"wParam",
		"lParam",
		"display",
		"display",
		"wParam",
		"display",
		"display",
		"display",
		"SWT",
		"OS",
		"wParam",
		"lParam",
		"LRESULT",
		"ignoreCharacter",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"msg",
		"hwnd",
		"OS",
		"OS",
		"flags",
		"OS",
		"msg",
		"OS",
		"msg",
		"ignoreCharacter",
		"SWT",
		"OS",
		"wParam",
		"lParam",
		"display",
		"display",
		"result",
		"IsWinNT",
		"lpfnWndProc",
		"ERROR_NULL_ARGUMENT",
		"CB_ADDSTRING",
		"CB_ERR",
		"ERROR_ITEM_NOT_ADDED",
		"CB_ERRSPACE",
		"ERROR_ITEM_NOT_ADDED",
		"ERROR_NULL_ARGUMENT",
		"CB_GETCOUNT",
		"ERROR_INVALID_RANGE",
		"CB_INSERTSTRING",
		"CB_ERRSPACE",
		"CB_ERR",
		"ERROR_ITEM_NOT_ADDED",
		"ERROR_NULL_ARGUMENT",
		"Modify",
		"ERROR_NULL_ARGUMENT",
		"Selection",
		"DefaultSelection",
		"ERROR_NULL_ARGUMENT",
		"Verify",
		"ERROR_INVALID_SUBCLASS",
		"BORDER",
		"H_SCROLL",
		"V_SCROLL",
		"DROP_DOWN",
		"SIMPLE",
		"SIMPLE",
		"READ_ONLY",
		"CB_SETEDITSEL",
		"DEFAULT",
		"WM_GETFONT",
		"CB_GETCOUNT",
		"DT_CALCRECT",
		"DT_NOPREFIX",
		"READ_ONLY",
		"DT_EDITCONTROL",
		"right",
		"left",
		"CB_GETLBTEXTLEN",
		"CB_ERR",
		"CB_GETLBTEXT",
		"CB_ERR",
		"right",
		"left",
		"DEFAULT",
		"SIMPLE",
		"CB_GETCOUNT",
		"CB_GETITEMHEIGHT",
		"DEFAULT",
		"DEFAULT",
		"READ_ONLY",
		"EM_GETMARGINS",
		"cbSize",
		"sizeof",
		"SIMPLE",
		"IsWinCE",
		"itemLeft",
		"buttonRight",
		"buttonLeft",
		"buttonBottom",
		"buttonTop",
		"buttonTop",
		"SM_CXEDGE",
		"SM_CXVSCROLL",
		"CB_GETITEMHEIGHT",
		"DROP_DOWN",
		"WM_COPY",
		"GWL_WNDPROC",
		"GWL_WNDPROC",
		"SIMPLE",
		"SWP_NOZORDER",
		"SWP_DRAWFRAME",
		"SWP_NOACTIVATE",
		"READ_ONLY",
		"WM_CUT",
		"COLOR_WINDOW",
		"CB_GETCURSEL",
		"CB_SETCURSEL",
		"Modify",
		"CB_SETCURSEL",
		"Modify",
		"CB_GETLBTEXTLEN",
		"CB_ERR",
		"CB_GETLBTEXT",
		"CB_ERR",
		"CB_GETCOUNT",
		"ERROR_CANNOT_GET_ITEM",
		"ERROR_INVALID_RANGE",
		"CB_GETCOUNT",
		"CB_ERR",
		"ERROR_CANNOT_GET_COUNT",
		"CB_GETITEMHEIGHT",
		"CB_ERR",
		"ERROR_CANNOT_GET_ITEM_HEIGHT",
		"LEFT_TO_RIGHT",
		"RIGHT_TO_LEFT",
		"DROP_DOWN",
		"READ_ONLY",
		"CB_GETEDITSEL",
		"IsUnicode",
		"IsDBLocale",
		"CB_GETCURSEL",
		"cbSize",
		"sizeof",
		"SIMPLE",
		"IsWinCE",
		"buttonBottom",
		"buttonTop",
		"buttonTop",
		"CB_GETITEMHEIGHT",
		"CB_ERR",
		"ERROR_CANNOT_GET_ITEM_HEIGHT",
		"DROP_DOWN",
		"EM_GETLIMITTEXT",
		"ERROR_NULL_ARGUMENT",
		"CB_GETCOUNT",
		"CB_FINDSTRINGEXACT",
		"CB_ERR",
		"IsUnicode",
		"MB_PRECOMPOSED",
		"READ_ONLY",
		"WM_PASTE",
		"CB_DELETESTRING",
		"CB_ERR",
		"CB_GETCOUNT",
		"ERROR_ITEM_NOT_REMOVED",
		"ERROR_INVALID_RANGE",
		"Modify",
		"READ_ONLY",
		"CB_GETCOUNT",
		"CB_GETCOUNT",
		"ERROR_INVALID_RANGE",
		"CB_DELETESTRING",
		"CB_ERR",
		"ERROR_ITEM_NOT_REMOVED",
		"Modify",
		"READ_ONLY",
		"CB_GETCOUNT",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"CB_RESETCONTENT",
		"Modify",
		"ERROR_NULL_ARGUMENT",
		"Modify",
		"ERROR_NULL_ARGUMENT",
		"Selection",
		"DefaultSelection",
		"ERROR_NULL_ARGUMENT",
		"Verify",
		"READ_ONLY",
		"KeyDown",
		"WM_CHAR",
		"WM_KEYDOWN",
		"WM_IME_CHAR",
		"character",
		"Verify",
		"Verify",
		"character",
		"stateMask",
		"WM_CHAR",
		"WM_KEYDOWN",
		"ALT",
		"SHIFT",
		"CONTROL",
		"VK_LBUTTON",
		"EM_GETSEL",
		"IsUnicode",
		"IsDBLocale",
		"EM_SETSEL",
		"EM_GETSEL",
		"IsUnicode",
		"IsDBLocale",
		"EM_SETSEL",
		"EM_GETSEL",
		"EM_SETSEL",
		"EM_REPLACESEL",
		"CB_GETCOUNT",
		"CB_GETCURSEL",
		"CB_SETCURSEL",
		"CB_ERR",
		"Modify",
		"DROP_DOWN",
		"right",
		"left",
		"CB_GETDROPPEDCONTROLRECT",
		"right",
		"left",
		"bottom",
		"top",
		"SWP_NOSIZE",
		"ERROR_NULL_ARGUMENT",
		"ERROR_NULL_ARGUMENT",
		"length",
		"ERROR_INVALID_ARGUMENT",
		"CB_RESETCONTENT",
		"length",
		"CB_ADDSTRING",
		"CB_ERR",
		"ERROR_ITEM_NOT_ADDED",
		"CB_ERRSPACE",
		"ERROR_ITEM_NOT_ADDED",
		"Modify",
		"IsWinCE",
		"WIN32_VERSION",
		"RIGHT_TO_LEFT",
		"LEFT_TO_RIGHT",
		"GWL_EXSTYLE",
		"RIGHT_TO_LEFT",
		"MIRRORED",
		"WS_EX_LAYOUTRTL",
		"MIRRORED",
		"WS_EX_LAYOUTRTL",
		"GWL_EXSTYLE",
		"cbSize",
		"sizeof",
		"hwndItem",
		"hwndList",
		"GWL_EXSTYLE",
		"GWL_STYLE",
		"RIGHT_TO_LEFT",
		"WS_EX_RIGHT",
		"WS_EX_RTLREADING",
		"ES_RIGHT",
		"WS_EX_RIGHT",
		"WS_EX_RTLREADING",
		"ES_RIGHT",
		"GWL_EXSTYLE",
		"GWL_STYLE",
		"right",
		"left",
		"bottom",
		"top",
		"right",
		"left",
		"bottom",
		"top",
		"SWP_NOMOVE",
		"SWP_NOZORDER",
		"SWP_NOACTIVATE",
		"GWL_EXSTYLE",
		"RIGHT_TO_LEFT",
		"WS_EX_LAYOUTRTL",
		"WS_EX_LAYOUTRTL",
		"GWL_EXSTYLE",
		"ERROR_NULL_ARGUMENT",
		"x",
		"y",
		"IsUnicode",
		"IsDBLocale",
		"CB_SETEDITSEL",
		"ERROR_NULL_ARGUMENT",
		"READ_ONLY",
		"Modify",
		"ERROR_CANNOT_BE_ZERO",
		"CB_LIMITTEXT",
		"DROP_DOWN",
		"SWP_NOMOVE",
		"SWP_NOZORDER",
		"SWP_DRAWFRAME",
		"SWP_NOACTIVATE",
		"right",
		"left",
		"bottom",
		"top",
		"windowProc",
		"GWL_WNDPROC",
		"GWL_WNDPROC",
		"wParam",
		"VK_RETURN",
		"VK_ESCAPE",
		"DROP_DOWN",
		"CB_GETDROPPEDSTATE",
		"DROP_DOWN",
		"CB_GETDROPPEDSTATE",
		"CB_SHOWDROPDOWN",
		"GWL_WNDPROC",
		"GWL_WNDPROC",
		"text",
		"start",
		"end",
		"character",
		"character",
		"keyCode",
		"keyCode",
		"stateMask",
		"stateMask",
		"IsUnicode",
		"IsDBLocale",
		"start",
		"end",
		"Verify",
		"doit",
		"text",
		"IsUnicode",
		"WS_EX_NOINHERITLAYOUT",
		"CBS_AUTOHSCROLL",
		"CBS_NOINTEGRALHEIGHT",
		"WS_VSCROLL",
		"SIMPLE",
		"CBS_SIMPLE",
		"READ_ONLY",
		"CBS_DROPDOWNLIST",
		"CBS_DROPDOWN",
		"WM_CHAR",
		"WM_IME_CHAR",
		"WM_KEYDOWN",
		"WM_KEYUP",
		"WM_SYSCHAR",
		"WM_SYSKEYDOWN",
		"WM_SYSKEYUP",
		"WM_CAPTURECHANGED",
		"WM_LBUTTONDBLCLK",
		"WM_LBUTTONDOWN",
		"WM_LBUTTONUP",
		"WM_MBUTTONDBLCLK",
		"WM_MBUTTONDOWN",
		"WM_MBUTTONUP",
		"WM_MOUSEHOVER",
		"WM_MOUSELEAVE",
		"WM_MOUSEMOVE",
		"WM_RBUTTONDBLCLK",
		"WM_RBUTTONDOWN",
		"WM_RBUTTONUP",
		"WM_XBUTTONDBLCLK",
		"WM_XBUTTONDOWN",
		"WM_XBUTTONUP",
		"WM_PAINT",
		"WM_CONTEXTMENU",
		"WM_CLEAR",
		"WM_CUT",
		"WM_PASTE",
		"WM_UNDO",
		"EM_UNDO",
		"WM_SETTEXT",
		"value",
		"CB_SETCURSEL",
		"READ_ONLY",
		"Verify",
		"Verify",
		"CB_SETCURSEL",
		"WM_GETDLGCODE",
		"DLGC_WANTARROWS",
		"READ_ONLY",
		"CB_GETCURSEL",
		"READ_ONLY",
		"CB_GETCURSEL",
		"Modify",
		"ZERO",
		"Selection",
		"ZERO",
		"SIMPLE",
		"IsWinCE",
		"RDW_ERASE",
		"RDW_INVALIDATE",
		"RDW_ALLCHILDREN",
		"READ_ONLY",
		"DROP_DOWN",
		"CB_GETCURSEL",
		"CB_ERR",
		"CB_GETEDITSEL",
		"CB_SETEDITSEL",
		"TAB",
		"ZERO",
		"CR",
		"DefaultSelection",
		"ESC",
		"DROP_DOWN",
		"CB_GETDROPPEDSTATE",
		"ZERO",
		"READ_ONLY",
		"Verify",
		"Verify",
		"WM_CLEAR",
		"WM_CUT",
		"EM_GETSEL",
		"WM_PASTE",
		"EM_GETSEL",
		"EM_UNDO",
		"WM_UNDO",
		"EM_CANUNDO",
		"EM_GETSEL",
		"WM_SETTEXT",
		"IsUnicode",
		"sizeof",
		"ZERO",
		"WM_SETTEXT",
		"sizeof",
		"HEAP_ZERO_MEMORY",
		"EM_REPLACESEL",
		"ZERO",
		"CBN_EDITCHANGE",
		"Modify",
		"ZERO",
		"CBN_SELCHANGE",
		"CB_GETCURSEL",
		"CB_ERR",
		"CB_SETCURSEL",
		"Modify",
		"ZERO",
		"Selection",
		"CBN_SETFOCUS",
		"FocusIn",
		"ZERO",
		"CBN_KILLFOCUS",
		"READ_ONLY",
		"FocusOut",
		"ZERO",
		"display",
		"lastKey",
		"lastAscii",
		"lastVirtual",
		"lastNull",
		"lastDead",
		"KeyDown",
		"WM_IME_CHAR",
		"ZERO",
		"WM_IME_CHAR",
		"PM_REMOVE",
		"PM_NOYIELD",
		"PM_QS_INPUT",
		"PM_QS_POSTMESSAGE",
		"WM_CHAR",
		"WM_CHAR",
		"KeyUp",
		"WM_IME_CHAR",
		"lastKey",
		"lastAscii",
		"parent",
		"style",
		"string",
		"string",
		"index",
		"listener",
		"listener",
		"listener",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"hwnd",
		"style",
		"wHint",
		"hHint",
		"changed",
		"index",
		"index",
		"string",
		"string",
		"start",
		"mbcsPos",
		"index",
		"start",
		"end",
		"string",
		"listener",
		"listener",
		"listener",
		"type",
		"msg",
		"wParam",
		"lParam",
		"event",
		"index",
		"pixel",
		"x",
		"y",
		"width",
		"height",
		"flags",
		"pixel",
		"index",
		"string",
		"items",
		"orientation",
		"selection",
		"string",
		"limit",
		"count",
		"msg",
		"string",
		"start",
		"end",
		"keyEvent",
		"wcsPos",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam",
		"hwndText",
		"msg",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam"
	],
	"extendORImplementFiles":[
		"Composite"
	],
	"package":[
		"org.eclipse.swt.widgets"
	],
	"import":[
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt",
		"org.eclipse.swt.graphics",
		"org.eclipse.swt.events"
	],
	"methods":[
		"add",
		"add",
		"addModifyListener",
		"addSelectionListener",
		"addVerifyListener",
		"callWindowProc",
		"checkHandle",
		"checkSubclass",
		"checkStyle",
		"clearSelection",
		"computeSize",
		"copy",
		"createHandle",
		"cut",
		"defaultBackground",
		"deregister",
		"deselect",
		"deselectAll",
		"getItem",
		"getItemCount",
		"getItemHeight",
		"getItems",
		"getNameText",
		"getOrientation",
		"getSelection",
		"getSelectionIndex",
		"getText",
		"getTextHeight",
		"getTextLimit",
		"getVisibleItemCount",
		"hasFocus",
		"indexOf",
		"indexOf",
		"mbcsToWcsPos",
		"paste",
		"register",
		"remove",
		"remove",
		"remove",
		"removeAll",
		"removeModifyListener",
		"removeSelectionListener",
		"removeVerifyListener",
		"sendKeyEvent",
		"select",
		"setBackgroundPixel",
		"setBounds",
		"setForegroundPixel",
		"setItem",
		"setItems",
		"setOrientation",
		"setSelection",
		"setText",
		"setTextLimit",
		"setVisibleItemCount",
		"subclass",
		"translateTraversal",
		"traverseEscape",
		"unsubclass",
		"verifyText",
		"wcsToMbcsPos",
		"widgetExtStyle",
		"widgetStyle",
		"windowClass",
		"windowProc",
		"windowProc",
		"WM_CTLCOLOR",
		"WM_GETDLGCODE",
		"WM_KILLFOCUS",
		"WM_LBUTTONDOWN",
		"WM_SETFOCUS",
		"WM_SIZE",
		"wmChar",
		"wmClipboard",
		"wmCommandChild",
		"wmIMEChar",
		"GetClassInfo",
		"checkStyle",
		"checkWidget",
		"error",
		"getCodePage",
		"SendMessage",
		"error",
		"error",
		"checkWidget",
		"error",
		"SendMessage",
		"error",
		"getCodePage",
		"SendMessage",
		"error",
		"checkWidget",
		"error",
		"addListener",
		"checkWidget",
		"error",
		"addListener",
		"addListener",
		"checkWidget",
		"error",
		"addListener",
		"CallWindowProc",
		"GetDlgItem",
		"CallWindowProc",
		"GetDlgItem",
		"CallWindowProc",
		"DefWindowProc",
		"GetDlgItem",
		"GetDlgItem",
		"isValidSubclass",
		"error",
		"checkBits",
		"checkWidget",
		"SendMessage",
		"checkWidget",
		"GetDC",
		"SendMessage",
		"SelectObject",
		"SendMessage",
		"GetWindowTextLength",
		"getCodePage",
		"GetWindowText",
		"DrawText",
		"max",
		"SendMessage",
		"length",
		"SendMessage",
		"DrawText",
		"max",
		"SelectObject",
		"ReleaseDC",
		"SendMessage",
		"SendMessage",
		"GetDlgItem",
		"SendMessage",
		"GetComboBoxInfo",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"createHandle",
		"GetDlgItem",
		"GetWindowLong",
		"GetDlgItem",
		"GetWindowLong",
		"SetWindowPos",
		"SetWindowPos",
		"checkWidget",
		"SendMessage",
		"GetSysColor",
		"deregister",
		"GetDlgItem",
		"removeControl",
		"GetDlgItem",
		"removeControl",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"sendEvent",
		"checkWidget",
		"SendMessage",
		"sendEvent",
		"checkWidget",
		"SendMessage",
		"getCodePage",
		"SendMessage",
		"toString",
		"SendMessage",
		"error",
		"error",
		"checkWidget",
		"SendMessage",
		"error",
		"checkWidget",
		"SendMessage",
		"error",
		"checkWidget",
		"getItemCount",
		"getItem",
		"getText",
		"checkWidget",
		"checkWidget",
		"GetWindowTextLength",
		"SendMessage",
		"mbcsToWcsPos",
		"mbcsToWcsPos",
		"checkWidget",
		"SendMessage",
		"checkWidget",
		"GetWindowTextLength",
		"getCodePage",
		"GetWindowText",
		"toString",
		"checkWidget",
		"GetComboBoxInfo",
		"SendMessage",
		"error",
		"checkWidget",
		"GetDlgItem",
		"SendMessage",
		"checkWidget",
		"GetFocus",
		"GetDlgItem",
		"GetDlgItem",
		"indexOf",
		"checkWidget",
		"error",
		"length",
		"getItemCount",
		"equals",
		"getItem",
		"SendMessage",
		"getCodePage",
		"SendMessage",
		"equals",
		"getItem",
		"GetDlgItem",
		"GetWindowTextLengthA",
		"GetWindowTextA",
		"MultiByteToWideChar",
		"getCodePage",
		"checkWidget",
		"SendMessage",
		"register",
		"GetDlgItem",
		"addControl",
		"GetDlgItem",
		"addControl",
		"checkWidget",
		"GetWindowTextLength",
		"SendMessage",
		"SendMessage",
		"error",
		"error",
		"GetWindowTextLength",
		"sendEvent",
		"isDisposed",
		"SendMessage",
		"InvalidateRect",
		"checkWidget",
		"SendMessage",
		"error",
		"GetWindowTextLength",
		"SendMessage",
		"error",
		"GetWindowTextLength",
		"sendEvent",
		"isDisposed",
		"SendMessage",
		"InvalidateRect",
		"checkWidget",
		"error",
		"indexOf",
		"error",
		"remove",
		"checkWidget",
		"SendMessage",
		"sendEvent",
		"checkWidget",
		"error",
		"unhook",
		"checkWidget",
		"error",
		"unhook",
		"unhook",
		"checkWidget",
		"error",
		"unhook",
		"sendKeyEvent",
		"hooks",
		"filters",
		"GetKeyState",
		"GetDlgItem",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"max",
		"GetWindowTextLength",
		"SendMessage",
		"SendMessage",
		"min",
		"verifyText",
		"getCodePage",
		"SendMessage",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"sendEvent",
		"setBackgroundPixel",
		"GetDlgItem",
		"InvalidateRect",
		"GetDlgItem",
		"InvalidateRect",
		"getTextHeight",
		"getItemHeight",
		"GetWindowRect",
		"SendMessage",
		"SetWindowPos",
		"setBounds",
		"setForegroundPixel",
		"GetDlgItem",
		"InvalidateRect",
		"GetDlgItem",
		"InvalidateRect",
		"checkWidget",
		"error",
		"remove",
		"isDisposed",
		"add",
		"checkWidget",
		"error",
		"error",
		"SendMessage",
		"getCodePage",
		"SendMessage",
		"error",
		"error",
		"sendEvent",
		"checkWidget",
		"VERSION",
		"GetWindowLong",
		"SetWindowLong",
		"GetComboBoxInfo",
		"GetWindowLong",
		"GetWindowLong",
		"SetWindowLong",
		"SetWindowLong",
		"GetWindowRect",
		"GetWindowRect",
		"SetWindowPos",
		"SetWindowPos",
		"SetWindowPos",
		"SetWindowPos",
		"InvalidateRect",
		"GetWindowLong",
		"SetWindowLong",
		"checkWidget",
		"error",
		"wcsToMbcsPos",
		"wcsToMbcsPos",
		"SendMessage",
		"checkWidget",
		"error",
		"indexOf",
		"select",
		"getCodePage",
		"SetWindowText",
		"sendEvent",
		"checkWidget",
		"error",
		"SendMessage",
		"checkWidget",
		"forceResize",
		"GetWindowRect",
		"setBounds",
		"subclass",
		"GetDlgItem",
		"SetWindowLong",
		"GetDlgItem",
		"SetWindowLong",
		"SendMessage",
		"translateTraversal",
		"SendMessage",
		"SendMessage",
		"traverseEscape",
		"unsubclass",
		"GetDlgItem",
		"SetWindowLong",
		"GetDlgItem",
		"SetWindowLong",
		"mbcsToWcsPos",
		"mbcsToWcsPos",
		"sendEvent",
		"isDisposed",
		"GetDlgItem",
		"GetWindowTextLengthA",
		"GetWindowTextA",
		"IsDBCSLeadByte",
		"widgetExtStyle",
		"widgetStyle",
		"GetDlgItem",
		"GetDlgItem",
		"wmChar",
		"wmIMEChar",
		"wmKeyDown",
		"wmKeyUp",
		"wmSysChar",
		"wmSysKeyDown",
		"wmSysKeyUp",
		"wmCaptureChanged",
		"wmLButtonDblClk",
		"wmLButtonDown",
		"wmLButtonUp",
		"wmMButtonDblClk",
		"wmMButtonDown",
		"wmMButtonUp",
		"wmMouseHover",
		"wmMouseLeave",
		"wmMouseMove",
		"wmRButtonDblClk",
		"wmRButtonDown",
		"wmRButtonUp",
		"wmXButtonDblClk",
		"wmXButtonDown",
		"wmXButtonUp",
		"wmPaint",
		"wmContextMenu",
		"wmClipboard",
		"callWindowProc",
		"hooks",
		"filters",
		"getText",
		"getItemCount",
		"getItem",
		"equals",
		"GetWindowTextLength",
		"verifyText",
		"equals",
		"indexOf",
		"callWindowProc",
		"windowProc",
		"wmColorChild",
		"callWindowProc",
		"WM_KILLFOCUS",
		"SendMessage",
		"WM_LBUTTONDOWN",
		"SendMessage",
		"sendEvent",
		"isDisposed",
		"sendEvent",
		"isDisposed",
		"WM_SIZE",
		"IsWindowVisible",
		"GetDlgItem",
		"InvalidateRect",
		"GetDlgItem",
		"InvalidateRect",
		"RedrawWindow",
		"WM_SIZE",
		"SendMessage",
		"GetWindowTextLength",
		"getCodePage",
		"GetWindowText",
		"SendMessage",
		"IsWindowVisible",
		"setRedraw",
		"WM_SIZE",
		"isDisposed",
		"SetWindowText",
		"SendMessage",
		"setRedraw",
		"wmChar",
		"postEvent",
		"SendMessage",
		"hooks",
		"filters",
		"SendMessage",
		"SendMessage",
		"getClipboardText",
		"SendMessage",
		"SendMessage",
		"CallWindowProc",
		"GetWindowTextLength",
		"getCodePage",
		"GetWindowText",
		"toString",
		"CallWindowProc",
		"GetWindowTextLength",
		"getText",
		"wcslen",
		"strlen",
		"getCodePage",
		"length",
		"MoveMemory",
		"toString",
		"equals",
		"verifyText",
		"equals",
		"CallWindowProc",
		"getCodePage",
		"GetProcessHeap",
		"length",
		"HeapAlloc",
		"MoveMemory",
		"CallWindowProc",
		"HeapFree",
		"SendMessage",
		"sendEvent",
		"isDisposed",
		"SendMessage",
		"SendMessage",
		"sendEvent",
		"isDisposed",
		"postEvent",
		"sendFocusEvent",
		"isDisposed",
		"sendFocusEvent",
		"isDisposed",
		"wmCommandChild",
		"sendKeyEvent",
		"callWindowProc",
		"PeekMessage",
		"TranslateMessage",
		"DispatchMessage",
		"sendKeyEvent",
		"TCHAR",
		"WNDCLASS",
		"TCHAR",
		"TCHAR",
		"TypedListener",
		"TypedListener",
		"TypedListener",
		"RECT",
		"TCHAR",
		"TCHAR",
		"COMBOBOXINFO",
		"Point",
		"TCHAR",
		"Point",
		"Point",
		"TCHAR",
		"COMBOBOXINFO",
		"TCHAR",
		"String",
		"TCHAR",
		"RECT",
		"TCHAR",
		"COMBOBOXINFO",
		"RECT",
		"TCHAR",
		"RECT",
		"Event",
		"LRESULT",
		"TCHAR",
		"TCHAR",
		"TCHAR",
		"TCHAR",
		"LRESULT",
		"MSG",
		"LRESULT"
	],
	"methodsBody":{
		"public void setText(String string)":{
			"methodBody":"{\n    checkWidget();\n    if (string == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if ((style & SWT.READ_ONLY) != 0) {\n        int index = indexOf(string);\n        if (index != -1)\n            select(index);\n        return;\n    }\n    TCHAR buffer = new TCHAR(getCodePage(), string, true);\n    if (OS.SetWindowText(handle, buffer)) {\n        sendEvent(SWT.Modify);\n    \n    }\n}",
			"comments":"/**\n* Sets the contents of the receiver's text field to the\n* given string.\n* <p>\n* Note: The text field in a <code>Combo</code> is typically\n* only capable of displaying a single line of text. Thus,\n* setting the text to a string containing line breaks or\n* other special characters will probably cause it to\n* display incorrectly.\n* </p>\n*\n* @param string the new text\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the string is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n// widget could be disposed at this point\n",
			"methodName":"public void setText(String string)"
		},
		"int windowProc(int hwnd, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    if (handle == 0)\n        return 0;\n    if (hwnd != handle) {\n        int hwndText = OS.GetDlgItem(handle, CBID_EDIT);\n        int hwndList = OS.GetDlgItem(handle, CBID_LIST);\n        if ((hwndText != 0 && hwnd == hwndText) || (hwndList != 0 && hwnd == hwndList)) {\n            LRESULT result = null;\n            switch(msg) {\n                \n                case OS.WM_CHAR:\n                    result = wmChar(hwnd, wParam, lParam);\n                    break;\n                case OS.WM_IME_CHAR:\n                    result = wmIMEChar(hwnd, wParam, lParam);\n                    break;\n                case OS.WM_KEYDOWN:\n                    result = wmKeyDown(hwnd, wParam, lParam);\n                    break;\n                case OS.WM_KEYUP:\n                    result = wmKeyUp(hwnd, wParam, lParam);\n                    break;\n                case OS.WM_SYSCHAR:\n                    result = wmSysChar(hwnd, wParam, lParam);\n                    break;\n                case OS.WM_SYSKEYDOWN:\n                    result = wmSysKeyDown(hwnd, wParam, lParam);\n                    break;\n                case OS.WM_SYSKEYUP:\n                    result = wmSysKeyUp(hwnd, wParam, lParam);\n                    break;\n                \n                case OS.WM_CAPTURECHANGED:\n                    result = wmCaptureChanged(hwnd, wParam, lParam);\n                    break;\n                case OS.WM_LBUTTONDBLCLK:\n                    result = wmLButtonDblClk(hwnd, wParam, lParam);\n                    break;\n                case OS.WM_LBUTTONDOWN:\n                    result = wmLButtonDown(hwnd, wParam, lParam);\n                    break;\n                case OS.WM_LBUTTONUP:\n                    result = wmLButtonUp(hwnd, wParam, lParam);\n                    break;\n                case OS.WM_MBUTTONDBLCLK:\n                    result = wmMButtonDblClk(hwnd, wParam, lParam);\n                    break;\n                case OS.WM_MBUTTONDOWN:\n                    result = wmMButtonDown(hwnd, wParam, lParam);\n                    break;\n                case OS.WM_MBUTTONUP:\n                    result = wmMButtonUp(hwnd, wParam, lParam);\n                    break;\n                case OS.WM_MOUSEHOVER:\n                    result = wmMouseHover(hwnd, wParam, lParam);\n                    break;\n                case OS.WM_MOUSELEAVE:\n                    result = wmMouseLeave(hwnd, wParam, lParam);\n                    break;\n                case OS.WM_MOUSEMOVE:\n                    result = wmMouseMove(hwnd, wParam, lParam);\n                    break;\n                \n                case OS.WM_RBUTTONDBLCLK:\n                    result = wmRButtonDblClk(hwnd, wParam, lParam);\n                    break;\n                case OS.WM_RBUTTONDOWN:\n                    result = wmRButtonDown(hwnd, wParam, lParam);\n                    break;\n                case OS.WM_RBUTTONUP:\n                    result = wmRButtonUp(hwnd, wParam, lParam);\n                    break;\n                case OS.WM_XBUTTONDBLCLK:\n                    result = wmXButtonDblClk(hwnd, wParam, lParam);\n                    break;\n                case OS.WM_XBUTTONDOWN:\n                    result = wmXButtonDown(hwnd, wParam, lParam);\n                    break;\n                case OS.WM_XBUTTONUP:\n                    result = wmXButtonUp(hwnd, wParam, lParam);\n                    break;\n                \n                case OS.WM_PAINT:\n                    result = wmPaint(hwnd, wParam, lParam);\n                    break;\n                \n                case OS.WM_CONTEXTMENU:\n                    result = wmContextMenu(hwnd, wParam, lParam);\n                    break;\n                \n                case OS.WM_CLEAR:\n                case OS.WM_CUT:\n                case OS.WM_PASTE:\n                case OS.WM_UNDO:\n                case OS.EM_UNDO:\n                case OS.WM_SETTEXT:\n                    if (hwnd == hwndText) {\n                        result = wmClipboard(hwnd, msg, wParam, lParam);\n                    }\n                    break;\n            }\n            if (result != null)\n                return result.value;\n            return callWindowProc(hwnd, msg, wParam, lParam);\n        }\n    }\n    if (msg == OS.CB_SETCURSEL) {\n        if ((style & SWT.READ_ONLY) != 0) {\n            if (hooks(SWT.Verify) || filters(SWT.Verify)) {\n                String oldText = getText(), newText = null;\n                if (wParam == -1) {\n                    newText = \"\";\n                } else {\n                    if (0 <= wParam && wParam < getItemCount()) {\n                        newText = getItem(wParam);\n                    }\n                }\n                if (newText != null && !newText.equals(oldText)) {\n                    int length = OS.GetWindowTextLength(handle);\n                    oldText = newText;\n                    newText = verifyText(newText, 0, length, null);\n                    if (newText == null)\n                        return 0;\n                    if (!newText.equals(oldText)) {\n                        int index = indexOf(newText);\n                        if (index != -1 && index != wParam) {\n                            return callWindowProc(handle, OS.CB_SETCURSEL, index, lParam);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return super.windowProc(hwnd, msg, wParam, lParam);\n}",
			"comments":"/* Keyboard messages */\n/* Mouse Messages */\n//\t\t\t\tcase OS.WM_MOUSEWHEEL:\t\tresult = wmMouseWheel (hwnd, wParam, lParam); break;\n/* Paint messages */\n/* Menu messages */\n/* Clipboard messages */\n",
			"methodName":"int windowProc(int hwnd, int msg, int wParam, int lParam)"
		},
		"public void setOrientation(int orientation)":{
			"methodBody":"{\n    checkWidget();\n    if (OS.IsWinCE)\n        return;\n    if (OS.WIN32_VERSION < OS.VERSION(4, 10))\n        return;\n    int flags = SWT.RIGHT_TO_LEFT | SWT.LEFT_TO_RIGHT;\n    if ((orientation & flags) == 0 || (orientation & flags) == flags)\n        return;\n    style &= ~flags;\n    style |= orientation & flags;\n    int bits = OS.GetWindowLong(handle, OS.GWL_EXSTYLE);\n    if ((style & SWT.RIGHT_TO_LEFT) != 0) {\n        style |= SWT.MIRRORED;\n        bits |= OS.WS_EX_LAYOUTRTL;\n    } else {\n        style &= ~SWT.MIRRORED;\n        bits &= ~OS.WS_EX_LAYOUTRTL;\n    }\n    OS.SetWindowLong(handle, OS.GWL_EXSTYLE, bits);\n    int hwndText = 0, hwndList = 0;\n    COMBOBOXINFO pcbi = new COMBOBOXINFO();\n    pcbi.cbSize = COMBOBOXINFO.sizeof;\n    if (OS.GetComboBoxInfo(handle, pcbi)) {\n        hwndText = pcbi.hwndItem;\n        hwndList = pcbi.hwndList;\n    }\n    if (hwndText != 0) {\n        int bits1 = OS.GetWindowLong(hwndText, OS.GWL_EXSTYLE);\n        int bits2 = OS.GetWindowLong(hwndText, OS.GWL_STYLE);\n        if ((style & SWT.RIGHT_TO_LEFT) != 0) {\n            bits1 |= OS.WS_EX_RIGHT | OS.WS_EX_RTLREADING;\n            bits2 |= OS.ES_RIGHT;\n        } else {\n            bits1 &= ~(OS.WS_EX_RIGHT | OS.WS_EX_RTLREADING);\n            bits2 &= ~OS.ES_RIGHT;\n        }\n        OS.SetWindowLong(hwndText, OS.GWL_EXSTYLE, bits1);\n        OS.SetWindowLong(hwndText, OS.GWL_STYLE, bits2);\n        \n        RECT rect = new RECT();\n        OS.GetWindowRect(hwndText, rect);\n        int width = rect.right - rect.left, height = rect.bottom - rect.top;\n        OS.GetWindowRect(handle, rect);\n        int widthCombo = rect.right - rect.left, heightCombo = rect.bottom - rect.top;\n        int uFlags = OS.SWP_NOMOVE | OS.SWP_NOZORDER | OS.SWP_NOACTIVATE;\n        SetWindowPos(hwndText, 0, 0, 0, width - 1, height - 1, uFlags);\n        SetWindowPos(handle, 0, 0, 0, widthCombo - 1, heightCombo - 1, uFlags);\n        SetWindowPos(hwndText, 0, 0, 0, width, height, uFlags);\n        SetWindowPos(handle, 0, 0, 0, widthCombo, heightCombo, uFlags);\n        OS.InvalidateRect(handle, null, true);\n    }\n    if (hwndList != 0) {\n        int bits1 = OS.GetWindowLong(hwndList, OS.GWL_EXSTYLE);\n        if ((style & SWT.RIGHT_TO_LEFT) != 0) {\n            bits1 |= OS.WS_EX_LAYOUTRTL;\n        } else {\n            bits1 &= ~OS.WS_EX_LAYOUTRTL;\n        }\n        OS.SetWindowLong(hwndList, OS.GWL_EXSTYLE, bits1);\n    }\n}",
			"comments":"/**\n* Sets the orientation of the receiver, which must be one\n* of the constants <code>SWT.LEFT_TO_RIGHT</code> or <code>SWT.RIGHT_TO_LEFT</code>.\n* <p>\n*\n* @param orientation new orientation style\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 2.1.2\n*/\n/*\n* Bug in Windows.  For some reason, the single line text field\n* portion of the combo box does not redraw to reflect the new\n* style bits.  The fix is to force the widget to be resized by\n* temporarily shrinking and then growing the width and height.\n*/\n",
			"methodName":"public void setOrientation(int orientation)"
		},
		"boolean hasFocus()":{
			"methodBody":"{\n    int hwndFocus = OS.GetFocus();\n    if (hwndFocus == handle)\n        return true;\n    if (hwndFocus == 0)\n        return false;\n    int hwndText = OS.GetDlgItem(handle, CBID_EDIT);\n    if (hwndFocus == hwndText)\n        return true;\n    int hwndList = OS.GetDlgItem(handle, CBID_LIST);\n    if (hwndFocus == hwndList)\n        return true;\n    return false;\n}",
			"comments":"",
			"methodName":"boolean hasFocus()"
		},
		"void deregister()":{
			"methodBody":"{\n    super.deregister();\n    int hwndText = OS.GetDlgItem(handle, CBID_EDIT);\n    if (hwndText != 0)\n        display.removeControl(hwndText);\n    int hwndList = OS.GetDlgItem(handle, CBID_LIST);\n    if (hwndList != 0)\n        display.removeControl(hwndList);\n}",
			"comments":"",
			"methodName":"void deregister()"
		},
		"LRESULT WM_SETFOCUS(int wParam, int lParam)":{
			"methodBody":"{\n    \n    return null;\n}",
			"comments":"/*\n* Return NULL - Focus notification is\n* done by WM_COMMAND with CBN_SETFOCUS.\n*/\n",
			"methodName":"LRESULT WM_SETFOCUS(int wParam, int lParam)"
		},
		"LRESULT wmCommandChild(int wParam, int lParam)":{
			"methodBody":"{\n    int code = wParam >> 16;\n    switch(code) {\n        case OS.CBN_EDITCHANGE:\n            if (ignoreModify)\n                break;\n            \n            noSelection = true;\n            sendEvent(SWT.Modify);\n            if (isDisposed())\n                return LRESULT.ZERO;\n            noSelection = false;\n            break;\n        case OS.CBN_SELCHANGE:\n            \n            int index = OS.SendMessage(handle, OS.CB_GETCURSEL, 0, 0);\n            if (index != OS.CB_ERR) {\n                OS.SendMessage(handle, OS.CB_SETCURSEL, index, 0);\n            }\n            \n            sendEvent(SWT.Modify);\n            if (isDisposed())\n                return LRESULT.ZERO;\n            postEvent(SWT.Selection);\n            break;\n        case OS.CBN_SETFOCUS:\n            sendFocusEvent(SWT.FocusIn);\n            if (isDisposed())\n                return LRESULT.ZERO;\n            break;\n        case OS.CBN_KILLFOCUS:\n            \n            if ((style & SWT.READ_ONLY) != 0)\n                break;\n            sendFocusEvent(SWT.FocusOut);\n            if (isDisposed())\n                return LRESULT.ZERO;\n            break;\n    }\n    return super.wmCommandChild(wParam, lParam);\n}",
			"comments":"/*\n* Feature in Windows.  If the combo box list selection is\n* queried using CB_GETCURSEL before the WM_COMMAND (with\n* CBN_EDITCHANGE) returns, CB_GETCURSEL returns the previous\n* selection in the list.  It seems that the combo box sends\n* the WM_COMMAND before it makes the selection in the list box\n* match the entry field.  The fix is remember that no selection\n* in the list should exist in this case.\n*/\n/*\n* Feature in Windows.  If the text in an editable combo box\n* is queried using GetWindowText () before the WM_COMMAND\n* (with CBN_SELCHANGE) returns, GetWindowText () returns is\n* the previous text in the combo box.  It seems that the combo\n* box sends the WM_COMMAND before it updates the text field to\n* match the list selection.  The fix is to force the text field\n* to match the list selection by re-selecting the list item.\n*/\n/*\n* It is possible (but unlikely), that application\n* code could have disposed the widget in the modify\n* event.  If this happens, end the processing of the\n* Windows message by returning zero as the result of\n* the window proc.\n*/\n/*\n* Bug in Windows.  When a combo box that is read only\n* is disposed in CBN_KILLFOCUS, Windows segment faults.\n* The fix is to send focus from WM_KILLFOCUS instead\n* of CBN_KILLFOCUS.\n*\n* NOTE: In version 6 of COMCTL32.DLL, the bug is fixed.\n*/\n",
			"methodName":"LRESULT wmCommandChild(int wParam, int lParam)"
		},
		"public void copy()":{
			"methodBody":"{\n    checkWidget();\n    OS.SendMessage(handle, OS.WM_COPY, 0, 0);\n}",
			"comments":"/**\n* Copies the selected text.\n* <p>\n* The current selection is copied to the clipboard.\n* </p>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 2.1\n*/\n",
			"methodName":"public void copy()"
		},
		"protected void checkSubclass()":{
			"methodBody":"{\n    if (!isValidSubclass())\n        error(SWT.ERROR_INVALID_SUBCLASS);\n}",
			"comments":"",
			"methodName":"protected void checkSubclass()"
		},
		"public int getVisibleItemCount()":{
			"methodBody":"{\n    checkWidget();\n    return visibleCount;\n}",
			"comments":"/**\n* Gets the number of items that are visible in the drop\n* down portion of the receiver's list.\n* <p>\n* Note: This operation is a hint and is not supported on\n* platforms that do not have this concept.\n* </p>\n*\n* @return the number of items that are visible\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public int getVisibleItemCount()"
		},
		"public void add(String string)":{
			"methodBody":"{\n    checkWidget();\n    if (string == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TCHAR buffer = new TCHAR(getCodePage(), string, true);\n    int result = OS.SendMessage(handle, OS.CB_ADDSTRING, 0, buffer);\n    if (result == OS.CB_ERR)\n        error(SWT.ERROR_ITEM_NOT_ADDED);\n    if (result == OS.CB_ERRSPACE)\n        error(SWT.ERROR_ITEM_NOT_ADDED);\n}",
			"comments":"/**\n* Adds the argument to the end of the receiver's list.\n*\n* @param string the new item\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the string is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #add(String,int)\n*/\n",
			"methodName":"public void add(String string)"
		},
		"public void removeVerifyListener(VerifyListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.Verify, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when the control is verified.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see VerifyListener\n* @see #addVerifyListener\n*\n* @since 3.1\n*/\n",
			"methodName":"public void removeVerifyListener(VerifyListener listener)"
		},
		"public String getItem(int index)":{
			"methodBody":"{\n    checkWidget();\n    int length = OS.SendMessage(handle, OS.CB_GETLBTEXTLEN, index, 0);\n    if (length != OS.CB_ERR) {\n        TCHAR buffer = new TCHAR(getCodePage(), length + 1);\n        int result = OS.SendMessage(handle, OS.CB_GETLBTEXT, index, buffer);\n        if (result != OS.CB_ERR)\n            return buffer.toString(0, length);\n    }\n    int count = OS.SendMessage(handle, OS.CB_GETCOUNT, 0, 0);\n    if (0 <= index && index < count)\n        error(SWT.ERROR_CANNOT_GET_ITEM);\n    error(SWT.ERROR_INVALID_RANGE);\n    return \"\";\n}",
			"comments":"/**\n* Returns the item at the given, zero-relative index in the\n* receiver's list. Throws an exception if the index is out\n* of range.\n*\n* @param index the index of the item to return\n* @return the item at the given index\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_RANGE - if the index is not between 0 and the number of elements in the list minus 1 (inclusive)</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public String getItem(int index)"
		},
		"public void removeSelectionListener(SelectionListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.Selection, listener);\n    eventTable.unhook(SWT.DefaultSelection, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when the receiver's selection changes.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see SelectionListener\n* @see #addSelectionListener\n*/\n",
			"methodName":"public void removeSelectionListener(SelectionListener listener)"
		},
		"public int indexOf(String string)":{
			"methodBody":"{\n    return indexOf(string, 0);\n}",
			"comments":"/**\n* Searches the receiver's list starting at the first item\n* (index 0) until an item is found that is equal to the\n* argument, and returns the index of that item. If no item\n* is found, returns -1.\n*\n* @param string the search item\n* @return the index of the item\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the string is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int indexOf(String string)"
		},
		"public void select(int index)":{
			"methodBody":"{\n    checkWidget();\n    int count = OS.SendMessage(handle, OS.CB_GETCOUNT, 0, 0);\n    if (0 <= index && index < count) {\n        int selection = OS.SendMessage(handle, OS.CB_GETCURSEL, 0, 0);\n        int code = OS.SendMessage(handle, OS.CB_SETCURSEL, index, 0);\n        if (code != OS.CB_ERR && code != selection) {\n            sendEvent(SWT.Modify);\n        \n        }\n    }\n}",
			"comments":"/**\n* Selects the item at the given zero-relative index in the receiver's\n* list.  If the item at the index was already selected, it remains\n* selected. Indices that are out of range are ignored.\n*\n* @param index the index of the item to select\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n// widget could be disposed at this point\n",
			"methodName":"public void select(int index)"
		},
		"void subclass()":{
			"methodBody":"{\n    super.subclass();\n    int newProc = display.windowProc;\n    int hwndText = OS.GetDlgItem(handle, CBID_EDIT);\n    if (hwndText != 0) {\n        OS.SetWindowLong(hwndText, OS.GWL_WNDPROC, newProc);\n    }\n    int hwndList = OS.GetDlgItem(handle, CBID_LIST);\n    if (hwndList != 0) {\n        OS.SetWindowLong(hwndList, OS.GWL_WNDPROC, newProc);\n    }\n}",
			"comments":"",
			"methodName":"void subclass()"
		},
		"int defaultBackground()":{
			"methodBody":"{\n    return OS.GetSysColor(OS.COLOR_WINDOW);\n}",
			"comments":"",
			"methodName":"int defaultBackground()"
		},
		"public String[] getItems()":{
			"methodBody":"{\n    checkWidget();\n    int count = getItemCount();\n    String[] result = new String[count];\n    for (int i = 0; i < count; i++) result[i] = getItem(i);\n    return result;\n}",
			"comments":"/**\n* Returns a (possibly empty) array of <code>String</code>s which are\n* the items in the receiver's list.\n* <p>\n* Note: This is not the actual structure used by the receiver\n* to maintain its list of items, so modifying the array will\n* not affect the receiver.\n* </p>\n*\n* @return the items in the receiver's list\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public String[] getItems()"
		},
		"public void remove(int start, int end)":{
			"methodBody":"{\n    checkWidget();\n    if (start > end)\n        return;\n    int count = OS.SendMessage(handle, OS.CB_GETCOUNT, 0, 0);\n    if (!(0 <= start && start <= end && end < count)) {\n        error(SWT.ERROR_INVALID_RANGE);\n    }\n    int length = OS.GetWindowTextLength(handle);\n    for (int i = start; i <= end; i++) {\n        int result = OS.SendMessage(handle, OS.CB_DELETESTRING, start, 0);\n        if (result == OS.CB_ERR)\n            error(SWT.ERROR_ITEM_NOT_REMOVED);\n    }\n    if (length != OS.GetWindowTextLength(handle)) {\n        \n        sendEvent(SWT.Modify);\n        if (isDisposed())\n            return;\n    }\n    \n    if ((style & SWT.READ_ONLY) != 0) {\n        count = OS.SendMessage(handle, OS.CB_GETCOUNT, 0, 0);\n        if (count == 0)\n            OS.InvalidateRect(handle, null, true);\n    }\n}",
			"comments":"/**\n* Removes the items from the receiver's list which are\n* between the given zero-relative start and end\n* indices (inclusive).\n*\n* @param start the start of the range\n* @param end the end of the range\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_RANGE - if either the start or end are not between 0 and the number of elements in the list minus 1 (inclusive)</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* It is possible (but unlikely), that application\n* code could have disposed the widget in the modify\n* event.  If this happens, just return.\n*/\n/*\n* Bug in Windows.  When the combo box is read only\n* with exactly one item that is currently selected\n* and that item is removed, the combo box does not\n* redraw to clear the text area.  The fix is to\n* force a redraw.\n*/\n",
			"methodName":"public void remove(int start, int end)"
		},
		"int widgetExtStyle()":{
			"methodBody":"{\n    return super.widgetExtStyle() & ~OS.WS_EX_NOINHERITLAYOUT;\n}",
			"comments":"",
			"methodName":"int widgetExtStyle()"
		},
		"LRESULT WM_SIZE(int wParam, int lParam)":{
			"methodBody":"{\n    \n    if ((style & SWT.SIMPLE) != 0) {\n        LRESULT result = super.WM_SIZE(wParam, lParam);\n        if (OS.IsWindowVisible(handle)) {\n            if (OS.IsWinCE) {\n                int hwndText = OS.GetDlgItem(handle, CBID_EDIT);\n                if (hwndText != 0)\n                    OS.InvalidateRect(hwndText, null, true);\n                int hwndList = OS.GetDlgItem(handle, CBID_LIST);\n                if (hwndList != 0)\n                    OS.InvalidateRect(hwndList, null, true);\n            } else {\n                int uFlags = OS.RDW_ERASE | OS.RDW_INVALIDATE | OS.RDW_ALLCHILDREN;\n                OS.RedrawWindow(handle, null, 0, uFlags);\n            }\n        }\n        return result;\n    }\n    \n    if ((style & SWT.READ_ONLY) != 0 || (style & SWT.DROP_DOWN) == 0) {\n        return super.WM_SIZE(wParam, lParam);\n    }\n    int index = OS.SendMessage(handle, OS.CB_GETCURSEL, 0, 0);\n    boolean redraw = false;\n    TCHAR buffer = null;\n    int[] start = null, end = null;\n    if (index == OS.CB_ERR) {\n        int length = OS.GetWindowTextLength(handle);\n        if (length != 0) {\n            buffer = new TCHAR(getCodePage(), length + 1);\n            OS.GetWindowText(handle, buffer, length + 1);\n            start = new int[1];\n            end = new int[1];\n            OS.SendMessage(handle, OS.CB_GETEDITSEL, start, end);\n            redraw = drawCount == 0 && OS.IsWindowVisible(handle);\n            if (redraw)\n                setRedraw(false);\n        }\n    }\n    LRESULT result = super.WM_SIZE(wParam, lParam);\n    \n    if (isDisposed())\n        return result;\n    if (buffer != null) {\n        OS.SetWindowText(handle, buffer);\n        int bits = start[0] | (end[0] << 16);\n        OS.SendMessage(handle, OS.CB_SETEDITSEL, 0, bits);\n        if (redraw)\n            setRedraw(true);\n    }\n    return result;\n}",
			"comments":"/*\n* Bug in Windows.  If the combo box has the CBS_SIMPLE style,\n* the list portion of the combo box is not redrawn when the\n* combo box is resized.  The fix is to force a redraw when\n* the size has changed.\n*/\n/*\n* Feature in Windows.  When an editable drop down combo box\n* contains text that does not correspond to an item in the\n* list, when the widget is resized, it selects the closest\n* match from the list.  The fix is to remember the original\n* text and reset it after the widget is resized.\n*/\n/*\n* It is possible (but unlikely), that application\n* code could have disposed the widget in the resize\n* event.  If this happens, end the processing of the\n* Windows message by returning the result of the\n* WM_SIZE message.\n*/\n",
			"methodName":"LRESULT WM_SIZE(int wParam, int lParam)"
		},
		"LRESULT WM_CTLCOLOR(int wParam, int lParam)":{
			"methodBody":"{\n    return wmColorChild(wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_CTLCOLOR(int wParam, int lParam)"
		},
		"public void remove(int index)":{
			"methodBody":"{\n    checkWidget();\n    int length = OS.GetWindowTextLength(handle);\n    int code = OS.SendMessage(handle, OS.CB_DELETESTRING, index, 0);\n    if (code == OS.CB_ERR) {\n        int count = OS.SendMessage(handle, OS.CB_GETCOUNT, 0, 0);\n        if (0 <= index && index < count)\n            error(SWT.ERROR_ITEM_NOT_REMOVED);\n        error(SWT.ERROR_INVALID_RANGE);\n    }\n    if (length != OS.GetWindowTextLength(handle)) {\n        \n        sendEvent(SWT.Modify);\n        if (isDisposed())\n            return;\n    }\n    \n    if ((style & SWT.READ_ONLY) != 0) {\n        int count = OS.SendMessage(handle, OS.CB_GETCOUNT, 0, 0);\n        if (count == 0)\n            OS.InvalidateRect(handle, null, true);\n    }\n}",
			"comments":"/**\n* Removes the item from the receiver's list at the given\n* zero-relative index.\n*\n* @param index the index for the item\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_RANGE - if the index is not between 0 and the number of elements in the list minus 1 (inclusive)</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* It is possible (but unlikely), that application\n* code could have disposed the widget in the modify\n* event.  If this happens, just return.\n*/\n/*\n* Bug in Windows.  When the combo box is read only\n* with exactly one item that is currently selected\n* and that item is removed, the combo box does not\n* redraw to clear the text area.  The fix is to\n* force a redraw.\n*/\n",
			"methodName":"public void remove(int index)"
		},
		"void createHandle()":{
			"methodBody":"{\n    super.createHandle();\n    state &= ~CANVAS;\n    \n    int hwndText = OS.GetDlgItem(handle, CBID_EDIT);\n    if (hwndText != 0 && EditProc == 0) {\n        EditProc = OS.GetWindowLong(hwndText, OS.GWL_WNDPROC);\n    }\n    int hwndList = OS.GetDlgItem(handle, CBID_LIST);\n    if (hwndList != 0 && ListProc == 0) {\n        ListProc = OS.GetWindowLong(hwndList, OS.GWL_WNDPROC);\n    }\n    \n    if ((style & SWT.SIMPLE) != 0) {\n        int flags = OS.SWP_NOZORDER | OS.SWP_DRAWFRAME | OS.SWP_NOACTIVATE;\n        SetWindowPos(handle, 0, 0, 0, 0x3FFF, 0x3FFF, flags);\n        SetWindowPos(handle, 0, 0, 0, 0, 0, flags);\n    }\n}",
			"comments":"/* Get the text and list window procs */\n/*\n* Bug in Windows.  If the combo box has the CBS_SIMPLE style,\n* the list portion of the combo box is not drawn correctly the\n* first time, causing pixel corruption.  The fix is to ensure\n* that the combo box has been resized more than once.\n*/\n",
			"methodName":"void createHandle()"
		},
		"public void add(String string, int index)":{
			"methodBody":"{\n    checkWidget();\n    if (string == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    int count = OS.SendMessage(handle, OS.CB_GETCOUNT, 0, 0);\n    if (!(0 <= index && index <= count)) {\n        error(SWT.ERROR_INVALID_RANGE);\n    }\n    TCHAR buffer = new TCHAR(getCodePage(), string, true);\n    int result = OS.SendMessage(handle, OS.CB_INSERTSTRING, index, buffer);\n    if (result == OS.CB_ERRSPACE || result == OS.CB_ERR) {\n        error(SWT.ERROR_ITEM_NOT_ADDED);\n    }\n}",
			"comments":"/**\n* Adds the argument to the receiver's list at the given\n* zero-relative index.\n* <p>\n* Note: To add an item at the end of the list, use the\n* result of calling <code>getItemCount()</code> as the\n* index or use <code>add(String)</code>.\n* </p>\n*\n* @param string the new item\n* @param index the index for the item\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the string is null</li>\n*    <li>ERROR_INVALID_RANGE - if the index is not between 0 and the number of elements in the list (inclusive)</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #add(String)\n*/\n",
			"methodName":"public void add(String string, int index)"
		},
		"String getNameText()":{
			"methodBody":"{\n    return getText();\n}",
			"comments":"",
			"methodName":"String getNameText()"
		},
		"int mbcsToWcsPos(int mbcsPos)":{
			"methodBody":"{\n    if (mbcsPos <= 0)\n        return 0;\n    if (OS.IsUnicode)\n        return mbcsPos;\n    int hwndText = OS.GetDlgItem(handle, CBID_EDIT);\n    if (hwndText == 0)\n        return mbcsPos;\n    int mbcsSize = OS.GetWindowTextLengthA(hwndText);\n    if (mbcsSize == 0)\n        return 0;\n    if (mbcsPos >= mbcsSize)\n        return mbcsSize;\n    byte[] buffer = new byte[mbcsSize + 1];\n    OS.GetWindowTextA(hwndText, buffer, mbcsSize + 1);\n    return OS.MultiByteToWideChar(getCodePage(), OS.MB_PRECOMPOSED, buffer, mbcsPos, null, 0);\n}",
			"comments":"",
			"methodName":"int mbcsToWcsPos(int mbcsPos)"
		},
		"public void setVisibleItemCount(int count)":{
			"methodBody":"{\n    checkWidget();\n    if (count < 0)\n        return;\n    visibleCount = count;\n    if ((style & SWT.DROP_DOWN) != 0) {\n        forceResize();\n        RECT rect = new RECT();\n        OS.GetWindowRect(handle, rect);\n        int flags = OS.SWP_NOMOVE | OS.SWP_NOZORDER | OS.SWP_DRAWFRAME | OS.SWP_NOACTIVATE;\n        setBounds(0, 0, rect.right - rect.left, rect.bottom - rect.top, flags);\n    }\n}",
			"comments":"/**\n* Sets the number of items that are visible in the drop\n* down portion of the receiver's list.\n* <p>\n* Note: This operation is a hint and is not supported on\n* platforms that do not have this concept.\n* </p>\n*\n* @param count the new number of items to be visible\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public void setVisibleItemCount(int count)"
		},
		"public String getText()":{
			"methodBody":"{\n    checkWidget();\n    int length = OS.GetWindowTextLength(handle);\n    if (length == 0)\n        return \"\";\n    TCHAR buffer = new TCHAR(getCodePage(), length + 1);\n    OS.GetWindowText(handle, buffer, length + 1);\n    return buffer.toString(0, length);\n}",
			"comments":"/**\n* Returns a string containing a copy of the contents of the\n* receiver's text field, or an empty string if there are no\n* contents.\n*\n* @return the receiver's text\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public String getText()"
		},
		"LRESULT WM_GETDLGCODE(int wParam, int lParam)":{
			"methodBody":"{\n    int code = callWindowProc(handle, OS.WM_GETDLGCODE, wParam, lParam);\n    return new LRESULT(code | OS.DLGC_WANTARROWS);\n}",
			"comments":"",
			"methodName":"LRESULT WM_GETDLGCODE(int wParam, int lParam)"
		},
		"public int getOrientation()":{
			"methodBody":"{\n    checkWidget();\n    return style & (SWT.LEFT_TO_RIGHT | SWT.RIGHT_TO_LEFT);\n}",
			"comments":"/**\n* Returns the orientation of the receiver.\n*\n* @return the orientation style\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 2.1.2\n*/\n",
			"methodName":"public int getOrientation()"
		},
		"boolean translateTraversal(MSG msg)":{
			"methodBody":"{\n    \n    switch(msg.wParam) {\n        case OS.VK_RETURN:\n        case OS.VK_ESCAPE:\n            if ((style & SWT.DROP_DOWN) != 0) {\n                if (OS.SendMessage(handle, OS.CB_GETDROPPEDSTATE, 0, 0) != 0) {\n                    return false;\n                }\n            }\n    }\n    return super.translateTraversal(msg);\n}",
			"comments":"/*\n* When the combo box is dropped down, allow return\n* to select an item in the list and escape to close\n* the combo box.\n*/\n",
			"methodName":"boolean translateTraversal(MSG msg)"
		},
		"int windowProc()":{
			"methodBody":"{\n    return ComboProc;\n}",
			"comments":"",
			"methodName":"int windowProc()"
		},
		"public void removeAll()":{
			"methodBody":"{\n    checkWidget();\n    OS.SendMessage(handle, OS.CB_RESETCONTENT, 0, 0);\n    sendEvent(SWT.Modify);\n\n}",
			"comments":"/**\n* Removes all of the items from the receiver's list and clear the\n* contents of receiver's text field.\n* <p>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n// widget could be disposed at this point\n",
			"methodName":"public void removeAll()"
		},
		"String verifyText(String string, int start, int end, Event keyEvent)":{
			"methodBody":"{\n    Event event = new Event();\n    event.text = string;\n    event.start = start;\n    event.end = end;\n    if (keyEvent != null) {\n        event.character = keyEvent.character;\n        event.keyCode = keyEvent.keyCode;\n        event.stateMask = keyEvent.stateMask;\n    }\n    if (!OS.IsUnicode && OS.IsDBLocale) {\n        event.start = mbcsToWcsPos(start);\n        event.end = mbcsToWcsPos(end);\n    }\n    \n    sendEvent(SWT.Verify, event);\n    if (!event.doit || isDisposed())\n        return null;\n    return event.text;\n}",
			"comments":"/*\n* It is possible (but unlikely), that application\n* code could have disposed the widget in the verify\n* event.  If this happens, answer null to cancel\n* the operation.\n*/\n",
			"methodName":"String verifyText(String string, int start, int end, Event keyEvent)"
		},
		"public void addSelectionListener(SelectionListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.Selection, typedListener);\n    addListener(SWT.DefaultSelection, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when the receiver's selection changes, by sending\n* it one of the messages defined in the <code>SelectionListener</code>\n* interface.\n* <p>\n* <code>widgetSelected</code> is called when the combo's list selection changes.\n* <code>widgetDefaultSelected</code> is typically called when ENTER is pressed the combo's text area.\n* </p>\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see SelectionListener\n* @see #removeSelectionListener\n* @see SelectionEvent\n*/\n",
			"methodName":"public void addSelectionListener(SelectionListener listener)"
		},
		"void setBounds(int x, int y, int width, int height, int flags)":{
			"methodBody":"{\n    \n    if ((style & SWT.DROP_DOWN) != 0) {\n        height = getTextHeight() + (getItemHeight() * visibleCount) + 2;\n        \n        RECT rect = new RECT();\n        OS.GetWindowRect(handle, rect);\n        if (rect.right - rect.left != 0) {\n            if (OS.SendMessage(handle, OS.CB_GETDROPPEDCONTROLRECT, 0, rect) != 0) {\n                int oldWidth = rect.right - rect.left, oldHeight = rect.bottom - rect.top;\n                if (oldWidth == width && oldHeight == height)\n                    flags |= OS.SWP_NOSIZE;\n            }\n        }\n        SetWindowPos(handle, 0, x, y, width, height, flags);\n    } else {\n        super.setBounds(x, y, width, height, flags);\n    }\n}",
			"comments":"/*\n* Feature in Windows.  If the combo box has the CBS_DROPDOWN\n* or CBS_DROPDOWNLIST style, Windows uses the height that the\n* programmer sets in SetWindowPos () to control height of the\n* drop down list.  When the width is non-zero, Windows remembers\n* this value and sets the height to be the height of the text\n* field part of the combo box.  If the width is zero, Windows\n* allows the height to have any value.  Therefore, when the\n* programmer sets and then queries the height, the values can\n* be different depending on the width.  The problem occurs when\n* the programmer uses computeSize () to determine the preferred\n* height (always the height of the text field) and then uses\n* this value to set the height of the combo box.  The result\n* is a combo box with a zero size drop down list.  The fix, is\n* to always set the height to show a fixed number of combo box\n* items and ignore the height value that the programmer supplies.\n*/\n/*\n* Feature in Windows.  When a drop down combo box is resized,\n* the combo box resizes the height of the text field and uses\n* the height provided in SetWindowPos () to determine the height\n* of the drop down list.  For some reason, the combo box redraws\n* the whole area, not just the text field.  The fix is to set the\n* SWP_NOSIZE bits when the height of text field and the drop down\n* list is the same as the requested height.\n*\n* NOTE:  Setting the width of a combo box to zero does not update\n* the width of the drop down control rect.  If the width of the\n* combo box is zero, then do not set SWP_NOSIZE.\n*/\n",
			"methodName":"void setBounds(int x, int y, int width, int height, int flags)"
		},
		"boolean checkHandle(int hwnd)":{
			"methodBody":"{\n    return hwnd == handle || hwnd == OS.GetDlgItem(handle, CBID_EDIT) || hwnd == OS.GetDlgItem(handle, CBID_LIST);\n}",
			"comments":"",
			"methodName":"boolean checkHandle(int hwnd)"
		},
		"public void setItems(String[] items)":{
			"methodBody":"{\n    checkWidget();\n    if (items == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    for (int i = 0; i < items.length; i++) {\n        if (items[i] == null)\n            error(SWT.ERROR_INVALID_ARGUMENT);\n    }\n    OS.SendMessage(handle, OS.CB_RESETCONTENT, 0, 0);\n    int codePage = getCodePage();\n    for (int i = 0; i < items.length; i++) {\n        String string = items[i];\n        TCHAR buffer = new TCHAR(codePage, string, true);\n        int code = OS.SendMessage(handle, OS.CB_ADDSTRING, 0, buffer);\n        if (code == OS.CB_ERR)\n            error(SWT.ERROR_ITEM_NOT_ADDED);\n        if (code == OS.CB_ERRSPACE)\n            error(SWT.ERROR_ITEM_NOT_ADDED);\n    }\n    \n    sendEvent(SWT.Modify);\n}",
			"comments":"/**\n* Sets the receiver's list to be the given array of items.\n*\n* @param items the array of items\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the items array is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if an item in the items array is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n// widget could be disposed at this point\n",
			"methodName":"public void setItems(String[] items)"
		},
		"int widgetStyle()":{
			"methodBody":"{\n    int bits = super.widgetStyle() | OS.CBS_AUTOHSCROLL | OS.CBS_NOINTEGRALHEIGHT | OS.WS_VSCROLL;\n    if ((style & SWT.SIMPLE) != 0)\n        return bits | OS.CBS_SIMPLE;\n    if ((style & SWT.READ_ONLY) != 0)\n        return bits | OS.CBS_DROPDOWNLIST;\n    return bits | OS.CBS_DROPDOWN;\n}",
			"comments":"",
			"methodName":"int widgetStyle()"
		},
		"public int getTextLimit()":{
			"methodBody":"{\n    checkWidget();\n    int hwndText = OS.GetDlgItem(handle, CBID_EDIT);\n    if (hwndText == 0)\n        return LIMIT;\n    return OS.SendMessage(hwndText, OS.EM_GETLIMITTEXT, 0, 0);\n}",
			"comments":"/**\n* Returns the maximum number of characters that the receiver's\n* text field is capable of holding. If this has not been changed\n* by <code>setTextLimit()</code>, it will be the constant\n* <code>Combo.LIMIT</code>.\n*\n* @return the text limit\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #LIMIT\n*/\n",
			"methodName":"public int getTextLimit()"
		},
		"public int getItemCount()":{
			"methodBody":"{\n    checkWidget();\n    int count = OS.SendMessage(handle, OS.CB_GETCOUNT, 0, 0);\n    if (count == OS.CB_ERR)\n        error(SWT.ERROR_CANNOT_GET_COUNT);\n    return count;\n}",
			"comments":"/**\n* Returns the number of items contained in the receiver's list.\n*\n* @return the number of items\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getItemCount()"
		},
		"public int getTextHeight()":{
			"methodBody":"{\n    checkWidget();\n    COMBOBOXINFO pcbi = new COMBOBOXINFO();\n    pcbi.cbSize = COMBOBOXINFO.sizeof;\n    if (((style & SWT.SIMPLE) == 0) && !OS.IsWinCE && OS.GetComboBoxInfo(handle, pcbi)) {\n        return (pcbi.buttonBottom - pcbi.buttonTop) + pcbi.buttonTop * 2;\n    }\n    int result = OS.SendMessage(handle, OS.CB_GETITEMHEIGHT, -1, 0);\n    if (result == OS.CB_ERR)\n        error(SWT.ERROR_CANNOT_GET_ITEM_HEIGHT);\n    return (style & SWT.DROP_DOWN) != 0 ? result + 6 : result + 10;\n}",
			"comments":"/**\n* Returns the height of the receivers's text field.\n*\n* @return the text height\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getTextHeight()"
		},
		"public void removeModifyListener(ModifyListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.Modify, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when the receiver's text is modified.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see ModifyListener\n* @see #addModifyListener\n*/\n",
			"methodName":"public void removeModifyListener(ModifyListener listener)"
		},
		"void unsubclass()":{
			"methodBody":"{\n    super.unsubclass();\n    int hwndText = OS.GetDlgItem(handle, CBID_EDIT);\n    if (hwndText != 0 && EditProc != 0) {\n        OS.SetWindowLong(hwndText, OS.GWL_WNDPROC, EditProc);\n    }\n    int hwndList = OS.GetDlgItem(handle, CBID_LIST);\n    if (hwndList != 0 && ListProc != 0) {\n        OS.SetWindowLong(hwndList, OS.GWL_WNDPROC, ListProc);\n    }\n}",
			"comments":"",
			"methodName":"void unsubclass()"
		},
		"void setBackgroundPixel(int pixel)":{
			"methodBody":"{\n    if (background == pixel)\n        return;\n    super.setBackgroundPixel(pixel);\n    int hwndText = OS.GetDlgItem(handle, CBID_EDIT);\n    if (hwndText != 0)\n        OS.InvalidateRect(hwndText, null, true);\n    int hwndList = OS.GetDlgItem(handle, CBID_LIST);\n    if (hwndList != 0)\n        OS.InvalidateRect(hwndList, null, true);\n}",
			"comments":"",
			"methodName":"void setBackgroundPixel(int pixel)"
		},
		"public int getItemHeight()":{
			"methodBody":"{\n    checkWidget();\n    int result = OS.SendMessage(handle, OS.CB_GETITEMHEIGHT, 0, 0);\n    if (result == OS.CB_ERR)\n        error(SWT.ERROR_CANNOT_GET_ITEM_HEIGHT);\n    return result;\n}",
			"comments":"/**\n* Returns the height of the area which would be used to\n* display <em>one</em> of the items in the receiver's list.\n*\n* @return the height of one item\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getItemHeight()"
		},
		"public void deselectAll()":{
			"methodBody":"{\n    checkWidget();\n    OS.SendMessage(handle, OS.CB_SETCURSEL, -1, 0);\n    sendEvent(SWT.Modify);\n\n}",
			"comments":"/**\n* Deselects all selected items in the receiver's list.\n* <p>\n* Note: To clear the selection in the receiver's text field,\n* use <code>clearSelection()</code>.\n* </p>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #clearSelection\n*/\n// widget could be disposed at this point\n",
			"methodName":"public void deselectAll()"
		},
		"int wcsToMbcsPos(int wcsPos)":{
			"methodBody":"{\n    if (wcsPos <= 0)\n        return 0;\n    if (OS.IsUnicode)\n        return wcsPos;\n    int hwndText = OS.GetDlgItem(handle, CBID_EDIT);\n    if (hwndText == 0)\n        return wcsPos;\n    int mbcsSize = OS.GetWindowTextLengthA(hwndText);\n    if (mbcsSize == 0)\n        return 0;\n    byte[] buffer = new byte[mbcsSize + 1];\n    OS.GetWindowTextA(hwndText, buffer, mbcsSize + 1);\n    int mbcsPos = 0, wcsCount = 0;\n    while (mbcsPos < mbcsSize) {\n        if (wcsPos == wcsCount)\n            break;\n        if (OS.IsDBCSLeadByte(buffer[mbcsPos++]))\n            mbcsPos++;\n        wcsCount++;\n    }\n    return mbcsPos;\n}",
			"comments":"",
			"methodName":"int wcsToMbcsPos(int wcsPos)"
		},
		"public void addVerifyListener(VerifyListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.Verify, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when the receiver's text is verified, by sending\n* it one of the messages defined in the <code>VerifyListener</code>\n* interface.\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see VerifyListener\n* @see #removeVerifyListener\n*\n* @since 3.1\n*/\n",
			"methodName":"public void addVerifyListener(VerifyListener listener)"
		},
		"static int checkStyle(int style)":{
			"methodBody":"{\n    \n    style &= ~SWT.BORDER;\n    \n    style &= ~(SWT.H_SCROLL | SWT.V_SCROLL);\n    style = checkBits(style, SWT.DROP_DOWN, SWT.SIMPLE, 0, 0, 0, 0);\n    if ((style & SWT.SIMPLE) != 0)\n        return style & ~SWT.READ_ONLY;\n    return style;\n}",
			"comments":"/*\n* Feature in Windows.  It is not possible to create\n* a combo box that has a border using Windows style\n* bits.  All combo boxes draw their own border and\n* do not use the standard Windows border styles.\n* Therefore, no matter what style bits are specified,\n* clear the BORDER bits so that the SWT style will\n* match the Windows widget.\n*\n* The Windows behavior is currently implemented on\n* all platforms.\n*/\n/*\n* Even though it is legal to create this widget\n* with scroll bars, they serve no useful purpose\n* because they do not automatically scroll the\n* widget's client area.  The fix is to clear\n* the SWT style.\n*/\n",
			"methodName":"static int checkStyle(int style)"
		},
		"public void setTextLimit(int limit)":{
			"methodBody":"{\n    checkWidget();\n    if (limit == 0)\n        error(SWT.ERROR_CANNOT_BE_ZERO);\n    OS.SendMessage(handle, OS.CB_LIMITTEXT, limit, 0);\n}",
			"comments":"/**\n* Sets the maximum number of characters that the receiver's\n* text field is capable of holding to be the argument.\n* <p>\n* To reset this value to the default, use <code>setTextLimit(Combo.LIMIT)</code>.\n* Specifying a limit value larger than <code>Combo.LIMIT</code> sets the\n* receiver's limit to <code>Combo.LIMIT</code>.\n* </p>\n* @param limit new text limit\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_CANNOT_BE_ZERO - if the limit is zero</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #LIMIT\n*/\n",
			"methodName":"public void setTextLimit(int limit)"
		},
		"LRESULT WM_LBUTTONDOWN(int wParam, int lParam)":{
			"methodBody":"{\n    \n    int oldSelection = OS.SendMessage(handle, OS.CB_GETCURSEL, 0, 0);\n    LRESULT result = super.WM_LBUTTONDOWN(wParam, lParam);\n    if ((style & SWT.READ_ONLY) == 0) {\n        int newSelection = OS.SendMessage(handle, OS.CB_GETCURSEL, 0, 0);\n        if (oldSelection != newSelection) {\n            sendEvent(SWT.Modify);\n            if (isDisposed())\n                return LRESULT.ZERO;\n            sendEvent(SWT.Selection);\n            if (isDisposed())\n                return LRESULT.ZERO;\n        }\n    }\n    return result;\n}",
			"comments":"/*\n* Feature in Windows.  When an editable combo box is dropped\n* down and the text in the entry field partially matches an\n* item in the list, Windows selects the item but doesn't send\n* WM_COMMAND with CBN_SELCHANGE.  The fix is to detect that\n* the selection has changed and issue the notification.\n*/\n",
			"methodName":"LRESULT WM_LBUTTONDOWN(int wParam, int lParam)"
		},
		"public void remove(String string)":{
			"methodBody":"{\n    checkWidget();\n    if (string == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    int index = indexOf(string, 0);\n    if (index == -1)\n        error(SWT.ERROR_INVALID_ARGUMENT);\n    remove(index);\n}",
			"comments":"/**\n* Searches the receiver's list starting at the first item\n* until an item is found that is equal to the argument,\n* and removes that item from the list.\n*\n* @param string the item to remove\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the string is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the string is not found in the list</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void remove(String string)"
		},
		"public Point computeSize(int wHint, int hHint, boolean changed)":{
			"methodBody":"{\n    checkWidget();\n    int width = 0, height = 0;\n    if (wHint == SWT.DEFAULT) {\n        int newFont, oldFont = 0;\n        int hDC = OS.GetDC(handle);\n        newFont = OS.SendMessage(handle, OS.WM_GETFONT, 0, 0);\n        if (newFont != 0)\n            oldFont = OS.SelectObject(hDC, newFont);\n        int count = OS.SendMessage(handle, OS.CB_GETCOUNT, 0, 0);\n        RECT rect = new RECT();\n        int flags = OS.DT_CALCRECT | OS.DT_NOPREFIX;\n        if ((style & SWT.READ_ONLY) == 0)\n            flags |= OS.DT_EDITCONTROL;\n        int length = OS.GetWindowTextLength(handle);\n        int cp = getCodePage();\n        TCHAR buffer = new TCHAR(cp, length + 1);\n        OS.GetWindowText(handle, buffer, length + 1);\n        OS.DrawText(hDC, buffer, length, rect, flags);\n        width = Math.max(width, rect.right - rect.left);\n        for (int i = 0; i < count; i++) {\n            length = OS.SendMessage(handle, OS.CB_GETLBTEXTLEN, i, 0);\n            if (length != OS.CB_ERR) {\n                if (length + 1 > buffer.length())\n                    buffer = new TCHAR(cp, length + 1);\n                int result = OS.SendMessage(handle, OS.CB_GETLBTEXT, i, buffer);\n                if (result != OS.CB_ERR) {\n                    OS.DrawText(hDC, buffer, length, rect, flags);\n                    width = Math.max(width, rect.right - rect.left);\n                }\n            }\n        }\n        if (newFont != 0)\n            OS.SelectObject(hDC, oldFont);\n        OS.ReleaseDC(handle, hDC);\n    }\n    if (hHint == SWT.DEFAULT) {\n        if ((style & SWT.SIMPLE) != 0) {\n            int count = OS.SendMessage(handle, OS.CB_GETCOUNT, 0, 0);\n            int itemHeight = OS.SendMessage(handle, OS.CB_GETITEMHEIGHT, 0, 0);\n            height = count * itemHeight;\n        }\n    }\n    if (width == 0)\n        width = DEFAULT_WIDTH;\n    if (height == 0)\n        height = DEFAULT_HEIGHT;\n    if (wHint != SWT.DEFAULT)\n        width = wHint;\n    if (hHint != SWT.DEFAULT)\n        height = hHint;\n    if ((style & SWT.READ_ONLY) != 0) {\n        width += 8;\n    } else {\n        int hwndText = OS.GetDlgItem(handle, CBID_EDIT);\n        if (hwndText != 0) {\n            int margins = OS.SendMessage(hwndText, OS.EM_GETMARGINS, 0, 0);\n            int marginWidth = (margins & 0xFFFF) + ((margins >> 16) & 0xFFFF);\n            width += marginWidth + 3;\n        }\n    }\n    COMBOBOXINFO pcbi = new COMBOBOXINFO();\n    pcbi.cbSize = COMBOBOXINFO.sizeof;\n    if (((style & SWT.SIMPLE) == 0) && !OS.IsWinCE && OS.GetComboBoxInfo(handle, pcbi)) {\n        width += pcbi.itemLeft + (pcbi.buttonRight - pcbi.buttonLeft);\n        height = (pcbi.buttonBottom - pcbi.buttonTop) + pcbi.buttonTop * 2;\n    } else {\n        int border = OS.GetSystemMetrics(OS.SM_CXEDGE);\n        width += OS.GetSystemMetrics(OS.SM_CXVSCROLL) + border * 2;\n        int textHeight = OS.SendMessage(handle, OS.CB_GETITEMHEIGHT, -1, 0);\n        if ((style & SWT.DROP_DOWN) != 0) {\n            height = textHeight + 6;\n        } else {\n            height += textHeight + 10;\n        }\n    }\n    return new Point(width, height);\n}",
			"comments":"",
			"methodName":"public Point computeSize(int wHint, int hHint, boolean changed)"
		},
		"public int indexOf(String string, int start)":{
			"methodBody":"{\n    checkWidget();\n    if (string == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    \n    if (string.length() == 0) {\n        int count = getItemCount();\n        for (int i = start; i < count; i++) {\n            if (string.equals(getItem(i)))\n                return i;\n        }\n        return -1;\n    }\n    \n    int count = OS.SendMessage(handle, OS.CB_GETCOUNT, 0, 0);\n    if (!(0 <= start && start < count))\n        return -1;\n    int index = start - 1, last = 0;\n    TCHAR buffer = new TCHAR(getCodePage(), string, true);\n    do {\n        index = OS.SendMessage(handle, OS.CB_FINDSTRINGEXACT, last = index, buffer);\n        if (index == OS.CB_ERR || index <= last)\n            return -1;\n    } while (!string.equals(getItem(index)));\n    return index;\n}",
			"comments":"/**\n* Searches the receiver's list starting at the given,\n* zero-relative index until an item is found that is equal\n* to the argument, and returns the index of that item. If\n* no item is found or the starting index is out of range,\n* returns -1.\n*\n* @param string the search item\n* @param start the zero-relative index at which to begin the search\n* @return the index of the item\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the string is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* Bug in Windows.  For some reason, CB_FINDSTRINGEXACT\n* will not find empty strings even though it is legal\n* to insert an empty string into a combo.  The fix is\n* to search the combo, an item at a time.\n*/\n/* Use CB_FINDSTRINGEXACT to search for the item */\n",
			"methodName":"public int indexOf(String string, int start)"
		},
		"public void paste()":{
			"methodBody":"{\n    checkWidget();\n    if ((style & SWT.READ_ONLY) != 0)\n        return;\n    OS.SendMessage(handle, OS.WM_PASTE, 0, 0);\n}",
			"comments":"/**\n* Pastes text from clipboard.\n* <p>\n* The selected text is deleted from the widget\n* and new text inserted from the clipboard.\n* </p>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 2.1\n*/\n",
			"methodName":"public void paste()"
		},
		"public void setSelection(Point selection)":{
			"methodBody":"{\n    checkWidget();\n    if (selection == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    int start = selection.x, end = selection.y;\n    if (!OS.IsUnicode && OS.IsDBLocale) {\n        start = wcsToMbcsPos(start);\n        end = wcsToMbcsPos(end);\n    }\n    int bits = start | (end << 16);\n    OS.SendMessage(handle, OS.CB_SETEDITSEL, 0, bits);\n}",
			"comments":"/**\n* Sets the selection in the receiver's text field to the\n* range specified by the argument whose x coordinate is the\n* start of the selection and whose y coordinate is the end\n* of the selection.\n*\n* @param selection a point representing the new selection start and end\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the point is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setSelection(Point selection)"
		},
		"LRESULT wmChar(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    if (ignoreCharacter)\n        return null;\n    LRESULT result = super.wmChar(hwnd, wParam, lParam);\n    if (result != null)\n        return result;\n    \n    switch(wParam) {\n        case SWT.TAB:\n            return LRESULT.ZERO;\n        case SWT.CR:\n            postEvent(SWT.DefaultSelection);\n        \n        case SWT.ESC:\n            if ((style & SWT.DROP_DOWN) != 0) {\n                if (OS.SendMessage(handle, OS.CB_GETDROPPEDSTATE, 0, 0) == 0) {\n                    return LRESULT.ZERO;\n                }\n            }\n    }\n    return result;\n}",
			"comments":"/*\n* Feature in Windows.  For some reason, when the\n* widget is a single line text widget, when the\n* user presses tab, return or escape, Windows beeps.\n* The fix is to look for these keys and not call\n* the window proc.\n*\n* NOTE: This only happens when the drop down list\n* is not visible.\n*/\n// FALL THROUGH\n",
			"methodName":"LRESULT wmChar(int hwnd, int wParam, int lParam)"
		},
		"void register()":{
			"methodBody":"{\n    super.register();\n    int hwndText = OS.GetDlgItem(handle, CBID_EDIT);\n    if (hwndText != 0)\n        display.addControl(hwndText, this);\n    int hwndList = OS.GetDlgItem(handle, CBID_LIST);\n    if (hwndList != 0)\n        display.addControl(hwndList, this);\n}",
			"comments":"",
			"methodName":"void register()"
		},
		"TCHAR windowClass()":{
			"methodBody":"{\n    return ComboClass;\n}",
			"comments":"",
			"methodName":"TCHAR windowClass()"
		},
		"public void cut()":{
			"methodBody":"{\n    checkWidget();\n    if ((style & SWT.READ_ONLY) != 0)\n        return;\n    OS.SendMessage(handle, OS.WM_CUT, 0, 0);\n}",
			"comments":"/**\n* Cuts the selected text.\n* <p>\n* The current selection is first copied to the\n* clipboard and then deleted from the widget.\n* </p>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 2.1\n*/\n",
			"methodName":"public void cut()"
		},
		"public void setItem(int index, String string)":{
			"methodBody":"{\n    checkWidget();\n    if (string == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    remove(index);\n    \n    if (isDisposed())\n        return;\n    add(string, index);\n}",
			"comments":"/**\n* Sets the text of the item in the receiver's list at the given\n* zero-relative index to the string argument. This is equivalent\n* to removing the old item at the index, and then adding the new\n* item at that index.\n*\n* @param index the index for the item\n* @param string the new text for the item\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_RANGE - if the index is not between 0 and the number of elements in the list minus 1 (inclusive)</li>\n*    <li>ERROR_NULL_ARGUMENT - if the string is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* It is possible (but unlikely), that application\n* code could have disposed the widget in the modify\n* event that might be sent when the index is removed.\n* If this happens, just exit.\n*/\n",
			"methodName":"public void setItem(int index, String string)"
		},
		"public void deselect(int index)":{
			"methodBody":"{\n    checkWidget();\n    int selection = OS.SendMessage(handle, OS.CB_GETCURSEL, 0, 0);\n    if (index != selection)\n        return;\n    OS.SendMessage(handle, OS.CB_SETCURSEL, -1, 0);\n    sendEvent(SWT.Modify);\n\n}",
			"comments":"/**\n* Deselects the item at the given zero-relative index in the receiver's\n* list.  If the item at the index was already deselected, it remains\n* deselected. Indices that are out of range are ignored.\n*\n* @param index the index of the item to deselect\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n// widget could be disposed at this point\n",
			"methodName":"public void deselect(int index)"
		},
		"public void addModifyListener(ModifyListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.Modify, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when the receiver's text is modified, by sending\n* it one of the messages defined in the <code>ModifyListener</code>\n* interface.\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see ModifyListener\n* @see #removeModifyListener\n*/\n",
			"methodName":"public void addModifyListener(ModifyListener listener)"
		},
		"LRESULT WM_KILLFOCUS(int wParam, int lParam)":{
			"methodBody":"{\n    \n    if ((style & SWT.READ_ONLY) != 0) {\n        return super.WM_KILLFOCUS(wParam, lParam);\n    }\n    \n    return null;\n}",
			"comments":"/*\n* Bug in Windows.  When a combo box that is read only\n* is disposed in CBN_KILLFOCUS, Windows segment faults.\n* The fix is to send focus from WM_KILLFOCUS instead\n* of CBN_KILLFOCUS.\n*\n* NOTE: In version 6 of COMCTL32.DLL, the bug is fixed.\n*/\n/*\n* Return NULL - Focus notification is\n* done in WM_COMMAND by CBN_KILLFOCUS.\n*/\n",
			"methodName":"LRESULT WM_KILLFOCUS(int wParam, int lParam)"
		},
		"boolean sendKeyEvent(int type, int msg, int wParam, int lParam, Event event)":{
			"methodBody":"{\n    if (!super.sendKeyEvent(type, msg, wParam, lParam, event)) {\n        return false;\n    }\n    if ((style & SWT.READ_ONLY) != 0)\n        return true;\n    if (type != SWT.KeyDown)\n        return true;\n    if (msg != OS.WM_CHAR && msg != OS.WM_KEYDOWN && msg != OS.WM_IME_CHAR) {\n        return true;\n    }\n    if (event.character == 0)\n        return true;\n    if (!hooks(SWT.Verify) && !filters(SWT.Verify))\n        return true;\n    char key = event.character;\n    int stateMask = event.stateMask;\n    \n    switch(msg) {\n        case OS.WM_CHAR:\n            if (key != 0x08 && key != 0x7F && key != '\\r' && key != '\\t' && key != '\\n')\n                break;\n        \n        case OS.WM_KEYDOWN:\n            if ((stateMask & (SWT.ALT | SWT.SHIFT | SWT.CONTROL)) != 0)\n                return false;\n            break;\n    }\n    \n    if (OS.GetKeyState(OS.VK_LBUTTON) < 0) {\n        return true;\n    }\n    \n    String oldText = \"\";\n    int[] start = new int[1], end = new int[1];\n    int hwndText = OS.GetDlgItem(handle, CBID_EDIT);\n    if (hwndText == 0)\n        return true;\n    OS.SendMessage(hwndText, OS.EM_GETSEL, start, end);\n    switch(key) {\n        case 0x08:\n            \n            if (start[0] == end[0]) {\n                if (start[0] == 0)\n                    return true;\n                start[0] = start[0] - 1;\n                if (!OS.IsUnicode && OS.IsDBLocale) {\n                    int[] newStart = new int[1], newEnd = new int[1];\n                    OS.SendMessage(hwndText, OS.EM_SETSEL, start[0], end[0]);\n                    OS.SendMessage(hwndText, OS.EM_GETSEL, newStart, newEnd);\n                    if (start[0] != newStart[0])\n                        start[0] = start[0] - 1;\n                }\n                start[0] = Math.max(start[0], 0);\n            }\n            break;\n        case 0x7F:\n            \n            if (start[0] == end[0]) {\n                int length = OS.GetWindowTextLength(hwndText);\n                if (start[0] == length)\n                    return true;\n                end[0] = end[0] + 1;\n                if (!OS.IsUnicode && OS.IsDBLocale) {\n                    int[] newStart = new int[1], newEnd = new int[1];\n                    OS.SendMessage(hwndText, OS.EM_SETSEL, start[0], end[0]);\n                    OS.SendMessage(hwndText, OS.EM_GETSEL, newStart, newEnd);\n                    if (end[0] != newEnd[0])\n                        end[0] = end[0] + 1;\n                }\n                end[0] = Math.min(end[0], length);\n            }\n            break;\n        case '\\r':\n            \n            return true;\n        default:\n            \n            if (key != '\\t' && key < 0x20)\n                return true;\n            oldText = new String(new char[] { key });\n            break;\n    }\n    String newText = verifyText(oldText, start[0], end[0], event);\n    if (newText == null)\n        return false;\n    if (newText == oldText)\n        return true;\n    TCHAR buffer = new TCHAR(getCodePage(), newText, true);\n    OS.SendMessage(hwndText, OS.EM_SETSEL, start[0], end[0]);\n    OS.SendMessage(hwndText, OS.EM_REPLACESEL, 0, buffer);\n    return false;\n}",
			"comments":"/*\n* Disable all magic keys that could modify the text\n* and don't send events when Alt, Shift or Ctrl is\n* pressed.\n*/\n// FALL THROUGH\n/*\n* If the left button is down, the text widget refuses the character.\n*/\n/* Verify the character */\n/* Bs */\n/* Del */\n/* Return */\n/* Tab and other characters */\n",
			"methodName":"boolean sendKeyEvent(int type, int msg, int wParam, int lParam, Event event)"
		},
		"public int getSelectionIndex()":{
			"methodBody":"{\n    checkWidget();\n    if (noSelection)\n        return -1;\n    return OS.SendMessage(handle, OS.CB_GETCURSEL, 0, 0);\n}",
			"comments":"/**\n* Returns the zero-relative index of the item which is currently\n* selected in the receiver's list, or -1 if no item is selected.\n*\n* @return the index of the selected item\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getSelectionIndex()"
		},
		"int callWindowProc(int hwnd, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    if (handle == 0)\n        return 0;\n    if (hwnd == handle) {\n        return OS.CallWindowProc(ComboProc, hwnd, msg, wParam, lParam);\n    }\n    int hwndText = OS.GetDlgItem(handle, CBID_EDIT);\n    if (hwnd == hwndText) {\n        return OS.CallWindowProc(EditProc, hwnd, msg, wParam, lParam);\n    }\n    int hwndList = OS.GetDlgItem(handle, CBID_LIST);\n    if (hwnd == hwndList) {\n        return OS.CallWindowProc(ListProc, hwnd, msg, wParam, lParam);\n    }\n    return OS.DefWindowProc(hwnd, msg, wParam, lParam);\n}",
			"comments":"",
			"methodName":"int callWindowProc(int hwnd, int msg, int wParam, int lParam)"
		},
		"void setForegroundPixel(int pixel)":{
			"methodBody":"{\n    if (foreground == pixel)\n        return;\n    super.setForegroundPixel(pixel);\n    int hwndText = OS.GetDlgItem(handle, CBID_EDIT);\n    if (hwndText != 0)\n        OS.InvalidateRect(hwndText, null, true);\n    int hwndList = OS.GetDlgItem(handle, CBID_LIST);\n    if (hwndList != 0)\n        OS.InvalidateRect(hwndList, null, true);\n}",
			"comments":"",
			"methodName":"void setForegroundPixel(int pixel)"
		},
		"public void clearSelection()":{
			"methodBody":"{\n    checkWidget();\n    OS.SendMessage(handle, OS.CB_SETEDITSEL, 0, -1);\n}",
			"comments":"/**\n* Sets the selection in the receiver's text field to an empty\n* selection starting just before the first character. If the\n* text field is editable, this has the effect of placing the\n* i-beam at the start of the text.\n* <p>\n* Note: To clear the selected items in the receiver's list,\n* use <code>deselectAll()</code>.\n* </p>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #deselectAll\n*/\n",
			"methodName":"public void clearSelection()"
		},
		"public Point getSelection()":{
			"methodBody":"{\n    checkWidget();\n    if ((style & SWT.DROP_DOWN) != 0 && (style & SWT.READ_ONLY) != 0) {\n        return new Point(0, OS.GetWindowTextLength(handle));\n    }\n    int[] start = new int[1], end = new int[1];\n    OS.SendMessage(handle, OS.CB_GETEDITSEL, start, end);\n    if (!OS.IsUnicode && OS.IsDBLocale) {\n        start[0] = mbcsToWcsPos(start[0]);\n        end[0] = mbcsToWcsPos(end[0]);\n    }\n    return new Point(start[0], end[0]);\n}",
			"comments":"/**\n* Returns a <code>Point</code> whose x coordinate is the\n* character position representing the start of the selection\n* in the receiver's text field, and whose y coordinate is the\n* character position representing the end of the selection.\n* An \"empty\" selection is indicated by the x and y coordinates\n* having the same value.\n* <p>\n* Indexing is zero based.  The range of a selection is from\n* 0..N where N is the number of characters in the widget.\n* </p>\n*\n* @return a point representing the selection start and end\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Point getSelection()"
		},
		"boolean traverseEscape()":{
			"methodBody":"{\n    if ((style & SWT.DROP_DOWN) != 0) {\n        if (OS.SendMessage(handle, OS.CB_GETDROPPEDSTATE, 0, 0) != 0) {\n            OS.SendMessage(handle, OS.CB_SHOWDROPDOWN, 0, 0);\n            return true;\n        }\n    }\n    return super.traverseEscape();\n}",
			"comments":"",
			"methodName":"boolean traverseEscape()"
		},
		"LRESULT wmClipboard(int hwndText, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    if ((style & SWT.READ_ONLY) != 0)\n        return null;\n    if (!hooks(SWT.Verify) && !filters(SWT.Verify))\n        return null;\n    boolean call = false;\n    int[] start = new int[1], end = new int[1];\n    String oldText = null, newText = null;\n    switch(msg) {\n        case OS.WM_CLEAR:\n        case OS.WM_CUT:\n            OS.SendMessage(hwndText, OS.EM_GETSEL, start, end);\n            if (start[0] != end[0]) {\n                newText = \"\";\n                call = true;\n            }\n            break;\n        case OS.WM_PASTE:\n            OS.SendMessage(hwndText, OS.EM_GETSEL, start, end);\n            newText = getClipboardText();\n            break;\n        case OS.EM_UNDO:\n        case OS.WM_UNDO:\n            if (OS.SendMessage(hwndText, OS.EM_CANUNDO, 0, 0) != 0) {\n                ignoreModify = true;\n                OS.SendMessage(hwndText, OS.EM_GETSEL, start, end);\n                OS.CallWindowProc(EditProc, hwndText, msg, wParam, lParam);\n                int length = OS.GetWindowTextLength(hwndText);\n                if (length != 0 && start[0] != end[0]) {\n                    TCHAR buffer = new TCHAR(getCodePage(), length + 1);\n                    OS.GetWindowText(hwndText, buffer, length + 1);\n                    newText = buffer.toString(start[0], end[0] - start[0]);\n                } else {\n                    newText = \"\";\n                }\n                OS.CallWindowProc(EditProc, hwndText, msg, wParam, lParam);\n                ignoreModify = false;\n            }\n            break;\n        case OS.WM_SETTEXT:\n            end[0] = OS.GetWindowTextLength(hwndText);\n            oldText = getText();\n            int length = OS.IsUnicode ? OS.wcslen(lParam) : OS.strlen(lParam);\n            TCHAR buffer = new TCHAR(getCodePage(), length);\n            int byteCount = buffer.length() * TCHAR.sizeof;\n            OS.MoveMemory(buffer, lParam, byteCount);\n            newText = buffer.toString(0, length);\n            break;\n    }\n    if (newText != null && !newText.equals(oldText)) {\n        oldText = newText;\n        newText = verifyText(newText, start[0], end[0], null);\n        if (newText == null)\n            return LRESULT.ZERO;\n        if (!newText.equals(oldText)) {\n            if (call) {\n                OS.CallWindowProc(EditProc, hwndText, msg, wParam, lParam);\n            }\n            TCHAR buffer = new TCHAR(getCodePage(), newText, true);\n            if (msg == OS.WM_SETTEXT) {\n                int hHeap = OS.GetProcessHeap();\n                int byteCount = buffer.length() * TCHAR.sizeof;\n                int pszText = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, byteCount);\n                OS.MoveMemory(pszText, buffer, byteCount);\n                int code = OS.CallWindowProc(EditProc, hwndText, msg, wParam, pszText);\n                OS.HeapFree(hHeap, 0, pszText);\n                return new LRESULT(code);\n            } else {\n                OS.SendMessage(hwndText, OS.EM_REPLACESEL, 0, buffer);\n                return LRESULT.ZERO;\n            }\n        }\n    }\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT wmClipboard(int hwndText, int msg, int wParam, int lParam)"
		},
		"LRESULT wmIMEChar(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    \n    Display display = this.display;\n    display.lastKey = 0;\n    display.lastAscii = wParam;\n    display.lastVirtual = display.lastNull = display.lastDead = false;\n    if (!sendKeyEvent(SWT.KeyDown, OS.WM_IME_CHAR, wParam, lParam)) {\n        return LRESULT.ZERO;\n    }\n    \n    ignoreCharacter = true;\n    int result = callWindowProc(hwnd, OS.WM_IME_CHAR, wParam, lParam);\n    MSG msg = new MSG();\n    int flags = OS.PM_REMOVE | OS.PM_NOYIELD | OS.PM_QS_INPUT | OS.PM_QS_POSTMESSAGE;\n    while (OS.PeekMessage(msg, hwnd, OS.WM_CHAR, OS.WM_CHAR, flags)) {\n        OS.TranslateMessage(msg);\n        OS.DispatchMessage(msg);\n    }\n    ignoreCharacter = false;\n    sendKeyEvent(SWT.KeyUp, OS.WM_IME_CHAR, wParam, lParam);\n    \n    display.lastKey = display.lastAscii = 0;\n    return new LRESULT(result);\n}",
			"comments":"/* Process a DBCS character */\n/*\n* Feature in Windows.  The Windows text widget uses\n* two 2 WM_CHAR's to process a DBCS key instead of\n* using WM_IME_CHAR.  The fix is to allow the text\n* widget to get the WM_CHAR's but ignore sending\n* them to the application.\n*/\n// widget could be disposed at this point\n",
			"methodName":"LRESULT wmIMEChar(int hwnd, int wParam, int lParam)"
		}
	},
	"ClassORInterfaceName":[
		"Combo"
	]
}
