{
	"variables":[
		"device",
		"regularFont",
		"boldFont",
		"italicFont",
		"boldItalicFont",
		"tabWidth",
		"ascent",
		"descent",
		"lineEndSpaceWidth",
		"gc",
		"originalFont",
		"metrics",
		"lineOffset",
		"lineLength",
		"selection",
		"selectionStart",
		"selectionEnd",
		"leftMargin",
		"lineBackground",
		"layout",
		"client",
		"event",
		"paintX",
		"rect",
		"start",
		"end",
		"fontDatas",
		"i",
		"lineLength",
		"lineEnd",
		"oldStyleCount",
		"newStyleCount",
		"i",
		"style",
		"newStyles",
		"i",
		"j",
		"style",
		"gc",
		"tabBuffer",
		"i",
		"layout",
		"length",
		"event",
		"styles",
		"lastOffset",
		"styleIndex",
		"style",
		"start",
		"end",
		"textStyle",
		"device",
		"regularFont",
		"lineEndSpaceWidth",
		"gc",
		"gc",
		"gc",
		"ascent",
		"Math",
		"ascent",
		"metrics",
		"metrics",
		"descent",
		"Math",
		"descent",
		"metrics",
		"gc",
		"SWT",
		"metrics",
		"gc",
		"ascent",
		"Math",
		"ascent",
		"metrics",
		"metrics",
		"descent",
		"Math",
		"descent",
		"metrics",
		"gc",
		"SWT",
		"metrics",
		"gc",
		"ascent",
		"Math",
		"ascent",
		"metrics",
		"metrics",
		"descent",
		"Math",
		"descent",
		"metrics",
		"gc",
		"SWT",
		"SWT",
		"metrics",
		"gc",
		"ascent",
		"Math",
		"ascent",
		"metrics",
		"metrics",
		"descent",
		"Math",
		"descent",
		"metrics",
		"gc",
		"originalFont",
		"gc",
		"boldFont",
		"boldFont",
		"italicFont",
		"italicFont",
		"boldItalicFont",
		"boldItalicFont",
		"boldFont",
		"italicFont",
		"boldItalicFont",
		"boldFont",
		"boldFont",
		"italicFont",
		"italicFont",
		"boldItalicFont",
		"boldItalicFont",
		"boldFont",
		"italicFont",
		"boldItalicFont",
		"lineIndex",
		"line",
		"selection",
		"selection",
		"line",
		"lineOffset",
		"lineOffset",
		"line",
		"event",
		"lineBackground",
		"event",
		"lineBackground",
		"lineBackground",
		"widgetBackground",
		"clearBackground",
		"selectionStart",
		"lineOffset",
		"selectionEnd",
		"lineOffset",
		"lineLength",
		"gc",
		"lineBackground",
		"gc",
		"lineBackground",
		"gc",
		"client",
		"leftMargin",
		"paintY",
		"client",
		"ascent",
		"descent",
		"client",
		"leftMargin",
		"selectionStart",
		"selectionEnd",
		"layout",
		"line",
		"lineOffset",
		"paintX",
		"rect",
		"rect",
		"paintY",
		"gc",
		"gc",
		"widgetForeground",
		"gc",
		"lineBackground",
		"selectionStart",
		"selectionEnd",
		"selectionEnd",
		"lineOffset",
		"selectionStart",
		"lineOffset",
		"lineLength",
		"layout",
		"gc",
		"paintX",
		"paintY",
		"Math",
		"selectionStart",
		"lineOffset",
		"Math",
		"lineLength",
		"selectionEnd",
		"lineOffset",
		"layout",
		"gc",
		"paintX",
		"paintY",
		"start",
		"end",
		"layout",
		"device",
		"ascent",
		"style",
		"SWT",
		"boldFont",
		"boldFont",
		"boldFont",
		"device",
		"style",
		"SWT",
		"italicFont",
		"italicFont",
		"italicFont",
		"device",
		"style",
		"SWT",
		"SWT",
		"boldItalicFont",
		"boldItalicFont",
		"boldItalicFont",
		"device",
		"style",
		"regularFont",
		"regularFont",
		"i",
		"fontDatas",
		"i",
		"fontDatas",
		"i",
		"style",
		"fontDatas",
		"lineEndSpaceWidth",
		"ascent",
		"descent",
		"line",
		"event",
		"event",
		"event",
		"lineOffset",
		"lineLength",
		"event",
		"event",
		"event",
		"lineOffset",
		"lineLength",
		"logicalStyles",
		"i",
		"oldStyleCount",
		"i",
		"logicalStyles",
		"i",
		"style",
		"lineEnd",
		"style",
		"style",
		"lineOffset",
		"newStyleCount",
		"newStyleCount",
		"oldStyleCount",
		"newStyleCount",
		"i",
		"oldStyleCount",
		"i",
		"logicalStyles",
		"i",
		"style",
		"lineEnd",
		"style",
		"style",
		"lineOffset",
		"newStyles",
		"j",
		"logicalStyles",
		"i",
		"logicalStyles",
		"newStyles",
		"logicalStyles",
		"tabLength",
		"i",
		"tabLength",
		"i",
		"tabBuffer",
		"tabWidth",
		"gc",
		"tabBuffer",
		"gc",
		"lineOffset",
		"layout",
		"regularFont",
		"layout",
		"ascent",
		"layout",
		"descent",
		"layout",
		"line",
		"layout",
		"layout",
		"lineOffset",
		"line",
		"layout",
		"tabWidth",
		"line",
		"lineOffset",
		"line",
		"event",
		"event",
		"styles",
		"styleIndex",
		"styles",
		"styleIndex",
		"styles",
		"styleIndex",
		"style",
		"lineOffset",
		"style",
		"start",
		"end",
		"Math",
		"length",
		"style",
		"lineOffset",
		"style",
		"start",
		"style",
		"lineOffset",
		"end",
		"Math",
		"length",
		"start",
		"style",
		"start",
		"length",
		"lastOffset",
		"start",
		"layout",
		"lastOffset",
		"start",
		"style",
		"style",
		"style",
		"textStyle",
		"style",
		"textStyle",
		"style",
		"layout",
		"textStyle",
		"start",
		"end",
		"lastOffset",
		"Math",
		"lastOffset",
		"end",
		"lastOffset",
		"length",
		"layout",
		"lastOffset",
		"length",
		"layout",
		"device",
		"layout",
		"device",
		"regularFont",
		"x",
		"BOLD",
		"ITALIC",
		"BOLD",
		"ITALIC",
		"x",
		"y",
		"lineBackground",
		"x",
		"width",
		"x",
		"x",
		"width",
		"BOLD",
		"ITALIC",
		"BOLD",
		"ITALIC",
		"length",
		"styles",
		"styles",
		"styles",
		"styles",
		"styles",
		"length",
		"start",
		"start",
		"length",
		"start",
		"start",
		"length",
		"x",
		"styles",
		"length",
		"start",
		"length",
		"start",
		"start",
		"length",
		"fontStyle",
		"foreground",
		"background",
		"underline",
		"underline",
		"strikeout",
		"strikeout",
		"device",
		"regularFont",
		"gc",
		"line",
		"lineIndex",
		"paintY",
		"gc",
		"widgetBackground",
		"widgetForeground",
		"clearBackground",
		"line",
		"lineOffset",
		"paintX",
		"paintY",
		"gc",
		"lineOffset",
		"lineText",
		"style",
		"style",
		"lineOffset",
		"line",
		"event",
		"lineOffset",
		"line",
		"lineOffset",
		"line",
		"logicalStyles",
		"lineOffset",
		"lineLength",
		"tabLength",
		"line",
		"lineOffset",
		"lineOffset",
		"layout"
	],
	"extendORImplementFiles":[],
	"package":[
		"org.eclipse.swt.custom"
	],
	"import":[
		"org.eclipse.swt.SWT",
		"org.eclipse.swt.graphics"
	],
	"methods":[
		"calculateLineHeight",
		"dispose",
		"disposeGC",
		"drawLine",
		"drawLineBreakSelection",
		"getClientArea",
		"getContent",
		"getDevice",
		"getBaseline",
		"getBidiSegments",
		"getFont",
		"getFontData",
		"getGC",
		"getHorizontalPixel",
		"getLeftMargin",
		"getLineEndSpaceWidth",
		"getLineBackgroundData",
		"getLineHeight",
		"getLineStyleData",
		"getLineStyleData",
		"getOrientation",
		"getRightMargin",
		"getSelectionForeground",
		"getSelectionBackground",
		"getSelection",
		"getVisualLineStyleData",
		"getWordWrap",
		"isFullLineSelection",
		"setTabLength",
		"getTextLayout",
		"createTextLayout",
		"disposeTextLayout",
		"getGC",
		"stringExtent",
		"getFont",
		"getFontMetrics",
		"max",
		"getAscent",
		"getLeading",
		"max",
		"getDescent",
		"setFont",
		"getFont",
		"getFontMetrics",
		"max",
		"getAscent",
		"getLeading",
		"max",
		"getDescent",
		"setFont",
		"getFont",
		"getFontMetrics",
		"max",
		"getAscent",
		"getLeading",
		"max",
		"getDescent",
		"setFont",
		"getFont",
		"getFontMetrics",
		"max",
		"getAscent",
		"getLeading",
		"max",
		"getDescent",
		"setFont",
		"disposeGC",
		"dispose",
		"dispose",
		"dispose",
		"dispose",
		"dispose",
		"dispose",
		"getOffsetAtLine",
		"getContent",
		"length",
		"getSelection",
		"getLeftMargin",
		"getTextLayout",
		"getClientArea",
		"getLineBackgroundData",
		"isFullLineSelection",
		"setBackground",
		"setForeground",
		"fillRectangle",
		"getHorizontalPixel",
		"getLineBounds",
		"drawLineBreakSelection",
		"setForeground",
		"setBackground",
		"draw",
		"max",
		"min",
		"draw",
		"getSelectionForeground",
		"getSelectionBackground",
		"disposeTextLayout",
		"getFontData",
		"getFontData",
		"getFontData",
		"getFontData",
		"setStyle",
		"length",
		"getWordWrap",
		"getVisualLineStyleData",
		"getGC",
		"append",
		"stringExtent",
		"toString",
		"disposeGC",
		"createTextLayout",
		"setFont",
		"setAscent",
		"setDescent",
		"setText",
		"setOrientation",
		"getOrientation",
		"setSegments",
		"getBidiSegments",
		"setTabs",
		"length",
		"getLineStyleData",
		"isUnstyled",
		"min",
		"min",
		"setStyle",
		"getFont",
		"setStyle",
		"max",
		"setStyle",
		"dispose",
		"Font",
		"Font",
		"Font",
		"StringBuffer",
		"TextStyle",
		"TextLayout"
	],
	"methodsBody":{
		"protected abstract boolean isFullLineSelection()":{
			"methodBody":"",
			"comments":"/**\n* Returns whether the widget was created with the SWT.FULL_SELECTION style.\n* Implemented by subclasses for optional selection rendering.\n* </p>\n* @return true=the widget is running in full line selection mode,\n* \tfalse=otherwise\n*/\n",
			"methodName":"protected abstract boolean isFullLineSelection()"
		},
		"StyledTextEvent getLineStyleData(StyledTextEvent event, int lineOffset, String line)":{
			"methodBody":"{\n    int lineLength = line.length();\n    if (event.styles != null && getWordWrap()) {\n        event.styles = getVisualLineStyleData(event.styles, lineOffset, lineLength);\n    }\n    if (event.styles == null) {\n        event.styles = new StyleRange[0];\n    }\n    return event;\n}",
			"comments":"/**\n* Returns the line style data for the specified line.\n* The lineOffset and line may specify a segment of a logical line stored\n* in the <class>StyledTextContent</class> of the widget.\n* The returned styles are guaranteed to be at least partially on the\n* segment.\n* </p>\n* @param event the styles for the logical line\n* @param lineOffset offset of the line start relative to the start of\n* \tthe content.\n* @param line line to get line styles for\n* @return line style data for the given line segment. Styles may start\n* \tbefore line start and end after line end but are guaranteed to be at\n* \tleast partially on the line.\n*/\n",
			"methodName":"StyledTextEvent getLineStyleData(StyledTextEvent event, int lineOffset, String line)"
		},
		"Device getDevice()":{
			"methodBody":"{\n    return device;\n}",
			"comments":"/**\n* Returns the Device that is being rendered on.\n* </p>\n* @return the Device that is being rendered on.\n*/\n",
			"methodName":"Device getDevice()"
		},
		"int getBaseline()":{
			"methodBody":"{\n    return ascent;\n}",
			"comments":"",
			"methodName":"int getBaseline()"
		},
		"StyleRange[] getVisualLineStyleData(StyleRange[] logicalStyles, int lineOffset, int lineLength)":{
			"methodBody":"{\n    int lineEnd = lineOffset + lineLength;\n    int oldStyleCount = logicalStyles.length;\n    int newStyleCount = 0;\n    for (int i = 0; i < oldStyleCount; i++) {\n        StyleRange style = logicalStyles[i];\n        if (style.start < lineEnd && style.start + style.length > lineOffset) {\n            newStyleCount++;\n        }\n    }\n    if (newStyleCount != oldStyleCount) {\n        StyleRange[] newStyles = new StyleRange[newStyleCount];\n        for (int i = 0, j = 0; i < oldStyleCount; i++) {\n            StyleRange style = logicalStyles[i];\n            if (style.start < lineEnd && style.start + style.length > lineOffset) {\n                newStyles[j++] = logicalStyles[i];\n            }\n        }\n        logicalStyles = newStyles;\n    }\n    return logicalStyles;\n}",
			"comments":"/**\n* Returns styles for the specified visual (wrapped) line.\n* </p>\n*\n* @param logicalStyles the styles for a logical (unwrapped) line\n* @param lineOffset offset of the visual line\n* @param lineLength length of the visual line\n* @return styles in the logicalStyles array that are at least\n* \tpartially on the specified visual line.\n*/\n",
			"methodName":"StyleRange[] getVisualLineStyleData(StyleRange[] logicalStyles, int lineOffset, int lineLength)"
		},
		"protected abstract void disposeGC(GC gc)":{
			"methodBody":"",
			"comments":"/**\n* Dispose the specified GC.\n* Allows subclasses to reuse GCs.\n* </p>\n* @param gc GC to dispose.\n*/\n",
			"methodName":"protected abstract void disposeGC(GC gc)"
		},
		"void dispose()":{
			"methodBody":"{\n    if (boldFont != null)\n        boldFont.dispose();\n    if (italicFont != null)\n        italicFont.dispose();\n    if (boldItalicFont != null)\n        boldItalicFont.dispose();\n    boldFont = italicFont = boldItalicFont = null;\n}",
			"comments":"/**\n* Disposes the resource created by the receiver.\n*/\n",
			"methodName":"void dispose()"
		},
		"protected abstract Color getSelectionForeground()":{
			"methodBody":"",
			"comments":"/**\n*\n*/\n",
			"methodName":"protected abstract Color getSelectionForeground()"
		},
		"void disposeTextLayout(TextLayout layout)":{
			"methodBody":"{\n    layout.dispose();\n}",
			"comments":"",
			"methodName":"void disposeTextLayout(TextLayout layout)"
		},
		"protected abstract StyledTextContent getContent()":{
			"methodBody":"",
			"comments":"/**\n* Returns the <class>StyledTextContent</class> to use for line offset\n* calculations.\n* </p>\n* @return the <class>StyledTextContent</class> to use for line offset\n* calculations.\n*/\n",
			"methodName":"protected abstract StyledTextContent getContent()"
		},
		"TextLayout getTextLayout(String line, int lineOffset)":{
			"methodBody":"{\n    TextLayout layout = createTextLayout(lineOffset);\n    layout.setFont(regularFont);\n    layout.setAscent(ascent);\n    layout.setDescent(descent);\n    layout.setText(line);\n    layout.setOrientation(getOrientation());\n    layout.setSegments(getBidiSegments(lineOffset, line));\n    layout.setTabs(new int[] { tabWidth });\n    int length = line.length();\n    StyledTextEvent event = getLineStyleData(lineOffset, line);\n    StyleRange[] styles = event != null ? event.styles : null;\n    int lastOffset = 0;\n    if (styles != null) {\n        for (int styleIndex = 0; styleIndex < styles.length; styleIndex++) {\n            StyleRange style = styles[styleIndex];\n            if (style.isUnstyled())\n                continue;\n            int start, end;\n            if (lineOffset > style.start) {\n                start = 0;\n                end = Math.min(length, style.length - lineOffset + style.start);\n            } else {\n                start = style.start - lineOffset;\n                end = Math.min(length, start + style.length);\n            }\n            if (start >= length)\n                break;\n            if (lastOffset < start) {\n                layout.setStyle(null, lastOffset, start - 1);\n            }\n            TextStyle textStyle = new TextStyle(getFont(style.fontStyle), style.foreground, style.background);\n            textStyle.underline = style.underline;\n            textStyle.strikeout = style.strikeout;\n            layout.setStyle(textStyle, start, end - 1);\n            lastOffset = Math.max(lastOffset, end);\n        }\n    }\n    if (lastOffset < length)\n        layout.setStyle(null, lastOffset, length);\n    return layout;\n}",
			"comments":"/**\n*  Returns TextLayout given a line index and an array of styles\n*/\n",
			"methodName":"TextLayout getTextLayout(String line, int lineOffset)"
		},
		"protected abstract int[] getBidiSegments(int lineOffset, String lineText)":{
			"methodBody":"",
			"comments":"/**\n* Returns the text segments that should be treated as if they\n* had a different direction than the surrounding text.\n* </p>\n*\n* @param lineOffset offset of the first character in the line.\n* \t0 based from the beginning of the document.\n* @param line text of the line to specify bidi segments for\n* @return text segments that should be treated as if they had a\n* \tdifferent direction than the surrounding text. Only the start\n* \tindex of a segment is specified, relative to the start of the\n* \tline. Always starts with 0 and ends with the line length.\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the segment indices returned\n* \t\tby the listener do not start with 0, are not in ascending order,\n* \t\texceed the line length or have duplicates</li>\n* </ul>\n*/\n",
			"methodName":"protected abstract int[] getBidiSegments(int lineOffset, String lineText)"
		},
		"protected abstract int getHorizontalPixel()":{
			"methodBody":"",
			"comments":"/**\n* Returns the horizontal scroll position.\n* </p>\n* @return the horizontal scroll position.\n*/\n",
			"methodName":"protected abstract int getHorizontalPixel()"
		},
		"protected abstract boolean getWordWrap()":{
			"methodBody":"",
			"comments":"/**\n* Returns the word wrap state.\n* </p>\n* @return true=word wrap is on. false=no word wrap, lines may extend\n* \tbeyond the right side of the client area.\n*/\n",
			"methodName":"protected abstract boolean getWordWrap()"
		},
		"protected abstract StyledTextEvent getLineBackgroundData(int lineOffset, String line)":{
			"methodBody":"",
			"comments":"/**\n* Returns the line background data for the given line or null if\n* there is none.\n* </p>\n* @param lineOffset offset of the line start relative to the start\n* \tof the content.\n* @param line line to get line background data for\n* @return line background data for the given line. may return null\n*/\n",
			"methodName":"protected abstract StyledTextEvent getLineBackgroundData(int lineOffset, String line)"
		},
		"void drawLine(String line, int lineIndex, int paintY, GC gc, Color widgetBackground, Color widgetForeground, boolean clearBackground)":{
			"methodBody":"{\n    int lineOffset = getContent().getOffsetAtLine(lineIndex);\n    int lineLength = line.length();\n    Point selection = getSelection();\n    int selectionStart = selection.x;\n    int selectionEnd = selection.y;\n    int leftMargin = getLeftMargin();\n    Color lineBackground = null;\n    TextLayout layout = getTextLayout(line, lineOffset);\n    Rectangle client = getClientArea();\n    StyledTextEvent event = getLineBackgroundData(lineOffset, line);\n    if (event != null) {\n        lineBackground = event.lineBackground;\n    }\n    if (lineBackground == null) {\n        lineBackground = widgetBackground;\n    }\n    if (clearBackground && (isFullLineSelection() == false || selectionStart > lineOffset || selectionEnd <= lineOffset + lineLength)) {\n        \n        \n        gc.setBackground(lineBackground);\n        gc.setForeground(lineBackground);\n        gc.fillRectangle(client.x + leftMargin, paintY, client.width, ascent + descent);\n    }\n    int paintX = client.x + leftMargin - getHorizontalPixel();\n    if (selectionStart != selectionEnd) {\n        Rectangle rect = layout.getLineBounds(0);\n        drawLineBreakSelection(line, lineOffset, paintX + rect.x + rect.width, paintY, gc);\n    }\n    gc.setForeground(widgetForeground);\n    gc.setBackground(lineBackground);\n    if (selectionStart == selectionEnd || (selectionEnd <= lineOffset && selectionStart > lineOffset + lineLength - 1)) {\n        layout.draw(gc, paintX, paintY);\n    } else {\n        int start = Math.max(0, selectionStart - lineOffset);\n        int end = Math.min(lineLength, selectionEnd - lineOffset);\n        layout.draw(gc, paintX, paintY, start, end - 1, getSelectionForeground(), getSelectionBackground());\n    }\n    disposeTextLayout(layout);\n}",
			"comments":"/**\n* Draws a line of text at the specified location.\n* </p>\n*\n* @param line the line to draw\n* @param lineIndex\tindex of the line to draw\n* @param paintY y location to draw at\n* @param gc GC to draw on\n* @param widgetBackground the widget background color.\n* \tUsed as the default rendering color.\n* @param widgetForeground the widget foreground color.\n* \tUsed as the default rendering color.\n* @param clearBackground true if the line background should be drawn\n* explicitly.\n*/\n// draw background if full selection is off or if line is not\n// completely selected\n",
			"methodName":"void drawLine(String line, int lineIndex, int paintY, GC gc, Color widgetBackground, Color widgetForeground, boolean clearBackground)"
		},
		"void calculateLineHeight()":{
			"methodBody":"{\n    GC gc = getGC();\n    lineEndSpaceWidth = gc.stringExtent(\" \").x;\n    \n    \n    Font originalFont = gc.getFont();\n    FontMetrics metrics = gc.getFontMetrics();\n    ascent = Math.max(ascent, metrics.getAscent() + metrics.getLeading());\n    descent = Math.max(descent, metrics.getDescent());\n    gc.setFont(getFont(SWT.BOLD));\n    metrics = gc.getFontMetrics();\n    ascent = Math.max(ascent, metrics.getAscent() + metrics.getLeading());\n    descent = Math.max(descent, metrics.getDescent());\n    gc.setFont(getFont(SWT.ITALIC));\n    metrics = gc.getFontMetrics();\n    ascent = Math.max(ascent, metrics.getAscent() + metrics.getLeading());\n    descent = Math.max(descent, metrics.getDescent());\n    gc.setFont(getFont(SWT.BOLD | SWT.ITALIC));\n    metrics = gc.getFontMetrics();\n    ascent = Math.max(ascent, metrics.getAscent() + metrics.getLeading());\n    descent = Math.max(descent, metrics.getDescent());\n    gc.setFont(originalFont);\n    disposeGC(gc);\n    \n    if (boldFont != null)\n        boldFont.dispose();\n    if (italicFont != null)\n        italicFont.dispose();\n    if (boldItalicFont != null)\n        boldItalicFont.dispose();\n    boldFont = italicFont = boldItalicFont = null;\n}",
			"comments":"/**\n* Calculates the line height and space width.\n*/\n// don't assume that bold and normal fonts have the same height\n// fixes bug 41773\n// clear the font cache\n",
			"methodName":"void calculateLineHeight()"
		},
		"protected abstract void drawLineBreakSelection(String line, int lineOffset, int paintX, int paintY, GC gc)":{
			"methodBody":"",
			"comments":"/**\n* Draws the background of the line selection.\n* Implemented by subclasses for optional selection rendering.\n* </p>\n*\n* @param line the line to draw\n* @param lineOffset offset of the first character in the line.\n* \tRelative to the start of the document.\n* @param styles line styles\n* @param paintY y location to draw at\n* @param gc GC to draw on\n* @param bidi the bidi object to use for measuring and rendering \ttext in bidi\n* locales. null when not in bidi mode.\n*/\n",
			"methodName":"protected abstract void drawLineBreakSelection(String line, int lineOffset, int paintX, int paintY, GC gc)"
		},
		"protected abstract StyledTextEvent getLineStyleData(int lineOffset, String line)":{
			"methodBody":"",
			"comments":"/**\n* Returns the line style data for the given line or null if there is\n* none. If there is a LineStyleListener but it does not set any styles,\n* the StyledTextEvent.styles field will be initialized to an empty\n* array.\n* </p>\n*\n* @param lineOffset offset of the line start relative to the start of\n* \tthe content.\n* @param line line to get line styles for\n* @return line style data for the given line. Styles may start before\n* \tline start and end after line end\n*/\n",
			"methodName":"protected abstract StyledTextEvent getLineStyleData(int lineOffset, String line)"
		},
		"void setTabLength(int tabLength)":{
			"methodBody":"{\n    GC gc = getGC();\n    StringBuffer tabBuffer = new StringBuffer(tabLength);\n    for (int i = 0; i < tabLength; i++) {\n        tabBuffer.append(' ');\n    }\n    tabWidth = gc.stringExtent(tabBuffer.toString()).x;\n    disposeGC(gc);\n}",
			"comments":"/**\n* Calculates the width in pixel of a tab character\n* </p>\n* @param tabLength number of space characters represented by a tab character.\n*/\n",
			"methodName":"void setTabLength(int tabLength)"
		},
		"int getLineEndSpaceWidth()":{
			"methodBody":"{\n    return lineEndSpaceWidth;\n}",
			"comments":"/**\n* Returns the width in pixels of the space used to represent line delimiters.\n* @return the width in pixels of the space used to represent line delimiters.\n*/\n",
			"methodName":"int getLineEndSpaceWidth()"
		},
		"TextLayout createTextLayout(int lineOffset)":{
			"methodBody":"{\n    return new TextLayout(device);\n}",
			"comments":"",
			"methodName":"TextLayout createTextLayout(int lineOffset)"
		},
		"protected int getLeftMargin()":{
			"methodBody":"{\n    return 0;\n}",
			"comments":"",
			"methodName":"protected int getLeftMargin()"
		},
		"Font getFont(int style)":{
			"methodBody":"{\n    switch(style) {\n        case SWT.BOLD:\n            if (boldFont != null)\n                return boldFont;\n            return boldFont = new Font(device, getFontData(style));\n        case SWT.ITALIC:\n            if (italicFont != null)\n                return italicFont;\n            return italicFont = new Font(device, getFontData(style));\n        case SWT.BOLD | SWT.ITALIC:\n            if (boldItalicFont != null)\n                return boldItalicFont;\n            return boldItalicFont = new Font(device, getFontData(style));\n        default:\n            return regularFont;\n    }\n}",
			"comments":"/**\n*  Returns the Font according with the given style\n*/\n",
			"methodName":"Font getFont(int style)"
		},
		"protected abstract Rectangle getClientArea()":{
			"methodBody":"",
			"comments":"/**\n* Returns the visible client area that can be used for rendering.\n* </p>\n* @return the visible client area that can be used for rendering.\n*/\n",
			"methodName":"protected abstract Rectangle getClientArea()"
		},
		"FontData[] getFontData(int style)":{
			"methodBody":"{\n    FontData[] fontDatas = regularFont.getFontData();\n    for (int i = 0; i < fontDatas.length; i++) {\n        fontDatas[i].setStyle(style);\n    }\n    return fontDatas;\n}",
			"comments":"",
			"methodName":"FontData[] getFontData(int style)"
		},
		"protected abstract GC getGC()":{
			"methodBody":"",
			"comments":"/**\n* Returns the GC to use for rendering and measuring.\n* Allows subclasses to reuse GCs.\n* </p>\n* @return the GC to use for rendering and measuring.\n*/\n",
			"methodName":"protected abstract GC getGC()"
		},
		"int getLineHeight()":{
			"methodBody":"{\n    return ascent + descent;\n}",
			"comments":"/**\n* Returns the height in pixels of a line.\n* </p>\n* @return the height in pixels of a line.\n*/\n",
			"methodName":"int getLineHeight()"
		},
		"protected abstract int getOrientation()":{
			"methodBody":"",
			"comments":"/**\n*\n*/\n",
			"methodName":"protected abstract int getOrientation()"
		},
		"protected int getRightMargin()":{
			"methodBody":"{\n    return 0;\n}",
			"comments":"/**\n*\n*/\n",
			"methodName":"protected int getRightMargin()"
		},
		"protected abstract Color getSelectionBackground()":{
			"methodBody":"",
			"comments":"/**\n*\n*/\n",
			"methodName":"protected abstract Color getSelectionBackground()"
		},
		"protected abstract Point getSelection()":{
			"methodBody":"",
			"comments":"/**\n* Returns the widget selection.\n* Implemented by subclasses for optional selection rendering.\n* </p>\n* @return the widget selection.\n*/\n",
			"methodName":"protected abstract Point getSelection()"
		}
	},
	"ClassORInterfaceName":[
		"StyledTextRenderer"
	]
}
