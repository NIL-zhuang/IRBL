{
	"variables":[
		"handle",
		"currentPoint",
		"startPoint",
		"rect",
		"length",
		"buffer",
		"hDC",
		"gdipFont",
		"point",
		"family",
		"style",
		"size",
		"mode",
		"rect",
		"count",
		"gdipTypes",
		"points",
		"types",
		"index",
		"typesIndex",
		"type",
		"close",
		"newTypes",
		"result",
		"cx1",
		"cy1",
		"cx2",
		"cy2",
		"device",
		"device",
		"Device",
		"device",
		"SWT",
		"SWT",
		"device",
		"device",
		"handle",
		"Gdip",
		"Gdip",
		"handle",
		"SWT",
		"SWT",
		"device",
		"device",
		"SWT",
		"SWT",
		"width",
		"x",
		"x",
		"width",
		"width",
		"width",
		"height",
		"y",
		"y",
		"height",
		"height",
		"height",
		"width",
		"height",
		"arcAngle",
		"Gdip",
		"handle",
		"x",
		"y",
		"width",
		"height",
		"startAngle",
		"arcAngle",
		"Gdip",
		"handle",
		"currentPoint",
		"SWT",
		"SWT",
		"path",
		"SWT",
		"SWT",
		"path",
		"SWT",
		"SWT",
		"Gdip",
		"handle",
		"path",
		"currentPoint",
		"path",
		"currentPoint",
		"path",
		"SWT",
		"SWT",
		"rect",
		"x",
		"rect",
		"y",
		"rect",
		"width",
		"rect",
		"height",
		"Gdip",
		"handle",
		"rect",
		"currentPoint",
		"x",
		"currentPoint",
		"y",
		"SWT",
		"SWT",
		"font",
		"SWT",
		"SWT",
		"font",
		"SWT",
		"SWT",
		"string",
		"length",
		"string",
		"length",
		"buffer",
		"device",
		"GC",
		"hDC",
		"font",
		"point",
		"x",
		"Gdip",
		"gdipFont",
		"point",
		"y",
		"Gdip",
		"Gdip",
		"gdipFont",
		"family",
		"Gdip",
		"gdipFont",
		"Gdip",
		"gdipFont",
		"Gdip",
		"handle",
		"buffer",
		"length",
		"family",
		"style",
		"size",
		"point",
		"Gdip",
		"handle",
		"currentPoint",
		"Gdip",
		"family",
		"Gdip",
		"gdipFont",
		"device",
		"hDC",
		"SWT",
		"SWT",
		"Gdip",
		"handle",
		"currentPoint",
		"startPoint",
		"currentPoint",
		"startPoint",
		"SWT",
		"SWT",
		"gc",
		"SWT",
		"SWT",
		"gc",
		"SWT",
		"SWT",
		"gc",
		"outline",
		"OS",
		"gc",
		"OS",
		"Gdip",
		"Gdip",
		"Gdip",
		"handle",
		"mode",
		"outline",
		"Gdip",
		"handle",
		"x",
		"y",
		"gc",
		"gc",
		"Gdip",
		"handle",
		"x",
		"y",
		"gc",
		"SWT",
		"SWT",
		"Gdip",
		"handle",
		"currentPoint",
		"currentPoint",
		"cx1",
		"cy1",
		"cx2",
		"cy2",
		"x",
		"y",
		"Gdip",
		"handle",
		"currentPoint",
		"handle",
		"device",
		"Gdip",
		"handle",
		"handle",
		"device",
		"device",
		"device",
		"SWT",
		"SWT",
		"bounds",
		"SWT",
		"SWT",
		"bounds",
		"SWT",
		"SWT",
		"Gdip",
		"handle",
		"rect",
		"bounds",
		"rect",
		"bounds",
		"rect",
		"bounds",
		"rect",
		"bounds",
		"rect",
		"SWT",
		"SWT",
		"point",
		"SWT",
		"SWT",
		"point",
		"SWT",
		"SWT",
		"point",
		"currentPoint",
		"point",
		"currentPoint",
		"SWT",
		"SWT",
		"Gdip",
		"handle",
		"count",
		"count",
		"Gdip",
		"handle",
		"gdipTypes",
		"count",
		"Gdip",
		"handle",
		"points",
		"count",
		"count",
		"index",
		"count",
		"gdipTypes",
		"index",
		"type",
		"Gdip",
		"Gdip",
		"types",
		"typesIndex",
		"SWT",
		"close",
		"type",
		"Gdip",
		"index",
		"Gdip",
		"types",
		"typesIndex",
		"SWT",
		"close",
		"type",
		"Gdip",
		"index",
		"Gdip",
		"types",
		"typesIndex",
		"SWT",
		"close",
		"gdipTypes",
		"index",
		"Gdip",
		"index",
		"index",
		"close",
		"types",
		"typesIndex",
		"SWT",
		"typesIndex",
		"types",
		"typesIndex",
		"System",
		"types",
		"newTypes",
		"typesIndex",
		"types",
		"newTypes",
		"result",
		"types",
		"result",
		"points",
		"result",
		"SWT",
		"SWT",
		"Gdip",
		"handle",
		"currentPoint",
		"currentPoint",
		"x",
		"y",
		"Gdip",
		"handle",
		"currentPoint",
		"handle",
		"SWT",
		"SWT",
		"currentPoint",
		"startPoint",
		"x",
		"currentPoint",
		"startPoint",
		"y",
		"SWT",
		"SWT",
		"currentPoint",
		"cx",
		"currentPoint",
		"currentPoint",
		"cy",
		"currentPoint",
		"cx1",
		"x",
		"currentPoint",
		"cy1",
		"y",
		"currentPoint",
		"Gdip",
		"handle",
		"currentPoint",
		"currentPoint",
		"cx1",
		"cy1",
		"cx2",
		"cy2",
		"x",
		"y",
		"Gdip",
		"handle",
		"currentPoint",
		"handle",
		"ERROR_NULL_ARGUMENT",
		"device",
		"FillModeAlternate",
		"ERROR_NO_HANDLES",
		"tracking",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"handle",
		"X",
		"X",
		"currentPoint",
		"Y",
		"Y",
		"currentPoint",
		"ERROR_GRAPHIC_DISPOSED",
		"X",
		"Y",
		"Width",
		"Height",
		"X",
		"Y",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"handle",
		"X",
		"Y",
		"ERROR_GRAPHIC_DISPOSED",
		"X",
		"X",
		"Y",
		"Y",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"handle",
		"WINDING",
		"FillModeWinding",
		"FillModeAlternate",
		"gdipPen",
		"data",
		"gdipGraphics",
		"data",
		"gdipGraphics",
		"data",
		"ERROR_GRAPHIC_DISPOSED",
		"X",
		"Y",
		"tracking",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_NULL_ARGUMENT",
		"length",
		"ERROR_INVALID_ARGUMENT",
		"X",
		"Y",
		"Width",
		"Height",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_NULL_ARGUMENT",
		"length",
		"ERROR_INVALID_ARGUMENT",
		"X",
		"Y",
		"ERROR_GRAPHIC_DISPOSED",
		"PathPointTypePathTypeMask",
		"PathPointTypeStart",
		"PATH_MOVE_TO",
		"PathPointTypeCloseSubpath",
		"PathPointTypeLine",
		"PATH_LINE_TO",
		"PathPointTypeCloseSubpath",
		"PathPointTypeBezier",
		"PATH_CUBIC_TO",
		"PathPointTypeCloseSubpath",
		"PATH_CLOSE",
		"length",
		"types",
		"points",
		"ERROR_GRAPHIC_DISPOSED",
		"X",
		"Y",
		"ERROR_GRAPHIC_DISPOSED",
		"X",
		"X",
		"Y",
		"Y",
		"ERROR_GRAPHIC_DISPOSED",
		"X",
		"X",
		"Y",
		"Y",
		"X",
		"Y",
		"X",
		"Y",
		"device",
		"x",
		"y",
		"width",
		"height",
		"startAngle",
		"arcAngle",
		"path",
		"x",
		"y",
		"width",
		"height",
		"string",
		"x",
		"y",
		"font",
		"x",
		"y",
		"gc",
		"outline",
		"cx1",
		"cy1",
		"cx2",
		"cy2",
		"x",
		"y",
		"bounds",
		"point",
		"x",
		"y",
		"x",
		"y",
		"cx",
		"cy",
		"x",
		"y"
	],
	"extendORImplementFiles":[
		"Resource"
	],
	"package":[
		"org.eclipse.swt.graphics"
	],
	"import":[
		"org.eclipse.swt",
		"org.eclipse.swt.internal.gdip",
		"org.eclipse.swt.internal.win32"
	],
	"methods":[
		"addArc",
		"addPath",
		"addRectangle",
		"addString",
		"close",
		"contains",
		"cubicTo",
		"dispose",
		"getBounds",
		"getCurrentPoint",
		"getPathData",
		"lineTo",
		"isDisposed",
		"moveTo",
		"quadTo",
		"toString",
		"getDevice",
		"error",
		"checkGDIP",
		"GraphicsPath_new",
		"error",
		"new_Object",
		"isDisposed",
		"error",
		"GraphicsPath_AddArc",
		"GraphicsPath_GetLastPoint",
		"isDisposed",
		"error",
		"error",
		"isDisposed",
		"error",
		"GraphicsPath_AddPath",
		"isDisposed",
		"error",
		"GraphicsPath_AddRectangle",
		"isDisposed",
		"error",
		"error",
		"isDisposed",
		"error",
		"length",
		"getChars",
		"internal_new_GC",
		"createGdipFont",
		"Font_GetSize",
		"FontFamily_new",
		"Font_GetFamily",
		"Font_GetStyle",
		"Font_GetSize",
		"GraphicsPath_AddString",
		"GraphicsPath_GetLastPoint",
		"FontFamily_delete",
		"Font_delete",
		"internal_dispose_GC",
		"isDisposed",
		"error",
		"GraphicsPath_CloseFigure",
		"isDisposed",
		"error",
		"error",
		"isDisposed",
		"error",
		"initGdip",
		"GetPolyFillMode",
		"GraphicsPath_SetFillMode",
		"GraphicsPath_IsOutlineVisible",
		"GraphicsPath_IsVisible",
		"isDisposed",
		"error",
		"GraphicsPath_AddBezier",
		"GraphicsPath_GetLastPoint",
		"isDisposed",
		"GraphicsPath_delete",
		"dispose_Object",
		"isDisposed",
		"error",
		"error",
		"error",
		"GraphicsPath_GetBounds",
		"isDisposed",
		"error",
		"error",
		"error",
		"isDisposed",
		"error",
		"GraphicsPath_GetPointCount",
		"GraphicsPath_GetPathTypes",
		"GraphicsPath_GetPathPoints",
		"arraycopy",
		"isDisposed",
		"error",
		"GraphicsPath_AddLine",
		"GraphicsPath_GetLastPoint",
		"isDisposed",
		"error",
		"isDisposed",
		"error",
		"GraphicsPath_AddBezier",
		"GraphicsPath_GetLastPoint",
		"isDisposed",
		"PointF",
		"PointF",
		"RectF",
		"PointF",
		"RectF",
		"PathData"
	],
	"methodsBody":{
		"public boolean contains(float x, float y, GC gc, boolean outline)":{
			"methodBody":"{\n    if (isDisposed())\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (gc == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (gc.isDisposed())\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    \n    gc.initGdip(outline, false);\n    int mode = OS.GetPolyFillMode(gc.handle) == OS.WINDING ? Gdip.FillModeWinding : Gdip.FillModeAlternate;\n    Gdip.GraphicsPath_SetFillMode(handle, mode);\n    if (outline) {\n        return Gdip.GraphicsPath_IsOutlineVisible(handle, x, y, gc.data.gdipPen, gc.data.gdipGraphics);\n    } else {\n        return Gdip.GraphicsPath_IsVisible(handle, x, y, gc.data.gdipGraphics);\n    }\n}",
			"comments":"/**\n* Returns <code>true</code> if the specified point is contained by\n* the receiver and false otherwise.\n* <p>\n* If outline is <code>true</code>, the point (x, y) checked for containment in\n* the receiver's outline. If outline is <code>false</code>, the point is\n* checked to see if it is contained within the bounds of the (closed) area\n* covered by the receiver.\n*\n* @param x the x coordinate of the point to test for containment\n* @param y the y coordinate of the point to test for containment\n* @param gc the GC to use when testing for containment\n* @param outline controls wether to check the outline or contained area of the path\n* @return <code>true</code> if the path contains the point and <code>false</code> otherwise\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the gc is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the gc has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n//TODO - should use GC transformation\n",
			"methodName":"public boolean contains(float x, float y, GC gc, boolean outline)"
		},
		"public void dispose()":{
			"methodBody":"{\n    if (handle == 0)\n        return;\n    if (device.isDisposed())\n        return;\n    Gdip.GraphicsPath_delete(handle);\n    handle = 0;\n    if (device.tracking)\n        device.dispose_Object(this);\n    device = null;\n}",
			"comments":"/**\n* Disposes of the operating system resources associated with\n* the Path. Applications must dispose of all Paths that\n* they allocate.\n*/\n",
			"methodName":"public void dispose()"
		},
		"public void addPath(Path path)":{
			"methodBody":"{\n    if (isDisposed())\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (path == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (path.isDisposed())\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    \n    Gdip.GraphicsPath_AddPath(handle, path.handle, false);\n    currentPoint.X = path.currentPoint.X;\n    currentPoint.Y = path.currentPoint.Y;\n}",
			"comments":"/**\n* Adds to the receiver the path described by the parameter.\n*\n* @param path the path to add to the receiver\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the parameter is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the parameter has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n//TODO - expose connect?\n",
			"methodName":"public void addPath(Path path)"
		},
		"public void cubicTo(float cx1, float cy1, float cx2, float cy2, float x, float y)":{
			"methodBody":"{\n    if (isDisposed())\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    Gdip.GraphicsPath_AddBezier(handle, currentPoint.X, currentPoint.Y, cx1, cy1, cx2, cy2, x, y);\n    Gdip.GraphicsPath_GetLastPoint(handle, currentPoint);\n}",
			"comments":"/**\n* Adds to the receiver a cubic bezier curve based on the parameters.\n*\n* @param cx1 the x coordinate of the first control point of the spline\n* @param cy1 the y coordinate of the first control of the spline\n* @param cx2 the x coordinate of the second control of the spline\n* @param cy2 the y coordinate of the second control of the spline\n* @param x the x coordinate of the end point of the spline\n* @param y the y coordinate of the end point of the spline\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void cubicTo(float cx1, float cy1, float cx2, float cy2, float x, float y)"
		},
		"public PathData getPathData()":{
			"methodBody":"{\n    if (isDisposed())\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    int count = Gdip.GraphicsPath_GetPointCount(handle);\n    byte[] gdipTypes = new byte[count];\n    float[] points = new float[count * 2];\n    Gdip.GraphicsPath_GetPathTypes(handle, gdipTypes, count);\n    Gdip.GraphicsPath_GetPathPoints(handle, points, count);\n    byte[] types = new byte[count * 2];\n    int index = 0, typesIndex = 0;\n    while (index < count) {\n        byte type = gdipTypes[index];\n        boolean close = false;\n        switch(type & Gdip.PathPointTypePathTypeMask) {\n            case Gdip.PathPointTypeStart:\n                types[typesIndex++] = SWT.PATH_MOVE_TO;\n                close = (type & Gdip.PathPointTypeCloseSubpath) != 0;\n                index += 1;\n                break;\n            case Gdip.PathPointTypeLine:\n                types[typesIndex++] = SWT.PATH_LINE_TO;\n                close = (type & Gdip.PathPointTypeCloseSubpath) != 0;\n                index += 1;\n                break;\n            case Gdip.PathPointTypeBezier:\n                types[typesIndex++] = SWT.PATH_CUBIC_TO;\n                close = (gdipTypes[index + 2] & Gdip.PathPointTypeCloseSubpath) != 0;\n                index += 3;\n                break;\n            default:\n                index++;\n        }\n        if (close) {\n            types[typesIndex++] = SWT.PATH_CLOSE;\n        }\n    }\n    if (typesIndex != types.length) {\n        byte[] newTypes = new byte[typesIndex];\n        System.arraycopy(types, 0, newTypes, 0, typesIndex);\n        types = newTypes;\n    }\n    PathData result = new PathData();\n    result.types = types;\n    result.points = points;\n    return result;\n}",
			"comments":"/**\n* Returns a device independent representation of the receiver.\n*\n* @return the PathData for the receiver\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see PathData\n*/\n",
			"methodName":"public PathData getPathData()"
		},
		"public boolean isDisposed()":{
			"methodBody":"{\n    return handle == 0;\n}",
			"comments":"/**\n* Returns <code>true</code> if the Path has been disposed,\n* and <code>false</code> otherwise.\n* <p>\n* This method gets the dispose state for the Path.\n* When a Path has been disposed, it is an error to\n* invoke any other method using the Path.\n*\n* @return <code>true</code> when the Path is disposed, and <code>false</code> otherwise\n*/\n",
			"methodName":"public boolean isDisposed()"
		},
		"public void addString(String string, float x, float y, Font font)":{
			"methodBody":"{\n    if (isDisposed())\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (font == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (font.isDisposed())\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    int length = string.length();\n    char[] buffer = new char[length];\n    string.getChars(0, length, buffer, 0);\n    int hDC = device.internal_new_GC(null);\n    int gdipFont = GC.createGdipFont(hDC, font.handle);\n    PointF point = new PointF();\n    point.X = x - (Gdip.Font_GetSize(gdipFont) / 6);\n    point.Y = y;\n    int family = Gdip.FontFamily_new();\n    Gdip.Font_GetFamily(gdipFont, family);\n    int style = Gdip.Font_GetStyle(gdipFont);\n    float size = Gdip.Font_GetSize(gdipFont);\n    Gdip.GraphicsPath_AddString(handle, buffer, length, family, style, size, point, 0);\n    Gdip.GraphicsPath_GetLastPoint(handle, currentPoint);\n    Gdip.FontFamily_delete(family);\n    Gdip.Font_delete(gdipFont);\n    device.internal_dispose_GC(hDC, null);\n}",
			"comments":"/**\n* Adds to the receiver the pattern of glyphs generated by drawing\n* the given string using the given font starting at the point (x, y).\n*\n* @param string the text to use\n* @param x the x coordinate of the starting point\n* @param y the y coordinate of the starting point\n* @param font the font to use\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the font is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the font has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void addString(String string, float x, float y, Font font)"
		},
		"public void getCurrentPoint(float[] point)":{
			"methodBody":"{\n    if (isDisposed())\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (point == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (point.length < 2)\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    point[0] = currentPoint.X;\n    point[1] = currentPoint.Y;\n}",
			"comments":"/**\n* Replaces the first two elements in the parameter with values that\n* describe the current point of the path.\n*\n* @param point the array to hold the result\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the parameter is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the parameter is too small to hold the end point</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void getCurrentPoint(float[] point)"
		},
		"public void addRectangle(float x, float y, float width, float height)":{
			"methodBody":"{\n    if (isDisposed())\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    RectF rect = new RectF();\n    rect.X = x;\n    rect.Y = y;\n    rect.Width = width;\n    rect.Height = height;\n    Gdip.GraphicsPath_AddRectangle(handle, rect);\n    currentPoint.X = x;\n    currentPoint.Y = y;\n}",
			"comments":"/**\n* Adds to the receiver the rectangle specified by x, y, width and height.\n*\n* @param x the x coordinate of the rectangle to add\n* @param y the y coordinate of the rectangle to add\n* @param width the width of the rectangle to add\n* @param height the height of the rectangle to add\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void addRectangle(float x, float y, float width, float height)"
		},
		"public String toString()":{
			"methodBody":"{\n    if (isDisposed())\n        return \"Path {*DISPOSED*}\";\n    return \"Path {\" + handle + \"}\";\n}",
			"comments":"/**\n* Returns a string containing a concise, human-readable\n* description of the receiver.\n*\n* @return a string representation of the receiver\n*/\n",
			"methodName":"public String toString()"
		},
		"public void lineTo(float x, float y)":{
			"methodBody":"{\n    if (isDisposed())\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    Gdip.GraphicsPath_AddLine(handle, currentPoint.X, currentPoint.Y, x, y);\n    Gdip.GraphicsPath_GetLastPoint(handle, currentPoint);\n}",
			"comments":"/**\n* Adds to the receiver a line from the current point to\n* the point specified by (x, y).\n*\n* @param x the x coordinate of the end of the line to add\n* @param y the y coordinate of the end of the line to add\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void lineTo(float x, float y)"
		},
		"public void quadTo(float cx, float cy, float x, float y)":{
			"methodBody":"{\n    if (isDisposed())\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    float cx1 = currentPoint.X + 2 * (cx - currentPoint.X) / 3;\n    float cy1 = currentPoint.Y + 2 * (cy - currentPoint.Y) / 3;\n    float cx2 = cx1 + (x - currentPoint.X) / 3;\n    float cy2 = cy1 + (y - currentPoint.Y) / 3;\n    Gdip.GraphicsPath_AddBezier(handle, currentPoint.X, currentPoint.Y, cx1, cy1, cx2, cy2, x, y);\n    Gdip.GraphicsPath_GetLastPoint(handle, currentPoint);\n}",
			"comments":"/**\n* Adds to the receiver a quadratic curve based on the parameters.\n*\n* @param cx the x coordinate of the control point of the spline\n* @param cy the y coordinate of the control point of the spline\n* @param x the x coordinate of the end point of the spline\n* @param y the y coordinate of the end point of the spline\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void quadTo(float cx, float cy, float x, float y)"
		},
		"public void moveTo(float x, float y)":{
			"methodBody":"{\n    if (isDisposed())\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    currentPoint.X = startPoint.X = x;\n    currentPoint.Y = startPoint.Y = y;\n}",
			"comments":"/**\n* Sets the current point of the receiver to the point\n* specified by (x, y). Note that this starts a new\n* sub path.\n*\n* @param x the x coordinate of the new end point\n* @param y the y coordinate of the new end point\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void moveTo(float x, float y)"
		},
		"public void close()":{
			"methodBody":"{\n    if (isDisposed())\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    Gdip.GraphicsPath_CloseFigure(handle);\n    \n    currentPoint.X = startPoint.X;\n    currentPoint.Y = startPoint.Y;\n}",
			"comments":"/**\n* Closes the current sub path by adding to the receiver a line\n* from the current point of the path back to the starting point\n* of the sub path.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n/*\n* Feature in GDI+. CloseFigure() does affect the last\n* point, so GetLastPoint() does not return the starting\n* point of the subpath after calling CloseFigure().  The\n* fix is to remember the subpath starting point and use\n* it instead.\n*/\n",
			"methodName":"public void close()"
		},
		"public void addArc(float x, float y, float width, float height, float startAngle, float arcAngle)":{
			"methodBody":"{\n    if (isDisposed())\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (width < 0) {\n        x = x + width;\n        width = -width;\n    }\n    if (height < 0) {\n        y = y + height;\n        height = -height;\n    }\n    if (width == 0 || height == 0 || arcAngle == 0)\n        return;\n    Gdip.GraphicsPath_AddArc(handle, x, y, width, height, -startAngle, -arcAngle);\n    Gdip.GraphicsPath_GetLastPoint(handle, currentPoint);\n}",
			"comments":"/**\n* Adds to the receiver a circular or elliptical arc that lies within\n* the specified rectangular area.\n* <p>\n* The resulting arc begins at <code>startAngle</code> and extends\n* for <code>arcAngle</code> degrees.\n* Angles are interpreted such that 0 degrees is at the 3 o'clock\n* position. A positive value indicates a counter-clockwise rotation\n* while a negative value indicates a clockwise rotation.\n* </p><p>\n* The center of the arc is the center of the rectangle whose origin\n* is (<code>x</code>, <code>y</code>) and whose size is specified by the\n* <code>width</code> and <code>height</code> arguments.\n* </p><p>\n* The resulting arc covers an area <code>width + 1</code> pixels wide\n* by <code>height + 1</code> pixels tall.\n* </p>\n*\n* @param x the x coordinate of the upper-left corner of the arc\n* @param y the y coordinate of the upper-left corner of the arc\n* @param width the width of the arc\n* @param height the height of the arc\n* @param startAngle the beginning angle\n* @param arcAngle the angular extent of the arc, relative to the start angle\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void addArc(float x, float y, float width, float height, float startAngle, float arcAngle)"
		},
		"public void getBounds(float[] bounds)":{
			"methodBody":"{\n    if (isDisposed())\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (bounds == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (bounds.length < 4)\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    RectF rect = new RectF();\n    Gdip.GraphicsPath_GetBounds(handle, rect, 0, 0);\n    bounds[0] = rect.X;\n    bounds[1] = rect.Y;\n    bounds[2] = rect.Width;\n    bounds[3] = rect.Height;\n}",
			"comments":"/**\n* Replaces the first four elements in the parameter with values that\n* describe the smallest rectangle that will completely contain the\n* receiver (i.e. the bounding box).\n*\n* @param bounds the array to hold the result\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the parameter is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the parameter is too small to hold the bounding box</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void getBounds(float[] bounds)"
		}
	},
	"ClassORInterfaceName":[
		"Path"
	]
}
