{
	"variables":[
		"tree",
		"item",
		"column",
		"columnListener",
		"treeListener",
		"runnable",
		"cell",
		"rect",
		"area",
		"editorRect",
		"treeColumn",
		"columnCount",
		"treeColumn",
		"treeColumn",
		"columnCount",
		"tree",
		"tree",
		"columnListener",
		"treeListener",
		"editor",
		"editor",
		"TreeEditor",
		"editor",
		"editor",
		"editor",
		"editor",
		"e",
		"runnable",
		"editor",
		"editor",
		"editor",
		"e",
		"runnable",
		"tree",
		"treeListener",
		"grabVertical",
		"item",
		"column",
		"item",
		"item",
		"column",
		"item",
		"column",
		"cell",
		"rect",
		"rect",
		"cell",
		"rect",
		"tree",
		"cell",
		"area",
		"area",
		"cell",
		"cell",
		"area",
		"area",
		"cell",
		"area",
		"area",
		"cell",
		"cell",
		"cell",
		"minimumWidth",
		"minimumHeight",
		"grabHorizontal",
		"tree",
		"cell",
		"area",
		"area",
		"cell",
		"editorRect",
		"Math",
		"cell",
		"minimumWidth",
		"grabVertical",
		"editorRect",
		"Math",
		"cell",
		"minimumHeight",
		"horizontalAlignment",
		"SWT",
		"editorRect",
		"cell",
		"editorRect",
		"horizontalAlignment",
		"SWT",
		"editorRect",
		"cell",
		"editorRect",
		"editorRect",
		"Math",
		"cell",
		"editorRect",
		"verticalAlignment",
		"SWT",
		"editorRect",
		"cell",
		"editorRect",
		"verticalAlignment",
		"SWT",
		"editorRect",
		"cell",
		"editorRect",
		"editorRect",
		"tree",
		"tree",
		"treeColumn",
		"columnListener",
		"columnListener",
		"treeListener",
		"tree",
		"treeListener",
		"treeListener",
		"tree",
		"item",
		"column",
		"column",
		"item",
		"tree",
		"columnCount",
		"column",
		"columnCount",
		"tree",
		"treeColumn",
		"columnListener",
		"column",
		"column",
		"tree",
		"column",
		"tree",
		"treeColumn",
		"columnListener",
		"item",
		"item",
		"column",
		"editor",
		"item",
		"editor",
		"tree",
		"item",
		"item",
		"tree",
		"columnCount",
		"column",
		"columnCount",
		"column",
		"column",
		"columnCount",
		"tree",
		"tree",
		"display",
		"display",
		"x",
		"x",
		"width",
		"width",
		"width",
		"x",
		"x",
		"width",
		"x",
		"width",
		"x",
		"width",
		"width",
		"x",
		"width",
		"x",
		"x",
		"y",
		"width",
		"x",
		"width",
		"x",
		"width",
		"width",
		"height",
		"height",
		"RIGHT",
		"x",
		"width",
		"width",
		"LEFT",
		"x",
		"width",
		"width",
		"x",
		"x",
		"x",
		"BOTTOM",
		"y",
		"height",
		"height",
		"TOP",
		"y",
		"height",
		"height",
		"column",
		"column",
		"column",
		"column",
		"column",
		"column",
		"column",
		"column",
		"column",
		"column",
		"item",
		"tree",
		"e",
		"e",
		"e",
		"e",
		"column",
		"item",
		"editor",
		"item",
		"column",
		"editor",
		"item"
	],
	"extendORImplementFiles":[
		"ControlEditor"
	],
	"package":[
		"org.eclipse.swt.custom"
	],
	"import":[
		"org.eclipse.swt",
		"org.eclipse.swt.events",
		"org.eclipse.swt.graphics",
		"org.eclipse.swt.widgets"
	],
	"methods":[
		"controlMoved",
		"controlResized",
		"run",
		"treeCollapsed",
		"treeExpanded",
		"computeBounds",
		"dispose",
		"getColumn",
		"getItem",
		"setColumn",
		"setItem",
		"setEditor",
		"setEditor",
		"resize",
		"resize",
		"resize",
		"isDisposed",
		"isDisposed",
		"resize",
		"setVisible",
		"isDisposed",
		"setVisible",
		"asyncExec",
		"isDisposed",
		"setVisible",
		"asyncExec",
		"addTreeListener",
		"isDisposed",
		"getBounds",
		"getImageBounds",
		"getClientArea",
		"getColumnCount",
		"max",
		"max",
		"max",
		"getColumnCount",
		"getColumn",
		"removeControlListener",
		"removeTreeListener",
		"dispose",
		"getColumnCount",
		"resize",
		"getColumn",
		"removeControlListener",
		"getColumnCount",
		"getColumn",
		"addControlListener",
		"resize",
		"resize",
		"setItem",
		"setColumn",
		"setEditor",
		"setItem",
		"setEditor",
		"isDisposed",
		"isDisposed",
		"getColumnCount",
		"resize",
		"ControlListener",
		"TreeListener",
		"Runnable",
		"Rectangle",
		"Rectangle"
	],
	"methodsBody":{
		"public void setItem(TreeItem item)":{
			"methodBody":"{\n    this.item = item;\n    resize();\n}",
			"comments":"",
			"methodName":"public void setItem(TreeItem item)"
		},
		"public void setEditor(Control editor, TreeItem item, int column)":{
			"methodBody":"{\n    setItem(item);\n    setColumn(column);\n    setEditor(editor);\n}",
			"comments":"/**\n* Specify the Control that is to be displayed and the cell in the tree that it is to be positioned above.\n*\n* <p>Note: The Control provided as the editor <b>must</b> be created with its parent being the Tree control\n* specified in the TreeEditor constructor.\n*\n* @param editor the Control that is displayed above the cell being edited\n* @param item the TreeItem for the row of the cell being tracked by this editor\n* @param column the zero based index of the column of the cell being tracked by this editor\n*\n* @since 3.1\n*/\n",
			"methodName":"public void setEditor(Control editor, TreeItem item, int column)"
		},
		"public void dispose()":{
			"methodBody":"{\n    if (this.column > -1 && this.column < tree.getColumnCount()) {\n        TreeColumn treeColumn = tree.getColumn(this.column);\n        treeColumn.removeControlListener(columnListener);\n    }\n    columnListener = null;\n    if (treeListener != null)\n        tree.removeTreeListener(treeListener);\n    treeListener = null;\n    tree = null;\n    item = null;\n    column = 0;\n    super.dispose();\n}",
			"comments":"/**\n* Removes all associations between the TreeEditor and the row in the tree.  The\n* tree and the editor Control are <b>not</b> disposed.\n*/\n",
			"methodName":"public void dispose()"
		},
		"public TreeItem getItem()":{
			"methodBody":"{\n    return item;\n}",
			"comments":"/**\n* Returns the TreeItem for the row of the cell being tracked by this editor.\n*\n* @return the TreeItem for the row of the cell being tracked by this editor\n*/\n",
			"methodName":"public TreeItem getItem()"
		},
		"public void treeCollapsed(TreeEvent e)":{
			"methodBody":"{\n    if (editor == null || editor.isDisposed())\n        return;\n    editor.setVisible(false);\n    e.display.asyncExec(runnable);\n}",
			"comments":"",
			"methodName":"public void treeCollapsed(TreeEvent e)"
		},
		"public void setEditor(Control editor, TreeItem item)":{
			"methodBody":"{\n    setItem(item);\n    setEditor(editor);\n}",
			"comments":"/**\n* Specify the Control that is to be displayed and the cell in the tree that it is to be positioned above.\n*\n* <p>Note: The Control provided as the editor <b>must</b> be created with its parent being the Tree control\n* specified in the TreeEditor constructor.\n*\n* @param editor the Control that is displayed above the cell being edited\n* @param item the TreeItem for the row of the cell being tracked by this editor\n*/\n",
			"methodName":"public void setEditor(Control editor, TreeItem item)"
		},
		"public void run()":{
			"methodBody":"{\n    if (editor == null || editor.isDisposed())\n        return;\n    if (TreeEditor.this.tree.isDisposed())\n        return;\n    resize();\n    editor.setVisible(true);\n}",
			"comments":"",
			"methodName":"public void run()"
		},
		"Rectangle computeBounds()":{
			"methodBody":"{\n    if (item == null || column == -1 || item.isDisposed())\n        return new Rectangle(0, 0, 0, 0);\n    Rectangle cell = item.getBounds(column);\n    Rectangle rect = item.getImageBounds(column);\n    cell.x = rect.x + rect.width;\n    cell.width -= rect.width;\n    Rectangle area = tree.getClientArea();\n    if (cell.x < area.x + area.width) {\n        if (cell.x + cell.width > area.x + area.width) {\n            cell.width = area.x + area.width - cell.x;\n        }\n    }\n    Rectangle editorRect = new Rectangle(cell.x, cell.y, minimumWidth, minimumHeight);\n    if (grabHorizontal) {\n        if (tree.getColumnCount() == 0) {\n            \n            \n            cell.width = area.x + area.width - cell.x;\n        }\n        editorRect.width = Math.max(cell.width, minimumWidth);\n    }\n    if (grabVertical) {\n        editorRect.height = Math.max(cell.height, minimumHeight);\n    }\n    if (horizontalAlignment == SWT.RIGHT) {\n        editorRect.x += cell.width - editorRect.width;\n    } else if (horizontalAlignment == SWT.LEFT) {\n    \n    } else {\n        \n        editorRect.x += (cell.width - editorRect.width) / 2;\n    }\n    \n    editorRect.x = Math.max(cell.x, editorRect.x);\n    if (verticalAlignment == SWT.BOTTOM) {\n        editorRect.y += cell.height - editorRect.height;\n    } else if (verticalAlignment == SWT.TOP) {\n    \n    } else {\n        \n        editorRect.y += (cell.height - editorRect.height) / 2;\n    }\n    return editorRect;\n}",
			"comments":"// Bounds of tree item only include the text area - stretch out to include\n// entire client area\n// do nothing - cell.x is the right answer\n// default is CENTER\n// don't let the editor overlap with the +/- of the tree\n// do nothing - cell.y is the right answer\n// default is CENTER\n",
			"methodName":"Rectangle computeBounds()"
		},
		"void resize()":{
			"methodBody":"{\n    if (tree.isDisposed())\n        return;\n    if (item == null || item.isDisposed())\n        return;\n    int columnCount = tree.getColumnCount();\n    if (columnCount == 0 && column != 0)\n        return;\n    if (columnCount > 0 && (column < 0 || column >= columnCount))\n        return;\n    super.resize();\n}",
			"comments":"",
			"methodName":"void resize()"
		},
		"public void controlMoved(ControlEvent e)":{
			"methodBody":"{\n    resize();\n}",
			"comments":"",
			"methodName":"public void controlMoved(ControlEvent e)"
		},
		"public int getColumn()":{
			"methodBody":"{\n    return column;\n}",
			"comments":"/**\n* Returns the zero based index of the column of the cell being tracked by this editor.\n*\n* @return the zero based index of the column of the cell being tracked by this editor\n*\n* @since 3.1\n*/\n",
			"methodName":"public int getColumn()"
		},
		"public void controlResized(ControlEvent e)":{
			"methodBody":"{\n    resize();\n}",
			"comments":"",
			"methodName":"public void controlResized(ControlEvent e)"
		},
		"public void setColumn(int column)":{
			"methodBody":"{\n    int columnCount = tree.getColumnCount();\n    \n    if (columnCount == 0) {\n        this.column = (column == 0) ? 0 : -1;\n        resize();\n        return;\n    }\n    if (this.column > -1 && this.column < columnCount) {\n        TreeColumn treeColumn = tree.getColumn(this.column);\n        treeColumn.removeControlListener(columnListener);\n        this.column = -1;\n    }\n    if (column < 0 || column >= tree.getColumnCount())\n        return;\n    this.column = column;\n    TreeColumn treeColumn = tree.getColumn(this.column);\n    treeColumn.addControlListener(columnListener);\n    resize();\n}",
			"comments":"/**\n* Sets the zero based index of the column of the cell being tracked by this editor.\n*\n* @param column the zero based index of the column of the cell being tracked by this editor\n*\n* @since 3.1\n*/\n// Separately handle the case where the tree has no TreeColumns.\n// In this situation, there is a single default column.\n",
			"methodName":"public void setColumn(int column)"
		},
		"public void treeExpanded(TreeEvent e)":{
			"methodBody":"{\n    if (editor == null || editor.isDisposed())\n        return;\n    editor.setVisible(false);\n    e.display.asyncExec(runnable);\n}",
			"comments":"",
			"methodName":"public void treeExpanded(TreeEvent e)"
		}
	},
	"ClassORInterfaceName":[
		"TreeEditor"
	]
}
