{
	"variables":[
		"items",
		"columns",
		"imageList",
		"currentItem",
		"lastIndexOf",
		"lastWidth",
		"customDraw",
		"cancelMove",
		"dragStarted",
		"fixScrollWidth",
		"tipRequested",
		"wasSelected",
		"ignoreActivate",
		"ignoreSelect",
		"ignoreShrink",
		"ignoreResize",
		"INSET",
		"GRID_WIDTH",
		"HEADER_MARGIN",
		"TableProc",
		"TableClass",
		"BUTTON",
		"lpWndClass",
		"typedListener",
		"checkSelection",
		"checkFilter",
		"checkActivate",
		"oldSelected",
		"code",
		"event",
		"index",
		"event",
		"count",
		"item",
		"lvItem",
		"count",
		"lvItem",
		"cleared",
		"i",
		"item",
		"item",
		"count",
		"i",
		"lvItem",
		"cleared",
		"i",
		"index",
		"item",
		"lvItem",
		"cleared",
		"count",
		"i",
		"item",
		"bits",
		"width",
		"hwndHeader",
		"count",
		"i",
		"result",
		"width",
		"height",
		"empty",
		"oneItem",
		"border",
		"empty",
		"oneItem",
		"width",
		"height",
		"hFont",
		"lvColumn",
		"hHeap",
		"pszText",
		"bits1",
		"hwndHeader",
		"bits2",
		"hwndHeader",
		"count",
		"columnCount",
		"newColumns",
		"itemCount",
		"i",
		"item",
		"strings",
		"temp",
		"images",
		"temp",
		"cellBackground",
		"temp",
		"cellForeground",
		"temp",
		"cellFont",
		"temp",
		"lvColumn",
		"width",
		"cchTextMax",
		"hHeap",
		"byteCount",
		"pszText",
		"lvItem",
		"i",
		"fmt",
		"lvColumn",
		"count",
		"small",
		"length",
		"newItems",
		"lvItem",
		"result",
		"lvItem",
		"i",
		"lvItem",
		"count",
		"lvItem",
		"i",
		"lvItem",
		"hwndHeader",
		"columnCount",
		"index",
		"first",
		"cchTextMax",
		"hHeap",
		"byteCount",
		"pszText",
		"lvColumn",
		"hHeap",
		"pszText",
		"lvColumn",
		"lvItem",
		"itemCount",
		"i",
		"itemCount",
		"i",
		"item",
		"strings",
		"temp",
		"images",
		"temp",
		"cellBackground",
		"temp",
		"cellForeground",
		"temp",
		"cellFont",
		"temp",
		"count",
		"index",
		"code",
		"hImageList",
		"cx",
		"cy",
		"hOldStateList",
		"stateCx",
		"stateCy",
		"hwndHeader",
		"count",
		"hwndHeader",
		"count",
		"hwndHeader",
		"count",
		"order",
		"hwndHeader",
		"count",
		"result",
		"pixel",
		"hwndHeader",
		"rect",
		"bits",
		"count",
		"pinfo",
		"empty",
		"oneItem",
		"count",
		"result",
		"i",
		"bits",
		"i",
		"j",
		"count",
		"result",
		"focusIndex",
		"selectedIndex",
		"i",
		"i",
		"j",
		"count",
		"result",
		"bounds",
		"index",
		"hImageList",
		"topIndex",
		"index",
		"hwndHeader",
		"count",
		"i",
		"count",
		"i",
		"i",
		"lvItem",
		"result",
		"hwndHeader",
		"columnCount",
		"itemCount",
		"i",
		"item",
		"i",
		"item",
		"i",
		"column",
		"hOldList",
		"newIndices",
		"start",
		"end",
		"count",
		"last",
		"i",
		"index",
		"item",
		"code",
		"count",
		"item",
		"code",
		"count",
		"index",
		"item",
		"code",
		"i",
		"hwndHeader",
		"columnCount",
		"itemCount",
		"redraw",
		"index",
		"item",
		"code",
		"code",
		"i",
		"item",
		"length",
		"lvItem",
		"i",
		"lvItem",
		"count",
		"lvItem",
		"i",
		"lvItem",
		"pinfo",
		"forceSelect",
		"count",
		"lvItem",
		"code",
		"flags",
		"fakeMouseUp",
		"fixResize",
		"rect",
		"hwndHeader",
		"count",
		"oldOrder",
		"reorder",
		"seen",
		"i",
		"index",
		"oldRects",
		"i",
		"newColumns",
		"newRect",
		"i",
		"column",
		"hOldStateList",
		"cx",
		"cy",
		"count",
		"flags",
		"hImageList",
		"hDC",
		"memDC",
		"hBitmap",
		"hOldBitmap",
		"rect",
		"clrBackground",
		"hBrush",
		"oldFont",
		"tm",
		"itemWidth",
		"itemHeight",
		"left",
		"top",
		"hTheme",
		"hOldStateList",
		"lvItem",
		"topIndex",
		"hwndHeader",
		"bits",
		"newBits",
		"topIndex",
		"bits",
		"itemCount",
		"isVirtual",
		"index",
		"item",
		"code",
		"length",
		"newItems",
		"flags",
		"i",
		"hOldList",
		"hwndHeader",
		"rect",
		"height",
		"hImageList",
		"newBits",
		"bits",
		"bits",
		"hwndHeader",
		"flags",
		"hwndHeader",
		"hwndHeader",
		"count",
		"newWidth",
		"index",
		"imageIndent",
		"string",
		"font",
		"tableItem",
		"hDC",
		"oldFont",
		"flags",
		"buffer",
		"rect",
		"buffer",
		"hStateList",
		"cx",
		"cy",
		"hImageList",
		"cx",
		"cy",
		"oldWidth",
		"length",
		"focusIndex",
		"length",
		"focusIndex",
		"i",
		"index",
		"count",
		"hwndHeader",
		"columnCount",
		"i",
		"column",
		"hImageList",
		"topIndex",
		"rect",
		"dy",
		"index",
		"hwndHeader",
		"count",
		"rect",
		"width",
		"area",
		"dx",
		"width",
		"dx",
		"index",
		"index",
		"hwndToolTip",
		"hwndHeader",
		"count",
		"index",
		"newBits",
		"bits",
		"result",
		"index",
		"item",
		"code",
		"index",
		"event",
		"result",
		"result",
		"result",
		"pinfo",
		"index",
		"item",
		"result",
		"pinfo",
		"index",
		"item",
		"result",
		"bits",
		"mask",
		"count",
		"length",
		"newItems",
		"hdr",
		"hwndHeader",
		"count",
		"phdn",
		"column",
		"bits",
		"count",
		"phdn",
		"column",
		"bits",
		"phdn",
		"pitem",
		"count",
		"order",
		"index",
		"start",
		"end",
		"i",
		"column",
		"width",
		"bits",
		"rect",
		"phdn",
		"pitem",
		"column",
		"count",
		"newColumns",
		"order",
		"moved",
		"i",
		"nextColumn",
		"phdn",
		"column",
		"result",
		"code",
		"pinfo",
		"result",
		"count",
		"index",
		"lvItem",
		"result",
		"pixel",
		"result",
		"bits",
		"code",
		"headerHeight",
		"hwndHeader",
		"rect",
		"rect",
		"empty",
		"oneItem",
		"itemHeight",
		"hdr",
		"pnmfi",
		"index",
		"plvfi",
		"item",
		"newItem",
		"string",
		"strings",
		"buffer",
		"byteCount",
		"image",
		"images",
		"state",
		"nmcd",
		"item",
		"hFont",
		"clrText",
		"clrTextBk",
		"hwndHeader",
		"count",
		"pos",
		"pt",
		"event",
		"pnmlv",
		"column",
		"pnmlv",
		"event",
		"pnmlv",
		"oldSelected",
		"newSelected",
		"hasMenu",
		"hasMenu",
		"nmrg",
		"OS",
		"OS",
		"TableClass",
		"lpWndClass",
		"TableProc",
		"lpWndClass",
		"parent",
		"style",
		"items",
		"index",
		"items",
		"index",
		"items",
		"index",
		"SWT",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"SWT",
		"typedListener",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"handle",
		"msg",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"checkSelection",
		"OS",
		"OS",
		"OS",
		"OS",
		"checkSelection",
		"checkFilter",
		"OS",
		"checkSelection",
		"checkActivate",
		"wasSelected",
		"checkSelection",
		"wasSelected",
		"checkActivate",
		"ignoreActivate",
		"checkFilter",
		"display",
		"OS",
		"TableProc",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"checkFilter",
		"display",
		"checkActivate",
		"ignoreActivate",
		"checkSelection",
		"wasSelected",
		"forceSelect",
		"OS",
		"handle",
		"OS",
		"OS",
		"index",
		"event",
		"index",
		"SWT",
		"event",
		"wasSelected",
		"oldSelected",
		"code",
		"style",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"item",
		"style",
		"SWT",
		"item",
		"event",
		"item",
		"currentItem",
		"item",
		"SWT",
		"event",
		"currentItem",
		"item",
		"redraw",
		"item",
		"item",
		"SWT",
		"OS",
		"handle",
		"OS",
		"index",
		"index",
		"count",
		"SWT",
		"items",
		"index",
		"item",
		"item",
		"currentItem",
		"item",
		"style",
		"SWT",
		"item",
		"lvItem",
		"OS",
		"OS",
		"lvItem",
		"OS",
		"lvItem",
		"index",
		"OS",
		"handle",
		"OS",
		"lvItem",
		"item",
		"currentItem",
		"drawCount",
		"OS",
		"handle",
		"OS",
		"handle",
		"OS",
		"index",
		"index",
		"item",
		"start",
		"end",
		"OS",
		"handle",
		"OS",
		"start",
		"start",
		"end",
		"end",
		"count",
		"SWT",
		"start",
		"end",
		"count",
		"start",
		"i",
		"end",
		"i",
		"items",
		"i",
		"item",
		"item",
		"currentItem",
		"cleared",
		"item",
		"style",
		"SWT",
		"item",
		"lvItem",
		"lvItem",
		"lvItem",
		"OS",
		"OS",
		"lvItem",
		"OS",
		"lvItem",
		"i",
		"OS",
		"handle",
		"OS",
		"lvItem",
		"item",
		"cleared",
		"currentItem",
		"drawCount",
		"OS",
		"handle",
		"OS",
		"handle",
		"OS",
		"start",
		"end",
		"start",
		"end",
		"items",
		"start",
		"item",
		"indices",
		"SWT",
		"indices",
		"OS",
		"handle",
		"OS",
		"i",
		"indices",
		"i",
		"indices",
		"i",
		"indices",
		"i",
		"count",
		"SWT",
		"i",
		"indices",
		"i",
		"indices",
		"i",
		"items",
		"index",
		"item",
		"item",
		"currentItem",
		"cleared",
		"item",
		"style",
		"SWT",
		"item",
		"lvItem",
		"lvItem",
		"lvItem",
		"OS",
		"OS",
		"lvItem",
		"OS",
		"lvItem",
		"i",
		"OS",
		"handle",
		"OS",
		"lvItem",
		"item",
		"currentItem",
		"drawCount",
		"OS",
		"handle",
		"OS",
		"handle",
		"OS",
		"index",
		"index",
		"cleared",
		"OS",
		"handle",
		"OS",
		"i",
		"count",
		"i",
		"items",
		"i",
		"item",
		"item",
		"currentItem",
		"cleared",
		"item",
		"style",
		"SWT",
		"item",
		"lvItem",
		"lvItem",
		"lvItem",
		"OS",
		"OS",
		"lvItem",
		"OS",
		"lvItem",
		"i",
		"OS",
		"handle",
		"OS",
		"lvItem",
		"item",
		"cleared",
		"currentItem",
		"drawCount",
		"OS",
		"handle",
		"OS",
		"handle",
		"OS",
		"count",
		"fixScrollWidth",
		"wHint",
		"SWT",
		"bits",
		"wHint",
		"OS",
		"handle",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"i",
		"count",
		"i",
		"width",
		"OS",
		"handle",
		"OS",
		"i",
		"bits",
		"width",
		"hHint",
		"SWT",
		"bits",
		"hHint",
		"OS",
		"handle",
		"OS",
		"bits",
		"result",
		"result",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"height",
		"oneItem",
		"empty",
		"width",
		"width",
		"DEFAULT_WIDTH",
		"height",
		"height",
		"DEFAULT_HEIGHT",
		"wHint",
		"SWT",
		"width",
		"wHint",
		"hHint",
		"SWT",
		"height",
		"hHint",
		"width",
		"border",
		"height",
		"border",
		"style",
		"SWT",
		"width",
		"OS",
		"OS",
		"style",
		"SWT",
		"height",
		"OS",
		"OS",
		"width",
		"height",
		"state",
		"CANVAS",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"oneItem",
		"empty",
		"width",
		"width",
		"height",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"hFont",
		"lvColumn",
		"OS",
		"OS",
		"OS",
		"hHeap",
		"OS",
		"TCHAR",
		"lvColumn",
		"pszText",
		"OS",
		"handle",
		"OS",
		"lvColumn",
		"OS",
		"hHeap",
		"pszText",
		"OS",
		"OS",
		"style",
		"SWT",
		"bits1",
		"OS",
		"OS",
		"handle",
		"OS",
		"bits1",
		"bits1",
		"OS",
		"OS",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"bits2",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"count",
		"count",
		"columns",
		"count",
		"index",
		"index",
		"count",
		"SWT",
		"count",
		"columns",
		"columns",
		"System",
		"columns",
		"newColumns",
		"columns",
		"columns",
		"newColumns",
		"OS",
		"handle",
		"OS",
		"i",
		"itemCount",
		"i",
		"items",
		"i",
		"item",
		"item",
		"strings",
		"columnCount",
		"System",
		"strings",
		"temp",
		"index",
		"System",
		"strings",
		"index",
		"temp",
		"index",
		"columnCount",
		"index",
		"item",
		"temp",
		"item",
		"images",
		"columnCount",
		"System",
		"images",
		"temp",
		"index",
		"System",
		"images",
		"index",
		"temp",
		"index",
		"columnCount",
		"index",
		"item",
		"temp",
		"index",
		"count",
		"strings",
		"item",
		"columnCount",
		"item",
		"item",
		"item",
		"images",
		"item",
		"columnCount",
		"item",
		"item",
		"item",
		"item",
		"item",
		"columnCount",
		"System",
		"cellBackground",
		"temp",
		"index",
		"System",
		"cellBackground",
		"index",
		"temp",
		"index",
		"columnCount",
		"index",
		"temp",
		"index",
		"item",
		"temp",
		"item",
		"item",
		"columnCount",
		"System",
		"cellForeground",
		"temp",
		"index",
		"System",
		"cellForeground",
		"index",
		"temp",
		"index",
		"columnCount",
		"index",
		"temp",
		"index",
		"item",
		"temp",
		"item",
		"item",
		"columnCount",
		"System",
		"cellFont",
		"temp",
		"index",
		"System",
		"cellFont",
		"index",
		"temp",
		"index",
		"columnCount",
		"index",
		"temp",
		"index",
		"item",
		"temp",
		"System",
		"columns",
		"index",
		"columns",
		"index",
		"count",
		"index",
		"columns",
		"index",
		"column",
		"ignoreResize",
		"index",
		"count",
		"lvColumn",
		"OS",
		"OS",
		"handle",
		"OS",
		"lvColumn",
		"OS",
		"handle",
		"OS",
		"lvColumn",
		"lvColumn",
		"OS",
		"cchTextMax",
		"TCHAR",
		"OS",
		"hHeap",
		"OS",
		"byteCount",
		"lvColumn",
		"OS",
		"OS",
		"OS",
		"OS",
		"lvColumn",
		"pszText",
		"lvColumn",
		"cchTextMax",
		"OS",
		"handle",
		"OS",
		"lvColumn",
		"OS",
		"handle",
		"OS",
		"lvColumn",
		"lvColumn",
		"OS",
		"lvColumn",
		"width",
		"lvColumn",
		"OS",
		"lvColumn",
		"lvColumn",
		"OS",
		"handle",
		"OS",
		"lvColumn",
		"lvColumn",
		"OS",
		"lvColumn",
		"OS",
		"OS",
		"handle",
		"OS",
		"lvColumn",
		"pszText",
		"OS",
		"hHeap",
		"pszText",
		"OS",
		"handle",
		"OS",
		"parent",
		"SWT",
		"lvItem",
		"OS",
		"OS",
		"lvItem",
		"OS",
		"lvItem",
		"OS",
		"i",
		"itemCount",
		"i",
		"lvItem",
		"i",
		"OS",
		"handle",
		"OS",
		"lvItem",
		"OS",
		"column",
		"SWT",
		"SWT",
		"fmt",
		"OS",
		"column",
		"SWT",
		"SWT",
		"fmt",
		"OS",
		"lvColumn",
		"OS",
		"OS",
		"lvColumn",
		"fmt",
		"OS",
		"handle",
		"OS",
		"index",
		"lvColumn",
		"ignoreResize",
		"OS",
		"handle",
		"OS",
		"index",
		"index",
		"count",
		"SWT",
		"count",
		"items",
		"drawCount",
		"OS",
		"handle",
		"small",
		"items",
		"Math",
		"items",
		"length",
		"System",
		"items",
		"newItems",
		"items",
		"items",
		"newItems",
		"lvItem",
		"OS",
		"OS",
		"lvItem",
		"index",
		"lvItem",
		"OS",
		"lvItem",
		"OS",
		"ignoreSelect",
		"OS",
		"handle",
		"OS",
		"lvItem",
		"ignoreSelect",
		"result",
		"SWT",
		"System",
		"items",
		"index",
		"items",
		"index",
		"count",
		"index",
		"items",
		"index",
		"item",
		"items",
		"columns",
		"style",
		"SWT",
		"customDraw",
		"OS",
		"OS",
		"indices",
		"SWT",
		"indices",
		"lvItem",
		"OS",
		"i",
		"indices",
		"i",
		"indices",
		"i",
		"ignoreSelect",
		"OS",
		"handle",
		"OS",
		"indices",
		"i",
		"lvItem",
		"ignoreSelect",
		"index",
		"lvItem",
		"OS",
		"ignoreSelect",
		"OS",
		"handle",
		"OS",
		"index",
		"lvItem",
		"ignoreSelect",
		"OS",
		"handle",
		"OS",
		"start",
		"end",
		"count",
		"lvItem",
		"OS",
		"start",
		"Math",
		"start",
		"start",
		"i",
		"end",
		"i",
		"ignoreSelect",
		"OS",
		"handle",
		"OS",
		"i",
		"lvItem",
		"ignoreSelect",
		"lvItem",
		"OS",
		"lvItem",
		"OS",
		"ignoreSelect",
		"OS",
		"handle",
		"OS",
		"lvItem",
		"ignoreSelect",
		"OS",
		"handle",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"index",
		"columnCount",
		"columns",
		"index",
		"column",
		"index",
		"index",
		"first",
		"columnCount",
		"index",
		"OS",
		"cchTextMax",
		"TCHAR",
		"OS",
		"hHeap",
		"OS",
		"byteCount",
		"lvColumn",
		"OS",
		"OS",
		"lvColumn",
		"pszText",
		"lvColumn",
		"cchTextMax",
		"OS",
		"handle",
		"OS",
		"lvColumn",
		"lvColumn",
		"OS",
		"lvColumn",
		"OS",
		"OS",
		"handle",
		"OS",
		"lvColumn",
		"pszText",
		"OS",
		"hHeap",
		"pszText",
		"OS",
		"OS",
		"hHeap",
		"OS",
		"TCHAR",
		"lvColumn",
		"OS",
		"lvColumn",
		"pszText",
		"OS",
		"handle",
		"OS",
		"lvColumn",
		"pszText",
		"OS",
		"hHeap",
		"pszText",
		"parent",
		"SWT",
		"lvItem",
		"OS",
		"OS",
		"lvItem",
		"OS",
		"lvItem",
		"OS",
		"OS",
		"handle",
		"OS",
		"i",
		"itemCount",
		"i",
		"lvItem",
		"i",
		"OS",
		"handle",
		"OS",
		"lvItem",
		"columnCount",
		"OS",
		"handle",
		"OS",
		"index",
		"SWT",
		"first",
		"index",
		"System",
		"columns",
		"index",
		"columns",
		"index",
		"columnCount",
		"index",
		"columns",
		"columnCount",
		"OS",
		"handle",
		"OS",
		"i",
		"itemCount",
		"i",
		"items",
		"i",
		"item",
		"columnCount",
		"item",
		"item",
		"item",
		"item",
		"item",
		"item",
		"item",
		"index",
		"item",
		"strings",
		"strings",
		"columnCount",
		"System",
		"strings",
		"temp",
		"index",
		"System",
		"strings",
		"index",
		"temp",
		"index",
		"columnCount",
		"index",
		"item",
		"temp",
		"index",
		"item",
		"item",
		"item",
		"index",
		"item",
		"images",
		"columnCount",
		"System",
		"images",
		"temp",
		"index",
		"System",
		"images",
		"index",
		"temp",
		"index",
		"columnCount",
		"index",
		"item",
		"temp",
		"index",
		"item",
		"item",
		"item",
		"columnCount",
		"System",
		"cellBackground",
		"temp",
		"index",
		"System",
		"cellBackground",
		"index",
		"temp",
		"index",
		"columnCount",
		"index",
		"item",
		"temp",
		"item",
		"item",
		"columnCount",
		"System",
		"cellForeground",
		"temp",
		"index",
		"System",
		"cellForeground",
		"index",
		"temp",
		"index",
		"columnCount",
		"index",
		"item",
		"temp",
		"item",
		"item",
		"columnCount",
		"System",
		"cellFont",
		"temp",
		"index",
		"System",
		"cellFont",
		"index",
		"temp",
		"index",
		"columnCount",
		"index",
		"item",
		"temp",
		"columnCount",
		"OS",
		"handle",
		"OS",
		"index",
		"count",
		"items",
		"index",
		"item",
		"index",
		"index",
		"count",
		"ignoreSelect",
		"ignoreShrink",
		"OS",
		"handle",
		"OS",
		"index",
		"ignoreSelect",
		"ignoreShrink",
		"code",
		"SWT",
		"System",
		"items",
		"index",
		"items",
		"index",
		"count",
		"index",
		"items",
		"count",
		"count",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"OS",
		"hImageList",
		"OS",
		"hImageList",
		"cx",
		"cy",
		"OS",
		"handle",
		"OS",
		"OS",
		"hOldStateList",
		"OS",
		"hOldStateList",
		"stateCx",
		"stateCy",
		"cx",
		"stateCx",
		"cy",
		"stateCy",
		"cx",
		"cy",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"count",
		"columns",
		"count",
		"index",
		"index",
		"count",
		"SWT",
		"columns",
		"index",
		"OS",
		"handle",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"count",
		"columns",
		"count",
		"count",
		"OS",
		"handle",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"count",
		"columns",
		"count",
		"OS",
		"handle",
		"OS",
		"count",
		"order",
		"order",
		"OS",
		"handle",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"count",
		"columns",
		"count",
		"count",
		"System",
		"columns",
		"result",
		"count",
		"result",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"pixel",
		"OS",
		"OS",
		"OS",
		"pixel",
		"GRID_WIDTH",
		"OS",
		"handle",
		"OS",
		"hwndHeader",
		"OS",
		"hwndHeader",
		"rect",
		"rect",
		"rect",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"OS",
		"handle",
		"OS",
		"index",
		"index",
		"count",
		"SWT",
		"index",
		"point",
		"SWT",
		"pinfo",
		"point",
		"pinfo",
		"point",
		"OS",
		"handle",
		"OS",
		"pinfo",
		"pinfo",
		"pinfo",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"oneItem",
		"empty",
		"OS",
		"handle",
		"OS",
		"count",
		"style",
		"SWT",
		"i",
		"count",
		"i",
		"result",
		"i",
		"i",
		"System",
		"items",
		"result",
		"count",
		"result",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"OS",
		"handle",
		"OS",
		"count",
		"i",
		"OS",
		"handle",
		"OS",
		"i",
		"OS",
		"result",
		"j",
		"i",
		"result",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"focusIndex",
		"selectedIndex",
		"selectedIndex",
		"i",
		"OS",
		"handle",
		"OS",
		"i",
		"OS",
		"i",
		"focusIndex",
		"i",
		"selectedIndex",
		"OS",
		"handle",
		"OS",
		"count",
		"i",
		"OS",
		"handle",
		"OS",
		"i",
		"OS",
		"result",
		"j",
		"i",
		"result",
		"Math",
		"OS",
		"handle",
		"OS",
		"image",
		"OS",
		"imageList",
		"image",
		"imageList",
		"display",
		"style",
		"SWT",
		"bounds",
		"bounds",
		"imageList",
		"image",
		"index",
		"index",
		"imageList",
		"image",
		"imageList",
		"OS",
		"handle",
		"OS",
		"OS",
		"hImageList",
		"topIndex",
		"index",
		"imageList",
		"image",
		"index",
		"index",
		"imageList",
		"image",
		"column",
		"SWT",
		"OS",
		"handle",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"i",
		"count",
		"i",
		"columns",
		"i",
		"column",
		"i",
		"item",
		"SWT",
		"OS",
		"handle",
		"OS",
		"lastIndexOf",
		"lastIndexOf",
		"count",
		"items",
		"lastIndexOf",
		"item",
		"lastIndexOf",
		"items",
		"lastIndexOf",
		"item",
		"lastIndexOf",
		"items",
		"lastIndexOf",
		"item",
		"lastIndexOf",
		"lastIndexOf",
		"count",
		"i",
		"count",
		"i",
		"items",
		"i",
		"item",
		"lastIndexOf",
		"i",
		"count",
		"i",
		"i",
		"items",
		"i",
		"item",
		"lastIndexOf",
		"i",
		"lvItem",
		"OS",
		"lvItem",
		"OS",
		"lvItem",
		"index",
		"OS",
		"handle",
		"OS",
		"lvItem",
		"result",
		"lvItem",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"columnCount",
		"columns",
		"columnCount",
		"OS",
		"handle",
		"OS",
		"OS",
		"columnCount",
		"OS",
		"handle",
		"OS",
		"itemCount",
		"i",
		"i",
		"items",
		"i",
		"ignoreSelect",
		"ignoreShrink",
		"OS",
		"handle",
		"OS",
		"i",
		"ignoreSelect",
		"ignoreShrink",
		"item",
		"item",
		"item",
		"i",
		"itemCount",
		"i",
		"items",
		"i",
		"item",
		"item",
		"item",
		"customDraw",
		"currentItem",
		"items",
		"i",
		"columnCount",
		"i",
		"columns",
		"i",
		"column",
		"column",
		"columns",
		"imageList",
		"OS",
		"handle",
		"OS",
		"OS",
		"display",
		"imageList",
		"imageList",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"hOldList",
		"OS",
		"hOldList",
		"indices",
		"SWT",
		"indices",
		"indices",
		"System",
		"indices",
		"newIndices",
		"indices",
		"newIndices",
		"newIndices",
		"newIndices",
		"newIndices",
		"OS",
		"handle",
		"OS",
		"start",
		"start",
		"end",
		"end",
		"count",
		"SWT",
		"i",
		"newIndices",
		"i",
		"newIndices",
		"i",
		"index",
		"last",
		"items",
		"index",
		"ignoreSelect",
		"ignoreShrink",
		"OS",
		"handle",
		"OS",
		"index",
		"ignoreSelect",
		"ignoreShrink",
		"code",
		"SWT",
		"item",
		"item",
		"item",
		"System",
		"items",
		"index",
		"items",
		"index",
		"count",
		"index",
		"items",
		"count",
		"last",
		"index",
		"count",
		"OS",
		"handle",
		"OS",
		"index",
		"index",
		"count",
		"SWT",
		"items",
		"index",
		"ignoreSelect",
		"ignoreShrink",
		"OS",
		"handle",
		"OS",
		"index",
		"ignoreSelect",
		"ignoreShrink",
		"code",
		"SWT",
		"item",
		"item",
		"item",
		"System",
		"items",
		"index",
		"items",
		"index",
		"count",
		"index",
		"items",
		"count",
		"count",
		"start",
		"end",
		"OS",
		"handle",
		"OS",
		"start",
		"start",
		"end",
		"end",
		"count",
		"SWT",
		"start",
		"end",
		"count",
		"start",
		"index",
		"end",
		"items",
		"index",
		"ignoreSelect",
		"ignoreShrink",
		"OS",
		"handle",
		"OS",
		"start",
		"ignoreSelect",
		"ignoreShrink",
		"code",
		"item",
		"item",
		"item",
		"index",
		"System",
		"items",
		"index",
		"items",
		"start",
		"count",
		"index",
		"count",
		"index",
		"start",
		"i",
		"count",
		"i",
		"items",
		"i",
		"index",
		"end",
		"SWT",
		"OS",
		"handle",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"columnCount",
		"columns",
		"columnCount",
		"OS",
		"handle",
		"OS",
		"OS",
		"columnCount",
		"drawCount",
		"OS",
		"handle",
		"redraw",
		"OS",
		"handle",
		"OS",
		"itemCount",
		"index",
		"items",
		"index",
		"ignoreSelect",
		"ignoreShrink",
		"OS",
		"handle",
		"OS",
		"index",
		"ignoreSelect",
		"ignoreShrink",
		"code",
		"item",
		"item",
		"item",
		"index",
		"redraw",
		"OS",
		"handle",
		"OS",
		"index",
		"SWT",
		"ignoreSelect",
		"ignoreShrink",
		"OS",
		"handle",
		"OS",
		"ignoreSelect",
		"ignoreShrink",
		"code",
		"SWT",
		"i",
		"itemCount",
		"i",
		"items",
		"i",
		"item",
		"item",
		"item",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"eventTable",
		"SWT",
		"listener",
		"indices",
		"SWT",
		"indices",
		"length",
		"style",
		"SWT",
		"length",
		"lvItem",
		"OS",
		"lvItem",
		"OS",
		"length",
		"i",
		"i",
		"indices",
		"i",
		"ignoreSelect",
		"OS",
		"handle",
		"OS",
		"indices",
		"i",
		"lvItem",
		"ignoreSelect",
		"index",
		"lvItem",
		"OS",
		"lvItem",
		"OS",
		"ignoreSelect",
		"OS",
		"handle",
		"OS",
		"index",
		"lvItem",
		"ignoreSelect",
		"end",
		"start",
		"end",
		"style",
		"SWT",
		"start",
		"end",
		"OS",
		"handle",
		"OS",
		"count",
		"start",
		"count",
		"start",
		"Math",
		"start",
		"end",
		"Math",
		"end",
		"count",
		"start",
		"end",
		"count",
		"lvItem",
		"OS",
		"lvItem",
		"OS",
		"start",
		"i",
		"end",
		"i",
		"ignoreSelect",
		"OS",
		"handle",
		"OS",
		"i",
		"lvItem",
		"ignoreSelect",
		"style",
		"SWT",
		"lvItem",
		"OS",
		"lvItem",
		"OS",
		"lvItem",
		"OS",
		"ignoreSelect",
		"OS",
		"handle",
		"OS",
		"lvItem",
		"ignoreSelect",
		"pinfo",
		"lParam",
		"pinfo",
		"lParam",
		"OS",
		"handle",
		"OS",
		"pinfo",
		"type",
		"button",
		"handle",
		"msg",
		"wParam",
		"lParam",
		"OS",
		"handle",
		"pinfo",
		"OS",
		"handle",
		"OS",
		"handle",
		"LRESULT",
		"OS",
		"handle",
		"OS",
		"count",
		"pinfo",
		"lvItem",
		"OS",
		"lvItem",
		"OS",
		"lvItem",
		"pinfo",
		"OS",
		"handle",
		"OS",
		"lvItem",
		"lvItem",
		"OS",
		"forceSelect",
		"dragStarted",
		"handle",
		"msg",
		"wParam",
		"lParam",
		"forceSelect",
		"dragStarted",
		"OS",
		"handle",
		"OS",
		"handle",
		"OS",
		"OS",
		"pinfo",
		"flags",
		"fakeMouseUp",
		"style",
		"SWT",
		"fakeMouseUp",
		"pinfo",
		"OS",
		"fakeMouseUp",
		"SWT",
		"button",
		"handle",
		"msg",
		"wParam",
		"lParam",
		"dragStarted",
		"code",
		"background",
		"pixel",
		"background",
		"pixel",
		"pixel",
		"pixel",
		"OS",
		"handle",
		"OS",
		"pixel",
		"OS",
		"handle",
		"OS",
		"pixel",
		"style",
		"SWT",
		"OS",
		"handle",
		"flags",
		"OS",
		"fixResize",
		"rect",
		"fixResize",
		"x",
		"y",
		"width",
		"height",
		"flags",
		"fixResize",
		"order",
		"SWT",
		"OS",
		"handle",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"count",
		"columns",
		"order",
		"SWT",
		"order",
		"count",
		"SWT",
		"count",
		"OS",
		"handle",
		"OS",
		"count",
		"oldOrder",
		"count",
		"i",
		"order",
		"i",
		"order",
		"i",
		"index",
		"index",
		"count",
		"SWT",
		"seen",
		"index",
		"SWT",
		"seen",
		"index",
		"index",
		"oldOrder",
		"i",
		"reorder",
		"reorder",
		"count",
		"i",
		"count",
		"i",
		"oldRects",
		"i",
		"OS",
		"hwndHeader",
		"OS",
		"i",
		"oldRects",
		"i",
		"OS",
		"handle",
		"OS",
		"order",
		"order",
		"OS",
		"handle",
		"count",
		"System",
		"columns",
		"newColumns",
		"count",
		"i",
		"count",
		"i",
		"newColumns",
		"i",
		"column",
		"OS",
		"hwndHeader",
		"OS",
		"i",
		"newRect",
		"newRect",
		"oldRects",
		"i",
		"column",
		"SWT",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"OS",
		"hOldStateList",
		"OS",
		"hOldStateList",
		"cx",
		"cy",
		"cx",
		"cy",
		"style",
		"SWT",
		"ImageList",
		"style",
		"SWT",
		"flags",
		"OS",
		"OS",
		"OS",
		"flags",
		"OS",
		"OS",
		"width",
		"height",
		"flags",
		"count",
		"count",
		"OS",
		"handle",
		"OS",
		"hDC",
		"OS",
		"hDC",
		"width",
		"count",
		"height",
		"OS",
		"memDC",
		"hBitmap",
		"OS",
		"rect",
		"width",
		"count",
		"height",
		"OS",
		"clrBackground",
		"OS",
		"memDC",
		"rect",
		"hBrush",
		"OS",
		"hBrush",
		"OS",
		"hDC",
		"OS",
		"OS",
		"hDC",
		"tm",
		"OS",
		"hDC",
		"oldFont",
		"Math",
		"tm",
		"width",
		"Math",
		"tm",
		"height",
		"width",
		"itemWidth",
		"height",
		"itemHeight",
		"OS",
		"rect",
		"left",
		"top",
		"left",
		"itemWidth",
		"top",
		"itemHeight",
		"OS",
		"OS",
		"OS",
		"handle",
		"BUTTON",
		"OS",
		"hTheme",
		"memDC",
		"OS",
		"OS",
		"rect",
		"rect",
		"width",
		"rect",
		"width",
		"OS",
		"hTheme",
		"memDC",
		"OS",
		"OS",
		"rect",
		"rect",
		"width",
		"rect",
		"width",
		"OS",
		"hTheme",
		"memDC",
		"OS",
		"OS",
		"rect",
		"rect",
		"width",
		"rect",
		"width",
		"OS",
		"hTheme",
		"memDC",
		"OS",
		"OS",
		"rect",
		"OS",
		"hTheme",
		"OS",
		"memDC",
		"rect",
		"OS",
		"OS",
		"OS",
		"rect",
		"width",
		"rect",
		"width",
		"OS",
		"memDC",
		"rect",
		"OS",
		"OS",
		"OS",
		"OS",
		"rect",
		"width",
		"rect",
		"width",
		"OS",
		"memDC",
		"rect",
		"OS",
		"OS",
		"OS",
		"OS",
		"rect",
		"width",
		"rect",
		"width",
		"OS",
		"memDC",
		"rect",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"memDC",
		"hOldBitmap",
		"OS",
		"memDC",
		"OS",
		"handle",
		"hDC",
		"OS",
		"OS",
		"OS",
		"hImageList",
		"hBitmap",
		"OS",
		"hImageList",
		"hBitmap",
		"clrBackground",
		"OS",
		"hBitmap",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"hImageList",
		"hOldStateList",
		"OS",
		"hOldStateList",
		"index",
		"lvItem",
		"OS",
		"lvItem",
		"OS",
		"ignoreSelect",
		"OS",
		"handle",
		"OS",
		"index",
		"lvItem",
		"ignoreSelect",
		"font",
		"topIndex",
		"OS",
		"handle",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"bits",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"foreground",
		"pixel",
		"foreground",
		"pixel",
		"pixel",
		"pixel",
		"OS",
		"OS",
		"handle",
		"OS",
		"pixel",
		"OS",
		"handle",
		"OS",
		"handle",
		"OS",
		"newBits",
		"OS",
		"show",
		"newBits",
		"OS",
		"OS",
		"handle",
		"OS",
		"newBits",
		"topIndex",
		"show",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"count",
		"Math",
		"count",
		"OS",
		"handle",
		"OS",
		"count",
		"itemCount",
		"style",
		"SWT",
		"isVirtual",
		"count",
		"index",
		"itemCount",
		"items",
		"index",
		"isVirtual",
		"ignoreSelect",
		"ignoreShrink",
		"OS",
		"handle",
		"OS",
		"count",
		"ignoreSelect",
		"ignoreShrink",
		"code",
		"item",
		"item",
		"item",
		"index",
		"index",
		"itemCount",
		"SWT",
		"Math",
		"count",
		"length",
		"System",
		"items",
		"newItems",
		"Math",
		"count",
		"itemCount",
		"items",
		"newItems",
		"isVirtual",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"count",
		"flags",
		"count",
		"itemCount",
		"OS",
		"handle",
		"itemCount",
		"i",
		"count",
		"i",
		"items",
		"i",
		"SWT",
		"i",
		"isVirtual",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"hOldList",
		"OS",
		"handle",
		"OS",
		"OS",
		"hwndHeader",
		"rect",
		"rect",
		"rect",
		"OS",
		"height",
		"OS",
		"handle",
		"OS",
		"OS",
		"hImageList",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"hImageList",
		"show",
		"newBits",
		"OS",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"newBits",
		"drawCount",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"state",
		"HIDDEN",
		"redraw",
		"drawCount",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"hwndHeader",
		"OS",
		"hwndHeader",
		"OS",
		"state",
		"HIDDEN",
		"state",
		"HIDDEN",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"handle",
		"hwndHeader",
		"OS",
		"hwndHeader",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"handle",
		"flags",
		"drawCount",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"hwndHeader",
		"OS",
		"hwndHeader",
		"OS",
		"currentItem",
		"currentItem",
		"item",
		"fixScrollWidth",
		"force",
		"drawCount",
		"OS",
		"handle",
		"fixScrollWidth",
		"fixScrollWidth",
		"OS",
		"handle",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"count",
		"columns",
		"count",
		"OS",
		"handle",
		"OS",
		"index",
		"count",
		"item",
		"string",
		"item",
		"imageIndent",
		"Math",
		"imageIndent",
		"item",
		"item",
		"font",
		"item",
		"font",
		"font",
		"item",
		"items",
		"index",
		"items",
		"index",
		"string",
		"tableItem",
		"imageIndent",
		"Math",
		"imageIndent",
		"tableItem",
		"tableItem",
		"font",
		"tableItem",
		"font",
		"font",
		"tableItem",
		"string",
		"string",
		"font",
		"OS",
		"handle",
		"OS",
		"hDC",
		"font",
		"OS",
		"OS",
		"OS",
		"string",
		"OS",
		"hDC",
		"buffer",
		"buffer",
		"rect",
		"flags",
		"OS",
		"hDC",
		"oldFont",
		"OS",
		"handle",
		"hDC",
		"newWidth",
		"Math",
		"newWidth",
		"rect",
		"rect",
		"string",
		"newWidth",
		"Math",
		"newWidth",
		"OS",
		"handle",
		"OS",
		"buffer",
		"item",
		"index",
		"OS",
		"handle",
		"OS",
		"OS",
		"hStateList",
		"OS",
		"hStateList",
		"cx",
		"cy",
		"newWidth",
		"cx",
		"INSET",
		"OS",
		"handle",
		"OS",
		"OS",
		"hImageList",
		"OS",
		"hImageList",
		"cx",
		"cy",
		"newWidth",
		"imageIndent",
		"cx",
		"newWidth",
		"newWidth",
		"INSET",
		"OS",
		"handle",
		"OS",
		"newWidth",
		"oldWidth",
		"OS",
		"handle",
		"OS",
		"newWidth",
		"indices",
		"SWT",
		"indices",
		"length",
		"style",
		"SWT",
		"length",
		"indices",
		"indices",
		"focusIndex",
		"focusIndex",
		"items",
		"SWT",
		"items",
		"length",
		"style",
		"SWT",
		"length",
		"length",
		"i",
		"i",
		"items",
		"i",
		"index",
		"focusIndex",
		"index",
		"focusIndex",
		"focusIndex",
		"index",
		"index",
		"index",
		"end",
		"start",
		"end",
		"style",
		"SWT",
		"start",
		"end",
		"OS",
		"handle",
		"OS",
		"count",
		"start",
		"count",
		"start",
		"Math",
		"start",
		"end",
		"Math",
		"end",
		"count",
		"start",
		"end",
		"start",
		"imageList",
		"OS",
		"handle",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"columnCount",
		"columns",
		"columnCount",
		"i",
		"columnCount",
		"columns",
		"i",
		"column",
		"i",
		"i",
		"columnCount",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"hImageList",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"hImageList",
		"display",
		"imageList",
		"imageList",
		"style",
		"SWT",
		"customDraw",
		"items",
		"OS",
		"handle",
		"OS",
		"index",
		"topIndex",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"index",
		"index",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"index",
		"rect",
		"OS",
		"OS",
		"handle",
		"OS",
		"rect",
		"index",
		"topIndex",
		"rect",
		"rect",
		"OS",
		"handle",
		"OS",
		"dy",
		"column",
		"SWT",
		"column",
		"SWT",
		"column",
		"column",
		"index",
		"OS",
		"handle",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"count",
		"index",
		"index",
		"count",
		"rect",
		"OS",
		"index",
		"rect",
		"OS",
		"handle",
		"OS",
		"rect",
		"rect",
		"rect",
		"OS",
		"handle",
		"OS",
		"rect",
		"rect",
		"width",
		"rect",
		"index",
		"OS",
		"handle",
		"OS",
		"rect",
		"OS",
		"handle",
		"area",
		"rect",
		"area",
		"rect",
		"area",
		"OS",
		"handle",
		"OS",
		"dx",
		"Math",
		"area",
		"area",
		"rect",
		"rect",
		"rect",
		"width",
		"area",
		"rect",
		"width",
		"area",
		"OS",
		"handle",
		"OS",
		"dx",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"index",
		"index",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"index",
		"OS",
		"handle",
		"OS",
		"index",
		"item",
		"SWT",
		"item",
		"SWT",
		"item",
		"index",
		"index",
		"OS",
		"handle",
		"OS",
		"OS",
		"index",
		"index",
		"OS",
		"handle",
		"OS",
		"hwndToolTip",
		"hdr",
		"toolTipText",
		"hdr",
		"OS",
		"handle",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"count",
		"columns",
		"count",
		"index",
		"count",
		"columns",
		"index",
		"index",
		"index",
		"count",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"newBits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"bits",
		"OS",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"bits",
		"TableClass",
		"TableProc",
		"wParam",
		"lParam",
		"result",
		"result",
		"wParam",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"OS",
		"index",
		"index",
		"item",
		"item",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"index",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"code",
		"SWT",
		"OS",
		"handle",
		"OS",
		"OS",
		"index",
		"event",
		"index",
		"SWT",
		"event",
		"LRESULT",
		"result",
		"wParam",
		"lParam",
		"result",
		"result",
		"result",
		"style",
		"SWT",
		"accessible",
		"accessible",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"result",
		"result",
		"wParam",
		"OS",
		"LRESULT",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"result",
		"wParam",
		"lParam",
		"style",
		"SWT",
		"imageList",
		"style",
		"SWT",
		"OS",
		"handle",
		"result",
		"pinfo",
		"lParam",
		"pinfo",
		"lParam",
		"OS",
		"handle",
		"OS",
		"pinfo",
		"SWT",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"SWT",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"pinfo",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"OS",
		"handle",
		"OS",
		"handle",
		"style",
		"SWT",
		"index",
		"pinfo",
		"OS",
		"index",
		"item",
		"item",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"index",
		"LRESULT",
		"SWT",
		"OS",
		"wParam",
		"lParam",
		"style",
		"SWT",
		"pinfo",
		"lParam",
		"pinfo",
		"lParam",
		"OS",
		"handle",
		"OS",
		"pinfo",
		"index",
		"pinfo",
		"OS",
		"index",
		"item",
		"item",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"index",
		"result",
		"wParam",
		"lParam",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"OS",
		"bits",
		"mask",
		"result",
		"LRESULT",
		"ignoreShrink",
		"OS",
		"handle",
		"OS",
		"items",
		"items",
		"count",
		"Math",
		"count",
		"length",
		"System",
		"items",
		"newItems",
		"count",
		"items",
		"newItems",
		"fixScrollWidth",
		"wParam",
		"lParam",
		"OS",
		"hdr",
		"lParam",
		"NMHDR",
		"OS",
		"handle",
		"OS",
		"hdr",
		"hwndHeader",
		"hdr",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"count",
		"columns",
		"LRESULT",
		"OS",
		"phdn",
		"lParam",
		"NMHEADER",
		"columns",
		"phdn",
		"column",
		"column",
		"LRESULT",
		"OS",
		"cancelMove",
		"OS",
		"cancelMove",
		"LRESULT",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"count",
		"columns",
		"LRESULT",
		"OS",
		"phdn",
		"lParam",
		"NMHEADER",
		"phdn",
		"columns",
		"phdn",
		"column",
		"column",
		"cancelMove",
		"LRESULT",
		"OS",
		"cancelMove",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"OS",
		"phdn",
		"lParam",
		"NMHEADER",
		"phdn",
		"phdn",
		"OS",
		"pitem",
		"phdn",
		"HDITEM",
		"pitem",
		"OS",
		"pitem",
		"OS",
		"hwndHeader",
		"OS",
		"count",
		"columns",
		"count",
		"OS",
		"handle",
		"OS",
		"count",
		"order",
		"index",
		"order",
		"order",
		"index",
		"phdn",
		"index",
		"index",
		"order",
		"index",
		"index",
		"pitem",
		"Math",
		"index",
		"pitem",
		"Math",
		"index",
		"pitem",
		"start",
		"i",
		"end",
		"i",
		"columns",
		"order",
		"i",
		"column",
		"column",
		"SWT",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"lastWidth",
		"width",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"OS",
		"handle",
		"rect",
		"rect",
		"rect",
		"width",
		"OS",
		"handle",
		"rect",
		"lastWidth",
		"width",
		"ignoreResize",
		"OS",
		"phdn",
		"lParam",
		"NMHEADER",
		"phdn",
		"OS",
		"pitem",
		"phdn",
		"HDITEM",
		"pitem",
		"OS",
		"columns",
		"phdn",
		"column",
		"column",
		"SWT",
		"LRESULT",
		"OS",
		"hwndHeader",
		"OS",
		"count",
		"columns",
		"count",
		"count",
		"System",
		"columns",
		"newColumns",
		"count",
		"count",
		"OS",
		"handle",
		"OS",
		"count",
		"order",
		"i",
		"count",
		"i",
		"newColumns",
		"order",
		"i",
		"moved",
		"nextColumn",
		"nextColumn",
		"SWT",
		"nextColumn",
		"column",
		"moved",
		"OS",
		"OS",
		"OS",
		"phdn",
		"lParam",
		"NMHEADER",
		"columns",
		"phdn",
		"column",
		"column",
		"SWT",
		"wParam",
		"lParam",
		"result",
		"result",
		"hdr",
		"OS",
		"OS",
		"tipRequested",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"tipRequested",
		"code",
		"result",
		"pinfo",
		"lParam",
		"pinfo",
		"lParam",
		"OS",
		"handle",
		"OS",
		"pinfo",
		"SWT",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"SWT",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"pinfo",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"OS",
		"handle",
		"OS",
		"handle",
		"LRESULT",
		"SWT",
		"OS",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"OS",
		"handle",
		"OS",
		"count",
		"result",
		"OS",
		"handle",
		"OS",
		"OS",
		"index",
		"lvItem",
		"OS",
		"lvItem",
		"OS",
		"ignoreSelect",
		"OS",
		"handle",
		"OS",
		"lvItem",
		"ignoreSelect",
		"result",
		"wParam",
		"lParam",
		"result",
		"result",
		"background",
		"OS",
		"handle",
		"OS",
		"pixel",
		"OS",
		"handle",
		"OS",
		"pixel",
		"style",
		"SWT",
		"result",
		"wParam",
		"lParam",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"wParam",
		"code",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"hwndHeader",
		"OS",
		"hwndHeader",
		"rect",
		"headerHeight",
		"rect",
		"rect",
		"OS",
		"handle",
		"rect",
		"rect",
		"headerHeight",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"oneItem",
		"empty",
		"code",
		"OS",
		"rect",
		"rect",
		"itemHeight",
		"GRID_WIDTH",
		"rect",
		"rect",
		"itemHeight",
		"GRID_WIDTH",
		"OS",
		"handle",
		"rect",
		"OS",
		"OS",
		"OS",
		"handle",
		"result",
		"OS",
		"hdr",
		"lParam",
		"NMHDR",
		"hdr",
		"OS",
		"OS",
		"style",
		"SWT",
		"OS",
		"pnmfi",
		"lParam",
		"NMLVFINDITEM",
		"Math",
		"pnmfi",
		"index",
		"OS",
		"OS",
		"OS",
		"plvfi",
		"lParam",
		"NMLVDISPINFO",
		"plvfi",
		"item",
		"style",
		"SWT",
		"lastIndexOf",
		"plvfi",
		"item",
		"fixScrollWidth",
		"item",
		"newItem",
		"OS",
		"handle",
		"item",
		"plvfi",
		"OS",
		"plvfi",
		"string",
		"item",
		"item",
		"strings",
		"string",
		"strings",
		"plvfi",
		"string",
		"tipRequested",
		"string",
		"plvfi",
		"string",
		"string",
		"Math",
		"buffer",
		"plvfi",
		"TCHAR",
		"OS",
		"plvfi",
		"buffer",
		"byteCount",
		"OS",
		"plvfi",
		"byteCount",
		"TCHAR",
		"TCHAR",
		"plvfi",
		"Math",
		"plvfi",
		"string",
		"plvfi",
		"OS",
		"plvfi",
		"image",
		"item",
		"item",
		"images",
		"image",
		"images",
		"plvfi",
		"image",
		"plvfi",
		"image",
		"plvfi",
		"OS",
		"plvfi",
		"item",
		"state",
		"item",
		"state",
		"plvfi",
		"state",
		"plvfi",
		"OS",
		"plvfi",
		"OS",
		"plvfi",
		"plvfi",
		"item",
		"OS",
		"lParam",
		"plvfi",
		"NMLVDISPINFO",
		"OS",
		"customDraw",
		"OS",
		"nmcd",
		"lParam",
		"NMLVCUSTOMDRAW",
		"nmcd",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"nmcd",
		"item",
		"item",
		"nmcd",
		"hFont",
		"hFont",
		"item",
		"item",
		"item",
		"nmcd",
		"clrText",
		"clrText",
		"item",
		"item",
		"item",
		"nmcd",
		"clrTextBk",
		"clrTextBk",
		"item",
		"hFont",
		"clrText",
		"clrTextBk",
		"item",
		"item",
		"item",
		"OS",
		"handle",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"count",
		"hFont",
		"hFont",
		"OS",
		"handle",
		"OS",
		"OS",
		"nmcd",
		"hFont",
		"OS",
		"handle",
		"nmcd",
		"clrText",
		"clrText",
		"nmcd",
		"clrTextBk",
		"clrTextBk",
		"OS",
		"lParam",
		"nmcd",
		"NMLVCUSTOMDRAW",
		"OS",
		"OS",
		"LRESULT",
		"OS",
		"OS",
		"dragStarted",
		"hdr",
		"OS",
		"OS",
		"pt",
		"pos",
		"pt",
		"pos",
		"OS",
		"handle",
		"pt",
		"event",
		"pt",
		"event",
		"pt",
		"SWT",
		"event",
		"OS",
		"OS",
		"pnmlv",
		"lParam",
		"NMLISTVIEW",
		"columns",
		"pnmlv",
		"column",
		"column",
		"SWT",
		"OS",
		"ignoreActivate",
		"OS",
		"pnmlv",
		"lParam",
		"NMLISTVIEW",
		"pnmlv",
		"event",
		"pnmlv",
		"SWT",
		"event",
		"OS",
		"ignoreSelect",
		"OS",
		"pnmlv",
		"lParam",
		"NMLISTVIEW",
		"pnmlv",
		"OS",
		"pnmlv",
		"wasSelected",
		"pnmlv",
		"OS",
		"pnmlv",
		"OS",
		"oldSelected",
		"newSelected",
		"wasSelected",
		"OS",
		"OS",
		"menu",
		"menu",
		"hasMenu",
		"SWT",
		"LRESULT",
		"OS",
		"OS",
		"menu",
		"menu",
		"hasMenu",
		"SWT",
		"OS",
		"nmrg",
		"lParam",
		"NMRGINFO",
		"nmrg",
		"nmrg",
		"LRESULT",
		"wParam",
		"lParam",
		"WC_LISTVIEW",
		"lpfnWndProc",
		"NONE",
		"ERROR_NULL_ARGUMENT",
		"Selection",
		"DefaultSelection",
		"WM_CHAR",
		"WM_IME_CHAR",
		"WM_KEYUP",
		"WM_SYSCHAR",
		"WM_SYSKEYDOWN",
		"WM_SYSKEYUP",
		"WM_LBUTTONDBLCLK",
		"WM_LBUTTONUP",
		"WM_MBUTTONDBLCLK",
		"WM_MBUTTONUP",
		"WM_MOUSEHOVER",
		"WM_MOUSELEAVE",
		"WM_MOUSEMOVE",
		"WM_RBUTTONDBLCLK",
		"WM_RBUTTONUP",
		"WM_XBUTTONDBLCLK",
		"WM_XBUTTONUP",
		"WM_LBUTTONDOWN",
		"WM_MBUTTONDOWN",
		"WM_RBUTTONDOWN",
		"WM_XBUTTONDOWN",
		"WM_KEYDOWN",
		"ignoreMsgFilter",
		"ignoreMsgFilter",
		"LVM_GETNEXTITEM",
		"LVNI_FOCUSED",
		"item",
		"Selection",
		"H_SCROLL",
		"V_SCROLL",
		"SINGLE",
		"MULTI",
		"cached",
		"VIRTUAL",
		"cached",
		"item",
		"SetData",
		"ERROR_INVALID_SUBCLASS",
		"LVM_GETITEMCOUNT",
		"ERROR_INVALID_RANGE",
		"VIRTUAL",
		"cached",
		"mask",
		"LVIF_TEXT",
		"LVIF_INDENT",
		"pszText",
		"LPSTR_TEXTCALLBACK",
		"iItem",
		"LVM_SETITEM",
		"cached",
		"LVM_REDRAWITEMS",
		"LVM_GETITEMCOUNT",
		"ERROR_INVALID_RANGE",
		"VIRTUAL",
		"cached",
		"mask",
		"LVIF_TEXT",
		"LVIF_INDENT",
		"pszText",
		"LPSTR_TEXTCALLBACK",
		"iItem",
		"LVM_SETITEM",
		"cached",
		"LVM_REDRAWITEMS",
		"ERROR_NULL_ARGUMENT",
		"length",
		"LVM_GETITEMCOUNT",
		"length",
		"ERROR_INVALID_RANGE",
		"length",
		"VIRTUAL",
		"cached",
		"mask",
		"LVIF_TEXT",
		"LVIF_INDENT",
		"pszText",
		"LPSTR_TEXTCALLBACK",
		"iItem",
		"LVM_SETITEM",
		"cached",
		"LVM_REDRAWITEMS",
		"LVM_GETITEMCOUNT",
		"VIRTUAL",
		"cached",
		"mask",
		"LVIF_TEXT",
		"LVIF_INDENT",
		"pszText",
		"LPSTR_TEXTCALLBACK",
		"iItem",
		"LVM_SETITEM",
		"cached",
		"LVM_REDRAWITEMS",
		"DEFAULT",
		"LVM_GETHEADER",
		"HDM_GETITEMCOUNT",
		"LVM_GETCOLUMNWIDTH",
		"DEFAULT",
		"LVM_APPROXIMATEVIEWRECT",
		"LVM_APPROXIMATEVIEWRECT",
		"LVM_APPROXIMATEVIEWRECT",
		"DEFAULT",
		"DEFAULT",
		"V_SCROLL",
		"SM_CXVSCROLL",
		"H_SCROLL",
		"SM_CYHSCROLL",
		"IsWinCE",
		"COMCTL32_MAJOR",
		"CCM_SETVERSION",
		"CHECK",
		"LVM_APPROXIMATEVIEWRECT",
		"LVM_APPROXIMATEVIEWRECT",
		"LVM_SETCALLBACKMASK",
		"LVIS_STATEIMAGEMASK",
		"SYSTEM_FONT",
		"WM_SETFONT",
		"mask",
		"LVCF_TEXT",
		"HEAP_ZERO_MEMORY",
		"sizeof",
		"pszText",
		"LVM_INSERTCOLUMN",
		"LVS_EX_SUBITEMIMAGES",
		"LVS_EX_LABELTIP",
		"FULL_SELECTION",
		"LVS_EX_FULLROWSELECT",
		"LVM_SETEXTENDEDLISTVIEWSTYLE",
		"WIN32_VERSION",
		"RIGHT_TO_LEFT",
		"LVM_GETHEADER",
		"GWL_EXSTYLE",
		"GWL_EXSTYLE",
		"WS_EX_LAYOUTRTL",
		"LVM_GETHEADER",
		"HDM_GETITEMCOUNT",
		"ERROR_INVALID_RANGE",
		"length",
		"length",
		"length",
		"LVM_GETITEMCOUNT",
		"strings",
		"strings",
		"images",
		"images",
		"strings",
		"strings",
		"text",
		"text",
		"images",
		"images",
		"image",
		"image",
		"cellBackground",
		"cellBackground",
		"cellBackground",
		"cellForeground",
		"cellForeground",
		"cellForeground",
		"cellFont",
		"cellFont",
		"cellFont",
		"mask",
		"LVCF_WIDTH",
		"LVM_INSERTCOLUMN",
		"LVM_GETCOLUMN",
		"cx",
		"sizeof",
		"HEAP_ZERO_MEMORY",
		"mask",
		"LVCF_TEXT",
		"LVCF_IMAGE",
		"LVCF_WIDTH",
		"LVCF_FMT",
		"pszText",
		"cchTextMax",
		"LVM_GETCOLUMN",
		"LVM_SETCOLUMN",
		"fmt",
		"LVCFMT_IMAGE",
		"cx",
		"iImage",
		"I_IMAGENONE",
		"pszText",
		"cchTextMax",
		"LVM_SETCOLUMN",
		"mask",
		"LVCF_FMT",
		"fmt",
		"LVCFMT_LEFT",
		"LVM_SETCOLUMN",
		"LVM_SETCOLUMNWIDTH",
		"style",
		"VIRTUAL",
		"mask",
		"LVIF_TEXT",
		"LVIF_IMAGE",
		"pszText",
		"LPSTR_TEXTCALLBACK",
		"iImage",
		"I_IMAGECALLBACK",
		"iItem",
		"LVM_SETITEM",
		"LVCFMT_LEFT",
		"style",
		"CENTER",
		"CENTER",
		"LVCFMT_CENTER",
		"style",
		"RIGHT",
		"RIGHT",
		"LVCFMT_RIGHT",
		"mask",
		"LVCF_WIDTH",
		"LVCF_FMT",
		"fmt",
		"LVM_INSERTCOLUMN",
		"LVM_GETITEMCOUNT",
		"ERROR_INVALID_RANGE",
		"length",
		"length",
		"length",
		"length",
		"mask",
		"LVIF_TEXT",
		"LVIF_IMAGE",
		"iItem",
		"pszText",
		"LPSTR_TEXTCALLBACK",
		"iImage",
		"I_IMAGECALLBACK",
		"LVM_INSERTITEM",
		"ERROR_ITEM_NOT_ADDED",
		"VIRTUAL",
		"COLOR_WINDOW",
		"ERROR_NULL_ARGUMENT",
		"length",
		"stateMask",
		"LVIS_SELECTED",
		"length",
		"LVM_SETITEMSTATE",
		"stateMask",
		"LVIS_SELECTED",
		"LVM_SETITEMSTATE",
		"LVM_GETITEMCOUNT",
		"stateMask",
		"LVIS_SELECTED",
		"LVM_SETITEMSTATE",
		"mask",
		"LVIF_STATE",
		"stateMask",
		"LVIS_SELECTED",
		"LVM_SETITEMSTATE",
		"LVM_GETHEADER",
		"HDM_GETITEMCOUNT",
		"sizeof",
		"HEAP_ZERO_MEMORY",
		"mask",
		"LVCF_TEXT",
		"LVCF_WIDTH",
		"pszText",
		"cchTextMax",
		"LVM_GETCOLUMN",
		"mask",
		"LVCF_FMT",
		"fmt",
		"LVCFMT_LEFT",
		"LVM_SETCOLUMN",
		"HEAP_ZERO_MEMORY",
		"sizeof",
		"mask",
		"LVCF_TEXT",
		"pszText",
		"LVM_SETCOLUMN",
		"style",
		"VIRTUAL",
		"mask",
		"LVIF_TEXT",
		"LVIF_IMAGE",
		"pszText",
		"LPSTR_TEXTCALLBACK",
		"iImage",
		"I_IMAGECALLBACK",
		"LVM_GETITEMCOUNT",
		"iItem",
		"LVM_SETITEM",
		"LVM_DELETECOLUMN",
		"ERROR_ITEM_NOT_REMOVED",
		"LVM_GETITEMCOUNT",
		"strings",
		"images",
		"cellBackground",
		"cellForeground",
		"cellFont",
		"strings",
		"strings",
		"text",
		"strings",
		"text",
		"images",
		"images",
		"image",
		"images",
		"image",
		"cellBackground",
		"cellBackground",
		"cellBackground",
		"cellForeground",
		"cellForeground",
		"cellForeground",
		"cellFont",
		"cellFont",
		"cellFont",
		"LVM_GETITEMCOUNT",
		"LVM_DELETEITEM",
		"ERROR_ITEM_NOT_REMOVED",
		"CHECK",
		"LVM_GETIMAGELIST",
		"LVSIL_SMALL",
		"LVM_GETIMAGELIST",
		"LVSIL_STATE",
		"LVM_GETBKCOLOR",
		"LVM_GETHEADER",
		"HDM_GETITEMCOUNT",
		"ERROR_INVALID_RANGE",
		"LVM_GETHEADER",
		"HDM_GETITEMCOUNT",
		"LVM_GETHEADER",
		"HDM_GETITEMCOUNT",
		"LVM_GETCOLUMNORDERARRAY",
		"LVM_GETHEADER",
		"HDM_GETITEMCOUNT",
		"LVM_GETNEXTITEM",
		"LVNI_FOCUSED",
		"LVM_GETTEXTCOLOR",
		"CLR_DEFAULT",
		"COLOR_WINDOWTEXT",
		"LVM_GETHEADER",
		"bottom",
		"top",
		"GWL_STYLE",
		"LVS_NOCOLUMNHEADER",
		"LVM_GETITEMCOUNT",
		"ERROR_INVALID_RANGE",
		"ERROR_NULL_ARGUMENT",
		"x",
		"x",
		"y",
		"y",
		"LVM_HITTEST",
		"iItem",
		"iItem",
		"LVM_GETITEMCOUNT",
		"LVM_APPROXIMATEVIEWRECT",
		"LVM_APPROXIMATEVIEWRECT",
		"LVM_GETITEMCOUNT",
		"VIRTUAL",
		"LVM_GETEXTENDEDLISTVIEWSTYLE",
		"LVS_EX_GRIDLINES",
		"LVM_GETSELECTEDCOUNT",
		"LVM_GETNEXTITEM",
		"LVNI_SELECTED",
		"LVM_GETSELECTEDCOUNT",
		"LVM_GETNEXTITEM",
		"LVNI_FOCUSED",
		"LVM_GETNEXTITEM",
		"LVNI_SELECTED",
		"LVM_GETNEXTITEM",
		"LVNI_SELECTED",
		"LVM_GETSELECTEDCOUNT",
		"LVM_GETNEXTITEM",
		"LVNI_SELECTED",
		"LVM_GETTOPINDEX",
		"I_IMAGENONE",
		"RIGHT_TO_LEFT",
		"width",
		"height",
		"LVM_SETIMAGELIST",
		"LVSIL_SMALL",
		"ERROR_NULL_ARGUMENT",
		"LVM_GETHEADER",
		"HDM_GETITEMCOUNT",
		"ERROR_NULL_ARGUMENT",
		"LVM_GETITEMCOUNT",
		"mask",
		"LVIF_STATE",
		"stateMask",
		"LVIS_SELECTED",
		"iItem",
		"LVM_GETITEM",
		"state",
		"LVIS_SELECTED",
		"LVM_GETHEADER",
		"HDM_GETITEMCOUNT",
		"LVM_GETITEMCOUNT",
		"IsWin95",
		"WM_SETREDRAW",
		"LVM_DELETEITEM",
		"LVM_SETIMAGELIST",
		"LVSIL_SMALL",
		"LVM_GETIMAGELIST",
		"LVSIL_STATE",
		"LVM_SETIMAGELIST",
		"LVSIL_STATE",
		"ERROR_NULL_ARGUMENT",
		"length",
		"length",
		"length",
		"length",
		"LVM_GETITEMCOUNT",
		"ERROR_INVALID_RANGE",
		"length",
		"LVM_DELETEITEM",
		"ERROR_ITEM_NOT_REMOVED",
		"LVM_GETITEMCOUNT",
		"ERROR_INVALID_RANGE",
		"LVM_DELETEITEM",
		"ERROR_ITEM_NOT_REMOVED",
		"LVM_GETITEMCOUNT",
		"ERROR_INVALID_RANGE",
		"LVM_DELETEITEM",
		"ERROR_ITEM_NOT_REMOVED",
		"LVM_GETHEADER",
		"HDM_GETITEMCOUNT",
		"LVM_GETITEMCOUNT",
		"IsWin95",
		"WM_SETREDRAW",
		"LVM_DELETEITEM",
		"WM_SETREDRAW",
		"ERROR_ITEM_NOT_REMOVED",
		"LVM_DELETEALLITEMS",
		"ERROR_ITEM_NOT_REMOVED",
		"ERROR_NULL_ARGUMENT",
		"Selection",
		"DefaultSelection",
		"ERROR_NULL_ARGUMENT",
		"length",
		"SINGLE",
		"state",
		"LVIS_SELECTED",
		"stateMask",
		"LVIS_SELECTED",
		"LVM_SETITEMSTATE",
		"state",
		"LVIS_SELECTED",
		"stateMask",
		"LVIS_SELECTED",
		"LVM_SETITEMSTATE",
		"SINGLE",
		"LVM_GETITEMCOUNT",
		"state",
		"LVIS_SELECTED",
		"stateMask",
		"LVIS_SELECTED",
		"LVM_SETITEMSTATE",
		"SINGLE",
		"mask",
		"LVIF_STATE",
		"state",
		"LVIS_SELECTED",
		"stateMask",
		"LVIS_SELECTED",
		"LVM_SETITEMSTATE",
		"x",
		"y",
		"LVM_HITTEST",
		"iItem",
		"ZERO",
		"LVM_GETSELECTEDCOUNT",
		"iItem",
		"mask",
		"LVIF_STATE",
		"stateMask",
		"LVIS_SELECTED",
		"iItem",
		"iItem",
		"LVM_GETITEM",
		"state",
		"LVIS_SELECTED",
		"LVHT_ONITEMLABEL",
		"LVHT_ONITEMICON",
		"flags",
		"MULTI",
		"flags",
		"LVHT_ONITEMSTATEICON",
		"MouseUp",
		"LVM_SETBKCOLOR",
		"LVM_SETTEXTBKCOLOR",
		"CHECK",
		"SWP_NOSIZE",
		"height",
		"ERROR_NULL_ARGUMENT",
		"LVM_GETHEADER",
		"HDM_GETITEMCOUNT",
		"length",
		"ERROR_INVALID_ARGUMENT",
		"length",
		"ERROR_INVALID_ARGUMENT",
		"LVM_GETCOLUMNORDERARRAY",
		"length",
		"ERROR_INVALID_RANGE",
		"ERROR_INVALID_ARGUMENT",
		"HDM_GETITEMRECT",
		"LVM_SETCOLUMNORDERARRAY",
		"length",
		"HDM_GETITEMRECT",
		"left",
		"left",
		"Move",
		"CHECK",
		"LVM_GETIMAGELIST",
		"LVSIL_STATE",
		"CHECK",
		"COLOR_FLAGS",
		"RIGHT_TO_LEFT",
		"ILC_MIRROR",
		"COMCTL32_MAJOR",
		"ILC_MASK",
		"IsUnicode",
		"tmHeight",
		"tmHeight",
		"COMCTL32_MAJOR",
		"BP_CHECKBOX",
		"CBS_UNCHECKEDNORMAL",
		"left",
		"right",
		"BP_CHECKBOX",
		"CBS_CHECKEDNORMAL",
		"left",
		"right",
		"BP_CHECKBOX",
		"CBS_UNCHECKEDNORMAL",
		"left",
		"right",
		"BP_CHECKBOX",
		"CBS_MIXEDNORMAL",
		"DFC_BUTTON",
		"DFCS_BUTTONCHECK",
		"DFCS_FLAT",
		"left",
		"right",
		"DFC_BUTTON",
		"DFCS_BUTTONCHECK",
		"DFCS_CHECKED",
		"DFCS_FLAT",
		"left",
		"right",
		"DFC_BUTTON",
		"DFCS_BUTTONCHECK",
		"DFCS_INACTIVE",
		"DFCS_FLAT",
		"left",
		"right",
		"DFC_BUTTON",
		"DFCS_BUTTONCHECK",
		"DFCS_CHECKED",
		"DFCS_INACTIVE",
		"DFCS_FLAT",
		"COMCTL32_MAJOR",
		"LVM_GETIMAGELIST",
		"LVSIL_STATE",
		"LVM_SETIMAGELIST",
		"LVSIL_STATE",
		"state",
		"LVIS_FOCUSED",
		"stateMask",
		"LVIS_FOCUSED",
		"LVM_SETITEMSTATE",
		"LVM_GETHEADER",
		"LVM_GETEXTENDEDLISTVIEWSTYLE",
		"LVS_EX_GRIDLINES",
		"GWL_STYLE",
		"LVS_NOCOLUMNHEADER",
		"CLR_DEFAULT",
		"LVM_SETTEXTCOLOR",
		"GWL_STYLE",
		"LVS_NOCOLUMNHEADER",
		"LVS_NOCOLUMNHEADER",
		"GWL_STYLE",
		"LVM_GETEXTENDEDLISTVIEWSTYLE",
		"LVS_EX_GRIDLINES",
		"LVM_GETITEMCOUNT",
		"VIRTUAL",
		"LVM_DELETEITEM",
		"ERROR_ITEM_NOT_REMOVED",
		"LVSICF_NOINVALIDATEALL",
		"LVSICF_NOSCROLL",
		"LVM_SETITEMCOUNT",
		"NONE",
		"COMCTL32_VERSION",
		"LVM_GETIMAGELIST",
		"LVSIL_SMALL",
		"LVM_GETHEADER",
		"bottom",
		"top",
		"LVM_SETIMAGELIST",
		"LVSIL_SMALL",
		"LVM_SETIMAGELIST",
		"LVSIL_SMALL",
		"LVS_EX_GRIDLINES",
		"GWL_STYLE",
		"LVS_NOCOLUMNHEADER",
		"LVM_SETEXTENDEDLISTVIEWSTYLE",
		"LVS_EX_GRIDLINES",
		"GWL_STYLE",
		"WS_VISIBLE",
		"WM_SETREDRAW",
		"LVM_GETHEADER",
		"WM_SETREDRAW",
		"SW_HIDE",
		"IsWinCE",
		"RDW_ERASE",
		"RDW_FRAME",
		"RDW_INVALIDATE",
		"RDW_ALLCHILDREN",
		"WM_SETREDRAW",
		"LVM_GETHEADER",
		"WM_SETREDRAW",
		"LVM_GETHEADER",
		"HDM_GETITEMCOUNT",
		"LVM_GETITEMCOUNT",
		"text",
		"imageIndent",
		"cellFont",
		"cellFont",
		"font",
		"text",
		"imageIndent",
		"cellFont",
		"cellFont",
		"font",
		"DT_CALCRECT",
		"DT_SINGLELINE",
		"DT_NOPREFIX",
		"right",
		"left",
		"LVM_GETSTRINGWIDTH",
		"LVM_GETIMAGELIST",
		"LVSIL_STATE",
		"LVM_GETIMAGELIST",
		"LVSIL_SMALL",
		"LVM_GETCOLUMNWIDTH",
		"LVM_SETCOLUMNWIDTH",
		"ERROR_NULL_ARGUMENT",
		"length",
		"SINGLE",
		"ERROR_NULL_ARGUMENT",
		"length",
		"SINGLE",
		"SINGLE",
		"LVM_GETITEMCOUNT",
		"LVM_GETHEADER",
		"HDM_GETITEMCOUNT",
		"LVM_SETIMAGELIST",
		"LVSIL_SMALL",
		"LVM_SETIMAGELIST",
		"LVSIL_SMALL",
		"VIRTUAL",
		"LVM_GETTOPINDEX",
		"LVM_GETCOUNTPERPAGE",
		"LVM_ENSUREVISIBLE",
		"LVM_GETTOPINDEX",
		"LVM_ENSUREVISIBLE",
		"left",
		"LVIR_BOUNDS",
		"LVM_GETITEMRECT",
		"bottom",
		"top",
		"LVM_SCROLL",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"parent",
		"LVM_GETHEADER",
		"HDM_GETITEMCOUNT",
		"left",
		"LVIR_BOUNDS",
		"top",
		"LVM_GETSUBITEMRECT",
		"right",
		"left",
		"LVM_GETCOLUMNWIDTH",
		"left",
		"right",
		"top",
		"LVM_GETSUBITEMRECT",
		"left",
		"left",
		"left",
		"left",
		"LVM_SCROLL",
		"right",
		"left",
		"right",
		"left",
		"left",
		"right",
		"left",
		"right",
		"LVM_SCROLL",
		"LVM_GETCOUNTPERPAGE",
		"LVM_ENSUREVISIBLE",
		"LVM_GETTOPINDEX",
		"LVM_ENSUREVISIBLE",
		"LVM_ENSUREVISIBLE",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"LVM_GETNEXTITEM",
		"LVNI_SELECTED",
		"LVM_GETTOOLTIPS",
		"hwndFrom",
		"LVM_GETHEADER",
		"HDM_GETITEMCOUNT",
		"moveable",
		"LVS_EX_HEADERDRAGDROP",
		"LVM_SETEXTENDEDLISTVIEWSTYLE",
		"LVS_EX_HEADERDRAGDROP",
		"LVS_SHAREIMAGELISTS",
		"HIDE_SELECTION",
		"LVS_SHOWSELALWAYS",
		"SINGLE",
		"LVS_SINGLESEL",
		"LVS_REPORT",
		"LVS_NOCOLUMNHEADER",
		"VIRTUAL",
		"LVS_OWNERDATA",
		"CHECK",
		"LVM_GETNEXTITEM",
		"LVNI_FOCUSED",
		"IsWinCE",
		"EVENT_OBJECT_FOCUS",
		"OBJID_CLIENT",
		"WM_KEYDOWN",
		"CR",
		"LVM_GETNEXTITEM",
		"LVNI_FOCUSED",
		"item",
		"DefaultSelection",
		"ZERO",
		"CHECK",
		"VK_SPACE",
		"ZERO",
		"VK_UP",
		"VK_DOWN",
		"VK_PRIOR",
		"VK_NEXT",
		"VK_HOME",
		"VK_END",
		"WM_CHANGEUISTATE",
		"UIS_INITIALIZE",
		"HIDE_SELECTION",
		"CHECK",
		"x",
		"y",
		"LVM_HITTEST",
		"MouseDown",
		"WM_LBUTTONDOWN",
		"MouseDoubleClick",
		"WM_LBUTTONDBLCLK",
		"iItem",
		"WM_LBUTTONDBLCLK",
		"CHECK",
		"flags",
		"LVHT_ONITEMSTATEICON",
		"IsWinCE",
		"EVENT_OBJECT_FOCUS",
		"OBJID_CLIENT",
		"ZERO",
		"MouseDown",
		"WM_LBUTTONDOWN",
		"CHECK",
		"x",
		"y",
		"LVM_HITTEST",
		"flags",
		"LVHT_ONITEMSTATEICON",
		"IsWinCE",
		"EVENT_OBJECT_FOCUS",
		"OBJID_CLIENT",
		"LVM_GETEXTENDEDLISTVIEWSTYLE",
		"LVS_EX_ONECLICKACTIVATE",
		"LVS_EX_TRACKSELECT",
		"LVS_EX_TWOCLICKACTIVATE",
		"ZERO",
		"LVM_GETITEMCOUNT",
		"length",
		"length",
		"sizeof",
		"LVM_GETHEADER",
		"hwndFrom",
		"code",
		"HDN_BEGINTRACKW",
		"HDN_BEGINTRACKA",
		"HDN_DIVIDERDBLCLICKW",
		"HDN_DIVIDERDBLCLICKA",
		"HDM_GETITEMCOUNT",
		"ONE",
		"sizeof",
		"iItem",
		"ONE",
		"NM_RELEASEDCAPTURE",
		"HDN_BEGINDRAG",
		"ONE",
		"LVM_GETEXTENDEDLISTVIEWSTYLE",
		"LVS_EX_HEADERDRAGDROP",
		"HDM_GETITEMCOUNT",
		"ONE",
		"sizeof",
		"iItem",
		"iItem",
		"ONE",
		"HDN_ENDDRAG",
		"LVM_GETEXTENDEDLISTVIEWSTYLE",
		"LVS_EX_HEADERDRAGDROP",
		"sizeof",
		"iItem",
		"pitem",
		"pitem",
		"sizeof",
		"mask",
		"HDI_ORDER",
		"iOrder",
		"HDM_GETITEMCOUNT",
		"LVM_GETCOLUMNORDERARRAY",
		"length",
		"iItem",
		"length",
		"iOrder",
		"iOrder",
		"iOrder",
		"Move",
		"HDN_ITEMCHANGEDW",
		"HDN_ITEMCHANGEDA",
		"LVM_GETCOLUMNWIDTH",
		"LVM_GETEXTENDEDLISTVIEWSTYLE",
		"LVS_EX_GRIDLINES",
		"right",
		"left",
		"sizeof",
		"pitem",
		"pitem",
		"sizeof",
		"mask",
		"HDI_WIDTH",
		"iItem",
		"Resize",
		"ZERO",
		"HDM_GETITEMCOUNT",
		"LVM_GETCOLUMNORDERARRAY",
		"Move",
		"HDN_ITEMDBLCLICKW",
		"HDN_ITEMDBLCLICKA",
		"sizeof",
		"iItem",
		"DefaultSelection",
		"code",
		"TTN_GETDISPINFOA",
		"TTN_GETDISPINFOW",
		"WM_NOTIFY",
		"x",
		"y",
		"LVM_HITTEST",
		"MouseDown",
		"WM_RBUTTONDOWN",
		"MouseDoubleClick",
		"WM_RBUTTONDBLCLK",
		"iItem",
		"WM_RBUTTONDBLCLK",
		"ZERO",
		"MouseDown",
		"WM_RBUTTONDOWN",
		"LVM_GETITEMCOUNT",
		"LVM_GETNEXTITEM",
		"LVNI_FOCUSED",
		"state",
		"LVIS_FOCUSED",
		"stateMask",
		"LVIS_FOCUSED",
		"LVM_SETITEMSTATE",
		"LVM_SETBKCOLOR",
		"LVM_SETTEXTBKCOLOR",
		"CHECK",
		"LVM_GETEXTENDEDLISTVIEWSTYLE",
		"LVS_EX_GRIDLINES",
		"SB_ENDSCROLL",
		"SB_THUMBPOSITION",
		"SB_THUMBTRACK",
		"SB_TOP",
		"SB_BOTTOM",
		"SB_LINEDOWN",
		"SB_LINEUP",
		"LVM_GETHEADER",
		"bottom",
		"top",
		"top",
		"LVM_APPROXIMATEVIEWRECT",
		"LVM_APPROXIMATEVIEWRECT",
		"SB_LINEDOWN",
		"top",
		"bottom",
		"bottom",
		"top",
		"SB_PAGEDOWN",
		"SB_PAGEUP",
		"sizeof",
		"code",
		"LVN_ODFINDITEMA",
		"LVN_ODFINDITEMW",
		"VIRTUAL",
		"sizeof",
		"iStart",
		"LVN_GETDISPINFOA",
		"LVN_GETDISPINFOW",
		"sizeof",
		"iItem",
		"cached",
		"VIRTUAL",
		"iItem",
		"cached",
		"mask",
		"LVIF_TEXT",
		"iSubItem",
		"text",
		"strings",
		"iSubItem",
		"iSubItem",
		"cchTextMax",
		"sizeof",
		"pszText",
		"pszText",
		"sizeof",
		"sizeof",
		"cchTextMax",
		"cchTextMax",
		"mask",
		"LVIF_IMAGE",
		"iSubItem",
		"image",
		"images",
		"iSubItem",
		"iImage",
		"mask",
		"LVIF_STATE",
		"iSubItem",
		"checked",
		"grayed",
		"state",
		"stateMask",
		"LVIS_STATEIMAGEMASK",
		"mask",
		"LVIF_INDENT",
		"iSubItem",
		"iIndent",
		"imageIndent",
		"sizeof",
		"NM_CUSTOMDRAW",
		"sizeof",
		"dwDrawStage",
		"CDDS_PREPAINT",
		"CDRF_NOTIFYITEMDRAW",
		"CDDS_ITEMPREPAINT",
		"CDRF_NOTIFYSUBITEMDRAW",
		"CDDS_ITEMPREPAINT",
		"CDDS_SUBITEM",
		"dwItemSpec",
		"cellFont",
		"cellFont",
		"iSubItem",
		"font",
		"cellForeground",
		"cellForeground",
		"iSubItem",
		"foreground",
		"cellBackground",
		"cellBackground",
		"iSubItem",
		"background",
		"cellForeground",
		"cellBackground",
		"cellFont",
		"LVM_GETHEADER",
		"HDM_GETITEMCOUNT",
		"WM_GETFONT",
		"hdc",
		"clrText",
		"clrTextBk",
		"sizeof",
		"CDRF_NEWFONT",
		"LVN_MARQUEEBEGIN",
		"ONE",
		"LVN_BEGINDRAG",
		"LVN_BEGINRDRAG",
		"code",
		"LVN_BEGINDRAG",
		"x",
		"y",
		"x",
		"x",
		"y",
		"y",
		"DragDetect",
		"LVN_COLUMNCLICK",
		"sizeof",
		"iSubItem",
		"Selection",
		"LVN_ITEMACTIVATE",
		"sizeof",
		"iItem",
		"item",
		"iItem",
		"DefaultSelection",
		"LVN_ITEMCHANGED",
		"sizeof",
		"uChanged",
		"LVIF_STATE",
		"iItem",
		"uNewState",
		"LVIS_SELECTED",
		"uOldState",
		"LVIS_SELECTED",
		"NM_RECOGNIZEGESTURE",
		"IsPPC",
		"MenuDetect",
		"ONE",
		"GN_CONTEXTMENU",
		"IsPPC",
		"MenuDetect",
		"sizeof",
		"x",
		"y",
		"ONE",
		"parent",
		"style",
		"index",
		"listener",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"forceSelect",
		"style",
		"item",
		"redraw",
		"index",
		"start",
		"end",
		"indices",
		"wHint",
		"hHint",
		"changed",
		"column",
		"index",
		"item",
		"index",
		"indices",
		"index",
		"start",
		"end",
		"column",
		"item",
		"index",
		"index",
		"point",
		"image",
		"column",
		"item",
		"index",
		"indices",
		"index",
		"start",
		"end",
		"listener",
		"indices",
		"index",
		"start",
		"end",
		"type",
		"button",
		"msg",
		"wParam",
		"lParam",
		"pixel",
		"x",
		"y",
		"width",
		"height",
		"flags",
		"order",
		"width",
		"height",
		"index",
		"font",
		"pixel",
		"show",
		"count",
		"show",
		"redraw",
		"item",
		"force",
		"indices",
		"items",
		"index",
		"start",
		"end",
		"index",
		"column",
		"index",
		"item",
		"hdr",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam"
	],
	"extendORImplementFiles":[
		"Composite"
	],
	"package":[
		"org.eclipse.swt.widgets"
	],
	"import":[
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt",
		"org.eclipse.swt.graphics",
		"org.eclipse.swt.events"
	],
	"methods":[
		"_getItem",
		"addSelectionListener",
		"callWindowProc",
		"callWindowProc",
		"checkStyle",
		"checkData",
		"checkSubclass",
		"clear",
		"clear",
		"clear",
		"clearAll",
		"computeSize",
		"createHandle",
		"createItem",
		"createItem",
		"createWidget",
		"defaultBackground",
		"deselect",
		"deselect",
		"deselect",
		"deselectAll",
		"destroyItem",
		"destroyItem",
		"fixCheckboxImageList",
		"getBackgroundPixel",
		"getColumn",
		"getColumnCount",
		"getColumnOrder",
		"getColumns",
		"getFocusIndex",
		"getForegroundPixel",
		"getGridLineWidth",
		"getHeaderHeight",
		"getHeaderVisible",
		"getItem",
		"getItem",
		"getItemCount",
		"getItemHeight",
		"getItems",
		"getLinesVisible",
		"getSelection",
		"getSelectionCount",
		"getSelectionIndex",
		"getSelectionIndices",
		"getTopIndex",
		"imageIndex",
		"indexOf",
		"indexOf",
		"isSelected",
		"releaseWidget",
		"remove",
		"remove",
		"remove",
		"removeAll",
		"removeSelectionListener",
		"select",
		"select",
		"select",
		"selectAll",
		"sendMouseDownEvent",
		"setBackgroundPixel",
		"setBounds",
		"setColumnOrder",
		"setCheckboxImageListColor",
		"setCheckboxImageList",
		"setFocusIndex",
		"setFont",
		"setForegroundPixel",
		"setHeaderVisible",
		"setItemCount",
		"setItemHeight",
		"setLinesVisible",
		"setRedraw",
		"setScrollWidth",
		"setSelection",
		"setSelection",
		"setSelection",
		"setSelection",
		"setTableEmpty",
		"setTopIndex",
		"showColumn",
		"showItem",
		"showItem",
		"showSelection",
		"toolTipText",
		"updateMoveable",
		"widgetStyle",
		"windowClass",
		"windowProc",
		"WM_CHAR",
		"WM_ERASEBKGND",
		"WM_GETOBJECT",
		"WM_KEYDOWN",
		"WM_KILLFOCUS",
		"WM_LBUTTONDBLCLK",
		"WM_LBUTTONDOWN",
		"WM_MOUSEHOVER",
		"WM_PAINT",
		"WM_NOTIFY",
		"WM_RBUTTONDBLCLK",
		"WM_RBUTTONDOWN",
		"WM_SETFOCUS",
		"WM_SYSCOLORCHANGE",
		"WM_VSCROLL",
		"wmNotifyChild",
		"GetClassInfo",
		"checkStyle",
		"checkWidget",
		"error",
		"addListener",
		"addListener",
		"callWindowProc",
		"CallWindowProc",
		"SendMessage",
		"_getItem",
		"postEvent",
		"checkBits",
		"sendEvent",
		"isDisposed",
		"isDisposed",
		"setScrollWidth",
		"redraw",
		"isValidSubclass",
		"error",
		"checkWidget",
		"SendMessage",
		"error",
		"clear",
		"SendMessage",
		"IsWindowVisible",
		"SendMessage",
		"setScrollWidth",
		"checkWidget",
		"SendMessage",
		"error",
		"clearAll",
		"clear",
		"SendMessage",
		"IsWindowVisible",
		"SendMessage",
		"setScrollWidth",
		"checkWidget",
		"error",
		"SendMessage",
		"error",
		"clear",
		"SendMessage",
		"IsWindowVisible",
		"SendMessage",
		"setScrollWidth",
		"checkWidget",
		"SendMessage",
		"clear",
		"SendMessage",
		"IsWindowVisible",
		"SendMessage",
		"setScrollWidth",
		"checkWidget",
		"setScrollWidth",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"getBorderWidth",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"createHandle",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"setCheckboxImageList",
		"SendMessage",
		"GetStockObject",
		"SendMessage",
		"GetProcessHeap",
		"HeapAlloc",
		"SendMessage",
		"HeapFree",
		"SendMessage",
		"VERSION",
		"SendMessage",
		"GetWindowLong",
		"SetWindowLong",
		"SendMessage",
		"SendMessage",
		"error",
		"arraycopy",
		"SendMessage",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"SendMessage",
		"SendMessage",
		"GetProcessHeap",
		"HeapAlloc",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"HeapFree",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"error",
		"IsWindowVisible",
		"max",
		"arraycopy",
		"SendMessage",
		"error",
		"arraycopy",
		"createWidget",
		"GetSysColor",
		"checkWidget",
		"error",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"deselectAll",
		"max",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"GetProcessHeap",
		"HeapAlloc",
		"SendMessage",
		"SendMessage",
		"HeapFree",
		"GetProcessHeap",
		"HeapAlloc",
		"SendMessage",
		"HeapFree",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"error",
		"arraycopy",
		"SendMessage",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"setScrollWidth",
		"updateMoveable",
		"SendMessage",
		"SendMessage",
		"error",
		"arraycopy",
		"setTableEmpty",
		"SendMessage",
		"ImageList_GetIconSize",
		"SendMessage",
		"ImageList_GetIconSize",
		"setCheckboxImageList",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"error",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"arraycopy",
		"SendMessage",
		"SendMessage",
		"GetSysColor",
		"checkWidget",
		"checkWidget",
		"SendMessage",
		"GetWindowRect",
		"checkWidget",
		"GetWindowLong",
		"checkWidget",
		"SendMessage",
		"error",
		"_getItem",
		"checkWidget",
		"error",
		"SendMessage",
		"_getItem",
		"checkWidget",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"_getItem",
		"arraycopy",
		"checkWidget",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"_getItem",
		"checkWidget",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"checkWidget",
		"max",
		"SendMessage",
		"getBounds",
		"getImageList",
		"indexOf",
		"add",
		"getHandle",
		"getTopIndex",
		"setRedraw",
		"setTopIndex",
		"SendMessage",
		"setTopIndex",
		"fixCheckboxImageList",
		"setRedraw",
		"indexOf",
		"add",
		"checkWidget",
		"error",
		"SendMessage",
		"SendMessage",
		"checkWidget",
		"error",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"isDisposed",
		"releaseResources",
		"isDisposed",
		"releaseResources",
		"isDisposed",
		"releaseResources",
		"SendMessage",
		"releaseImageList",
		"SendMessage",
		"SendMessage",
		"ImageList_Destroy",
		"releaseWidget",
		"checkWidget",
		"error",
		"arraycopy",
		"sort",
		"SendMessage",
		"error",
		"SendMessage",
		"error",
		"isDisposed",
		"releaseResources",
		"arraycopy",
		"setTableEmpty",
		"checkWidget",
		"SendMessage",
		"error",
		"SendMessage",
		"error",
		"isDisposed",
		"releaseResources",
		"arraycopy",
		"setTableEmpty",
		"checkWidget",
		"SendMessage",
		"error",
		"removeAll",
		"SendMessage",
		"isDisposed",
		"releaseResources",
		"arraycopy",
		"error",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"IsWindowVisible",
		"SendMessage",
		"SendMessage",
		"isDisposed",
		"releaseResources",
		"SendMessage",
		"error",
		"SendMessage",
		"error",
		"isDisposed",
		"releaseResources",
		"setTableEmpty",
		"checkWidget",
		"error",
		"unhook",
		"unhook",
		"checkWidget",
		"error",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"max",
		"min",
		"selectAll",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"sendMouseEvent",
		"SetFocus",
		"GetCapture",
		"SetCapture",
		"SendMessage",
		"SendMessage",
		"callWindowProc",
		"GetCapture",
		"SetCapture",
		"sendMouseEvent",
		"defaultBackground",
		"SendMessage",
		"SendMessage",
		"setCheckboxImageListColor",
		"InvalidateRect",
		"getBounds",
		"getItemHeight",
		"setRedraw",
		"setBounds",
		"setRedraw",
		"checkWidget",
		"error",
		"SendMessage",
		"SendMessage",
		"error",
		"error",
		"SendMessage",
		"error",
		"error",
		"SendMessage",
		"SendMessage",
		"InvalidateRect",
		"arraycopy",
		"isDisposed",
		"SendMessage",
		"sendEvent",
		"SendMessage",
		"ImageList_GetIconSize",
		"setCheckboxImageList",
		"IsAppThemed",
		"ImageList_Create",
		"GetDC",
		"CreateCompatibleDC",
		"CreateCompatibleBitmap",
		"SelectObject",
		"SetRect",
		"getBackgroundPixel",
		"CreateSolidBrush",
		"FillRect",
		"DeleteObject",
		"SelectObject",
		"defaultFont",
		"GetTextMetrics",
		"SelectObject",
		"min",
		"min",
		"SetRect",
		"IsAppThemed",
		"OpenThemeData",
		"DrawThemeBackground",
		"DrawThemeBackground",
		"DrawThemeBackground",
		"DrawThemeBackground",
		"CloseThemeData",
		"DrawFrameControl",
		"DrawFrameControl",
		"DrawFrameControl",
		"DrawFrameControl",
		"SelectObject",
		"DeleteDC",
		"ReleaseDC",
		"IsAppThemed",
		"ImageList_Add",
		"ImageList_AddMasked",
		"DeleteObject",
		"SendMessage",
		"SendMessage",
		"ImageList_Destroy",
		"SendMessage",
		"checkWidget",
		"getTopIndex",
		"setRedraw",
		"setTopIndex",
		"setFont",
		"setTopIndex",
		"setScrollWidth",
		"setRedraw",
		"SendMessage",
		"InvalidateRect",
		"SendMessage",
		"GetWindowLong",
		"setItemHeight",
		"SendMessage",
		"InvalidateRect",
		"checkWidget",
		"GetWindowLong",
		"getTopIndex",
		"SetWindowLong",
		"setTopIndex",
		"SendMessage",
		"setItemHeight",
		"checkWidget",
		"max",
		"SendMessage",
		"setRedraw",
		"SendMessage",
		"isDisposed",
		"releaseResources",
		"error",
		"max",
		"arraycopy",
		"min",
		"SendMessage",
		"InvalidateRect",
		"setRedraw",
		"VERSION",
		"SendMessage",
		"SendMessage",
		"GetWindowRect",
		"ImageList_Create",
		"SendMessage",
		"fixCheckboxImageList",
		"SendMessage",
		"ImageList_Destroy",
		"checkWidget",
		"GetWindowLong",
		"setItemHeight",
		"SendMessage",
		"checkWidget",
		"GetWindowLong",
		"setScrollWidth",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"ShowWindow",
		"InvalidateRect",
		"InvalidateRect",
		"RedrawWindow",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"IsWindowVisible",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"max",
		"max",
		"length",
		"GetDC",
		"SelectObject",
		"getCodePage",
		"DrawText",
		"length",
		"SelectObject",
		"ReleaseDC",
		"max",
		"getCodePage",
		"max",
		"SendMessage",
		"SendMessage",
		"ImageList_GetIconSize",
		"SendMessage",
		"ImageList_GetIconSize",
		"SendMessage",
		"SendMessage",
		"checkWidget",
		"error",
		"deselectAll",
		"select",
		"setFocusIndex",
		"showSelection",
		"checkWidget",
		"error",
		"deselectAll",
		"indexOf",
		"select",
		"setFocusIndex",
		"showSelection",
		"checkWidget",
		"deselectAll",
		"select",
		"setFocusIndex",
		"showSelection",
		"checkWidget",
		"deselectAll",
		"SendMessage",
		"max",
		"min",
		"select",
		"setFocusIndex",
		"showSelection",
		"SendMessage",
		"SendMessage",
		"getImage",
		"ImageList_Create",
		"SendMessage",
		"SendMessage",
		"ImageList_Destroy",
		"releaseImageList",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"checkWidget",
		"error",
		"isDisposed",
		"error",
		"indexOf",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"GetClientRect",
		"SendMessage",
		"min",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"checkWidget",
		"error",
		"isDisposed",
		"error",
		"indexOf",
		"showItem",
		"checkWidget",
		"SendMessage",
		"showItem",
		"SendMessage",
		"toolTipText",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"widgetStyle",
		"WM_CHAR",
		"SendMessage",
		"_getItem",
		"setChecked",
		"getChecked",
		"NotifyWinEvent",
		"callWindowProc",
		"SendMessage",
		"_getItem",
		"postEvent",
		"WM_ERASEBKGND",
		"new_Accessible",
		"WM_GETOBJECT",
		"WM_KEYDOWN",
		"SendMessage",
		"WM_KILLFOCUS",
		"InvalidateRect",
		"SendMessage",
		"sendMouseEvent",
		"sendMouseEvent",
		"callWindowProc",
		"GetCapture",
		"SetCapture",
		"_getItem",
		"setChecked",
		"getChecked",
		"NotifyWinEvent",
		"sendMouseDownEvent",
		"SendMessage",
		"_getItem",
		"setChecked",
		"getChecked",
		"NotifyWinEvent",
		"WM_MOUSEHOVER",
		"SendMessage",
		"SendMessage",
		"max",
		"arraycopy",
		"setScrollWidth",
		"WM_PAINT",
		"MoveMemory",
		"SendMessage",
		"SendMessage",
		"MoveMemory",
		"getResizable",
		"SendMessage",
		"SendMessage",
		"MoveMemory",
		"getMoveable",
		"SendMessage",
		"MoveMemory",
		"MoveMemory",
		"SendMessage",
		"SendMessage",
		"min",
		"max",
		"isDisposed",
		"postEvent",
		"SendMessage",
		"SendMessage",
		"GetClientRect",
		"InvalidateRect",
		"MoveMemory",
		"MoveMemory",
		"sendEvent",
		"isDisposed",
		"SendMessage",
		"arraycopy",
		"SendMessage",
		"isDisposed",
		"sendEvent",
		"MoveMemory",
		"postEvent",
		"WM_NOTIFY",
		"callWindowProc",
		"SendMessage",
		"sendMouseEvent",
		"sendMouseEvent",
		"callWindowProc",
		"GetCapture",
		"SetCapture",
		"sendMouseDownEvent",
		"WM_SETFOCUS",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"WM_SYSCOLORCHANGE",
		"defaultBackground",
		"SendMessage",
		"SendMessage",
		"setCheckboxImageListColor",
		"WM_VSCROLL",
		"SendMessage",
		"SendMessage",
		"GetWindowRect",
		"GetClientRect",
		"SendMessage",
		"SendMessage",
		"InvalidateRect",
		"InvalidateRect",
		"MoveMemory",
		"MoveMemory",
		"max",
		"MoveMemory",
		"_getItem",
		"checkData",
		"setScrollWidth",
		"InvalidateRect",
		"length",
		"getCodePage",
		"min",
		"length",
		"MoveMemory",
		"MoveMemory",
		"min",
		"length",
		"imageIndex",
		"MoveMemory",
		"MoveMemory",
		"_getItem",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SelectObject",
		"IsWindowEnabled",
		"getForegroundPixel",
		"getBackgroundPixel",
		"MoveMemory",
		"GetMessagePos",
		"ScreenToClient",
		"postEvent",
		"MoveMemory",
		"postEvent",
		"MoveMemory",
		"_getItem",
		"postEvent",
		"MoveMemory",
		"isDisposed",
		"hooks",
		"isDisposed",
		"hooks",
		"MoveMemory",
		"showMenu",
		"wmNotifyChild",
		"TCHAR",
		"WNDCLASS",
		"TableItem",
		"TypedListener",
		"Event",
		"Event",
		"LVITEM",
		"LVITEM",
		"LVITEM",
		"LVITEM",
		"Point",
		"LVCOLUMN",
		"LVCOLUMN",
		"LVITEM",
		"LVCOLUMN",
		"LVITEM",
		"LVITEM",
		"LVITEM",
		"LVITEM",
		"LVITEM",
		"LVCOLUMN",
		"LVCOLUMN",
		"LVITEM",
		"RECT",
		"LVHITTESTINFO",
		"LVITEM",
		"LVITEM",
		"LVITEM",
		"LVITEM",
		"LVITEM",
		"LVHITTESTINFO",
		"LVITEM",
		"LRESULT",
		"RECT",
		"RECT",
		"RECT",
		"TEXTMETRICW",
		"TEXTMETRICA",
		"LVITEM",
		"TableItem",
		"RECT",
		"TCHAR",
		"RECT",
		"TCHAR",
		"RECT",
		"RECT",
		"RECT",
		"LRESULT",
		"Event",
		"LVHITTESTINFO",
		"LVHITTESTINFO",
		"NMHDR",
		"NMHEADER",
		"NMHEADER",
		"NMHEADER",
		"HDITEM",
		"RECT",
		"NMHEADER",
		"HDITEM",
		"NMHEADER",
		"LRESULT",
		"LVHITTESTINFO",
		"LVITEM",
		"RECT",
		"RECT",
		"NMHDR",
		"NMLVFINDITEM",
		"LRESULT",
		"NMLVDISPINFO",
		"TCHAR",
		"NMLVCUSTOMDRAW",
		"LRESULT",
		"LRESULT",
		"LRESULT",
		"POINT",
		"Event",
		"NMLISTVIEW",
		"NMLISTVIEW",
		"Event",
		"NMLISTVIEW",
		"NMRGINFO"
	],
	"methodsBody":{
		"public void setHeaderVisible(boolean show)":{
			"methodBody":"{\n    checkWidget();\n    int newBits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n    newBits &= ~OS.LVS_NOCOLUMNHEADER;\n    if (!show)\n        newBits |= OS.LVS_NOCOLUMNHEADER;\n    \n    int topIndex = getTopIndex();\n    OS.SetWindowLong(handle, OS.GWL_STYLE, newBits);\n    setTopIndex(topIndex);\n    if (show) {\n        int bits = OS.SendMessage(handle, OS.LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0);\n        if ((bits & OS.LVS_EX_GRIDLINES) != 0)\n            setItemHeight();\n    }\n}",
			"comments":"/**\n* Marks the receiver's header as visible if the argument is <code>true</code>,\n* and marks it invisible otherwise.\n* <p>\n* If one of the receiver's ancestors is not visible or some\n* other condition makes the receiver not visible, marking\n* it visible may not actually cause it to be displayed.\n* </p>\n*\n* @param show the new visibility state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* Feature in Windows.  Setting or clearing LVS_NOCOLUMNHEADER\n* causes the table to scroll to the beginning.  The fix is to\n* save and restore the top index causing the table to scroll\n* to the new location.\n*/\n",
			"methodName":"public void setHeaderVisible(boolean show)"
		},
		"public void setSelection(TableItem[] items)":{
			"methodBody":"{\n    checkWidget();\n    if (items == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    deselectAll();\n    int length = items.length;\n    if (length == 0 || ((style & SWT.SINGLE) != 0 && length > 1))\n        return;\n    int focusIndex = -1;\n    for (int i = length - 1; i >= 0; --i) {\n        int index = indexOf(items[i]);\n        if (index != -1) {\n            select(focusIndex = index);\n        }\n    }\n    if (focusIndex != -1)\n        setFocusIndex(focusIndex);\n    showSelection();\n}",
			"comments":"/**\n* Sets the receiver's selection to be the given array of items.\n* The current selection is cleared before the new items are selected.\n* <p>\n* Items that are not in the receiver are ignored.\n* If the receiver is single-select and multiple items are specified,\n* then all items are ignored.\n*\n* @param items the array of items\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the array of items is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if one of the items has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see Table#deselectAll()\n* @see Table#select(int[])\n* @see Table#setSelection(int[])\n*/\n",
			"methodName":"public void setSelection(TableItem[] items)"
		},
		"public boolean getLinesVisible()":{
			"methodBody":"{\n    checkWidget();\n    int bits = OS.SendMessage(handle, OS.LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0);\n    return (bits & OS.LVS_EX_GRIDLINES) != 0;\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver's lines are visible,\n* and <code>false</code> otherwise.\n* <p>\n* If one of the receiver's ancestors is not visible or some\n* other condition makes the receiver not visible, this method\n* may still indicate that it is considered visible even though\n* it may not actually be showing.\n* </p>\n*\n* @return the visibility state of the lines\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public boolean getLinesVisible()"
		},
		"public void selectAll()":{
			"methodBody":"{\n    checkWidget();\n    if ((style & SWT.SINGLE) != 0)\n        return;\n    LVITEM lvItem = new LVITEM();\n    lvItem.mask = OS.LVIF_STATE;\n    lvItem.state = OS.LVIS_SELECTED;\n    lvItem.stateMask = OS.LVIS_SELECTED;\n    ignoreSelect = true;\n    OS.SendMessage(handle, OS.LVM_SETITEMSTATE, -1, lvItem);\n    ignoreSelect = false;\n}",
			"comments":"/**\n* Selects all of the items in the receiver.\n* <p>\n* If the receiver is single-select, do nothing.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void selectAll()"
		},
		"LRESULT WM_LBUTTONDBLCLK(int wParam, int lParam)":{
			"methodBody":"{\n    \n    LVHITTESTINFO pinfo = new LVHITTESTINFO();\n    pinfo.x = (short) (lParam & 0xFFFF);\n    pinfo.y = (short) (lParam >> 16);\n    int index = OS.SendMessage(handle, OS.LVM_HITTEST, 0, pinfo);\n    sendMouseEvent(SWT.MouseDown, 1, handle, OS.WM_LBUTTONDOWN, wParam, lParam);\n    sendMouseEvent(SWT.MouseDoubleClick, 1, handle, OS.WM_LBUTTONDBLCLK, wParam, lParam);\n    if (pinfo.iItem != -1)\n        callWindowProc(handle, OS.WM_LBUTTONDBLCLK, wParam, lParam);\n    if (OS.GetCapture() != handle)\n        OS.SetCapture(handle);\n    \n    if ((style & SWT.CHECK) != 0) {\n        \n        if (index != -1 && pinfo.flags == OS.LVHT_ONITEMSTATEICON) {\n            TableItem item = _getItem(index);\n            item.setChecked(!item.getChecked(), true);\n            if (!OS.IsWinCE) {\n                OS.NotifyWinEvent(OS.EVENT_OBJECT_FOCUS, handle, OS.OBJID_CLIENT, index + 1);\n            }\n        }\n    }\n    return LRESULT.ZERO;\n}",
			"comments":"/*\n* Feature in Windows.  When the user selects outside of\n* a table item, Windows deselects all the items, even\n* when the table is multi-select.  While not strictly\n* wrong, this is unexpected.  The fix is to detect the\n* case and avoid calling the window proc.\n*/\n/* Look for check/uncheck */\n/*\n* Note that when the table has LVS_EX_FULLROWSELECT and the\n* user clicks anywhere on a row except on the check box, all\n* of the bits are set.  The hit test flags are LVHT_ONITEM.\n* This means that a bit test for LVHT_ONITEMSTATEICON is not\n* the correct way to determine that the user has selected\n* the check box, equality is needed.\n*/\n",
			"methodName":"LRESULT WM_LBUTTONDBLCLK(int wParam, int lParam)"
		},
		"LRESULT WM_SETFOCUS(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_SETFOCUS(wParam, lParam);\n    \n    int count = OS.SendMessage(handle, OS.LVM_GETITEMCOUNT, 0, 0);\n    if (count == 0)\n        return result;\n    int index = OS.SendMessage(handle, OS.LVM_GETNEXTITEM, -1, OS.LVNI_FOCUSED);\n    if (index == -1) {\n        LVITEM lvItem = new LVITEM();\n        lvItem.state = OS.LVIS_FOCUSED;\n        lvItem.stateMask = OS.LVIS_FOCUSED;\n        ignoreSelect = true;\n        OS.SendMessage(handle, OS.LVM_SETITEMSTATE, 0, lvItem);\n        ignoreSelect = false;\n    }\n    return result;\n}",
			"comments":"/*\n* Bug in Windows.  For some reason, the table does\n* not set the default focus rectangle to be the first\n* item in the table when it gets focus and there is\n* no selected item.  The fix to make the first item\n* be the focus item.\n*/\n",
			"methodName":"LRESULT WM_SETFOCUS(int wParam, int lParam)"
		},
		"public void setSelection(int start, int end)":{
			"methodBody":"{\n    checkWidget();\n    deselectAll();\n    if (end < 0 || start > end || ((style & SWT.SINGLE) != 0 && start != end))\n        return;\n    int count = OS.SendMessage(handle, OS.LVM_GETITEMCOUNT, 0, 0);\n    if (count == 0 || start >= count)\n        return;\n    start = Math.max(0, start);\n    end = Math.min(end, count - 1);\n    select(start, end);\n    setFocusIndex(start);\n    showSelection();\n}",
			"comments":"/**\n* Selects the items in the range specified by the given zero-relative\n* indices in the receiver. The range of indices is inclusive.\n* The current selection is cleared before the new items are selected.\n* <p>\n* Indices that are out of range are ignored and no items will be selected\n* if start is greater than end.\n* If the receiver is single-select and there is more than one item in the\n* given range, then all indices are ignored.\n*\n* @param start the start index of the items to select\n* @param end the end index of the items to select\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see Table#deselectAll()\n* @see Table#select(int,int)\n*/\n",
			"methodName":"public void setSelection(int start, int end)"
		},
		"public void setSelection(int index)":{
			"methodBody":"{\n    checkWidget();\n    deselectAll();\n    select(index);\n    if (index != -1)\n        setFocusIndex(index);\n    showSelection();\n}",
			"comments":"/**\n* Selects the item at the given zero-relative index in the receiver.\n* The current selection is first cleared, then the new item is selected.\n*\n* @param index the index of the item to select\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see Table#deselectAll()\n* @see Table#select(int)\n*/\n",
			"methodName":"public void setSelection(int index)"
		},
		"public void removeSelectionListener(SelectionListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.Selection, listener);\n    eventTable.unhook(SWT.DefaultSelection, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when the receiver's selection changes.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see SelectionListener\n* @see #addSelectionListener(SelectionListener)\n*/\n",
			"methodName":"public void removeSelectionListener(SelectionListener listener)"
		},
		"LRESULT WM_RBUTTONDBLCLK(int wParam, int lParam)":{
			"methodBody":"{\n    \n    LVHITTESTINFO pinfo = new LVHITTESTINFO();\n    pinfo.x = (short) (lParam & 0xFFFF);\n    pinfo.y = (short) (lParam >> 16);\n    OS.SendMessage(handle, OS.LVM_HITTEST, 0, pinfo);\n    sendMouseEvent(SWT.MouseDown, 1, handle, OS.WM_RBUTTONDOWN, wParam, lParam);\n    sendMouseEvent(SWT.MouseDoubleClick, 1, handle, OS.WM_RBUTTONDBLCLK, wParam, lParam);\n    if (pinfo.iItem != -1)\n        callWindowProc(handle, OS.WM_RBUTTONDBLCLK, wParam, lParam);\n    if (OS.GetCapture() != handle)\n        OS.SetCapture(handle);\n    return LRESULT.ZERO;\n}",
			"comments":"/*\n* Feature in Windows.  When the user selects outside of\n* a table item, Windows deselects all the items, even\n* when the table is multi-select.  While not strictly\n* wrong, this is unexpected.  The fix is to detect the\n* case and avoid calling the window proc.\n*/\n",
			"methodName":"LRESULT WM_RBUTTONDBLCLK(int wParam, int lParam)"
		},
		"void createWidget()":{
			"methodBody":"{\n    super.createWidget();\n    items = new TableItem[4];\n    columns = new TableColumn[4];\n    \n    if ((style & SWT.VIRTUAL) != 0)\n        customDraw = true;\n}",
			"comments":"/*\n* Force virtual tables to use custom draw.  This\n* is necessary to support colors and fonts for table\n* items.  When the application is queried for data,\n* setting the custom draw flag at that time is too\n* late.  The current item is not redrawn in order\n* to avoid recursion and NM_CUSTOMDRAW has already\n* been avoided because at the time of the message,\n* there were no items that required custom drawing.\n*/\n",
			"methodName":"void createWidget()"
		},
		"public void setRedraw(boolean redraw)":{
			"methodBody":"{\n    checkWidget();\n    \n    if (drawCount == 0) {\n        int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n        if ((bits & OS.WS_VISIBLE) == 0)\n            state |= HIDDEN;\n    }\n    if (redraw) {\n        if (--drawCount == 0) {\n            \n            \n            \n            setScrollWidth(null, true);\n            OS.SendMessage(handle, OS.WM_SETREDRAW, 1, 0);\n            int hwndHeader = OS.SendMessage(handle, OS.LVM_GETHEADER, 0, 0);\n            if (hwndHeader != 0)\n                OS.SendMessage(hwndHeader, OS.WM_SETREDRAW, 1, 0);\n            if ((state & HIDDEN) != 0) {\n                state &= ~HIDDEN;\n                OS.ShowWindow(handle, OS.SW_HIDE);\n            } else {\n                if (OS.IsWinCE) {\n                    OS.InvalidateRect(handle, null, false);\n                    if (hwndHeader != 0) {\n                        OS.InvalidateRect(hwndHeader, null, false);\n                    }\n                } else {\n                    int flags = OS.RDW_ERASE | OS.RDW_FRAME | OS.RDW_INVALIDATE | OS.RDW_ALLCHILDREN;\n                    OS.RedrawWindow(handle, null, 0, flags);\n                }\n            }\n        }\n    } else {\n        if (drawCount++ == 0) {\n            OS.SendMessage(handle, OS.WM_SETREDRAW, 0, 0);\n            int hwndHeader = OS.SendMessage(handle, OS.LVM_GETHEADER, 0, 0);\n            if (hwndHeader != 0)\n                OS.SendMessage(hwndHeader, OS.WM_SETREDRAW, 0, 0);\n        \n        \n        }\n    }\n}",
			"comments":"/*\n* Feature in Windows.  When WM_SETREDRAW is used to turn\n* off drawing in a widget, it clears the WS_VISIBLE bits\n* and then sets them when redraw is turned back on.  This\n* means that WM_SETREDRAW will make a widget unexpectedly\n* visible.  The fix is to track the visibility state while\n* drawing is turned off and restore it when drawing is turned\n* back on.\n*/\n/*\n* When many items are added to a table, it is faster to\n* temporarily unsubclass the window proc so that messages\n* are dispatched directly to the table.\n*\n* NOTE: This is optimization somewhat dangerous because any\n* operation can occur when redraw is turned off, even operations\n* where the table must be subclassed in order to have the correct\n* behavior or work around a Windows bug.\n*\n* This code is intentionally commented.\n*/\n//\t\t\tsubclass ();\n/* Set the width of the horizontal scroll bar */\n/*\n* When many items are added to a table, it is faster to\n* temporarily unsubclass the window proc so that messages\n* are dispatched directly to the table.\n*\n* NOTE: This is optimization somewhat dangerous because any\n* operation can occur when redraw is turned off, even operations\n* where the table must be subclassed in order to have the correct\n* behavior or work around a Windows bug.\n*\n* This code is intentionally commented.\n*/\n//\t\t\tunsubclass ();\n",
			"methodName":"public void setRedraw(boolean redraw)"
		},
		"public void select(int index)":{
			"methodBody":"{\n    checkWidget();\n    \n    if (index < 0)\n        return;\n    LVITEM lvItem = new LVITEM();\n    lvItem.state = OS.LVIS_SELECTED;\n    lvItem.stateMask = OS.LVIS_SELECTED;\n    ignoreSelect = true;\n    OS.SendMessage(handle, OS.LVM_SETITEMSTATE, index, lvItem);\n    ignoreSelect = false;\n}",
			"comments":"/**\n* Selects the item at the given zero-relative index in the receiver.\n* If the item at the index was already selected, it remains\n* selected. Indices that are out of range are ignored.\n*\n* @param index the index of the item to select\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* An index of -1 will apply the change to all\n* items.  Ensure that index is greater than -1.\n*/\n",
			"methodName":"public void select(int index)"
		},
		"public void setItemCount(int count)":{
			"methodBody":"{\n    checkWidget();\n    count = Math.max(0, count);\n    int itemCount = OS.SendMessage(handle, OS.LVM_GETITEMCOUNT, 0, 0);\n    if (count == itemCount)\n        return;\n    boolean isVirtual = (style & SWT.VIRTUAL) != 0;\n    if (!isVirtual)\n        setRedraw(false);\n    int index = count;\n    while (index < itemCount) {\n        TableItem item = items[index];\n        if (!isVirtual) {\n            ignoreSelect = ignoreShrink = true;\n            int code = OS.SendMessage(handle, OS.LVM_DELETEITEM, count, 0);\n            ignoreSelect = ignoreShrink = false;\n            if (code == 0)\n                break;\n        }\n        if (item != null && !item.isDisposed())\n            item.releaseResources();\n        index++;\n    }\n    if (index < itemCount)\n        error(SWT.ERROR_ITEM_NOT_REMOVED);\n    int length = Math.max(4, (count + 3) / 4 * 4);\n    TableItem[] newItems = new TableItem[length];\n    System.arraycopy(items, 0, newItems, 0, Math.min(count, itemCount));\n    items = newItems;\n    if (isVirtual) {\n        int flags = OS.LVSICF_NOINVALIDATEALL | OS.LVSICF_NOSCROLL;\n        OS.SendMessage(handle, OS.LVM_SETITEMCOUNT, count, flags);\n        \n        if (count == 0 && itemCount != 0) {\n            OS.InvalidateRect(handle, null, true);\n        }\n    } else {\n        for (int i = itemCount; i < count; i++) {\n            items[i] = new TableItem(this, SWT.NONE, i, true);\n        }\n    }\n    if (!isVirtual)\n        setRedraw(true);\n}",
			"comments":"/**\n* Sets the number of items contained in the receiver.\n*\n* @param count the number of items\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.0\n*/\n/*\n* Bug in Windows.  When a virutal table contains items and\n* LVM_SETITEMCOUNT is used to set the new item count to zero,\n* Windows does not redraw the table.  Note that simply not\n* specifying LVSICF_NOINVALIDATEALL or LVSICF_NOSCROLL does\n* correct the problem.  The fix is to force a redraw.\n*/\n",
			"methodName":"public void setItemCount(int count)"
		},
		"public int getTopIndex()":{
			"methodBody":"{\n    checkWidget();\n    \n    return Math.max(0, OS.SendMessage(handle, OS.LVM_GETTOPINDEX, 0, 0));\n}",
			"comments":"/**\n* Returns the zero-relative index of the item which is currently\n* at the top of the receiver. This index can change when items are\n* scrolled or new items are added or removed.\n*\n* @return the index of the top item\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* Bug in Windows.  Under rare circumstances, LVM_GETTOPINDEX\n* can return a negative number.  When this happens, the table\n* is displaying blank lines at the top of the controls.  The\n* fix is to check for a negative number and return zero instead.\n*/\n",
			"methodName":"public int getTopIndex()"
		},
		"public void setSelection(int[] indices)":{
			"methodBody":"{\n    checkWidget();\n    if (indices == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    deselectAll();\n    int length = indices.length;\n    if (length == 0 || ((style & SWT.SINGLE) != 0 && length > 1))\n        return;\n    select(indices);\n    int focusIndex = indices[0];\n    if (focusIndex != -1)\n        setFocusIndex(focusIndex);\n    showSelection();\n}",
			"comments":"/**\n* Selects the items at the given zero-relative indices in the receiver.\n* The current selection is cleared before the new items are selected.\n* <p>\n* Indices that are out of range and duplicate indices are ignored.\n* If the receiver is single-select and multiple indices are specified,\n* then all indices are ignored.\n*\n* @param indices the indices of the items to select\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the array of indices is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see Table#deselectAll()\n* @see Table#select(int[])\n*/\n",
			"methodName":"public void setSelection(int[] indices)"
		},
		"public void clear(int index)":{
			"methodBody":"{\n    checkWidget();\n    int count = OS.SendMessage(handle, OS.LVM_GETITEMCOUNT, 0, 0);\n    if (!(0 <= index && index < count))\n        error(SWT.ERROR_INVALID_RANGE);\n    TableItem item = items[index];\n    if (item != null) {\n        if (item != currentItem)\n            item.clear();\n        \n        if ((style & SWT.VIRTUAL) == 0 && item.cached) {\n            LVITEM lvItem = new LVITEM();\n            lvItem.mask = OS.LVIF_TEXT | OS.LVIF_INDENT;\n            lvItem.pszText = OS.LPSTR_TEXTCALLBACK;\n            lvItem.iItem = index;\n            OS.SendMessage(handle, OS.LVM_SETITEM, 0, lvItem);\n            item.cached = false;\n        }\n        if (currentItem == null && drawCount == 0 && OS.IsWindowVisible(handle)) {\n            OS.SendMessage(handle, OS.LVM_REDRAWITEMS, index, index);\n        }\n        setScrollWidth(item, false);\n    }\n}",
			"comments":"/**\n* Clears the item at the given zero-relative index in the receiver.\n* The text, icon and other attributes of the item are set to the default\n* value.  If the table was created with the SWT.VIRTUAL style, these\n* attributes are requested again as needed.\n*\n* @param index the index of the item to clear\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_RANGE - if the index is not between 0 and the number of elements in the list minus 1 (inclusive)</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see SWT#VIRTUAL\n* @see SWT#SetData\n*\n* @since 3.0\n*/\n/*\n* Bug in Windows.  Despite the fact that every item in the\n* table always has LPSTR_TEXTCALLBACK, Windows caches the\n* bounds for the selected items.  This means that\n* when you change the string to be something else, Windows\n* correctly asks you for the new string but when the item\n* is selected, the selection draws using the bounds of the\n* previous item.  The fix is to reset LPSTR_TEXTCALLBACK\n* even though it has not changed, causing Windows to flush\n* cached bounds.\n*/\n",
			"methodName":"public void clear(int index)"
		},
		"int getFocusIndex()":{
			"methodBody":"{\n    \n    return OS.SendMessage(handle, OS.LVM_GETNEXTITEM, -1, OS.LVNI_FOCUSED);\n}",
			"comments":"/*\n* Not currently used.\n*/\n//\tcheckWidget ();\n",
			"methodName":"int getFocusIndex()"
		},
		"public TableItem getItem(Point point)":{
			"methodBody":"{\n    checkWidget();\n    if (point == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    LVHITTESTINFO pinfo = new LVHITTESTINFO();\n    pinfo.x = point.x;\n    pinfo.y = point.y;\n    OS.SendMessage(handle, OS.LVM_HITTEST, 0, pinfo);\n    if (pinfo.iItem != -1)\n        return _getItem(pinfo.iItem);\n    return null;\n}",
			"comments":"/**\n* Returns the item at the given point in the receiver\n* or null if no such item exists. The point is in the\n* coordinate system of the receiver.\n*\n* @param point the point used to locate the item\n* @return the item at the given point\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the point is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public TableItem getItem(Point point)"
		},
		"public void setFont(Font font)":{
			"methodBody":"{\n    checkWidget();\n    \n    int topIndex = getTopIndex();\n    setRedraw(false);\n    setTopIndex(0);\n    super.setFont(font);\n    setTopIndex(topIndex);\n    setScrollWidth(null, true);\n    setRedraw(true);\n    \n    int hwndHeader = OS.SendMessage(handle, OS.LVM_GETHEADER, 0, 0);\n    OS.InvalidateRect(hwndHeader, null, true);\n    int bits = OS.SendMessage(handle, OS.LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0);\n    if ((bits & OS.LVS_EX_GRIDLINES) == 0)\n        return;\n    bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n    if ((bits & OS.LVS_NOCOLUMNHEADER) != 0)\n        return;\n    setItemHeight();\n}",
			"comments":"/*\n* Bug in Windows.  Making any change to an item that\n* changes the item height of a table while the table\n* is scrolled can cause the lines to draw incorrectly.\n* This happens even when the lines are not currently\n* visible and are shown afterwards.  The fix is to\n* save the top index, scroll to the top of the table\n* and then restore the original top index.\n*/\n/*\n* Bug in Windows.  Setting the font will cause the table\n* to be redrawn but not the column headers.  The fix is\n* to force a redraw of the column headers.\n*/\n",
			"methodName":"public void setFont(Font font)"
		},
		"int windowProc()":{
			"methodBody":"{\n    return TableProc;\n}",
			"comments":"",
			"methodName":"int windowProc()"
		},
		"public int getSelectionCount()":{
			"methodBody":"{\n    checkWidget();\n    return OS.SendMessage(handle, OS.LVM_GETSELECTEDCOUNT, 0, 0);\n}",
			"comments":"/**\n* Returns the number of selected items contained in the receiver.\n*\n* @return the number of selected items\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getSelectionCount()"
		},
		"public void removeAll()":{
			"methodBody":"{\n    checkWidget();\n    int hwndHeader = OS.SendMessage(handle, OS.LVM_GETHEADER, 0, 0);\n    int columnCount = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n    if (columnCount == 1 && columns[0] == null)\n        columnCount = 0;\n    int itemCount = OS.SendMessage(handle, OS.LVM_GETITEMCOUNT, 0, 0);\n    \n    if (OS.IsWin95 && columnCount > 1) {\n        boolean redraw = drawCount == 0 && OS.IsWindowVisible(handle);\n        if (redraw)\n            OS.SendMessage(handle, OS.WM_SETREDRAW, 0, 0);\n        int index = itemCount - 1;\n        while (index >= 0) {\n            TableItem item = items[index];\n            ignoreSelect = ignoreShrink = true;\n            int code = OS.SendMessage(handle, OS.LVM_DELETEITEM, index, 0);\n            ignoreSelect = ignoreShrink = false;\n            if (code == 0)\n                break;\n            if (item != null && !item.isDisposed())\n                item.releaseResources();\n            --index;\n        }\n        if (redraw) {\n            OS.SendMessage(handle, OS.WM_SETREDRAW, 1, 0);\n        \n        \n        \n        }\n        if (index != -1)\n            error(SWT.ERROR_ITEM_NOT_REMOVED);\n    } else {\n        ignoreSelect = ignoreShrink = true;\n        int code = OS.SendMessage(handle, OS.LVM_DELETEALLITEMS, 0, 0);\n        ignoreSelect = ignoreShrink = false;\n        if (code == 0)\n            error(SWT.ERROR_ITEM_NOT_REMOVED);\n        for (int i = 0; i < itemCount; i++) {\n            TableItem item = items[i];\n            if (item != null && !item.isDisposed())\n                item.releaseResources();\n        }\n    }\n    setTableEmpty();\n}",
			"comments":"/**\n* Removes all of the items from the receiver.\n* <p>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* Feature in Windows 98.  When there are a large number\n* of columns and items in a table (>1000) where each\n* of the subitems in the table has a string, it is much\n* faster to delete each item with LVM_DELETEITEM rather\n* than using LVM_DELETEALLITEMS.  The fix is to detect\n* this case and delete the items, one by one.  The fact\n* that the fix is only necessary on Windows 98 was\n* confirmed using version 5.81 of COMCTL32.DLL on both\n* Windows 98 and NT.\n*\n* NOTE: LVM_DELETEALLITEMS is also sent by the table\n* when the table is destroyed.\n*/\n/*\n* This code is intentionally commented.  The window proc\n* for the table implements WM_SETREDRAW to invalidate\n* and erase the table so it is not necessary to do this\n* again.\n*/\n//\t\t\tint flags = OS.RDW_ERASE | OS.RDW_FRAME | OS.RDW_INVALIDATE;\n//\t\t\tOS.RedrawWindow (handle, null, 0, flags);\n",
			"methodName":"public void removeAll()"
		},
		"public void addSelectionListener(SelectionListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.Selection, typedListener);\n    addListener(SWT.DefaultSelection, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when the receiver's selection changes, by sending\n* it one of the messages defined in the <code>SelectionListener</code>\n* interface.\n* <p>\n* When <code>widgetSelected</code> is called, the item field of the event object is valid.\n* If the reciever has <code>SWT.CHECK</code> style set and the check selection changes,\n* the event object detail field contains the value <code>SWT.CHECK</code>.\n* <code>widgetDefaultSelected</code> is typically called when an item is double-clicked.\n* The item field of the event object is valid for default selection, but the detail field is not used.\n* </p>\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see SelectionListener\n* @see #removeSelectionListener\n* @see SelectionEvent\n*/\n",
			"methodName":"public void addSelectionListener(SelectionListener listener)"
		},
		"void setBounds(int x, int y, int width, int height, int flags)":{
			"methodBody":"{\n    \n    boolean fixResize = false;\n    if ((flags & OS.SWP_NOSIZE) == 0) {\n        Rectangle rect = getBounds();\n        fixResize = rect.height < getItemHeight() * 2;\n    }\n    if (fixResize)\n        setRedraw(false);\n    super.setBounds(x, y, width, height, flags);\n    if (fixResize)\n        setRedraw(true);\n}",
			"comments":"/*\n* Bug in Windows.  If the table column widths are adjusted\n* in WM_SIZE or WM_POSITIONCHANGED using LVM_SETCOLUMNWIDTH\n* blank lines may be inserted at the top of the table.  A\n* call to LVM_GETTOPINDEX will return a negative number (this\n* is an impossible result).  Once the blank lines appear,\n* there seems to be no way to get rid of them, other than\n* destroying and recreating the table.  By observation, the\n* problem happens when the height of the table is less than\n* the two times the height of a line (this was tested using\n* different fonts and images).  It also seems that the bug\n* does not occur when the redraw is turned off for the table.\n* The fix is to turn off drawing when resizing a table that\n* is small enough to show the problem.\n*/\n",
			"methodName":"void setBounds(int x, int y, int width, int height, int flags)"
		},
		"public void deselect(int[] indices)":{
			"methodBody":"{\n    checkWidget();\n    if (indices == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (indices.length == 0)\n        return;\n    LVITEM lvItem = new LVITEM();\n    lvItem.stateMask = OS.LVIS_SELECTED;\n    for (int i = 0; i < indices.length; i++) {\n        \n        if (indices[i] >= 0) {\n            ignoreSelect = true;\n            OS.SendMessage(handle, OS.LVM_SETITEMSTATE, indices[i], lvItem);\n            ignoreSelect = false;\n        }\n    }\n}",
			"comments":"/**\n* Deselects the items at the given zero-relative indices in the receiver.\n* If the item at the given zero-relative index in the receiver\n* is selected, it is deselected.  If the item at the index\n* was not selected, it remains deselected. Indices that are out\n* of range and duplicate indices are ignored.\n*\n* @param indices the array of indices for the items to deselect\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the set of indices is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* An index of -1 will apply the change to all\n* items.  Ensure that indices are greater than -1.\n*/\n",
			"methodName":"public void deselect(int[] indices)"
		},
		"public void showItem(TableItem item)":{
			"methodBody":"{\n    checkWidget();\n    if (item == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (item.isDisposed())\n        error(SWT.ERROR_INVALID_ARGUMENT);\n    int index = indexOf(item);\n    if (index != -1)\n        showItem(index);\n}",
			"comments":"/**\n* Shows the item.  If the item is already showing in the receiver,\n* this method simply returns.  Otherwise, the items are scrolled until\n* the item is visible.\n*\n* @param item the item to be shown\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the item is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the item has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see Table#showSelection()\n*/\n",
			"methodName":"public void showItem(TableItem item)"
		},
		"LRESULT WM_ERASEBKGND(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_ERASEBKGND(wParam, lParam);\n    if (result != null)\n        return result;\n    \n    return result;\n}",
			"comments":"/*\n* This code is intentionally commented.  When a table contains\n* images that are not in the first column, the work around causes\n* pixel corruption.\n*/\n//\tif (!OS.IsWindowEnabled (handle)) return result;\n//\t/*\n//\t* Feature in Windows.  When WM_ERASEBKGND is called,\n//\t* it clears the damaged area by filling it with the\n//\t* background color.  During WM_PAINT, when the table\n//\t* items are drawn, the background for each item is\n//\t* also drawn, causing flashing.  The fix is to adjust\n//\t* the damage by subtracting the bounds of each visible\n//\t* table item.\n//\t*/\n//\tint itemCount = getItemCount ();\n//\tif (itemCount == 0) return result;\n//\tGCData data = new GCData();\n//\tdata.device = display;\n//\tGC gc = GC.win32_new (wParam, data);\n//\tRegion region = new Region (display);\n//\tgc.getClipping (region);\n//\tint columnCount = Math.max (1, getColumnCount ());\n//\tRectangle clientArea = getClientArea ();\n//\tint i = getTopIndex ();\n//\tint bottomIndex = i + OS.SendMessage (handle, OS.LVM_GETCOUNTPERPAGE, 0, 0);\n//\tbottomIndex = Math.min (itemCount, bottomIndex);\n//\twhile (i < bottomIndex) {\n//\t\tint j = 0;\n//\t\twhile (j < columnCount) {\n//\t\t\tif (j != 0 || (!isSelected (i) && i != getFocusIndex ())) {\n//\t\t\t\tRECT rect = new RECT ();\n//\t\t\t\trect.top = j;\n//\t\t\t\trect.left = OS.LVIR_LABEL;\n//\t\t\t\tOS.SendMessage (handle, OS. LVM_GETSUBITEMRECT, i, rect);\n//\t\t\t\tint width = Math.max (0, rect.right - rect.left);\n//\t\t\t\tint height = Math.max (0, rect.bottom - rect.top);\n//\t\t\t\tRectangle rect2 = new Rectangle (rect.left, rect.top, width, height);\n//\t\t\t\tif (!rect2.intersects (clientArea)) break;\n//\t\t\t\tregion.subtract (rect2);\n//\t\t\t}\n//\t\t\tj++;\n//\t\t}\n//\t\ti++;\n//\t}\n//\tgc.setClipping (region);\n//\tdrawBackground (wParam);\n//\tgc.setClipping ((Region) null);\n//\tregion.dispose ();\n//\tgc.dispose ();\n//\treturn LRESULT.ONE;\n",
			"methodName":"LRESULT WM_ERASEBKGND(int wParam, int lParam)"
		},
		"public int getGridLineWidth()":{
			"methodBody":"{\n    checkWidget();\n    return GRID_WIDTH;\n}",
			"comments":"/**\n* Returns the width in pixels of a grid line.\n*\n* @return the width of a grid line in pixels\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getGridLineWidth()"
		},
		"void createItem(TableItem item, int index)":{
			"methodBody":"{\n    int count = OS.SendMessage(handle, OS.LVM_GETITEMCOUNT, 0, 0);\n    if (!(0 <= index && index <= count))\n        error(SWT.ERROR_INVALID_RANGE);\n    if (count == items.length) {\n        \n        boolean small = drawCount == 0 && OS.IsWindowVisible(handle);\n        int length = small ? items.length + 4 : Math.max(4, items.length * 3 / 2);\n        TableItem[] newItems = new TableItem[length];\n        System.arraycopy(items, 0, newItems, 0, items.length);\n        items = newItems;\n    }\n    LVITEM lvItem = new LVITEM();\n    lvItem.mask = OS.LVIF_TEXT | OS.LVIF_IMAGE;\n    lvItem.iItem = index;\n    lvItem.pszText = OS.LPSTR_TEXTCALLBACK;\n    \n    lvItem.iImage = OS.I_IMAGECALLBACK;\n    \n    ignoreSelect = true;\n    int result = OS.SendMessage(handle, OS.LVM_INSERTITEM, 0, lvItem);\n    ignoreSelect = false;\n    if (result == -1)\n        error(SWT.ERROR_ITEM_NOT_ADDED);\n    System.arraycopy(items, index, items, index + 1, count - index);\n    items[index] = item;\n}",
			"comments":"/*\n* Grow the array faster when redraw is off or the\n* table is not visible.  When the table is painted,\n* the items array is resized to be smaller to reduce\n* memory usage.\n*/\n/*\n* Bug in Windows.  Despite the fact that the image list\n* index has never been set for the item, Windows always\n* assumes that the image index for the item is valid.\n* When an item is inserted, the image index is zero.\n* Therefore, when the first image is inserted and is\n* assigned image index zero, every item draws with this\n* image.  The fix is to set the image index when the\n* the item is created.\n*/\n/* Insert the item */\n",
			"methodName":"void createItem(TableItem item, int index)"
		},
		"public void deselectAll()":{
			"methodBody":"{\n    checkWidget();\n    LVITEM lvItem = new LVITEM();\n    lvItem.mask = OS.LVIF_STATE;\n    lvItem.stateMask = OS.LVIS_SELECTED;\n    ignoreSelect = true;\n    OS.SendMessage(handle, OS.LVM_SETITEMSTATE, -1, lvItem);\n    ignoreSelect = false;\n}",
			"comments":"/**\n* Deselects all selected items in the receiver.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void deselectAll()"
		},
		"public boolean getHeaderVisible()":{
			"methodBody":"{\n    checkWidget();\n    int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n    return (bits & OS.LVS_NOCOLUMNHEADER) == 0;\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver's header is visible,\n* and <code>false</code> otherwise.\n* <p>\n* If one of the receiver's ancestors is not visible or some\n* other condition makes the receiver not visible, this method\n* may still indicate that it is considered visible even though\n* it may not actually be showing.\n* </p>\n*\n* @return the receiver's header's visibility state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public boolean getHeaderVisible()"
		},
		"LRESULT WM_MOUSEHOVER(int wParam, int lParam)":{
			"methodBody":"{\n    \n    LRESULT result = super.WM_MOUSEHOVER(wParam, lParam);\n    int bits = OS.SendMessage(handle, OS.LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0);\n    int mask = OS.LVS_EX_ONECLICKACTIVATE | OS.LVS_EX_TRACKSELECT | OS.LVS_EX_TWOCLICKACTIVATE;\n    if ((bits & mask) != 0)\n        return result;\n    return LRESULT.ZERO;\n}",
			"comments":"/*\n* Feature in Windows.  Despite the fact that hot\n* tracking is not enabled, the hot tracking code\n* in WM_MOUSEHOVER is executed causing the item\n* under the cursor to be selected.  The fix is to\n* avoid calling the window proc.\n*/\n",
			"methodName":"LRESULT WM_MOUSEHOVER(int wParam, int lParam)"
		},
		"int callWindowProc(int hwnd, int msg, int wParam, int lParam, boolean forceSelect)":{
			"methodBody":"{\n    if (handle == 0)\n        return 0;\n    boolean checkSelection = false, checkFilter = false, checkActivate = false;\n    switch(msg) {\n        case OS.WM_CHAR:\n        case OS.WM_IME_CHAR:\n        case OS.WM_KEYUP:\n        case OS.WM_SYSCHAR:\n        case OS.WM_SYSKEYDOWN:\n        case OS.WM_SYSKEYUP:\n        case OS.WM_LBUTTONDBLCLK:\n        case OS.WM_LBUTTONUP:\n        case OS.WM_MBUTTONDBLCLK:\n        case OS.WM_MBUTTONUP:\n        case OS.WM_MOUSEHOVER:\n        case OS.WM_MOUSELEAVE:\n        case OS.WM_MOUSEMOVE:\n        \n        case OS.WM_RBUTTONDBLCLK:\n        case OS.WM_RBUTTONUP:\n        case OS.WM_XBUTTONDBLCLK:\n        case OS.WM_XBUTTONUP:\n            checkSelection = true;\n            break;\n        \n        case OS.WM_LBUTTONDOWN:\n        case OS.WM_MBUTTONDOWN:\n        case OS.WM_RBUTTONDOWN:\n        case OS.WM_XBUTTONDOWN:\n            checkSelection = checkFilter = true;\n            break;\n        \n        case OS.WM_KEYDOWN:\n            checkSelection = checkActivate = true;\n            break;\n    }\n    boolean oldSelected = wasSelected;\n    if (checkSelection)\n        wasSelected = false;\n    if (checkActivate)\n        ignoreActivate = true;\n    if (checkFilter)\n        display.ignoreMsgFilter = true;\n    int code = OS.CallWindowProc(TableProc, hwnd, msg, wParam, lParam);\n    if (checkFilter)\n        display.ignoreMsgFilter = false;\n    if (checkActivate)\n        ignoreActivate = false;\n    if (checkSelection) {\n        if (wasSelected || forceSelect) {\n            Event event = new Event();\n            int index = OS.SendMessage(handle, OS.LVM_GETNEXTITEM, -1, OS.LVNI_FOCUSED);\n            if (index != -1)\n                event.item = _getItem(index);\n            postEvent(SWT.Selection, event);\n        }\n        wasSelected = oldSelected;\n    }\n    return code;\n}",
			"comments":"//\t\tcase OS.WM_MOUSEWHEEL:\n/*\n* Bug in Windows.  For some reason, when the user clicks\n* on this control, the Windows hook WH_MSGFILTER is sent\n* despite the fact that an input event from a dialog box,\n* message box, menu, or scroll bar did not seem to occur.\n* The fix is to ignore the hook.\n*/\n/*\n* Feature in Windows.  Windows sends LVN_ITEMACTIVATE from WM_KEYDOWN\n* instead of WM_CHAR.  This means that application code that expects\n* to consume the key press and therefore avoid a SWT.DefaultSelection\n* event will fail.  The fix is to ignore LVN_ITEMACTIVATE when it is\n* caused by WM_KEYDOWN and send SWT.DefaultSelection from WM_CHAR.\n*/\n",
			"methodName":"int callWindowProc(int hwnd, int msg, int wParam, int lParam, boolean forceSelect)"
		},
		"public void showColumn(TableColumn column)":{
			"methodBody":"{\n    checkWidget();\n    if (column == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (column.isDisposed())\n        error(SWT.ERROR_INVALID_ARGUMENT);\n    if (column.parent != this)\n        return;\n    int index = indexOf(column);\n    if (index == -1)\n        return;\n    int hwndHeader = OS.SendMessage(handle, OS.LVM_GETHEADER, 0, 0);\n    int count = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n    if (count <= 1 || !(0 <= index && index < count))\n        return;\n    \n    RECT rect = new RECT();\n    rect.left = OS.LVIR_BOUNDS;\n    if (index == 0) {\n        rect.top = 1;\n        OS.SendMessage(handle, OS.LVM_GETSUBITEMRECT, -1, rect);\n        rect.right = rect.left;\n        int width = OS.SendMessage(handle, OS.LVM_GETCOLUMNWIDTH, 0, 0);\n        rect.left = rect.right - width;\n    } else {\n        rect.top = index;\n        OS.SendMessage(handle, OS.LVM_GETSUBITEMRECT, -1, rect);\n    }\n    RECT area = new RECT();\n    OS.GetClientRect(handle, area);\n    if (rect.left < area.left) {\n        int dx = rect.left - area.left;\n        OS.SendMessage(handle, OS.LVM_SCROLL, dx, 0);\n    } else {\n        int width = Math.min(area.right - area.left, rect.right - rect.left);\n        if (rect.left + width > area.right) {\n            int dx = rect.left + width - area.right;\n            OS.SendMessage(handle, OS.LVM_SCROLL, dx, 0);\n        }\n    }\n}",
			"comments":"/**\n* Shows the column.  If the column is already showing in the receiver,\n* this method simply returns.  Otherwise, the columns are scrolled until\n* the column is visible.\n*\n* @param column the column to be shown\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the column is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the column has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.0\n*/\n/*\n* Feature in Windows.  Calling LVM_GETSUBITEMRECT with -1 for the\n* row number gives the bounds of the item that would be above the\n* first row in the table.  This is undocumented and does not work\n* for the first column. In this case, to get the bounds of the\n* first column, get the bounds of the second column and subtract\n* the width of the first. The left edge of the second column is\n* also used as the right edge of the first.\n*/\n",
			"methodName":"public void showColumn(TableColumn column)"
		},
		"void updateMoveable()":{
			"methodBody":"{\n    int hwndHeader = OS.SendMessage(handle, OS.LVM_GETHEADER, 0, 0);\n    int count = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n    if (count == 1 && columns[0] == null)\n        count = 0;\n    int index = 0;\n    while (index < count) {\n        if (columns[index].moveable)\n            break;\n        index++;\n    }\n    int newBits = index < count ? OS.LVS_EX_HEADERDRAGDROP : 0;\n    OS.SendMessage(handle, OS.LVM_SETEXTENDEDLISTVIEWSTYLE, OS.LVS_EX_HEADERDRAGDROP, newBits);\n}",
			"comments":"",
			"methodName":"void updateMoveable()"
		},
		"static int checkStyle(int style)":{
			"methodBody":"{\n    \n    style |= SWT.H_SCROLL | SWT.V_SCROLL;\n    return checkBits(style, SWT.SINGLE, SWT.MULTI, 0, 0, 0, 0);\n}",
			"comments":"/*\n* Feature in Windows.  It is not possible to create\n* a table that does not have scroll bars.  Therefore,\n* no matter what style bits are specified, set the\n* H_SCROLL and V_SCROLL bits so that the SWT style\n* will match the widget that Windows creates.\n*/\n",
			"methodName":"static int checkStyle(int style)"
		},
		"int getBackgroundPixel()":{
			"methodBody":"{\n    return OS.SendMessage(handle, OS.LVM_GETBKCOLOR, 0, 0);\n}",
			"comments":"",
			"methodName":"int getBackgroundPixel()"
		},
		"public Point computeSize(int wHint, int hHint, boolean changed)":{
			"methodBody":"{\n    checkWidget();\n    if (fixScrollWidth)\n        setScrollWidth(null, true);\n    int bits = 0;\n    if (wHint != SWT.DEFAULT) {\n        bits |= wHint & 0xFFFF;\n    } else {\n        int width = 0;\n        int hwndHeader = OS.SendMessage(handle, OS.LVM_GETHEADER, 0, 0);\n        int count = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n        for (int i = 0; i < count; i++) {\n            width += OS.SendMessage(handle, OS.LVM_GETCOLUMNWIDTH, i, 0);\n        }\n        bits |= width & 0xFFFF;\n    }\n    if (hHint != SWT.DEFAULT)\n        bits |= hHint << 16;\n    int result = OS.SendMessage(handle, OS.LVM_APPROXIMATEVIEWRECT, -1, bits);\n    int width = result & 0xFFFF, height = result >> 16;\n    \n    int empty = OS.SendMessage(handle, OS.LVM_APPROXIMATEVIEWRECT, 0, 0);\n    int oneItem = OS.SendMessage(handle, OS.LVM_APPROXIMATEVIEWRECT, 1, 0);\n    height -= (oneItem >> 16) - (empty >> 16);\n    if (width == 0)\n        width = DEFAULT_WIDTH;\n    if (height == 0)\n        height = DEFAULT_HEIGHT;\n    if (wHint != SWT.DEFAULT)\n        width = wHint;\n    if (hHint != SWT.DEFAULT)\n        height = hHint;\n    int border = getBorderWidth();\n    width += border * 2;\n    height += border * 2;\n    if ((style & SWT.V_SCROLL) != 0) {\n        width += OS.GetSystemMetrics(OS.SM_CXVSCROLL);\n    }\n    if ((style & SWT.H_SCROLL) != 0) {\n        height += OS.GetSystemMetrics(OS.SM_CYHSCROLL);\n    }\n    return new Point(width, height);\n}",
			"comments":"/*\n* Feature in Windows.  The height returned by LVM_APPROXIMATEVIEWRECT\n* includes the trim plus the height of the items plus one extra row.\n* The fix is to subtract the height of one row from the result height.\n*/\n",
			"methodName":"public Point computeSize(int wHint, int hHint, boolean changed)"
		},
		"public void clear(int start, int end)":{
			"methodBody":"{\n    checkWidget();\n    if (start > end)\n        return;\n    int count = OS.SendMessage(handle, OS.LVM_GETITEMCOUNT, 0, 0);\n    if (!(0 <= start && start <= end && end < count)) {\n        error(SWT.ERROR_INVALID_RANGE);\n    }\n    if (start == 0 && end == count - 1) {\n        clearAll();\n    } else {\n        LVITEM lvItem = null;\n        boolean cleared = false;\n        for (int i = start; i <= end; i++) {\n            TableItem item = items[i];\n            if (item != null) {\n                if (item != currentItem) {\n                    cleared = true;\n                    item.clear();\n                }\n                \n                if ((style & SWT.VIRTUAL) == 0 && item.cached) {\n                    if (lvItem == null) {\n                        lvItem = new LVITEM();\n                        lvItem.mask = OS.LVIF_TEXT | OS.LVIF_INDENT;\n                        lvItem.pszText = OS.LPSTR_TEXTCALLBACK;\n                    }\n                    lvItem.iItem = i;\n                    OS.SendMessage(handle, OS.LVM_SETITEM, 0, lvItem);\n                    item.cached = false;\n                }\n            }\n        }\n        if (cleared) {\n            if (currentItem == null && drawCount == 0 && OS.IsWindowVisible(handle)) {\n                OS.SendMessage(handle, OS.LVM_REDRAWITEMS, start, end);\n            }\n            TableItem item = start == end ? items[start] : null;\n            setScrollWidth(item, false);\n        }\n    }\n}",
			"comments":"/**\n* Removes the items from the receiver which are between the given\n* zero-relative start and end indices (inclusive).  The text, icon\n* and other attribues of the items are set to their default values.\n* If the table was created with the SWT.VIRTUAL style, these attributes\n* are requested again as needed.\n*\n* @param start the start index of the item to clear\n* @param end the end index of the item to clear\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_RANGE - if either the start or end are not between 0 and the number of elements in the list minus 1 (inclusive)</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see SWT#VIRTUAL\n* @see SWT#SetData\n*\n* @since 3.0\n*/\n/*\n* Bug in Windows.  Despite the fact that every item in the\n* table always has LPSTR_TEXTCALLBACK, Windows caches the\n* bounds for the selected items.  This means that\n* when you change the string to be something else, Windows\n* correctly asks you for the new string but when the item\n* is selected, the selection draws using the bounds of the\n* previous item.  The fix is to reset LPSTR_TEXTCALLBACK\n* even though it has not changed, causing Windows to flush\n* cached bounds.\n*/\n",
			"methodName":"public void clear(int start, int end)"
		},
		"public void setLinesVisible(boolean show)":{
			"methodBody":"{\n    checkWidget();\n    int newBits = 0;\n    if (show) {\n        newBits = OS.LVS_EX_GRIDLINES;\n        int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n        if ((bits & OS.LVS_NOCOLUMNHEADER) == 0)\n            setItemHeight();\n    }\n    OS.SendMessage(handle, OS.LVM_SETEXTENDEDLISTVIEWSTYLE, OS.LVS_EX_GRIDLINES, newBits);\n}",
			"comments":"/**\n* Marks the receiver's lines as visible if the argument is <code>true</code>,\n* and marks it invisible otherwise.\n* <p>\n* If one of the receiver's ancestors is not visible or some\n* other condition makes the receiver not visible, marking\n* it visible may not actually cause it to be displayed.\n* </p>\n*\n* @param show the new visibility state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setLinesVisible(boolean show)"
		},
		"TCHAR windowClass()":{
			"methodBody":"{\n    return TableClass;\n}",
			"comments":"",
			"methodName":"TCHAR windowClass()"
		},
		"LRESULT WM_RBUTTONDOWN(int wParam, int lParam)":{
			"methodBody":"{\n    \n    return sendMouseDownEvent(SWT.MouseDown, 3, OS.WM_RBUTTONDOWN, wParam, lParam);\n}",
			"comments":"/*\n* Feature in Windows.  For some reason, capturing\n* the mouse after processing the mouse event for the\n* widget interferes with the normal mouse processing\n* for the widget.  The fix is to avoid the automatic\n* mouse capture.\n*/\n",
			"methodName":"LRESULT WM_RBUTTONDOWN(int wParam, int lParam)"
		},
		"public TableItem[] getItems()":{
			"methodBody":"{\n    checkWidget();\n    int count = OS.SendMessage(handle, OS.LVM_GETITEMCOUNT, 0, 0);\n    TableItem[] result = new TableItem[count];\n    if ((style & SWT.VIRTUAL) != 0) {\n        for (int i = 0; i < count; i++) {\n            result[i] = _getItem(i);\n        }\n    } else {\n        System.arraycopy(items, 0, result, 0, count);\n    }\n    return result;\n}",
			"comments":"/**\n* Returns a (possibly empty) array of <code>TableItem</code>s which\n* are the items in the receiver.\n* <p>\n* Note: This is not the actual structure used by the receiver\n* to maintain its list of items, so modifying the array will\n* not affect the receiver.\n* </p>\n*\n* @return the items in the receiver\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public TableItem[] getItems()"
		},
		"public TableColumn getColumn(int index)":{
			"methodBody":"{\n    checkWidget();\n    int hwndHeader = OS.SendMessage(handle, OS.LVM_GETHEADER, 0, 0);\n    int count = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n    if (count == 1 && columns[0] == null)\n        count = 0;\n    if (!(0 <= index && index < count))\n        error(SWT.ERROR_INVALID_RANGE);\n    return columns[index];\n}",
			"comments":"/**\n* Returns the column at the given, zero-relative index in the\n* receiver. Throws an exception if the index is out of range.\n* If no <code>TableColumn</code>s were created by the programmer,\n* this method will throw <code>ERROR_INVALID_RANGE</code> despite\n* the fact that a single column of data may be visible in the table.\n* This occurs when the programmer uses the table like a list, adding\n* items but never creating a column.\n*\n* @param index the index of the column to return\n* @return the column at the given index\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_RANGE - if the index is not between 0 and the number of elements in the list minus 1 (inclusive)</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public TableColumn getColumn(int index)"
		},
		"String toolTipText(NMTTDISPINFO hdr)":{
			"methodBody":"{\n    int hwndToolTip = OS.SendMessage(handle, OS.LVM_GETTOOLTIPS, 0, 0);\n    \n    if (hwndToolTip == hdr.hwndFrom && toolTipText != null)\n        return \"\";\n    return super.toolTipText(hdr);\n}",
			"comments":"//$NON-NLS-1$\n",
			"methodName":"String toolTipText(NMTTDISPINFO hdr)"
		},
		"void releaseWidget()":{
			"methodBody":"{\n    int hwndHeader = OS.SendMessage(handle, OS.LVM_GETHEADER, 0, 0);\n    int columnCount = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n    if (columnCount == 1 && columns[0] == null)\n        columnCount = 0;\n    int itemCount = OS.SendMessage(handle, OS.LVM_GETITEMCOUNT, 0, 0);\n    \n    if (OS.IsWin95 && columnCount > 1) {\n        \n        OS.SendMessage(handle, OS.WM_SETREDRAW, 0, 0);\n        for (int i = itemCount - 1; i >= 0; --i) {\n            TableItem item = items[i];\n            ignoreSelect = ignoreShrink = true;\n            OS.SendMessage(handle, OS.LVM_DELETEITEM, i, 0);\n            ignoreSelect = ignoreShrink = false;\n            if (item != null && !item.isDisposed())\n                item.releaseResources();\n        }\n    } else {\n        for (int i = 0; i < itemCount; i++) {\n            TableItem item = items[i];\n            if (item != null && !item.isDisposed())\n                item.releaseResources();\n        }\n    }\n    customDraw = false;\n    currentItem = null;\n    items = null;\n    for (int i = 0; i < columnCount; i++) {\n        TableColumn column = columns[i];\n        if (!column.isDisposed())\n            column.releaseResources();\n    }\n    columns = null;\n    if (imageList != null) {\n        OS.SendMessage(handle, OS.LVM_SETIMAGELIST, OS.LVSIL_SMALL, 0);\n        display.releaseImageList(imageList);\n    }\n    imageList = null;\n    int hOldList = OS.SendMessage(handle, OS.LVM_GETIMAGELIST, OS.LVSIL_STATE, 0);\n    OS.SendMessage(handle, OS.LVM_SETIMAGELIST, OS.LVSIL_STATE, 0);\n    if (hOldList != 0)\n        OS.ImageList_Destroy(hOldList);\n    super.releaseWidget();\n}",
			"comments":"/*\n* Feature in Windows 98.  When there are a large number\n* of columns and items in a table (>1000) where each\n* of the subitems in the table has a string, it is much\n* faster to delete each item with LVM_DELETEITEM rather\n* than using LVM_DELETEALLITEMS.  The fix is to detect\n* this case and delete the items, one by one.  The fact\n* that the fix is only necessary on Windows 98 was\n* confirmed using version 5.81 of COMCTL32.DLL on both\n* Windows 98 and NT.\n*\n* NOTE: LVM_DELETEALLITEMS is also sent by the table\n* when the table is destroyed.\n*/\n/* Turn off redraw and leave it off */\n",
			"methodName":"void releaseWidget()"
		},
		"public void select(int[] indices)":{
			"methodBody":"{\n    checkWidget();\n    if (indices == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    int length = indices.length;\n    if (length == 0 || ((style & SWT.SINGLE) != 0 && length > 1))\n        return;\n    LVITEM lvItem = new LVITEM();\n    lvItem.state = OS.LVIS_SELECTED;\n    lvItem.stateMask = OS.LVIS_SELECTED;\n    for (int i = length - 1; i >= 0; --i) {\n        \n        if (indices[i] >= 0) {\n            ignoreSelect = true;\n            OS.SendMessage(handle, OS.LVM_SETITEMSTATE, indices[i], lvItem);\n            ignoreSelect = false;\n        }\n    }\n}",
			"comments":"/**\n* Selects the items at the given zero-relative indices in the receiver.\n* The current selection is not cleared before the new items are selected.\n* <p>\n* If the item at a given index is not selected, it is selected.\n* If the item at a given index was already selected, it remains selected.\n* Indices that are out of range and duplicate indices are ignored.\n* If the receiver is single-select and multiple indices are specified,\n* then all indices are ignored.\n*\n* @param indices the array of indices for the items to select\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the array of indices is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see Table#setSelection(int[])\n*/\n/*\n* An index of -1 will apply the change to all\n* items.  Ensure that indices are greater than -1.\n*/\n",
			"methodName":"public void select(int[] indices)"
		},
		"public int indexOf(TableItem item)":{
			"methodBody":"{\n    checkWidget();\n    if (item == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    int count = OS.SendMessage(handle, OS.LVM_GETITEMCOUNT, 0, 0);\n    if (1 <= lastIndexOf && lastIndexOf < count - 1) {\n        if (items[lastIndexOf] == item)\n            return lastIndexOf;\n        if (items[lastIndexOf + 1] == item)\n            return ++lastIndexOf;\n        if (items[lastIndexOf - 1] == item)\n            return --lastIndexOf;\n    }\n    if (lastIndexOf < count / 2) {\n        for (int i = 0; i < count; i++) {\n            if (items[i] == item)\n                return lastIndexOf = i;\n        }\n    } else {\n        for (int i = count - 1; i >= 0; --i) {\n            if (items[i] == item)\n                return lastIndexOf = i;\n        }\n    }\n    return -1;\n}",
			"comments":"/**\n* Searches the receiver's list starting at the first item\n* (index 0) until an item is found that is equal to the\n* argument, and returns the index of that item. If no item\n* is found, returns -1.\n*\n* @param item the search item\n* @return the index of the item\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the string is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int indexOf(TableItem item)"
		},
		"public TableItem[] getSelection()":{
			"methodBody":"{\n    checkWidget();\n    int i = -1, j = 0, count = OS.SendMessage(handle, OS.LVM_GETSELECTEDCOUNT, 0, 0);\n    TableItem[] result = new TableItem[count];\n    while ((i = OS.SendMessage(handle, OS.LVM_GETNEXTITEM, i, OS.LVNI_SELECTED)) != -1) {\n        result[j++] = _getItem(i);\n    }\n    return result;\n}",
			"comments":"/**\n* Returns an array of <code>TableItem</code>s that are currently\n* selected in the receiver. The order of the items is unspecified.\n* An empty array indicates that no items are selected.\n* <p>\n* Note: This is not the actual structure used by the receiver\n* to maintain its selection, so modifying the array will\n* not affect the receiver.\n* </p>\n* @return an array representing the selection\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public TableItem[] getSelection()"
		},
		"int callWindowProc(int hwnd, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    return callWindowProc(hwnd, msg, wParam, lParam, false);\n}",
			"comments":"",
			"methodName":"int callWindowProc(int hwnd, int msg, int wParam, int lParam)"
		},
		"void destroyItem(TableColumn column)":{
			"methodBody":"{\n    int hwndHeader = OS.SendMessage(handle, OS.LVM_GETHEADER, 0, 0);\n    int columnCount = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n    int index = 0;\n    while (index < columnCount) {\n        if (columns[index] == column)\n            break;\n        index++;\n    }\n    boolean first = false;\n    if (index == 0) {\n        first = true;\n        if (columnCount > 1) {\n            index = 1;\n            int cchTextMax = 1024;\n            int hHeap = OS.GetProcessHeap();\n            int byteCount = cchTextMax * TCHAR.sizeof;\n            int pszText = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, byteCount);\n            LVCOLUMN lvColumn = new LVCOLUMN();\n            lvColumn.mask = OS.LVCF_TEXT | OS.LVCF_WIDTH;\n            lvColumn.pszText = pszText;\n            lvColumn.cchTextMax = cchTextMax;\n            OS.SendMessage(handle, OS.LVM_GETCOLUMN, 1, lvColumn);\n            lvColumn.mask |= OS.LVCF_FMT;\n            lvColumn.fmt = OS.LVCFMT_LEFT;\n            OS.SendMessage(handle, OS.LVM_SETCOLUMN, 0, lvColumn);\n            if (pszText != 0)\n                OS.HeapFree(hHeap, 0, pszText);\n        } else {\n            int hHeap = OS.GetProcessHeap();\n            int pszText = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, TCHAR.sizeof);\n            LVCOLUMN lvColumn = new LVCOLUMN();\n            lvColumn.mask = OS.LVCF_TEXT;\n            lvColumn.pszText = pszText;\n            OS.SendMessage(handle, OS.LVM_SETCOLUMN, 0, lvColumn);\n            if (pszText != 0)\n                OS.HeapFree(hHeap, 0, pszText);\n        }\n        if ((parent.style & SWT.VIRTUAL) == 0) {\n            LVITEM lvItem = new LVITEM();\n            lvItem.mask = OS.LVIF_TEXT | OS.LVIF_IMAGE;\n            lvItem.pszText = OS.LPSTR_TEXTCALLBACK;\n            lvItem.iImage = OS.I_IMAGECALLBACK;\n            int itemCount = OS.SendMessage(handle, OS.LVM_GETITEMCOUNT, 0, 0);\n            for (int i = 0; i < itemCount; i++) {\n                lvItem.iItem = i;\n                OS.SendMessage(handle, OS.LVM_SETITEM, 0, lvItem);\n            }\n        }\n    }\n    if (columnCount > 1) {\n        if (OS.SendMessage(handle, OS.LVM_DELETECOLUMN, index, 0) == 0) {\n            error(SWT.ERROR_ITEM_NOT_REMOVED);\n        }\n    }\n    if (first)\n        index = 0;\n    System.arraycopy(columns, index + 1, columns, index, --columnCount - index);\n    columns[columnCount] = null;\n    int itemCount = OS.SendMessage(handle, OS.LVM_GETITEMCOUNT, 0, 0);\n    for (int i = 0; i < itemCount; i++) {\n        TableItem item = items[i];\n        if (item != null) {\n            if (columnCount == 0) {\n                item.strings = null;\n                item.images = null;\n                item.cellBackground = null;\n                item.cellForeground = null;\n                item.cellFont = null;\n            } else {\n                if (item.strings != null) {\n                    String[] strings = item.strings;\n                    if (index == 0) {\n                        \n                        item.text = strings[1] != null ? strings[1] : \"\";\n                    }\n                    String[] temp = new String[columnCount];\n                    System.arraycopy(strings, 0, temp, 0, index);\n                    System.arraycopy(strings, index + 1, temp, index, columnCount - index);\n                    item.strings = temp;\n                } else {\n                    \n                    if (index == 0)\n                        item.text = \"\";\n                }\n                if (item.images != null) {\n                    Image[] images = item.images;\n                    if (index == 0)\n                        item.image = images[1];\n                    Image[] temp = new Image[columnCount];\n                    System.arraycopy(images, 0, temp, 0, index);\n                    System.arraycopy(images, index + 1, temp, index, columnCount - index);\n                    item.images = temp;\n                } else {\n                    if (index == 0)\n                        item.image = null;\n                }\n                if (item.cellBackground != null) {\n                    int[] cellBackground = item.cellBackground;\n                    int[] temp = new int[columnCount];\n                    System.arraycopy(cellBackground, 0, temp, 0, index);\n                    System.arraycopy(cellBackground, index + 1, temp, index, columnCount - index);\n                    item.cellBackground = temp;\n                }\n                if (item.cellForeground != null) {\n                    int[] cellForeground = item.cellForeground;\n                    int[] temp = new int[columnCount];\n                    System.arraycopy(cellForeground, 0, temp, 0, index);\n                    System.arraycopy(cellForeground, index + 1, temp, index, columnCount - index);\n                    item.cellForeground = temp;\n                }\n                if (item.cellFont != null) {\n                    int[] cellFont = item.cellFont;\n                    int[] temp = new int[columnCount];\n                    System.arraycopy(cellFont, 0, temp, 0, index);\n                    System.arraycopy(cellFont, index + 1, temp, index, columnCount - index);\n                    item.cellFont = temp;\n                }\n            }\n        }\n    }\n    if (columnCount == 0)\n        setScrollWidth(null, true);\n    updateMoveable();\n}",
			"comments":"//$NON-NLS-1$\n//$NON-NLS-1$\n",
			"methodName":"void destroyItem(TableColumn column)"
		},
		"void setItemHeight()":{
			"methodBody":"{\n    \n    if (OS.COMCTL32_VERSION >= OS.VERSION(5, 80))\n        return;\n    int hOldList = OS.SendMessage(handle, OS.LVM_GETIMAGELIST, OS.LVSIL_SMALL, 0);\n    if (hOldList != 0)\n        return;\n    int hwndHeader = OS.SendMessage(handle, OS.LVM_GETHEADER, 0, 0);\n    RECT rect = new RECT();\n    OS.GetWindowRect(hwndHeader, rect);\n    int height = rect.bottom - rect.top - 1;\n    int hImageList = OS.ImageList_Create(1, height, 0, 0, 0);\n    OS.SendMessage(handle, OS.LVM_SETIMAGELIST, OS.LVSIL_SMALL, hImageList);\n    fixCheckboxImageList();\n    OS.SendMessage(handle, OS.LVM_SETIMAGELIST, OS.LVSIL_SMALL, 0);\n    OS.ImageList_Destroy(hImageList);\n}",
			"comments":"/*\n* Bug in Windows.  When both a header and grid lines are\n* displayed, the grid lines do not take into account the\n* height of the header and draw in the wrong place.  The\n* fix is to set the height of the table items to be the\n* height of the header so that the lines draw in the right\n* place.  The height of a table item is the maximum of the\n* height of the font or the height of image list.\n*\n* NOTE: In version 5.80 of COMCTL32.DLL, the bug is fixed.\n*/\n",
			"methodName":"void setItemHeight()"
		},
		"boolean setScrollWidth(TableItem item, boolean force)":{
			"methodBody":"{\n    if (currentItem != null) {\n        if (currentItem != item)\n            fixScrollWidth = true;\n        return false;\n    }\n    if (!force && (drawCount != 0 || !OS.IsWindowVisible(handle))) {\n        fixScrollWidth = true;\n        return false;\n    }\n    fixScrollWidth = false;\n    int hwndHeader = OS.SendMessage(handle, OS.LVM_GETHEADER, 0, 0);\n    int count = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n    \n    if (count == 1 && columns[0] == null) {\n        int newWidth = 0;\n        count = OS.SendMessage(handle, OS.LVM_GETITEMCOUNT, 0, 0);\n        int index = 0;\n        int imageIndent = 0;\n        while (index < count) {\n            String string = null;\n            int font = -1;\n            if (item != null) {\n                string = item.text;\n                imageIndent = Math.max(imageIndent, item.imageIndent);\n                if (item.cellFont != null)\n                    font = item.cellFont[0];\n                if (font == -1)\n                    font = item.font;\n            } else {\n                if (items[index] != null) {\n                    TableItem tableItem = items[index];\n                    string = tableItem.text;\n                    imageIndent = Math.max(imageIndent, tableItem.imageIndent);\n                    if (tableItem.cellFont != null)\n                        font = tableItem.cellFont[0];\n                    if (font == -1)\n                        font = tableItem.font;\n                }\n            }\n            if (string != null && string.length() != 0) {\n                if (font != -1) {\n                    int hDC = OS.GetDC(handle);\n                    int oldFont = OS.SelectObject(hDC, font);\n                    int flags = OS.DT_CALCRECT | OS.DT_SINGLELINE | OS.DT_NOPREFIX;\n                    TCHAR buffer = new TCHAR(getCodePage(), string, false);\n                    RECT rect = new RECT();\n                    OS.DrawText(hDC, buffer, buffer.length(), rect, flags);\n                    OS.SelectObject(hDC, oldFont);\n                    OS.ReleaseDC(handle, hDC);\n                    newWidth = Math.max(newWidth, rect.right - rect.left);\n                } else {\n                    TCHAR buffer = new TCHAR(getCodePage(), string, true);\n                    newWidth = Math.max(newWidth, OS.SendMessage(handle, OS.LVM_GETSTRINGWIDTH, 0, buffer));\n                }\n            }\n            if (item != null)\n                break;\n            index++;\n        }\n        int hStateList = OS.SendMessage(handle, OS.LVM_GETIMAGELIST, OS.LVSIL_STATE, 0);\n        if (hStateList != 0) {\n            int[] cx = new int[1], cy = new int[1];\n            OS.ImageList_GetIconSize(hStateList, cx, cy);\n            newWidth += cx[0] + INSET;\n        }\n        int hImageList = OS.SendMessage(handle, OS.LVM_GETIMAGELIST, OS.LVSIL_SMALL, 0);\n        if (hImageList != 0) {\n            int[] cx = new int[1], cy = new int[1];\n            OS.ImageList_GetIconSize(hImageList, cx, cy);\n            newWidth += (imageIndent + 1) * cx[0];\n        } else {\n            \n            newWidth++;\n        }\n        newWidth += INSET * 2;\n        int oldWidth = OS.SendMessage(handle, OS.LVM_GETCOLUMNWIDTH, 0, 0);\n        if (newWidth > oldWidth) {\n            OS.SendMessage(handle, OS.LVM_SETCOLUMNWIDTH, 0, newWidth);\n            return true;\n        }\n    }\n    return false;\n}",
			"comments":"/*\n* NOTE: It is much faster to measure the strings and compute the\n* width of the scroll bar in non-virtual table rather than using\n* LVM_SETCOLUMNWIDTH with LVSCW_AUTOSIZE.\n*/\n/*\n* Bug in Windows.  When LVM_SETIMAGELIST is used to remove the\n* image list by setting it to NULL, the item width and height\n* is not changed and space is reserved for icons despite the\n* fact that there are none.  The fix is to set the image list\n* to be very small before setting it to NULL.  This causes\n* Windows to reserve the smallest possible space when an image\n* list is removed.  In this case, the scroll width must be one\n* pixel larger.\n*/\n",
			"methodName":"boolean setScrollWidth(TableItem item, boolean force)"
		},
		"LRESULT WM_VSCROLL(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_VSCROLL(wParam, lParam);\n    \n    int bits = OS.SendMessage(handle, OS.LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0);\n    if ((bits & OS.LVS_EX_GRIDLINES) != 0) {\n        int code = wParam & 0xFFFF;\n        switch(code) {\n            case OS.SB_ENDSCROLL:\n            case OS.SB_THUMBPOSITION:\n            case OS.SB_THUMBTRACK:\n            case OS.SB_TOP:\n            case OS.SB_BOTTOM:\n                break;\n            case OS.SB_LINEDOWN:\n            case OS.SB_LINEUP:\n                int headerHeight = 0;\n                int hwndHeader = OS.SendMessage(handle, OS.LVM_GETHEADER, 0, 0);\n                if (hwndHeader != 0) {\n                    RECT rect = new RECT();\n                    OS.GetWindowRect(hwndHeader, rect);\n                    headerHeight = rect.bottom - rect.top;\n                }\n                RECT rect = new RECT();\n                OS.GetClientRect(handle, rect);\n                rect.top += headerHeight;\n                int empty = OS.SendMessage(handle, OS.LVM_APPROXIMATEVIEWRECT, 0, 0);\n                int oneItem = OS.SendMessage(handle, OS.LVM_APPROXIMATEVIEWRECT, 1, 0);\n                int itemHeight = (oneItem >> 16) - (empty >> 16);\n                if (code == OS.SB_LINEDOWN) {\n                    rect.top = rect.bottom - itemHeight - GRID_WIDTH;\n                } else {\n                    rect.bottom = rect.top + itemHeight + GRID_WIDTH;\n                }\n                OS.InvalidateRect(handle, rect, true);\n                break;\n            case OS.SB_PAGEDOWN:\n            case OS.SB_PAGEUP:\n                OS.InvalidateRect(handle, null, true);\n                break;\n        }\n    }\n    return result;\n}",
			"comments":"/*\n* Bug in Windows.  When a table is drawing grid lines and the\n* user scrolls vertically up or down by a line or a page, the\n* table does not redraw the grid lines for newly exposed items.\n* The fix is to invalidate the items.\n*/\n",
			"methodName":"LRESULT WM_VSCROLL(int wParam, int lParam)"
		},
		"protected void checkSubclass()":{
			"methodBody":"{\n    if (!isValidSubclass())\n        error(SWT.ERROR_INVALID_SUBCLASS);\n}",
			"comments":"",
			"methodName":"protected void checkSubclass()"
		},
		"public int getColumnCount()":{
			"methodBody":"{\n    checkWidget();\n    int hwndHeader = OS.SendMessage(handle, OS.LVM_GETHEADER, 0, 0);\n    int count = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n    if (count == 1 && columns[0] == null)\n        count = 0;\n    return count;\n}",
			"comments":"/**\n* Returns the number of columns contained in the receiver.\n* If no <code>TableColumn</code>s were created by the programmer,\n* this value is zero, despite the fact that visually, one column\n* of items may be visible. This occurs when the programmer uses\n* the table like a list, adding items but never creating a column.\n*\n* @return the number of columns\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getColumnCount()"
		},
		"void setFocusIndex(int index)":{
			"methodBody":"{\n    \n    if (index < 0)\n        return;\n    LVITEM lvItem = new LVITEM();\n    lvItem.state = OS.LVIS_FOCUSED;\n    lvItem.stateMask = OS.LVIS_FOCUSED;\n    ignoreSelect = true;\n    OS.SendMessage(handle, OS.LVM_SETITEMSTATE, index, lvItem);\n    ignoreSelect = false;\n}",
			"comments":"//\tcheckWidget ();\n/*\n* An index of -1 will apply the change to all\n* items.  Ensure that index is greater than -1.\n*/\n",
			"methodName":"void setFocusIndex(int index)"
		},
		"boolean checkData(TableItem item, boolean redraw)":{
			"methodBody":"{\n    if (item.cached)\n        return true;\n    if ((style & SWT.VIRTUAL) != 0) {\n        item.cached = true;\n        Event event = new Event();\n        event.item = item;\n        currentItem = item;\n        sendEvent(SWT.SetData, event);\n        \n        currentItem = null;\n        if (isDisposed() || item.isDisposed())\n            return false;\n        if (redraw) {\n            if (!setScrollWidth(item, false)) {\n                item.redraw();\n            }\n        }\n    }\n    return true;\n}",
			"comments":"//widget could be disposed at this point\n",
			"methodName":"boolean checkData(TableItem item, boolean redraw)"
		},
		"int defaultBackground()":{
			"methodBody":"{\n    return OS.GetSysColor(OS.COLOR_WINDOW);\n}",
			"comments":"",
			"methodName":"int defaultBackground()"
		},
		"public void clear(int[] indices)":{
			"methodBody":"{\n    checkWidget();\n    if (indices == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (indices.length == 0)\n        return;\n    int count = OS.SendMessage(handle, OS.LVM_GETITEMCOUNT, 0, 0);\n    for (int i = 0; i < indices.length; i++) {\n        if (!(0 <= indices[i] && indices[i] < count)) {\n            error(SWT.ERROR_INVALID_RANGE);\n        }\n    }\n    LVITEM lvItem = null;\n    boolean cleared = false;\n    for (int i = 0; i < indices.length; i++) {\n        int index = indices[i];\n        TableItem item = items[index];\n        if (item != null) {\n            if (item != currentItem) {\n                cleared = true;\n                item.clear();\n            }\n            \n            if ((style & SWT.VIRTUAL) == 0 && item.cached) {\n                if (lvItem == null) {\n                    lvItem = new LVITEM();\n                    lvItem.mask = OS.LVIF_TEXT | OS.LVIF_INDENT;\n                    lvItem.pszText = OS.LPSTR_TEXTCALLBACK;\n                }\n                lvItem.iItem = i;\n                OS.SendMessage(handle, OS.LVM_SETITEM, 0, lvItem);\n                item.cached = false;\n            }\n            if (currentItem == null && drawCount == 0 && OS.IsWindowVisible(handle)) {\n                OS.SendMessage(handle, OS.LVM_REDRAWITEMS, index, index);\n            }\n        }\n    }\n    if (cleared)\n        setScrollWidth(null, false);\n}",
			"comments":"/**\n* Clears the items at the given zero-relative indices in the receiver.\n* The text, icon and other attribues of the items are set to their default\n* values.  If the table was created with the SWT.VIRTUAL style, these\n* attributes are requested again as needed.\n*\n* @param indices the array of indices of the items\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_RANGE - if the index is not between 0 and the number of elements in the list minus 1 (inclusive)</li>\n*    <li>ERROR_NULL_ARGUMENT - if the indices array is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see SWT#VIRTUAL\n* @see SWT#SetData\n*\n* @since 3.0\n*/\n/*\n* Bug in Windows.  Despite the fact that every item in the\n* table always has LPSTR_TEXTCALLBACK, Windows caches the\n* bounds for the selected items.  This means that\n* when you change the string to be something else, Windows\n* correctly asks you for the new string but when the item\n* is selected, the selection draws using the bounds of the\n* previous item.  The fix is to reset LPSTR_TEXTCALLBACK\n* even though it has not changed, causing Windows to flush\n* cached bounds.\n*/\n",
			"methodName":"public void clear(int[] indices)"
		},
		"public void remove(int start, int end)":{
			"methodBody":"{\n    checkWidget();\n    if (start > end)\n        return;\n    int count = OS.SendMessage(handle, OS.LVM_GETITEMCOUNT, 0, 0);\n    if (!(0 <= start && start <= end && end < count)) {\n        error(SWT.ERROR_INVALID_RANGE);\n    }\n    if (start == 0 && end == count - 1) {\n        removeAll();\n    } else {\n        int index = start;\n        while (index <= end) {\n            TableItem item = items[index];\n            ignoreSelect = ignoreShrink = true;\n            int code = OS.SendMessage(handle, OS.LVM_DELETEITEM, start, 0);\n            ignoreSelect = ignoreShrink = false;\n            if (code == 0)\n                break;\n            if (item != null && !item.isDisposed())\n                item.releaseResources();\n            index++;\n        }\n        System.arraycopy(items, index, items, start, count - index);\n        for (int i = count - (index - start); i < count; i++) items[i] = null;\n        if (index <= end)\n            error(SWT.ERROR_ITEM_NOT_REMOVED);\n    }\n}",
			"comments":"/**\n* Removes the items from the receiver which are\n* between the given zero-relative start and end\n* indices (inclusive).\n*\n* @param start the start of the range\n* @param end the end of the range\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_RANGE - if either the start or end are not between 0 and the number of elements in the list minus 1 (inclusive)</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void remove(int start, int end)"
		},
		"void destroyItem(TableItem item)":{
			"methodBody":"{\n    int count = OS.SendMessage(handle, OS.LVM_GETITEMCOUNT, 0, 0);\n    int index = 0;\n    while (index < count) {\n        if (items[index] == item)\n            break;\n        index++;\n    }\n    if (index == count)\n        return;\n    ignoreSelect = ignoreShrink = true;\n    int code = OS.SendMessage(handle, OS.LVM_DELETEITEM, index, 0);\n    ignoreSelect = ignoreShrink = false;\n    if (code == 0)\n        error(SWT.ERROR_ITEM_NOT_REMOVED);\n    System.arraycopy(items, index + 1, items, index, --count - index);\n    items[count] = null;\n    if (count == 0)\n        setTableEmpty();\n}",
			"comments":"",
			"methodName":"void destroyItem(TableItem item)"
		},
		"public int getHeaderHeight()":{
			"methodBody":"{\n    checkWidget();\n    int hwndHeader = OS.SendMessage(handle, OS.LVM_GETHEADER, 0, 0);\n    if (hwndHeader == 0)\n        return 0;\n    RECT rect = new RECT();\n    OS.GetWindowRect(hwndHeader, rect);\n    return rect.bottom - rect.top;\n}",
			"comments":"/**\n* Returns the height of the receiver's header\n*\n* @return the height of the header or zero if the header is not visible\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 2.0\n*/\n",
			"methodName":"public int getHeaderHeight()"
		},
		"LRESULT WM_CHAR(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_CHAR(wParam, lParam);\n    if (result != null)\n        return result;\n    switch(wParam) {\n        case ' ':\n            if ((style & SWT.CHECK) != 0) {\n                int index = OS.SendMessage(handle, OS.LVM_GETNEXTITEM, -1, OS.LVNI_FOCUSED);\n                if (index != -1) {\n                    TableItem item = _getItem(index);\n                    item.setChecked(!item.getChecked(), true);\n                    if (!OS.IsWinCE) {\n                        OS.NotifyWinEvent(OS.EVENT_OBJECT_FOCUS, handle, OS.OBJID_CLIENT, index + 1);\n                    }\n                }\n            }\n            \n            int code = callWindowProc(handle, OS.WM_KEYDOWN, wParam, lParam);\n            return new LRESULT(code);\n        case SWT.CR:\n            \n            int index = OS.SendMessage(handle, OS.LVM_GETNEXTITEM, -1, OS.LVNI_FOCUSED);\n            if (index != -1) {\n                Event event = new Event();\n                event.item = _getItem(index);\n                postEvent(SWT.DefaultSelection, event);\n            }\n            return LRESULT.ZERO;\n    }\n    return result;\n}",
			"comments":"/*\n* NOTE: Call the window proc with WM_KEYDOWN rather than WM_CHAR\n* so that the key that was ignored during WM_KEYDOWN is processed.\n* This allows the application to cancel an operation that is normally\n* performed in WM_KEYDOWN from WM_CHAR.\n*/\n/*\n* Feature in Windows.  Windows sends LVN_ITEMACTIVATE from WM_KEYDOWN\n* instead of WM_CHAR.  This means that application code that expects\n* to consume the key press and therefore avoid a SWT.DefaultSelection\n* event will fail.  The fix is to ignore LVN_ITEMACTIVATE when it is\n* caused by WM_KEYDOWN and send SWT.DefaultSelection from WM_CHAR.\n*/\n",
			"methodName":"LRESULT WM_CHAR(int wParam, int lParam)"
		},
		"LRESULT WM_PAINT(int wParam, int lParam)":{
			"methodBody":"{\n    if (!ignoreShrink) {\n        \n        int count = OS.SendMessage(handle, OS.LVM_GETITEMCOUNT, 0, 0);\n        if (items.length > 4 && items.length - count > 3) {\n            int length = Math.max(4, (count + 3) / 4 * 4);\n            TableItem[] newItems = new TableItem[length];\n            System.arraycopy(items, 0, newItems, 0, count);\n            items = newItems;\n        }\n    }\n    if (fixScrollWidth)\n        setScrollWidth(null, true);\n    return super.WM_PAINT(wParam, lParam);\n}",
			"comments":"/* Resize the item array to match the item count */\n",
			"methodName":"LRESULT WM_PAINT(int wParam, int lParam)"
		},
		"public void remove(int index)":{
			"methodBody":"{\n    checkWidget();\n    int count = OS.SendMessage(handle, OS.LVM_GETITEMCOUNT, 0, 0);\n    if (!(0 <= index && index < count))\n        error(SWT.ERROR_INVALID_RANGE);\n    TableItem item = items[index];\n    ignoreSelect = ignoreShrink = true;\n    int code = OS.SendMessage(handle, OS.LVM_DELETEITEM, index, 0);\n    ignoreSelect = ignoreShrink = false;\n    if (code == 0)\n        error(SWT.ERROR_ITEM_NOT_REMOVED);\n    if (item != null && !item.isDisposed())\n        item.releaseResources();\n    System.arraycopy(items, index + 1, items, index, --count - index);\n    items[count] = null;\n    if (count == 0)\n        setTableEmpty();\n}",
			"comments":"/**\n* Removes the item from the receiver at the given\n* zero-relative index.\n*\n* @param index the index for the item\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_RANGE - if the index is not between 0 and the number of elements in the list minus 1 (inclusive)</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void remove(int index)"
		},
		"void createHandle()":{
			"methodBody":"{\n    super.createHandle();\n    state &= ~CANVAS;\n    \n    if (!OS.IsWinCE) {\n        if (OS.COMCTL32_MAJOR < 6) {\n            OS.SendMessage(handle, OS.CCM_SETVERSION, 5, 0);\n        }\n    }\n    \n    if ((style & SWT.CHECK) != 0) {\n        int empty = OS.SendMessage(handle, OS.LVM_APPROXIMATEVIEWRECT, 0, 0);\n        int oneItem = OS.SendMessage(handle, OS.LVM_APPROXIMATEVIEWRECT, 1, 0);\n        int width = (oneItem >> 16) - (empty >> 16), height = width;\n        setCheckboxImageList(width, height);\n        OS.SendMessage(handle, OS.LVM_SETCALLBACKMASK, OS.LVIS_STATEIMAGEMASK, 0);\n    }\n    \n    int hFont = OS.GetStockObject(OS.SYSTEM_FONT);\n    OS.SendMessage(handle, OS.WM_SETFONT, hFont, 0);\n    \n    LVCOLUMN lvColumn = new LVCOLUMN();\n    lvColumn.mask = OS.LVCF_TEXT;\n    int hHeap = OS.GetProcessHeap();\n    int pszText = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, TCHAR.sizeof);\n    lvColumn.pszText = pszText;\n    OS.SendMessage(handle, OS.LVM_INSERTCOLUMN, 0, lvColumn);\n    OS.HeapFree(hHeap, 0, pszText);\n    \n    int bits1 = OS.LVS_EX_SUBITEMIMAGES | OS.LVS_EX_LABELTIP;\n    if ((style & SWT.FULL_SELECTION) != 0)\n        bits1 |= OS.LVS_EX_FULLROWSELECT;\n    OS.SendMessage(handle, OS.LVM_SETEXTENDEDLISTVIEWSTYLE, bits1, bits1);\n    \n    if (OS.WIN32_VERSION < OS.VERSION(4, 10))\n        return;\n    if ((style & SWT.RIGHT_TO_LEFT) != 0) {\n        int hwndHeader = OS.SendMessage(handle, OS.LVM_GETHEADER, 0, 0);\n        int bits2 = OS.GetWindowLong(hwndHeader, OS.GWL_EXSTYLE);\n        OS.SetWindowLong(hwndHeader, OS.GWL_EXSTYLE, bits2 | OS.WS_EX_LAYOUTRTL);\n    }\n}",
			"comments":"/*\n* Feature in Windows.  In version 5.8 of COMCTL32.DLL,\n* if the font is changed for an item, the bounds for the\n* item are not updated, causing the text to be clipped.\n* The fix is to detect the version of COMCTL32.DLL, and\n* if it is one of the versions with the problem, then\n* use version 5.00 of the control (a version that does\n* not have the problem).  This is the recomended work\n* around from the MSDN.\n*/\n/*\n* This code is intentionally commented.  According to\n* the documentation, setting the default item size is\n* supposed to improve performance.  By experimentation,\n* this does not seem to have much of an effect.\n*/\n//\tOS.SendMessage (handle, OS.LVM_SETITEMCOUNT, 1024 * 2, 0);\n/* Set the checkbox image list */\n/*\n* Feature in Windows.  When the control is created,\n* it does not use the default system font.  A new HFONT\n* is created and destroyed when the control is destroyed.\n* This means that a program that queries the font from\n* this control, uses the font in another control and then\n* destroys this control will have the font unexpectedly\n* destroyed in the other control.  The fix is to assign\n* the font ourselves each time the control is created.\n* The control will not destroy a font that it did not\n* create.\n*/\n/*\n* Bug in Windows.  When the first column is inserted\n* without setting the header text, Windows will never\n* allow the header text for the first column to be set.\n* The fix is to set the text to an empty string when\n* the column is inserted.\n*/\n/* Set the extended style bits */\n/*\n* Feature in Windows.  Windows does not explicitly set the orientation of\n* the header.  Instead, the orientation is inherited when WS_EX_LAYOUTRTL\n* is specified for the table.  This means that when both WS_EX_LAYOUTRTL\n* and WS_EX_NOINHERITLAYOUT are specified for the table, the header will\n* not be oriented correctly.  The fix is to explicitly set the orientation\n* for the header.\n*\n* NOTE: WS_EX_LAYOUTRTL is not supported on Windows NT.\n*/\n",
			"methodName":"void createHandle()"
		},
		"void setCheckboxImageListColor()":{
			"methodBody":"{\n    if ((style & SWT.CHECK) == 0)\n        return;\n    int hOldStateList = OS.SendMessage(handle, OS.LVM_GETIMAGELIST, OS.LVSIL_STATE, 0);\n    if (hOldStateList == 0)\n        return;\n    int[] cx = new int[1], cy = new int[1];\n    OS.ImageList_GetIconSize(hOldStateList, cx, cy);\n    setCheckboxImageList(cx[0], cy[0]);\n}",
			"comments":"",
			"methodName":"void setCheckboxImageListColor()"
		},
		"LRESULT WM_SYSCOLORCHANGE(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_SYSCOLORCHANGE(wParam, lParam);\n    if (result != null)\n        return result;\n    if (background == -1) {\n        int pixel = defaultBackground();\n        OS.SendMessage(handle, OS.LVM_SETBKCOLOR, 0, pixel);\n        OS.SendMessage(handle, OS.LVM_SETTEXTBKCOLOR, 0, pixel);\n    }\n    if ((style & SWT.CHECK) != 0)\n        setCheckboxImageListColor();\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_SYSCOLORCHANGE(int wParam, int lParam)"
		},
		"public int indexOf(TableColumn column)":{
			"methodBody":"{\n    checkWidget();\n    if (column == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    int hwndHeader = OS.SendMessage(handle, OS.LVM_GETHEADER, 0, 0);\n    int count = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n    for (int i = 0; i < count; i++) {\n        if (columns[i] == column)\n            return i;\n    }\n    return -1;\n}",
			"comments":"/**\n* Searches the receiver's list starting at the first column\n* (index 0) until a column is found that is equal to the\n* argument, and returns the index of that column. If no column\n* is found, returns -1.\n*\n* @param column the search column\n* @return the index of the column\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the string is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int indexOf(TableColumn column)"
		},
		"LRESULT WM_GETOBJECT(int wParam, int lParam)":{
			"methodBody":"{\n    \n    if ((style & SWT.CHECK) != 0) {\n        if (accessible == null)\n            accessible = new_Accessible(this);\n    }\n    return super.WM_GETOBJECT(wParam, lParam);\n}",
			"comments":"/*\n* Ensure that there is an accessible object created for this\n* control because support for checked item accessibility is\n* temporarily implemented in the accessibility package.\n*/\n",
			"methodName":"LRESULT WM_GETOBJECT(int wParam, int lParam)"
		},
		"int widgetStyle()":{
			"methodBody":"{\n    int bits = super.widgetStyle() | OS.LVS_SHAREIMAGELISTS;\n    if ((style & SWT.HIDE_SELECTION) == 0)\n        bits |= OS.LVS_SHOWSELALWAYS;\n    if ((style & SWT.SINGLE) != 0)\n        bits |= OS.LVS_SINGLESEL;\n    \n    \n    bits |= OS.LVS_REPORT | OS.LVS_NOCOLUMNHEADER;\n    if ((style & SWT.VIRTUAL) != 0)\n        bits |= OS.LVS_OWNERDATA;\n    return bits;\n}",
			"comments":"/*\n* This code is intentionally commented.  In the future,\n* the FLAT bit may be used to make the header flat and\n* unresponsive to mouse clicks.\n*/\n//\tif ((style & SWT.FLAT) != 0) bits |= OS.LVS_NOSORTHEADER;\n",
			"methodName":"int widgetStyle()"
		},
		"public int getItemCount()":{
			"methodBody":"{\n    checkWidget();\n    return OS.SendMessage(handle, OS.LVM_GETITEMCOUNT, 0, 0);\n}",
			"comments":"/**\n* Returns the number of items contained in the receiver.\n*\n* @return the number of items\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getItemCount()"
		},
		"public int[] getSelectionIndices()":{
			"methodBody":"{\n    checkWidget();\n    int i = -1, j = 0, count = OS.SendMessage(handle, OS.LVM_GETSELECTEDCOUNT, 0, 0);\n    int[] result = new int[count];\n    while ((i = OS.SendMessage(handle, OS.LVM_GETNEXTITEM, i, OS.LVNI_SELECTED)) != -1) {\n        result[j++] = i;\n    }\n    return result;\n}",
			"comments":"/**\n* Returns the zero-relative indices of the items which are currently\n* selected in the receiver. The order of the indices is unspecified.\n* The array is empty if no items are selected.\n* <p>\n* Note: This is not the actual structure used by the receiver\n* to maintain its selection, so modifying the array will\n* not affect the receiver.\n* </p>\n* @return the array of indices of the selected items\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int[] getSelectionIndices()"
		},
		"LRESULT wmNotifyChild(int wParam, int lParam)":{
			"methodBody":"{\n    NMHDR hdr = new NMHDR();\n    OS.MoveMemory(hdr, lParam, NMHDR.sizeof);\n    switch(hdr.code) {\n        case OS.LVN_ODFINDITEMA:\n        case OS.LVN_ODFINDITEMW:\n            {\n                if ((style & SWT.VIRTUAL) != 0) {\n                    NMLVFINDITEM pnmfi = new NMLVFINDITEM();\n                    OS.MoveMemory(pnmfi, lParam, NMLVFINDITEM.sizeof);\n                    int index = Math.max(0, pnmfi.iStart - 1);\n                    return new LRESULT(index);\n                }\n                break;\n            }\n        case OS.LVN_GETDISPINFOA:\n        case OS.LVN_GETDISPINFOW:\n            {\n                \n                NMLVDISPINFO plvfi = new NMLVDISPINFO();\n                OS.MoveMemory(plvfi, lParam, NMLVDISPINFO.sizeof);\n                TableItem item = _getItem(plvfi.iItem);\n                \n                if (!item.cached) {\n                    if ((style & SWT.VIRTUAL) != 0) {\n                        lastIndexOf = plvfi.iItem;\n                        if (!checkData(item, false))\n                            break;\n                        TableItem newItem = fixScrollWidth ? null : item;\n                        if (setScrollWidth(newItem, true)) {\n                            OS.InvalidateRect(handle, null, true);\n                        }\n                    }\n                    item.cached = true;\n                }\n                if ((plvfi.mask & OS.LVIF_TEXT) != 0) {\n                    String string = null;\n                    if (plvfi.iSubItem == 0) {\n                        string = item.text;\n                    } else {\n                        String[] strings = item.strings;\n                        if (strings != null)\n                            string = strings[plvfi.iSubItem];\n                    }\n                    if (string != null) {\n                        \n                        if (!tipRequested && string.length() == 0 && plvfi.iSubItem == 0) {\n                            \n                            string = \" \";\n                        }\n                        TCHAR buffer = new TCHAR(getCodePage(), string, false);\n                        int byteCount = Math.min(buffer.length(), plvfi.cchTextMax - 1) * TCHAR.sizeof;\n                        OS.MoveMemory(plvfi.pszText, buffer, byteCount);\n                        OS.MoveMemory(plvfi.pszText + byteCount, new byte[TCHAR.sizeof], TCHAR.sizeof);\n                        plvfi.cchTextMax = Math.min(plvfi.cchTextMax, string.length() + 1);\n                    }\n                }\n                if ((plvfi.mask & OS.LVIF_IMAGE) != 0) {\n                    Image image = null;\n                    if (plvfi.iSubItem == 0) {\n                        image = item.image;\n                    } else {\n                        Image[] images = item.images;\n                        if (images != null)\n                            image = images[plvfi.iSubItem];\n                    }\n                    if (image != null)\n                        plvfi.iImage = imageIndex(image);\n                }\n                if ((plvfi.mask & OS.LVIF_STATE) != 0) {\n                    if (plvfi.iSubItem == 0) {\n                        int state = 1;\n                        if (item.checked)\n                            state++;\n                        if (item.grayed)\n                            state += 2;\n                        plvfi.state = state << 12;\n                        plvfi.stateMask = OS.LVIS_STATEIMAGEMASK;\n                    }\n                }\n                if ((plvfi.mask & OS.LVIF_INDENT) != 0) {\n                    if (plvfi.iSubItem == 0)\n                        plvfi.iIndent = item.imageIndent;\n                }\n                OS.MoveMemory(lParam, plvfi, NMLVDISPINFO.sizeof);\n                break;\n            }\n        case OS.NM_CUSTOMDRAW:\n            {\n                if (!customDraw)\n                    break;\n                NMLVCUSTOMDRAW nmcd = new NMLVCUSTOMDRAW();\n                OS.MoveMemory(nmcd, lParam, NMLVCUSTOMDRAW.sizeof);\n                switch(nmcd.dwDrawStage) {\n                    case OS.CDDS_PREPAINT:\n                        return new LRESULT(OS.CDRF_NOTIFYITEMDRAW);\n                    case OS.CDDS_ITEMPREPAINT:\n                        return new LRESULT(OS.CDRF_NOTIFYSUBITEMDRAW);\n                    case OS.CDDS_ITEMPREPAINT | OS.CDDS_SUBITEM:\n                        {\n                            TableItem item = _getItem(nmcd.dwItemSpec);\n                            int hFont = item.cellFont != null ? item.cellFont[nmcd.iSubItem] : -1;\n                            if (hFont == -1)\n                                hFont = item.font;\n                            int clrText = item.cellForeground != null ? item.cellForeground[nmcd.iSubItem] : -1;\n                            if (clrText == -1)\n                                clrText = item.foreground;\n                            int clrTextBk = item.cellBackground != null ? item.cellBackground[nmcd.iSubItem] : -1;\n                            if (clrTextBk == -1)\n                                clrTextBk = item.background;\n                            \n                            if (hFont == -1 && clrText == -1 && clrTextBk == -1) {\n                                if (item.cellForeground == null && item.cellBackground == null && item.cellFont == null) {\n                                    int hwndHeader = OS.SendMessage(handle, OS.LVM_GETHEADER, 0, 0);\n                                    int count = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n                                    if (count == 1)\n                                        break;\n                                }\n                            }\n                            if (hFont == -1)\n                                hFont = OS.SendMessage(handle, OS.WM_GETFONT, 0, 0);\n                            OS.SelectObject(nmcd.hdc, hFont);\n                            if (OS.IsWindowEnabled(handle)) {\n                                nmcd.clrText = clrText == -1 ? getForegroundPixel() : clrText;\n                                nmcd.clrTextBk = clrTextBk == -1 ? getBackgroundPixel() : clrTextBk;\n                                OS.MoveMemory(lParam, nmcd, NMLVCUSTOMDRAW.sizeof);\n                            }\n                            return new LRESULT(OS.CDRF_NEWFONT);\n                        }\n                }\n                break;\n            }\n        case OS.LVN_MARQUEEBEGIN:\n            return LRESULT.ONE;\n        case OS.LVN_BEGINDRAG:\n        case OS.LVN_BEGINRDRAG:\n            {\n                dragStarted = true;\n                if (hdr.code == OS.LVN_BEGINDRAG) {\n                    int pos = OS.GetMessagePos();\n                    POINT pt = new POINT();\n                    pt.x = (short) (pos & 0xFFFF);\n                    pt.y = (short) (pos >> 16);\n                    OS.ScreenToClient(handle, pt);\n                    Event event = new Event();\n                    event.x = pt.x;\n                    event.y = pt.y;\n                    postEvent(SWT.DragDetect, event);\n                }\n                break;\n            }\n        case OS.LVN_COLUMNCLICK:\n            {\n                NMLISTVIEW pnmlv = new NMLISTVIEW();\n                OS.MoveMemory(pnmlv, lParam, NMLISTVIEW.sizeof);\n                TableColumn column = columns[pnmlv.iSubItem];\n                if (column != null) {\n                    column.postEvent(SWT.Selection);\n                }\n                break;\n            }\n        case OS.LVN_ITEMACTIVATE:\n            {\n                if (ignoreActivate)\n                    break;\n                NMLISTVIEW pnmlv = new NMLISTVIEW();\n                OS.MoveMemory(pnmlv, lParam, NMLISTVIEW.sizeof);\n                if (pnmlv.iItem != -1) {\n                    Event event = new Event();\n                    event.item = _getItem(pnmlv.iItem);\n                    postEvent(SWT.DefaultSelection, event);\n                }\n                break;\n            }\n        case OS.LVN_ITEMCHANGED:\n            {\n                if (!ignoreSelect) {\n                    NMLISTVIEW pnmlv = new NMLISTVIEW();\n                    OS.MoveMemory(pnmlv, lParam, NMLISTVIEW.sizeof);\n                    if ((pnmlv.uChanged & OS.LVIF_STATE) != 0) {\n                        if (pnmlv.iItem == -1) {\n                            wasSelected = true;\n                        } else {\n                            boolean oldSelected = (pnmlv.uNewState & OS.LVIS_SELECTED) != 0;\n                            boolean newSelected = (pnmlv.uOldState & OS.LVIS_SELECTED) != 0;\n                            if (oldSelected != newSelected)\n                                wasSelected = true;\n                        }\n                    }\n                }\n                break;\n            }\n        case OS.NM_RECOGNIZEGESTURE:\n            \n            if (OS.IsPPC) {\n                boolean hasMenu = menu != null && !menu.isDisposed();\n                if (!hasMenu && !hooks(SWT.MenuDetect))\n                    return LRESULT.ONE;\n            }\n            break;\n        case OS.GN_CONTEXTMENU:\n            if (OS.IsPPC) {\n                boolean hasMenu = menu != null && !menu.isDisposed();\n                if (hasMenu || hooks(SWT.MenuDetect)) {\n                    NMRGINFO nmrg = new NMRGINFO();\n                    OS.MoveMemory(nmrg, lParam, NMRGINFO.sizeof);\n                    showMenu(nmrg.x, nmrg.y);\n                    return LRESULT.ONE;\n                }\n            }\n            break;\n    }\n    return super.wmNotifyChild(wParam, lParam);\n}",
			"comments":"//\t\t\tif (drawCount != 0 || !OS.IsWindowVisible (handle)) break;\n/*\n* The cached flag is used by both virtual and non-virtual\n* tables to indicate that Windows has asked at least once\n* for a table item.\n*/\n/*\n* Bug in Windows.  When pszText points to a zero length\n* NULL terminated string, Windows correctly draws the\n* empty string but the cache of the bounds for the item\n* is not reset.  This means that when the text for the\n* item is set and then reset to an empty string, the\n* selection draws using the bounds of the previous text.\n* The fix is to use a space rather than an empty string\n* when anything but a tool tip is requested (to avoid\n* a tool tip that is a single space).\n*\n* NOTE: This is only a problem for items in the first\n* column.  Assigning NULL to other columns stops Windows\n* from drawing the selection when LVS_EX_FULLROWSELECT\n* is set.\n*/\n//$NON-NLS-1$\n/*\n* Feature in Windows.  When the font is set for one cell in a table,\n* Windows does not reset the font for the next cell.  As a result,\n* all subsequent cells are drawn using the new font.  The fix is to\n* reset the font to the default.\n*\n* NOTE: This does not happen for foreground and background.\n*/\n/*\n* Feature on Pocket PC.  The tree and table controls detect the tap\n* and hold gesture by default. They send a GN_CONTEXTMENU message to show\n* the popup menu.  This default behaviour is unwanted on Pocket PC 2002\n* when no menu has been set, as it still draws a red circle.  The fix\n* is to disable this default behaviour when no menu is set by returning\n* TRUE when receiving the Pocket PC 2002 specific NM_RECOGNIZEGESTURE\n* message.\n*/\n",
			"methodName":"LRESULT wmNotifyChild(int wParam, int lParam)"
		},
		"public void clearAll()":{
			"methodBody":"{\n    checkWidget();\n    LVITEM lvItem = null;\n    boolean cleared = false;\n    int count = OS.SendMessage(handle, OS.LVM_GETITEMCOUNT, 0, 0);\n    for (int i = 0; i < count; i++) {\n        TableItem item = items[i];\n        if (item != null) {\n            if (item != currentItem) {\n                cleared = true;\n                item.clear();\n            }\n            \n            if ((style & SWT.VIRTUAL) == 0 && item.cached) {\n                if (lvItem == null) {\n                    lvItem = new LVITEM();\n                    lvItem.mask = OS.LVIF_TEXT | OS.LVIF_INDENT;\n                    lvItem.pszText = OS.LPSTR_TEXTCALLBACK;\n                }\n                lvItem.iItem = i;\n                OS.SendMessage(handle, OS.LVM_SETITEM, 0, lvItem);\n                item.cached = false;\n            }\n        }\n    }\n    if (cleared) {\n        if (currentItem == null && drawCount == 0 && OS.IsWindowVisible(handle)) {\n            OS.SendMessage(handle, OS.LVM_REDRAWITEMS, 0, count - 1);\n        }\n        setScrollWidth(null, false);\n    }\n}",
			"comments":"/**\n* Clears all the items in the receiver. The text, icon and other\n* attribues of the items are set to their default values. If the\n* table was created with the SWT.VIRTUAL style, these attributes\n* are requested again as needed.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see SWT#VIRTUAL\n* @see SWT#SetData\n*\n* @since 3.0\n*/\n/*\n* Bug in Windows.  Despite the fact that every item in the\n* table always has LPSTR_TEXTCALLBACK, Windows caches the\n* bounds for the selected items.  This means that\n* when you change the string to be something else, Windows\n* correctly asks you for the new string but when the item\n* is selected, the selection draws using the bounds of the\n* previous item.  The fix is to reset LPSTR_TEXTCALLBACK\n* even though it has not changed, causing Windows to flush\n* cached bounds.\n*/\n",
			"methodName":"public void clearAll()"
		},
		"void setBackgroundPixel(int pixel)":{
			"methodBody":"{\n    if (background == pixel)\n        return;\n    background = pixel;\n    if (pixel == -1)\n        pixel = defaultBackground();\n    OS.SendMessage(handle, OS.LVM_SETBKCOLOR, 0, pixel);\n    OS.SendMessage(handle, OS.LVM_SETTEXTBKCOLOR, 0, pixel);\n    if ((style & SWT.CHECK) != 0)\n        setCheckboxImageListColor();\n    \n    OS.InvalidateRect(handle, null, true);\n}",
			"comments":"/*\n* Feature in Windows.  When the background color is\n* changed, the table does not redraw until the next\n* WM_PAINT.  The fix is to force a redraw.\n*/\n",
			"methodName":"void setBackgroundPixel(int pixel)"
		},
		"public void showSelection()":{
			"methodBody":"{\n    checkWidget();\n    int index = OS.SendMessage(handle, OS.LVM_GETNEXTITEM, -1, OS.LVNI_SELECTED);\n    if (index != -1)\n        showItem(index);\n}",
			"comments":"/**\n* Shows the selection.  If the selection is already showing in the receiver,\n* this method simply returns.  Otherwise, the items are scrolled until\n* the selection is visible.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see Table#showItem(TableItem)\n*/\n",
			"methodName":"public void showSelection()"
		},
		"public int getItemHeight()":{
			"methodBody":"{\n    checkWidget();\n    int empty = OS.SendMessage(handle, OS.LVM_APPROXIMATEVIEWRECT, 0, 0);\n    int oneItem = OS.SendMessage(handle, OS.LVM_APPROXIMATEVIEWRECT, 1, 0);\n    return (oneItem >> 16) - (empty >> 16);\n}",
			"comments":"/**\n* Returns the height of the area which would be used to\n* display <em>one</em> of the items in the receiver's.\n*\n* @return the height of one item\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getItemHeight()"
		},
		"int getForegroundPixel()":{
			"methodBody":"{\n    int pixel = OS.SendMessage(handle, OS.LVM_GETTEXTCOLOR, 0, 0);\n    \n    if (pixel == OS.CLR_DEFAULT)\n        return OS.GetSysColor(OS.COLOR_WINDOWTEXT);\n    return pixel;\n}",
			"comments":"/*\n* The Windows table control uses CLR_DEFAULT to indicate\n* that it is using the default foreground color.  This\n* is undocumented.\n*/\n",
			"methodName":"int getForegroundPixel()"
		},
		"public void remove(int[] indices)":{
			"methodBody":"{\n    checkWidget();\n    if (indices == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (indices.length == 0)\n        return;\n    int[] newIndices = new int[indices.length];\n    System.arraycopy(indices, 0, newIndices, 0, indices.length);\n    sort(newIndices);\n    int start = newIndices[newIndices.length - 1], end = newIndices[0];\n    int count = OS.SendMessage(handle, OS.LVM_GETITEMCOUNT, 0, 0);\n    if (!(0 <= start && start <= end && end < count)) {\n        error(SWT.ERROR_INVALID_RANGE);\n    }\n    int last = -1;\n    for (int i = 0; i < newIndices.length; i++) {\n        int index = newIndices[i];\n        if (index != last) {\n            TableItem item = items[index];\n            ignoreSelect = ignoreShrink = true;\n            int code = OS.SendMessage(handle, OS.LVM_DELETEITEM, index, 0);\n            ignoreSelect = ignoreShrink = false;\n            if (code == 0)\n                error(SWT.ERROR_ITEM_NOT_REMOVED);\n            if (item != null && !item.isDisposed())\n                item.releaseResources();\n            System.arraycopy(items, index + 1, items, index, --count - index);\n            items[count] = null;\n            last = index;\n        }\n    }\n    if (count == 0)\n        setTableEmpty();\n}",
			"comments":"/**\n* Removes the items from the receiver's list at the given\n* zero-relative indices.\n*\n* @param indices the array of indices of the items\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_RANGE - if the index is not between 0 and the number of elements in the list minus 1 (inclusive)</li>\n*    <li>ERROR_NULL_ARGUMENT - if the indices array is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void remove(int[] indices)"
		},
		"LRESULT WM_NOTIFY(int wParam, int lParam)":{
			"methodBody":"{\n    NMHDR hdr = new NMHDR();\n    OS.MoveMemory(hdr, lParam, NMHDR.sizeof);\n    int hwndHeader = OS.SendMessage(handle, OS.LVM_GETHEADER, 0, 0);\n    if (hdr.hwndFrom == hwndHeader) {\n        \n        switch(hdr.code) {\n            case OS.HDN_BEGINTRACKW:\n            case OS.HDN_BEGINTRACKA:\n            case OS.HDN_DIVIDERDBLCLICKW:\n            case OS.HDN_DIVIDERDBLCLICKA:\n                {\n                    int count = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n                    if (count == 1 && columns[0] == null)\n                        return LRESULT.ONE;\n                    NMHEADER phdn = new NMHEADER();\n                    OS.MoveMemory(phdn, lParam, NMHEADER.sizeof);\n                    TableColumn column = columns[phdn.iItem];\n                    if (column != null && !column.getResizable()) {\n                        return LRESULT.ONE;\n                    }\n                    break;\n                }\n            case OS.NM_RELEASEDCAPTURE:\n                cancelMove = false;\n                break;\n            case OS.HDN_BEGINDRAG:\n                {\n                    if (cancelMove)\n                        return LRESULT.ONE;\n                    int bits = OS.SendMessage(handle, OS.LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0);\n                    if ((bits & OS.LVS_EX_HEADERDRAGDROP) == 0)\n                        break;\n                    int count = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n                    if (count == 1 && columns[0] == null)\n                        return LRESULT.ONE;\n                    NMHEADER phdn = new NMHEADER();\n                    OS.MoveMemory(phdn, lParam, NMHEADER.sizeof);\n                    if (phdn.iItem != -1) {\n                        TableColumn column = columns[phdn.iItem];\n                        if (column != null && !column.getMoveable()) {\n                            cancelMove = true;\n                            return LRESULT.ONE;\n                        }\n                    }\n                    break;\n                }\n            case OS.HDN_ENDDRAG:\n                {\n                    cancelMove = false;\n                    int bits = OS.SendMessage(handle, OS.LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0);\n                    if ((bits & OS.LVS_EX_HEADERDRAGDROP) == 0)\n                        break;\n                    NMHEADER phdn = new NMHEADER();\n                    OS.MoveMemory(phdn, lParam, NMHEADER.sizeof);\n                    if (phdn.iItem != -1 && phdn.pitem != 0) {\n                        HDITEM pitem = new HDITEM();\n                        OS.MoveMemory(pitem, phdn.pitem, HDITEM.sizeof);\n                        if ((pitem.mask & OS.HDI_ORDER) != 0 && pitem.iOrder != -1) {\n                            int count = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n                            if (count == 1 && columns[0] == null)\n                                break;\n                            int[] order = new int[count];\n                            OS.SendMessage(handle, OS.LVM_GETCOLUMNORDERARRAY, count, order);\n                            int index = 0;\n                            while (index < order.length) {\n                                if (order[index] == phdn.iItem)\n                                    break;\n                                index++;\n                            }\n                            if (index == order.length)\n                                index = 0;\n                            if (index == pitem.iOrder)\n                                break;\n                            int start = Math.min(index, pitem.iOrder);\n                            int end = Math.max(index, pitem.iOrder);\n                            for (int i = start; i <= end; i++) {\n                                TableColumn column = columns[order[i]];\n                                if (!column.isDisposed()) {\n                                    column.postEvent(SWT.Move);\n                                }\n                            }\n                        }\n                    }\n                    break;\n                }\n            case OS.HDN_ITEMCHANGEDW:\n            case OS.HDN_ITEMCHANGEDA:\n                {\n                    \n                    int width = OS.SendMessage(handle, OS.LVM_GETCOLUMNWIDTH, 0, 0);\n                    if (lastWidth == 0 && width > 0) {\n                        int bits = OS.SendMessage(handle, OS.LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0);\n                        if ((bits & OS.LVS_EX_GRIDLINES) != 0) {\n                            RECT rect = new RECT();\n                            OS.GetClientRect(handle, rect);\n                            rect.right = rect.left + width;\n                            OS.InvalidateRect(handle, rect, true);\n                        }\n                    }\n                    lastWidth = width;\n                    if (!ignoreResize) {\n                        NMHEADER phdn = new NMHEADER();\n                        OS.MoveMemory(phdn, lParam, NMHEADER.sizeof);\n                        if (phdn.pitem != 0) {\n                            HDITEM pitem = new HDITEM();\n                            OS.MoveMemory(pitem, phdn.pitem, HDITEM.sizeof);\n                            if ((pitem.mask & OS.HDI_WIDTH) != 0) {\n                                TableColumn column = columns[phdn.iItem];\n                                if (column != null) {\n                                    column.sendEvent(SWT.Resize);\n                                    \n                                    if (isDisposed())\n                                        return LRESULT.ZERO;\n                                    int count = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n                                    if (count == 1 && columns[0] == null)\n                                        count = 0;\n                                    \n                                    TableColumn[] newColumns = new TableColumn[count];\n                                    System.arraycopy(columns, 0, newColumns, 0, count);\n                                    int[] order = new int[count];\n                                    OS.SendMessage(handle, OS.LVM_GETCOLUMNORDERARRAY, count, order);\n                                    boolean moved = false;\n                                    for (int i = 0; i < count; i++) {\n                                        TableColumn nextColumn = newColumns[order[i]];\n                                        if (moved && !nextColumn.isDisposed()) {\n                                            nextColumn.sendEvent(SWT.Move);\n                                        }\n                                        if (nextColumn == column)\n                                            moved = true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    break;\n                }\n            case OS.HDN_ITEMDBLCLICKW:\n            case OS.HDN_ITEMDBLCLICKA:\n                {\n                    NMHEADER phdn = new NMHEADER();\n                    OS.MoveMemory(phdn, lParam, NMHEADER.sizeof);\n                    TableColumn column = columns[phdn.iItem];\n                    if (column != null) {\n                        column.postEvent(SWT.DefaultSelection);\n                    }\n                    break;\n                }\n        }\n    }\n    LRESULT result = super.WM_NOTIFY(wParam, lParam);\n    if (result != null)\n        return result;\n    switch(hdr.code) {\n        case OS.TTN_GETDISPINFOA:\n        case OS.TTN_GETDISPINFOW:\n            {\n                tipRequested = true;\n                int code = callWindowProc(handle, OS.WM_NOTIFY, wParam, lParam);\n                tipRequested = false;\n                return new LRESULT(code);\n            }\n    }\n    return result;\n}",
			"comments":"/*\n* Feature in Windows.  On NT, the automatically created\n* header control is created as a UNICODE window, not an\n* ANSI window despite the fact that the parent is created\n* as an ANSI window.  This means that it sends UNICODE\n* notification messages to the parent window on NT for\n* no good reason.  The data and size in the NMHEADER and\n* HDITEM structs is identical between the platforms so no\n* different message is actually necessary.  Despite this,\n* Windows sends different messages.  The fix is to look\n* for both messages, despite the platform.  This works\n* because only one will be sent on either platform, never\n* both.\n*/\n/*\n* Bug in Windows.  When a table has the LVS_EX_GRIDLINES extended\n* style and the user drags any column over the first column in the\n* table, making the size become zero, when the user drags a column\n* such that the size of the first column becomes non-zero, the grid\n* lines are not redrawn.  The fix is to detect the case and force\n* a redraw of the first column.\n*/\n/*\n* It is possible (but unlikely), that application\n* code could have disposed the widget in the resize\n* event.  If this happens, end the processing of the\n* Windows message by returning zero as the result of\n* the window proc.\n*/\n/*\n* It is possible (but unlikely), that application\n* code could have disposed the column in the move\n* event.  If this happens, process the move event\n* for those columns that have not been destroyed.\n*/\n",
			"methodName":"LRESULT WM_NOTIFY(int wParam, int lParam)"
		},
		"void fixCheckboxImageList()":{
			"methodBody":"{\n    \n    if ((style & SWT.CHECK) == 0)\n        return;\n    int hImageList = OS.SendMessage(handle, OS.LVM_GETIMAGELIST, OS.LVSIL_SMALL, 0);\n    if (hImageList == 0)\n        return;\n    int[] cx = new int[1], cy = new int[1];\n    OS.ImageList_GetIconSize(hImageList, cx, cy);\n    int hOldStateList = OS.SendMessage(handle, OS.LVM_GETIMAGELIST, OS.LVSIL_STATE, 0);\n    if (hOldStateList == 0)\n        return;\n    int[] stateCx = new int[1], stateCy = new int[1];\n    OS.ImageList_GetIconSize(hOldStateList, stateCx, stateCy);\n    if (cx[0] == stateCx[0] && cy[0] == stateCy[0])\n        return;\n    setCheckboxImageList(cx[0], cy[0]);\n}",
			"comments":"/*\n* Bug in Windows.  When the state image list is larger than the\n* image list, Windows incorrectly positions the state images.  When\n* the table is scrolled, Windows draws garbage.  The fix is to force\n* the state image list to be the same size as the image list.\n*/\n",
			"methodName":"void fixCheckboxImageList()"
		},
		"LRESULT WM_LBUTTONDOWN(int wParam, int lParam)":{
			"methodBody":"{\n    \n    LRESULT result = sendMouseDownEvent(SWT.MouseDown, 1, OS.WM_LBUTTONDOWN, wParam, lParam);\n    \n    if ((style & SWT.CHECK) != 0) {\n        LVHITTESTINFO pinfo = new LVHITTESTINFO();\n        pinfo.x = (short) (lParam & 0xFFFF);\n        pinfo.y = (short) (lParam >> 16);\n        \n        int index = OS.SendMessage(handle, OS.LVM_HITTEST, 0, pinfo);\n        if (index != -1 && pinfo.flags == OS.LVHT_ONITEMSTATEICON) {\n            TableItem item = _getItem(index);\n            item.setChecked(!item.getChecked(), true);\n            if (!OS.IsWinCE) {\n                OS.NotifyWinEvent(OS.EVENT_OBJECT_FOCUS, handle, OS.OBJID_CLIENT, index + 1);\n            }\n        }\n    }\n    return result;\n}",
			"comments":"/*\n* Feature in Windows.  For some reason, capturing\n* the mouse after processing the mouse event for the\n* widget interferes with the normal mouse processing\n* for the widget.  The fix is to avoid the automatic\n* mouse capture.\n*/\n/* Look for check/uncheck */\n/*\n* Note that when the table has LVS_EX_FULLROWSELECT and the\n* user clicks anywhere on a row except on the check box, all\n* of the bits are set.  The hit test flags are LVHT_ONITEM.\n* This means that a bit test for LVHT_ONITEMSTATEICON is not\n* the correct way to determine that the user has selected\n* the check box, equality is needed.\n*/\n",
			"methodName":"LRESULT WM_LBUTTONDOWN(int wParam, int lParam)"
		},
		"public TableItem getItem(int index)":{
			"methodBody":"{\n    checkWidget();\n    int count = OS.SendMessage(handle, OS.LVM_GETITEMCOUNT, 0, 0);\n    if (!(0 <= index && index < count))\n        error(SWT.ERROR_INVALID_RANGE);\n    return _getItem(index);\n}",
			"comments":"/**\n* Returns the item at the given, zero-relative index in the\n* receiver. Throws an exception if the index is out of range.\n*\n* @param index the index of the item to return\n* @return the item at the given index\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_RANGE - if the index is not between 0 and the number of elements in the list minus 1 (inclusive)</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public TableItem getItem(int index)"
		},
		"LRESULT sendMouseDownEvent(int type, int button, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    \n    LVHITTESTINFO pinfo = new LVHITTESTINFO();\n    pinfo.x = (short) (lParam & 0xFFFF);\n    pinfo.y = (short) (lParam >> 16);\n    OS.SendMessage(handle, OS.LVM_HITTEST, 0, pinfo);\n    sendMouseEvent(type, button, handle, msg, wParam, lParam);\n    \n    OS.SetFocus(handle);\n    \n    if (pinfo.iItem == -1) {\n        if (OS.GetCapture() != handle)\n            OS.SetCapture(handle);\n        return LRESULT.ZERO;\n    }\n    \n    boolean forceSelect = false;\n    int count = OS.SendMessage(handle, OS.LVM_GETSELECTEDCOUNT, 0, 0);\n    if (count == 1 && pinfo.iItem != -1) {\n        LVITEM lvItem = new LVITEM();\n        lvItem.mask = OS.LVIF_STATE;\n        lvItem.stateMask = OS.LVIS_SELECTED;\n        lvItem.iItem = pinfo.iItem;\n        OS.SendMessage(handle, OS.LVM_GETITEM, 0, lvItem);\n        if ((lvItem.state & OS.LVIS_SELECTED) != 0) {\n            forceSelect = true;\n        }\n    }\n    dragStarted = false;\n    int code = callWindowProc(handle, msg, wParam, lParam, forceSelect);\n    if (dragStarted) {\n        if (OS.GetCapture() != handle)\n            OS.SetCapture(handle);\n    } else {\n        int flags = OS.LVHT_ONITEMLABEL | OS.LVHT_ONITEMICON;\n        boolean fakeMouseUp = (pinfo.flags & flags) != 0;\n        if (!fakeMouseUp && (style & SWT.MULTI) != 0) {\n            fakeMouseUp = (pinfo.flags & OS.LVHT_ONITEMSTATEICON) == 0;\n        }\n        if (fakeMouseUp) {\n            sendMouseEvent(SWT.MouseUp, button, handle, msg, wParam, lParam);\n        }\n    }\n    dragStarted = false;\n    return new LRESULT(code);\n}",
			"comments":"/*\n* Feature in Windows.  Inside WM_LBUTTONDOWN and WM_RBUTTONDOWN,\n* the widget starts a modal loop to determine if the user wants\n* to begin a drag/drop operation or marque select.  Unfortunately,\n* this modal loop eats the corresponding mouse up.  The fix is to\n* detect the cases when the modal loop has eaten the mouse up and\n* issue a fake mouse up.\n*\n* By observation, when the mouse is clicked anywhere but the check\n* box, the widget eats the mouse up.  When the mouse is dragged,\n* the widget does not eat the mouse up.\n*/\n/*\n* Force the table to have focus so that when the user\n* reselects the focus item, the LVIS_FOCUSED state bits\n* for the item will be set.  If the user did not click on\n* an item, then set focus to the table so that it will\n* come to the front and take focus in the work around\n* below.\n*/\n/*\n* Feature in Windows.  When the user selects outside of\n* a table item, Windows deselects all the items, even\n* when the table is multi-select.  While not strictly\n* wrong, this is unexpected.  The fix is to detect the\n* case and avoid calling the window proc.\n*/\n/*\n* Feature in Windows.  When a table item is reselected\n* in a single-select table, Windows does not issue a\n* WM_NOTIFY because the item state has not changed.\n* This is strictly correct but is inconsistent with the\n* list widget and other widgets in Windows.  The fix is\n* to detect the case when an item is mark it as selected.\n*/\n",
			"methodName":"LRESULT sendMouseDownEvent(int type, int button, int msg, int wParam, int lParam)"
		},
		"void setTableEmpty()":{
			"methodBody":"{\n    if (imageList != null) {\n        int hwndHeader = OS.SendMessage(handle, OS.LVM_GETHEADER, 0, 0);\n        int columnCount = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n        if (columnCount == 1 && columns[0] == null)\n            columnCount = 0;\n        int i = 0;\n        while (i < columnCount) {\n            TableColumn column = columns[i];\n            if (column.getImage() != null)\n                break;\n            i++;\n        }\n        if (i == columnCount) {\n            \n            int hImageList = OS.ImageList_Create(1, 1, 0, 0, 0);\n            OS.SendMessage(handle, OS.LVM_SETIMAGELIST, OS.LVSIL_SMALL, hImageList);\n            OS.SendMessage(handle, OS.LVM_SETIMAGELIST, OS.LVSIL_SMALL, 0);\n            OS.ImageList_Destroy(hImageList);\n            display.releaseImageList(imageList);\n            imageList = null;\n        }\n    }\n    if ((style & SWT.VIRTUAL) != 0)\n        customDraw = false;\n    items = new TableItem[4];\n}",
			"comments":"/*\n* Bug in Windows.  When LVM_SETIMAGELIST is used to remove the\n* image list by setting it to NULL, the item width and height\n* is not changed and space is reserved for icons despite the\n* fact that there are none.  The fix is to set the image list\n* to be very small before setting it to NULL.  This causes\n* Windows to reserve the smallest possible space when an image\n* list is removed.\n*/\n",
			"methodName":"void setTableEmpty()"
		},
		"TableItem _getItem(int index)":{
			"methodBody":"{\n    if (items[index] != null)\n        return items[index];\n    return items[index] = new TableItem(this, SWT.NONE, -1, false);\n}",
			"comments":"",
			"methodName":"TableItem _getItem(int index)"
		},
		"void createItem(TableColumn column, int index)":{
			"methodBody":"{\n    int hwndHeader = OS.SendMessage(handle, OS.LVM_GETHEADER, 0, 0);\n    int count = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n    int columnCount = count + 1;\n    if (count == 1 && columns[0] == null)\n        count = 0;\n    if (!(0 <= index && index <= count))\n        error(SWT.ERROR_INVALID_RANGE);\n    if (count == columns.length) {\n        TableColumn[] newColumns = new TableColumn[columns.length + 4];\n        System.arraycopy(columns, 0, newColumns, 0, columns.length);\n        columns = newColumns;\n    }\n    int itemCount = OS.SendMessage(handle, OS.LVM_GETITEMCOUNT, 0, 0);\n    for (int i = 0; i < itemCount; i++) {\n        TableItem item = items[i];\n        if (item != null) {\n            String[] strings = item.strings;\n            if (strings != null) {\n                String[] temp = new String[columnCount];\n                System.arraycopy(strings, 0, temp, 0, index);\n                System.arraycopy(strings, index, temp, index + 1, columnCount - index - 1);\n                item.strings = temp;\n            }\n            Image[] images = item.images;\n            if (images != null) {\n                Image[] temp = new Image[columnCount];\n                System.arraycopy(images, 0, temp, 0, index);\n                System.arraycopy(images, index, temp, index + 1, columnCount - index - 1);\n                item.images = temp;\n            }\n            if (index == 0) {\n                if (count != 0) {\n                    if (strings == null) {\n                        item.strings = new String[columnCount];\n                        item.strings[1] = item.text;\n                    }\n                    \n                    item.text = \"\";\n                    if (images == null) {\n                        item.images = new Image[columnCount];\n                        item.images[1] = item.image;\n                    }\n                    item.image = null;\n                }\n            }\n            if (item.cellBackground != null) {\n                int[] cellBackground = item.cellBackground;\n                int[] temp = new int[columnCount];\n                System.arraycopy(cellBackground, 0, temp, 0, index);\n                System.arraycopy(cellBackground, index, temp, index + 1, columnCount - index - 1);\n                temp[index] = -1;\n                item.cellBackground = temp;\n            }\n            if (item.cellForeground != null) {\n                int[] cellForeground = item.cellForeground;\n                int[] temp = new int[columnCount];\n                System.arraycopy(cellForeground, 0, temp, 0, index);\n                System.arraycopy(cellForeground, index, temp, index + 1, columnCount - index - 1);\n                temp[index] = -1;\n                item.cellForeground = temp;\n            }\n            if (item.cellFont != null) {\n                int[] cellFont = item.cellFont;\n                int[] temp = new int[columnCount];\n                System.arraycopy(cellFont, 0, temp, 0, index);\n                System.arraycopy(cellFont, index, temp, index + 1, columnCount - index - 1);\n                temp[index] = -1;\n                item.cellFont = temp;\n            }\n        }\n    }\n    \n    System.arraycopy(columns, index, columns, index + 1, count - index);\n    columns[index] = column;\n    \n    ignoreResize = true;\n    if (index == 0) {\n        if (count > 0) {\n            LVCOLUMN lvColumn = new LVCOLUMN();\n            lvColumn.mask = OS.LVCF_WIDTH;\n            OS.SendMessage(handle, OS.LVM_INSERTCOLUMN, 1, lvColumn);\n            OS.SendMessage(handle, OS.LVM_GETCOLUMN, 1, lvColumn);\n            int width = lvColumn.cx;\n            int cchTextMax = 1024;\n            int hHeap = OS.GetProcessHeap();\n            int byteCount = cchTextMax * TCHAR.sizeof;\n            int pszText = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, byteCount);\n            lvColumn.mask = OS.LVCF_TEXT | OS.LVCF_IMAGE | OS.LVCF_WIDTH | OS.LVCF_FMT;\n            lvColumn.pszText = pszText;\n            lvColumn.cchTextMax = cchTextMax;\n            OS.SendMessage(handle, OS.LVM_GETCOLUMN, 0, lvColumn);\n            OS.SendMessage(handle, OS.LVM_SETCOLUMN, 1, lvColumn);\n            lvColumn.fmt = OS.LVCFMT_IMAGE;\n            lvColumn.cx = width;\n            lvColumn.iImage = OS.I_IMAGENONE;\n            lvColumn.pszText = lvColumn.cchTextMax = 0;\n            OS.SendMessage(handle, OS.LVM_SETCOLUMN, 0, lvColumn);\n            lvColumn.mask = OS.LVCF_FMT;\n            lvColumn.fmt = OS.LVCFMT_LEFT;\n            OS.SendMessage(handle, OS.LVM_SETCOLUMN, 0, lvColumn);\n            if (pszText != 0)\n                OS.HeapFree(hHeap, 0, pszText);\n        } else {\n            OS.SendMessage(handle, OS.LVM_SETCOLUMNWIDTH, 0, 0);\n        }\n        if ((parent.style & SWT.VIRTUAL) == 0) {\n            LVITEM lvItem = new LVITEM();\n            lvItem.mask = OS.LVIF_TEXT | OS.LVIF_IMAGE;\n            lvItem.pszText = OS.LPSTR_TEXTCALLBACK;\n            lvItem.iImage = OS.I_IMAGECALLBACK;\n            for (int i = 0; i < itemCount; i++) {\n                lvItem.iItem = i;\n                OS.SendMessage(handle, OS.LVM_SETITEM, 0, lvItem);\n            }\n        }\n    } else {\n        int fmt = OS.LVCFMT_LEFT;\n        if ((column.style & SWT.CENTER) == SWT.CENTER)\n            fmt = OS.LVCFMT_CENTER;\n        if ((column.style & SWT.RIGHT) == SWT.RIGHT)\n            fmt = OS.LVCFMT_RIGHT;\n        LVCOLUMN lvColumn = new LVCOLUMN();\n        lvColumn.mask = OS.LVCF_WIDTH | OS.LVCF_FMT;\n        lvColumn.fmt = fmt;\n        OS.SendMessage(handle, OS.LVM_INSERTCOLUMN, index, lvColumn);\n    }\n    ignoreResize = false;\n}",
			"comments":"//$NON-NLS-1$\n/*\n* Insert the column into the columns array before inserting\n* it into the widget so that the column will be present when\n* any callbacks are issued as a result of LVM_INSERTCOLUMN\n* or LVM_SETCOLUMN.\n*/\n/*\n* Ensure that resize listeners for the table and for columns\n* within the table are not called.  This can happen when the\n* first column is inserted into a table or when a new column\n* is inserted in the first position.\n*/\n",
			"methodName":"void createItem(TableColumn column, int index)"
		},
		"public int[] getColumnOrder()":{
			"methodBody":"{\n    checkWidget();\n    int hwndHeader = OS.SendMessage(handle, OS.LVM_GETHEADER, 0, 0);\n    int count = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n    if (count == 1 && columns[0] == null)\n        return new int[0];\n    int[] order = new int[count];\n    OS.SendMessage(handle, OS.LVM_GETCOLUMNORDERARRAY, count, order);\n    return order;\n}",
			"comments":"/**\n* Returns an array of zero-relative integers that map\n* the creation order of the receiver's items to the\n* order in which they are currently being displayed.\n* <p>\n* Specifically, the indices of the returned array represent\n* the current visual order of the items, and the contents\n* of the array represent the creation order of the items.\n* </p><p>\n* Note: This is not the actual structure used by the receiver\n* to maintain its list of items, so modifying the array will\n* not affect the receiver.\n* </p>\n*\n* @return the current visual order of the receiver's items\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see Table#setColumnOrder(int[])\n* @see TableColumn#getMoveable()\n* @see TableColumn#setMoveable(boolean)\n* @see SWT#Move\n*\n* @since 3.1\n*/\n",
			"methodName":"public int[] getColumnOrder()"
		},
		"public TableColumn[] getColumns()":{
			"methodBody":"{\n    checkWidget();\n    int hwndHeader = OS.SendMessage(handle, OS.LVM_GETHEADER, 0, 0);\n    int count = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n    if (count == 1 && columns[0] == null)\n        count = 0;\n    TableColumn[] result = new TableColumn[count];\n    System.arraycopy(columns, 0, result, 0, count);\n    return result;\n}",
			"comments":"/**\n* Returns an array of <code>TableColumn</code>s which are the\n* columns in the receiver. If no <code>TableColumn</code>s were\n* created by the programmer, the array is empty, despite the fact\n* that visually, one column of items may be visible. This occurs\n* when the programmer uses the table like a list, adding items but\n* never creating a column.\n* <p>\n* Note: This is not the actual structure used by the receiver\n* to maintain its list of items, so modifying the array will\n* not affect the receiver.\n* </p>\n*\n* @return the items in the receiver\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public TableColumn[] getColumns()"
		},
		"public void deselect(int index)":{
			"methodBody":"{\n    checkWidget();\n    \n    if (index < 0)\n        return;\n    LVITEM lvItem = new LVITEM();\n    lvItem.stateMask = OS.LVIS_SELECTED;\n    ignoreSelect = true;\n    OS.SendMessage(handle, OS.LVM_SETITEMSTATE, index, lvItem);\n    ignoreSelect = false;\n}",
			"comments":"/**\n* Deselects the item at the given zero-relative index in the receiver.\n* If the item at the index was already deselected, it remains\n* deselected. Indices that are out of range are ignored.\n*\n* @param index the index of the item to deselect\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* An index of -1 will apply the change to all\n* items.  Ensure that index is greater than -1.\n*/\n",
			"methodName":"public void deselect(int index)"
		},
		"void showItem(int index)":{
			"methodBody":"{\n    \n    if (OS.SendMessage(handle, OS.LVM_GETCOUNTPERPAGE, 0, 0) <= 0) {\n        \n        OS.SendMessage(handle, OS.LVM_ENSUREVISIBLE, index, 1);\n        if (index != OS.SendMessage(handle, OS.LVM_GETTOPINDEX, 0, 0)) {\n            OS.SendMessage(handle, OS.LVM_ENSUREVISIBLE, index, 1);\n        }\n    } else {\n        OS.SendMessage(handle, OS.LVM_ENSUREVISIBLE, index, 0);\n    }\n}",
			"comments":"/*\n* Bug in Windows.  For some reason, when there is insufficient space\n* to show an item, LVM_ENSUREVISIBLE causes blank lines to be\n* inserted at the top of the widget.  A call to LVM_GETTOPINDEX will\n* return a negative number (this is an impossible result).  The fix\n* is to use LVM_GETCOUNTPERPAGE to detect the case when the number\n* of visible items is zero and use LVM_ENSUREVISIBLE with the\n* fPartialOK flag set to true to scroll the table.\n*/\n/*\n* Bug in Windows.  For some reason, LVM_ENSUREVISIBLE can\n* scroll one item more or one item less when there is not\n* enough space to show a single table item.  The fix is\n* to detect the case and call LVM_ENSUREVISIBLE again with\n* the same arguments.  It seems that once LVM_ENSUREVISIBLE\n* has scrolled into the general area, it is able to scroll\n* to the exact item.\n*/\n",
			"methodName":"void showItem(int index)"
		},
		"void setCheckboxImageList(int width, int height)":{
			"methodBody":"{\n    if ((style & SWT.CHECK) == 0)\n        return;\n    int count = 4;\n    int flags = ImageList.COLOR_FLAGS;\n    if ((style & SWT.RIGHT_TO_LEFT) != 0)\n        flags |= OS.ILC_MIRROR;\n    if (OS.COMCTL32_MAJOR < 6 || !OS.IsAppThemed())\n        flags |= OS.ILC_MASK;\n    int hImageList = OS.ImageList_Create(width, height, flags, count, count);\n    int hDC = OS.GetDC(handle);\n    int memDC = OS.CreateCompatibleDC(hDC);\n    int hBitmap = OS.CreateCompatibleBitmap(hDC, width * count, height);\n    int hOldBitmap = OS.SelectObject(memDC, hBitmap);\n    RECT rect = new RECT();\n    OS.SetRect(rect, 0, 0, width * count, height);\n    int clrBackground = getBackgroundPixel();\n    int hBrush = OS.CreateSolidBrush(clrBackground);\n    OS.FillRect(memDC, rect, hBrush);\n    OS.DeleteObject(hBrush);\n    int oldFont = OS.SelectObject(hDC, defaultFont());\n    TEXTMETRIC tm = OS.IsUnicode ? (TEXTMETRIC) new TEXTMETRICW() : new TEXTMETRICA();\n    OS.GetTextMetrics(hDC, tm);\n    OS.SelectObject(hDC, oldFont);\n    int itemWidth = Math.min(tm.tmHeight, width);\n    int itemHeight = Math.min(tm.tmHeight, height);\n    int left = (width - itemWidth) / 2, top = (height - itemHeight) / 2 + 1;\n    OS.SetRect(rect, left, top, left + itemWidth, top + itemHeight);\n    if (OS.COMCTL32_MAJOR >= 6 && OS.IsAppThemed()) {\n        int hTheme = OS.OpenThemeData(handle, BUTTON);\n        OS.DrawThemeBackground(hTheme, memDC, OS.BP_CHECKBOX, OS.CBS_UNCHECKEDNORMAL, rect, null);\n        rect.left += width;\n        rect.right += width;\n        OS.DrawThemeBackground(hTheme, memDC, OS.BP_CHECKBOX, OS.CBS_CHECKEDNORMAL, rect, null);\n        rect.left += width;\n        rect.right += width;\n        OS.DrawThemeBackground(hTheme, memDC, OS.BP_CHECKBOX, OS.CBS_UNCHECKEDNORMAL, rect, null);\n        rect.left += width;\n        rect.right += width;\n        OS.DrawThemeBackground(hTheme, memDC, OS.BP_CHECKBOX, OS.CBS_MIXEDNORMAL, rect, null);\n        OS.CloseThemeData(hTheme);\n    } else {\n        OS.DrawFrameControl(memDC, rect, OS.DFC_BUTTON, OS.DFCS_BUTTONCHECK | OS.DFCS_FLAT);\n        rect.left += width;\n        rect.right += width;\n        OS.DrawFrameControl(memDC, rect, OS.DFC_BUTTON, OS.DFCS_BUTTONCHECK | OS.DFCS_CHECKED | OS.DFCS_FLAT);\n        rect.left += width;\n        rect.right += width;\n        OS.DrawFrameControl(memDC, rect, OS.DFC_BUTTON, OS.DFCS_BUTTONCHECK | OS.DFCS_INACTIVE | OS.DFCS_FLAT);\n        rect.left += width;\n        rect.right += width;\n        OS.DrawFrameControl(memDC, rect, OS.DFC_BUTTON, OS.DFCS_BUTTONCHECK | OS.DFCS_CHECKED | OS.DFCS_INACTIVE | OS.DFCS_FLAT);\n    }\n    OS.SelectObject(memDC, hOldBitmap);\n    OS.DeleteDC(memDC);\n    OS.ReleaseDC(handle, hDC);\n    if (OS.COMCTL32_MAJOR >= 6 && OS.IsAppThemed()) {\n        OS.ImageList_Add(hImageList, hBitmap, 0);\n    } else {\n        OS.ImageList_AddMasked(hImageList, hBitmap, clrBackground);\n    }\n    OS.DeleteObject(hBitmap);\n    int hOldStateList = OS.SendMessage(handle, OS.LVM_GETIMAGELIST, OS.LVSIL_STATE, 0);\n    OS.SendMessage(handle, OS.LVM_SETIMAGELIST, OS.LVSIL_STATE, hImageList);\n    if (hOldStateList != 0)\n        OS.ImageList_Destroy(hOldStateList);\n}",
			"comments":"",
			"methodName":"void setCheckboxImageList(int width, int height)"
		},
		"int imageIndex(Image image)":{
			"methodBody":"{\n    if (image == null)\n        return OS.I_IMAGENONE;\n    if (imageList == null) {\n        Rectangle bounds = image.getBounds();\n        imageList = display.getImageList(style & SWT.RIGHT_TO_LEFT, bounds.width, bounds.height);\n        int index = imageList.indexOf(image);\n        if (index == -1)\n            index = imageList.add(image);\n        int hImageList = imageList.getHandle();\n        \n        int topIndex = getTopIndex();\n        setRedraw(false);\n        setTopIndex(0);\n        OS.SendMessage(handle, OS.LVM_SETIMAGELIST, OS.LVSIL_SMALL, hImageList);\n        setTopIndex(topIndex);\n        fixCheckboxImageList();\n        setRedraw(true);\n        return index;\n    }\n    int index = imageList.indexOf(image);\n    if (index != -1)\n        return index;\n    return imageList.add(image);\n}",
			"comments":"/*\n* Bug in Windows.  Making any change to an item that\n* changes the item height of a table while the table\n* is scrolled can cause the lines to draw incorrectly.\n* This happens even when the lines are not currently\n* visible and are shown afterwards.  The fix is to\n* save the top index, scroll to the top of the table\n* and then restore the original top index.\n*/\n",
			"methodName":"int imageIndex(Image image)"
		},
		"public void setTopIndex(int index)":{
			"methodBody":"{\n    checkWidget();\n    int topIndex = OS.SendMessage(handle, OS.LVM_GETTOPINDEX, 0, 0);\n    if (index == topIndex)\n        return;\n    \n    if (OS.SendMessage(handle, OS.LVM_GETCOUNTPERPAGE, 0, 0) <= 0) {\n        \n        OS.SendMessage(handle, OS.LVM_ENSUREVISIBLE, index, 1);\n        if (index != OS.SendMessage(handle, OS.LVM_GETTOPINDEX, 0, 0)) {\n            OS.SendMessage(handle, OS.LVM_ENSUREVISIBLE, index, 1);\n        }\n        return;\n    }\n    \n    RECT rect = new RECT();\n    rect.left = OS.LVIR_BOUNDS;\n    OS.SendMessage(handle, OS.LVM_GETITEMRECT, 0, rect);\n    int dy = (index - topIndex) * (rect.bottom - rect.top);\n    OS.SendMessage(handle, OS.LVM_SCROLL, 0, dy);\n}",
			"comments":"/**\n* Sets the zero-relative index of the item which is currently\n* at the top of the receiver. This index can change when items\n* are scrolled or new items are added and removed.\n*\n* @param index the index of the top item\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* Bug in Windows.  For some reason, LVM_SCROLL refuses to\n* scroll a table vertically when the width and height of\n* the table is smaller than a certain size.  The values\n* that seem to cause the problem are width=68 and height=6\n* but there is no guarantee that these values cause the\n* failure on different machines or on different versions\n* of Windows.  It may depend on the font and any number\n* of other factors.  For example, setting the font to\n* anything but the default sometimes fixes the problem.\n* The fix is to use LVM_GETCOUNTPERPAGE to detect the\n* case when the number of visible items is zero and\n* use LVM_ENSUREVISIBLE to scroll the table to make the\n* index visible.\n*/\n/*\n* Bug in Windows.  When the table header is visible and\n* there is not enough space to show a single table item,\n* LVM_GETCOUNTPERPAGE can return a negative number instead\n* of zero.  The fix is to test for negative or zero.\n*/\n/*\n* Bug in Windows.  For some reason, LVM_ENSUREVISIBLE can\n* scroll one item more or one item less when there is not\n* enough space to show a single table item.  The fix is\n* to detect the case and call LVM_ENSUREVISIBLE again with\n* the same arguments.  It seems that once LVM_ENSUREVISIBLE\n* has scrolled into the general area, it is able to scroll\n* to the exact item.\n*/\n/* Use LVM_SCROLL to scroll the table */\n",
			"methodName":"public void setTopIndex(int index)"
		},
		"public void deselect(int start, int end)":{
			"methodBody":"{\n    checkWidget();\n    int count = OS.SendMessage(handle, OS.LVM_GETITEMCOUNT, 0, 0);\n    if (start == 0 && end == count - 1) {\n        deselectAll();\n    } else {\n        LVITEM lvItem = new LVITEM();\n        lvItem.stateMask = OS.LVIS_SELECTED;\n        \n        start = Math.max(0, start);\n        for (int i = start; i <= end; i++) {\n            ignoreSelect = true;\n            OS.SendMessage(handle, OS.LVM_SETITEMSTATE, i, lvItem);\n            ignoreSelect = false;\n        }\n    }\n}",
			"comments":"/**\n* Deselects the items at the given zero-relative indices in the receiver.\n* If the item at the given zero-relative index in the receiver\n* is selected, it is deselected.  If the item at the index\n* was not selected, it remains deselected.  The range of the\n* indices is inclusive. Indices that are out of range are ignored.\n*\n* @param start the start index of the items to deselect\n* @param end the end index of the items to deselect\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* An index of -1 will apply the change to all\n* items.  Ensure that indices are greater than -1.\n*/\n",
			"methodName":"public void deselect(int start, int end)"
		},
		"public void select(int start, int end)":{
			"methodBody":"{\n    checkWidget();\n    if (end < 0 || start > end || ((style & SWT.SINGLE) != 0 && start != end))\n        return;\n    int count = OS.SendMessage(handle, OS.LVM_GETITEMCOUNT, 0, 0);\n    if (count == 0 || start >= count)\n        return;\n    start = Math.max(0, start);\n    end = Math.min(end, count - 1);\n    if (start == 0 && end == count - 1) {\n        selectAll();\n    } else {\n        \n        LVITEM lvItem = new LVITEM();\n        lvItem.state = OS.LVIS_SELECTED;\n        lvItem.stateMask = OS.LVIS_SELECTED;\n        for (int i = start; i <= end; i++) {\n            ignoreSelect = true;\n            OS.SendMessage(handle, OS.LVM_SETITEMSTATE, i, lvItem);\n            ignoreSelect = false;\n        }\n    }\n}",
			"comments":"/**\n* Selects the items in the range specified by the given zero-relative\n* indices in the receiver. The range of indices is inclusive.\n* The current selection is not cleared before the new items are selected.\n* <p>\n* If an item in the given range is not selected, it is selected.\n* If an item in the given range was already selected, it remains selected.\n* Indices that are out of range are ignored and no items will be selected\n* if start is greater than end.\n* If the receiver is single-select and there is more than one item in the\n* given range, then all indices are ignored.\n*\n* @param start the start of the range\n* @param end the end of the range\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see Table#setSelection(int,int)\n*/\n/*\n* An index of -1 will apply the change to all\n* items.  Indices must be greater than -1.\n*/\n",
			"methodName":"public void select(int start, int end)"
		},
		"LRESULT WM_KILLFOCUS(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_KILLFOCUS(wParam, lParam);\n    \n    if ((style & SWT.HIDE_SELECTION) != 0) {\n        if (imageList != null || (style & SWT.CHECK) != 0) {\n            OS.InvalidateRect(handle, null, false);\n        }\n    }\n    return result;\n}",
			"comments":"/*\n* Bug in Windows.  When LVS_SHOWSELALWAYS is not specified,\n* Windows hides the selection when focus is lost but does\n* not redraw anything other than the text, leaving the image\n* and check box appearing selected.  The fix is to redraw\n* the table.\n*/\n",
			"methodName":"LRESULT WM_KILLFOCUS(int wParam, int lParam)"
		},
		"public int getSelectionIndex()":{
			"methodBody":"{\n    checkWidget();\n    int focusIndex = OS.SendMessage(handle, OS.LVM_GETNEXTITEM, -1, OS.LVNI_FOCUSED);\n    int selectedIndex = OS.SendMessage(handle, OS.LVM_GETNEXTITEM, -1, OS.LVNI_SELECTED);\n    if (focusIndex == selectedIndex)\n        return selectedIndex;\n    int i = -1;\n    while ((i = OS.SendMessage(handle, OS.LVM_GETNEXTITEM, i, OS.LVNI_SELECTED)) != -1) {\n        if (i == focusIndex)\n            return i;\n    }\n    return selectedIndex;\n}",
			"comments":"/**\n* Returns the zero-relative index of the item which is currently\n* selected in the receiver, or -1 if no item is selected.\n*\n* @return the index of the selected item\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getSelectionIndex()"
		},
		"public void setColumnOrder(int[] order)":{
			"methodBody":"{\n    checkWidget();\n    if (order == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    int hwndHeader = OS.SendMessage(handle, OS.LVM_GETHEADER, 0, 0);\n    int count = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n    if (count == 1 && columns[0] == null) {\n        if (order.length != 0)\n            error(SWT.ERROR_INVALID_ARGUMENT);\n        return;\n    }\n    if (order.length != count)\n        error(SWT.ERROR_INVALID_ARGUMENT);\n    int[] oldOrder = new int[count];\n    OS.SendMessage(handle, OS.LVM_GETCOLUMNORDERARRAY, count, oldOrder);\n    boolean reorder = false;\n    boolean[] seen = new boolean[count];\n    for (int i = 0; i < order.length; i++) {\n        int index = order[i];\n        if (index < 0 || index >= count)\n            error(SWT.ERROR_INVALID_RANGE);\n        if (seen[index])\n            error(SWT.ERROR_INVALID_ARGUMENT);\n        seen[index] = true;\n        if (index != oldOrder[i])\n            reorder = true;\n    }\n    if (reorder) {\n        RECT[] oldRects = new RECT[count];\n        for (int i = 0; i < count; i++) {\n            oldRects[i] = new RECT();\n            OS.SendMessage(hwndHeader, OS.HDM_GETITEMRECT, i, oldRects[i]);\n        }\n        OS.SendMessage(handle, OS.LVM_SETCOLUMNORDERARRAY, order.length, order);\n        \n        OS.InvalidateRect(handle, null, true);\n        TableColumn[] newColumns = new TableColumn[count];\n        System.arraycopy(columns, 0, newColumns, 0, count);\n        RECT newRect = new RECT();\n        for (int i = 0; i < count; i++) {\n            TableColumn column = newColumns[i];\n            if (!column.isDisposed()) {\n                OS.SendMessage(hwndHeader, OS.HDM_GETITEMRECT, i, newRect);\n                if (newRect.left != oldRects[i].left) {\n                    column.sendEvent(SWT.Move);\n                }\n            }\n        }\n    }\n}",
			"comments":"/**\n* Sets the order that the items in the receiver should\n* be displayed in to the given argument which is described\n* in terms of the zero-relative ordering of when the items\n* were added.\n*\n* @param order the new order to display the items\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the item order is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the item order is not the same length as the number of items</li>\n* </ul>\n*\n* @see Table#getColumnOrder()\n* @see TableColumn#getMoveable()\n* @see TableColumn#setMoveable(boolean)\n* @see SWT#Move\n*\n* @since 3.1\n*/\n/*\n* Bug in Windows.  When LVM_SETCOLUMNORDERARRAY is used to change\n* the column order, the header redraws correctly but the table does\n* not.  The fix is to force a redraw.\n*/\n",
			"methodName":"public void setColumnOrder(int[] order)"
		},
		"void setForegroundPixel(int pixel)":{
			"methodBody":"{\n    if (foreground == pixel)\n        return;\n    foreground = pixel;\n    \n    if (pixel == -1)\n        pixel = OS.CLR_DEFAULT;\n    OS.SendMessage(handle, OS.LVM_SETTEXTCOLOR, 0, pixel);\n    \n    OS.InvalidateRect(handle, null, true);\n}",
			"comments":"/*\n* The Windows table control uses CLR_DEFAULT to indicate\n* that it is using the default foreground color.  This\n* is undocumented.\n*/\n/*\n* Feature in Windows.  When the foreground color is\n* changed, the table does not redraw until the next\n* WM_PAINT.  The fix is to force a redraw.\n*/\n",
			"methodName":"void setForegroundPixel(int pixel)"
		},
		"public boolean isSelected(int index)":{
			"methodBody":"{\n    checkWidget();\n    LVITEM lvItem = new LVITEM();\n    lvItem.mask = OS.LVIF_STATE;\n    lvItem.stateMask = OS.LVIS_SELECTED;\n    lvItem.iItem = index;\n    int result = OS.SendMessage(handle, OS.LVM_GETITEM, 0, lvItem);\n    return (result != 0) && ((lvItem.state & OS.LVIS_SELECTED) != 0);\n}",
			"comments":"/**\n* Returns <code>true</code> if the item is selected,\n* and <code>false</code> otherwise.  Indices out of\n* range are ignored.\n*\n* @param index the index of the item\n* @return the visibility state of the item at the index\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public boolean isSelected(int index)"
		},
		"LRESULT WM_KEYDOWN(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_KEYDOWN(wParam, lParam);\n    if (result != null)\n        return result;\n    switch(wParam) {\n        case OS.VK_SPACE:\n            \n            return LRESULT.ZERO;\n        case OS.VK_UP:\n        case OS.VK_DOWN:\n        case OS.VK_PRIOR:\n        case OS.VK_NEXT:\n        case OS.VK_HOME:\n        case OS.VK_END:\n            OS.SendMessage(handle, OS.WM_CHANGEUISTATE, OS.UIS_INITIALIZE, 0);\n            break;\n    }\n    return result;\n}",
			"comments":"/*\n* Ensure that the window proc does not process VK_SPACE\n* so that it can be handled in WM_CHAR.  This allows the\n* application to cancel an operation that is normally\n* performed in WM_KEYDOWN from WM_CHAR.\n*/\n",
			"methodName":"LRESULT WM_KEYDOWN(int wParam, int lParam)"
		}
	},
	"ClassORInterfaceName":[
		"Table"
	]
}
