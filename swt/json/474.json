{
	"variables":[
		"lastFocusId",
		"items",
		"ignoreResize",
		"ignoreMouse",
		"imageList",
		"disabledImageList",
		"hotImageList",
		"ToolBarProc",
		"ToolBarClass",
		"lpWndClass",
		"DEFAULT_WIDTH",
		"DEFAULT_HEIGHT",
		"bits",
		"width",
		"height",
		"rect",
		"lpButton",
		"count",
		"i",
		"info",
		"oldRect",
		"oldWidth",
		"oldHeight",
		"border",
		"newWidth",
		"newHeight",
		"redraw",
		"flags",
		"count",
		"rect",
		"trim",
		"trim",
		"bits",
		"bits",
		"hFont",
		"bits",
		"count",
		"id",
		"newItems",
		"bits",
		"lpButton",
		"info",
		"index",
		"count",
		"i",
		"item",
		"count",
		"lpButton",
		"result",
		"items",
		"i",
		"rect",
		"count",
		"lpButton",
		"result",
		"i",
		"info",
		"size",
		"index",
		"item",
		"padding",
		"i",
		"item",
		"i",
		"item",
		"key",
		"id",
		"index",
		"key",
		"id",
		"index",
		"i",
		"item",
		"i",
		"item",
		"bits",
		"hImageList",
		"index",
		"mask",
		"item",
		"hImageList",
		"hImageList",
		"rect",
		"flags",
		"index",
		"item",
		"index",
		"hwndToolTip",
		"item",
		"bits",
		"result",
		"i",
		"item",
		"fsState",
		"result",
		"index",
		"lpButton",
		"code",
		"result",
		"result",
		"result",
		"index",
		"lpButton",
		"code",
		"result",
		"result",
		"index",
		"code",
		"result",
		"windowRect",
		"index",
		"border",
		"rect",
		"count",
		"bits",
		"result",
		"lpwp",
		"oldRect",
		"newRect",
		"oldWidth",
		"newWidth",
		"rect",
		"newHeight",
		"child",
		"hdr",
		"lpnmtb",
		"child",
		"event",
		"index",
		"rect",
		"nmcd",
		"lpnmhi",
		"client",
		"index",
		"rect",
		"OS",
		"OS",
		"ToolBarClass",
		"lpWndClass",
		"ToolBarProc",
		"lpWndClass",
		"parent",
		"style",
		"style",
		"SWT",
		"SWT",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"SWT",
		"handle",
		"msg",
		"OS",
		"OS",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"OS",
		"ToolBarProc",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"style",
		"SWT",
		"style",
		"SWT",
		"style",
		"SWT",
		"style",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"i",
		"count",
		"i",
		"OS",
		"handle",
		"OS",
		"i",
		"rect",
		"height",
		"Math",
		"height",
		"rect",
		"OS",
		"handle",
		"OS",
		"i",
		"lpButton",
		"lpButton",
		"OS",
		"info",
		"TBBUTTONINFO",
		"info",
		"OS",
		"OS",
		"handle",
		"OS",
		"lpButton",
		"info",
		"width",
		"Math",
		"width",
		"info",
		"width",
		"Math",
		"width",
		"rect",
		"OS",
		"handle",
		"oldRect",
		"oldRect",
		"oldRect",
		"oldRect",
		"oldRect",
		"wHint",
		"SWT",
		"wHint",
		"border",
		"hHint",
		"SWT",
		"hHint",
		"border",
		"drawCount",
		"OS",
		"handle",
		"ignoreResize",
		"redraw",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"OS",
		"handle",
		"newWidth",
		"newHeight",
		"flags",
		"OS",
		"handle",
		"OS",
		"count",
		"OS",
		"handle",
		"OS",
		"count",
		"rect",
		"width",
		"Math",
		"width",
		"rect",
		"height",
		"Math",
		"height",
		"rect",
		"handle",
		"oldWidth",
		"oldHeight",
		"flags",
		"redraw",
		"OS",
		"handle",
		"ignoreResize",
		"width",
		"width",
		"DEFAULT_WIDTH",
		"height",
		"height",
		"DEFAULT_HEIGHT",
		"wHint",
		"SWT",
		"width",
		"wHint",
		"hHint",
		"SWT",
		"height",
		"hHint",
		"width",
		"height",
		"width",
		"trim",
		"height",
		"trim",
		"width",
		"height",
		"x",
		"y",
		"width",
		"height",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"trim",
		"trim",
		"state",
		"CANVAS",
		"style",
		"SWT",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"hFont",
		"OS",
		"handle",
		"OS",
		"TBBUTTON",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"bits",
		"OS",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"handle",
		"OS",
		"index",
		"index",
		"count",
		"SWT",
		"id",
		"items",
		"items",
		"id",
		"id",
		"id",
		"items",
		"items",
		"System",
		"items",
		"newItems",
		"items",
		"items",
		"newItems",
		"item",
		"lpButton",
		"id",
		"lpButton",
		"bits",
		"lpButton",
		"OS",
		"bits",
		"OS",
		"lpButton",
		"OS",
		"OS",
		"handle",
		"OS",
		"index",
		"lpButton",
		"SWT",
		"items",
		"item",
		"id",
		"item",
		"style",
		"SWT",
		"count",
		"items",
		"lastFocusId",
		"OS",
		"OS",
		"OS",
		"info",
		"TBBUTTONINFO",
		"info",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"item",
		"info",
		"info",
		"OS",
		"info",
		"OS",
		"imageList",
		"imageList",
		"info",
		"hotImageList",
		"hotImageList",
		"info",
		"disabledImageList",
		"disabledImageList",
		"info",
		"OS",
		"handle",
		"OS",
		"index",
		"item",
		"lastFocusId",
		"lastFocusId",
		"items",
		"item",
		"item",
		"OS",
		"handle",
		"OS",
		"count",
		"imageList",
		"OS",
		"handle",
		"OS",
		"display",
		"imageList",
		"hotImageList",
		"OS",
		"handle",
		"OS",
		"display",
		"hotImageList",
		"disabledImageList",
		"OS",
		"handle",
		"OS",
		"display",
		"disabledImageList",
		"imageList",
		"hotImageList",
		"disabledImageList",
		"items",
		"style",
		"SWT",
		"count",
		"enabled",
		"i",
		"items",
		"i",
		"items",
		"i",
		"item",
		"item",
		"SWT",
		"SWT",
		"item",
		"enabled",
		"item",
		"disabledImageList",
		"hotImageList",
		"imageList",
		"OS",
		"handle",
		"OS",
		"index",
		"index",
		"count",
		"SWT",
		"OS",
		"handle",
		"OS",
		"index",
		"lpButton",
		"result",
		"SWT",
		"items",
		"lpButton",
		"point",
		"SWT",
		"i",
		"items",
		"i",
		"items",
		"i",
		"rect",
		"point",
		"items",
		"i",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"count",
		"i",
		"count",
		"i",
		"OS",
		"handle",
		"OS",
		"i",
		"lpButton",
		"result",
		"i",
		"items",
		"lpButton",
		"result",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"item",
		"SWT",
		"item",
		"SWT",
		"OS",
		"handle",
		"OS",
		"item",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"style",
		"SWT",
		"info",
		"TBBUTTONINFO",
		"info",
		"OS",
		"OS",
		"handle",
		"OS",
		"info",
		"size",
		"index",
		"items",
		"items",
		"index",
		"item",
		"item",
		"SWT",
		"index",
		"index",
		"items",
		"OS",
		"handle",
		"OS",
		"info",
		"padding",
		"i",
		"items",
		"i",
		"items",
		"i",
		"item",
		"item",
		"SWT",
		"OS",
		"handle",
		"OS",
		"item",
		"info",
		"i",
		"items",
		"i",
		"items",
		"i",
		"item",
		"item",
		"Display",
		"ch",
		"OS",
		"handle",
		"OS",
		"key",
		"id",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"id",
		"index",
		"OS",
		"handle",
		"OS",
		"index",
		"items",
		"id",
		"Display",
		"ch",
		"OS",
		"handle",
		"OS",
		"key",
		"id",
		"OS",
		"handle",
		"OS",
		"id",
		"index",
		"items",
		"id",
		"i",
		"items",
		"i",
		"items",
		"i",
		"item",
		"item",
		"item",
		"item",
		"items",
		"imageList",
		"OS",
		"handle",
		"OS",
		"display",
		"imageList",
		"hotImageList",
		"OS",
		"handle",
		"OS",
		"display",
		"hotImageList",
		"disabledImageList",
		"OS",
		"handle",
		"OS",
		"display",
		"disabledImageList",
		"imageList",
		"hotImageList",
		"disabledImageList",
		"control",
		"i",
		"items",
		"i",
		"items",
		"i",
		"item",
		"item",
		"control",
		"item",
		"pixel",
		"style",
		"SWT",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"pixel",
		"bits",
		"OS",
		"bits",
		"OS",
		"OS",
		"handle",
		"OS",
		"bits",
		"parent",
		"drawCount",
		"OS",
		"handle",
		"parent",
		"parent",
		"x",
		"y",
		"width",
		"height",
		"flags",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"disabledImageList",
		"imageList",
		"disabledImageList",
		"imageList",
		"hImageList",
		"disabledImageList",
		"OS",
		"handle",
		"OS",
		"hImageList",
		"font",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"index",
		"items",
		"items",
		"index",
		"item",
		"item",
		"mask",
		"index",
		"index",
		"items",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"hotImageList",
		"imageList",
		"hotImageList",
		"imageList",
		"hImageList",
		"hotImageList",
		"OS",
		"handle",
		"OS",
		"hImageList",
		"imageList",
		"imageList",
		"hImageList",
		"imageList",
		"OS",
		"handle",
		"OS",
		"hImageList",
		"parent",
		"OS",
		"handle",
		"OS",
		"parent",
		"style",
		"SWT",
		"OS",
		"handle",
		"rect",
		"OS",
		"parent",
		"rect",
		"ignoreResize",
		"count",
		"OS",
		"handle",
		"OS",
		"count",
		"OS",
		"OS",
		"OS",
		"handle",
		"rect",
		"rect",
		"rect",
		"rect",
		"flags",
		"ignoreResize",
		"index",
		"items",
		"items",
		"index",
		"item",
		"item",
		"SWT",
		"item",
		"index",
		"index",
		"items",
		"hdr",
		"OS",
		"hdr",
		"OS",
		"handle",
		"OS",
		"hwndToolTip",
		"hdr",
		"toolTipText",
		"index",
		"index",
		"items",
		"items",
		"index",
		"item",
		"item",
		"hdr",
		"OS",
		"OS",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"bits",
		"ToolBarClass",
		"ToolBarProc",
		"wParam",
		"lParam",
		"result",
		"result",
		"OS",
		"OS",
		"i",
		"items",
		"i",
		"items",
		"i",
		"item",
		"OS",
		"handle",
		"OS",
		"item",
		"fsState",
		"OS",
		"fsState",
		"OS",
		"OS",
		"handle",
		"OS",
		"item",
		"fsState",
		"wParam",
		"lParam",
		"result",
		"result",
		"wParam",
		"OS",
		"handle",
		"OS",
		"index",
		"OS",
		"handle",
		"OS",
		"index",
		"lpButton",
		"code",
		"items",
		"lpButton",
		"LRESULT",
		"result",
		"wParam",
		"lParam",
		"result",
		"result",
		"LRESULT",
		"wParam",
		"lParam",
		"result",
		"result",
		"OS",
		"wParam",
		"lParam",
		"result",
		"result",
		"wParam",
		"OS",
		"LRESULT",
		"result",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"index",
		"lpButton",
		"code",
		"lastFocusId",
		"lpButton",
		"wParam",
		"lParam",
		"ignoreMouse",
		"wParam",
		"lParam",
		"ignoreMouse",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"result",
		"result",
		"LRESULT",
		"wParam",
		"lParam",
		"lastFocusId",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"lastFocusId",
		"OS",
		"handle",
		"OS",
		"index",
		"result",
		"ignoreResize",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"code",
		"LRESULT",
		"code",
		"wParam",
		"lParam",
		"result",
		"style",
		"SWT",
		"style",
		"SWT",
		"OS",
		"handle",
		"windowRect",
		"OS",
		"handle",
		"OS",
		"index",
		"count",
		"OS",
		"handle",
		"OS",
		"index",
		"rect",
		"OS",
		"handle",
		"rect",
		"rect",
		"windowRect",
		"border",
		"index",
		"OS",
		"handle",
		"OS",
		"index",
		"count",
		"bits",
		"OS",
		"bits",
		"OS",
		"OS",
		"handle",
		"OS",
		"bits",
		"result",
		"wParam",
		"lParam",
		"result",
		"result",
		"ignoreResize",
		"result",
		"drawCount",
		"result",
		"style",
		"SWT",
		"result",
		"OS",
		"handle",
		"result",
		"OS",
		"handle",
		"OS",
		"result",
		"OS",
		"lpwp",
		"lParam",
		"WINDOWPOS",
		"lpwp",
		"OS",
		"OS",
		"result",
		"OS",
		"handle",
		"oldRect",
		"OS",
		"newRect",
		"lpwp",
		"lpwp",
		"OS",
		"handle",
		"OS",
		"newRect",
		"oldRect",
		"oldRect",
		"newRect",
		"newRect",
		"newWidth",
		"oldWidth",
		"newRect",
		"newRect",
		"OS",
		"rect",
		"oldWidth",
		"oldWidth",
		"newHeight",
		"OS",
		"handle",
		"rect",
		"result",
		"items",
		"wParam",
		"child",
		"child",
		"wParam",
		"lParam",
		"OS",
		"hdr",
		"lParam",
		"NMHDR",
		"hdr",
		"OS",
		"OS",
		"lpnmtb",
		"lParam",
		"NMTOOLBAR",
		"items",
		"lpnmtb",
		"child",
		"event",
		"SWT",
		"OS",
		"handle",
		"OS",
		"lpnmtb",
		"OS",
		"handle",
		"OS",
		"index",
		"rect",
		"event",
		"rect",
		"event",
		"rect",
		"child",
		"SWT",
		"event",
		"OS",
		"background",
		"OS",
		"nmcd",
		"lParam",
		"NMCUSTOMDRAW",
		"nmcd",
		"OS",
		"OS",
		"OS",
		"nmcd",
		"OS",
		"OS",
		"OS",
		"lpnmhi",
		"lParam",
		"NMTBHOTITEM",
		"lpnmhi",
		"OS",
		"OS",
		"handle",
		"client",
		"OS",
		"handle",
		"OS",
		"lpnmhi",
		"OS",
		"handle",
		"OS",
		"index",
		"rect",
		"rect",
		"client",
		"rect",
		"client",
		"LRESULT",
		"wParam",
		"lParam",
		"TOOLBARCLASSNAME",
		"lpfnWndProc",
		"VERTICAL",
		"style",
		"VERTICAL",
		"GWL_STYLE",
		"GWL_STYLE",
		"CCS_VERT",
		"style",
		"HORIZONTAL",
		"WM_SYSCHAR",
		"FLAT",
		"NO_FOCUS",
		"VERTICAL",
		"WRAP",
		"H_SCROLL",
		"V_SCROLL",
		"ERROR_INVALID_SUBCLASS",
		"VERTICAL",
		"TB_BUTTONCOUNT",
		"TB_GETITEMRECT",
		"bottom",
		"TB_GETBUTTON",
		"fsStyle",
		"BTNS_SEP",
		"cbSize",
		"sizeof",
		"dwMask",
		"TBIF_SIZE",
		"TB_GETBUTTONINFO",
		"idCommand",
		"cx",
		"right",
		"right",
		"left",
		"bottom",
		"top",
		"DEFAULT",
		"DEFAULT",
		"SWP_NOACTIVATE",
		"SWP_NOMOVE",
		"SWP_NOREDRAW",
		"SWP_NOZORDER",
		"TB_BUTTONCOUNT",
		"TB_GETITEMRECT",
		"right",
		"bottom",
		"DEFAULT",
		"DEFAULT",
		"width",
		"height",
		"GWL_STYLE",
		"CCS_NODIVIDER",
		"height",
		"FLAT",
		"COMCTL32_MAJOR",
		"GWL_STYLE",
		"TBSTYLE_TRANSPARENT",
		"GWL_STYLE",
		"SYSTEM_FONT",
		"WM_SETFONT",
		"TB_BUTTONSTRUCTSIZE",
		"sizeof",
		"TB_SETBITMAPSIZE",
		"TB_SETBUTTONSIZE",
		"TBSTYLE_EX_DRAWDDARROWS",
		"TBSTYLE_EX_MIXEDBUTTONS",
		"TBSTYLE_EX_HIDECLIPPEDBUTTONS",
		"COMCTL32_MAJOR",
		"TBSTYLE_EX_DOUBLEBUFFER",
		"TB_SETEXTENDEDSTYLE",
		"TB_BUTTONCOUNT",
		"ERROR_INVALID_RANGE",
		"length",
		"length",
		"length",
		"length",
		"idCommand",
		"fsStyle",
		"fsState",
		"TBSTATE_ENABLED",
		"BTNS_SEP",
		"iBitmap",
		"I_IMAGENONE",
		"TB_INSERTBUTTON",
		"ERROR_ITEM_NOT_ADDED",
		"id",
		"VERTICAL",
		"IsWinCE",
		"COLOR_BTNFACE",
		"cbSize",
		"sizeof",
		"dwMask",
		"TBIF_IMAGE",
		"TBIF_STYLE",
		"TB_GETBUTTONINFO",
		"id",
		"fsStyle",
		"BTNS_SEP",
		"iImage",
		"I_IMAGENONE",
		"iImage",
		"iImage",
		"iImage",
		"TB_DELETEBUTTON",
		"id",
		"id",
		"id",
		"TB_BUTTONCOUNT",
		"TB_SETIMAGELIST",
		"TB_SETHOTIMAGELIST",
		"TB_SETDISABLEDIMAGELIST",
		"VERTICAL",
		"length",
		"style",
		"CHECK",
		"RADIO",
		"TB_BUTTONCOUNT",
		"ERROR_INVALID_RANGE",
		"TB_GETBUTTON",
		"ERROR_CANNOT_GET_ITEM",
		"idCommand",
		"ERROR_NULL_ARGUMENT",
		"length",
		"TB_BUTTONCOUNT",
		"TB_BUTTONCOUNT",
		"TB_GETBUTTON",
		"idCommand",
		"VERTICAL",
		"TB_BUTTONCOUNT",
		"TB_GETROWS",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"TB_COMMANDTOINDEX",
		"id",
		"WRAP",
		"TB_AUTOSIZE",
		"VERTICAL",
		"cbSize",
		"sizeof",
		"dwMask",
		"TBIF_SIZE",
		"TB_GETBUTTONSIZE",
		"cx",
		"length",
		"style",
		"DROP_DOWN",
		"length",
		"TB_GETPADDING",
		"cx",
		"length",
		"style",
		"SEPARATOR",
		"TB_SETBUTTONINFO",
		"id",
		"length",
		"TB_MAPACCELERATOR",
		"FLAT",
		"TB_COMMANDTOINDEX",
		"TB_SETHOTITEM",
		"TB_MAPACCELERATOR",
		"TB_COMMANDTOINDEX",
		"text",
		"length",
		"TB_SETIMAGELIST",
		"TB_SETHOTIMAGELIST",
		"TB_SETDISABLEDIMAGELIST",
		"length",
		"control",
		"FLAT",
		"COMCTL32_MAJOR",
		"GWL_STYLE",
		"TBSTYLE_TRANSPARENT",
		"TBSTYLE_TRANSPARENT",
		"GWL_STYLE",
		"lpwp",
		"TB_SETBITMAPSIZE",
		"TB_SETBUTTONSIZE",
		"TB_SETDISABLEDIMAGELIST",
		"PUSH",
		"CHECK",
		"RADIO",
		"DROP_DOWN",
		"length",
		"style",
		"length",
		"TB_SETBITMAPSIZE",
		"TB_SETBUTTONSIZE",
		"TB_SETHOTIMAGELIST",
		"imageList",
		"imageList",
		"TB_SETIMAGELIST",
		"TB_SETPARENT",
		"handle",
		"VERTICAL",
		"handle",
		"TB_SETROWS",
		"SWP_NOACTIVATE",
		"SWP_NOMOVE",
		"SWP_NOZORDER",
		"right",
		"left",
		"bottom",
		"top",
		"length",
		"style",
		"SEPARATOR",
		"length",
		"uFlags",
		"TTF_IDISHWND",
		"idFrom",
		"TB_GETTOOLTIPS",
		"hwndFrom",
		"length",
		"toolTipText",
		"CCS_NORESIZE",
		"TBSTYLE_TOOLTIPS",
		"TBSTYLE_CUSTOMERASE",
		"SHADOW_OUT",
		"CCS_NODIVIDER",
		"WRAP",
		"TBSTYLE_WRAPABLE",
		"FLAT",
		"TBSTYLE_FLAT",
		"RIGHT",
		"TBSTYLE_LIST",
		"VK_LBUTTON",
		"length",
		"TB_GETSTATE",
		"id",
		"TBSTATE_PRESSED",
		"TBSTATE_PRESSED",
		"TB_SETSTATE",
		"id",
		"TB_GETHOTITEM",
		"TB_GETBUTTON",
		"idCommand",
		"ZERO",
		"ZERO",
		"DLGC_BUTTON",
		"VK_SPACE",
		"ZERO",
		"TB_GETHOTITEM",
		"TB_GETBUTTON",
		"idCommand",
		"ZERO",
		"TB_COMMANDTOINDEX",
		"TB_SETHOTITEM",
		"WM_SIZE",
		"ZERO",
		"BORDER",
		"WRAP",
		"TB_BUTTONCOUNT",
		"TB_GETITEMRECT",
		"right",
		"right",
		"TB_GETEXTENDEDSTYLE",
		"TBSTYLE_EX_HIDECLIPPEDBUTTONS",
		"TBSTYLE_EX_HIDECLIPPEDBUTTONS",
		"TB_SETEXTENDEDSTYLE",
		"WRAP",
		"TB_GETROWS",
		"sizeof",
		"flags",
		"SWP_NOSIZE",
		"SWP_NOREDRAW",
		"cx",
		"cy",
		"WM_NCCALCSIZE",
		"right",
		"left",
		"right",
		"left",
		"bottom",
		"top",
		"sizeof",
		"code",
		"TBN_DROPDOWN",
		"sizeof",
		"iItem",
		"detail",
		"ARROW",
		"TB_COMMANDTOINDEX",
		"iItem",
		"TB_GETITEMRECT",
		"x",
		"left",
		"y",
		"bottom",
		"Selection",
		"NM_CUSTOMDRAW",
		"sizeof",
		"dwDrawStage",
		"CDDS_PREERASE",
		"CDRF_NOTIFYPOSTERASE",
		"CDDS_POSTERASE",
		"hdc",
		"TBN_HOTITEMCHANGE",
		"IsWinCE",
		"sizeof",
		"dwFlags",
		"HICF_ARROWKEYS",
		"TB_COMMANDTOINDEX",
		"idNew",
		"TB_GETITEMRECT",
		"right",
		"right",
		"bottom",
		"bottom",
		"ONE",
		"parent",
		"style",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"style",
		"wHint",
		"hHint",
		"changed",
		"x",
		"y",
		"width",
		"height",
		"item",
		"index",
		"item",
		"enabled",
		"index",
		"point",
		"item",
		"ch",
		"ch",
		"control",
		"pixel",
		"x",
		"y",
		"width",
		"height",
		"flags",
		"imageList",
		"font",
		"imageList",
		"imageList",
		"parent",
		"count",
		"hdr",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam"
	],
	"extendORImplementFiles":[
		"Composite"
	],
	"package":[
		"org.eclipse.swt.widgets"
	],
	"import":[
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt",
		"org.eclipse.swt.graphics"
	],
	"methods":[
		"callWindowProc",
		"checkStyle",
		"checkSubclass",
		"computeSize",
		"computeTrim",
		"createHandle",
		"createItem",
		"createWidget",
		"defaultBackground",
		"destroyItem",
		"enableWidget",
		"getDisabledImageList",
		"getHotImageList",
		"getImageList",
		"getItem",
		"getItem",
		"getItemCount",
		"getItems",
		"getRowCount",
		"indexOf",
		"layoutItems",
		"mnemonicHit",
		"mnemonicMatch",
		"releaseWidget",
		"removeControl",
		"setBackgroundPixel",
		"setBounds",
		"setDefaultFont",
		"setDisabledImageList",
		"setFont",
		"setHotImageList",
		"setImageList",
		"setParent",
		"setRowCount",
		"setTabItemFocus",
		"toolTipText",
		"widgetStyle",
		"windowClass",
		"windowProc",
		"WM_CAPTURECHANGED",
		"WM_CHAR",
		"WM_COMMAND",
		"WM_GETDLGCODE",
		"WM_KEYDOWN",
		"WM_KILLFOCUS",
		"WM_LBUTTONDOWN",
		"WM_LBUTTONUP",
		"WM_NOTIFY",
		"WM_SETFOCUS",
		"WM_SIZE",
		"WM_WINDOWPOSCHANGING",
		"wmCommandChild",
		"wmNotifyChild",
		"GetClassInfo",
		"checkStyle",
		"GetWindowLong",
		"SetWindowLong",
		"DefWindowProc",
		"CallWindowProc",
		"isValidSubclass",
		"error",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"max",
		"SendMessage",
		"SendMessage",
		"max",
		"max",
		"GetWindowRect",
		"getBorderWidth",
		"IsWindowVisible",
		"UpdateWindow",
		"SetWindowPos",
		"SendMessage",
		"SendMessage",
		"max",
		"max",
		"SetWindowPos",
		"ValidateRect",
		"computeTrim",
		"checkWidget",
		"computeTrim",
		"GetWindowLong",
		"createHandle",
		"IsAppThemed",
		"GetWindowLong",
		"SetWindowLong",
		"GetStockObject",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"error",
		"arraycopy",
		"widgetStyle",
		"SendMessage",
		"error",
		"setRowCount",
		"layoutItems",
		"createWidget",
		"GetSysColor",
		"defaultBackground",
		"SendMessage",
		"put",
		"put",
		"put",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"releaseToolImageList",
		"SendMessage",
		"releaseToolHotImageList",
		"SendMessage",
		"releaseToolDisabledImageList",
		"setRowCount",
		"layoutItems",
		"enableWidget",
		"updateImages",
		"getEnabled",
		"checkWidget",
		"SendMessage",
		"error",
		"SendMessage",
		"error",
		"checkWidget",
		"error",
		"getItems",
		"getBounds",
		"contains",
		"checkWidget",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"checkWidget",
		"error",
		"isDisposed",
		"error",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"resizeControl",
		"wcsToMbcs",
		"SendMessage",
		"setTabGroupFocus",
		"SendMessage",
		"SendMessage",
		"click",
		"wcsToMbcs",
		"SendMessage",
		"SendMessage",
		"findMnemonic",
		"isDisposed",
		"releaseImages",
		"releaseResources",
		"SendMessage",
		"releaseToolImageList",
		"SendMessage",
		"releaseToolHotImageList",
		"SendMessage",
		"releaseToolDisabledImageList",
		"releaseWidget",
		"removeControl",
		"setControl",
		"setBackgroundPixel",
		"IsAppThemed",
		"GetWindowLong",
		"SetWindowLong",
		"IsWindowVisible",
		"setResizeChildren",
		"setResizeChildren",
		"setBounds",
		"setDefaultFont",
		"SendMessage",
		"SendMessage",
		"getHandle",
		"SendMessage",
		"checkWidget",
		"setFont",
		"SendMessage",
		"SendMessage",
		"layoutItems",
		"getHandle",
		"SendMessage",
		"getHandle",
		"SendMessage",
		"checkWidget",
		"setParent",
		"SendMessage",
		"GetWindowRect",
		"MapWindowPoints",
		"SendMessage",
		"SetWindowPos",
		"getEnabled",
		"setTabItemFocus",
		"hasCursor",
		"SendMessage",
		"toolTipText",
		"widgetStyle",
		"WM_CAPTURECHANGED",
		"GetKeyState",
		"SendMessage",
		"SendMessage",
		"WM_CHAR",
		"SendMessage",
		"SendMessage",
		"click",
		"WM_COMMAND",
		"WM_GETDLGCODE",
		"WM_KEYDOWN",
		"SendMessage",
		"SendMessage",
		"WM_KILLFOCUS",
		"WM_LBUTTONDOWN",
		"WM_LBUTTONUP",
		"WM_NOTIFY",
		"WM_SETFOCUS",
		"GetFocus",
		"SendMessage",
		"SendMessage",
		"callWindowProc",
		"WM_SIZE",
		"isDisposed",
		"GetWindowRect",
		"getBorderWidth",
		"SendMessage",
		"SendMessage",
		"MapWindowPoints",
		"SendMessage",
		"SendMessage",
		"layoutItems",
		"WM_WINDOWPOSCHANGING",
		"IsWindowVisible",
		"SendMessage",
		"MoveMemory",
		"GetClientRect",
		"SetRect",
		"SendMessage",
		"SetRect",
		"InvalidateRect",
		"wmCommandChild",
		"MoveMemory",
		"MoveMemory",
		"SendMessage",
		"SendMessage",
		"postEvent",
		"findThemeControl",
		"MoveMemory",
		"drawBackground",
		"MoveMemory",
		"GetClientRect",
		"SendMessage",
		"SendMessage",
		"wmNotifyChild",
		"TCHAR",
		"WNDCLASS",
		"RECT",
		"TBBUTTON",
		"TBBUTTONINFO",
		"RECT",
		"RECT",
		"Point",
		"TBBUTTON",
		"TBBUTTONINFO",
		"TBBUTTON",
		"TBBUTTON",
		"TBBUTTONINFO",
		"RECT",
		"TBBUTTON",
		"LRESULT",
		"TBBUTTON",
		"LRESULT",
		"RECT",
		"RECT",
		"WINDOWPOS",
		"RECT",
		"RECT",
		"RECT",
		"NMHDR",
		"NMTOOLBAR",
		"Event",
		"RECT",
		"NMCUSTOMDRAW",
		"LRESULT",
		"NMTBHOTITEM",
		"RECT",
		"RECT"
	],
	"methodsBody":{
		"void enableWidget(boolean enabled)":{
			"methodBody":"{\n    super.enableWidget(enabled);\n    \n    for (int i = 0; i < items.length; i++) {\n        ToolItem item = items[i];\n        if (item != null) {\n            if ((item.style & (SWT.CHECK | SWT.RADIO)) != 0) {\n                item.updateImages(enabled && item.getEnabled());\n            }\n        }\n    }\n}",
			"comments":"/*\n* Bug in Windows.  When a tool item with the style\n* BTNS_CHECK or BTNS_CHECKGROUP is selected and then\n* disabled, the item does not draw using the disabled\n* image.  The fix is to use the disabled image in all\n* image lists.\n*/\n",
			"methodName":"void enableWidget(boolean enabled)"
		},
		"ImageList getDisabledImageList()":{
			"methodBody":"{\n    return disabledImageList;\n}",
			"comments":"",
			"methodName":"ImageList getDisabledImageList()"
		},
		"public ToolItem[] getItems()":{
			"methodBody":"{\n    checkWidget();\n    int count = OS.SendMessage(handle, OS.TB_BUTTONCOUNT, 0, 0);\n    TBBUTTON lpButton = new TBBUTTON();\n    ToolItem[] result = new ToolItem[count];\n    for (int i = 0; i < count; i++) {\n        OS.SendMessage(handle, OS.TB_GETBUTTON, i, lpButton);\n        result[i] = items[lpButton.idCommand];\n    }\n    return result;\n}",
			"comments":"/**\n* Returns an array of <code>ToolItem</code>s which are the items\n* in the receiver.\n* <p>\n* Note: This is not the actual structure used by the receiver\n* to maintain its list of items, so modifying the array will\n* not affect the receiver.\n* </p>\n*\n* @return the items in the receiver\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public ToolItem[] getItems()"
		},
		"public int getRowCount()":{
			"methodBody":"{\n    checkWidget();\n    if ((style & SWT.VERTICAL) != 0) {\n        return OS.SendMessage(handle, OS.TB_BUTTONCOUNT, 0, 0);\n    }\n    return OS.SendMessage(handle, OS.TB_GETROWS, 0, 0);\n}",
			"comments":"/**\n* Returns the number of rows in the receiver. When\n* the receiver has the <code>WRAP</code> style, the\n* number of rows can be greater than one.  Otherwise,\n* the number of rows is always one.\n*\n* @return the number of items\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getRowCount()"
		},
		"LRESULT WM_SETFOCUS(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_SETFOCUS(wParam, lParam);\n    if (lastFocusId != -1 && handle == OS.GetFocus()) {\n        int index = OS.SendMessage(handle, OS.TB_COMMANDTOINDEX, lastFocusId, 0);\n        OS.SendMessage(handle, OS.TB_SETHOTITEM, index, 0);\n    }\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_SETFOCUS(int wParam, int lParam)"
		},
		"LRESULT wmCommandChild(int wParam, int lParam)":{
			"methodBody":"{\n    ToolItem child = items[wParam & 0xFFFF];\n    if (child == null)\n        return null;\n    return child.wmCommandChild(wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT wmCommandChild(int wParam, int lParam)"
		},
		"protected void checkSubclass()":{
			"methodBody":"{\n    if (!isValidSubclass())\n        error(SWT.ERROR_INVALID_SUBCLASS);\n}",
			"comments":"",
			"methodName":"protected void checkSubclass()"
		},
		"public int indexOf(ToolItem item)":{
			"methodBody":"{\n    checkWidget();\n    if (item == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (item.isDisposed())\n        error(SWT.ERROR_INVALID_ARGUMENT);\n    return OS.SendMessage(handle, OS.TB_COMMANDTOINDEX, item.id, 0);\n}",
			"comments":"/**\n* Searches the receiver's list starting at the first item\n* (index 0) until an item is found that is equal to the\n* argument, and returns the index of that item. If no item\n* is found, returns -1.\n*\n* @param item the search item\n* @return the index of the item\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the tool item is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the tool item has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int indexOf(ToolItem item)"
		},
		"void removeControl(Control control)":{
			"methodBody":"{\n    super.removeControl(control);\n    for (int i = 0; i < items.length; i++) {\n        ToolItem item = items[i];\n        if (item != null && item.control == control) {\n            item.setControl(null);\n        }\n    }\n}",
			"comments":"",
			"methodName":"void removeControl(Control control)"
		},
		"LRESULT WM_LBUTTONUP(int wParam, int lParam)":{
			"methodBody":"{\n    if (ignoreMouse)\n        return null;\n    return super.WM_LBUTTONUP(wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_LBUTTONUP(int wParam, int lParam)"
		},
		"void createWidget()":{
			"methodBody":"{\n    super.createWidget();\n    items = new ToolItem[4];\n    lastFocusId = -1;\n}",
			"comments":"",
			"methodName":"void createWidget()"
		},
		"ImageList getHotImageList()":{
			"methodBody":"{\n    return hotImageList;\n}",
			"comments":"",
			"methodName":"ImageList getHotImageList()"
		},
		"int defaultBackground()":{
			"methodBody":"{\n    if (OS.IsWinCE)\n        return OS.GetSysColor(OS.COLOR_BTNFACE);\n    return super.defaultBackground();\n}",
			"comments":"",
			"methodName":"int defaultBackground()"
		},
		"void setHotImageList(ImageList imageList)":{
			"methodBody":"{\n    if (hotImageList == imageList)\n        return;\n    int hImageList = 0;\n    if ((hotImageList = imageList) != null) {\n        hImageList = hotImageList.getHandle();\n    }\n    OS.SendMessage(handle, OS.TB_SETHOTIMAGELIST, 0, hImageList);\n}",
			"comments":"",
			"methodName":"void setHotImageList(ImageList imageList)"
		},
		"void setImageList(ImageList imageList)":{
			"methodBody":"{\n    if (this.imageList == imageList)\n        return;\n    int hImageList = 0;\n    if ((this.imageList = imageList) != null) {\n        hImageList = imageList.getHandle();\n    }\n    OS.SendMessage(handle, OS.TB_SETIMAGELIST, 0, hImageList);\n}",
			"comments":"",
			"methodName":"void setImageList(ImageList imageList)"
		},
		"LRESULT WM_SIZE(int wParam, int lParam)":{
			"methodBody":"{\n    if (ignoreResize) {\n        int code = callWindowProc(handle, OS.WM_SIZE, wParam, lParam);\n        if (code == 0)\n            return LRESULT.ZERO;\n        return new LRESULT(code);\n    }\n    LRESULT result = super.WM_SIZE(wParam, lParam);\n    if (isDisposed())\n        return result;\n    \n    if ((style & SWT.BORDER) != 0 && (style & SWT.WRAP) != 0) {\n        RECT windowRect = new RECT();\n        OS.GetWindowRect(handle, windowRect);\n        int index = 0, border = getBorderWidth() * 2;\n        RECT rect = new RECT();\n        int count = OS.SendMessage(handle, OS.TB_BUTTONCOUNT, 0, 0);\n        while (index < count) {\n            OS.SendMessage(handle, OS.TB_GETITEMRECT, index, rect);\n            OS.MapWindowPoints(handle, 0, rect, 2);\n            if (rect.right > windowRect.right - border * 2)\n                break;\n            index++;\n        }\n        int bits = OS.SendMessage(handle, OS.TB_GETEXTENDEDSTYLE, 0, 0);\n        if (index == count) {\n            bits |= OS.TBSTYLE_EX_HIDECLIPPEDBUTTONS;\n        } else {\n            bits &= ~OS.TBSTYLE_EX_HIDECLIPPEDBUTTONS;\n        }\n        OS.SendMessage(handle, OS.TB_SETEXTENDEDSTYLE, 0, bits);\n    }\n    layoutItems();\n    return result;\n}",
			"comments":"/*\n* Bug in Windows.  The code in Windows that determines\n* when tool items should wrap seems to use the window\n* bounds rather than the client area.  Unfortunately,\n* tool bars with the style TBSTYLE_EX_HIDECLIPPEDBUTTONS\n* use the client area.  This means that buttons which\n* overlap the border are hidden before they are wrapped.\n* The fix is to compute TBSTYLE_EX_HIDECLIPPEDBUTTONS\n* and set it each time the tool bar is resized.\n*/\n",
			"methodName":"LRESULT WM_SIZE(int wParam, int lParam)"
		},
		"LRESULT WM_CHAR(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_CHAR(wParam, lParam);\n    if (result != null)\n        return result;\n    switch(wParam) {\n        case ' ':\n            int index = OS.SendMessage(handle, OS.TB_GETHOTITEM, 0, 0);\n            if (index != -1) {\n                TBBUTTON lpButton = new TBBUTTON();\n                int code = OS.SendMessage(handle, OS.TB_GETBUTTON, index, lpButton);\n                if (code != 0) {\n                    items[lpButton.idCommand].click(false);\n                    return LRESULT.ZERO;\n                }\n            }\n    }\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_CHAR(int wParam, int lParam)"
		},
		"void createHandle()":{
			"methodBody":"{\n    super.createHandle();\n    state &= ~CANVAS;\n    \n    if ((style & SWT.FLAT) != 0) {\n        if (OS.COMCTL32_MAJOR < 6 || !OS.IsAppThemed()) {\n            int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n            bits &= ~OS.TBSTYLE_TRANSPARENT;\n            OS.SetWindowLong(handle, OS.GWL_STYLE, bits);\n        }\n    }\n    \n    \n    \n    \n    \n    int hFont = OS.GetStockObject(OS.SYSTEM_FONT);\n    OS.SendMessage(handle, OS.WM_SETFONT, hFont, 0);\n    \n    OS.SendMessage(handle, OS.TB_BUTTONSTRUCTSIZE, TBBUTTON.sizeof, 0);\n    OS.SendMessage(handle, OS.TB_SETBITMAPSIZE, 0, 0);\n    OS.SendMessage(handle, OS.TB_SETBUTTONSIZE, 0, 0);\n    \n    int bits = OS.TBSTYLE_EX_DRAWDDARROWS | OS.TBSTYLE_EX_MIXEDBUTTONS | OS.TBSTYLE_EX_HIDECLIPPEDBUTTONS;\n    if (OS.COMCTL32_MAJOR >= 6)\n        bits |= OS.TBSTYLE_EX_DOUBLEBUFFER;\n    OS.SendMessage(handle, OS.TB_SETEXTENDEDSTYLE, 0, bits);\n}",
			"comments":"/*\n* Feature in Windows.  When TBSTYLE_FLAT is used to create\n* a flat toolbar, for some reason TBSTYLE_TRANSPARENT is\n* also set.  This causes the toolbar to flicker when it is\n* moved or resized.  The fix is to clear TBSTYLE_TRANSPARENT.\n*\n* NOTE:  This work around is unnecessary on XP.  There is no\n* flickering and clearing the TBSTYLE_TRANSPARENT interferes\n* with the XP theme.\n*/\n/*\n* Feature in Windows.  Despite the fact that the\n* tool tip text contains \\r\\n, the tooltip will\n* not honour the new line unless TTM_SETMAXTIPWIDTH\n* is set.  The fix is to set TTM_SETMAXTIPWIDTH to\n* a large value.\n*/\n/*\n* These lines are intentionally commented.  The tool\n* bar currently sets this value to 300 so it is not\n* necessary to set TTM_SETMAXTIPWIDTH.\n*/\n//\tint hwndToolTip = OS.SendMessage (handle, OS.TB_GETTOOLTIPS, 0, 0);\n//\tOS.SendMessage (hwndToolTip, OS.TTM_SETMAXTIPWIDTH, 0, 0x7FFF);\n/*\n* Feature in Windows.  When the control is created,\n* it does not use the default system font.  A new HFONT\n* is created and destroyed when the control is destroyed.\n* This means that a program that queries the font from\n* this control, uses the font in another control and then\n* destroys this control will have the font unexpectedly\n* destroyed in the other control.  The fix is to assign\n* the font ourselves each time the control is created.\n* The control will not destroy a font that it did not\n* create.\n*/\n/* Set the button struct, bitmap and button sizes */\n/* Set the extended style bits */\n",
			"methodName":"void createHandle()"
		},
		"public void setFont(Font font)":{
			"methodBody":"{\n    checkWidget();\n    super.setFont(font);\n    \n    int index = 0;\n    int mask = SWT.PUSH | SWT.CHECK | SWT.RADIO | SWT.DROP_DOWN;\n    while (index < items.length) {\n        ToolItem item = items[index];\n        if (item != null && (item.style & mask) != 0)\n            break;\n        index++;\n    }\n    if (index == items.length) {\n        OS.SendMessage(handle, OS.TB_SETBITMAPSIZE, 0, 0);\n        OS.SendMessage(handle, OS.TB_SETBUTTONSIZE, 0, 0);\n    }\n    layoutItems();\n}",
			"comments":"/*\n* Bug in Windows.  When WM_SETFONT is sent to a tool bar\n* that contains only separators, causes the bitmap and button\n* sizes to be set.  The fix is to reset these sizes after the font\n* has been changed when the tool bar contains only separators.\n*/\n",
			"methodName":"public void setFont(Font font)"
		},
		"LRESULT WM_GETDLGCODE(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_GETDLGCODE(wParam, lParam);\n    \n    if (result != null)\n        return result;\n    return new LRESULT(OS.DLGC_BUTTON);\n}",
			"comments":"/*\n* Return DLGC_BUTTON so that mnemonics will be\n* processed without needing to press the ALT key\n* when the widget has focus.\n*/\n",
			"methodName":"LRESULT WM_GETDLGCODE(int wParam, int lParam)"
		},
		"boolean mnemonicMatch(char ch)":{
			"methodBody":"{\n    int key = Display.wcsToMbcs(ch);\n    int[] id = new int[1];\n    if (OS.SendMessage(handle, OS.TB_MAPACCELERATOR, key, id) == 0) {\n        return false;\n    }\n    \n    int index = OS.SendMessage(handle, OS.TB_COMMANDTOINDEX, id[0], 0);\n    if (index == -1)\n        return false;\n    return findMnemonic(items[id[0]].text) != '\\0';\n}",
			"comments":"/*\n* Feature in Windows.  TB_MAPACCELERATOR matches either the mnemonic\n* character or the first character in a tool item.  This behavior is\n* undocumented and unwanted.  The fix is to ensure that the tool item\n* contains a mnemonic when TB_MAPACCELERATOR returns true.\n*/\n",
			"methodName":"boolean mnemonicMatch(char ch)"
		},
		"boolean setTabItemFocus()":{
			"methodBody":"{\n    int index = 0;\n    while (index < items.length) {\n        ToolItem item = items[index];\n        if (item != null && (item.style & SWT.SEPARATOR) == 0) {\n            if (item.getEnabled())\n                break;\n        }\n        index++;\n    }\n    if (index == items.length)\n        return false;\n    return super.setTabItemFocus();\n}",
			"comments":"",
			"methodName":"boolean setTabItemFocus()"
		},
		"int windowProc()":{
			"methodBody":"{\n    return ToolBarProc;\n}",
			"comments":"",
			"methodName":"int windowProc()"
		},
		"void destroyItem(ToolItem item)":{
			"methodBody":"{\n    TBBUTTONINFO info = new TBBUTTONINFO();\n    info.cbSize = TBBUTTONINFO.sizeof;\n    info.dwMask = OS.TBIF_IMAGE | OS.TBIF_STYLE;\n    int index = OS.SendMessage(handle, OS.TB_GETBUTTONINFO, item.id, info);\n    \n    if ((info.fsStyle & OS.BTNS_SEP) == 0 && info.iImage != OS.I_IMAGENONE) {\n        if (imageList != null)\n            imageList.put(info.iImage, null);\n        if (hotImageList != null)\n            hotImageList.put(info.iImage, null);\n        if (disabledImageList != null)\n            disabledImageList.put(info.iImage, null);\n    }\n    OS.SendMessage(handle, OS.TB_DELETEBUTTON, index, 0);\n    if (item.id == lastFocusId)\n        lastFocusId = -1;\n    items[item.id] = null;\n    item.id = -1;\n    int count = OS.SendMessage(handle, OS.TB_BUTTONCOUNT, 0, 0);\n    if (count == 0) {\n        if (imageList != null) {\n            OS.SendMessage(handle, OS.TB_SETIMAGELIST, 0, 0);\n            display.releaseToolImageList(imageList);\n        }\n        if (hotImageList != null) {\n            OS.SendMessage(handle, OS.TB_SETHOTIMAGELIST, 0, 0);\n            display.releaseToolHotImageList(hotImageList);\n        }\n        if (disabledImageList != null) {\n            OS.SendMessage(handle, OS.TB_SETDISABLEDIMAGELIST, 0, 0);\n            display.releaseToolDisabledImageList(disabledImageList);\n        }\n        imageList = hotImageList = disabledImageList = null;\n        items = new ToolItem[4];\n    }\n    if ((style & SWT.VERTICAL) != 0)\n        setRowCount(count - 1);\n    layoutItems();\n}",
			"comments":"/*\n* Feature in Windows.  For some reason, a tool item that has\n* the style BTNS_SEP does not return I_IMAGENONE when queried\n* for an image index, despite the fact that no attempt has been\n* made to assign an image to the item.  As a result, operations\n* on an image list that use the wrong index cause random results.\n* The fix is to ensure that the tool item is not a separator\n* before using the image index.  Since separators cannot have\n* an image and one is never assigned, this is not a problem.\n*/\n",
			"methodName":"void destroyItem(ToolItem item)"
		},
		"void setBounds(int x, int y, int width, int height, int flags)":{
			"methodBody":"{\n    \n    if (parent.lpwp != null) {\n        if (drawCount == 0 && OS.IsWindowVisible(handle)) {\n            parent.setResizeChildren(false);\n            parent.setResizeChildren(true);\n        }\n    }\n    super.setBounds(x, y, width, height, flags);\n}",
			"comments":"/*\n* Feature in Windows.  For some reason, when a tool bar is\n* repositioned more than once using DeferWindowPos () into\n* the same HDWP, the toolbar redraws more than once, defeating\n* the puropse of DeferWindowPos ().  The fix is to end the\n* defered positioning before the next tool bar is added,\n* ensuring that only one tool bar position is deferred at\n* any given time.\n*/\n",
			"methodName":"void setBounds(int x, int y, int width, int height, int flags)"
		},
		"public boolean setParent(Composite parent)":{
			"methodBody":"{\n    checkWidget();\n    if (!super.setParent(parent))\n        return false;\n    OS.SendMessage(handle, OS.TB_SETPARENT, parent.handle, 0);\n    return true;\n}",
			"comments":"",
			"methodName":"public boolean setParent(Composite parent)"
		},
		"int widgetStyle()":{
			"methodBody":"{\n    int bits = super.widgetStyle() | OS.CCS_NORESIZE | OS.TBSTYLE_TOOLTIPS | OS.TBSTYLE_CUSTOMERASE;\n    if ((style & SWT.SHADOW_OUT) == 0)\n        bits |= OS.CCS_NODIVIDER;\n    if ((style & SWT.WRAP) != 0)\n        bits |= OS.TBSTYLE_WRAPABLE;\n    if ((style & SWT.FLAT) != 0)\n        bits |= OS.TBSTYLE_FLAT;\n    if ((style & SWT.RIGHT) != 0)\n        bits |= OS.TBSTYLE_LIST;\n    return bits;\n}",
			"comments":"",
			"methodName":"int widgetStyle()"
		},
		"public int getItemCount()":{
			"methodBody":"{\n    checkWidget();\n    return OS.SendMessage(handle, OS.TB_BUTTONCOUNT, 0, 0);\n}",
			"comments":"/**\n* Returns the number of items contained in the receiver.\n*\n* @return the number of items\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getItemCount()"
		},
		"LRESULT wmNotifyChild(int wParam, int lParam)":{
			"methodBody":"{\n    NMHDR hdr = new NMHDR();\n    OS.MoveMemory(hdr, lParam, NMHDR.sizeof);\n    switch(hdr.code) {\n        case OS.TBN_DROPDOWN:\n            NMTOOLBAR lpnmtb = new NMTOOLBAR();\n            OS.MoveMemory(lpnmtb, lParam, NMTOOLBAR.sizeof);\n            ToolItem child = items[lpnmtb.iItem];\n            if (child != null) {\n                Event event = new Event();\n                event.detail = SWT.ARROW;\n                int index = OS.SendMessage(handle, OS.TB_COMMANDTOINDEX, lpnmtb.iItem, 0);\n                RECT rect = new RECT();\n                OS.SendMessage(handle, OS.TB_GETITEMRECT, index, rect);\n                event.x = rect.left;\n                event.y = rect.bottom;\n                child.postEvent(SWT.Selection, event);\n            }\n            break;\n        case OS.NM_CUSTOMDRAW:\n            if (findThemeControl() == null && background == -1)\n                break;\n            NMCUSTOMDRAW nmcd = new NMCUSTOMDRAW();\n            OS.MoveMemory(nmcd, lParam, NMCUSTOMDRAW.sizeof);\n            switch(nmcd.dwDrawStage) {\n                case OS.CDDS_PREERASE:\n                    return new LRESULT(OS.CDRF_NOTIFYPOSTERASE);\n                case OS.CDDS_POSTERASE:\n                    drawBackground(nmcd.hdc);\n                    return null;\n            }\n            break;\n        case OS.TBN_HOTITEMCHANGE:\n            if (!OS.IsWinCE) {\n                NMTBHOTITEM lpnmhi = new NMTBHOTITEM();\n                OS.MoveMemory(lpnmhi, lParam, NMTBHOTITEM.sizeof);\n                switch(lpnmhi.dwFlags) {\n                    case OS.HICF_ARROWKEYS:\n                        RECT client = new RECT();\n                        OS.GetClientRect(handle, client);\n                        int index = OS.SendMessage(handle, OS.TB_COMMANDTOINDEX, lpnmhi.idNew, 0);\n                        RECT rect = new RECT();\n                        OS.SendMessage(handle, OS.TB_GETITEMRECT, index, rect);\n                        if (rect.right > client.right || rect.bottom > client.bottom) {\n                            return LRESULT.ONE;\n                        }\n                        break;\n                }\n            }\n            break;\n    }\n    return super.wmNotifyChild(wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT wmNotifyChild(int wParam, int lParam)"
		},
		"void setBackgroundPixel(int pixel)":{
			"methodBody":"{\n    super.setBackgroundPixel(pixel);\n    \n    if ((style & SWT.FLAT) != 0) {\n        if (OS.COMCTL32_MAJOR < 6 || !OS.IsAppThemed()) {\n            int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n            if (pixel == -1) {\n                bits &= ~OS.TBSTYLE_TRANSPARENT;\n            } else {\n                bits |= OS.TBSTYLE_TRANSPARENT;\n            }\n            OS.SetWindowLong(handle, OS.GWL_STYLE, bits);\n        }\n    }\n}",
			"comments":"/*\n* Feature in Windows.  When TBSTYLE_TRANSPARENT is set\n* in a tool bar that is drawing a background, image in\n* the image list that include transparency information\n* do not draw correctly.  The fix is to clear and set\n* TBSTYLE_TRANSPARENT depending on the background color.\n*\n* NOTE:  This work around is unnecessary on XP.  The\n* TBSTYLE_TRANSPARENT style is never cleared on that\n* platform.\n*/\n",
			"methodName":"void setBackgroundPixel(int pixel)"
		},
		"boolean mnemonicHit(char ch)":{
			"methodBody":"{\n    int key = Display.wcsToMbcs(ch);\n    int[] id = new int[1];\n    if (OS.SendMessage(handle, OS.TB_MAPACCELERATOR, key, id) == 0) {\n        return false;\n    }\n    if ((style & SWT.FLAT) != 0 && !setTabGroupFocus())\n        return false;\n    int index = OS.SendMessage(handle, OS.TB_COMMANDTOINDEX, id[0], 0);\n    if (index == -1)\n        return false;\n    OS.SendMessage(handle, OS.TB_SETHOTITEM, index, 0);\n    items[id[0]].click(false);\n    return true;\n}",
			"comments":"",
			"methodName":"boolean mnemonicHit(char ch)"
		},
		"LRESULT WM_CAPTURECHANGED(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_CAPTURECHANGED(wParam, lParam);\n    if (result != null)\n        return result;\n    \n    if (OS.GetKeyState(OS.VK_LBUTTON) < 0) {\n        for (int i = 0; i < items.length; i++) {\n            ToolItem item = items[i];\n            if (item != null) {\n                int fsState = OS.SendMessage(handle, OS.TB_GETSTATE, item.id, 0);\n                if ((fsState & OS.TBSTATE_PRESSED) != 0) {\n                    fsState &= ~OS.TBSTATE_PRESSED;\n                    OS.SendMessage(handle, OS.TB_SETSTATE, item.id, fsState);\n                }\n            }\n        }\n    }\n    return null;\n}",
			"comments":"/*\n* Bug in Windows.  When the tool bar loses capture while an\n* item is pressed in WM_LBUTTONDOWN, the item remains pressed.\n* The fix is unpress the item using TB_SETSTATE.\n*/\n",
			"methodName":"LRESULT WM_CAPTURECHANGED(int wParam, int lParam)"
		},
		"public Rectangle computeTrim(int x, int y, int width, int height)":{
			"methodBody":"{\n    checkWidget();\n    Rectangle trim = super.computeTrim(x, y, width, height);\n    int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n    if ((bits & OS.CCS_NODIVIDER) == 0)\n        trim.height += 2;\n    return trim;\n}",
			"comments":"",
			"methodName":"public Rectangle computeTrim(int x, int y, int width, int height)"
		},
		"LRESULT WM_NOTIFY(int wParam, int lParam)":{
			"methodBody":"{\n    \n    LRESULT result = super.WM_NOTIFY(wParam, lParam);\n    if (result != null)\n        return result;\n    return LRESULT.ZERO;\n}",
			"comments":"/*\n* Feature in Windows.  When the toolbar window\n* proc processes WM_NOTIFY, it forwards this\n* message to its parent.  This is done so that\n* children of this control that send this message\n* type to their parent will notify not only\n* this control but also the parent of this control,\n* which is typically the application window and\n* the window that is looking for the message.\n* If the control did not forward the message,\n* applications would have to subclass the control\n* window to see the message. Because the control\n* window is subclassed by SWT, the message\n* is delivered twice, once by SWT and once when\n* the message is forwarded by the window proc.\n* The fix is to avoid calling the window proc\n* for this control.\n*/\n",
			"methodName":"LRESULT WM_NOTIFY(int wParam, int lParam)"
		},
		"public ToolItem getItem(Point point)":{
			"methodBody":"{\n    checkWidget();\n    if (point == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    ToolItem[] items = getItems();\n    for (int i = 0; i < items.length; i++) {\n        Rectangle rect = items[i].getBounds();\n        if (rect.contains(point))\n            return items[i];\n    }\n    return null;\n}",
			"comments":"/**\n* Returns the item at the given point in the receiver\n* or null if no such item exists. The point is in the\n* coordinate system of the receiver.\n*\n* @param point the point used to locate the item\n* @return the item at the given point\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the point is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public ToolItem getItem(Point point)"
		},
		"static int checkStyle(int style)":{
			"methodBody":"{\n    \n    if ((style & SWT.FLAT) == 0)\n        style |= SWT.NO_FOCUS;\n    \n    if ((style & SWT.VERTICAL) != 0)\n        style &= ~SWT.WRAP;\n    \n    return style & ~(SWT.H_SCROLL | SWT.V_SCROLL);\n}",
			"comments":"/*\n* On Windows, only flat tool bars can be traversed.\n*/\n/*\n* A vertical tool bar cannot wrap because TB_SETROWS\n* fails when the toobar has TBSTYLE_WRAPABLE.\n*/\n/*\n* Even though it is legal to create this widget\n* with scroll bars, they serve no useful purpose\n* because they do not automatically scroll the\n* widget's client area.  The fix is to clear\n* the SWT style.\n*/\n",
			"methodName":"static int checkStyle(int style)"
		},
		"LRESULT WM_COMMAND(int wParam, int lParam)":{
			"methodBody":"{\n    \n    LRESULT result = super.WM_COMMAND(wParam, lParam);\n    if (result != null)\n        return result;\n    return LRESULT.ZERO;\n}",
			"comments":"/*\n* Feature in Windows.  When the toolbar window\n* proc processes WM_COMMAND, it forwards this\n* message to its parent.  This is done so that\n* children of this control that send this message\n* type to their parent will notify not only\n* this control but also the parent of this control,\n* which is typically the application window and\n* the window that is looking for the message.\n* If the control did not forward the message,\n* applications would have to subclass the control\n* window to see the message. Because the control\n* window is subclassed by SWT, the message\n* is delivered twice, once by SWT and once when\n* the message is forwarded by the window proc.\n* The fix is to avoid calling the window proc\n* for this control.\n*/\n",
			"methodName":"LRESULT WM_COMMAND(int wParam, int lParam)"
		},
		"LRESULT WM_LBUTTONDOWN(int wParam, int lParam)":{
			"methodBody":"{\n    if (ignoreMouse)\n        return null;\n    return super.WM_LBUTTONDOWN(wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_LBUTTONDOWN(int wParam, int lParam)"
		},
		"void setRowCount(int count)":{
			"methodBody":"{\n    if ((style & SWT.VERTICAL) != 0) {\n        \n        RECT rect = new RECT();\n        OS.GetWindowRect(handle, rect);\n        OS.MapWindowPoints(0, parent.handle, rect, 2);\n        ignoreResize = true;\n        \n        count += 2;\n        OS.SendMessage(handle, OS.TB_SETROWS, (1 << 16) | count, 0);\n        int flags = OS.SWP_NOACTIVATE | OS.SWP_NOMOVE | OS.SWP_NOZORDER;\n        SetWindowPos(handle, 0, 0, 0, rect.right - rect.left, rect.bottom - rect.top, flags);\n        ignoreResize = false;\n    }\n}",
			"comments":"/*\n* Feature in Windows.  When the TB_SETROWS is used to set the\n* number of rows in a tool bar, the tool bar is resized to show\n* the items.  This is unexpected.  The fix is to save and restore\n* the current size of the tool bar.\n*/\n/*\n* Feature in Windows.  When the last button in a tool bar has the\n* style BTNS_SEP and TB_SETROWS is used to set the number of rows\n* in the tool bar, depending on the number of buttons, the toolbar\n* will wrap items with the style BTNS_CHECK, even when the fLarger\n* flags is used to force the number of rows to be larger than the\n* number of items.  The fix is to set the number of rows to be two\n* larger than the actual number of rows in the tool bar.  When items\n* are being added, as long as the number of rows is at least one\n* item larger than the count, the tool bar is laid out properly.\n* When items are being removed, setting the number of rows to be\n* one more than the item count has no effect.  The number of rows\n* is already one more causing TB_SETROWS to do nothing.  Therefore,\n* choosing two instead of one as the row increment fixes both cases.\n*/\n",
			"methodName":"void setRowCount(int count)"
		},
		"public Point computeSize(int wHint, int hHint, boolean changed)":{
			"methodBody":"{\n    checkWidget();\n    int width = 0, height = 0;\n    if ((style & SWT.VERTICAL) != 0) {\n        RECT rect = new RECT();\n        TBBUTTON lpButton = new TBBUTTON();\n        int count = OS.SendMessage(handle, OS.TB_BUTTONCOUNT, 0, 0);\n        for (int i = 0; i < count; i++) {\n            OS.SendMessage(handle, OS.TB_GETITEMRECT, i, rect);\n            height = Math.max(height, rect.bottom);\n            OS.SendMessage(handle, OS.TB_GETBUTTON, i, lpButton);\n            if ((lpButton.fsStyle & OS.BTNS_SEP) != 0) {\n                TBBUTTONINFO info = new TBBUTTONINFO();\n                info.cbSize = TBBUTTONINFO.sizeof;\n                info.dwMask = OS.TBIF_SIZE;\n                OS.SendMessage(handle, OS.TB_GETBUTTONINFO, lpButton.idCommand, info);\n                width = Math.max(width, info.cx);\n            } else {\n                width = Math.max(width, rect.right);\n            }\n        }\n    } else {\n        RECT oldRect = new RECT();\n        OS.GetWindowRect(handle, oldRect);\n        int oldWidth = oldRect.right - oldRect.left;\n        int oldHeight = oldRect.bottom - oldRect.top;\n        int border = getBorderWidth();\n        int newWidth = wHint == SWT.DEFAULT ? 0x3FFF : wHint + border * 2;\n        int newHeight = hHint == SWT.DEFAULT ? 0x3FFF : hHint + border * 2;\n        boolean redraw = drawCount == 0 && OS.IsWindowVisible(handle);\n        ignoreResize = true;\n        if (redraw)\n            OS.UpdateWindow(handle);\n        int flags = OS.SWP_NOACTIVATE | OS.SWP_NOMOVE | OS.SWP_NOREDRAW | OS.SWP_NOZORDER;\n        SetWindowPos(handle, 0, 0, 0, newWidth, newHeight, flags);\n        int count = OS.SendMessage(handle, OS.TB_BUTTONCOUNT, 0, 0);\n        if (count != 0) {\n            RECT rect = new RECT();\n            OS.SendMessage(handle, OS.TB_GETITEMRECT, count - 1, rect);\n            width = Math.max(width, rect.right);\n            height = Math.max(height, rect.bottom);\n        }\n        SetWindowPos(handle, 0, 0, 0, oldWidth, oldHeight, flags);\n        if (redraw)\n            OS.ValidateRect(handle, null);\n        ignoreResize = false;\n    }\n    \n    if (width == 0)\n        width = DEFAULT_WIDTH;\n    if (height == 0)\n        height = DEFAULT_HEIGHT;\n    if (wHint != SWT.DEFAULT)\n        width = wHint;\n    if (hHint != SWT.DEFAULT)\n        height = hHint;\n    Rectangle trim = computeTrim(0, 0, width, height);\n    width = trim.width;\n    height = trim.height;\n    return new Point(width, height);\n}",
			"comments":"/*\n* From the Windows SDK for TB_SETBUTTONSIZE:\n*\n*   \"If an application does not explicitly\n*\tset the button size, the size defaults\n*\tto 24 by 22 pixels\".\n*/\n",
			"methodName":"public Point computeSize(int wHint, int hHint, boolean changed)"
		},
		"LRESULT WM_WINDOWPOSCHANGING(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_WINDOWPOSCHANGING(wParam, lParam);\n    if (result != null)\n        return result;\n    if (ignoreResize)\n        return result;\n    \n    if (drawCount != 0)\n        return result;\n    if ((style & SWT.WRAP) == 0)\n        return result;\n    if (!OS.IsWindowVisible(handle))\n        return result;\n    if (OS.SendMessage(handle, OS.TB_GETROWS, 0, 0) == 1) {\n        return result;\n    }\n    WINDOWPOS lpwp = new WINDOWPOS();\n    OS.MoveMemory(lpwp, lParam, WINDOWPOS.sizeof);\n    if ((lpwp.flags & (OS.SWP_NOSIZE | OS.SWP_NOREDRAW)) != 0) {\n        return result;\n    }\n    RECT oldRect = new RECT();\n    OS.GetClientRect(handle, oldRect);\n    RECT newRect = new RECT();\n    OS.SetRect(newRect, 0, 0, lpwp.cx, lpwp.cy);\n    OS.SendMessage(handle, OS.WM_NCCALCSIZE, 0, newRect);\n    int oldWidth = oldRect.right - oldRect.left;\n    int newWidth = newRect.right - newRect.left;\n    if (newWidth > oldWidth) {\n        RECT rect = new RECT();\n        int newHeight = newRect.bottom - newRect.top;\n        OS.SetRect(rect, oldWidth - 2, 0, oldWidth, newHeight);\n        OS.InvalidateRect(handle, rect, false);\n    }\n    return result;\n}",
			"comments":"/*\n* Bug in Windows.  When a flat tool bar is wrapped,\n* Windows draws a horizontal separator between the\n* rows.  The tool bar does not draw the first or\n* the last two pixels of this separator.  When the\n* toolbar is resized to be bigger, only the new\n* area is drawn and the last two pixels, which are\n* blank are drawn over by separator.  This leaves\n* garbage on the screen.  The fix is to damage the\n* pixels.\n*/\n",
			"methodName":"LRESULT WM_WINDOWPOSCHANGING(int wParam, int lParam)"
		},
		"TCHAR windowClass()":{
			"methodBody":"{\n    return ToolBarClass;\n}",
			"comments":"",
			"methodName":"TCHAR windowClass()"
		},
		"public ToolItem getItem(int index)":{
			"methodBody":"{\n    checkWidget();\n    int count = OS.SendMessage(handle, OS.TB_BUTTONCOUNT, 0, 0);\n    if (!(0 <= index && index < count))\n        error(SWT.ERROR_INVALID_RANGE);\n    TBBUTTON lpButton = new TBBUTTON();\n    int result = OS.SendMessage(handle, OS.TB_GETBUTTON, index, lpButton);\n    if (result == 0)\n        error(SWT.ERROR_CANNOT_GET_ITEM);\n    return items[lpButton.idCommand];\n}",
			"comments":"/**\n* Returns the item at the given, zero-relative index in the\n* receiver. Throws an exception if the index is out of range.\n*\n* @param index the index of the item to return\n* @return the item at the given index\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_RANGE - if the index is not between 0 and the number of elements in the list minus 1 (inclusive)</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public ToolItem getItem(int index)"
		},
		"void setDefaultFont()":{
			"methodBody":"{\n    super.setDefaultFont();\n    OS.SendMessage(handle, OS.TB_SETBITMAPSIZE, 0, 0);\n    OS.SendMessage(handle, OS.TB_SETBUTTONSIZE, 0, 0);\n}",
			"comments":"",
			"methodName":"void setDefaultFont()"
		},
		"String toolTipText(NMTTDISPINFO hdr)":{
			"methodBody":"{\n    if ((hdr.uFlags & OS.TTF_IDISHWND) != 0) {\n        return null;\n    }\n    \n    if (!hasCursor())\n        return \"\";\n    int index = hdr.idFrom;\n    int hwndToolTip = OS.SendMessage(handle, OS.TB_GETTOOLTIPS, 0, 0);\n    if (hwndToolTip == hdr.hwndFrom) {\n        \n        if (toolTipText != null)\n            return \"\";\n        if (0 <= index && index < items.length) {\n            ToolItem item = items[index];\n            if (item != null)\n                return item.toolTipText;\n        }\n    }\n    return super.toolTipText(hdr);\n}",
			"comments":"/*\n* Bug in Windows.  On Windows XP, when TB_SETHOTITEM is\n* used to set the hot item, the tool bar control attempts\n* to display the tool tip, even when the cursor is not in\n* the hot item.  The fix is to detect this case and fail to\n* provide the string, causing no tool tip to be displayed.\n*/\n//$NON-NLS-1$\n//$NON-NLS-1$\n",
			"methodName":"String toolTipText(NMTTDISPINFO hdr)"
		},
		"LRESULT WM_KILLFOCUS(int wParam, int lParam)":{
			"methodBody":"{\n    int index = OS.SendMessage(handle, OS.TB_GETHOTITEM, 0, 0);\n    TBBUTTON lpButton = new TBBUTTON();\n    int code = OS.SendMessage(handle, OS.TB_GETBUTTON, index, lpButton);\n    if (code != 0)\n        lastFocusId = lpButton.idCommand;\n    return super.WM_KILLFOCUS(wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_KILLFOCUS(int wParam, int lParam)"
		},
		"void releaseWidget()":{
			"methodBody":"{\n    for (int i = 0; i < items.length; i++) {\n        ToolItem item = items[i];\n        if (item != null && !item.isDisposed()) {\n            item.releaseImages();\n            item.releaseResources();\n        }\n    }\n    items = null;\n    if (imageList != null) {\n        OS.SendMessage(handle, OS.TB_SETIMAGELIST, 0, 0);\n        display.releaseToolImageList(imageList);\n    }\n    if (hotImageList != null) {\n        OS.SendMessage(handle, OS.TB_SETHOTIMAGELIST, 0, 0);\n        display.releaseToolHotImageList(hotImageList);\n    }\n    if (disabledImageList != null) {\n        OS.SendMessage(handle, OS.TB_SETDISABLEDIMAGELIST, 0, 0);\n        display.releaseToolDisabledImageList(disabledImageList);\n    }\n    imageList = hotImageList = disabledImageList = null;\n    super.releaseWidget();\n}",
			"comments":"",
			"methodName":"void releaseWidget()"
		},
		"void layoutItems()":{
			"methodBody":"{\n    if ((style & SWT.WRAP) != 0) {\n        OS.SendMessage(handle, OS.TB_AUTOSIZE, 0, 0);\n    }\n    \n    if ((style & SWT.VERTICAL) != 0) {\n        TBBUTTONINFO info = new TBBUTTONINFO();\n        info.cbSize = TBBUTTONINFO.sizeof;\n        info.dwMask = OS.TBIF_SIZE;\n        int size = OS.SendMessage(handle, OS.TB_GETBUTTONSIZE, 0, 0);\n        info.cx = (short) (size & 0xFFFF);\n        int index = 0;\n        while (index < items.length) {\n            ToolItem item = items[index];\n            if (item != null && (item.style & SWT.DROP_DOWN) != 0)\n                break;\n            index++;\n        }\n        if (index < items.length) {\n            int padding = OS.SendMessage(handle, OS.TB_GETPADDING, 0, 0);\n            info.cx += (padding & 0xFFFF) * 2;\n        }\n        for (int i = 0; i < items.length; i++) {\n            ToolItem item = items[i];\n            if (item != null && (item.style & SWT.SEPARATOR) == 0) {\n                OS.SendMessage(handle, OS.TB_SETBUTTONINFO, item.id, info);\n            }\n        }\n    }\n    for (int i = 0; i < items.length; i++) {\n        ToolItem item = items[i];\n        if (item != null)\n            item.resizeControl();\n    }\n}",
			"comments":"/*\n*  When the tool bar is vertical, make the width of each button\n*  be the width of the widest button in the tool bar.  Note that\n*  when the tool bar contains a drop down item, it needs to take\n*  into account extra padding.\n*/\n",
			"methodName":"void layoutItems()"
		},
		"void setDisabledImageList(ImageList imageList)":{
			"methodBody":"{\n    if (disabledImageList == imageList)\n        return;\n    int hImageList = 0;\n    if ((disabledImageList = imageList) != null) {\n        hImageList = disabledImageList.getHandle();\n    }\n    OS.SendMessage(handle, OS.TB_SETDISABLEDIMAGELIST, 0, hImageList);\n}",
			"comments":"",
			"methodName":"void setDisabledImageList(ImageList imageList)"
		},
		"ImageList getImageList()":{
			"methodBody":"{\n    return imageList;\n}",
			"comments":"",
			"methodName":"ImageList getImageList()"
		},
		"int callWindowProc(int hwnd, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    if (handle == 0)\n        return 0;\n    \n    if (msg == OS.WM_SYSCHAR) {\n        return OS.DefWindowProc(hwnd, msg, wParam, lParam);\n    }\n    return OS.CallWindowProc(ToolBarProc, hwnd, msg, wParam, lParam);\n}",
			"comments":"/*\n* Bug in Windows.  For some reason, during the processing\n* of WM_SYSCHAR, the tool bar window proc does not call the\n* default window proc causing mnemonics for the menu bar\n* to be ignored.  The fix is to always call the default\n* window proc for WM_SYSCHAR.\n*/\n",
			"methodName":"int callWindowProc(int hwnd, int msg, int wParam, int lParam)"
		},
		"void createItem(ToolItem item, int index)":{
			"methodBody":"{\n    int count = OS.SendMessage(handle, OS.TB_BUTTONCOUNT, 0, 0);\n    if (!(0 <= index && index <= count))\n        error(SWT.ERROR_INVALID_RANGE);\n    int id = 0;\n    while (id < items.length && items[id] != null) id++;\n    if (id == items.length) {\n        ToolItem[] newItems = new ToolItem[items.length + 4];\n        System.arraycopy(items, 0, newItems, 0, items.length);\n        items = newItems;\n    }\n    int bits = item.widgetStyle();\n    TBBUTTON lpButton = new TBBUTTON();\n    lpButton.idCommand = id;\n    lpButton.fsStyle = (byte) bits;\n    lpButton.fsState = (byte) OS.TBSTATE_ENABLED;\n    \n    if ((bits & OS.BTNS_SEP) == 0)\n        lpButton.iBitmap = OS.I_IMAGENONE;\n    if (OS.SendMessage(handle, OS.TB_INSERTBUTTON, index, lpButton) == 0) {\n        error(SWT.ERROR_ITEM_NOT_ADDED);\n    }\n    items[item.id = id] = item;\n    if ((style & SWT.VERTICAL) != 0)\n        setRowCount(count + 1);\n    layoutItems();\n}",
			"comments":"/*\n* Bug in Windows.  Despite the fact that the image list\n* index has never been set for the item, Windows always\n* assumes that the image index for the item is valid.\n* When an item is inserted, the image index is zero.\n* Therefore, when the first image is inserted and is\n* assigned image index zero, every item draws with this\n* image.  The fix is to set the image index to none\n* when the item is created.  This is not necessary in\n* the case when the item has the BTNS_SEP style because\n* separators cannot show images.\n*/\n",
			"methodName":"void createItem(ToolItem item, int index)"
		},
		"LRESULT WM_KEYDOWN(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_KEYDOWN(wParam, lParam);\n    if (result != null)\n        return result;\n    switch(wParam) {\n        case OS.VK_SPACE:\n            \n            return LRESULT.ZERO;\n    }\n    return result;\n}",
			"comments":"/*\n* Ensure that the window proc does not process VK_SPACE\n* so that it can be handled in WM_CHAR.  This allows the\n* application the opportunity to cancel the operation.\n*/\n",
			"methodName":"LRESULT WM_KEYDOWN(int wParam, int lParam)"
		}
	},
	"ClassORInterfaceName":[
		"ToolBar"
	]
}
