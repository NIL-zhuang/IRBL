{
	"variables":[
		"handle",
		"style",
		"refCount",
		"images",
		"COLOR_FLAGS",
		"flags",
		"hDC",
		"bits",
		"planes",
		"depth",
		"flags",
		"count",
		"index",
		"rect",
		"newImages",
		"bm",
		"hDC",
		"hdc1",
		"hdc2",
		"hBitmap",
		"hIcon",
		"bm",
		"srcWidth",
		"srcHeight",
		"hdc",
		"srcHdc",
		"oldSrcBitmap",
		"memHdc",
		"bmiHeader",
		"bmi",
		"pBits",
		"memDib",
		"oldMemBitmap",
		"dibBM",
		"sizeInBytes",
		"srcData",
		"spinc",
		"ap",
		"sp",
		"y",
		"x",
		"transRed",
		"transGreen",
		"transBlue",
		"spinc",
		"sp",
		"y",
		"x",
		"bm",
		"srcWidth",
		"srcHeight",
		"hMask",
		"hDC",
		"hdc1",
		"isDib",
		"originalColors",
		"maxColors",
		"oldColors",
		"offset",
		"newColors",
		"hdc2",
		"hOldBitmap",
		"cx",
		"cy",
		"count",
		"i",
		"count",
		"count",
		"hImage",
		"cx",
		"cy",
		"hBitmap",
		"hMask",
		"data",
		"background",
		"color",
		"hIcon",
		"result",
		"count",
		"i",
		"OS",
		"COLOR_FLAGS",
		"OS",
		"OS",
		"OS",
		"flags",
		"OS",
		"OS",
		"OS",
		"hDC",
		"OS",
		"OS",
		"hDC",
		"OS",
		"OS",
		"hDC",
		"bits",
		"planes",
		"depth",
		"flags",
		"OS",
		"flags",
		"OS",
		"flags",
		"OS",
		"flags",
		"OS",
		"flags",
		"OS",
		"flags",
		"OS",
		"COLOR_FLAGS",
		"flags",
		"style",
		"COLOR_FLAGS",
		"OS",
		"style",
		"SWT",
		"flags",
		"OS",
		"handle",
		"OS",
		"flags",
		"images",
		"OS",
		"handle",
		"index",
		"count",
		"images",
		"index",
		"images",
		"index",
		"images",
		"index",
		"images",
		"index",
		"index",
		"count",
		"image",
		"OS",
		"handle",
		"rect",
		"rect",
		"index",
		"image",
		"count",
		"index",
		"images",
		"images",
		"System",
		"images",
		"newImages",
		"images",
		"images",
		"newImages",
		"images",
		"index",
		"image",
		"index",
		"refCount",
		"OS",
		"hImage",
		"BITMAP",
		"bm",
		"OS",
		"OS",
		"hDC",
		"OS",
		"hdc1",
		"hImage",
		"OS",
		"hDC",
		"OS",
		"hDC",
		"width",
		"height",
		"OS",
		"hdc2",
		"hBitmap",
		"width",
		"bm",
		"height",
		"bm",
		"OS",
		"OS",
		"hdc2",
		"OS",
		"OS",
		"hdc2",
		"width",
		"height",
		"hdc1",
		"bm",
		"bm",
		"OS",
		"OS",
		"hdc2",
		"width",
		"height",
		"hdc1",
		"OS",
		"OS",
		"hdc1",
		"OS",
		"hdc2",
		"OS",
		"hDC",
		"hBitmap",
		"OS",
		"SWT",
		"SWT",
		"OS",
		"hImage",
		"OS",
		"width",
		"height",
		"hIcon",
		"hIcon",
		"hImage",
		"OS",
		"hBitmap",
		"BITMAP",
		"bm",
		"bm",
		"bm",
		"OS",
		"OS",
		"hdc",
		"OS",
		"srcHdc",
		"hBitmap",
		"OS",
		"hdc",
		"bmiHeader",
		"BITMAPINFOHEADER",
		"bmiHeader",
		"Math",
		"srcWidth",
		"destWidth",
		"bmiHeader",
		"Math",
		"srcHeight",
		"destHeight",
		"bmiHeader",
		"bmiHeader",
		"bmiHeader",
		"OS",
		"BITMAPINFOHEADER",
		"OS",
		"bmi",
		"bmiHeader",
		"BITMAPINFOHEADER",
		"OS",
		"bmi",
		"OS",
		"pBits",
		"memDib",
		"SWT",
		"SWT",
		"OS",
		"memHdc",
		"memDib",
		"OS",
		"memDib",
		"BITMAP",
		"dibBM",
		"dibBM",
		"dibBM",
		"OS",
		"memHdc",
		"srcWidth",
		"srcHeight",
		"srcHdc",
		"OS",
		"sizeInBytes",
		"OS",
		"srcData",
		"dibBM",
		"sizeInBytes",
		"alphaData",
		"dibBM",
		"srcWidth",
		"y",
		"srcHeight",
		"y",
		"x",
		"srcWidth",
		"x",
		"srcData",
		"sp",
		"alphaData",
		"ap",
		"sp",
		"sp",
		"spinc",
		"background",
		"background",
		"background",
		"dibBM",
		"srcWidth",
		"y",
		"srcHeight",
		"y",
		"x",
		"srcWidth",
		"x",
		"srcData",
		"sp",
		"srcData",
		"sp",
		"transRed",
		"srcData",
		"sp",
		"transGreen",
		"srcData",
		"sp",
		"transBlue",
		"sp",
		"sp",
		"spinc",
		"OS",
		"dibBM",
		"srcData",
		"sizeInBytes",
		"srcWidth",
		"destWidth",
		"srcHeight",
		"destHeight",
		"OS",
		"memHdc",
		"OS",
		"OS",
		"memHdc",
		"destWidth",
		"destHeight",
		"memHdc",
		"srcWidth",
		"srcHeight",
		"OS",
		"OS",
		"memHdc",
		"oldMemBitmap",
		"OS",
		"memHdc",
		"OS",
		"srcHdc",
		"oldSrcBitmap",
		"OS",
		"srcHdc",
		"OS",
		"hdc",
		"memDib",
		"OS",
		"hBitmap",
		"BITMAP",
		"bm",
		"bm",
		"bm",
		"OS",
		"destWidth",
		"destHeight",
		"OS",
		"OS",
		"hDC",
		"background",
		"OS",
		"hdc1",
		"hBitmap",
		"bm",
		"OS",
		"transparentPixel",
		"isDib",
		"bm",
		"bm",
		"maxColors",
		"OS",
		"hdc1",
		"maxColors",
		"oldColors",
		"transparentPixel",
		"oldColors",
		"newColors",
		"offset",
		"newColors",
		"offset",
		"newColors",
		"offset",
		"OS",
		"hdc1",
		"maxColors",
		"newColors",
		"originalColors",
		"oldColors",
		"OS",
		"hdc1",
		"OS",
		"hdc1",
		"background",
		"OS",
		"hDC",
		"OS",
		"hdc2",
		"hMask",
		"destWidth",
		"srcWidth",
		"destHeight",
		"srcHeight",
		"OS",
		"OS",
		"hdc2",
		"OS",
		"OS",
		"hdc2",
		"destWidth",
		"destHeight",
		"hdc1",
		"srcWidth",
		"srcHeight",
		"OS",
		"OS",
		"hdc2",
		"destWidth",
		"destHeight",
		"hdc1",
		"OS",
		"OS",
		"hdc2",
		"originalColors",
		"OS",
		"hdc1",
		"bm",
		"originalColors",
		"OS",
		"hdc1",
		"hMask",
		"OS",
		"hdc1",
		"destWidth",
		"destHeight",
		"OS",
		"OS",
		"hdc1",
		"hOldBitmap",
		"OS",
		"hDC",
		"OS",
		"hdc1",
		"hMask",
		"handle",
		"OS",
		"handle",
		"handle",
		"images",
		"images",
		"index",
		"style",
		"handle",
		"OS",
		"handle",
		"cx",
		"cy",
		"cx",
		"cy",
		"OS",
		"handle",
		"i",
		"count",
		"i",
		"images",
		"i",
		"images",
		"i",
		"images",
		"i",
		"images",
		"i",
		"images",
		"i",
		"image",
		"i",
		"OS",
		"handle",
		"index",
		"index",
		"count",
		"image",
		"index",
		"image",
		"count",
		"images",
		"index",
		"image",
		"OS",
		"handle",
		"index",
		"index",
		"count",
		"OS",
		"handle",
		"index",
		"System",
		"images",
		"index",
		"images",
		"index",
		"count",
		"index",
		"images",
		"index",
		"refCount",
		"image",
		"OS",
		"handle",
		"cx",
		"cy",
		"image",
		"SWT",
		"image",
		"data",
		"SWT",
		"OS",
		"hBitmap",
		"hImage",
		"data",
		"cx",
		"cy",
		"hBitmap",
		"hImage",
		"cx",
		"cy",
		"hMask",
		"Display",
		"data",
		"cx",
		"cy",
		"SWT",
		"image",
		"color",
		"background",
		"color",
		"hBitmap",
		"hImage",
		"cx",
		"cy",
		"hMask",
		"hImage",
		"cx",
		"cy",
		"background",
		"data",
		"SWT",
		"hBitmap",
		"hImage",
		"cx",
		"cy",
		"index",
		"count",
		"hMask",
		"hImage",
		"cx",
		"cy",
		"index",
		"count",
		"OS",
		"handle",
		"hBitmap",
		"hMask",
		"OS",
		"handle",
		"index",
		"hBitmap",
		"hMask",
		"hMask",
		"OS",
		"hMask",
		"hBitmap",
		"hImage",
		"OS",
		"hBitmap",
		"SWT",
		"OS",
		"OS",
		"handle",
		"index",
		"count",
		"index",
		"hImage",
		"hImage",
		"cx",
		"cy",
		"OS",
		"handle",
		"index",
		"count",
		"index",
		"hIcon",
		"OS",
		"hIcon",
		"OS",
		"handle",
		"i",
		"count",
		"i",
		"images",
		"i",
		"images",
		"i",
		"images",
		"i",
		"images",
		"i",
		"result",
		"result",
		"IsWinCE",
		"ILC_COLOR",
		"COMCTL32_MAJOR",
		"ILC_COLOR32",
		"BITSPIXEL",
		"PLANES",
		"ILC_COLOR4",
		"ILC_COLOR8",
		"ILC_COLOR16",
		"ILC_COLOR24",
		"ILC_COLOR32",
		"ILC_COLOR",
		"style",
		"ILC_MASK",
		"RIGHT_TO_LEFT",
		"ILC_MIRROR",
		"width",
		"height",
		"length",
		"length",
		"length",
		"sizeof",
		"bmWidth",
		"bmHeight",
		"IsWinCE",
		"COLORONCOLOR",
		"bmWidth",
		"bmHeight",
		"SRCCOPY",
		"SRCCOPY",
		"IsWinCE",
		"ERROR_NOT_IMPLEMENTED",
		"IMAGE_ICON",
		"sizeof",
		"bmWidth",
		"bmHeight",
		"biSize",
		"sizeof",
		"biWidth",
		"biHeight",
		"biPlanes",
		"biBitCount",
		"biCompression",
		"BI_RGB",
		"sizeof",
		"sizeof",
		"DIB_RGB_COLORS",
		"ERROR_NO_HANDLES",
		"sizeof",
		"bmWidthBytes",
		"bmHeight",
		"SRCCOPY",
		"bmBits",
		"bmWidthBytes",
		"bmWidthBytes",
		"bmBits",
		"COLORONCOLOR",
		"SRCCOPY",
		"sizeof",
		"bmWidth",
		"bmHeight",
		"bmBits",
		"IsWinCE",
		"bmBitsPixel",
		"bmBitsPixel",
		"length",
		"IsWinCE",
		"COLORONCOLOR",
		"SRCCOPY",
		"SRCCOPY",
		"bmBitsPixel",
		"BLACKNESS",
		"handle",
		"type",
		"BITMAP",
		"TRANSPARENCY_ALPHA",
		"COMCTL32_MAJOR",
		"alphaData",
		"TRANSPARENCY_PIXEL",
		"handle",
		"transparentPixel",
		"TRANSPARENCY_NONE",
		"ICON",
		"IsWinCE",
		"style",
		"image",
		"hImage",
		"width",
		"height",
		"hImage",
		"width",
		"height",
		"hBitmap",
		"background",
		"alphaData",
		"destWidth",
		"destHeight",
		"hBitmap",
		"destWidth",
		"destHeight",
		"background",
		"transparentPixel",
		"index",
		"image",
		"index",
		"image",
		"index",
		"index",
		"image",
		"count"
	],
	"extendORImplementFiles":[],
	"package":[
		"org.eclipse.swt.widgets"
	],
	"import":[
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt",
		"org.eclipse.swt.graphics"
	],
	"methods":[
		"add",
		"addRef",
		"copyBitmap",
		"copyIcon",
		"copyWithAlpha",
		"createMask",
		"dispose",
		"get",
		"getStyle",
		"getHandle",
		"getImageSize",
		"indexOf",
		"put",
		"remove",
		"removeRef",
		"set",
		"size",
		"IsAppThemed",
		"GetDC",
		"GetDeviceCaps",
		"GetDeviceCaps",
		"ReleaseDC",
		"ImageList_Create",
		"ImageList_GetImageCount",
		"isDisposed",
		"getBounds",
		"ImageList_SetIconSize",
		"set",
		"arraycopy",
		"GetObject",
		"GetDC",
		"CreateCompatibleDC",
		"SelectObject",
		"CreateCompatibleDC",
		"CreateCompatibleBitmap",
		"SelectObject",
		"SetStretchBltMode",
		"StretchBlt",
		"BitBlt",
		"DeleteDC",
		"DeleteDC",
		"ReleaseDC",
		"error",
		"CopyImage",
		"GetObject",
		"GetDC",
		"CreateCompatibleDC",
		"SelectObject",
		"CreateCompatibleDC",
		"max",
		"max",
		"MoveMemory",
		"CreateDIBSection",
		"error",
		"SelectObject",
		"GetObject",
		"BitBlt",
		"MoveMemory",
		"MoveMemory",
		"SetStretchBltMode",
		"StretchBlt",
		"SelectObject",
		"DeleteDC",
		"SelectObject",
		"DeleteDC",
		"ReleaseDC",
		"GetObject",
		"CreateBitmap",
		"GetDC",
		"CreateCompatibleDC",
		"SelectObject",
		"GetDIBColorTable",
		"SetDIBColorTable",
		"SetBkColor",
		"SetBkColor",
		"CreateCompatibleDC",
		"SelectObject",
		"SetStretchBltMode",
		"StretchBlt",
		"BitBlt",
		"DeleteDC",
		"SetDIBColorTable",
		"SelectObject",
		"PatBlt",
		"SelectObject",
		"ReleaseDC",
		"DeleteDC",
		"ImageList_Destroy",
		"ImageList_GetIconSize",
		"ImageList_GetImageCount",
		"isDisposed",
		"equals",
		"ImageList_GetImageCount",
		"set",
		"ImageList_GetImageCount",
		"ImageList_Remove",
		"arraycopy",
		"ImageList_GetIconSize",
		"getImageData",
		"getTransparencyType",
		"copyWithAlpha",
		"copyBitmap",
		"createMaskFromAlpha",
		"getBackground",
		"copyBitmap",
		"createMask",
		"copyBitmap",
		"createMask",
		"ImageList_Add",
		"ImageList_Replace",
		"DeleteObject",
		"DeleteObject",
		"ImageList_ReplaceIcon",
		"copyIcon",
		"ImageList_ReplaceIcon",
		"DestroyIcon",
		"ImageList_GetImageCount",
		"isDisposed",
		"BITMAP",
		"BITMAP",
		"BITMAPINFOHEADER",
		"BITMAP",
		"BITMAP",
		"Point"
	],
	"methodsBody":{
		"int copyBitmap(int hImage, int width, int height)":{
			"methodBody":"{\n    BITMAP bm = new BITMAP();\n    OS.GetObject(hImage, BITMAP.sizeof, bm);\n    int hDC = OS.GetDC(0);\n    int hdc1 = OS.CreateCompatibleDC(hDC);\n    OS.SelectObject(hdc1, hImage);\n    int hdc2 = OS.CreateCompatibleDC(hDC);\n    int hBitmap = OS.CreateCompatibleBitmap(hDC, width, height);\n    OS.SelectObject(hdc2, hBitmap);\n    if (width != bm.bmWidth || height != bm.bmHeight) {\n        if (!OS.IsWinCE)\n            OS.SetStretchBltMode(hdc2, OS.COLORONCOLOR);\n        OS.StretchBlt(hdc2, 0, 0, width, height, hdc1, 0, 0, bm.bmWidth, bm.bmHeight, OS.SRCCOPY);\n    } else {\n        OS.BitBlt(hdc2, 0, 0, width, height, hdc1, 0, 0, OS.SRCCOPY);\n    }\n    OS.DeleteDC(hdc1);\n    OS.DeleteDC(hdc2);\n    OS.ReleaseDC(0, hDC);\n    return hBitmap;\n}",
			"comments":"",
			"methodName":"int copyBitmap(int hImage, int width, int height)"
		},
		"public void dispose()":{
			"methodBody":"{\n    if (handle != 0)\n        OS.ImageList_Destroy(handle);\n    handle = 0;\n    images = null;\n}",
			"comments":"",
			"methodName":"public void dispose()"
		},
		"public void remove(int index)":{
			"methodBody":"{\n    int count = OS.ImageList_GetImageCount(handle);\n    if (!(0 <= index && index < count))\n        return;\n    OS.ImageList_Remove(handle, index);\n    System.arraycopy(images, index + 1, images, index, --count - index);\n    images[index] = null;\n}",
			"comments":"",
			"methodName":"public void remove(int index)"
		},
		"public Image get(int index)":{
			"methodBody":"{\n    return images[index];\n}",
			"comments":"",
			"methodName":"public Image get(int index)"
		},
		"int copyIcon(int hImage, int width, int height)":{
			"methodBody":"{\n    if (OS.IsWinCE)\n        SWT.error(SWT.ERROR_NOT_IMPLEMENTED);\n    int hIcon = OS.CopyImage(hImage, OS.IMAGE_ICON, width, height, 0);\n    return hIcon != 0 ? hIcon : hImage;\n}",
			"comments":"",
			"methodName":"int copyIcon(int hImage, int width, int height)"
		},
		"int copyWithAlpha(int hBitmap, int background, byte[] alphaData, int destWidth, int destHeight)":{
			"methodBody":"{\n    BITMAP bm = new BITMAP();\n    OS.GetObject(hBitmap, BITMAP.sizeof, bm);\n    int srcWidth = bm.bmWidth;\n    int srcHeight = bm.bmHeight;\n    \n    int hdc = OS.GetDC(0);\n    int srcHdc = OS.CreateCompatibleDC(hdc);\n    int oldSrcBitmap = OS.SelectObject(srcHdc, hBitmap);\n    int memHdc = OS.CreateCompatibleDC(hdc);\n    BITMAPINFOHEADER bmiHeader = new BITMAPINFOHEADER();\n    bmiHeader.biSize = BITMAPINFOHEADER.sizeof;\n    bmiHeader.biWidth = Math.max(srcWidth, destWidth);\n    bmiHeader.biHeight = -Math.max(srcHeight, destHeight);\n    bmiHeader.biPlanes = 1;\n    bmiHeader.biBitCount = 32;\n    bmiHeader.biCompression = OS.BI_RGB;\n    byte[] bmi = new byte[BITMAPINFOHEADER.sizeof];\n    OS.MoveMemory(bmi, bmiHeader, BITMAPINFOHEADER.sizeof);\n    int[] pBits = new int[1];\n    int memDib = OS.CreateDIBSection(0, bmi, OS.DIB_RGB_COLORS, pBits, 0, 0);\n    if (memDib == 0)\n        SWT.error(SWT.ERROR_NO_HANDLES);\n    int oldMemBitmap = OS.SelectObject(memHdc, memDib);\n    BITMAP dibBM = new BITMAP();\n    OS.GetObject(memDib, BITMAP.sizeof, dibBM);\n    int sizeInBytes = dibBM.bmWidthBytes * dibBM.bmHeight;\n    \n    OS.BitBlt(memHdc, 0, 0, srcWidth, srcHeight, srcHdc, 0, 0, OS.SRCCOPY);\n    byte[] srcData = new byte[sizeInBytes];\n    OS.MoveMemory(srcData, dibBM.bmBits, sizeInBytes);\n    \n    if (alphaData != null) {\n        int spinc = dibBM.bmWidthBytes - srcWidth * 4;\n        int ap = 0, sp = 3;\n        for (int y = 0; y < srcHeight; ++y) {\n            for (int x = 0; x < srcWidth; ++x) {\n                srcData[sp] = alphaData[ap++];\n                sp += 4;\n            }\n            sp += spinc;\n        }\n    } else {\n        byte transRed = (byte) (background & 0xFF);\n        byte transGreen = (byte) ((background >> 8) & 0xFF);\n        byte transBlue = (byte) ((background >> 16) & 0xFF);\n        final int spinc = dibBM.bmWidthBytes - srcWidth * 4;\n        int sp = 3;\n        for (int y = 0; y < srcHeight; ++y) {\n            for (int x = 0; x < srcWidth; ++x) {\n                srcData[sp] = (srcData[sp - 1] == transRed && srcData[sp - 2] == transGreen && srcData[sp - 3] == transBlue) ? 0 : (byte) 255;\n                sp += 4;\n            }\n            sp += spinc;\n        }\n    }\n    OS.MoveMemory(dibBM.bmBits, srcData, sizeInBytes);\n    \n    if (srcWidth != destWidth || srcHeight != destHeight) {\n        OS.SetStretchBltMode(memHdc, OS.COLORONCOLOR);\n        OS.StretchBlt(memHdc, 0, 0, destWidth, destHeight, memHdc, 0, 0, srcWidth, srcHeight, OS.SRCCOPY);\n    }\n    \n    OS.SelectObject(memHdc, oldMemBitmap);\n    OS.DeleteDC(memHdc);\n    OS.SelectObject(srcHdc, oldSrcBitmap);\n    OS.DeleteDC(srcHdc);\n    OS.ReleaseDC(0, hdc);\n    return memDib;\n}",
			"comments":"/* Create resources */\n/* Get the foreground pixels */\n/* Merge the alpha channel in place */\n/* Stretch */\n/* Free resources */\n",
			"methodName":"int copyWithAlpha(int hBitmap, int background, byte[] alphaData, int destWidth, int destHeight)"
		},
		"int addRef()":{
			"methodBody":"{\n    return ++refCount;\n}",
			"comments":"",
			"methodName":"int addRef()"
		},
		"public int size()":{
			"methodBody":"{\n    int result = 0;\n    int count = OS.ImageList_GetImageCount(handle);\n    for (int i = 0; i < count; i++) {\n        if (images[i] != null) {\n            if (images[i].isDisposed())\n                images[i] = null;\n            if (images[i] != null)\n                result++;\n        }\n    }\n    return result;\n}",
			"comments":"",
			"methodName":"public int size()"
		},
		"public int getHandle()":{
			"methodBody":"{\n    return handle;\n}",
			"comments":"",
			"methodName":"public int getHandle()"
		},
		"public int getStyle()":{
			"methodBody":"{\n    return style;\n}",
			"comments":"",
			"methodName":"public int getStyle()"
		},
		"public int indexOf(Image image)":{
			"methodBody":"{\n    int count = OS.ImageList_GetImageCount(handle);\n    for (int i = 0; i < count; i++) {\n        if (images[i] != null) {\n            if (images[i].isDisposed())\n                images[i] = null;\n            if (images[i] != null && images[i].equals(image))\n                return i;\n        }\n    }\n    return -1;\n}",
			"comments":"",
			"methodName":"public int indexOf(Image image)"
		},
		"void set(int index, Image image, int count)":{
			"methodBody":"{\n    int hImage = image.handle;\n    int[] cx = new int[1], cy = new int[1];\n    OS.ImageList_GetIconSize(handle, cx, cy);\n    switch(image.type) {\n        case SWT.BITMAP:\n            {\n                \n                int hBitmap = 0, hMask = 0;\n                ImageData data = image.getImageData();\n                switch(data.getTransparencyType()) {\n                    case SWT.TRANSPARENCY_ALPHA:\n                        if (OS.COMCTL32_MAJOR >= 6) {\n                            hBitmap = copyWithAlpha(hImage, -1, data.alphaData, cx[0], cy[0]);\n                        } else {\n                            hBitmap = copyBitmap(hImage, cx[0], cy[0]);\n                            hMask = Display.createMaskFromAlpha(data, cx[0], cy[0]);\n                        }\n                        break;\n                    case SWT.TRANSPARENCY_PIXEL:\n                        int background = -1;\n                        Color color = image.getBackground();\n                        if (color != null)\n                            background = color.handle;\n                        hBitmap = copyBitmap(hImage, cx[0], cy[0]);\n                        hMask = createMask(hImage, cx[0], cy[0], background, data.transparentPixel);\n                        break;\n                    case SWT.TRANSPARENCY_NONE:\n                    default:\n                        hBitmap = copyBitmap(hImage, cx[0], cy[0]);\n                        if (index != count)\n                            hMask = createMask(hImage, cx[0], cy[0], -1, -1);\n                        break;\n                }\n                if (index == count) {\n                    OS.ImageList_Add(handle, hBitmap, hMask);\n                } else {\n                    \n                    OS.ImageList_Replace(handle, index, hBitmap, hMask);\n                }\n                if (hMask != 0)\n                    OS.DeleteObject(hMask);\n                if (hBitmap != hImage)\n                    OS.DeleteObject(hBitmap);\n                break;\n            }\n        case SWT.ICON:\n            {\n                if (OS.IsWinCE) {\n                    OS.ImageList_ReplaceIcon(handle, index == count ? -1 : index, hImage);\n                } else {\n                    int hIcon = copyIcon(hImage, cx[0], cy[0]);\n                    OS.ImageList_ReplaceIcon(handle, index == count ? -1 : index, hIcon);\n                    OS.DestroyIcon(hIcon);\n                }\n                break;\n            }\n    }\n}",
			"comments":"/*\n* Note that the image size has to match the image list icon size.\n*/\n/* Note that the mask must always be replaced even for TRANSPARENCY_NONE */\n",
			"methodName":"void set(int index, Image image, int count)"
		},
		"public int add(Image image)":{
			"methodBody":"{\n    int count = OS.ImageList_GetImageCount(handle);\n    int index = 0;\n    while (index < count) {\n        if (images[index] != null) {\n            if (images[index].isDisposed())\n                images[index] = null;\n        }\n        if (images[index] == null)\n            break;\n        index++;\n    }\n    if (count == 0) {\n        Rectangle rect = image.getBounds();\n        OS.ImageList_SetIconSize(handle, rect.width, rect.height);\n    }\n    set(index, image, count);\n    if (index == images.length) {\n        Image[] newImages = new Image[images.length + 4];\n        System.arraycopy(images, 0, newImages, 0, images.length);\n        images = newImages;\n    }\n    images[index] = image;\n    return index;\n}",
			"comments":"",
			"methodName":"public int add(Image image)"
		},
		"int createMask(int hBitmap, int destWidth, int destHeight, int background, int transparentPixel)":{
			"methodBody":"{\n    BITMAP bm = new BITMAP();\n    OS.GetObject(hBitmap, BITMAP.sizeof, bm);\n    int srcWidth = bm.bmWidth;\n    int srcHeight = bm.bmHeight;\n    int hMask = OS.CreateBitmap(destWidth, destHeight, 1, 1, null);\n    int hDC = OS.GetDC(0);\n    int hdc1 = OS.CreateCompatibleDC(hDC);\n    if (background != -1) {\n        OS.SelectObject(hdc1, hBitmap);\n        \n        boolean isDib = bm.bmBits != 0;\n        byte[] originalColors = null;\n        if (!OS.IsWinCE && transparentPixel != -1 && isDib && bm.bmBitsPixel <= 8) {\n            int maxColors = 1 << bm.bmBitsPixel;\n            byte[] oldColors = new byte[maxColors * 4];\n            OS.GetDIBColorTable(hdc1, 0, maxColors, oldColors);\n            int offset = transparentPixel * 4;\n            byte[] newColors = new byte[oldColors.length];\n            newColors[offset] = (byte) 0xFF;\n            newColors[offset + 1] = (byte) 0xFF;\n            newColors[offset + 2] = (byte) 0xFF;\n            OS.SetDIBColorTable(hdc1, 0, maxColors, newColors);\n            originalColors = oldColors;\n            OS.SetBkColor(hdc1, 0xFFFFFF);\n        } else {\n            OS.SetBkColor(hdc1, background);\n        }\n        int hdc2 = OS.CreateCompatibleDC(hDC);\n        OS.SelectObject(hdc2, hMask);\n        if (destWidth != srcWidth || destHeight != srcHeight) {\n            if (!OS.IsWinCE)\n                OS.SetStretchBltMode(hdc2, OS.COLORONCOLOR);\n            OS.StretchBlt(hdc2, 0, 0, destWidth, destHeight, hdc1, 0, 0, srcWidth, srcHeight, OS.SRCCOPY);\n        } else {\n            OS.BitBlt(hdc2, 0, 0, destWidth, destHeight, hdc1, 0, 0, OS.SRCCOPY);\n        }\n        OS.DeleteDC(hdc2);\n        \n        if (originalColors != null)\n            OS.SetDIBColorTable(hdc1, 0, 1 << bm.bmBitsPixel, originalColors);\n    } else {\n        int hOldBitmap = OS.SelectObject(hdc1, hMask);\n        OS.PatBlt(hdc1, 0, 0, destWidth, destHeight, OS.BLACKNESS);\n        OS.SelectObject(hdc1, hOldBitmap);\n    }\n    OS.ReleaseDC(0, hDC);\n    OS.DeleteDC(hdc1);\n    return hMask;\n}",
			"comments":"/*\n* If the image has a palette with multiple entries having\n* the same color and one of those entries is the transparentPixel,\n* only the first entry becomes transparent. To avoid this\n* problem, temporarily change the image palette to a palette\n* where the transparentPixel is white and everything else is\n* black.\n*/\n/* Put back the original palette */\n",
			"methodName":"int createMask(int hBitmap, int destWidth, int destHeight, int background, int transparentPixel)"
		},
		"public Point getImageSize()":{
			"methodBody":"{\n    int[] cx = new int[1], cy = new int[1];\n    OS.ImageList_GetIconSize(handle, cx, cy);\n    return new Point(cx[0], cy[0]);\n}",
			"comments":"",
			"methodName":"public Point getImageSize()"
		},
		"public void put(int index, Image image)":{
			"methodBody":"{\n    int count = OS.ImageList_GetImageCount(handle);\n    if (!(0 <= index && index < count))\n        return;\n    if (image != null)\n        set(index, image, count);\n    images[index] = image;\n}",
			"comments":"",
			"methodName":"public void put(int index, Image image)"
		},
		"int removeRef()":{
			"methodBody":"{\n    return --refCount;\n}",
			"comments":"",
			"methodName":"int removeRef()"
		}
	},
	"ClassORInterfaceName":[
		"ImageList"
	]
}
