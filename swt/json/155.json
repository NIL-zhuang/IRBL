{
	"variables":[
		"handle",
		"hPal",
		"index",
		"colorRefCount",
		"color",
		"hPal",
		"colorRefCount",
		"index",
		"entry",
		"i",
		"color",
		"device",
		"device",
		"Device",
		"device",
		"SWT",
		"SWT",
		"device",
		"red",
		"green",
		"blue",
		"device",
		"device",
		"device",
		"device",
		"Device",
		"device",
		"SWT",
		"SWT",
		"rgb",
		"SWT",
		"SWT",
		"device",
		"rgb",
		"rgb",
		"rgb",
		"device",
		"device",
		"handle",
		"device",
		"device",
		"hPal",
		"OS",
		"hPal",
		"handle",
		"device",
		"colorRefCount",
		"index",
		"colorRefCount",
		"index",
		"handle",
		"device",
		"device",
		"device",
		"object",
		"object",
		"object",
		"device",
		"color",
		"handle",
		"color",
		"SWT",
		"SWT",
		"handle",
		"SWT",
		"SWT",
		"handle",
		"SWT",
		"SWT",
		"handle",
		"SWT",
		"SWT",
		"handle",
		"handle",
		"handle",
		"handle",
		"red",
		"red",
		"green",
		"green",
		"blue",
		"blue",
		"SWT",
		"SWT",
		"device",
		"handle",
		"red",
		"green",
		"blue",
		"device",
		"hPal",
		"device",
		"OS",
		"hPal",
		"handle",
		"OS",
		"hPal",
		"index",
		"entry",
		"entry",
		"red",
		"entry",
		"green",
		"entry",
		"blue",
		"colorRefCount",
		"index",
		"i",
		"colorRefCount",
		"colorRefCount",
		"i",
		"index",
		"i",
		"i",
		"i",
		"colorRefCount",
		"handle",
		"entry",
		"entry",
		"entry",
		"entry",
		"red",
		"green",
		"blue",
		"OS",
		"hPal",
		"index",
		"entry",
		"colorRefCount",
		"index",
		"handle",
		"device",
		"device",
		"Device",
		"color",
		"handle",
		"color",
		"device",
		"color",
		"ERROR_NULL_ARGUMENT",
		"tracking",
		"ERROR_NULL_ARGUMENT",
		"ERROR_NULL_ARGUMENT",
		"red",
		"green",
		"blue",
		"tracking",
		"hPalette",
		"colorRefCount",
		"tracking",
		"device",
		"handle",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_INVALID_ARGUMENT",
		"device",
		"hPalette",
		"colorRefCount",
		"length",
		"length",
		"handle",
		"device",
		"device",
		"red",
		"green",
		"blue",
		"device",
		"rgb",
		"object",
		"device",
		"red",
		"green",
		"blue",
		"device",
		"handle"
	],
	"extendORImplementFiles":[
		"Resource"
	],
	"package":[
		"org.eclipse.swt.graphics"
	],
	"import":[
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt"
	],
	"methods":[
		"dispose",
		"equals",
		"getBlue",
		"getGreen",
		"getRed",
		"getRGB",
		"hashCode",
		"init",
		"isDisposed",
		"toString",
		"win32_new",
		"getDevice",
		"error",
		"init",
		"new_Object",
		"getDevice",
		"error",
		"error",
		"init",
		"new_Object",
		"isDisposed",
		"GetNearestPaletteIndex",
		"dispose_Object",
		"isDisposed",
		"error",
		"isDisposed",
		"error",
		"isDisposed",
		"error",
		"isDisposed",
		"error",
		"error",
		"GetNearestPaletteIndex",
		"GetPaletteEntries",
		"SetPaletteEntries",
		"isDisposed",
		"getRed",
		"getGreen",
		"getBlue",
		"getDevice",
		"RGB",
		"Color"
	],
	"methodsBody":{
		"public RGB getRGB()":{
			"methodBody":"{\n    if (isDisposed())\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    return new RGB(handle & 0xFF, (handle & 0xFF00) >> 8, (handle & 0xFF0000) >> 16);\n}",
			"comments":"/**\n* Returns an <code>RGB</code> representing the receiver.\n*\n* @return the RGB for the color\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public RGB getRGB()"
		},
		"public String toString()":{
			"methodBody":"{\n    \n    if (isDisposed())\n        return \"Color {*DISPOSED*}\";\n    \n    return \"Color {\" + getRed() + \", \" + getGreen() + \", \" + getBlue() + \"}\";\n}",
			"comments":"/**\n* Returns a string containing a concise, human-readable\n* description of the receiver.\n*\n* @return a string representation of the receiver\n*/\n//$NON-NLS-1$\n//$NON-NLS-1$//$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$\n",
			"methodName":"public String toString()"
		},
		"public void dispose()":{
			"methodBody":"{\n    if (handle == -1)\n        return;\n    if (device.isDisposed())\n        return;\n    \n    int hPal = device.hPalette;\n    if (hPal != 0) {\n        int index = OS.GetNearestPaletteIndex(hPal, handle);\n        int[] colorRefCount = device.colorRefCount;\n        if (colorRefCount[index] > 0) {\n            colorRefCount[index]--;\n        }\n    }\n    handle = -1;\n    if (device.tracking)\n        device.dispose_Object(this);\n    device = null;\n}",
			"comments":"/**\n* Disposes of the operating system resources associated with\n* the color. Applications must dispose of all colors which\n* they allocate.\n*/\n/*\n* If this is a palette-based device,\n* Decrease the reference count for this color.\n* If the reference count reaches 0, the slot may\n* be reused when another color is allocated.\n*/\n",
			"methodName":"public void dispose()"
		},
		"public int getRed()":{
			"methodBody":"{\n    if (isDisposed())\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    return handle & 0xFF;\n}",
			"comments":"/**\n* Returns the amount of red in the color, from 0 to 255.\n*\n* @return the red component of the color\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public int getRed()"
		},
		"public int hashCode()":{
			"methodBody":"{\n    return handle;\n}",
			"comments":"/**\n* Returns an integer hash code for the receiver. Any two\n* objects that return <code>true</code> when passed to\n* <code>equals</code> must return the same value for this\n* method.\n*\n* @return the receiver's hash\n*\n* @see #equals\n*/\n",
			"methodName":"public int hashCode()"
		},
		"public boolean isDisposed()":{
			"methodBody":"{\n    return handle == -1;\n}",
			"comments":"/**\n* Returns <code>true</code> if the color has been disposed,\n* and <code>false</code> otherwise.\n* <p>\n* This method gets the dispose state for the color.\n* When a color has been disposed, it is an error to\n* invoke any other method using the color.\n*\n* @return <code>true</code> when the color is disposed and <code>false</code> otherwise\n*/\n",
			"methodName":"public boolean isDisposed()"
		},
		"public static Color win32_new(Device device, int handle)":{
			"methodBody":"{\n    if (device == null)\n        device = Device.getDevice();\n    Color color = new Color();\n    color.handle = handle;\n    color.device = device;\n    return color;\n}",
			"comments":"/**\n* Invokes platform specific functionality to allocate a new color.\n* <p>\n* <b>IMPORTANT:</b> This method is <em>not</em> part of the public\n* API for <code>Color</code>. It is marked public only so that it\n* can be shared within the packages provided by SWT. It is not\n* available on all platforms, and should never be called from\n* application code.\n* </p>\n*\n* @param device the device on which to allocate the color\n* @param handle the handle for the color\n* @return a new color object containing the specified device and handle\n*/\n",
			"methodName":"public static Color win32_new(Device device, int handle)"
		},
		"public int getBlue()":{
			"methodBody":"{\n    if (isDisposed())\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    return (handle & 0xFF0000) >> 16;\n}",
			"comments":"/**\n* Returns the amount of blue in the color, from 0 to 255.\n*\n* @return the blue component of the color\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public int getBlue()"
		},
		"public boolean equals(Object object)":{
			"methodBody":"{\n    if (object == this)\n        return true;\n    if (!(object instanceof Color))\n        return false;\n    Color color = (Color) object;\n    return device == color.device && (handle & 0xFFFFFF) == (color.handle & 0xFFFFFF);\n}",
			"comments":"/**\n* Compares the argument to the receiver, and returns true\n* if they represent the <em>same</em> object using a class\n* specific comparison.\n*\n* @param object the object to compare with this object\n* @return <code>true</code> if the object is the same as this object and <code>false</code> otherwise\n*\n* @see #hashCode\n*/\n",
			"methodName":"public boolean equals(Object object)"
		},
		"public int getGreen()":{
			"methodBody":"{\n    if (isDisposed())\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    return (handle & 0xFF00) >> 8;\n}",
			"comments":"/**\n* Returns the amount of green in the color, from 0 to 255.\n*\n* @return the green component of the color\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public int getGreen()"
		},
		"void init(Device device, int red, int green, int blue)":{
			"methodBody":"{\n    if (red > 255 || red < 0 || green > 255 || green < 0 || blue > 255 || blue < 0) {\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    }\n    this.device = device;\n    handle = 0x02000000 | (red & 0xFF) | ((green & 0xFF) << 8) | ((blue & 0xFF) << 16);\n    \n    int hPal = device.hPalette;\n    if (hPal == 0)\n        return;\n    int[] colorRefCount = device.colorRefCount;\n    \n    \n    int index = OS.GetNearestPaletteIndex(hPal, handle);\n    \n    byte[] entry = new byte[4];\n    OS.GetPaletteEntries(hPal, index, 1, entry);\n    if ((entry[0] == (byte) red) && (entry[1] == (byte) green) && (entry[2] == (byte) blue)) {\n        \n        colorRefCount[index]++;\n        return;\n    }\n    \n    int i = 0;\n    while (i < colorRefCount.length) {\n        if (colorRefCount[i] == 0) {\n            index = i;\n            break;\n        }\n        i++;\n    }\n    if (i == colorRefCount.length) {\n        \n        \n        handle = (entry[0] & 0xFF) | ((entry[1] & 0xFF) << 8) | ((entry[2] & 0xFF) << 16);\n    } else {\n        \n        entry = new byte[] { (byte) (red & 0xFF), (byte) (green & 0xFF), (byte) (blue & 0xFF), 0 };\n        OS.SetPaletteEntries(hPal, index, 1, entry);\n    }\n    colorRefCount[index]++;\n}",
			"comments":"/**\n* Allocates the operating system resources associated\n* with the receiver.\n*\n* @param device the device on which to allocate the color\n* @param red the amount of red in the color\n* @param green the amount of green in the color\n* @param blue the amount of blue in the color\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the red, green or blue argument is not between 0 and 255</li>\n* </ul>\n*\n* @see #dispose\n*/\n/* If this is not a palette-based device, return */\n/* Add this color to the default palette now */\n/* First find out if the color already exists */\n/* See if the nearest color actually is the color */\n/* Found the color. Increment the ref count and return */\n/* Didn't find the color, allocate it now. Find the first free entry */\n/* No free entries, use the closest one */\n/* Remake the handle from the actual rgbs */\n/* Found a free entry */\n",
			"methodName":"void init(Device device, int red, int green, int blue)"
		}
	},
	"ClassORInterfaceName":[
		"Color"
	]
}
