{
	"variables":[
		"parent",
		"topIndex",
		"layouts",
		"i",
		"layout",
		"selection",
		"lineLength",
		"selectionStart",
		"selectionEnd",
		"lineEndSpaceWidth",
		"lineHeight",
		"rect",
		"isWrappedLine",
		"content",
		"lineEnd",
		"lineIndex",
		"logicalLineEvent",
		"lineIndex",
		"layoutIndex",
		"layout",
		"i",
		"verticalIncrement",
		"topIndex",
		"newLength",
		"newLayouts",
		"i",
		"layout",
		"layoutIndex",
		"device",
		"regularFont",
		"parent",
		"tabLength",
		"layouts",
		"i",
		"layouts",
		"i",
		"layouts",
		"i",
		"layout",
		"layout",
		"topIndex",
		"layouts",
		"gc",
		"parent",
		"line",
		"Math",
		"selection",
		"lineOffset",
		"selection",
		"lineOffset",
		"selectionEnd",
		"selectionStart",
		"selectionEnd",
		"selectionStart",
		"lineLength",
		"selectionEnd",
		"lineLength",
		"gc",
		"parent",
		"gc",
		"parent",
		"parent",
		"SWT",
		"gc",
		"paintX",
		"paintY",
		"rect",
		"paintX",
		"lineHeight",
		"parent",
		"lineOffset",
		"lineLength",
		"content",
		"lineEnd",
		"lineIndex",
		"content",
		"content",
		"lineIndex",
		"lineEnd",
		"isWrappedLine",
		"isWrappedLine",
		"gc",
		"paintX",
		"paintY",
		"lineEndSpaceWidth",
		"lineHeight",
		"parent",
		"parent",
		"lineOffset",
		"lineText",
		"parent",
		"parent",
		"parent",
		"parent",
		"parent",
		"parent",
		"lineOffset",
		"line",
		"parent",
		"lineOffset",
		"line",
		"logicalLineEvent",
		"logicalLineEvent",
		"logicalLineEvent",
		"lineOffset",
		"line",
		"logicalLineEvent",
		"parent",
		"parent",
		"parent",
		"parent",
		"parent",
		"parent",
		"parent",
		"SWT",
		"parent",
		"lineOffset",
		"layouts",
		"lineIndex",
		"topIndex",
		"layoutIndex",
		"layoutIndex",
		"layouts",
		"layouts",
		"layoutIndex",
		"layout",
		"layout",
		"layouts",
		"layoutIndex",
		"lineIndex",
		"lineOffset",
		"layouts",
		"i",
		"layouts",
		"i",
		"layouts",
		"i",
		"layout",
		"layout",
		"parent",
		"verticalIncrement",
		"parent",
		"verticalIncrement",
		"Math",
		"parent",
		"topIndex",
		"layouts",
		"topIndex",
		"newLength",
		"layouts",
		"newLength",
		"layouts",
		"i",
		"layouts",
		"i",
		"layouts",
		"i",
		"layout",
		"i",
		"topIndex",
		"layoutIndex",
		"layoutIndex",
		"newLayouts",
		"newLayouts",
		"layoutIndex",
		"layout",
		"layout",
		"topIndex",
		"layouts",
		"newLayouts",
		"parent",
		"length",
		"x",
		"y",
		"FULL_SELECTION",
		"width",
		"leftMargin",
		"rightMargin",
		"FULL_SELECTION",
		"length",
		"length",
		"verticalScrollOffset",
		"topIndex",
		"length",
		"length",
		"topIndex",
		"length",
		"topIndex",
		"device",
		"regularFont",
		"parent",
		"tabLength",
		"gc",
		"line",
		"lineOffset",
		"paintX",
		"paintY",
		"gc",
		"lineOffset",
		"lineText",
		"lineOffset",
		"line",
		"lineOffset",
		"line",
		"lineOffset",
		"layout"
	],
	"extendORImplementFiles":[
		"StyledTextRenderer"
	],
	"package":[
		"org.eclipse.swt.custom"
	],
	"import":[
		"org.eclipse.swt.SWT",
		"org.eclipse.swt.graphics"
	],
	"methods":[
		"dispose",
		"disposeGC",
		"drawLineBreakSelection",
		"getBidiSegments",
		"getClientArea",
		"getContent",
		"getGC",
		"getHorizontalPixel",
		"getLeftMargin",
		"getLineBackgroundData",
		"getLineStyleData",
		"getOrientation",
		"getRightMargin",
		"getSelectionBackground",
		"getSelectionForeground",
		"getSelection",
		"getWordWrap",
		"isFullLineSelection",
		"createTextLayout",
		"disposeTextLayout",
		"updateTopIndex",
		"calculateLineHeight",
		"setTabLength",
		"dispose",
		"disposeTextLayout",
		"dispose",
		"internalGetSelection",
		"length",
		"max",
		"getLineEndSpaceWidth",
		"getLineHeight",
		"setBackground",
		"getSelectionBackground",
		"setForeground",
		"getSelectionForeground",
		"getStyle",
		"getClientArea",
		"fillRectangle",
		"internalGetWordWrap",
		"getContent",
		"getLineAtOffset",
		"getLineCount",
		"getOffsetAtLine",
		"fillRectangle",
		"isBidi",
		"getBidiSegments",
		"getClientArea",
		"internalGetContent",
		"internalGetHorizontalPixel",
		"getLineBackgroundData",
		"getLineStyleData",
		"getLineStyleData",
		"getOrientation",
		"getSelectionBackground",
		"getSelectionForeground",
		"internalGetSelection",
		"getWordWrap",
		"getStyle",
		"internalGetWordWrap",
		"getLineAtOffset",
		"getContent",
		"updateTopIndex",
		"createTextLayout",
		"createTextLayout",
		"disposeTextLayout",
		"getVerticalIncrement",
		"max",
		"getPartialBottomIndex",
		"disposeTextLayout",
		"GC"
	],
	"methodsBody":{
		"protected StyledTextEvent getLineBackgroundData(int lineOffset, String line)":{
			"methodBody":"{\n    return parent.getLineBackgroundData(lineOffset, line);\n}",
			"comments":"/**\n* @see StyledTextRenderer#getLineBackgroundData\n*/\n",
			"methodName":"protected StyledTextEvent getLineBackgroundData(int lineOffset, String line)"
		},
		"protected void disposeGC(GC gc)":{
			"methodBody":"{\n    gc.dispose();\n}",
			"comments":"/**\n* Dispose the specified GC.\n* </p>\n* @param gc GC to dispose.\n*/\n",
			"methodName":"protected void disposeGC(GC gc)"
		},
		"protected Rectangle getClientArea()":{
			"methodBody":"{\n    return parent.getClientArea();\n}",
			"comments":"/**\n* Returns the visible client area that can be used for rendering.\n* </p>\n* @return the visible client area that can be used for rendering.\n*/\n",
			"methodName":"protected Rectangle getClientArea()"
		},
		"protected GC getGC()":{
			"methodBody":"{\n    return new GC(parent);\n}",
			"comments":"/**\n* Returns a new GC to use for rendering and measuring.\n* When the GC is no longer used it needs to be disposed by\n* calling disposeGC.\n* </p>\n* @return the GC to use for rendering and measuring.\n* @see #disposeGC\n*/\n",
			"methodName":"protected GC getGC()"
		},
		"protected StyledTextContent getContent()":{
			"methodBody":"{\n    return parent.internalGetContent();\n}",
			"comments":"/**\n* Returns the <class>StyledTextContent</class> to use for line offset\n* calculations.\n* </p>\n* @return the <class>StyledTextContent</class> to use for line offset\n* calculations.\n*/\n",
			"methodName":"protected StyledTextContent getContent()"
		},
		"TextLayout createTextLayout(int lineOffset)":{
			"methodBody":"{\n    if (!parent.internalGetWordWrap()) {\n        int lineIndex = getContent().getLineAtOffset(lineOffset);\n        updateTopIndex();\n        if (layouts != null) {\n            int layoutIndex = lineIndex - topIndex;\n            if (0 <= layoutIndex && layoutIndex < layouts.length) {\n                TextLayout layout = layouts[layoutIndex];\n                if (layout != null)\n                    return layout;\n                return layouts[layoutIndex] = super.createTextLayout(lineIndex);\n            }\n        }\n    }\n    return super.createTextLayout(lineOffset);\n}",
			"comments":"",
			"methodName":"TextLayout createTextLayout(int lineOffset)"
		},
		"protected int getLeftMargin()":{
			"methodBody":"{\n    return parent.leftMargin;\n}",
			"comments":"",
			"methodName":"protected int getLeftMargin()"
		},
		"protected void drawLineBreakSelection(String line, int lineOffset, int paintX, int paintY, GC gc)":{
			"methodBody":"{\n    Point selection = parent.internalGetSelection();\n    int lineLength = line.length();\n    int selectionStart = Math.max(0, selection.x - lineOffset);\n    int selectionEnd = selection.y - lineOffset;\n    int lineEndSpaceWidth = getLineEndSpaceWidth();\n    int lineHeight = getLineHeight();\n    if (selectionEnd == selectionStart || selectionEnd < 0 || selectionStart > lineLength || selectionEnd <= lineLength) {\n        return;\n    }\n    gc.setBackground(parent.getSelectionBackground());\n    gc.setForeground(parent.getSelectionForeground());\n    if ((parent.getStyle() & SWT.FULL_SELECTION) != 0) {\n        Rectangle rect = getClientArea();\n        gc.fillRectangle(paintX, paintY, rect.width - paintX, lineHeight);\n    } else {\n        boolean isWrappedLine = false;\n        if (parent.internalGetWordWrap()) {\n            StyledTextContent content = getContent();\n            int lineEnd = lineOffset + lineLength;\n            int lineIndex = content.getLineAtOffset(lineEnd);\n            \n            if (lineIndex < content.getLineCount() - 1 && content.getOffsetAtLine(lineIndex + 1) == lineEnd) {\n                isWrappedLine = true;\n            }\n        }\n        if (isWrappedLine == false) {\n            \n            gc.fillRectangle(paintX, paintY, lineEndSpaceWidth, lineHeight);\n        }\n    }\n}",
			"comments":"/**\n* Draws the line delimiter selection if the selection extends beyond the given line.\n* </p>\n*\n* @param line the line to draw\n* @param lineOffset offset of the first character in the line.\n* \tRelative to the start of the document.\n* @param paintX x location to draw at\n* @param paintY y location to draw at\n* @param gc GC to draw on\n*/\n// is the start offset of the next line the same as the end\n// offset of this line?\n// render the line break selection\n",
			"methodName":"protected void drawLineBreakSelection(String line, int lineOffset, int paintX, int paintY, GC gc)"
		},
		"protected Color getSelectionForeground()":{
			"methodBody":"{\n    return parent.getSelectionForeground();\n}",
			"comments":"",
			"methodName":"protected Color getSelectionForeground()"
		},
		"void dispose()":{
			"methodBody":"{\n    super.dispose();\n    if (layouts != null) {\n        for (int i = 0; i < layouts.length; i++) {\n            TextLayout layout = layouts[i];\n            if (layout != null)\n                super.disposeTextLayout(layout);\n        }\n        topIndex = -1;\n        layouts = null;\n    }\n}",
			"comments":"",
			"methodName":"void dispose()"
		},
		"protected int[] getBidiSegments(int lineOffset, String lineText)":{
			"methodBody":"{\n    if (!parent.isBidi())\n        return null;\n    return parent.getBidiSegments(lineOffset, lineText);\n}",
			"comments":"/**\n* Returns the text segments that should be treated as if they\n* had a different direction than the surrounding text.\n* </p>\n*\n* @param lineOffset offset of the first character in the line.\n* \t0 based from the beginning of the document.\n* @param lineText text of the line to specify bidi segments for\n* @return text segments that should be treated as if they had a\n* \tdifferent direction than the surrounding text. Only the start\n* \tindex of a segment is specified, relative to the start of the\n* \tline. Always starts with 0 and ends with the line length.\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the segment indices returned\n* \t\tby the listener do not start with 0, are not in ascending order,\n* \t\texceed the line length or have duplicates</li>\n* </ul>\n*/\n",
			"methodName":"protected int[] getBidiSegments(int lineOffset, String lineText)"
		},
		"void disposeTextLayout(TextLayout layout)":{
			"methodBody":"{\n    if (layouts != null) {\n        for (int i = 0; i < layouts.length; i++) {\n            if (layouts[i] == layout)\n                return;\n        }\n    }\n    super.disposeTextLayout(layout);\n}",
			"comments":"",
			"methodName":"void disposeTextLayout(TextLayout layout)"
		},
		"protected Color getSelectionBackground()":{
			"methodBody":"{\n    return parent.getSelectionBackground();\n}",
			"comments":"",
			"methodName":"protected Color getSelectionBackground()"
		},
		"protected boolean isFullLineSelection()":{
			"methodBody":"{\n    return (parent.getStyle() & SWT.FULL_SELECTION) != 0;\n}",
			"comments":"/**\n* @see StyledTextRenderer#isFullLineSelection\n*/\n",
			"methodName":"protected boolean isFullLineSelection()"
		},
		"protected boolean getWordWrap()":{
			"methodBody":"{\n    return parent.getWordWrap();\n}",
			"comments":"/**\n* @see StyledTextRenderer#getWordWrap\n*/\n",
			"methodName":"protected boolean getWordWrap()"
		},
		"void updateTopIndex()":{
			"methodBody":"{\n    int verticalIncrement = parent.getVerticalIncrement();\n    int topIndex = verticalIncrement == 0 ? 0 : parent.verticalScrollOffset / verticalIncrement;\n    int newLength = Math.max(1, parent.getPartialBottomIndex() - topIndex + 1);\n    if (layouts == null || topIndex != this.topIndex || newLength != layouts.length) {\n        TextLayout[] newLayouts = new TextLayout[newLength];\n        if (layouts != null) {\n            for (int i = 0; i < layouts.length; i++) {\n                TextLayout layout = layouts[i];\n                if (layout != null) {\n                    int layoutIndex = (i + this.topIndex) - topIndex;\n                    if (0 <= layoutIndex && layoutIndex < newLayouts.length) {\n                        newLayouts[layoutIndex] = layout;\n                    } else {\n                        super.disposeTextLayout(layout);\n                    }\n                }\n            }\n        }\n        this.topIndex = topIndex;\n        layouts = newLayouts;\n    }\n}",
			"comments":"",
			"methodName":"void updateTopIndex()"
		},
		"protected Point getSelection()":{
			"methodBody":"{\n    return parent.internalGetSelection();\n}",
			"comments":"/**\n* @see StyledTextRenderer#getSelection\n*/\n",
			"methodName":"protected Point getSelection()"
		},
		"protected int getHorizontalPixel()":{
			"methodBody":"{\n    return parent.internalGetHorizontalPixel();\n}",
			"comments":"/**\n* Returns the horizontal scroll position.\n* </p>\n* @return the horizontal scroll position.\n*/\n",
			"methodName":"protected int getHorizontalPixel()"
		},
		"protected int getRightMargin()":{
			"methodBody":"{\n    return parent.rightMargin;\n}",
			"comments":"",
			"methodName":"protected int getRightMargin()"
		},
		"protected int getOrientation()":{
			"methodBody":"{\n    return parent.getOrientation();\n}",
			"comments":"",
			"methodName":"protected int getOrientation()"
		},
		"protected StyledTextEvent getLineStyleData(int lineOffset, String line)":{
			"methodBody":"{\n    StyledTextEvent logicalLineEvent = parent.getLineStyleData(lineOffset, line);\n    if (logicalLineEvent != null) {\n        logicalLineEvent = getLineStyleData(logicalLineEvent, lineOffset, line);\n    }\n    return logicalLineEvent;\n}",
			"comments":"/**\n* @see StyledTextRenderer#getLineStyleData\n*/\n",
			"methodName":"protected StyledTextEvent getLineStyleData(int lineOffset, String line)"
		}
	},
	"ClassORInterfaceName":[
		"DisplayRenderer"
	]
}
