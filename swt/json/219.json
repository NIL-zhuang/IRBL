{
	"variables":[
		"reference",
		"LENGTH_OFFSET",
		"TYPE_OFFSET",
		"DATA_OFFSET",
		"TYPE_FIELD_LENGTH",
		"LENGTH_FIELD_LENGTH",
		"MIN_LENGTH",
		"CHUNK_UNKNOWN",
		"CHUNK_IHDR",
		"CHUNK_PLTE",
		"CHUNK_IDAT",
		"CHUNK_IEND",
		"CHUNK_tRNS",
		"TYPE_IHDR",
		"TYPE_PLTE",
		"TYPE_IDAT",
		"TYPE_IEND",
		"TYPE_tRNS",
		"CRC_TABLE",
		"i",
		"j",
		"answer",
		"type",
		"dataLength",
		"data",
		"crcOffset",
		"crcOffset",
		"crc",
		"storedCRC",
		"crc",
		"start",
		"stop",
		"i",
		"index",
		"i",
		"headerLength",
		"headerBytes",
		"result",
		"tempChunk",
		"chunkLength",
		"chunk",
		"type",
		"i",
		"buffer",
		"type",
		"i",
		"CRC_TABLE",
		"i",
		"i",
		"CRC_TABLE",
		"i",
		"i",
		"j",
		"j",
		"CRC_TABLE",
		"i",
		"CRC_TABLE",
		"i",
		"CRC_TABLE",
		"i",
		"CRC_TABLE",
		"i",
		"CRC_TABLE",
		"i",
		"reference",
		"reference",
		"reference",
		"answer",
		"reference",
		"offset",
		"answer",
		"reference",
		"offset",
		"answer",
		"reference",
		"offset",
		"answer",
		"reference",
		"offset",
		"answer",
		"reference",
		"offset",
		"value",
		"reference",
		"offset",
		"value",
		"reference",
		"offset",
		"value",
		"reference",
		"offset",
		"value",
		"LENGTH_OFFSET",
		"LENGTH_OFFSET",
		"value",
		"System",
		"reference",
		"TYPE_OFFSET",
		"type",
		"TYPE_FIELD_LENGTH",
		"type",
		"value",
		"TYPE_FIELD_LENGTH",
		"SWT",
		"SWT",
		"System",
		"value",
		"reference",
		"TYPE_OFFSET",
		"TYPE_FIELD_LENGTH",
		"reference",
		"MIN_LENGTH",
		"dataLength",
		"SWT",
		"SWT",
		"dataLength",
		"System",
		"reference",
		"DATA_OFFSET",
		"data",
		"dataLength",
		"data",
		"data",
		"System",
		"data",
		"reference",
		"DATA_OFFSET",
		"data",
		"DATA_OFFSET",
		"crcOffset",
		"DATA_OFFSET",
		"crcOffset",
		"value",
		"MIN_LENGTH",
		"crc",
		"storedCRC",
		"TYPE_OFFSET",
		"DATA_OFFSET",
		"start",
		"i",
		"stop",
		"i",
		"crc",
		"reference",
		"i",
		"crc",
		"CRC_TABLE",
		"index",
		"crc",
		"crc",
		"i",
		"TYPE_FIELD_LENGTH",
		"i",
		"reference",
		"TYPE_OFFSET",
		"i",
		"array",
		"i",
		"Character",
		"TYPE_IHDR",
		"CHUNK_IHDR",
		"TYPE_PLTE",
		"CHUNK_PLTE",
		"TYPE_IDAT",
		"CHUNK_IDAT",
		"TYPE_IEND",
		"CHUNK_IEND",
		"TYPE_tRNS",
		"CHUNK_tRNS",
		"CHUNK_UNKNOWN",
		"LENGTH_FIELD_LENGTH",
		"TYPE_FIELD_LENGTH",
		"headerLength",
		"stream",
		"headerBytes",
		"headerLength",
		"stream",
		"headerBytes",
		"result",
		"headerLength",
		"headerBytes",
		"tempChunk",
		"chunkLength",
		"result",
		"stream",
		"chunk",
		"chunkLength",
		"result",
		"chunkLength",
		"tempChunk",
		"CHUNK_IHDR",
		"chunk",
		"CHUNK_PLTE",
		"chunk",
		"CHUNK_IDAT",
		"chunk",
		"CHUNK_IEND",
		"chunk",
		"CHUNK_tRNS",
		"chunk",
		"chunk",
		"reference",
		"MIN_LENGTH",
		"SWT",
		"SWT",
		"Character",
		"type",
		"SWT",
		"SWT",
		"i",
		"TYPE_FIELD_LENGTH",
		"i",
		"Compatibility",
		"type",
		"i",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"buffer",
		"buffer",
		"buffer",
		"buffer",
		"i",
		"type",
		"i",
		"buffer",
		"type",
		"i",
		"buffer",
		"buffer",
		"buffer",
		"Integer",
		"buffer",
		"buffer",
		"reference",
		"length",
		"ERROR_INVALID_ARGUMENT",
		"length",
		"ERROR_INVALID_RANGE",
		"length",
		"length",
		"length",
		"ERROR_INVALID_IMAGE",
		"ERROR_INVALID_IMAGE",
		"ERROR_INVALID_IMAGE",
		"ERROR_INVALID_IMAGE",
		"length",
		"reference",
		"reference",
		"offset",
		"offset",
		"value",
		"value",
		"value",
		"data",
		"value",
		"array",
		"stream",
		"e",
		"readState",
		"headerChunk",
		"buffer"
	],
	"extendORImplementFiles":[
		"Object"
	],
	"package":[
		"org.eclipse.swt.internal.image"
	],
	"import":[
		"org.eclipse.swt",
		"org.eclipse.swt.internal.Compatibility",
		"java.io"
	],
	"methods":[
		"getReference",
		"setReference",
		"getInt32",
		"setInt32",
		"getLength",
		"setLength",
		"getTypeBytes",
		"setType",
		"getData",
		"setData",
		"getCRC",
		"setCRC",
		"getSize",
		"checkCRC",
		"computeCRC",
		"typeMatchesArray",
		"isCritical",
		"getChunkType",
		"readNextFromStream",
		"validate",
		"contributeToString",
		"toString",
		"setReference",
		"getInt32",
		"setInt32",
		"arraycopy",
		"error",
		"arraycopy",
		"getLength",
		"error",
		"arraycopy",
		"setLength",
		"arraycopy",
		"setCRC",
		"computeCRC",
		"getLength",
		"getInt32",
		"getLength",
		"setInt32",
		"getLength",
		"computeCRC",
		"getCRC",
		"getLength",
		"isUpperCase",
		"getTypeBytes",
		"typeMatchesArray",
		"typeMatchesArray",
		"typeMatchesArray",
		"typeMatchesArray",
		"typeMatchesArray",
		"read",
		"unread",
		"getSize",
		"read",
		"getChunkType",
		"error",
		"getTypeBytes",
		"isUpperCase",
		"error",
		"isLetter",
		"error",
		"checkCRC",
		"error",
		"append",
		"append",
		"append",
		"getLength",
		"append",
		"getTypeBytes",
		"append",
		"contributeToString",
		"append",
		"append",
		"toHexString",
		"getCRC",
		"append",
		"toString",
		"PngChunk",
		"PngIhdrChunk",
		"PngPlteChunk",
		"PngIdatChunk",
		"PngIendChunk",
		"PngTrnsChunk",
		"PngChunk",
		"StringBuffer"
	],
	"methodsBody":{
		"int getInt32(int offset)":{
			"methodBody":"{\n    int answer = 0;\n    answer |= (reference[offset] & 0xFF) << 24;\n    answer |= (reference[offset + 1] & 0xFF) << 16;\n    answer |= (reference[offset + 2] & 0xFF) << 8;\n    answer |= (reference[offset + 3] & 0xFF);\n    return answer;\n}",
			"comments":"/**\n* Get the 32-bit integer from the reference byte\n* array at the given offset.\n*/\n",
			"methodName":"int getInt32(int offset)"
		},
		"void setType(byte[] value)":{
			"methodBody":"{\n    if (value.length != TYPE_FIELD_LENGTH) {\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    }\n    System.arraycopy(value, 0, reference, TYPE_OFFSET, TYPE_FIELD_LENGTH);\n}",
			"comments":"/**\n* Set the chunk type. This is a four byte value.\n* Each byte should be an ASCII character.\n* The first byte is upper case if the chunk is critical.\n* The second byte is upper case if the chunk is publicly defined.\n* The third byte must be upper case.\n* The fourth byte is upper case if the chunk is unsafe to copy.\n* Public chunk types are defined by the PNG Development Group.\n*/\n",
			"methodName":"void setType(byte[] value)"
		},
		"boolean isCritical()":{
			"methodBody":"{\n    return Character.isUpperCase((char) getTypeBytes()[0]);\n}",
			"comments":"",
			"methodName":"boolean isCritical()"
		},
		"boolean checkCRC()":{
			"methodBody":"{\n    int crc = computeCRC();\n    int storedCRC = getCRC();\n    return crc == storedCRC;\n}",
			"comments":"/**\n* Compute the CRC value for the chunk's data. Answer\n* whether this value matches the value stored in the\n* chunk.\n*/\n",
			"methodName":"boolean checkCRC()"
		},
		"byte[] getData()":{
			"methodBody":"{\n    int dataLength = getLength();\n    if (reference.length < MIN_LENGTH + dataLength) {\n        SWT.error(SWT.ERROR_INVALID_RANGE);\n    }\n    byte[] data = new byte[dataLength];\n    System.arraycopy(reference, DATA_OFFSET, data, 0, dataLength);\n    return data;\n}",
			"comments":"/**\n* Get the chunk's data.\n*/\n",
			"methodName":"byte[] getData()"
		},
		"void contributeToString(StringBuffer buffer)":{
			"methodBody":"{\n}",
			"comments":"/**\n* Provided so that subclasses can override and add\n* data to the toString() call.\n*/\n",
			"methodName":"void contributeToString(StringBuffer buffer)"
		},
		"void setData(byte[] data)":{
			"methodBody":"{\n    setLength(data.length);\n    System.arraycopy(data, 0, reference, DATA_OFFSET, data.length);\n    setCRC(computeCRC());\n}",
			"comments":"/**\n* Set the chunk's data.\n* This method has two side-effects.\n* 1. It will set the length field to be the length\n*    of the data array given.\n* 2. It will set the CRC field to the computed CRC\n*    value of the data array given.\n*/\n",
			"methodName":"void setData(byte[] data)"
		},
		"int getLength()":{
			"methodBody":"{\n    return getInt32(LENGTH_OFFSET);\n}",
			"comments":"/**\n* Get the length of the data component of this chunk.\n* This is not the length of the entire chunk.\n*/\n",
			"methodName":"int getLength()"
		},
		"byte[] getTypeBytes()":{
			"methodBody":"{\n    byte[] type = new byte[4];\n    System.arraycopy(reference, TYPE_OFFSET, type, 0, TYPE_FIELD_LENGTH);\n    return type;\n}",
			"comments":"/**\n* Get the chunk type. This is a four byte value.\n* Each byte should be an ASCII character.\n* The first byte is upper case if the chunk is critical.\n* The second byte is upper case if the chunk is publicly defined.\n* The third byte must be upper case.\n* The fourth byte is upper case if the chunk is unsafe to copy.\n* Public chunk types are defined by the PNG Development Group.\n*/\n",
			"methodName":"byte[] getTypeBytes()"
		},
		"boolean typeMatchesArray(byte[] array)":{
			"methodBody":"{\n    for (int i = 0; i < TYPE_FIELD_LENGTH; i++) {\n        if (reference[TYPE_OFFSET + i] != array[i]) {\n            return false;\n        }\n    }\n    return true;\n}",
			"comments":"",
			"methodName":"boolean typeMatchesArray(byte[] array)"
		},
		"void setReference(byte[] reference)":{
			"methodBody":"{\n    this.reference = reference;\n}",
			"comments":"/**\n* Set the PngChunk's reference byteArray;\n*/\n",
			"methodName":"void setReference(byte[] reference)"
		},
		"int getChunkType()":{
			"methodBody":"{\n    if (typeMatchesArray(TYPE_IHDR))\n        return CHUNK_IHDR;\n    if (typeMatchesArray(TYPE_PLTE))\n        return CHUNK_PLTE;\n    if (typeMatchesArray(TYPE_IDAT))\n        return CHUNK_IDAT;\n    if (typeMatchesArray(TYPE_IEND))\n        return CHUNK_IEND;\n    if (typeMatchesArray(TYPE_tRNS))\n        return CHUNK_tRNS;\n    return CHUNK_UNKNOWN;\n}",
			"comments":"",
			"methodName":"int getChunkType()"
		},
		"void setInt32(int offset, int value)":{
			"methodBody":"{\n    reference[offset] = (byte) ((value >> 24) & 0xFF);\n    reference[offset + 1] = (byte) ((value >> 16) & 0xFF);\n    reference[offset + 2] = (byte) ((value >> 8) & 0xFF);\n    reference[offset + 3] = (byte) (value & 0xFF);\n}",
			"comments":"/**\n* Set the 32-bit integer in the reference byte\n* array at the given offset.\n*/\n",
			"methodName":"void setInt32(int offset, int value)"
		},
		"void setCRC(int value)":{
			"methodBody":"{\n    int crcOffset = DATA_OFFSET + getLength();\n    setInt32(crcOffset, value);\n}",
			"comments":"/**\n* Set the CRC value for the chunk's data.\n* Ensure that the length field has a good\n* value before making this call.\n*/\n",
			"methodName":"void setCRC(int value)"
		},
		"int getSize()":{
			"methodBody":"{\n    return MIN_LENGTH + getLength();\n}",
			"comments":"/**\n* Get the chunk's total size including the length, type, and crc fields.\n*/\n",
			"methodName":"int getSize()"
		},
		"public String toString()":{
			"methodBody":"{\n    StringBuffer buffer = new StringBuffer();\n    buffer.append(\"{\");\n    buffer.append(\"\\n\\tLength: \");\n    buffer.append(getLength());\n    buffer.append(\"\\n\\tType: \");\n    byte[] type = getTypeBytes();\n    for (int i = 0; i < type.length; i++) {\n        buffer.append((char) type[i]);\n    }\n    contributeToString(buffer);\n    buffer.append(\"\\n\\tCRC: \");\n    buffer.append(Integer.toHexString(getCRC()));\n    buffer.append(\"\\n}\");\n    return buffer.toString();\n}",
			"comments":"/**\n* Returns a string containing a concise, human-readable\n* description of the receiver.\n*\n* @return a string representation of the event\n*/\n",
			"methodName":"public String toString()"
		},
		"static PngChunk readNextFromStream(LEDataInputStream stream)":{
			"methodBody":"{\n    try {\n        int headerLength = LENGTH_FIELD_LENGTH + TYPE_FIELD_LENGTH;\n        byte[] headerBytes = new byte[headerLength];\n        int result = stream.read(headerBytes, 0, headerLength);\n        stream.unread(headerBytes);\n        if (result != headerLength)\n            return null;\n        PngChunk tempChunk = new PngChunk(headerBytes);\n        int chunkLength = tempChunk.getSize();\n        byte[] chunk = new byte[chunkLength];\n        result = stream.read(chunk, 0, chunkLength);\n        if (result != chunkLength)\n            return null;\n        switch(tempChunk.getChunkType()) {\n            case CHUNK_IHDR:\n                return new PngIhdrChunk(chunk);\n            case CHUNK_PLTE:\n                return new PngPlteChunk(chunk);\n            case CHUNK_IDAT:\n                return new PngIdatChunk(chunk);\n            case CHUNK_IEND:\n                return new PngIendChunk(chunk);\n            case CHUNK_tRNS:\n                return new PngTrnsChunk(chunk);\n            default:\n                return new PngChunk(chunk);\n        }\n    } catch (IOException e) {\n        return null;\n    }\n}",
			"comments":"/**\n* Read the next PNG chunk from the input stream given.\n* If unable to read a chunk, return null.\n*/\n",
			"methodName":"static PngChunk readNextFromStream(LEDataInputStream stream)"
		},
		"int computeCRC()":{
			"methodBody":"{\n    int crc = 0xFFFFFFFF;\n    int start = TYPE_OFFSET;\n    int stop = DATA_OFFSET + getLength();\n    for (int i = start; i < stop; i++) {\n        int index = (crc ^ reference[i]) & 0xFF;\n        crc = CRC_TABLE[index] ^ ((crc >> 8) & 0x00FFFFFF);\n    }\n    return ~crc;\n}",
			"comments":"/**\n* Answer the CRC value of chunk's data.\n*/\n",
			"methodName":"int computeCRC()"
		},
		"byte[] getReference()":{
			"methodBody":"{\n    return reference;\n}",
			"comments":"/**\n* Get the PngChunk's reference byteArray;\n*/\n",
			"methodName":"byte[] getReference()"
		},
		"void validate(PngFileReadState readState, PngIhdrChunk headerChunk)":{
			"methodBody":"{\n    if (reference.length < MIN_LENGTH)\n        SWT.error(SWT.ERROR_INVALID_IMAGE);\n    byte[] type = getTypeBytes();\n    \n    if (!Character.isUpperCase((char) type[2]))\n        SWT.error(SWT.ERROR_INVALID_IMAGE);\n    \n    for (int i = 0; i < TYPE_FIELD_LENGTH; i++) {\n        if (!Compatibility.isLetter((char) type[i]))\n            SWT.error(SWT.ERROR_INVALID_IMAGE);\n    }\n    \n    if (!checkCRC())\n        SWT.error(SWT.ERROR_INVALID_IMAGE);\n}",
			"comments":"/**\n* Answer whether the chunk is a valid PNG chunk.\n*/\n// The third character MUST be upper case.\n// All characters must be letters.\n// The stored CRC must match the data's computed CRC.\n",
			"methodName":"void validate(PngFileReadState readState, PngIhdrChunk headerChunk)"
		},
		"int getCRC()":{
			"methodBody":"{\n    int crcOffset = DATA_OFFSET + getLength();\n    return getInt32(crcOffset);\n}",
			"comments":"/**\n* Get the CRC value for the chunk's data.\n* Ensure that the length field has a good\n* value before making this call.\n*/\n",
			"methodName":"int getCRC()"
		},
		"void setLength(int value)":{
			"methodBody":"{\n    setInt32(LENGTH_OFFSET, value);\n}",
			"comments":"/**\n* Set the length of the data component of this chunk.\n* This is not the length of the entire chunk.\n*/\n",
			"methodName":"void setLength(int value)"
		}
	},
	"ClassORInterfaceName":[
		"PngChunk"
	]
}
