{
	"variables":[
		"items",
		"imageList",
		"TabFolderProc",
		"TabFolderClass",
		"TAB",
		"ID_UPDOWN",
		"lpWndClass",
		"hInstance",
		"hHeap",
		"byteCount",
		"lpszClassName",
		"typedListener",
		"size",
		"insetRect",
		"itemRect",
		"width",
		"count",
		"rect",
		"border",
		"rect",
		"border",
		"newWidth",
		"newHeight",
		"count",
		"newItems",
		"tcItem",
		"event",
		"hwndToolTip",
		"count",
		"index",
		"selectionIndex",
		"hTheme",
		"rect",
		"width",
		"height",
		"count",
		"count",
		"result",
		"index",
		"bounds",
		"hImageList",
		"index",
		"count",
		"i",
		"children",
		"width",
		"height",
		"i",
		"child",
		"index",
		"count",
		"rect",
		"size",
		"selection",
		"i",
		"item",
		"ch",
		"i",
		"item",
		"ch",
		"count",
		"i",
		"item",
		"count",
		"i",
		"item",
		"i",
		"index",
		"count",
		"oldIndex",
		"item",
		"control",
		"newIndex",
		"item",
		"control",
		"event",
		"index",
		"hwndToolTip",
		"item",
		"count",
		"index",
		"offset",
		"bits",
		"result",
		"result",
		"hittest",
		"result",
		"result",
		"code",
		"id",
		"hwnd",
		"bits",
		"result",
		"index",
		"item",
		"control",
		"result",
		"lpwp",
		"bits",
		"rect",
		"newWidth",
		"newHeight",
		"oldWidth",
		"oldHeight",
		"inset",
		"marginX",
		"marginY",
		"left",
		"bottom",
		"hdr",
		"code",
		"item",
		"index",
		"control",
		"event",
		"OS",
		"OS",
		"TabFolderClass",
		"lpWndClass",
		"TabFolderProc",
		"lpWndClass",
		"OS",
		"OS",
		"lpWndClass",
		"hInstance",
		"lpWndClass",
		"OS",
		"OS",
		"OS",
		"TabFolderClass",
		"TCHAR",
		"OS",
		"hHeap",
		"OS",
		"byteCount",
		"OS",
		"lpszClassName",
		"TabFolderClass",
		"byteCount",
		"lpWndClass",
		"lpszClassName",
		"OS",
		"lpWndClass",
		"parent",
		"style",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"SWT",
		"typedListener",
		"handle",
		"OS",
		"TabFolderProc",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"style",
		"style",
		"SWT",
		"SWT",
		"OS",
		"style",
		"SWT",
		"style",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"wHint",
		"hHint",
		"changed",
		"OS",
		"handle",
		"OS",
		"insetRect",
		"insetRect",
		"insetRect",
		"OS",
		"handle",
		"OS",
		"count",
		"OS",
		"handle",
		"OS",
		"count",
		"itemRect",
		"width",
		"Math",
		"width",
		"itemRect",
		"insetRect",
		"OS",
		"rect",
		"width",
		"size",
		"OS",
		"handle",
		"OS",
		"rect",
		"rect",
		"border",
		"rect",
		"border",
		"width",
		"rect",
		"rect",
		"size",
		"Math",
		"width",
		"size",
		"size",
		"OS",
		"rect",
		"x",
		"y",
		"x",
		"width",
		"y",
		"height",
		"OS",
		"handle",
		"OS",
		"rect",
		"rect",
		"border",
		"rect",
		"border",
		"rect",
		"border",
		"rect",
		"border",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"newWidth",
		"newHeight",
		"OS",
		"handle",
		"OS",
		"index",
		"index",
		"count",
		"SWT",
		"count",
		"items",
		"items",
		"System",
		"items",
		"newItems",
		"items",
		"items",
		"newItems",
		"OS",
		"handle",
		"OS",
		"index",
		"tcItem",
		"SWT",
		"System",
		"items",
		"index",
		"items",
		"index",
		"count",
		"index",
		"items",
		"index",
		"item",
		"count",
		"event",
		"items",
		"SWT",
		"event",
		"OS",
		"OS",
		"handle",
		"OS",
		"state",
		"CANVAS",
		"OS",
		"handle",
		"OS",
		"OS",
		"hwndToolTip",
		"OS",
		"items",
		"OS",
		"handle",
		"OS",
		"index",
		"count",
		"items",
		"index",
		"item",
		"index",
		"index",
		"count",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"index",
		"SWT",
		"System",
		"items",
		"index",
		"items",
		"index",
		"count",
		"index",
		"items",
		"count",
		"count",
		"imageList",
		"OS",
		"handle",
		"OS",
		"display",
		"imageList",
		"imageList",
		"items",
		"count",
		"index",
		"selectionIndex",
		"Math",
		"selectionIndex",
		"OS",
		"handle",
		"TAB",
		"OS",
		"hTheme",
		"hDC",
		"OS",
		"rect",
		"OS",
		"hTheme",
		"OS",
		"handle",
		"rect",
		"OS",
		"handle",
		"OS",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"width",
		"height",
		"OS",
		"handle",
		"OS",
		"index",
		"index",
		"count",
		"SWT",
		"items",
		"index",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"count",
		"System",
		"items",
		"result",
		"count",
		"result",
		"OS",
		"handle",
		"OS",
		"index",
		"items",
		"index",
		"OS",
		"handle",
		"OS",
		"image",
		"OS",
		"imageList",
		"image",
		"imageList",
		"display",
		"style",
		"SWT",
		"bounds",
		"bounds",
		"imageList",
		"OS",
		"handle",
		"OS",
		"hImageList",
		"imageList",
		"image",
		"index",
		"index",
		"imageList",
		"image",
		"imageList",
		"index",
		"image",
		"index",
		"item",
		"SWT",
		"OS",
		"handle",
		"OS",
		"i",
		"count",
		"i",
		"items",
		"i",
		"item",
		"i",
		"i",
		"children",
		"i",
		"children",
		"i",
		"OS",
		"handle",
		"OS",
		"index",
		"count",
		"items",
		"index",
		"child",
		"index",
		"index",
		"count",
		"child",
		"width",
		"Math",
		"width",
		"rect",
		"rect",
		"height",
		"Math",
		"height",
		"rect",
		"rect",
		"child",
		"wHint",
		"hHint",
		"flushCache",
		"width",
		"Math",
		"width",
		"size",
		"height",
		"Math",
		"height",
		"size",
		"width",
		"height",
		"i",
		"items",
		"i",
		"i",
		"selection",
		"items",
		"i",
		"item",
		"item",
		"Character",
		"key",
		"Character",
		"ch",
		"i",
		"i",
		"items",
		"i",
		"items",
		"i",
		"item",
		"item",
		"Character",
		"key",
		"Character",
		"ch",
		"OS",
		"handle",
		"OS",
		"i",
		"count",
		"i",
		"items",
		"i",
		"item",
		"item",
		"items",
		"imageList",
		"OS",
		"handle",
		"OS",
		"display",
		"imageList",
		"imageList",
		"control",
		"OS",
		"handle",
		"OS",
		"i",
		"count",
		"i",
		"items",
		"i",
		"item",
		"control",
		"item",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"eventTable",
		"SWT",
		"listener",
		"items",
		"SWT",
		"items",
		"items",
		"i",
		"i",
		"items",
		"i",
		"index",
		"index",
		"OS",
		"handle",
		"OS",
		"index",
		"index",
		"count",
		"index",
		"OS",
		"handle",
		"OS",
		"oldIndex",
		"items",
		"oldIndex",
		"item",
		"control",
		"control",
		"control",
		"OS",
		"handle",
		"OS",
		"index",
		"OS",
		"handle",
		"OS",
		"newIndex",
		"items",
		"newIndex",
		"item",
		"control",
		"control",
		"control",
		"control",
		"notify",
		"event",
		"item",
		"SWT",
		"event",
		"hdr",
		"OS",
		"hdr",
		"OS",
		"handle",
		"OS",
		"hwndToolTip",
		"hdr",
		"toolTipText",
		"index",
		"index",
		"items",
		"items",
		"index",
		"item",
		"item",
		"hdr",
		"count",
		"index",
		"index",
		"next",
		"index",
		"index",
		"offset",
		"count",
		"count",
		"index",
		"index",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"bits",
		"OS",
		"OS",
		"TabFolderClass",
		"TabFolderProc",
		"wParam",
		"lParam",
		"result",
		"result",
		"OS",
		"wParam",
		"lParam",
		"result",
		"result",
		"OS",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"hittest",
		"wParam",
		"lParam",
		"result",
		"result",
		"LRESULT",
		"wParam",
		"lParam",
		"result",
		"result",
		"OS",
		"OS",
		"result",
		"style",
		"SWT",
		"wParam",
		"code",
		"OS",
		"wParam",
		"lParam",
		"id",
		"ID_UPDOWN",
		"OS",
		"hwnd",
		"OS",
		"OS",
		"hwnd",
		"OS",
		"bits",
		"OS",
		"result",
		"wParam",
		"lParam",
		"result",
		"OS",
		"handle",
		"OS",
		"index",
		"items",
		"index",
		"item",
		"control",
		"control",
		"control",
		"result",
		"wParam",
		"lParam",
		"result",
		"result",
		"OS",
		"handle",
		"result",
		"OS",
		"lpwp",
		"lParam",
		"WINDOWPOS",
		"lpwp",
		"OS",
		"OS",
		"result",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"OS",
		"handle",
		"result",
		"OS",
		"rect",
		"lpwp",
		"lpwp",
		"OS",
		"handle",
		"OS",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"OS",
		"handle",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"newWidth",
		"oldWidth",
		"newHeight",
		"oldHeight",
		"result",
		"OS",
		"handle",
		"OS",
		"inset",
		"inset",
		"inset",
		"newWidth",
		"oldWidth",
		"oldWidth",
		"newWidth",
		"oldWidth",
		"left",
		"newWidth",
		"OS",
		"rect",
		"left",
		"marginX",
		"newWidth",
		"newHeight",
		"OS",
		"handle",
		"rect",
		"newHeight",
		"oldHeight",
		"oldHeight",
		"newHeight",
		"oldHeight",
		"bottom",
		"newHeight",
		"newWidth",
		"oldWidth",
		"oldWidth",
		"marginX",
		"OS",
		"rect",
		"bottom",
		"marginY",
		"oldWidth",
		"newHeight",
		"OS",
		"handle",
		"rect",
		"result",
		"OS",
		"hdr",
		"lParam",
		"NMHDR",
		"hdr",
		"code",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"index",
		"item",
		"items",
		"index",
		"item",
		"item",
		"control",
		"control",
		"code",
		"OS",
		"control",
		"control",
		"code",
		"OS",
		"code",
		"OS",
		"event",
		"item",
		"SWT",
		"event",
		"wParam",
		"lParam",
		"WC_TABCONTROL",
		"lpfnWndProc",
		"hInstance",
		"style",
		"CS_HREDRAW",
		"CS_VREDRAW",
		"CS_GLOBALCLASS",
		"sizeof",
		"HEAP_ZERO_MEMORY",
		"lpszClassName",
		"ERROR_NULL_ARGUMENT",
		"Selection",
		"DefaultSelection",
		"TOP",
		"BOTTOM",
		"IsPPC",
		"BOTTOM",
		"TOP",
		"H_SCROLL",
		"V_SCROLL",
		"ERROR_INVALID_SUBCLASS",
		"TCM_ADJUSTRECT",
		"left",
		"right",
		"TCM_GETITEMCOUNT",
		"TCM_GETITEMRECT",
		"right",
		"right",
		"y",
		"TCM_ADJUSTRECT",
		"left",
		"right",
		"right",
		"left",
		"x",
		"x",
		"TCM_ADJUSTRECT",
		"left",
		"right",
		"top",
		"bottom",
		"right",
		"left",
		"bottom",
		"top",
		"left",
		"top",
		"TCM_GETITEMCOUNT",
		"ERROR_INVALID_RANGE",
		"length",
		"length",
		"length",
		"TCM_INSERTITEM",
		"ERROR_ITEM_NOT_ADDED",
		"item",
		"Selection",
		"IsPPC",
		"CCM_SETVERSION",
		"TCM_GETTOOLTIPS",
		"TTM_SETMAXTIPWIDTH",
		"TCM_GETITEMCOUNT",
		"TCM_GETCURSEL",
		"TCM_DELETEITEM",
		"ERROR_ITEM_NOT_REMOVED",
		"TCM_SETIMAGELIST",
		"TABP_BODY",
		"TCM_ADJUSTRECT",
		"right",
		"left",
		"bottom",
		"top",
		"left",
		"top",
		"TCM_GETITEMCOUNT",
		"ERROR_INVALID_RANGE",
		"TCM_GETITEMCOUNT",
		"TCM_GETITEMCOUNT",
		"TCM_GETCURSEL",
		"TCM_GETCURSEL",
		"I_IMAGENONE",
		"RIGHT_TO_LEFT",
		"width",
		"height",
		"TCM_SETIMAGELIST",
		"ERROR_NULL_ARGUMENT",
		"TCM_GETITEMCOUNT",
		"length",
		"TCM_GETITEMCOUNT",
		"control",
		"x",
		"width",
		"y",
		"height",
		"x",
		"y",
		"length",
		"length",
		"TCM_GETITEMCOUNT",
		"TCM_SETIMAGELIST",
		"TCM_GETITEMCOUNT",
		"control",
		"ERROR_NULL_ARGUMENT",
		"Selection",
		"DefaultSelection",
		"ERROR_NULL_ARGUMENT",
		"length",
		"length",
		"TCM_GETITEMCOUNT",
		"TCM_GETCURSEL",
		"control",
		"TCM_SETCURSEL",
		"TCM_GETCURSEL",
		"control",
		"item",
		"Selection",
		"uFlags",
		"TTF_IDISHWND",
		"idFrom",
		"TCM_GETTOOLTIPS",
		"hwndFrom",
		"length",
		"toolTipText",
		"WS_CLIPCHILDREN",
		"NO_FOCUS",
		"TCS_FOCUSNEVER",
		"BOTTOM",
		"TCS_BOTTOM",
		"TCS_TABS",
		"TCS_TOOLTIPS",
		"DLGC_BUTTON",
		"WM_NCHITTEST",
		"ZERO",
		"WIN32_VERSION",
		"RIGHT_TO_LEFT",
		"WM_CREATE",
		"GWL_EXSTYLE",
		"GWL_EXSTYLE",
		"WS_EX_LAYOUTRTL",
		"TCM_GETCURSEL",
		"control",
		"sizeof",
		"flags",
		"SWP_NOSIZE",
		"SWP_NOREDRAW",
		"GWL_STYLE",
		"TCS_MULTILINE",
		"cx",
		"cy",
		"WM_NCCALCSIZE",
		"right",
		"left",
		"bottom",
		"top",
		"right",
		"left",
		"bottom",
		"top",
		"TCM_ADJUSTRECT",
		"right",
		"bottom",
		"sizeof",
		"code",
		"TCN_SELCHANGE",
		"TCN_SELCHANGING",
		"TCM_GETCURSEL",
		"control",
		"TCN_SELCHANGE",
		"TCN_SELCHANGE",
		"TCN_SELCHANGE",
		"item",
		"Selection",
		"parent",
		"style",
		"listener",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"style",
		"wHint",
		"hHint",
		"changed",
		"x",
		"y",
		"width",
		"height",
		"item",
		"index",
		"item",
		"hDC",
		"rect",
		"index",
		"image",
		"item",
		"wHint",
		"hHint",
		"flushCache",
		"key",
		"key",
		"control",
		"listener",
		"items",
		"index",
		"index",
		"notify",
		"hdr",
		"next",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam"
	],
	"extendORImplementFiles":[
		"Composite"
	],
	"package":[
		"org.eclipse.swt.widgets"
	],
	"import":[
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt",
		"org.eclipse.swt.graphics",
		"org.eclipse.swt.events"
	],
	"methods":[
		"addSelectionListener",
		"callWindowProc",
		"checkStyle",
		"checkSubclass",
		"computeSize",
		"computeTrim",
		"createItem",
		"createHandle",
		"createWidget",
		"destroyItem",
		"drawThemeBackground",
		"findThemeControl",
		"getClientArea",
		"getItem",
		"getItemCount",
		"getItems",
		"getSelection",
		"getSelectionIndex",
		"imageIndex",
		"indexOf",
		"minimumSize",
		"mnemonicHit",
		"mnemonicMatch",
		"releaseWidget",
		"removeControl",
		"removeSelectionListener",
		"setSelection",
		"setSelection",
		"setSelection",
		"toolTipText",
		"traversePage",
		"widgetStyle",
		"windowClass",
		"windowProc",
		"WM_GETDLGCODE",
		"WM_NCHITTEST",
		"WM_NOTIFY",
		"WM_PARENTNOTIFY",
		"WM_SIZE",
		"WM_WINDOWPOSCHANGING",
		"wmNotifyChild",
		"GetClassInfo",
		"GetModuleHandle",
		"GetProcessHeap",
		"length",
		"HeapAlloc",
		"MoveMemory",
		"RegisterClass",
		"checkStyle",
		"checkWidget",
		"error",
		"addListener",
		"addListener",
		"CallWindowProc",
		"checkBits",
		"isValidSubclass",
		"error",
		"checkWidget",
		"computeSize",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"max",
		"SetRect",
		"SendMessage",
		"getBorderWidth",
		"max",
		"checkWidget",
		"SetRect",
		"SendMessage",
		"getBorderWidth",
		"SendMessage",
		"error",
		"arraycopy",
		"SendMessage",
		"error",
		"arraycopy",
		"sendEvent",
		"createHandle",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"createWidget",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"error",
		"arraycopy",
		"SendMessage",
		"releaseImageList",
		"setSelection",
		"max",
		"OpenThemeData",
		"DrawThemeBackground",
		"CloseThemeData",
		"checkWidget",
		"forceResize",
		"GetClientRect",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"error",
		"checkWidget",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"arraycopy",
		"checkWidget",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"getBounds",
		"getImageList",
		"getHandle",
		"SendMessage",
		"indexOf",
		"add",
		"put",
		"checkWidget",
		"error",
		"SendMessage",
		"_getChildren",
		"SendMessage",
		"getBounds",
		"max",
		"max",
		"computeSize",
		"max",
		"max",
		"getSelectionIndex",
		"findMnemonic",
		"getText",
		"toUpperCase",
		"toUpperCase",
		"setFocus",
		"setSelection",
		"findMnemonic",
		"getText",
		"toUpperCase",
		"toUpperCase",
		"SendMessage",
		"isDisposed",
		"releaseResources",
		"SendMessage",
		"releaseImageList",
		"releaseWidget",
		"removeControl",
		"SendMessage",
		"setControl",
		"checkWidget",
		"error",
		"unhook",
		"unhook",
		"checkWidget",
		"error",
		"setSelection",
		"indexOf",
		"setSelection",
		"checkWidget",
		"SendMessage",
		"setSelection",
		"SendMessage",
		"isDisposed",
		"setVisible",
		"SendMessage",
		"SendMessage",
		"isDisposed",
		"setBounds",
		"getClientArea",
		"setVisible",
		"sendEvent",
		"SendMessage",
		"toolTipText",
		"getItemCount",
		"getSelectionIndex",
		"setSelection",
		"getSelectionIndex",
		"widgetStyle",
		"WM_GETDLGCODE",
		"WM_NCHITTEST",
		"DefWindowProc",
		"WM_NOTIFY",
		"WM_PARENTNOTIFY",
		"VERSION",
		"GetWindowLong",
		"SetWindowLong",
		"WM_SIZE",
		"isDisposed",
		"SendMessage",
		"isDisposed",
		"setBounds",
		"getClientArea",
		"WM_WINDOWPOSCHANGING",
		"IsWindowVisible",
		"MoveMemory",
		"GetWindowLong",
		"InvalidateRect",
		"SetRect",
		"SendMessage",
		"GetClientRect",
		"SendMessage",
		"SetRect",
		"InvalidateRect",
		"SetRect",
		"InvalidateRect",
		"MoveMemory",
		"SendMessage",
		"isDisposed",
		"setBounds",
		"getClientArea",
		"setVisible",
		"postEvent",
		"wmNotifyChild",
		"TCHAR",
		"WNDCLASS",
		"TypedListener",
		"RECT",
		"RECT",
		"RECT",
		"RECT",
		"Rectangle",
		"TCITEM",
		"Event",
		"RECT",
		"Rectangle",
		"Point",
		"Event",
		"LRESULT",
		"LRESULT",
		"WINDOWPOS",
		"RECT",
		"RECT",
		"NMHDR",
		"Event"
	],
	"methodsBody":{
		"boolean mnemonicMatch(char key)":{
			"methodBody":"{\n    for (int i = 0; i < items.length; i++) {\n        TabItem item = items[i];\n        if (item != null) {\n            char ch = findMnemonic(item.getText());\n            if (Character.toUpperCase(key) == Character.toUpperCase(ch)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}",
			"comments":"",
			"methodName":"boolean mnemonicMatch(char key)"
		},
		"LRESULT wmNotifyChild(int wParam, int lParam)":{
			"methodBody":"{\n    NMHDR hdr = new NMHDR();\n    OS.MoveMemory(hdr, lParam, NMHDR.sizeof);\n    int code = hdr.code;\n    switch(code) {\n        case OS.TCN_SELCHANGE:\n        case OS.TCN_SELCHANGING:\n            TabItem item = null;\n            int index = OS.SendMessage(handle, OS.TCM_GETCURSEL, 0, 0);\n            if (index != -1)\n                item = items[index];\n            if (item != null) {\n                Control control = item.control;\n                if (control != null && !control.isDisposed()) {\n                    if (code == OS.TCN_SELCHANGE) {\n                        control.setBounds(getClientArea());\n                    }\n                    control.setVisible(code == OS.TCN_SELCHANGE);\n                }\n            }\n            if (code == OS.TCN_SELCHANGE) {\n                Event event = new Event();\n                event.item = item;\n                postEvent(SWT.Selection, event);\n            }\n    }\n    return super.wmNotifyChild(wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT wmNotifyChild(int wParam, int lParam)"
		},
		"void destroyItem(TabItem item)":{
			"methodBody":"{\n    int count = OS.SendMessage(handle, OS.TCM_GETITEMCOUNT, 0, 0);\n    int index = 0;\n    while (index < count) {\n        if (items[index] == item)\n            break;\n        index++;\n    }\n    if (index == count)\n        return;\n    int selectionIndex = OS.SendMessage(handle, OS.TCM_GETCURSEL, 0, 0);\n    if (OS.SendMessage(handle, OS.TCM_DELETEITEM, index, 0) == 0) {\n        error(SWT.ERROR_ITEM_NOT_REMOVED);\n    }\n    System.arraycopy(items, index + 1, items, index, --count - index);\n    items[count] = null;\n    if (count == 0) {\n        if (imageList != null) {\n            OS.SendMessage(handle, OS.TCM_SETIMAGELIST, 0, 0);\n            display.releaseImageList(imageList);\n        }\n        imageList = null;\n        items = new TabItem[4];\n    }\n    if (count > 0 && index == selectionIndex) {\n        setSelection(Math.max(0, selectionIndex - 1), true);\n    }\n}",
			"comments":"",
			"methodName":"void destroyItem(TabItem item)"
		},
		"boolean mnemonicHit(char key)":{
			"methodBody":"{\n    int selection = getSelectionIndex();\n    for (int i = 0; i < items.length; i++) {\n        if (i != selection) {\n            TabItem item = items[i];\n            if (item != null) {\n                char ch = findMnemonic(item.getText());\n                if (Character.toUpperCase(key) == Character.toUpperCase(ch)) {\n                    if (setFocus()) {\n                        setSelection(i, true);\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}",
			"comments":"",
			"methodName":"boolean mnemonicHit(char key)"
		},
		"void setSelection(int index, boolean notify)":{
			"methodBody":"{\n    int oldIndex = OS.SendMessage(handle, OS.TCM_GETCURSEL, 0, 0);\n    if (oldIndex != -1) {\n        TabItem item = items[oldIndex];\n        Control control = item.control;\n        if (control != null && !control.isDisposed()) {\n            control.setVisible(false);\n        }\n    }\n    OS.SendMessage(handle, OS.TCM_SETCURSEL, index, 0);\n    int newIndex = OS.SendMessage(handle, OS.TCM_GETCURSEL, 0, 0);\n    if (newIndex != -1) {\n        TabItem item = items[newIndex];\n        Control control = item.control;\n        if (control != null && !control.isDisposed()) {\n            control.setBounds(getClientArea());\n            control.setVisible(true);\n        }\n        if (notify) {\n            Event event = new Event();\n            event.item = item;\n            sendEvent(SWT.Selection, event);\n        }\n    }\n}",
			"comments":"",
			"methodName":"void setSelection(int index, boolean notify)"
		},
		"protected void checkSubclass()":{
			"methodBody":"{\n    if (!isValidSubclass())\n        error(SWT.ERROR_INVALID_SUBCLASS);\n}",
			"comments":"",
			"methodName":"protected void checkSubclass()"
		},
		"LRESULT WM_NCHITTEST(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_NCHITTEST(wParam, lParam);\n    if (result != null)\n        return result;\n    \n    int hittest = OS.DefWindowProc(handle, OS.WM_NCHITTEST, wParam, lParam);\n    return new LRESULT(hittest);\n}",
			"comments":"/*\n* Feature in Windows.  The tab control implements\n* WM_NCHITTEST to return HTCLIENT when the cursor\n* is inside the tab buttons.  This causes mouse\n* events like WM_MOUSEMOVE to be delivered to the\n* parent.  Also, tool tips for the tab control are\n* never invoked because tool tips rely on mouse\n* events to be delivered to the window that wants\n* to display the tool tip.  The fix is to call the\n* default window proc that returns HTCLIENT when\n* the mouse is in the client area.\n*/\n",
			"methodName":"LRESULT WM_NCHITTEST(int wParam, int lParam)"
		},
		"public Rectangle getClientArea()":{
			"methodBody":"{\n    checkWidget();\n    forceResize();\n    RECT rect = new RECT();\n    OS.GetClientRect(handle, rect);\n    OS.SendMessage(handle, OS.TCM_ADJUSTRECT, 0, rect);\n    int width = rect.right - rect.left;\n    int height = rect.bottom - rect.top;\n    return new Rectangle(rect.left, rect.top, width, height);\n}",
			"comments":"",
			"methodName":"public Rectangle getClientArea()"
		},
		"Point minimumSize(int wHint, int hHint, boolean flushCache)":{
			"methodBody":"{\n    Control[] children = _getChildren();\n    int width = 0, height = 0;\n    for (int i = 0; i < children.length; i++) {\n        Control child = children[i];\n        int index = 0;\n        int count = OS.SendMessage(handle, OS.TCM_GETITEMCOUNT, 0, 0);\n        while (index < count) {\n            if (items[index].control == child)\n                break;\n            index++;\n        }\n        if (index == count) {\n            Rectangle rect = child.getBounds();\n            width = Math.max(width, rect.x + rect.width);\n            height = Math.max(height, rect.y + rect.height);\n        } else {\n            Point size = child.computeSize(wHint, hHint, flushCache);\n            width = Math.max(width, size.x);\n            height = Math.max(height, size.y);\n        }\n    }\n    return new Point(width, height);\n}",
			"comments":"",
			"methodName":"Point minimumSize(int wHint, int hHint, boolean flushCache)"
		},
		"public Rectangle computeTrim(int x, int y, int width, int height)":{
			"methodBody":"{\n    checkWidget();\n    RECT rect = new RECT();\n    OS.SetRect(rect, x, y, x + width, y + height);\n    OS.SendMessage(handle, OS.TCM_ADJUSTRECT, 1, rect);\n    int border = getBorderWidth();\n    rect.left -= border;\n    rect.right += border;\n    rect.top -= border;\n    rect.bottom += border;\n    int newWidth = rect.right - rect.left;\n    int newHeight = rect.bottom - rect.top;\n    return new Rectangle(rect.left, rect.top, newWidth, newHeight);\n}",
			"comments":"",
			"methodName":"public Rectangle computeTrim(int x, int y, int width, int height)"
		},
		"LRESULT WM_NOTIFY(int wParam, int lParam)":{
			"methodBody":"{\n    \n    LRESULT result = super.WM_NOTIFY(wParam, lParam);\n    if (result != null)\n        return result;\n    return LRESULT.ZERO;\n}",
			"comments":"/*\n* Feature in Windows.  When the tab folder window\n* proc processes WM_NOTIFY, it forwards this\n* message to its parent.  This is done so that\n* children of this control that send this message\n* type to their parent will notify not only\n* this control but also the parent of this control,\n* which is typically the application window and\n* the window that is looking for the message.\n* If the control did not forward the message,\n* applications would have to subclass the control\n* window to see the message. Because the control\n* window is subclassed by SWT, the message\n* is delivered twice, once by SWT and once when\n* the message is forwarded by the window proc.\n* The fix is to avoid calling the window proc\n* for this control.\n*/\n",
			"methodName":"LRESULT WM_NOTIFY(int wParam, int lParam)"
		},
		"public void setSelection(int index)":{
			"methodBody":"{\n    checkWidget();\n    int count = OS.SendMessage(handle, OS.TCM_GETITEMCOUNT, 0, 0);\n    if (!(0 <= index && index < count))\n        return;\n    setSelection(index, false);\n}",
			"comments":"/**\n* Selects the item at the given zero-relative index in the receiver.\n* If the item at the index was already selected, it remains selected.\n* The current selection is first cleared, then the new items are\n* selected. Indices that are out of range are ignored.\n*\n* @param index the index of the item to select\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setSelection(int index)"
		},
		"void removeControl(Control control)":{
			"methodBody":"{\n    super.removeControl(control);\n    int count = OS.SendMessage(handle, OS.TCM_GETITEMCOUNT, 0, 0);\n    for (int i = 0; i < count; i++) {\n        TabItem item = items[i];\n        if (item.control == control)\n            item.setControl(null);\n    }\n}",
			"comments":"",
			"methodName":"void removeControl(Control control)"
		},
		"static int checkStyle(int style)":{
			"methodBody":"{\n    style = checkBits(style, SWT.TOP, SWT.BOTTOM, 0, 0, 0, 0);\n    \n    if (OS.IsPPC) {\n        style |= SWT.BOTTOM;\n        style &= ~SWT.TOP;\n    }\n    \n    return style & ~(SWT.H_SCROLL | SWT.V_SCROLL);\n}",
			"comments":"/* Force tabs to be on the bottom for tab folders on PPC */\n/*\n* Even though it is legal to create this widget\n* with scroll bars, they serve no useful purpose\n* because they do not automatically scroll the\n* widget's client area.  The fix is to clear\n* the SWT style.\n*/\n",
			"methodName":"static int checkStyle(int style)"
		},
		"public void removeSelectionListener(SelectionListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.Selection, listener);\n    eventTable.unhook(SWT.DefaultSelection, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when the receiver's selection changes.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see SelectionListener\n* @see #addSelectionListener\n*/\n",
			"methodName":"public void removeSelectionListener(SelectionListener listener)"
		},
		"void createWidget()":{
			"methodBody":"{\n    super.createWidget();\n    items = new TabItem[4];\n}",
			"comments":"",
			"methodName":"void createWidget()"
		},
		"public Point computeSize(int wHint, int hHint, boolean changed)":{
			"methodBody":"{\n    checkWidget();\n    Point size = super.computeSize(wHint, hHint, changed);\n    RECT insetRect = new RECT(), itemRect = new RECT();\n    OS.SendMessage(handle, OS.TCM_ADJUSTRECT, 0, insetRect);\n    int width = insetRect.left - insetRect.right;\n    int count = OS.SendMessage(handle, OS.TCM_GETITEMCOUNT, 0, 0);\n    if (count != 0) {\n        OS.SendMessage(handle, OS.TCM_GETITEMRECT, count - 1, itemRect);\n        width = Math.max(width, itemRect.right - insetRect.right);\n    }\n    RECT rect = new RECT();\n    OS.SetRect(rect, 0, 0, width, size.y);\n    OS.SendMessage(handle, OS.TCM_ADJUSTRECT, 1, rect);\n    int border = getBorderWidth();\n    rect.left -= border;\n    rect.right += border;\n    width = rect.right - rect.left;\n    size.x = Math.max(width, size.x);\n    return size;\n}",
			"comments":"",
			"methodName":"public Point computeSize(int wHint, int hHint, boolean changed)"
		},
		"LRESULT WM_PARENTNOTIFY(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_PARENTNOTIFY(wParam, lParam);\n    if (result != null)\n        return result;\n    \n    if (OS.WIN32_VERSION < OS.VERSION(4, 10))\n        return result;\n    if ((style & SWT.RIGHT_TO_LEFT) != 0) {\n        int code = wParam & 0xFFFF;\n        switch(code) {\n            case OS.WM_CREATE:\n                {\n                    int id = (wParam >> 16), hwnd = lParam;\n                    if (id == ID_UPDOWN) {\n                        int bits = OS.GetWindowLong(hwnd, OS.GWL_EXSTYLE);\n                        OS.SetWindowLong(hwnd, OS.GWL_EXSTYLE, bits | OS.WS_EX_LAYOUTRTL);\n                    }\n                    break;\n                }\n        }\n    }\n    return result;\n}",
			"comments":"/*\n* Feature in Windows.  Windows does not explicitly set the orientation of\n* the buddy control.  Instead, the orientation is inherited when WS_EX_LAYOUTRTL\n* is specified for the tab folder.  This means that when both WS_EX_LAYOUTRTL\n* and WS_EX_NOINHERITLAYOUT are specified for the tab folder, the buddy control\n* will not be oriented correctly.  The fix is to explicitly set the orientation\n* for the buddy control.\n*\n* NOTE: WS_EX_LAYOUTRTL is not supported on Windows NT.\n*/\n",
			"methodName":"LRESULT WM_PARENTNOTIFY(int wParam, int lParam)"
		},
		"Control findThemeControl()":{
			"methodBody":"{\n    \n    return null;\n\n}",
			"comments":"// TEMPORARY CODE\n//return background == -1 ? this : null;\n",
			"methodName":"Control findThemeControl()"
		},
		"LRESULT WM_WINDOWPOSCHANGING(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_WINDOWPOSCHANGING(wParam, lParam);\n    if (result != null)\n        return result;\n    if (!OS.IsWindowVisible(handle))\n        return result;\n    WINDOWPOS lpwp = new WINDOWPOS();\n    OS.MoveMemory(lpwp, lParam, WINDOWPOS.sizeof);\n    if ((lpwp.flags & (OS.SWP_NOSIZE | OS.SWP_NOREDRAW)) != 0) {\n        return result;\n    }\n    \n    \n    \n    \n    \n    int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n    if ((bits & OS.TCS_MULTILINE) != 0) {\n        OS.InvalidateRect(handle, null, true);\n        return result;\n    }\n    RECT rect = new RECT();\n    OS.SetRect(rect, 0, 0, lpwp.cx, lpwp.cy);\n    OS.SendMessage(handle, OS.WM_NCCALCSIZE, 0, rect);\n    int newWidth = rect.right - rect.left;\n    int newHeight = rect.bottom - rect.top;\n    OS.GetClientRect(handle, rect);\n    int oldWidth = rect.right - rect.left;\n    int oldHeight = rect.bottom - rect.top;\n    if (newWidth == oldWidth && newHeight == oldHeight) {\n        return result;\n    }\n    RECT inset = new RECT();\n    OS.SendMessage(handle, OS.TCM_ADJUSTRECT, 0, inset);\n    int marginX = -inset.right, marginY = -inset.bottom;\n    if (newWidth != oldWidth) {\n        int left = oldWidth;\n        if (newWidth < oldWidth)\n            left = newWidth;\n        OS.SetRect(rect, left - marginX, 0, newWidth, newHeight);\n        OS.InvalidateRect(handle, rect, true);\n    }\n    if (newHeight != oldHeight) {\n        int bottom = oldHeight;\n        if (newHeight < oldHeight)\n            bottom = newHeight;\n        if (newWidth < oldWidth)\n            oldWidth -= marginX;\n        OS.SetRect(rect, 0, bottom - marginY, oldWidth, newHeight);\n        OS.InvalidateRect(handle, rect, true);\n    }\n    return result;\n}",
			"comments":"// TEMPORARY CODE\n//\tif (OS.COMCTL32_MAJOR >= 6 && OS.IsAppThemed ()) {\n//\t\tOS.InvalidateRect (handle, null, true);\n//\t\treturn result;\n//\t}\n",
			"methodName":"LRESULT WM_WINDOWPOSCHANGING(int wParam, int lParam)"
		},
		"TCHAR windowClass()":{
			"methodBody":"{\n    return TabFolderClass;\n}",
			"comments":"",
			"methodName":"TCHAR windowClass()"
		},
		"LRESULT WM_SIZE(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_SIZE(wParam, lParam);\n    \n    if (isDisposed())\n        return result;\n    int index = OS.SendMessage(handle, OS.TCM_GETCURSEL, 0, 0);\n    if (index != -1) {\n        TabItem item = items[index];\n        Control control = item.control;\n        if (control != null && !control.isDisposed()) {\n            control.setBounds(getClientArea());\n        }\n    }\n    return result;\n}",
			"comments":"/*\n* It is possible (but unlikely), that application\n* code could have disposed the widget in the resize\n* event.  If this happens, end the processing of the\n* Windows message by returning the result of the\n* WM_SIZE message.\n*/\n",
			"methodName":"LRESULT WM_SIZE(int wParam, int lParam)"
		},
		"public TabItem getItem(int index)":{
			"methodBody":"{\n    checkWidget();\n    int count = OS.SendMessage(handle, OS.TCM_GETITEMCOUNT, 0, 0);\n    if (!(0 <= index && index < count))\n        error(SWT.ERROR_INVALID_RANGE);\n    return items[index];\n}",
			"comments":"/**\n* Returns the item at the given, zero-relative index in the\n* receiver. Throws an exception if the index is out of range.\n*\n* @param index the index of the item to return\n* @return the item at the given index\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_RANGE - if the index is not between 0 and the number of elements in the list minus 1 (inclusive)</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public TabItem getItem(int index)"
		},
		"void createHandle()":{
			"methodBody":"{\n    super.createHandle();\n    \n    if (OS.IsPPC) {\n        OS.SendMessage(handle, OS.CCM_SETVERSION, 0x020c, \n        0);\n    }\n    state &= ~CANVAS;\n    \n    int hwndToolTip = OS.SendMessage(handle, OS.TCM_GETTOOLTIPS, 0, 0);\n    OS.SendMessage(hwndToolTip, OS.TTM_SETMAXTIPWIDTH, 0, 0x7FFF);\n}",
			"comments":"/* Enable the flat look for tab folders on PPC */\n/*COMCTL32_VERSION*/\n/*\n* Feature in Windows.  Despite the fact that the\n* tool tip text contains \\r\\n, the tooltip will\n* not honour the new line unless TTM_SETMAXTIPWIDTH\n* is set.  The fix is to set TTM_SETMAXTIPWIDTH to\n* a large value.\n*/\n",
			"methodName":"void createHandle()"
		},
		"int imageIndex(Image image)":{
			"methodBody":"{\n    if (image == null)\n        return OS.I_IMAGENONE;\n    if (imageList == null) {\n        Rectangle bounds = image.getBounds();\n        imageList = display.getImageList(style & SWT.RIGHT_TO_LEFT, bounds.width, bounds.height);\n        int hImageList = imageList.getHandle();\n        OS.SendMessage(handle, OS.TCM_SETIMAGELIST, 0, hImageList);\n    }\n    int index = imageList.indexOf(image);\n    if (index == -1) {\n        index = imageList.add(image);\n    } else {\n        imageList.put(index, image);\n    }\n    return index;\n}",
			"comments":"",
			"methodName":"int imageIndex(Image image)"
		},
		"void drawThemeBackground(int hDC, RECT rect)":{
			"methodBody":"{\n    int hTheme = OS.OpenThemeData(handle, TAB);\n    OS.DrawThemeBackground(hTheme, hDC, OS.TABP_BODY, 0, rect, null);\n    OS.CloseThemeData(hTheme);\n}",
			"comments":"",
			"methodName":"void drawThemeBackground(int hDC, RECT rect)"
		},
		"public TabItem[] getSelection()":{
			"methodBody":"{\n    checkWidget();\n    int index = OS.SendMessage(handle, OS.TCM_GETCURSEL, 0, 0);\n    if (index == -1)\n        return new TabItem[0];\n    return new TabItem[] { items[index] };\n}",
			"comments":"/**\n* Returns an array of <code>TabItem</code>s that are currently\n* selected in the receiver. An empty array indicates that no\n* items are selected.\n* <p>\n* Note: This is not the actual structure used by the receiver\n* to maintain its selection, so modifying the array will\n* not affect the receiver.\n* </p>\n* @return an array representing the selection\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public TabItem[] getSelection()"
		},
		"public int indexOf(TabItem item)":{
			"methodBody":"{\n    checkWidget();\n    if (item == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    int count = OS.SendMessage(handle, OS.TCM_GETITEMCOUNT, 0, 0);\n    for (int i = 0; i < count; i++) {\n        if (items[i] == item)\n            return i;\n    }\n    return -1;\n}",
			"comments":"/**\n* Searches the receiver's list starting at the first item\n* (index 0) until an item is found that is equal to the\n* argument, and returns the index of that item. If no item\n* is found, returns -1.\n*\n* @param item the search item\n* @return the index of the item\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the string is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int indexOf(TabItem item)"
		},
		"public void setSelection(TabItem[] items)":{
			"methodBody":"{\n    checkWidget();\n    if (items == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (items.length == 0) {\n        setSelection(-1, false);\n    } else {\n        for (int i = items.length - 1; i >= 0; --i) {\n            int index = indexOf(items[i]);\n            if (index != -1)\n                setSelection(index, false);\n        }\n    }\n}",
			"comments":"/**\n* Sets the receiver's selection to be the given array of items.\n* The current selected is first cleared, then the new items are\n* selected.\n*\n* @param items the array of items\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the items array is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setSelection(TabItem[] items)"
		},
		"String toolTipText(NMTTDISPINFO hdr)":{
			"methodBody":"{\n    if ((hdr.uFlags & OS.TTF_IDISHWND) != 0) {\n        return null;\n    }\n    int index = hdr.idFrom;\n    int hwndToolTip = OS.SendMessage(handle, OS.TCM_GETTOOLTIPS, 0, 0);\n    if (hwndToolTip == hdr.hwndFrom) {\n        if (toolTipText != null)\n            return \"\";\n        if (0 <= index && index < items.length) {\n            TabItem item = items[index];\n            if (item != null)\n                return item.toolTipText;\n        }\n    }\n    return super.toolTipText(hdr);\n}",
			"comments":"",
			"methodName":"String toolTipText(NMTTDISPINFO hdr)"
		},
		"void createItem(TabItem item, int index)":{
			"methodBody":"{\n    int count = OS.SendMessage(handle, OS.TCM_GETITEMCOUNT, 0, 0);\n    if (!(0 <= index && index <= count))\n        error(SWT.ERROR_INVALID_RANGE);\n    if (count == items.length) {\n        TabItem[] newItems = new TabItem[items.length + 4];\n        System.arraycopy(items, 0, newItems, 0, items.length);\n        items = newItems;\n    }\n    TCITEM tcItem = new TCITEM();\n    if (OS.SendMessage(handle, OS.TCM_INSERTITEM, index, tcItem) == -1) {\n        error(SWT.ERROR_ITEM_NOT_ADDED);\n    }\n    System.arraycopy(items, index, items, index + 1, count - index);\n    items[index] = item;\n    \n    if (count == 0) {\n        Event event = new Event();\n        event.item = items[0];\n        sendEvent(SWT.Selection, event);\n    \n    }\n}",
			"comments":"/*\n* Send a selection event when the item that is added becomes\n* the new selection.  This only happens when the first item\n* is added.\n*/\n// the widget could be destroyed at this point\n",
			"methodName":"void createItem(TabItem item, int index)"
		},
		"void releaseWidget()":{
			"methodBody":"{\n    int count = OS.SendMessage(handle, OS.TCM_GETITEMCOUNT, 0, 0);\n    for (int i = 0; i < count; i++) {\n        TabItem item = items[i];\n        if (!item.isDisposed())\n            item.releaseResources();\n    }\n    items = null;\n    if (imageList != null) {\n        OS.SendMessage(handle, OS.TCM_SETIMAGELIST, 0, 0);\n        display.releaseImageList(imageList);\n    }\n    imageList = null;\n    super.releaseWidget();\n}",
			"comments":"",
			"methodName":"void releaseWidget()"
		},
		"LRESULT WM_GETDLGCODE(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_GETDLGCODE(wParam, lParam);\n    \n    if (result != null)\n        return result;\n    return new LRESULT(OS.DLGC_BUTTON);\n}",
			"comments":"/*\n* Return DLGC_BUTTON so that mnemonics will be\n* processed without needing to press the ALT key\n* when the widget has focus.\n*/\n",
			"methodName":"LRESULT WM_GETDLGCODE(int wParam, int lParam)"
		},
		"public TabItem[] getItems()":{
			"methodBody":"{\n    checkWidget();\n    int count = OS.SendMessage(handle, OS.TCM_GETITEMCOUNT, 0, 0);\n    TabItem[] result = new TabItem[count];\n    System.arraycopy(items, 0, result, 0, count);\n    return result;\n}",
			"comments":"/**\n* Returns an array of <code>TabItem</code>s which are the items\n* in the receiver.\n* <p>\n* Note: This is not the actual structure used by the receiver\n* to maintain its list of items, so modifying the array will\n* not affect the receiver.\n* </p>\n*\n* @return the items in the receiver\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public TabItem[] getItems()"
		},
		"public int getSelectionIndex()":{
			"methodBody":"{\n    checkWidget();\n    return OS.SendMessage(handle, OS.TCM_GETCURSEL, 0, 0);\n}",
			"comments":"/**\n* Returns the zero-relative index of the item which is currently\n* selected in the receiver, or -1 if no item is selected.\n*\n* @return the index of the selected item\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getSelectionIndex()"
		},
		"int windowProc()":{
			"methodBody":"{\n    return TabFolderProc;\n}",
			"comments":"",
			"methodName":"int windowProc()"
		},
		"public void addSelectionListener(SelectionListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.Selection, typedListener);\n    addListener(SWT.DefaultSelection, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when the receiver's selection changes, by sending\n* it one of the messages defined in the <code>SelectionListener</code>\n* interface.\n* <p>\n* When <code>widgetSelected</code> is called, the item field of the event object is valid.\n* <code>widgetDefaultSelected</code> is not called.\n* </p>\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see SelectionListener\n* @see #removeSelectionListener\n* @see SelectionEvent\n*/\n",
			"methodName":"public void addSelectionListener(SelectionListener listener)"
		},
		"int callWindowProc(int hwnd, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    if (handle == 0)\n        return 0;\n    return OS.CallWindowProc(TabFolderProc, hwnd, msg, wParam, lParam);\n}",
			"comments":"",
			"methodName":"int callWindowProc(int hwnd, int msg, int wParam, int lParam)"
		},
		"int widgetStyle()":{
			"methodBody":"{\n    \n    int bits = super.widgetStyle() | OS.WS_CLIPCHILDREN;\n    if ((style & SWT.NO_FOCUS) != 0)\n        bits |= OS.TCS_FOCUSNEVER;\n    if ((style & SWT.BOTTOM) != 0)\n        bits |= OS.TCS_BOTTOM;\n    return bits | OS.TCS_TABS | OS.TCS_TOOLTIPS;\n}",
			"comments":"/*\n* Bug in Windows.  Under certain circumstances,\n* when TCM_SETITEM is used to change the text\n* in a tab item, the tab folder draws on top\n* of the client area.  The fix is ensure that\n* this cannot happen by setting WS_CLIPCHILDREN.\n*/\n",
			"methodName":"int widgetStyle()"
		},
		"public int getItemCount()":{
			"methodBody":"{\n    checkWidget();\n    return OS.SendMessage(handle, OS.TCM_GETITEMCOUNT, 0, 0);\n}",
			"comments":"/**\n* Returns the number of items contained in the receiver.\n*\n* @return the number of items\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getItemCount()"
		},
		"boolean traversePage(boolean next)":{
			"methodBody":"{\n    int count = getItemCount();\n    if (count <= 1)\n        return false;\n    int index = getSelectionIndex();\n    if (index == -1) {\n        index = 0;\n    } else {\n        int offset = (next) ? 1 : -1;\n        index = (index + offset + count) % count;\n    }\n    setSelection(index, true);\n    return index == getSelectionIndex();\n}",
			"comments":"",
			"methodName":"boolean traversePage(boolean next)"
		}
	},
	"ClassORInterfaceName":[
		"TabFolder"
	]
}
