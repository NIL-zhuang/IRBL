{
	"variables":[
		"FORMAT_PACKAGE",
		"FORMAT_SUFFIX",
		"FORMATS",
		"inputStream",
		"outputStream",
		"loader",
		"compression",
		"i",
		"fileFormat",
		"stream",
		"isSupported",
		"i",
		"clazz",
		"data",
		"stream",
		"fileFormat",
		"clazz",
		"startIndex",
		"i",
		"endIndex",
		"i",
		"data",
		"i",
		"data",
		"i",
		"startIndex",
		"data",
		"inputStream",
		"stream",
		"SWT",
		"SWT",
		"e",
		"is",
		"i",
		"FORMATS",
		"i",
		"FORMATS",
		"i",
		"Class",
		"FORMAT_PACKAGE",
		"FORMATS",
		"i",
		"FORMAT_SUFFIX",
		"fileFormat",
		"clazz",
		"fileFormat",
		"stream",
		"isSupported",
		"FORMATS",
		"i",
		"isSupported",
		"SWT",
		"SWT",
		"fileFormat",
		"loader",
		"fileFormat",
		"stream",
		"format",
		"format",
		"FORMATS",
		"SWT",
		"SWT",
		"FORMATS",
		"format",
		"SWT",
		"SWT",
		"loader",
		"os",
		"Class",
		"FORMAT_PACKAGE",
		"FORMATS",
		"format",
		"FORMAT_SUFFIX",
		"fileFormat",
		"clazz",
		"SWT",
		"SWT",
		"format",
		"SWT",
		"data",
		"fileFormat",
		"fileFormat",
		"fileFormat",
		"data",
		"stream",
		"outputStream",
		"stream",
		"image",
		"outputStream",
		"outputStream",
		"SWT",
		"SWT",
		"e",
		"ERROR_IO",
		"length",
		"ERROR_UNSUPPORTED_FORMAT",
		"loader",
		"length",
		"ERROR_UNSUPPORTED_FORMAT",
		"ERROR_UNSUPPORTED_FORMAT",
		"data",
		"ERROR_UNSUPPORTED_FORMAT",
		"IMAGE_BMP_RLE",
		"depth",
		"compression",
		"compression",
		"ERROR_IO",
		"data",
		"startIndex",
		"endIndex",
		"stream",
		"stream",
		"e",
		"is",
		"loader",
		"e",
		"e",
		"os",
		"format",
		"loader",
		"e",
		"image",
		"image",
		"stream",
		"e",
		"f"
	],
	"extendORImplementFiles":[],
	"package":[
		"org.eclipse.swt.internal.image"
	],
	"import":[
		"java.io",
		"org.eclipse.swt",
		"org.eclipse.swt.graphics"
	],
	"methods":[
		"bitInvertData",
		"isFileFormat",
		"loadFromByteStream",
		"loadFromStream",
		"load",
		"save",
		"unloadIntoByteStream",
		"unloadIntoStream",
		"loadFromByteStream",
		"error",
		"forName",
		"newInstance",
		"isFileFormat",
		"error",
		"loadFromStream",
		"error",
		"error",
		"forName",
		"newInstance",
		"error",
		"unloadIntoStream",
		"unloadIntoByteStream",
		"close",
		"close",
		"error",
		"LEDataInputStream",
		"LEDataOutputStream"
	],
	"methodsBody":{
		"abstract void unloadIntoByteStream(ImageData image)":{
			"methodBody":"",
			"comments":"",
			"methodName":"abstract void unloadIntoByteStream(ImageData image)"
		},
		"public void unloadIntoStream(ImageData image, LEDataOutputStream stream)":{
			"methodBody":"{\n    try {\n        outputStream = stream;\n        unloadIntoByteStream(image);\n        outputStream.close();\n    } catch (Exception e) {\n        try {\n            outputStream.close();\n        } catch (Exception f) {\n        }\n        SWT.error(SWT.ERROR_IO, e);\n    }\n}",
			"comments":"",
			"methodName":"public void unloadIntoStream(ImageData image, LEDataOutputStream stream)"
		},
		"public static void save(OutputStream os, int format, ImageLoader loader)":{
			"methodBody":"{\n    if (format < 0 || format >= FORMATS.length)\n        SWT.error(SWT.ERROR_UNSUPPORTED_FORMAT);\n    if (FORMATS[format] == null)\n        SWT.error(SWT.ERROR_UNSUPPORTED_FORMAT);\n    \n    ImageData data = loader.data[0];\n    LEDataOutputStream stream = new LEDataOutputStream(os);\n    FileFormat fileFormat = null;\n    try {\n        Class clazz = Class.forName(FORMAT_PACKAGE + '.' + FORMATS[format] + FORMAT_SUFFIX);\n        fileFormat = (FileFormat) clazz.newInstance();\n    } catch (Exception e) {\n        SWT.error(SWT.ERROR_UNSUPPORTED_FORMAT);\n    }\n    if (format == SWT.IMAGE_BMP_RLE) {\n        switch(data.depth) {\n            case 8:\n                fileFormat.compression = 1;\n                break;\n            case 4:\n                fileFormat.compression = 2;\n                break;\n        }\n    }\n    fileFormat.unloadIntoStream(data, stream);\n}",
			"comments":"/* We do not currently support writing multi-image files,\n* so we use the first image data in the loader's array. */\n",
			"methodName":"public static void save(OutputStream os, int format, ImageLoader loader)"
		},
		"public ImageData[] loadFromStream(LEDataInputStream stream)":{
			"methodBody":"{\n    try {\n        inputStream = stream;\n        return loadFromByteStream();\n    } catch (Exception e) {\n        SWT.error(SWT.ERROR_IO, e);\n        return null;\n    }\n}",
			"comments":"",
			"methodName":"public ImageData[] loadFromStream(LEDataInputStream stream)"
		},
		"abstract ImageData[] loadFromByteStream()":{
			"methodBody":"",
			"comments":"",
			"methodName":"abstract ImageData[] loadFromByteStream()"
		},
		"public static ImageData[] load(InputStream is, ImageLoader loader)":{
			"methodBody":"{\n    FileFormat fileFormat = null;\n    LEDataInputStream stream = new LEDataInputStream(is);\n    boolean isSupported = false;\n    for (int i = 1; i < FORMATS.length; i++) {\n        if (FORMATS[i] != null) {\n            try {\n                Class clazz = Class.forName(FORMAT_PACKAGE + '.' + FORMATS[i] + FORMAT_SUFFIX);\n                fileFormat = (FileFormat) clazz.newInstance();\n                if (fileFormat.isFileFormat(stream)) {\n                    isSupported = true;\n                    break;\n                }\n            } catch (ClassNotFoundException e) {\n                FORMATS[i] = null;\n            } catch (Exception e) {\n            }\n        }\n    }\n    if (!isSupported)\n        SWT.error(SWT.ERROR_UNSUPPORTED_FORMAT);\n    fileFormat.loader = loader;\n    return fileFormat.loadFromStream(stream);\n}",
			"comments":"",
			"methodName":"public static ImageData[] load(InputStream is, ImageLoader loader)"
		},
		"byte[] bitInvertData(byte[] data, int startIndex, int endIndex)":{
			"methodBody":"{\n    \n    for (int i = startIndex; i < endIndex; i++) {\n        data[i] = (byte) (255 - data[i - startIndex]);\n    }\n    return data;\n}",
			"comments":"// Destructively bit invert data in the given byte array.\n",
			"methodName":"byte[] bitInvertData(byte[] data, int startIndex, int endIndex)"
		},
		"abstract boolean isFileFormat(LEDataInputStream stream)":{
			"methodBody":"",
			"comments":"/**\n* Return whether or not the specified input stream\n* represents a supported file format.\n*/\n",
			"methodName":"abstract boolean isFileFormat(LEDataInputStream stream)"
		}
	},
	"ClassORInterfaceName":[
		"FileFormat"
	]
}
