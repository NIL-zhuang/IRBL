{
	"variables":[
		"bitsPerPixel",
		"blockSize",
		"blockIndex",
		"currentByte",
		"bitsLeft",
		"codeSize",
		"clearCode",
		"endCode",
		"newCodes",
		"topSlot",
		"currentSlot",
		"imageWidth",
		"imageHeight",
		"imageX",
		"imageY",
		"pass",
		"line",
		"codeMask",
		"block",
		"lineArray",
		"stack",
		"suffix",
		"prefix",
		"nodeStack",
		"inputStream",
		"outputStream",
		"image",
		"loader",
		"interlaced",
		"MASK_TABLE",
		"code",
		"oc",
		"fc",
		"buf",
		"stackIndex",
		"bufIndex",
		"c",
		"lastPrefix",
		"pixel",
		"found",
		"node",
		"currentPrefix",
		"i",
		"i",
		"node",
		"code",
		"shift",
		"codeToDo",
		"codeBitsToDo",
		"c",
		"start",
		"i",
		"imageCopy",
		"i",
		"size",
		"imageWidth",
		"c",
		"endCode",
		"c",
		"clearCode",
		"codeSize",
		"bitsPerPixel",
		"codeMask",
		"MASK_TABLE",
		"bitsPerPixel",
		"currentSlot",
		"newCodes",
		"topSlot",
		"codeSize",
		"c",
		"clearCode",
		"c",
		"endCode",
		"oc",
		"fc",
		"c",
		"buf",
		"bufIndex",
		"c",
		"bufIndex",
		"bufIndex",
		"imageWidth",
		"buf",
		"bufIndex",
		"code",
		"c",
		"code",
		"currentSlot",
		"code",
		"currentSlot",
		"SWT",
		"SWT",
		"code",
		"oc",
		"stack",
		"stackIndex",
		"fc",
		"stackIndex",
		"code",
		"newCodes",
		"stack",
		"stackIndex",
		"suffix",
		"code",
		"stackIndex",
		"code",
		"prefix",
		"code",
		"stack",
		"stackIndex",
		"code",
		"stackIndex",
		"currentSlot",
		"topSlot",
		"fc",
		"code",
		"suffix",
		"currentSlot",
		"fc",
		"prefix",
		"currentSlot",
		"oc",
		"currentSlot",
		"oc",
		"c",
		"currentSlot",
		"topSlot",
		"codeSize",
		"codeMask",
		"MASK_TABLE",
		"codeSize",
		"codeSize",
		"topSlot",
		"topSlot",
		"topSlot",
		"stackIndex",
		"stackIndex",
		"buf",
		"bufIndex",
		"stack",
		"stackIndex",
		"bufIndex",
		"bufIndex",
		"imageWidth",
		"buf",
		"bufIndex",
		"bufIndex",
		"line",
		"imageHeight",
		"buf",
		"inputStream",
		"loader",
		"image",
		"interlaced",
		"depth",
		"clearCode",
		"lastPrefix",
		"endCode",
		"bitsLeft",
		"block",
		"blockIndex",
		"block",
		"blockIndex",
		"block",
		"block",
		"byteStream",
		"image",
		"pixel",
		"node",
		"nodeStack",
		"currentPrefix",
		"found",
		"pixel",
		"pixel",
		"currentPrefix",
		"found",
		"node",
		"node",
		"node",
		"found",
		"node",
		"pixel",
		"pixel",
		"node",
		"node",
		"node",
		"found",
		"node",
		"node",
		"node",
		"node",
		"found",
		"node",
		"node",
		"found",
		"currentPrefix",
		"node",
		"pixel",
		"pixel",
		"currentPrefix",
		"found",
		"node",
		"node",
		"node",
		"node",
		"node",
		"node",
		"node",
		"currentSlot",
		"node",
		"currentPrefix",
		"node",
		"pixel",
		"currentPrefix",
		"currentSlot",
		"currentSlot",
		"currentSlot",
		"topSlot",
		"codeSize",
		"codeMask",
		"MASK_TABLE",
		"codeSize",
		"topSlot",
		"clearCode",
		"i",
		"nodeStack",
		"i",
		"nodeStack",
		"i",
		"codeSize",
		"bitsPerPixel",
		"codeMask",
		"MASK_TABLE",
		"codeSize",
		"currentSlot",
		"newCodes",
		"topSlot",
		"codeSize",
		"pass",
		"line",
		"codeSize",
		"bitsPerPixel",
		"topSlot",
		"codeSize",
		"clearCode",
		"bitsPerPixel",
		"endCode",
		"clearCode",
		"newCodes",
		"currentSlot",
		"endCode",
		"currentByte",
		"blockSize",
		"bitsLeft",
		"blockIndex",
		"codeMask",
		"MASK_TABLE",
		"codeSize",
		"stack",
		"suffix",
		"prefix",
		"block",
		"imageWidth",
		"image",
		"imageHeight",
		"image",
		"interlaced",
		"bitsPerPixel",
		"image",
		"codeSize",
		"bitsPerPixel",
		"topSlot",
		"codeSize",
		"clearCode",
		"bitsPerPixel",
		"endCode",
		"clearCode",
		"newCodes",
		"currentSlot",
		"endCode",
		"bitsLeft",
		"currentByte",
		"blockIndex",
		"blockSize",
		"block",
		"blockSize",
		"block",
		"blockSize",
		"nodeStack",
		"bitsPerPixel",
		"i",
		"nodeStack",
		"i",
		"node",
		"i",
		"node",
		"node",
		"i",
		"nodeStack",
		"i",
		"node",
		"imageWidth",
		"image",
		"imageHeight",
		"image",
		"imageY",
		"lineArray",
		"imageWidth",
		"imageX",
		"imageWidth",
		"bitsLeft",
		"blockIndex",
		"blockSize",
		"blockSize",
		"blockIndex",
		"blockSize",
		"endCode",
		"blockIndex",
		"currentByte",
		"block",
		"blockIndex",
		"bitsLeft",
		"code",
		"currentByte",
		"bitsLeft",
		"shift",
		"code",
		"currentByte",
		"shift",
		"code",
		"currentByte",
		"shift",
		"codeSize",
		"bitsLeft",
		"blockIndex",
		"blockSize",
		"blockSize",
		"blockIndex",
		"blockSize",
		"endCode",
		"blockIndex",
		"currentByte",
		"block",
		"blockIndex",
		"code",
		"currentByte",
		"bitsLeft",
		"bitsLeft",
		"bitsLeft",
		"codeSize",
		"code",
		"codeMask",
		"imageX",
		"imageX",
		"imageWidth",
		"imageY",
		"imageY",
		"imageHeight",
		"lineArray",
		"imageWidth",
		"imageX",
		"imageX",
		"image",
		"System",
		"image",
		"imageY",
		"image",
		"buf",
		"lineWidth",
		"image",
		"imageY",
		"lineWidth",
		"buf",
		"aCode",
		"codeSize",
		"codeToDo",
		"MASK_TABLE",
		"bitsLeft",
		"currentByte",
		"currentByte",
		"c",
		"bitsLeft",
		"block",
		"blockIndex",
		"currentByte",
		"codeBitsToDo",
		"bitsLeft",
		"codeBitsToDo",
		"bitsLeft",
		"codeSize",
		"bitsLeft",
		"bitsLeft",
		"blockIndex",
		"blockIndex",
		"blockSize",
		"blockIndex",
		"currentByte",
		"codeToDo",
		"codeToDo",
		"bitsLeft",
		"blockIndex",
		"blockIndex",
		"blockSize",
		"blockIndex",
		"codeBitsToDo",
		"currentByte",
		"codeToDo",
		"block",
		"blockIndex",
		"currentByte",
		"codeToDo",
		"codeToDo",
		"codeBitsToDo",
		"blockIndex",
		"blockIndex",
		"blockSize",
		"blockIndex",
		"bitsLeft",
		"codeBitsToDo",
		"currentByte",
		"codeToDo",
		"block",
		"blockIndex",
		"currentByte",
		"image",
		"line",
		"image",
		"i",
		"imageWidth",
		"i",
		"image",
		"start",
		"i",
		"buf",
		"i",
		"image",
		"line",
		"imageWidth",
		"buf",
		"interlaced",
		"pass",
		"buf",
		"line",
		"pass",
		"buf",
		"line",
		"pass",
		"buf",
		"line",
		"pass",
		"line",
		"pass",
		"line",
		"line",
		"imageHeight",
		"pass",
		"pass",
		"line",
		"pass",
		"line",
		"pass",
		"line",
		"pass",
		"line",
		"pass",
		"loader",
		"image",
		"loader",
		"loader",
		"imageCopy",
		"pass",
		"line",
		"imageHeight",
		"line",
		"line",
		"i",
		"copies",
		"i",
		"line",
		"i",
		"imageHeight",
		"image",
		"line",
		"i",
		"imageWidth",
		"buf",
		"size",
		"inputStream",
		"size",
		"SWT",
		"SWT",
		"block",
		"size",
		"size",
		"inputStream",
		"block",
		"size",
		"size",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"e",
		"size",
		"outputStream",
		"block",
		"block",
		"SWT",
		"SWT",
		"e",
		"ERROR_INVALID_IMAGE",
		"inputStream",
		"loader",
		"image",
		"interlaced",
		"bitsPerPixel",
		"outputStream",
		"image",
		"children",
		"children",
		"suffix",
		"suffix",
		"left",
		"left",
		"left",
		"right",
		"right",
		"right",
		"code",
		"children",
		"children",
		"children",
		"left",
		"right",
		"code",
		"prefix",
		"suffix",
		"length",
		"children",
		"width",
		"height",
		"depth",
		"length",
		"code",
		"prefix",
		"suffix",
		"width",
		"height",
		"lineArray",
		"depth",
		"data",
		"bytesPerLine",
		"depth",
		"bytesPerLine",
		"data",
		"ERROR_INVALID_IMAGE",
		"ERROR_INVALID_IMAGE",
		"ERROR_IO",
		"ERROR_IO",
		"inputStream",
		"loader",
		"image",
		"interlaced",
		"depth",
		"byteStream",
		"image",
		"buf",
		"lineWidth",
		"aCode",
		"buf",
		"buf",
		"copies",
		"e",
		"e"
	],
	"extendORImplementFiles":[],
	"package":[
		"org.eclipse.swt.internal.image"
	],
	"import":[
		"org.eclipse.swt",
		"org.eclipse.swt.graphics"
	],
	"methods":[
		"decode",
		"decode",
		"encode",
		"encode",
		"encodeLoop",
		"initializeForDecoding",
		"initializeForEncoding",
		"nextCode",
		"nextPixel",
		"nextPixels",
		"nextPutCode",
		"nextPutPixels",
		"copyRow",
		"readBlock",
		"writeBlock",
		"nextCode",
		"nextCode",
		"nextPutPixels",
		"error",
		"nextPutPixels",
		"nextPutPixels",
		"initializeForDecoding",
		"decode",
		"nextPutCode",
		"encodeLoop",
		"nextPutCode",
		"nextPutCode",
		"writeBlock",
		"writeBlock",
		"initializeForEncoding",
		"encode",
		"nextPixel",
		"nextPixel",
		"nextPixel",
		"nextPutCode",
		"nextPutCode",
		"readBlock",
		"readBlock",
		"nextPixels",
		"arraycopy",
		"getPixels",
		"writeBlock",
		"writeBlock",
		"writeBlock",
		"setPixels",
		"copyRow",
		"copyRow",
		"copyRow",
		"hasListeners",
		"clone",
		"notifyListeners",
		"setPixels",
		"read",
		"error",
		"read",
		"error",
		"error",
		"write",
		"error",
		"LZWNode",
		"LZWNode",
		"LZWNode",
		"LZWNode",
		"ImageLoaderEvent"
	],
	"methodsBody":{
		"int nextPixel()":{
			"methodBody":"{\n    imageX++;\n    if (imageX > imageWidth) {\n        imageY++;\n        if (imageY >= imageHeight) {\n            return -1;\n        } else {\n            nextPixels(lineArray, imageWidth);\n        }\n        imageX = 1;\n    }\n    return this.lineArray[imageX - 1] & 0xFF;\n}",
			"comments":"/**\n* Answer the next pixel to encode in the image\n*/\n",
			"methodName":"int nextPixel()"
		},
		"int readBlock()":{
			"methodBody":"{\n    int size = -1;\n    try {\n        size = inputStream.read();\n        if (size == -1) {\n            SWT.error(SWT.ERROR_INVALID_IMAGE);\n        }\n        block[0] = (byte) size;\n        size = inputStream.read(block, 1, size);\n        if (size == -1) {\n            SWT.error(SWT.ERROR_INVALID_IMAGE);\n        }\n    } catch (Exception e) {\n        SWT.error(SWT.ERROR_IO, e);\n    }\n    return size;\n}",
			"comments":"/**\n* Read a block from the byte stream.\n* Return the number of bytes read.\n* Throw an exception if the block could not be read.\n*/\n",
			"methodName":"int readBlock()"
		},
		"void decode()":{
			"methodBody":"{\n    int code;\n    int oc = 0;\n    int fc = 0;\n    byte[] buf = new byte[imageWidth];\n    int stackIndex = 0;\n    int bufIndex = 0;\n    int c;\n    while ((c = nextCode()) != endCode) {\n        if (c == clearCode) {\n            codeSize = bitsPerPixel + 1;\n            codeMask = MASK_TABLE[bitsPerPixel];\n            currentSlot = newCodes;\n            topSlot = 1 << codeSize;\n            while ((c = nextCode()) == clearCode) {\n            }\n            if (c != endCode) {\n                oc = fc = c;\n                buf[bufIndex] = (byte) c;\n                bufIndex++;\n                if (bufIndex == imageWidth) {\n                    nextPutPixels(buf);\n                    bufIndex = 0;\n                }\n            }\n        } else {\n            code = c;\n            if (code >= currentSlot) {\n                if (code > currentSlot)\n                    SWT.error(SWT.ERROR_INVALID_IMAGE);\n                code = oc;\n                stack[stackIndex] = fc;\n                stackIndex++;\n            }\n            while (code >= newCodes) {\n                stack[stackIndex] = suffix[code];\n                stackIndex++;\n                code = prefix[code];\n            }\n            stack[stackIndex] = code;\n            stackIndex++;\n            if (currentSlot < topSlot) {\n                fc = code;\n                suffix[currentSlot] = fc;\n                prefix[currentSlot] = oc;\n                currentSlot++;\n                oc = c;\n            }\n            if (currentSlot >= topSlot) {\n                if (codeSize < 12) {\n                    codeMask = MASK_TABLE[codeSize];\n                    codeSize++;\n                    topSlot = topSlot + topSlot;\n                }\n            }\n            while (stackIndex > 0) {\n                stackIndex--;\n                buf[bufIndex] = (byte) stack[stackIndex];\n                bufIndex++;\n                if (bufIndex == imageWidth) {\n                    nextPutPixels(buf);\n                    bufIndex = 0;\n                }\n            }\n        }\n    }\n    if (bufIndex != 0 && line < imageHeight) {\n        nextPutPixels(buf);\n    }\n}",
			"comments":"/**\n* Decode the input.\n*/\n",
			"methodName":"void decode()"
		},
		"void copyRow(byte[] buf, int copies)":{
			"methodBody":"{\n    for (int i = 1; i <= copies; i++) {\n        if (line + i < imageHeight) {\n            image.setPixels(0, line + i, imageWidth, buf, 0);\n        }\n    }\n}",
			"comments":"/**\n* Copy duplicate rows of pixel values to the image.\n* This is to fill in rows if the image is interlaced.\n*/\n",
			"methodName":"void copyRow(byte[] buf, int copies)"
		},
		"public void decode(LEDataInputStream inputStream, ImageLoader loader, ImageData image, boolean interlaced, int depth)":{
			"methodBody":"{\n    this.inputStream = inputStream;\n    this.loader = loader;\n    this.image = image;\n    this.interlaced = interlaced;\n    this.bitsPerPixel = depth;\n    initializeForDecoding();\n    decode();\n}",
			"comments":"/**\n* Decode the LZW-encoded bytes in the given byte stream\n* into the given DeviceIndependentImage.\n*/\n",
			"methodName":"public void decode(LEDataInputStream inputStream, ImageLoader loader, ImageData image, boolean interlaced, int depth)"
		},
		"void nextPixels(byte[] buf, int lineWidth)":{
			"methodBody":"{\n    if (image.depth == 8) {\n        System.arraycopy(image.data, imageY * image.bytesPerLine, buf, 0, lineWidth);\n    } else {\n        image.getPixels(0, imageY, lineWidth, buf, 0);\n    }\n}",
			"comments":"/**\n* Copy a row of pixel values from the image.\n*/\n",
			"methodName":"void nextPixels(byte[] buf, int lineWidth)"
		},
		"void encode()":{
			"methodBody":"{\n    nextPutCode(clearCode);\n    int lastPrefix = encodeLoop();\n    nextPutCode(lastPrefix);\n    nextPutCode(endCode);\n    \n    if (bitsLeft == 8) {\n        \n        block[0] = (byte) (blockIndex - 1);\n    } else {\n        \n        block[0] = (byte) (blockIndex);\n    }\n    writeBlock();\n    \n    if (block[0] != 0) {\n        block[0] = 0;\n        writeBlock();\n    }\n}",
			"comments":"/**\n* Encode the image.\n*/\n// Write out last partial block\n// Nothing in last byte\n// Last byte has data\n// Write out empty block to indicate the end (if needed)\n",
			"methodName":"void encode()"
		},
		"int nextCode()":{
			"methodBody":"{\n    int code;\n    if (bitsLeft == 0) {\n        if (blockIndex >= blockSize) {\n            blockSize = readBlock();\n            blockIndex = 0;\n            if (blockSize == 0)\n                return endCode;\n        }\n        blockIndex++;\n        currentByte = block[blockIndex] & 0xFF;\n        bitsLeft = 8;\n        code = currentByte;\n    } else {\n        int shift = bitsLeft - 8;\n        if (shift < 0)\n            code = currentByte >> (0 - shift);\n        else\n            code = currentByte << shift;\n    }\n    while (codeSize > bitsLeft) {\n        if (blockIndex >= blockSize) {\n            blockSize = readBlock();\n            blockIndex = 0;\n            if (blockSize == 0)\n                return endCode;\n        }\n        blockIndex++;\n        currentByte = block[blockIndex] & 0xFF;\n        code += currentByte << bitsLeft;\n        bitsLeft += 8;\n    }\n    bitsLeft -= codeSize;\n    return code & codeMask;\n}",
			"comments":"/**\n* Answer the next code from the input byte array.\n*/\n",
			"methodName":"int nextCode()"
		},
		"void nextPutPixels(byte[] buf)":{
			"methodBody":"{\n    if (image.depth == 8) {\n        \n        int start = line * image.bytesPerLine;\n        for (int i = 0; i < imageWidth; i++) image.data[start + i] = buf[i];\n    } else {\n        image.setPixels(0, line, imageWidth, buf, 0);\n    }\n    if (interlaced) {\n        if (pass == 1) {\n            copyRow(buf, 7);\n            line += 8;\n        } else if (pass == 2) {\n            copyRow(buf, 3);\n            line += 8;\n        } else if (pass == 3) {\n            copyRow(buf, 1);\n            line += 4;\n        } else if (pass == 4) {\n            line += 2;\n        } else if (pass == 5) {\n            line += 0;\n        }\n        if (line >= imageHeight) {\n            pass++;\n            if (pass == 2)\n                line = 4;\n            else if (pass == 3)\n                line = 2;\n            else if (pass == 4)\n                line = 1;\n            else if (pass == 5)\n                line = 0;\n            if (pass < 5) {\n                if (loader.hasListeners()) {\n                    ImageData imageCopy = (ImageData) image.clone();\n                    loader.notifyListeners(new ImageLoaderEvent(loader, imageCopy, pass - 2, false));\n                }\n            }\n        }\n        if (line >= imageHeight)\n            line = 0;\n    } else {\n        line++;\n    }\n}",
			"comments":"/**\n* Copy a row of pixel values to the image.\n*/\n// Slight optimization for depth = 8.\n",
			"methodName":"void nextPutPixels(byte[] buf)"
		},
		"void initializeForEncoding()":{
			"methodBody":"{\n    interlaced = false;\n    bitsPerPixel = image.depth;\n    codeSize = bitsPerPixel + 1;\n    topSlot = 1 << codeSize;\n    clearCode = 1 << bitsPerPixel;\n    endCode = clearCode + 1;\n    newCodes = currentSlot = endCode + 1;\n    bitsLeft = 8;\n    currentByte = 0;\n    blockIndex = 1;\n    blockSize = 255;\n    block = new byte[blockSize];\n    block[0] = (byte) (blockSize - 1);\n    nodeStack = new LZWNode[1 << bitsPerPixel];\n    for (int i = 0; i < nodeStack.length; i++) {\n        LZWNode node = new LZWNode();\n        node.code = i + 1;\n        node.prefix = -1;\n        node.suffix = i + 1;\n        nodeStack[i] = node;\n    }\n    imageWidth = image.width;\n    imageHeight = image.height;\n    imageY = -1;\n    lineArray = new byte[imageWidth];\n    \n    imageX = imageWidth + 1;\n}",
			"comments":"/**\n* Initialize the receiver for encoding the given\n* byte array.\n*/\n// Force a read\n",
			"methodName":"void initializeForEncoding()"
		},
		"void nextPutCode(int aCode)":{
			"methodBody":"{\n    int codeToDo = aCode;\n    int codeBitsToDo = codeSize;\n    \n    \n    int c = codeToDo & MASK_TABLE[bitsLeft - 1];\n    currentByte = currentByte | (c << (8 - bitsLeft));\n    block[blockIndex] = (byte) currentByte;\n    codeBitsToDo -= bitsLeft;\n    if (codeBitsToDo < 1) {\n        \n        bitsLeft -= codeSize;\n        if (bitsLeft == 0) {\n            \n            \n            bitsLeft = 8;\n            blockIndex++;\n            if (blockIndex >= blockSize) {\n                writeBlock();\n                blockIndex = 1;\n            }\n            currentByte = 0;\n        }\n        return;\n    }\n    codeToDo = codeToDo >> bitsLeft;\n    \n    blockIndex++;\n    if (blockIndex >= blockSize) {\n        writeBlock();\n        blockIndex = 1;\n    }\n    while (codeBitsToDo >= 8) {\n        currentByte = codeToDo & 0xFF;\n        block[blockIndex] = (byte) currentByte;\n        codeToDo = codeToDo >> 8;\n        codeBitsToDo -= 8;\n        blockIndex++;\n        if (blockIndex >= blockSize) {\n            writeBlock();\n            blockIndex = 1;\n        }\n    }\n    \n    bitsLeft = 8 - codeBitsToDo;\n    currentByte = codeToDo;\n    block[blockIndex] = (byte) currentByte;\n}",
			"comments":"/**\n* Output aCode to the output stream.\n*/\n// Fill in the remainder of the current byte with the\n// *high-order* bits of the code.\n// The whole code fit in the first byte, so we are done.\n// We used the whole last byte, so get ready\n// for the next one.\n// Fill in any remaining whole bytes (i.e. not the last one!)\n// Fill the *low-order* bits of the last byte with the remainder\n",
			"methodName":"void nextPutCode(int aCode)"
		},
		"void writeBlock()":{
			"methodBody":"{\n    try {\n        outputStream.write(block, 0, (block[0] & 0xFF) + 1);\n    } catch (Exception e) {\n        SWT.error(SWT.ERROR_IO, e);\n    }\n}",
			"comments":"/**\n* Write a block to the byte stream.\n* Throw an exception if the block could not be written.\n*/\n",
			"methodName":"void writeBlock()"
		},
		"int encodeLoop()":{
			"methodBody":"{\n    int pixel = nextPixel();\n    boolean found;\n    LZWNode node;\n    while (true) {\n        int currentPrefix = pixel;\n        node = nodeStack[currentPrefix];\n        found = true;\n        pixel = nextPixel();\n        if (pixel < 0)\n            return currentPrefix;\n        while (found && (node.children != null)) {\n            node = node.children;\n            while (found && (node.suffix != pixel)) {\n                if (pixel < node.suffix) {\n                    if (node.left == null) {\n                        node.left = new LZWNode();\n                        found = false;\n                    }\n                    node = node.left;\n                } else {\n                    if (node.right == null) {\n                        node.right = new LZWNode();\n                        found = false;\n                    }\n                    node = node.right;\n                }\n            }\n            if (found) {\n                currentPrefix = node.code;\n                pixel = nextPixel();\n                if (pixel < 0)\n                    return currentPrefix;\n            }\n        }\n        if (found) {\n            node.children = new LZWNode();\n            node = node.children;\n        }\n        node.children = null;\n        node.left = null;\n        node.right = null;\n        node.code = currentSlot;\n        node.prefix = currentPrefix;\n        node.suffix = pixel;\n        nextPutCode(currentPrefix);\n        currentSlot++;\n        \n        if (currentSlot < 4096) {\n            if (currentSlot > topSlot) {\n                codeSize++;\n                codeMask = MASK_TABLE[codeSize - 1];\n                topSlot *= 2;\n            }\n        } else {\n            nextPutCode(clearCode);\n            for (int i = 0; i < nodeStack.length; i++) nodeStack[i].children = null;\n            codeSize = bitsPerPixel + 1;\n            codeMask = MASK_TABLE[codeSize - 1];\n            currentSlot = newCodes;\n            topSlot = 1 << codeSize;\n        }\n    }\n}",
			"comments":"/**\n* Encoding loop broken out to allow early return.\n*/\n// Off by one?\n",
			"methodName":"int encodeLoop()"
		},
		"void initializeForDecoding()":{
			"methodBody":"{\n    pass = 1;\n    line = 0;\n    codeSize = bitsPerPixel + 1;\n    topSlot = 1 << codeSize;\n    clearCode = 1 << bitsPerPixel;\n    endCode = clearCode + 1;\n    newCodes = currentSlot = endCode + 1;\n    currentByte = -1;\n    blockSize = bitsLeft = 0;\n    blockIndex = 0;\n    codeMask = MASK_TABLE[codeSize - 1];\n    stack = new int[4096];\n    suffix = new int[4096];\n    prefix = new int[4096];\n    block = new byte[256];\n    imageWidth = image.width;\n    imageHeight = image.height;\n}",
			"comments":"/**\n* Initialize the receiver for decoding the given\n* byte array.\n*/\n",
			"methodName":"void initializeForDecoding()"
		},
		"public void encode(LEDataOutputStream byteStream, ImageData image)":{
			"methodBody":"{\n    this.outputStream = byteStream;\n    this.image = image;\n    initializeForEncoding();\n    encode();\n}",
			"comments":"/**\n* Encode the bytes into the given byte stream\n* from the given DeviceIndependentImage.\n*/\n",
			"methodName":"public void encode(LEDataOutputStream byteStream, ImageData image)"
		}
	},
	"ClassORInterfaceName":[
		"LZWCodec"
	]
}
