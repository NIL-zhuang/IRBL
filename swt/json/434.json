{
	"variables":[
		"layout",
		"font",
		"lpwp",
		"tabList",
		"layoutCount",
		"count",
		"hwndChild",
		"children",
		"index",
		"control",
		"newChildren",
		"count",
		"i",
		"newList",
		"index",
		"i",
		"i",
		"control",
		"ancestor",
		"composite",
		"i",
		"child",
		"composite",
		"result",
		"list",
		"i",
		"child",
		"childList",
		"newResult",
		"size",
		"trim",
		"result",
		"children",
		"i",
		"child",
		"menuList",
		"newResult",
		"children",
		"i",
		"count",
		"i",
		"newList",
		"length",
		"index",
		"i",
		"count",
		"hwndChild",
		"tabList",
		"count",
		"list",
		"i",
		"index",
		"i",
		"i",
		"control",
		"ancestor",
		"composite",
		"updateCount",
		"update",
		"i",
		"child",
		"composite",
		"newUpdate",
		"i",
		"children",
		"i",
		"children",
		"width",
		"height",
		"i",
		"rect",
		"children",
		"i",
		"child",
		"hwndChild",
		"threadId",
		"currentLpwp",
		"hdwp",
		"i",
		"wp",
		"processID",
		"threadId",
		"flags",
		"children",
		"i",
		"child",
		"i",
		"child",
		"children",
		"i",
		"child",
		"i",
		"child",
		"i",
		"control",
		"newList",
		"count",
		"takeFocus",
		"children",
		"i",
		"child",
		"i",
		"child",
		"hwnd",
		"control",
		"children",
		"i",
		"child",
		"children",
		"i",
		"control",
		"changed",
		"changed",
		"children",
		"i",
		"result",
		"result",
		"flags",
		"result",
		"code",
		"result",
		"hdr",
		"hwndParent",
		"bits",
		"flags",
		"hwndInsertAfter",
		"lpnmtdi",
		"string",
		"shell",
		"length",
		"chars",
		"hwnd",
		"control",
		"bytes",
		"rect",
		"oldBits",
		"newBits",
		"ps",
		"lpRgnData",
		"isComplex",
		"exposeRegion",
		"rgn",
		"nBytes",
		"data",
		"gc",
		"width",
		"height",
		"paintGC",
		"image",
		"event",
		"rect",
		"count",
		"i",
		"rect",
		"hDC",
		"rect",
		"result",
		"nSavedDC",
		"rect",
		"data",
		"gc",
		"event",
		"result",
		"hwndChild",
		"flags",
		"hwndChild",
		"result",
		"cmd",
		"showHBar",
		"showVBar",
		"code",
		"flags",
		"parent",
		"style",
		"OS",
		"handle",
		"OS",
		"hwndChild",
		"hwndChild",
		"count",
		"hwndChild",
		"OS",
		"hwndChild",
		"OS",
		"count",
		"hwndChild",
		"OS",
		"handle",
		"OS",
		"hwndChild",
		"display",
		"hwndChild",
		"control",
		"control",
		"children",
		"index",
		"control",
		"hwndChild",
		"OS",
		"hwndChild",
		"OS",
		"count",
		"index",
		"children",
		"index",
		"System",
		"children",
		"newChildren",
		"index",
		"newChildren",
		"tabList",
		"tabList",
		"i",
		"tabList",
		"i",
		"tabList",
		"i",
		"count",
		"count",
		"tabList",
		"tabList",
		"count",
		"i",
		"tabList",
		"i",
		"tabList",
		"i",
		"newList",
		"index",
		"tabList",
		"i",
		"tabList",
		"newList",
		"tabList",
		"changed",
		"SWT",
		"i",
		"changed",
		"i",
		"changed",
		"i",
		"control",
		"SWT",
		"control",
		"SWT",
		"control",
		"composite",
		"ancestor",
		"composite",
		"ancestor",
		"composite",
		"composite",
		"ancestor",
		"SWT",
		"i",
		"changed",
		"i",
		"changed",
		"i",
		"child",
		"child",
		"composite",
		"composite",
		"child",
		"composite",
		"LAYOUT_CHANGED",
		"child",
		"composite",
		"composite",
		"child",
		"OS",
		"state",
		"CANVAS",
		"result",
		"result",
		"tabList",
		"i",
		"list",
		"i",
		"list",
		"i",
		"child",
		"childList",
		"result",
		"childList",
		"System",
		"result",
		"newResult",
		"result",
		"System",
		"childList",
		"newResult",
		"result",
		"childList",
		"result",
		"newResult",
		"result",
		"layout",
		"wHint",
		"SWT",
		"hHint",
		"SWT",
		"changed",
		"state",
		"LAYOUT_CHANGED",
		"state",
		"LAYOUT_CHANGED",
		"size",
		"layout",
		"wHint",
		"hHint",
		"changed",
		"size",
		"wHint",
		"hHint",
		"size",
		"wHint",
		"hHint",
		"changed",
		"size",
		"size",
		"DEFAULT_WIDTH",
		"size",
		"size",
		"DEFAULT_HEIGHT",
		"wHint",
		"SWT",
		"size",
		"wHint",
		"hHint",
		"SWT",
		"size",
		"hHint",
		"size",
		"size",
		"trim",
		"trim",
		"state",
		"CANVAS",
		"control",
		"control",
		"i",
		"children",
		"i",
		"children",
		"i",
		"child",
		"control",
		"menuList",
		"result",
		"menuList",
		"System",
		"result",
		"newResult",
		"result",
		"System",
		"menuList",
		"newResult",
		"result",
		"menuList",
		"result",
		"newResult",
		"result",
		"newShell",
		"oldShell",
		"newDecorations",
		"oldDecorations",
		"menus",
		"i",
		"children",
		"i",
		"children",
		"i",
		"newShell",
		"oldShell",
		"newDecorations",
		"oldDecorations",
		"menus",
		"tabList",
		"i",
		"tabList",
		"i",
		"tabList",
		"i",
		"control",
		"count",
		"count",
		"tabList",
		"count",
		"length",
		"newList",
		"length",
		"i",
		"tabList",
		"i",
		"tabList",
		"i",
		"control",
		"newList",
		"index",
		"tabList",
		"i",
		"tabList",
		"newList",
		"OS",
		"handle",
		"OS",
		"hwndChild",
		"count",
		"hwndChild",
		"OS",
		"hwndChild",
		"OS",
		"count",
		"layout",
		"tabList",
		"i",
		"list",
		"i",
		"list",
		"i",
		"count",
		"tabList",
		"count",
		"i",
		"list",
		"i",
		"list",
		"i",
		"tabList",
		"index",
		"list",
		"i",
		"tabList",
		"SWT",
		"SWT",
		"layoutCount",
		"layoutCount",
		"parent",
		"layout",
		"changed",
		"layout",
		"all",
		"changed",
		"all",
		"all",
		"changed",
		"SWT",
		"i",
		"changed",
		"i",
		"changed",
		"i",
		"control",
		"SWT",
		"control",
		"SWT",
		"control",
		"composite",
		"ancestor",
		"composite",
		"ancestor",
		"composite",
		"composite",
		"ancestor",
		"SWT",
		"i",
		"changed",
		"i",
		"changed",
		"i",
		"child",
		"child",
		"composite",
		"composite",
		"LAYOUT_NEEDED",
		"composite",
		"child",
		"composite",
		"LAYOUT_CHANGED",
		"updateCount",
		"update",
		"update",
		"System",
		"update",
		"newUpdate",
		"update",
		"update",
		"newUpdate",
		"child",
		"update",
		"updateCount",
		"composite",
		"composite",
		"child",
		"updateCount",
		"i",
		"i",
		"update",
		"i",
		"layout",
		"state",
		"LAYOUT_NEEDED",
		"changed",
		"state",
		"LAYOUT_CHANGED",
		"all",
		"i",
		"children",
		"i",
		"children",
		"i",
		"changed",
		"all",
		"i",
		"children",
		"i",
		"children",
		"i",
		"width",
		"Math",
		"width",
		"rect",
		"rect",
		"height",
		"Math",
		"height",
		"rect",
		"rect",
		"width",
		"height",
		"i",
		"children",
		"i",
		"children",
		"i",
		"child",
		"child",
		"state",
		"CANVAS",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"hwndChild",
		"OS",
		"hwndChild",
		"threadId",
		"OS",
		"OS",
		"hwndChild",
		"layout",
		"tabList",
		"lpwp",
		"control",
		"lpwp",
		"lpwp",
		"lpwp",
		"currentLpwp",
		"currentLpwp",
		"lpwp",
		"pwp",
		"defer",
		"hdwp",
		"OS",
		"pwp",
		"hdwp",
		"i",
		"pwp",
		"i",
		"pwp",
		"i",
		"wp",
		"defer",
		"hdwp",
		"hdwp",
		"wp",
		"wp",
		"wp",
		"wp",
		"wp",
		"wp",
		"hdwp",
		"wp",
		"wp",
		"wp",
		"wp",
		"wp",
		"wp",
		"defer",
		"OS",
		"hdwp",
		"embeddedHandle",
		"OS",
		"embeddedHandle",
		"processID",
		"threadId",
		"OS",
		"processID",
		"OS",
		"display",
		"OS",
		"display",
		"display",
		"display",
		"display",
		"display",
		"SWT",
		"display",
		"OS",
		"OS",
		"display",
		"OS",
		"threadId",
		"OS",
		"threadId",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"embeddedHandle",
		"width",
		"height",
		"flags",
		"i",
		"children",
		"i",
		"children",
		"i",
		"child",
		"i",
		"children",
		"i",
		"children",
		"i",
		"child",
		"i",
		"children",
		"i",
		"children",
		"i",
		"child",
		"i",
		"children",
		"i",
		"children",
		"i",
		"child",
		"layout",
		"defer",
		"layoutCount",
		"layoutCount",
		"tabList",
		"i",
		"tabList",
		"i",
		"tabList",
		"i",
		"control",
		"SWT",
		"control",
		"SWT",
		"control",
		"SWT",
		"tabList",
		"System",
		"tabList",
		"newList",
		"tabList",
		"tabList",
		"newList",
		"tabList",
		"resize",
		"count",
		"lpwp",
		"lpwp",
		"count",
		"style",
		"SWT",
		"state",
		"CANVAS",
		"takeFocus",
		"style",
		"SWT",
		"takeFocus",
		"takeFocus",
		"i",
		"children",
		"i",
		"children",
		"i",
		"child",
		"child",
		"i",
		"children",
		"i",
		"children",
		"i",
		"child",
		"child",
		"hdr",
		"OS",
		"hdr",
		"hwnd",
		"display",
		"hwnd",
		"control",
		"control",
		"event",
		"control",
		"control",
		"i",
		"children",
		"i",
		"children",
		"i",
		"child",
		"event",
		"control",
		"state",
		"CANVAS",
		"style",
		"SWT",
		"msg",
		"i",
		"children",
		"i",
		"children",
		"i",
		"control",
		"control",
		"oldFont",
		"newFont",
		"oldFont",
		"newFont",
		"changed",
		"changed",
		"state",
		"LAYOUT_NEEDED",
		"state",
		"LAYOUT_CHANGED",
		"state",
		"LAYOUT_NEEDED",
		"LAYOUT_CHANGED",
		"resize",
		"layout",
		"changed",
		"resize",
		"all",
		"i",
		"children",
		"i",
		"children",
		"i",
		"resize",
		"all",
		"OS",
		"wParam",
		"lParam",
		"result",
		"result",
		"state",
		"CANVAS",
		"style",
		"SWT",
		"LRESULT",
		"result",
		"wParam",
		"lParam",
		"result",
		"result",
		"state",
		"CANVAS",
		"flags",
		"OS",
		"OS",
		"OS",
		"style",
		"SWT",
		"flags",
		"OS",
		"OS",
		"handle",
		"OS",
		"flags",
		"OS",
		"flags",
		"flags",
		"result",
		"wParam",
		"lParam",
		"result",
		"result",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"code",
		"code",
		"font",
		"font",
		"font",
		"wParam",
		"lParam",
		"state",
		"CANVAS",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"result",
		"OS",
		"OS",
		"hdr",
		"lParam",
		"NMHDR",
		"hdr",
		"OS",
		"OS",
		"hdr",
		"hwndParent",
		"OS",
		"hwndParent",
		"hwndParent",
		"OS",
		"hwndParent",
		"OS",
		"bits",
		"OS",
		"hwndParent",
		"display",
		"OS",
		"OS",
		"OS",
		"hdr",
		"OS",
		"OS",
		"OS",
		"hdr",
		"hwndInsertAfter",
		"flags",
		"display",
		"OS",
		"OS",
		"hdr",
		"OS",
		"lpnmtdi",
		"OS",
		"lpnmtdi",
		"lParam",
		"NMTTDISPINFOA",
		"lpnmtdi",
		"OS",
		"lpnmtdi",
		"lParam",
		"NMTTDISPINFOW",
		"lpnmtdi",
		"string",
		"string",
		"Display",
		"string",
		"string",
		"length",
		"string",
		"length",
		"chars",
		"hdr",
		"hwnd",
		"lpnmtdi",
		"OS",
		"display",
		"hwnd",
		"control",
		"control",
		"SWT",
		"lpnmtdi",
		"OS",
		"lpnmtdi",
		"OS",
		"hdr",
		"OS",
		"chars",
		"OS",
		"OS",
		"chars",
		"chars",
		"bytes",
		"bytes",
		"shell",
		"lpnmtdi",
		"bytes",
		"OS",
		"lParam",
		"lpnmtdi",
		"NMTTDISPINFOA",
		"shell",
		"lpnmtdi",
		"chars",
		"OS",
		"lParam",
		"lpnmtdi",
		"NMTTDISPINFOW",
		"LRESULT",
		"wParam",
		"lParam",
		"state",
		"CANVAS",
		"style",
		"SWT",
		"wParam",
		"OS",
		"OS",
		"handle",
		"rect",
		"lParam",
		"rect",
		"rect",
		"rect",
		"rect",
		"wParam",
		"lParam",
		"state",
		"CANVAS",
		"wParam",
		"lParam",
		"OS",
		"oldBits",
		"OS",
		"handle",
		"OS",
		"newBits",
		"oldBits",
		"OS",
		"OS",
		"newBits",
		"oldBits",
		"OS",
		"handle",
		"OS",
		"newBits",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"rgn",
		"OS",
		"isComplex",
		"OS",
		"handle",
		"rgn",
		"OS",
		"style",
		"SWT",
		"isComplex",
		"OS",
		"rgn",
		"lpRgnData",
		"nBytes",
		"exposeRegion",
		"OS",
		"rgn",
		"nBytes",
		"lpRgnData",
		"data",
		"ps",
		"data",
		"handle",
		"GC",
		"data",
		"ps",
		"ps",
		"ps",
		"ps",
		"width",
		"height",
		"style",
		"SWT",
		"image",
		"display",
		"width",
		"height",
		"paintGC",
		"gc",
		"gc",
		"image",
		"style",
		"SWT",
		"gc",
		"gc",
		"gc",
		"style",
		"SWT",
		"paintGC",
		"image",
		"ps",
		"ps",
		"gc",
		"width",
		"height",
		"OS",
		"rgn",
		"ps",
		"ps",
		"OS",
		"gc",
		"rgn",
		"OS",
		"gc",
		"OS",
		"gc",
		"ps",
		"ps",
		"event",
		"gc",
		"isComplex",
		"exposeRegion",
		"lpRgnData",
		"i",
		"count",
		"i",
		"OS",
		"rect",
		"lpRgnData",
		"i",
		"lpRgnData",
		"i",
		"lpRgnData",
		"i",
		"lpRgnData",
		"i",
		"style",
		"SWT",
		"SWT",
		"gc",
		"rect",
		"event",
		"rect",
		"event",
		"rect",
		"event",
		"rect",
		"rect",
		"event",
		"rect",
		"rect",
		"event",
		"count",
		"i",
		"SWT",
		"event",
		"style",
		"SWT",
		"SWT",
		"OS",
		"rect",
		"ps",
		"ps",
		"ps",
		"ps",
		"gc",
		"rect",
		"event",
		"ps",
		"event",
		"ps",
		"event",
		"width",
		"event",
		"height",
		"SWT",
		"event",
		"event",
		"style",
		"SWT",
		"gc",
		"paintGC",
		"image",
		"ps",
		"ps",
		"image",
		"gc",
		"paintGC",
		"gc",
		"rgn",
		"OS",
		"rgn",
		"OS",
		"handle",
		"ps",
		"style",
		"SWT",
		"OS",
		"rect",
		"ps",
		"ps",
		"ps",
		"ps",
		"hDC",
		"rect",
		"OS",
		"handle",
		"ps",
		"OS",
		"newBits",
		"oldBits",
		"OS",
		"handle",
		"OS",
		"oldBits",
		"LRESULT",
		"wParam",
		"lParam",
		"result",
		"result",
		"state",
		"CANVAS",
		"OS",
		"wParam",
		"OS",
		"handle",
		"rect",
		"style",
		"SWT",
		"wParam",
		"rect",
		"SWT",
		"SWT",
		"data",
		"display",
		"GC",
		"wParam",
		"data",
		"event",
		"gc",
		"event",
		"rect",
		"event",
		"rect",
		"event",
		"rect",
		"rect",
		"event",
		"rect",
		"rect",
		"SWT",
		"event",
		"event",
		"gc",
		"OS",
		"wParam",
		"nSavedDC",
		"result",
		"font",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"result",
		"layout",
		"OS",
		"handle",
		"state",
		"CANVAS",
		"style",
		"SWT",
		"SWT",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"hwndChild",
		"OS",
		"OS",
		"OS",
		"OS",
		"hwndChild",
		"flags",
		"hwndChild",
		"OS",
		"hwndChild",
		"OS",
		"state",
		"CANVAS",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"lParam",
		"lParam",
		"result",
		"OS",
		"handle",
		"OS",
		"hwndChild",
		"OS",
		"hwndChild",
		"OS",
		"hwndChild",
		"OS",
		"hwndChild",
		"OS",
		"wParam",
		"lParam",
		"result",
		"result",
		"wParam",
		"result",
		"OS",
		"wParam",
		"cmd",
		"OS",
		"OS",
		"horizontalBar",
		"horizontalBar",
		"verticalBar",
		"verticalBar",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"showHBar",
		"horizontalBar",
		"horizontalBar",
		"showVBar",
		"verticalBar",
		"verticalBar",
		"OS",
		"OS",
		"OS",
		"OS",
		"handle",
		"flags",
		"code",
		"LRESULT",
		"code",
		"result",
		"GW_CHILD",
		"GW_HWNDNEXT",
		"GW_CHILD",
		"GW_HWNDNEXT",
		"length",
		"length",
		"length",
		"ERROR_INVALID_ARGUMENT",
		"length",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"parent",
		"parent",
		"ERROR_INVALID_PARENT",
		"length",
		"parent",
		"layout",
		"layout",
		"state",
		"parent",
		"IsWinCE",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"DEFAULT",
		"DEFAULT",
		"x",
		"x",
		"y",
		"y",
		"DEFAULT",
		"x",
		"DEFAULT",
		"y",
		"x",
		"y",
		"width",
		"height",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"GW_CHILD",
		"GW_HWNDNEXT",
		"length",
		"length",
		"KeyDown",
		"KeyUp",
		"ERROR_INVALID_ARGUMENT",
		"length",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"parent",
		"parent",
		"ERROR_INVALID_PARENT",
		"length",
		"parent",
		"layout",
		"state",
		"layout",
		"state",
		"length",
		"length",
		"length",
		"parent",
		"length",
		"length",
		"x",
		"width",
		"y",
		"height",
		"length",
		"EMBEDDED",
		"GW_CHILD",
		"length",
		"length",
		"hwnd",
		"x",
		"y",
		"cx",
		"cy",
		"flags",
		"hwnd",
		"x",
		"y",
		"cx",
		"cy",
		"flags",
		"msgHook",
		"IsWinCE",
		"getMsgCallback",
		"getMsgProc",
		"getMsgCallback",
		"getMsgProc",
		"ERROR_NO_MORE_CALLBACKS",
		"msgHook",
		"WH_GETMESSAGE",
		"getMsgProc",
		"WM_NULL",
		"SWP_NOZORDER",
		"SWP_DRAWFRAME",
		"SWP_NOACTIVATE",
		"SWP_ASYNCWINDOWPOS",
		"length",
		"length",
		"length",
		"length",
		"layout",
		"length",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"parent",
		"ERROR_INVALID_PARENT",
		"length",
		"length",
		"tabList",
		"NO_FOCUS",
		"EMBEDDED",
		"length",
		"length",
		"uFlags",
		"TTF_IDISHWND",
		"idFrom",
		"toolTipText",
		"length",
		"EMBEDDED",
		"length",
		"length",
		"WS_CLIPCHILDREN",
		"NO_BACKGROUND",
		"ZERO",
		"DLGC_WANTALLKEYS",
		"DLGC_WANTARROWS",
		"DLGC_WANTTAB",
		"NO_FOCUS",
		"DLGC_STATIC",
		"GW_CHILD",
		"DLGC_STATIC",
		"WM_GETFONT",
		"NO_FOCUS",
		"GW_CHILD",
		"IsWinCE",
		"sizeof",
		"code",
		"TTN_SHOW",
		"TTN_POP",
		"hwndFrom",
		"GWL_EXSTYLE",
		"WS_EX_TOPMOST",
		"lockActiveWindow",
		"SWP_NOACTIVATE",
		"SWP_NOMOVE",
		"SWP_NOSIZE",
		"code",
		"TTN_SHOW",
		"HWND_TOPMOST",
		"HWND_NOTOPMOST",
		"hwndFrom",
		"lockActiveWindow",
		"TTN_GETDISPINFOA",
		"TTN_GETDISPINFOW",
		"code",
		"TTN_GETDISPINFOA",
		"sizeof",
		"sizeof",
		"idFrom",
		"uFlags",
		"TTF_IDISHWND",
		"RIGHT_TO_LEFT",
		"uFlags",
		"TTF_RTLREADING",
		"uFlags",
		"TTF_RTLREADING",
		"code",
		"TTN_GETDISPINFOA",
		"length",
		"CP_ACP",
		"length",
		"length",
		"sizeof",
		"sizeof",
		"ZERO",
		"EMBEDDED",
		"WM_CREATE",
		"right",
		"left",
		"bottom",
		"top",
		"IsWinCE",
		"GWL_STYLE",
		"WS_CLIPSIBLINGS",
		"WS_CLIPCHILDREN",
		"GWL_STYLE",
		"Paint",
		"NO_MERGE_PAINTS",
		"DOUBLE_BUFFERED",
		"COMPLEXREGION",
		"NO_MERGE_PAINTS",
		"ps",
		"hwnd",
		"right",
		"left",
		"bottom",
		"top",
		"DOUBLE_BUFFERED",
		"RIGHT_TO_LEFT",
		"NO_BACKGROUND",
		"left",
		"top",
		"left",
		"top",
		"handle",
		"handle",
		"handle",
		"left",
		"top",
		"gc",
		"DOUBLE_BUFFERED",
		"NO_BACKGROUND",
		"handle",
		"x",
		"left",
		"y",
		"top",
		"width",
		"right",
		"left",
		"height",
		"bottom",
		"top",
		"count",
		"Paint",
		"DOUBLE_BUFFERED",
		"NO_BACKGROUND",
		"left",
		"top",
		"right",
		"bottom",
		"handle",
		"x",
		"left",
		"y",
		"top",
		"width",
		"height",
		"Paint",
		"gc",
		"DOUBLE_BUFFERED",
		"left",
		"top",
		"NO_BACKGROUND",
		"left",
		"top",
		"right",
		"bottom",
		"IsWinCE",
		"GWL_STYLE",
		"ZERO",
		"NO_BACKGROUND",
		"Paint",
		"Paint",
		"device",
		"gc",
		"x",
		"left",
		"y",
		"top",
		"width",
		"right",
		"left",
		"height",
		"bottom",
		"top",
		"Paint",
		"gc",
		"NO_REDRAW_RESIZE",
		"Paint",
		"COMCTL32_MAJOR",
		"GW_CHILD",
		"RDW_ERASE",
		"RDW_INVALIDATE",
		"RDW_ALLCHILDREN",
		"GW_HWNDNEXT",
		"EMBEDDED",
		"GW_CHILD",
		"GW_CHILD",
		"WM_SYSCOLORCHANGE",
		"GW_HWNDNEXT",
		"IsWinCE",
		"SC_HSCROLL",
		"SC_VSCROLL",
		"WM_SYSCOMMAND",
		"RDW_FRAME",
		"RDW_INVALIDATE",
		"RDW_UPDATENOW",
		"ZERO",
		"parent",
		"style",
		"changed",
		"wHint",
		"hHint",
		"changed",
		"control",
		"newShell",
		"oldShell",
		"newDecorations",
		"oldDecorations",
		"menus",
		"control",
		"changed",
		"changed",
		"all",
		"changed",
		"changed",
		"all",
		"wHint",
		"hHint",
		"changed",
		"control",
		"defer",
		"pwp",
		"embeddedHandle",
		"width",
		"height",
		"layout",
		"defer",
		"tabList",
		"resize",
		"hdr",
		"event",
		"control",
		"msg",
		"oldFont",
		"newFont",
		"resize",
		"all",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam"
	],
	"extendORImplementFiles":[
		"Scrollable"
	],
	"package":[
		"org.eclipse.swt.widgets"
	],
	"import":[
		"org.eclipse.swt.internal",
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt",
		"org.eclipse.swt.graphics"
	],
	"methods":[
		"_getChildren",
		"_getTabList",
		"changed",
		"checkBuffered",
		"checkSubclass",
		"computeTabList",
		"computeSize",
		"createHandle",
		"findMenus",
		"fixChildren",
		"fixTabList",
		"getChildren",
		"getChildrenCount",
		"getLayout",
		"getTabList",
		"hooksKeys",
		"getLayoutDeferred",
		"isLayoutDeferred",
		"layout",
		"layout",
		"layout",
		"layout",
		"markLayout",
		"minimumSize",
		"releaseChildren",
		"releaseWidget",
		"removeControl",
		"resizeChildren",
		"resizeChildren",
		"resizeEmbeddedHandle",
		"setFixedFocus",
		"setFocus",
		"setLayout",
		"setLayoutDeferred",
		"setTabList",
		"setResizeChildren",
		"setTabGroupFocus",
		"toolTipText",
		"translateMnemonic",
		"translateTraversal",
		"updateFont",
		"updateLayout",
		"widgetStyle",
		"WM_ERASEBKGND",
		"WM_GETDLGCODE",
		"WM_GETFONT",
		"WM_LBUTTONDOWN",
		"WM_NOTIFY",
		"WM_PARENTNOTIFY",
		"WM_PAINT",
		"WM_PRINTCLIENT",
		"WM_SETFONT",
		"WM_SIZE",
		"WM_SYSCOLORCHANGE",
		"WM_SYSCOMMAND",
		"GetWindow",
		"GetWindow",
		"GetWindow",
		"getControl",
		"GetWindow",
		"arraycopy",
		"isDisposed",
		"isDisposed",
		"checkWidget",
		"error",
		"error",
		"isDisposed",
		"error",
		"error",
		"flushCache",
		"checkBuffered",
		"computeTabList",
		"_getTabList",
		"_getChildren",
		"computeTabList",
		"arraycopy",
		"arraycopy",
		"checkWidget",
		"computeSize",
		"minimumSize",
		"computeTrim",
		"createHandle",
		"findMenus",
		"_getChildren",
		"findMenus",
		"arraycopy",
		"arraycopy",
		"fixChildren",
		"_getChildren",
		"fixChildren",
		"checkWidget",
		"_getChildren",
		"GetWindow",
		"GetWindow",
		"checkWidget",
		"checkWidget",
		"_getTabList",
		"_getChildren",
		"isTabGroup",
		"isTabGroup",
		"hooks",
		"hooks",
		"checkWidget",
		"checkWidget",
		"isLayoutDeferred",
		"checkWidget",
		"layout",
		"checkWidget",
		"layout",
		"checkWidget",
		"markLayout",
		"updateLayout",
		"checkWidget",
		"error",
		"error",
		"isDisposed",
		"error",
		"error",
		"flushCache",
		"arraycopy",
		"updateLayout",
		"_getChildren",
		"markLayout",
		"_getChildren",
		"getBounds",
		"max",
		"max",
		"_getChildren",
		"isDisposed",
		"releaseResources",
		"releaseChildren",
		"releaseWidget",
		"GetWindow",
		"GetWindowThreadProcessId",
		"GetCurrentThreadId",
		"SetParent",
		"fixTabList",
		"resizeChildren",
		"resizeChildren",
		"resizeChildren",
		"BeginDeferWindowPos",
		"DeferWindowPos",
		"SetWindowPos",
		"EndDeferWindowPos",
		"GetWindowThreadProcessId",
		"GetCurrentThreadId",
		"GetCurrentProcessId",
		"getAddress",
		"error",
		"SetWindowsHookEx",
		"GetLibraryHandle",
		"PostThreadMessage",
		"SetWindowPos",
		"checkWidget",
		"_getChildren",
		"setRadioFocus",
		"setFixedFocus",
		"setFixedFocus",
		"checkWidget",
		"_getChildren",
		"setRadioFocus",
		"setFocus",
		"setFocus",
		"checkWidget",
		"isLayoutDeferred",
		"updateLayout",
		"checkWidget",
		"error",
		"isDisposed",
		"error",
		"error",
		"arraycopy",
		"resizeChildren",
		"getChildrenCount",
		"isTabItem",
		"setTabItemFocus",
		"hooksKeys",
		"setTabItemFocus",
		"_getChildren",
		"isTabItem",
		"setRadioFocus",
		"isTabItem",
		"setTabItemFocus",
		"getControl",
		"translateMnemonic",
		"_getChildren",
		"translateMnemonic",
		"translateTraversal",
		"_getChildren",
		"isDisposed",
		"updateFont",
		"updateFont",
		"layout",
		"isLayoutDeferred",
		"setResizeChildren",
		"layout",
		"setResizeChildren",
		"_getChildren",
		"updateLayout",
		"widgetStyle",
		"WM_ERASEBKGND",
		"WM_GETDLGCODE",
		"hooksKeys",
		"GetWindow",
		"WM_GETFONT",
		"callWindowProc",
		"defaultFont",
		"WM_LBUTTONDOWN",
		"hooksKeys",
		"GetWindow",
		"setFocus",
		"MoveMemory",
		"GetParent",
		"GetWindowLong",
		"SetWindowPos",
		"MoveMemory",
		"MoveMemory",
		"toolTipText",
		"getShell",
		"withCrLf",
		"length",
		"getChars",
		"getControl",
		"getStyle",
		"WideCharToMultiByte",
		"setToolTipText",
		"MoveMemory",
		"setToolTipText",
		"MoveMemory",
		"WM_NOTIFY",
		"GetClientRect",
		"resizeEmbeddedHandle",
		"WM_PARENTNOTIFY",
		"WM_PAINT",
		"GetWindowLong",
		"SetWindowLong",
		"hooks",
		"CreateRectRgn",
		"GetUpdateRgn",
		"GetRegionData",
		"GetRegionData",
		"win32_new",
		"setForeground",
		"getForeground",
		"setBackground",
		"getBackground",
		"setFont",
		"getFont",
		"copyArea",
		"fillRectangle",
		"OffsetRgn",
		"SelectClipRgn",
		"SetMetaRgn",
		"SetWindowOrgEx",
		"SetRect",
		"drawBackground",
		"sendEvent",
		"isDisposed",
		"SetRect",
		"drawBackground",
		"sendEvent",
		"dispose",
		"isDisposed",
		"drawImage",
		"dispose",
		"dispose",
		"DeleteObject",
		"BeginPaint",
		"SetRect",
		"drawBackground",
		"EndPaint",
		"isDisposed",
		"SetWindowLong",
		"WM_PRINTCLIENT",
		"forceResize",
		"SaveDC",
		"GetClientRect",
		"drawBackground",
		"hooks",
		"filters",
		"win32_new",
		"sendEvent",
		"dispose",
		"RestoreDC",
		"WM_SETFONT",
		"setResizeChildren",
		"WM_SIZE",
		"isDisposed",
		"markLayout",
		"updateLayout",
		"setResizeChildren",
		"IsWindowVisible",
		"hooks",
		"InvalidateRect",
		"IsAppThemed",
		"findThemeControl",
		"GetWindow",
		"RedrawWindow",
		"GetWindow",
		"resizeEmbeddedHandle",
		"GetWindow",
		"GetWindow",
		"SendMessage",
		"GetWindow",
		"WM_SYSCOMMAND",
		"getVisible",
		"getVisible",
		"callWindowProc",
		"getVisible",
		"getVisible",
		"RedrawWindow",
		"Point",
		"Point",
		"Point",
		"Callback",
		"LRESULT",
		"LRESULT",
		"LRESULT",
		"NMHDR",
		"NMTTDISPINFOA",
		"NMTTDISPINFOW",
		"RECT",
		"PAINTSTRUCT",
		"GCData",
		"Image",
		"GC",
		"Event",
		"RECT",
		"RECT",
		"RECT",
		"RECT",
		"GCData",
		"Event",
		"LRESULT"
	],
	"methodsBody":{
		"public void layout(boolean changed)":{
			"methodBody":"{\n    checkWidget();\n    if (layout == null)\n        return;\n    layout(changed, false);\n}",
			"comments":"/**\n* If the receiver has a layout, asks the layout to <em>lay out</em>\n* (that is, set the size and location of) the receiver's children.\n* If the argument is <code>true</code> the layout must not rely\n* on any information it has cached about the immediate children. If it\n* is <code>false</code> the layout may (potentially) optimize the\n* work it is doing by assuming that none of the receiver's\n* children has changed state since the last layout.\n* If the receiver does not have a layout, do nothing.\n* <p>\n* If a child is resized as a result of a call to layout, the\n* resize event will invoke the layout of the child.  The layout\n* will cascade down through all child widgets in the receiver's widget\n* tree until a child is encountered that does not resize.  Note that\n* a layout due to a resize will not flush any cached information\n* (same as <code>layout(false)</code>).</p>\n*\n* @param changed <code>true</code> if the layout must flush its caches, and <code>false</code> otherwise\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void layout(boolean changed)"
		},
		"public void layout(Control[] changed)":{
			"methodBody":"{\n    checkWidget();\n    if (changed == null)\n        error(SWT.ERROR_INVALID_ARGUMENT);\n    for (int i = 0; i < changed.length; i++) {\n        Control control = changed[i];\n        if (control == null)\n            error(SWT.ERROR_INVALID_ARGUMENT);\n        if (control.isDisposed())\n            error(SWT.ERROR_INVALID_ARGUMENT);\n        boolean ancestor = false;\n        Composite composite = control.parent;\n        while (composite != null) {\n            ancestor = composite == this;\n            if (ancestor)\n                break;\n            composite = composite.parent;\n        }\n        if (!ancestor)\n            error(SWT.ERROR_INVALID_PARENT);\n    }\n    int updateCount = 0;\n    Composite[] update = new Composite[16];\n    for (int i = 0; i < changed.length; i++) {\n        Control child = changed[i];\n        Composite composite = child.parent;\n        while (child != this) {\n            if (composite.layout != null) {\n                composite.state |= LAYOUT_NEEDED;\n                if (!composite.layout.flushCache(child)) {\n                    composite.state |= LAYOUT_CHANGED;\n                }\n            }\n            if (updateCount == update.length) {\n                Composite[] newUpdate = new Composite[update.length + 16];\n                System.arraycopy(update, 0, newUpdate, 0, update.length);\n                update = newUpdate;\n            }\n            child = update[updateCount++] = composite;\n            composite = child.parent;\n        }\n    }\n    for (int i = updateCount - 1; i >= 0; i--) {\n        update[i].updateLayout(true, false);\n    }\n}",
			"comments":"/**\n* Forces a lay out (that is, sets the size and location) of all widgets that\n* are in the parent hierarchy of the changed control up to and including the\n* receiver.  The layouts in the hierarchy must not rely on any information\n* cached about the changed control or any of its ancestors.  The layout may\n* (potentially) optimize the work it is doing by assuming that none of the\n* peers of the changed control have changed state since the last layout.\n* If an ancestor does not have a layout, skip it.\n*\n* @param changed a control that has had a state change which requires a recalculation of its size\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the changed array is null any of its controls are null or have been disposed</li>\n*    <li>ERROR_INVALID_PARENT - if any control in changed is not in the widget tree of the receiver</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public void layout(Control[] changed)"
		},
		"public void layout(boolean changed, boolean all)":{
			"methodBody":"{\n    checkWidget();\n    if (layout == null && !all)\n        return;\n    markLayout(changed, all);\n    updateLayout(true, all);\n}",
			"comments":"/**\n* If the receiver has a layout, asks the layout to <em>lay out</em>\n* (that is, set the size and location of) the receiver's children.\n* If the changed argument is <code>true</code> the layout must not rely\n* on any information it has cached about its children. If it\n* is <code>false</code> the layout may (potentially) optimize the\n* work it is doing by assuming that none of the receiver's\n* children has changed state since the last layout.\n* If the all argument is <code>true</code> the layout will cascade down\n* through all child widgets in the receiver's widget tree, regardless of\n* whether the child has changed size.  The changed argument is applied to\n* all layouts.  If the all argument is <code>false</code>, the layout will\n* <em>not</em> cascade down through all child widgets in the receiver's widget\n* tree.  However, if a child is resized as a result of a call to layout, the\n* resize event will invoke the layout of the child.  Note that\n* a layout due to a resize will not flush any cached information\n* (same as <code>layout(false)</code>).</p>\n*\n* @param changed <code>true</code> if the layout must flush its caches, and <code>false</code> otherwise\n* @param all <code>true</code> if all children in the receiver's widget tree should be laid out, and <code>false</code> otherwise\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public void layout(boolean changed, boolean all)"
		},
		"void resizeChildren()":{
			"methodBody":"{\n    if (lpwp == null)\n        return;\n    do {\n        WINDOWPOS[] currentLpwp = lpwp;\n        lpwp = null;\n        if (!resizeChildren(true, currentLpwp)) {\n            resizeChildren(false, currentLpwp);\n        }\n    } while (lpwp != null);\n}",
			"comments":"",
			"methodName":"void resizeChildren()"
		},
		"protected void checkSubclass()":{
			"methodBody":"{\n\n}",
			"comments":"/* Do nothing - Subclassing is allowed */\n",
			"methodName":"protected void checkSubclass()"
		},
		"public Layout getLayout()":{
			"methodBody":"{\n    checkWidget();\n    return layout;\n}",
			"comments":"/**\n* Returns layout which is associated with the receiver, or\n* null if one has not been set.\n*\n* @return the receiver's layout or null\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Layout getLayout()"
		},
		"boolean resizeChildren(boolean defer, WINDOWPOS[] pwp)":{
			"methodBody":"{\n    if (pwp == null)\n        return true;\n    int hdwp = 0;\n    if (defer) {\n        hdwp = OS.BeginDeferWindowPos(pwp.length);\n        if (hdwp == 0)\n            return false;\n    }\n    for (int i = 0; i < pwp.length; i++) {\n        WINDOWPOS wp = pwp[i];\n        if (wp != null) {\n            \n            if (defer) {\n                hdwp = DeferWindowPos(hdwp, wp.hwnd, 0, wp.x, wp.y, wp.cx, wp.cy, wp.flags);\n                if (hdwp == 0)\n                    return false;\n            } else {\n                SetWindowPos(wp.hwnd, 0, wp.x, wp.y, wp.cx, wp.cy, wp.flags);\n            }\n        }\n    }\n    if (defer)\n        return OS.EndDeferWindowPos(hdwp);\n    return true;\n}",
			"comments":"/*\n* This code is intentionally commented.  All widgets that\n* are created by SWT have WS_CLIPSIBLINGS to ensure that\n* application code does not draw outside of the control.\n*/\n//\t\t\tint count = parent.getChildrenCount ();\n//\t\t\tif (count > 1) {\n//\t\t\t\tint bits = OS.GetWindowLong (handle, OS.GWL_STYLE);\n//\t\t\t\tif ((bits & OS.WS_CLIPSIBLINGS) == 0) wp.flags |= OS.SWP_NOCOPYBITS;\n//\t\t\t}\n",
			"methodName":"boolean resizeChildren(boolean defer, WINDOWPOS[] pwp)"
		},
		"public Control[] getChildren()":{
			"methodBody":"{\n    checkWidget();\n    return _getChildren();\n}",
			"comments":"/**\n* Returns a (possibly empty) array containing the receiver's children.\n* Children are returned in the order that they are drawn.\n* <p>\n* Note: This is not the actual structure used by the receiver\n* to maintain its list of children, so modifying the array will\n* not affect the receiver.\n* </p>\n*\n* @return an array of children\n*\n* @see Control#moveAbove\n* @see Control#moveBelow\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Control[] getChildren()"
		},
		"void removeControl(Control control)":{
			"methodBody":"{\n    fixTabList(control);\n    resizeChildren();\n}",
			"comments":"",
			"methodName":"void removeControl(Control control)"
		},
		"public Control[] getTabList()":{
			"methodBody":"{\n    checkWidget();\n    Control[] tabList = _getTabList();\n    if (tabList == null) {\n        int count = 0;\n        Control[] list = _getChildren();\n        for (int i = 0; i < list.length; i++) {\n            if (list[i].isTabGroup())\n                count++;\n        }\n        tabList = new Control[count];\n        int index = 0;\n        for (int i = 0; i < list.length; i++) {\n            if (list[i].isTabGroup()) {\n                tabList[index++] = list[i];\n            }\n        }\n    }\n    return tabList;\n}",
			"comments":"/**\n* Gets the (possibly empty) tabbing order for the control.\n*\n* @return tabList the ordered list of controls representing the tab order\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #setTabList\n*/\n",
			"methodName":"public Control[] getTabList()"
		},
		"LRESULT WM_PARENTNOTIFY(int wParam, int lParam)":{
			"methodBody":"{\n    if ((state & CANVAS) != 0 && (style & SWT.EMBEDDED) != 0) {\n        if ((wParam & 0xFFFF) == OS.WM_CREATE) {\n            RECT rect = new RECT();\n            OS.GetClientRect(handle, rect);\n            resizeEmbeddedHandle(lParam, rect.right - rect.left, rect.bottom - rect.top);\n        }\n    }\n    return super.WM_PARENTNOTIFY(wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_PARENTNOTIFY(int wParam, int lParam)"
		},
		"void updateLayout(boolean resize, boolean all)":{
			"methodBody":"{\n    if (isLayoutDeferred())\n        return;\n    if ((state & LAYOUT_NEEDED) != 0) {\n        boolean changed = (state & LAYOUT_CHANGED) != 0;\n        state &= ~(LAYOUT_NEEDED | LAYOUT_CHANGED);\n        if (resize)\n            setResizeChildren(false);\n        layout.layout(this, changed);\n        if (resize)\n            setResizeChildren(true);\n    }\n    if (all) {\n        Control[] children = _getChildren();\n        for (int i = 0; i < children.length; i++) {\n            children[i].updateLayout(resize, all);\n        }\n    }\n}",
			"comments":"",
			"methodName":"void updateLayout(boolean resize, boolean all)"
		},
		"LRESULT WM_SIZE(int wParam, int lParam)":{
			"methodBody":"{\n    \n    setResizeChildren(false);\n    \n    LRESULT result = super.WM_SIZE(wParam, lParam);\n    \n    if (isDisposed())\n        return result;\n    if (layout != null) {\n        markLayout(false, false);\n        updateLayout(false, false);\n    }\n    \n    setResizeChildren(true);\n    \n    if (OS.IsWindowVisible(handle)) {\n        if ((state & CANVAS) != 0) {\n            if ((style & SWT.NO_REDRAW_RESIZE) == 0) {\n                if (hooks(SWT.Paint)) {\n                    OS.InvalidateRect(handle, null, true);\n                }\n            }\n        }\n        if (OS.COMCTL32_MAJOR >= 6 && OS.IsAppThemed()) {\n            if (findThemeControl() != null) {\n                int hwndChild = OS.GetWindow(handle, OS.GW_CHILD);\n                while (hwndChild != 0) {\n                    int flags = OS.RDW_ERASE | OS.RDW_INVALIDATE | OS.RDW_ALLCHILDREN;\n                    OS.RedrawWindow(hwndChild, null, 0, flags);\n                    hwndChild = OS.GetWindow(hwndChild, OS.GW_HWNDNEXT);\n                }\n            }\n        }\n    }\n    \n    if ((state & CANVAS) != 0 && (style & SWT.EMBEDDED) != 0) {\n        resizeEmbeddedHandle(OS.GetWindow(handle, OS.GW_CHILD), lParam & 0xFFFF, lParam >> 16);\n    }\n    return result;\n}",
			"comments":"/* Begin deferred window positioning */\n/* Resize and Layout */\n/*\n* It is possible (but unlikely), that application\n* code could have disposed the widget in the resize\n* event.  If this happens, end the processing of the\n* Windows message by returning the result of the\n* WM_SIZE message.\n*/\n/* End deferred window positioning */\n/* Damage the widget to cause a repaint */\n/* Resize the embedded window */\n",
			"methodName":"LRESULT WM_SIZE(int wParam, int lParam)"
		},
		"LRESULT WM_PAINT(int wParam, int lParam)":{
			"methodBody":"{\n    if ((state & CANVAS) == 0) {\n        return super.WM_PAINT(wParam, lParam);\n    }\n    \n    int oldBits = 0, newBits = 0;\n    if (!OS.IsWinCE) {\n        oldBits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n        newBits = oldBits | OS.WS_CLIPSIBLINGS | OS.WS_CLIPCHILDREN;\n        if (newBits != oldBits)\n            OS.SetWindowLong(handle, OS.GWL_STYLE, newBits);\n    }\n    \n    PAINTSTRUCT ps = new PAINTSTRUCT();\n    if (hooks(SWT.Paint)) {\n        \n        int[] lpRgnData = null;\n        boolean isComplex = false;\n        boolean exposeRegion = false;\n        int rgn = 0;\n        if ((style & (SWT.NO_MERGE_PAINTS | SWT.DOUBLE_BUFFERED)) != 0) {\n            rgn = OS.CreateRectRgn(0, 0, 0, 0);\n            isComplex = OS.GetUpdateRgn(handle, rgn, false) == OS.COMPLEXREGION;\n        }\n        if ((style & SWT.NO_MERGE_PAINTS) != 0) {\n            if (isComplex) {\n                int nBytes = OS.GetRegionData(rgn, 0, null);\n                lpRgnData = new int[nBytes / 4];\n                exposeRegion = OS.GetRegionData(rgn, nBytes, lpRgnData) != 0;\n            }\n        }\n        \n        GCData data = new GCData();\n        data.ps = ps;\n        data.hwnd = handle;\n        GC gc = GC.win32_new(this, data);\n        \n        int width = ps.right - ps.left;\n        int height = ps.bottom - ps.top;\n        if (width != 0 && height != 0) {\n            GC paintGC = null;\n            Image image = null;\n            if ((style & SWT.DOUBLE_BUFFERED) != 0) {\n                image = new Image(display, width, height);\n                paintGC = gc;\n                gc = new GC(image, style & SWT.RIGHT_TO_LEFT);\n                gc.setForeground(getForeground());\n                gc.setBackground(getBackground());\n                gc.setFont(getFont());\n                if ((style & SWT.NO_BACKGROUND) != 0) {\n                    paintGC.copyArea(image, ps.left, ps.top);\n                } else {\n                    gc.fillRectangle(0, 0, width, height);\n                }\n                OS.OffsetRgn(rgn, -ps.left, -ps.top);\n                OS.SelectClipRgn(gc.handle, rgn);\n                OS.SetMetaRgn(gc.handle);\n                OS.SetWindowOrgEx(gc.handle, ps.left, ps.top, null);\n            }\n            Event event = new Event();\n            event.gc = gc;\n            if (isComplex && exposeRegion) {\n                RECT rect = new RECT();\n                int count = lpRgnData[2];\n                for (int i = 0; i < count; i++) {\n                    OS.SetRect(rect, lpRgnData[8 + (i << 2)], lpRgnData[8 + (i << 2) + 1], lpRgnData[8 + (i << 2) + 2], lpRgnData[8 + (i << 2) + 3]);\n                    if ((style & (SWT.DOUBLE_BUFFERED | SWT.NO_BACKGROUND)) == 0) {\n                        drawBackground(gc.handle, rect);\n                    }\n                    event.x = rect.left;\n                    event.y = rect.top;\n                    event.width = rect.right - rect.left;\n                    event.height = rect.bottom - rect.top;\n                    event.count = count - 1 - i;\n                    \n                    sendEvent(SWT.Paint, event);\n                    if (isDisposed())\n                        break;\n                }\n            } else {\n                if ((style & (SWT.DOUBLE_BUFFERED | SWT.NO_BACKGROUND)) == 0) {\n                    RECT rect = new RECT();\n                    OS.SetRect(rect, ps.left, ps.top, ps.right, ps.bottom);\n                    drawBackground(gc.handle, rect);\n                }\n                event.x = ps.left;\n                event.y = ps.top;\n                event.width = width;\n                event.height = height;\n                sendEvent(SWT.Paint, event);\n            }\n            \n            event.gc = null;\n            if ((style & SWT.DOUBLE_BUFFERED) != 0) {\n                gc.dispose();\n                if (!isDisposed()) {\n                    paintGC.drawImage(image, ps.left, ps.top);\n                }\n                image.dispose();\n                gc = paintGC;\n            }\n        }\n        \n        gc.dispose();\n        if (rgn != 0)\n            OS.DeleteObject(rgn);\n    } else {\n        int hDC = OS.BeginPaint(handle, ps);\n        if ((style & SWT.NO_BACKGROUND) == 0) {\n            RECT rect = new RECT();\n            OS.SetRect(rect, ps.left, ps.top, ps.right, ps.bottom);\n            drawBackground(hDC, rect);\n        }\n        OS.EndPaint(handle, ps);\n    }\n    \n    if (!OS.IsWinCE) {\n        if (newBits != oldBits) {\n            \n            if (!isDisposed()) {\n                OS.SetWindowLong(handle, OS.GWL_STYLE, oldBits);\n            }\n        }\n    }\n    return LRESULT.ZERO;\n}",
			"comments":"/* Set the clipping bits */\n/* Paint the control and the background */\n/* Get the damage */\n/* Create the paint GC */\n/* Send the paint event */\n/*\n* It is possible (but unlikely), that application\n* code could have disposed the widget in the paint\n* event.  If this happens, attempt to give back the\n* paint GC anyways because this is a scarce Windows\n* resource.\n*/\n// widget could be disposed at this point\n/* Dispose the paint GC */\n/* Restore the clipping bits */\n/*\n* It is possible (but unlikely), that application\n* code could have disposed the widget in the paint\n* event.  If this happens, don't attempt to restore\n* the style.\n*/\n",
			"methodName":"LRESULT WM_PAINT(int wParam, int lParam)"
		},
		"void setResizeChildren(boolean resize)":{
			"methodBody":"{\n    if (resize) {\n        resizeChildren();\n    } else {\n        int count = getChildrenCount();\n        if (count > 1 && lpwp == null) {\n            lpwp = new WINDOWPOS[count];\n        }\n    }\n}",
			"comments":"",
			"methodName":"void setResizeChildren(boolean resize)"
		},
		"Control[] computeTabList()":{
			"methodBody":"{\n    Control[] result = super.computeTabList();\n    if (result.length == 0)\n        return result;\n    Control[] list = tabList != null ? _getTabList() : _getChildren();\n    for (int i = 0; i < list.length; i++) {\n        Control child = list[i];\n        Control[] childList = child.computeTabList();\n        if (childList.length != 0) {\n            Control[] newResult = new Control[result.length + childList.length];\n            System.arraycopy(result, 0, newResult, 0, result.length);\n            System.arraycopy(childList, 0, newResult, result.length, childList.length);\n            result = newResult;\n        }\n    }\n    return result;\n}",
			"comments":"",
			"methodName":"Control[] computeTabList()"
		},
		"boolean updateFont(Font oldFont, Font newFont)":{
			"methodBody":"{\n    Control[] children = _getChildren();\n    for (int i = 0; i < children.length; i++) {\n        Control control = children[i];\n        if (!control.isDisposed()) {\n            control.updateFont(oldFont, newFont);\n        }\n    }\n    boolean changed = super.updateFont(oldFont, newFont);\n    if (changed) {\n        \n        layout(true);\n    }\n    return changed;\n}",
			"comments":"/*\n* Call layout() directly so that subclasses that reimplement\n* this method instead of using a Layout will set the size and\n* location of their children when the font changes.\n*/\n",
			"methodName":"boolean updateFont(Font oldFont, Font newFont)"
		},
		"public boolean getLayoutDeferred()":{
			"methodBody":"{\n    checkWidget();\n    return layoutCount > 0;\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver has deferred\n* the performing of layout, and <code>false</code> otherwise.\n*\n* @return the receiver's deferred layout state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #setLayoutDeferred(boolean)\n* @see #isLayoutDeferred()\n*\n* @since 3.1\n*/\n",
			"methodName":"public boolean getLayoutDeferred()"
		},
		"void createHandle()":{
			"methodBody":"{\n    super.createHandle();\n    state |= CANVAS;\n}",
			"comments":"",
			"methodName":"void createHandle()"
		},
		"LRESULT WM_SYSCOLORCHANGE(int wParam, int lParam)":{
			"methodBody":"{\n    int hwndChild = OS.GetWindow(handle, OS.GW_CHILD);\n    while (hwndChild != 0) {\n        OS.SendMessage(hwndChild, OS.WM_SYSCOLORCHANGE, 0, 0);\n        hwndChild = OS.GetWindow(hwndChild, OS.GW_HWNDNEXT);\n    }\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_SYSCOLORCHANGE(int wParam, int lParam)"
		},
		"void fixTabList(Control control)":{
			"methodBody":"{\n    if (tabList == null)\n        return;\n    int count = 0;\n    for (int i = 0; i < tabList.length; i++) {\n        if (tabList[i] == control)\n            count++;\n    }\n    if (count == 0)\n        return;\n    Control[] newList = null;\n    int length = tabList.length - count;\n    if (length != 0) {\n        newList = new Control[length];\n        int index = 0;\n        for (int i = 0; i < tabList.length; i++) {\n            if (tabList[i] != control) {\n                newList[index++] = tabList[i];\n            }\n        }\n    }\n    tabList = newList;\n}",
			"comments":"",
			"methodName":"void fixTabList(Control control)"
		},
		"boolean setTabGroupFocus()":{
			"methodBody":"{\n    if (isTabItem())\n        return setTabItemFocus();\n    boolean takeFocus = (style & SWT.NO_FOCUS) == 0;\n    if ((state & CANVAS) != 0) {\n        takeFocus = hooksKeys();\n        if ((style & SWT.EMBEDDED) != 0)\n            takeFocus = true;\n    }\n    if (takeFocus && setTabItemFocus())\n        return true;\n    Control[] children = _getChildren();\n    for (int i = 0; i < children.length; i++) {\n        Control child = children[i];\n        if (child.isTabItem() && child.setRadioFocus())\n            return true;\n    }\n    for (int i = 0; i < children.length; i++) {\n        Control child = children[i];\n        if (child.isTabItem() && child.setTabItemFocus())\n            return true;\n    }\n    return false;\n}",
			"comments":"",
			"methodName":"boolean setTabGroupFocus()"
		},
		"public void setLayoutDeferred(boolean defer)":{
			"methodBody":"{\n    if (!defer) {\n        if (--layoutCount == 0) {\n            if (!isLayoutDeferred())\n                updateLayout(true, true);\n        }\n    } else {\n        layoutCount++;\n    }\n}",
			"comments":"/**\n* If the argument is <code>true</code>, causes subsequent layout\n* operations in the receiver or any of its children to be ignored.\n* No layout of any kind can occur in the receiver or any of its\n* children until the flag is set to false.\n* Layout operations that occurred while the flag was\n* <code>true</code> are remembered and when the flag is set to\n* <code>false</code>, the layout operations are performed in an\n* optimized manner.  Nested calls to this method are stacked.\n*\n* @param defer the new defer state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #layout(boolean)\n* @see #layout(Control[])\n*\n* @since 3.1\n*/\n",
			"methodName":"public void setLayoutDeferred(boolean defer)"
		},
		"LRESULT WM_GETDLGCODE(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_GETDLGCODE(wParam, lParam);\n    if (result != null)\n        return result;\n    if ((state & CANVAS) != 0) {\n        int flags = 0;\n        if (hooksKeys()) {\n            flags |= OS.DLGC_WANTALLKEYS | OS.DLGC_WANTARROWS | OS.DLGC_WANTTAB;\n        }\n        if ((style & SWT.NO_FOCUS) != 0)\n            flags |= OS.DLGC_STATIC;\n        if (OS.GetWindow(handle, OS.GW_CHILD) != 0)\n            flags |= OS.DLGC_STATIC;\n        if (flags != 0)\n            return new LRESULT(flags);\n    }\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_GETDLGCODE(int wParam, int lParam)"
		},
		"boolean translateTraversal(MSG msg)":{
			"methodBody":"{\n    if ((state & CANVAS) != 0 && (style & SWT.EMBEDDED) != 0)\n        return false;\n    return super.translateTraversal(msg);\n}",
			"comments":"",
			"methodName":"boolean translateTraversal(MSG msg)"
		},
		"void releaseChildren()":{
			"methodBody":"{\n    Control[] children = _getChildren();\n    for (int i = 0; i < children.length; i++) {\n        Control child = children[i];\n        if (!child.isDisposed())\n            child.releaseResources();\n    }\n}",
			"comments":"",
			"methodName":"void releaseChildren()"
		},
		"int getChildrenCount()":{
			"methodBody":"{\n    \n    int count = 0;\n    int hwndChild = OS.GetWindow(handle, OS.GW_CHILD);\n    while (hwndChild != 0) {\n        count++;\n        hwndChild = OS.GetWindow(hwndChild, OS.GW_HWNDNEXT);\n    }\n    return count;\n}",
			"comments":"/*\n* NOTE: The current implementation will count\n* non-registered children.\n*/\n",
			"methodName":"int getChildrenCount()"
		},
		"int widgetStyle()":{
			"methodBody":"{\n    \n    return super.widgetStyle() | OS.WS_CLIPCHILDREN;\n}",
			"comments":"/* Force clipping of children by setting WS_CLIPCHILDREN */\n",
			"methodName":"int widgetStyle()"
		},
		"Point minimumSize(int wHint, int hHint, boolean changed)":{
			"methodBody":"{\n    Control[] children = _getChildren();\n    int width = 0, height = 0;\n    for (int i = 0; i < children.length; i++) {\n        Rectangle rect = children[i].getBounds();\n        width = Math.max(width, rect.x + rect.width);\n        height = Math.max(height, rect.y + rect.height);\n    }\n    return new Point(width, height);\n}",
			"comments":"",
			"methodName":"Point minimumSize(int wHint, int hHint, boolean changed)"
		},
		"boolean translateMnemonic(Event event, Control control)":{
			"methodBody":"{\n    if (super.translateMnemonic(event, control))\n        return true;\n    if (control != null) {\n        Control[] children = _getChildren();\n        for (int i = 0; i < children.length; i++) {\n            Control child = children[i];\n            if (child.translateMnemonic(event, control))\n                return true;\n        }\n    }\n    return false;\n}",
			"comments":"",
			"methodName":"boolean translateMnemonic(Event event, Control control)"
		},
		"public void changed(Control[] changed)":{
			"methodBody":"{\n    checkWidget();\n    if (changed == null)\n        error(SWT.ERROR_INVALID_ARGUMENT);\n    for (int i = 0; i < changed.length; i++) {\n        Control control = changed[i];\n        if (control == null)\n            error(SWT.ERROR_INVALID_ARGUMENT);\n        if (control.isDisposed())\n            error(SWT.ERROR_INVALID_ARGUMENT);\n        boolean ancestor = false;\n        Composite composite = control.parent;\n        while (composite != null) {\n            ancestor = composite == this;\n            if (ancestor)\n                break;\n            composite = composite.parent;\n        }\n        if (!ancestor)\n            error(SWT.ERROR_INVALID_PARENT);\n    }\n    for (int i = 0; i < changed.length; i++) {\n        Control child = changed[i];\n        Composite composite = child.parent;\n        while (child != this) {\n            if (composite.layout == null || !composite.layout.flushCache(child)) {\n                composite.state |= LAYOUT_CHANGED;\n            }\n            child = composite;\n            composite = child.parent;\n        }\n    }\n}",
			"comments":"/**\n* Clears any data that has been cached by a Layout for all widgets that\n* are in the parent hierarchy of the changed control up to and including the\n* receiver.  If an ancestor does not have a layout, it is skipped.\n*\n* @param changed an array of controls that changed state and require a recalculation of size\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the changed array is null any of its controls are null or have been disposed</li>\n*    <li>ERROR_INVALID_PARENT - if any control in changed is not in the widget tree of the receiver</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public void changed(Control[] changed)"
		},
		"LRESULT WM_ERASEBKGND(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_ERASEBKGND(wParam, lParam);\n    if (result != null)\n        return result;\n    if ((state & CANVAS) != 0) {\n        \n        if ((style & SWT.NO_BACKGROUND) != 0)\n            return LRESULT.ZERO;\n    }\n    return result;\n}",
			"comments":"/* Return zero to indicate that the background was not erased */\n",
			"methodName":"LRESULT WM_ERASEBKGND(int wParam, int lParam)"
		},
		"public boolean isLayoutDeferred()":{
			"methodBody":"{\n    checkWidget();\n    return layoutCount > 0 || parent.isLayoutDeferred();\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver or any ancestor\n* up to and including the receiver's nearest ancestor shell\n* has deferred the performing of layouts.  Otherwise, <code>false</code>\n* is returned.\n*\n* @return the receiver's deferred layout state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #setLayoutDeferred(boolean)\n* @see #getLayoutDeferred()\n*\n* @since 3.1\n*/\n",
			"methodName":"public boolean isLayoutDeferred()"
		},
		"Control[] _getChildren()":{
			"methodBody":"{\n    int count = 0;\n    int hwndChild = OS.GetWindow(handle, OS.GW_CHILD);\n    if (hwndChild == 0)\n        return new Control[0];\n    while (hwndChild != 0) {\n        count++;\n        hwndChild = OS.GetWindow(hwndChild, OS.GW_HWNDNEXT);\n    }\n    Control[] children = new Control[count];\n    int index = 0;\n    hwndChild = OS.GetWindow(handle, OS.GW_CHILD);\n    while (hwndChild != 0) {\n        Control control = display.getControl(hwndChild);\n        if (control != null && control != this) {\n            children[index++] = control;\n        }\n        hwndChild = OS.GetWindow(hwndChild, OS.GW_HWNDNEXT);\n    }\n    if (count == index)\n        return children;\n    Control[] newChildren = new Control[index];\n    System.arraycopy(children, 0, newChildren, 0, index);\n    return newChildren;\n}",
			"comments":"",
			"methodName":"Control[] _getChildren()"
		},
		"boolean setFixedFocus()":{
			"methodBody":"{\n    checkWidget();\n    Control[] children = _getChildren();\n    for (int i = 0; i < children.length; i++) {\n        Control child = children[i];\n        if (child.setRadioFocus())\n            return true;\n    }\n    for (int i = 0; i < children.length; i++) {\n        Control child = children[i];\n        if (child.setFixedFocus())\n            return true;\n    }\n    return super.setFixedFocus();\n}",
			"comments":"",
			"methodName":"boolean setFixedFocus()"
		},
		"boolean hooksKeys()":{
			"methodBody":"{\n    return hooks(SWT.KeyDown) || hooks(SWT.KeyUp);\n}",
			"comments":"",
			"methodName":"boolean hooksKeys()"
		},
		"LRESULT WM_GETFONT(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_GETFONT(wParam, lParam);\n    if (result != null)\n        return result;\n    int code = callWindowProc(handle, OS.WM_GETFONT, wParam, lParam);\n    if (code != 0)\n        return new LRESULT(code);\n    if (font == 0)\n        font = defaultFont();\n    return new LRESULT(font);\n}",
			"comments":"",
			"methodName":"LRESULT WM_GETFONT(int wParam, int lParam)"
		},
		"Menu[] findMenus(Control control)":{
			"methodBody":"{\n    if (control == this)\n        return new Menu[0];\n    Menu[] result = super.findMenus(control);\n    Control[] children = _getChildren();\n    for (int i = 0; i < children.length; i++) {\n        Control child = children[i];\n        Menu[] menuList = child.findMenus(control);\n        if (menuList.length != 0) {\n            Menu[] newResult = new Menu[result.length + menuList.length];\n            System.arraycopy(result, 0, newResult, 0, result.length);\n            System.arraycopy(menuList, 0, newResult, result.length, menuList.length);\n            result = newResult;\n        }\n    }\n    return result;\n}",
			"comments":"",
			"methodName":"Menu[] findMenus(Control control)"
		},
		"LRESULT WM_NOTIFY(int wParam, int lParam)":{
			"methodBody":"{\n    if (!OS.IsWinCE) {\n        NMHDR hdr = new NMHDR();\n        OS.MoveMemory(hdr, lParam, NMHDR.sizeof);\n        switch(hdr.code) {\n            \n            case OS.TTN_SHOW:\n            case OS.TTN_POP:\n                {\n                    \n                    int hwndParent = hdr.hwndFrom;\n                    do {\n                        hwndParent = OS.GetParent(hwndParent);\n                        if (hwndParent == 0)\n                            break;\n                        int bits = OS.GetWindowLong(hwndParent, OS.GWL_EXSTYLE);\n                        if ((bits & OS.WS_EX_TOPMOST) != 0)\n                            break;\n                    } while (true);\n                    if (hwndParent != 0)\n                        break;\n                    display.lockActiveWindow = true;\n                    int flags = OS.SWP_NOACTIVATE | OS.SWP_NOMOVE | OS.SWP_NOSIZE;\n                    int hwndInsertAfter = hdr.code == OS.TTN_SHOW ? OS.HWND_TOPMOST : OS.HWND_NOTOPMOST;\n                    SetWindowPos(hdr.hwndFrom, hwndInsertAfter, 0, 0, 0, 0, flags);\n                    display.lockActiveWindow = false;\n                    break;\n                }\n            \n            case OS.TTN_GETDISPINFOA:\n            case OS.TTN_GETDISPINFOW:\n                {\n                    NMTTDISPINFO lpnmtdi;\n                    if (hdr.code == OS.TTN_GETDISPINFOA) {\n                        lpnmtdi = new NMTTDISPINFOA();\n                        OS.MoveMemory((NMTTDISPINFOA) lpnmtdi, lParam, NMTTDISPINFOA.sizeof);\n                    } else {\n                        lpnmtdi = new NMTTDISPINFOW();\n                        OS.MoveMemory((NMTTDISPINFOW) lpnmtdi, lParam, NMTTDISPINFOW.sizeof);\n                    }\n                    String string = toolTipText(lpnmtdi);\n                    if (string != null) {\n                        Shell shell = getShell();\n                        string = Display.withCrLf(string);\n                        int length = string.length();\n                        char[] chars = new char[length + 1];\n                        string.getChars(0, length, chars, 0);\n                        \n                        int hwnd = hdr.idFrom;\n                        if (hwnd != 0 && ((lpnmtdi.uFlags & OS.TTF_IDISHWND) != 0)) {\n                            Control control = display.getControl(hwnd);\n                            if (control != null) {\n                                if ((control.getStyle() & SWT.RIGHT_TO_LEFT) != 0) {\n                                    lpnmtdi.uFlags |= OS.TTF_RTLREADING;\n                                } else {\n                                    lpnmtdi.uFlags &= ~OS.TTF_RTLREADING;\n                                }\n                            }\n                        }\n                        if (hdr.code == OS.TTN_GETDISPINFOA) {\n                            byte[] bytes = new byte[chars.length * 2];\n                            OS.WideCharToMultiByte(OS.CP_ACP, 0, chars, chars.length, bytes, bytes.length, null, null);\n                            shell.setToolTipText(lpnmtdi, bytes);\n                            OS.MoveMemory(lParam, (NMTTDISPINFOA) lpnmtdi, NMTTDISPINFOA.sizeof);\n                        } else {\n                            shell.setToolTipText(lpnmtdi, chars);\n                            OS.MoveMemory(lParam, (NMTTDISPINFOW) lpnmtdi, NMTTDISPINFOW.sizeof);\n                        }\n                        return LRESULT.ZERO;\n                    }\n                    break;\n                }\n        }\n    }\n    return super.WM_NOTIFY(wParam, lParam);\n}",
			"comments":"/*\n* Feature in Windows.  When the tool tip control is\n* created, the parent of the tool tip is the shell.\n* If SetParent () is used to reparent the tool bar\n* into a new shell, the tool tip is not reparented\n* and pops up underneath the new shell.  The fix is\n* to make sure the tool tip is a topmost window.\n*/\n/*\n* Bug in Windows 98 and NT.  Setting the tool tip to be the\n* top most window using HWND_TOPMOST can result in a parent\n* dialog shell being moved behind its parent if the dialog\n* has a sibling that is currently on top.  The fix is to\n* lock the z-order of the active window.\n*\n* Feature in Windows.  Using SetWindowPos() with HWND_NOTOPMOST\n* to clear the topmost state of a window whose parent is already\n* topmost clears the topmost state of the parent.  The fix is to\n* check if the parent is already on top and neither set or clear\n* the topmost status of the tool tip.\n*/\n/*\n* Bug in Windows 98.  For some reason, the tool bar control\n* sends both TTN_GETDISPINFOW and TTN_GETDISPINFOA to get\n* the tool tip text and the tab folder control sends only\n* TTN_GETDISPINFOW.  The fix is to handle only TTN_GETDISPINFOW,\n* even though it should never be sent on Windows 98.\n*\n* NOTE:  Because the size of NMTTDISPINFO differs between\n* Windows 98 and NT, guard against the case where the wrong\n* kind of message occurs by inlining the memory moves and\n* the UNICODE conversion code.\n*/\n/*\n* Ensure that the orientation of the tool tip matches\n* the orientation of the control.\n*/\n",
			"methodName":"LRESULT WM_NOTIFY(int wParam, int lParam)"
		},
		"public void layout()":{
			"methodBody":"{\n    checkWidget();\n    layout(true);\n}",
			"comments":"/**\n* If the receiver has a layout, asks the layout to <em>lay out</em>\n* (that is, set the size and location of) the receiver's children.\n* If the receiver does not have a layout, do nothing.\n* <p>\n* This is equivalent to calling <code>layout(true)</code>.\n* </p>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void layout()"
		},
		"LRESULT WM_PRINTCLIENT(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_PRINTCLIENT(wParam, lParam);\n    if (result != null)\n        return result;\n    if ((state & CANVAS) != 0) {\n        forceResize();\n        int nSavedDC = OS.SaveDC(wParam);\n        RECT rect = new RECT();\n        OS.GetClientRect(handle, rect);\n        if ((style & SWT.NO_BACKGROUND) == 0) {\n            drawBackground(wParam, rect);\n        }\n        if (hooks(SWT.Paint) || filters(SWT.Paint)) {\n            GCData data = new GCData();\n            data.device = display;\n            GC gc = GC.win32_new(wParam, data);\n            Event event = new Event();\n            event.gc = gc;\n            event.x = rect.left;\n            event.y = rect.top;\n            event.width = rect.right - rect.left;\n            event.height = rect.bottom - rect.top;\n            sendEvent(SWT.Paint, event);\n            event.gc = null;\n            gc.dispose();\n        }\n        OS.RestoreDC(wParam, nSavedDC);\n    }\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_PRINTCLIENT(int wParam, int lParam)"
		},
		"public void setLayout(Layout layout)":{
			"methodBody":"{\n    checkWidget();\n    this.layout = layout;\n}",
			"comments":"/**\n* Sets the layout which is associated with the receiver to be\n* the argument which may be null.\n*\n* @param layout the receiver's new layout or null\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setLayout(Layout layout)"
		},
		"LRESULT WM_LBUTTONDOWN(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_LBUTTONDOWN(wParam, lParam);\n    \n    if ((state & CANVAS) != 0) {\n        if ((style & SWT.NO_FOCUS) == 0 && hooksKeys()) {\n            if (OS.GetWindow(handle, OS.GW_CHILD) == 0)\n                setFocus();\n        }\n    }\n    return result;\n}",
			"comments":"/* Set focus for a canvas with no children */\n",
			"methodName":"LRESULT WM_LBUTTONDOWN(int wParam, int lParam)"
		},
		"public Point computeSize(int wHint, int hHint, boolean changed)":{
			"methodBody":"{\n    checkWidget();\n    Point size;\n    if (layout != null) {\n        if (wHint == SWT.DEFAULT || hHint == SWT.DEFAULT) {\n            changed |= (state & LAYOUT_CHANGED) != 0;\n            state &= ~LAYOUT_CHANGED;\n            size = layout.computeSize(this, wHint, hHint, changed);\n        } else {\n            size = new Point(wHint, hHint);\n        }\n    } else {\n        size = minimumSize(wHint, hHint, changed);\n    }\n    if (size.x == 0)\n        size.x = DEFAULT_WIDTH;\n    if (size.y == 0)\n        size.y = DEFAULT_HEIGHT;\n    if (wHint != SWT.DEFAULT)\n        size.x = wHint;\n    if (hHint != SWT.DEFAULT)\n        size.y = hHint;\n    Rectangle trim = computeTrim(0, 0, size.x, size.y);\n    return new Point(trim.width, trim.height);\n}",
			"comments":"",
			"methodName":"public Point computeSize(int wHint, int hHint, boolean changed)"
		},
		"void markLayout(boolean changed, boolean all)":{
			"methodBody":"{\n    if (layout != null) {\n        state |= LAYOUT_NEEDED;\n        if (changed)\n            state |= LAYOUT_CHANGED;\n    }\n    if (all) {\n        Control[] children = _getChildren();\n        for (int i = 0; i < children.length; i++) {\n            children[i].markLayout(changed, all);\n        }\n    }\n}",
			"comments":"",
			"methodName":"void markLayout(boolean changed, boolean all)"
		},
		"LRESULT WM_SYSCOMMAND(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_SYSCOMMAND(wParam, lParam);\n    if (result != null)\n        return result;\n    \n    if ((wParam & 0xF000) == 0)\n        return result;\n    \n    if (!OS.IsWinCE) {\n        int cmd = wParam & 0xFFF0;\n        switch(cmd) {\n            case OS.SC_HSCROLL:\n            case OS.SC_VSCROLL:\n                boolean showHBar = horizontalBar != null && horizontalBar.getVisible();\n                boolean showVBar = verticalBar != null && verticalBar.getVisible();\n                int code = callWindowProc(handle, OS.WM_SYSCOMMAND, wParam, lParam);\n                if ((showHBar != (horizontalBar != null && horizontalBar.getVisible())) || (showVBar != (verticalBar != null && verticalBar.getVisible()))) {\n                    int flags = OS.RDW_FRAME | OS.RDW_INVALIDATE | OS.RDW_UPDATENOW;\n                    OS.RedrawWindow(handle, null, 0, flags);\n                }\n                if (code == 0)\n                    return LRESULT.ZERO;\n                return new LRESULT(code);\n        }\n    }\n    \n    return result;\n}",
			"comments":"/*\n* Check to see if the command is a system command or\n* a user menu item that was added to the system menu.\n*/\n/*\n* Bug in Windows.  When a vertical or horizontal scroll bar is\n* hidden or shown while the opposite scroll bar is being scrolled\n* by the user (with WM_HSCROLL code SB_LINEDOWN), the scroll bar\n* does not redraw properly.  The fix is to detect this case and\n* redraw the non-client area.\n*/\n/* Return the result */\n",
			"methodName":"LRESULT WM_SYSCOMMAND(int wParam, int lParam)"
		},
		"LRESULT WM_SETFONT(int wParam, int lParam)":{
			"methodBody":"{\n    return super.WM_SETFONT(font = wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_SETFONT(int wParam, int lParam)"
		},
		"public void setTabList(Control[] tabList)":{
			"methodBody":"{\n    checkWidget();\n    if (tabList != null) {\n        for (int i = 0; i < tabList.length; i++) {\n            Control control = tabList[i];\n            if (control == null)\n                error(SWT.ERROR_INVALID_ARGUMENT);\n            if (control.isDisposed())\n                error(SWT.ERROR_INVALID_ARGUMENT);\n            if (control.parent != this)\n                error(SWT.ERROR_INVALID_PARENT);\n        }\n        Control[] newList = new Control[tabList.length];\n        System.arraycopy(tabList, 0, newList, 0, tabList.length);\n        tabList = newList;\n    }\n    this.tabList = tabList;\n}",
			"comments":"/**\n* Sets the tabbing order for the specified controls to\n* match the order that they occur in the argument list.\n*\n* @param tabList the ordered list of controls representing the tab order or null\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if a widget in the tabList is null or has been disposed</li>\n*    <li>ERROR_INVALID_PARENT - if widget in the tabList is not in the same widget tree</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setTabList(Control[] tabList)"
		},
		"void resizeEmbeddedHandle(int embeddedHandle, int width, int height)":{
			"methodBody":"{\n    if (embeddedHandle == 0)\n        return;\n    int[] processID = new int[1];\n    int threadId = OS.GetWindowThreadProcessId(embeddedHandle, processID);\n    if (threadId != OS.GetCurrentThreadId()) {\n        if (processID[0] == OS.GetCurrentProcessId()) {\n            if (display.msgHook == 0) {\n                if (!OS.IsWinCE) {\n                    display.getMsgCallback = new Callback(display, \"getMsgProc\", 3);\n                    display.getMsgProc = display.getMsgCallback.getAddress();\n                    if (display.getMsgProc == 0)\n                        error(SWT.ERROR_NO_MORE_CALLBACKS);\n                    display.msgHook = OS.SetWindowsHookEx(OS.WH_GETMESSAGE, display.getMsgProc, OS.GetLibraryHandle(), threadId);\n                    OS.PostThreadMessage(threadId, OS.WM_NULL, 0, 0);\n                }\n            }\n        }\n        int flags = OS.SWP_NOZORDER | OS.SWP_DRAWFRAME | OS.SWP_NOACTIVATE | OS.SWP_ASYNCWINDOWPOS;\n        OS.SetWindowPos(embeddedHandle, 0, 0, 0, width, height, flags);\n    }\n}",
			"comments":"",
			"methodName":"void resizeEmbeddedHandle(int embeddedHandle, int width, int height)"
		},
		"public boolean setFocus()":{
			"methodBody":"{\n    checkWidget();\n    Control[] children = _getChildren();\n    for (int i = 0; i < children.length; i++) {\n        Control child = children[i];\n        if (child.setRadioFocus())\n            return true;\n    }\n    for (int i = 0; i < children.length; i++) {\n        Control child = children[i];\n        if (child.setFocus())\n            return true;\n    }\n    return super.setFocus();\n}",
			"comments":"",
			"methodName":"public boolean setFocus()"
		},
		"String toolTipText(NMTTDISPINFO hdr)":{
			"methodBody":"{\n    if ((hdr.uFlags & OS.TTF_IDISHWND) == 0) {\n        return null;\n    }\n    int hwnd = hdr.idFrom;\n    if (hwnd == 0)\n        return null;\n    Control control = display.getControl(hwnd);\n    if (control == null)\n        return null;\n    return control.toolTipText;\n}",
			"comments":"",
			"methodName":"String toolTipText(NMTTDISPINFO hdr)"
		},
		"void checkBuffered()":{
			"methodBody":"{\n    if (OS.IsWinCE || (state & CANVAS) == 0) {\n        super.checkBuffered();\n    }\n}",
			"comments":"",
			"methodName":"void checkBuffered()"
		},
		"void releaseWidget()":{
			"methodBody":"{\n    releaseChildren();\n    super.releaseWidget();\n    if ((state & CANVAS) != 0 && (style & SWT.EMBEDDED) != 0) {\n        int hwndChild = OS.GetWindow(handle, OS.GW_CHILD);\n        if (hwndChild != 0) {\n            int threadId = OS.GetWindowThreadProcessId(hwndChild, null);\n            if (threadId != OS.GetCurrentThreadId()) {\n                OS.SetParent(hwndChild, 0);\n            }\n        }\n    }\n    layout = null;\n    tabList = null;\n    lpwp = null;\n}",
			"comments":"",
			"methodName":"void releaseWidget()"
		},
		"Control[] _getTabList()":{
			"methodBody":"{\n    if (tabList == null)\n        return tabList;\n    int count = 0;\n    for (int i = 0; i < tabList.length; i++) {\n        if (!tabList[i].isDisposed())\n            count++;\n    }\n    if (count == tabList.length)\n        return tabList;\n    Control[] newList = new Control[count];\n    int index = 0;\n    for (int i = 0; i < tabList.length; i++) {\n        if (!tabList[i].isDisposed()) {\n            newList[index++] = tabList[i];\n        }\n    }\n    tabList = newList;\n    return tabList;\n}",
			"comments":"",
			"methodName":"Control[] _getTabList()"
		},
		"void fixChildren(Shell newShell, Shell oldShell, Decorations newDecorations, Decorations oldDecorations, Menu[] menus)":{
			"methodBody":"{\n    super.fixChildren(newShell, oldShell, newDecorations, oldDecorations, menus);\n    Control[] children = _getChildren();\n    for (int i = 0; i < children.length; i++) {\n        children[i].fixChildren(newShell, oldShell, newDecorations, oldDecorations, menus);\n    }\n}",
			"comments":"",
			"methodName":"void fixChildren(Shell newShell, Shell oldShell, Decorations newDecorations, Decorations oldDecorations, Menu[] menus)"
		}
	},
	"ClassORInterfaceName":[
		"Composite"
	]
}
