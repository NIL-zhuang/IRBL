{
	"variables":[
		"text",
		"image",
		"image2",
		"imageList",
		"ignoreMouse",
		"ButtonProc",
		"ButtonClass",
		"SCROLLBAR",
		"CHECK_WIDTH",
		"CHECK_HEIGHT",
		"ICON_WIDTH",
		"ICON_HEIGHT",
		"hBitmap",
		"bitmap",
		"lpWndClass",
		"buttonImageList",
		"buffer",
		"buffer",
		"hImage",
		"imageBits",
		"fImageType",
		"rect",
		"data",
		"gc",
		"rect",
		"hDC",
		"dstHdc",
		"hBitmap",
		"oldBitmap",
		"srcHdc",
		"oldSrcBitmap",
		"newBrush",
		"oldBrush",
		"newBits",
		"oldBits",
		"typedListener",
		"border",
		"width",
		"height",
		"extra",
		"hasImage",
		"buttonImageList",
		"bits",
		"oldFont",
		"hDC",
		"newFont",
		"lptm",
		"length",
		"buffer",
		"rect",
		"flags",
		"rect",
		"bits",
		"hasImage",
		"string",
		"buffer",
		"bits",
		"state",
		"mnemonic",
		"children",
		"i",
		"child",
		"bits",
		"buttonImageList",
		"hwndShell",
		"bits",
		"flags",
		"bits",
		"newBits",
		"oldBits",
		"buffer",
		"bits",
		"result",
		"result",
		"bits",
		"result",
		"result",
		"result",
		"control",
		"rect",
		"code",
		"struct",
		"rect",
		"hTheme",
		"iStateId",
		"uState",
		"OS",
		"OS",
		"hBitmap",
		"CHECK_WIDTH",
		"OS",
		"OS",
		"OS",
		"OS",
		"CHECK_HEIGHT",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"hBitmap",
		"BITMAP",
		"bitmap",
		"OS",
		"hBitmap",
		"CHECK_WIDTH",
		"bitmap",
		"CHECK_HEIGHT",
		"bitmap",
		"OS",
		"ButtonClass",
		"lpWndClass",
		"ButtonProc",
		"lpWndClass",
		"parent",
		"style",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"imageList",
		"imageList",
		"imageList",
		"image",
		"imageList",
		"style",
		"SWT",
		"imageList",
		"image",
		"buttonImageList",
		"imageList",
		"style",
		"SWT",
		"buttonImageList",
		"OS",
		"style",
		"SWT",
		"buttonImageList",
		"OS",
		"style",
		"SWT",
		"buttonImageList",
		"OS",
		"OS",
		"handle",
		"buffer",
		"OS",
		"handle",
		"OS",
		"buttonImageList",
		"text",
		"OS",
		"handle",
		"buffer",
		"OS",
		"handle",
		"OS",
		"image2",
		"image2",
		"image2",
		"image",
		"image",
		"SWT",
		"image",
		"image",
		"data",
		"SWT",
		"rect",
		"ICON_WIDTH",
		"rect",
		"ICON_HEIGHT",
		"image2",
		"display",
		"data",
		"data",
		"hImage",
		"image2",
		"imageBits",
		"OS",
		"fImageType",
		"OS",
		"SWT",
		"image2",
		"display",
		"rect",
		"rect",
		"image2",
		"gc",
		"gc",
		"rect",
		"gc",
		"image",
		"gc",
		"hImage",
		"image2",
		"imageBits",
		"OS",
		"fImageType",
		"OS",
		"SWT",
		"hImage",
		"image",
		"imageBits",
		"OS",
		"fImageType",
		"OS",
		"SWT",
		"hImage",
		"image",
		"imageBits",
		"OS",
		"fImageType",
		"OS",
		"style",
		"SWT",
		"OS",
		"OS",
		"OS",
		"image",
		"OS",
		"handle",
		"OS",
		"hDC",
		"OS",
		"hDC",
		"rect",
		"rect",
		"OS",
		"dstHdc",
		"hBitmap",
		"OS",
		"dstHdc",
		"OS",
		"fImageType",
		"OS",
		"OS",
		"hDC",
		"OS",
		"srcHdc",
		"hImage",
		"OS",
		"dstHdc",
		"OS",
		"dstHdc",
		"rect",
		"rect",
		"srcHdc",
		"OS",
		"OS",
		"srcHdc",
		"oldSrcBitmap",
		"OS",
		"srcHdc",
		"OS",
		"OS",
		"dstHdc",
		"newBrush",
		"OS",
		"dstHdc",
		"rect",
		"rect",
		"OS",
		"OS",
		"dstHdc",
		"hImage",
		"OS",
		"OS",
		"dstHdc",
		"oldBrush",
		"OS",
		"newBrush",
		"OS",
		"dstHdc",
		"oldBitmap",
		"OS",
		"dstHdc",
		"OS",
		"handle",
		"hDC",
		"image2",
		"image2",
		"image2",
		"Image",
		"display",
		"SWT",
		"hBitmap",
		"imageBits",
		"OS",
		"fImageType",
		"OS",
		"hImage",
		"hBitmap",
		"OS",
		"handle",
		"OS",
		"newBits",
		"newBits",
		"OS",
		"OS",
		"newBits",
		"imageBits",
		"newBits",
		"oldBits",
		"OS",
		"handle",
		"OS",
		"newBits",
		"OS",
		"handle",
		"OS",
		"fImageType",
		"hImage",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"SWT",
		"typedListener",
		"handle",
		"OS",
		"ButtonProc",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"style",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"style",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"ignoreMouse",
		"OS",
		"handle",
		"OS",
		"ignoreMouse",
		"style",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"width",
		"OS",
		"OS",
		"height",
		"OS",
		"OS",
		"width",
		"OS",
		"OS",
		"height",
		"OS",
		"OS",
		"wHint",
		"SWT",
		"width",
		"wHint",
		"hHint",
		"SWT",
		"height",
		"hHint",
		"width",
		"border",
		"height",
		"border",
		"width",
		"height",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"buttonImageList",
		"hasImage",
		"buttonImageList",
		"OS",
		"handle",
		"OS",
		"hasImage",
		"bits",
		"OS",
		"OS",
		"hasImage",
		"OS",
		"handle",
		"OS",
		"handle",
		"OS",
		"newFont",
		"oldFont",
		"OS",
		"hDC",
		"newFont",
		"OS",
		"OS",
		"hDC",
		"lptm",
		"text",
		"length",
		"height",
		"lptm",
		"extra",
		"Math",
		"lptm",
		"text",
		"OS",
		"OS",
		"OS",
		"hDC",
		"buffer",
		"rect",
		"flags",
		"width",
		"rect",
		"rect",
		"height",
		"rect",
		"rect",
		"newFont",
		"OS",
		"hDC",
		"oldFont",
		"OS",
		"handle",
		"hDC",
		"image",
		"image",
		"width",
		"rect",
		"height",
		"rect",
		"extra",
		"style",
		"SWT",
		"SWT",
		"width",
		"CHECK_WIDTH",
		"extra",
		"height",
		"Math",
		"height",
		"CHECK_HEIGHT",
		"style",
		"SWT",
		"SWT",
		"width",
		"height",
		"wHint",
		"SWT",
		"width",
		"wHint",
		"hHint",
		"SWT",
		"height",
		"hHint",
		"width",
		"border",
		"height",
		"border",
		"width",
		"height",
		"style",
		"SWT",
		"SWT",
		"OS",
		"OS",
		"OS",
		"OS",
		"enabled",
		"style",
		"SWT",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"OS",
		"hasImage",
		"enabled",
		"text",
		"text",
		"string",
		"OS",
		"handle",
		"buffer",
		"style",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"image",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"OS",
		"handle",
		"OS",
		"state",
		"OS",
		"style",
		"SWT",
		"text",
		"style",
		"SWT",
		"mnemonic",
		"Character",
		"key",
		"Character",
		"mnemonic",
		"imageList",
		"imageList",
		"imageList",
		"image2",
		"image2",
		"image2",
		"text",
		"image",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"eventTable",
		"SWT",
		"listener",
		"parent",
		"i",
		"children",
		"i",
		"children",
		"i",
		"child",
		"child",
		"style",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"alignment",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"OS",
		"handle",
		"alignment",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"alignment",
		"SWT",
		"SWT",
		"SWT",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"OS",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"OS",
		"imageList",
		"buttonImageList",
		"imageList",
		"style",
		"SWT",
		"buttonImageList",
		"OS",
		"style",
		"SWT",
		"buttonImageList",
		"OS",
		"style",
		"SWT",
		"buttonImageList",
		"OS",
		"OS",
		"handle",
		"OS",
		"buttonImageList",
		"OS",
		"handle",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"value",
		"bits",
		"OS",
		"OS",
		"hwndShell",
		"OS",
		"handle",
		"bits",
		"OS",
		"OS",
		"hwndShell",
		"OS",
		"OS",
		"handle",
		"OS",
		"bits",
		"style",
		"SWT",
		"image",
		"image",
		"SWT",
		"image",
		"style",
		"SWT",
		"style",
		"SWT",
		"value",
		"value",
		"SWT",
		"style",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"selected",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"flags",
		"OS",
		"handle",
		"OS",
		"bits",
		"string",
		"SWT",
		"style",
		"SWT",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"imageList",
		"imageList",
		"imageList",
		"OS",
		"handle",
		"OS",
		"newBits",
		"newBits",
		"OS",
		"OS",
		"newBits",
		"oldBits",
		"OS",
		"handle",
		"OS",
		"newBits",
		"text",
		"string",
		"style",
		"SWT",
		"OS",
		"OS",
		"string",
		"OS",
		"handle",
		"text",
		"text",
		"string",
		"OS",
		"handle",
		"buffer",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"OS",
		"OS",
		"bits",
		"OS",
		"OS",
		"ButtonClass",
		"ButtonProc",
		"wParam",
		"lParam",
		"result",
		"result",
		"style",
		"SWT",
		"OS",
		"result",
		"wParam",
		"lParam",
		"style",
		"SWT",
		"result",
		"ignoreMouse",
		"wParam",
		"lParam",
		"ignoreMouse",
		"wParam",
		"lParam",
		"style",
		"SWT",
		"bits",
		"OS",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"bits",
		"style",
		"SWT",
		"result",
		"wParam",
		"lParam",
		"result",
		"result",
		"image2",
		"image",
		"result",
		"wParam",
		"lParam",
		"OS",
		"OS",
		"control",
		"OS",
		"wParam",
		"OS",
		"OS",
		"control",
		"rect",
		"OS",
		"control",
		"handle",
		"rect",
		"control",
		"wParam",
		"rect",
		"OS",
		"OS",
		"result",
		"wParam",
		"code",
		"OS",
		"OS",
		"style",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"parent",
		"SWT",
		"SWT",
		"wParam",
		"lParam",
		"style",
		"SWT",
		"wParam",
		"lParam",
		"OS",
		"struct",
		"lParam",
		"DRAWITEMSTRUCT",
		"OS",
		"rect",
		"struct",
		"struct",
		"struct",
		"struct",
		"OS",
		"OS",
		"OS",
		"handle",
		"SCROLLBAR",
		"OS",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"iStateId",
		"OS",
		"SWT",
		"iStateId",
		"OS",
		"SWT",
		"iStateId",
		"OS",
		"SWT",
		"iStateId",
		"OS",
		"iStateId",
		"OS",
		"OS",
		"struct",
		"OS",
		"iStateId",
		"OS",
		"OS",
		"OS",
		"hTheme",
		"struct",
		"OS",
		"iStateId",
		"rect",
		"OS",
		"hTheme",
		"OS",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"uState",
		"OS",
		"SWT",
		"uState",
		"OS",
		"SWT",
		"uState",
		"OS",
		"SWT",
		"uState",
		"OS",
		"uState",
		"OS",
		"style",
		"SWT",
		"SWT",
		"uState",
		"OS",
		"struct",
		"OS",
		"uState",
		"OS",
		"OS",
		"struct",
		"rect",
		"OS",
		"uState",
		"OBM_CHECKBOXES",
		"IsWinCE",
		"SM_CXSMICON",
		"SM_CXVSCROLL",
		"IsWinCE",
		"SM_CYSMICON",
		"SM_CYVSCROLL",
		"sizeof",
		"bmWidth",
		"bmHeight",
		"lpfnWndProc",
		"COMCTL32_MAJOR",
		"BCM_SETIMAGELIST",
		"RIGHT_TO_LEFT",
		"himl",
		"LEFT",
		"uAlign",
		"BUTTON_IMAGELIST_ALIGN_LEFT",
		"CENTER",
		"uAlign",
		"BUTTON_IMAGELIST_ALIGN_CENTER",
		"RIGHT",
		"uAlign",
		"BUTTON_IMAGELIST_ALIGN_RIGHT",
		"BCM_SETIMAGELIST",
		"BCM_SETIMAGELIST",
		"type",
		"BITMAP",
		"TRANSPARENCY_PIXEL",
		"width",
		"height",
		"handle",
		"BS_ICON",
		"IMAGE_ICON",
		"TRANSPARENCY_ALPHA",
		"width",
		"height",
		"handle",
		"BS_BITMAP",
		"IMAGE_BITMAP",
		"TRANSPARENCY_NONE",
		"handle",
		"BS_BITMAP",
		"IMAGE_BITMAP",
		"ICON",
		"handle",
		"BS_ICON",
		"IMAGE_ICON",
		"RIGHT_TO_LEFT",
		"IsWinCE",
		"WIN32_VERSION",
		"width",
		"height",
		"LAYOUT_RTL",
		"IMAGE_BITMAP",
		"width",
		"height",
		"SRCCOPY",
		"width",
		"height",
		"PATCOPY",
		"DI_NORMAL",
		"BITMAP",
		"BS_BITMAP",
		"IMAGE_BITMAP",
		"GWL_STYLE",
		"BS_BITMAP",
		"BS_ICON",
		"GWL_STYLE",
		"BM_SETIMAGE",
		"ERROR_NULL_ARGUMENT",
		"Selection",
		"DefaultSelection",
		"PUSH",
		"ARROW",
		"CHECK",
		"RADIO",
		"TOGGLE",
		"PUSH",
		"TOGGLE",
		"CENTER",
		"LEFT",
		"RIGHT",
		"CHECK",
		"RADIO",
		"LEFT",
		"RIGHT",
		"CENTER",
		"ARROW",
		"NO_FOCUS",
		"UP",
		"DOWN",
		"LEFT",
		"RIGHT",
		"BM_CLICK",
		"ARROW",
		"UP",
		"DOWN",
		"SM_CXVSCROLL",
		"SM_CYVSCROLL",
		"SM_CXHSCROLL",
		"SM_CYHSCROLL",
		"DEFAULT",
		"DEFAULT",
		"COMCTL32_MAJOR",
		"BCM_GETIMAGELIST",
		"himl",
		"GWL_STYLE",
		"BS_BITMAP",
		"BS_ICON",
		"WM_GETFONT",
		"IsUnicode",
		"tmHeight",
		"tmAveCharWidth",
		"DT_CALCRECT",
		"DT_SINGLELINE",
		"right",
		"left",
		"bottom",
		"top",
		"width",
		"height",
		"CHECK",
		"RADIO",
		"PUSH",
		"TOGGLE",
		"DEFAULT",
		"DEFAULT",
		"PUSH",
		"TOGGLE",
		"COLOR_BTNFACE",
		"COLOR_BTNTEXT",
		"RIGHT_TO_LEFT",
		"COMCTL32_MAJOR",
		"GWL_STYLE",
		"BS_BITMAP",
		"BS_ICON",
		"ARROW",
		"UP",
		"UP",
		"DOWN",
		"DOWN",
		"LEFT",
		"LEFT",
		"RIGHT",
		"RIGHT",
		"UP",
		"LEFT",
		"LEFT",
		"CENTER",
		"CENTER",
		"RIGHT",
		"RIGHT",
		"LEFT",
		"PUSH",
		"GWL_STYLE",
		"BS_DEFPUSHBUTTON",
		"CHECK",
		"RADIO",
		"TOGGLE",
		"BM_GETCHECK",
		"BST_CHECKED",
		"ARROW",
		"RADIO",
		"ERROR_NULL_ARGUMENT",
		"Selection",
		"DefaultSelection",
		"length",
		"ARROW",
		"UP",
		"DOWN",
		"LEFT",
		"RIGHT",
		"UP",
		"DOWN",
		"LEFT",
		"RIGHT",
		"UP",
		"DOWN",
		"LEFT",
		"RIGHT",
		"LEFT",
		"RIGHT",
		"CENTER",
		"LEFT",
		"RIGHT",
		"CENTER",
		"LEFT",
		"RIGHT",
		"CENTER",
		"GWL_STYLE",
		"BS_LEFT",
		"BS_CENTER",
		"BS_RIGHT",
		"LEFT",
		"BS_LEFT",
		"CENTER",
		"BS_CENTER",
		"RIGHT",
		"BS_RIGHT",
		"GWL_STYLE",
		"COMCTL32_MAJOR",
		"himl",
		"LEFT",
		"uAlign",
		"BUTTON_IMAGELIST_ALIGN_LEFT",
		"CENTER",
		"uAlign",
		"BUTTON_IMAGELIST_ALIGN_CENTER",
		"RIGHT",
		"uAlign",
		"BUTTON_IMAGELIST_ALIGN_RIGHT",
		"BCM_SETIMAGELIST",
		"PUSH",
		"handle",
		"GWL_STYLE",
		"BS_DEFPUSHBUTTON",
		"DM_SETDEFID",
		"BS_DEFPUSHBUTTON",
		"DM_SETDEFID",
		"BM_SETSTYLE",
		"RADIO",
		"ERROR_INVALID_ARGUMENT",
		"image",
		"RADIO",
		"RADIO",
		"Selection",
		"RADIO",
		"CHECK",
		"RADIO",
		"TOGGLE",
		"BST_CHECKED",
		"BST_UNCHECKED",
		"GWL_STYLE",
		"BM_SETCHECK",
		"GWL_STYLE",
		"ERROR_NULL_ARGUMENT",
		"ARROW",
		"COMCTL32_MAJOR",
		"BCM_SETIMAGELIST",
		"GWL_STYLE",
		"BS_BITMAP",
		"BS_ICON",
		"GWL_STYLE",
		"RIGHT_TO_LEFT",
		"COMCTL32_MAJOR",
		"FLAT",
		"BS_FLAT",
		"ARROW",
		"BS_OWNERDRAW",
		"LEFT",
		"BS_LEFT",
		"CENTER",
		"BS_CENTER",
		"RIGHT",
		"BS_RIGHT",
		"PUSH",
		"BS_PUSHBUTTON",
		"WS_TABSTOP",
		"CHECK",
		"BS_CHECKBOX",
		"WS_TABSTOP",
		"RADIO",
		"BS_RADIOBUTTON",
		"TOGGLE",
		"BS_PUSHLIKE",
		"BS_CHECKBOX",
		"WS_TABSTOP",
		"BS_PUSHBUTTON",
		"WS_TABSTOP",
		"ARROW",
		"DLGC_STATIC",
		"PUSH",
		"RADIO",
		"GWL_STYLE",
		"RADIO",
		"GWL_STYLE",
		"PUSH",
		"COMCTL32_MAJOR",
		"TRANSPARENT",
		"handle",
		"handle",
		"NULL_BRUSH",
		"BN_CLICKED",
		"BN_DOUBLECLICKED",
		"CHECK",
		"TOGGLE",
		"RADIO",
		"NO_RADIO_GROUP",
		"Selection",
		"ARROW",
		"sizeof",
		"left",
		"top",
		"right",
		"bottom",
		"COMCTL32_MAJOR",
		"ABS_LEFTNORMAL",
		"UP",
		"DOWN",
		"LEFT",
		"RIGHT",
		"UP",
		"ABS_UPNORMAL",
		"DOWN",
		"ABS_DOWNNORMAL",
		"LEFT",
		"ABS_LEFTNORMAL",
		"RIGHT",
		"ABS_RIGHTNORMAL",
		"ABS_UPDISABLED",
		"ABS_UPNORMAL",
		"itemState",
		"ODS_SELECTED",
		"ABS_UPPRESSED",
		"ABS_UPNORMAL",
		"hDC",
		"SBP_ARROWBTN",
		"DFCS_SCROLLLEFT",
		"UP",
		"DOWN",
		"LEFT",
		"RIGHT",
		"UP",
		"DFCS_SCROLLUP",
		"DOWN",
		"DFCS_SCROLLDOWN",
		"LEFT",
		"DFCS_SCROLLLEFT",
		"RIGHT",
		"DFCS_SCROLLRIGHT",
		"DFCS_INACTIVE",
		"FLAT",
		"FLAT",
		"DFCS_FLAT",
		"itemState",
		"ODS_SELECTED",
		"DFCS_PUSHED",
		"hDC",
		"DFC_SCROLL",
		"parent",
		"style",
		"image",
		"listener",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"style",
		"wHint",
		"hHint",
		"changed",
		"enabled",
		"ch",
		"key",
		"listener",
		"alignment",
		"value",
		"image",
		"value",
		"selected",
		"string",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam"
	],
	"extendORImplementFiles":[
		"Control"
	],
	"package":[
		"org.eclipse.swt.widgets"
	],
	"import":[
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt",
		"org.eclipse.swt.graphics",
		"org.eclipse.swt.events"
	],
	"methods":[
		"_setImage",
		"addSelectionListener",
		"callWindowProc",
		"checkStyle",
		"click",
		"computeSize",
		"defaultBackground",
		"defaultForeground",
		"enableWidget",
		"getAlignment",
		"getDefault",
		"getImage",
		"getNameText",
		"getSelection",
		"getText",
		"isTabItem",
		"mnemonicHit",
		"mnemonicMatch",
		"releaseWidget",
		"removeSelectionListener",
		"selectRadio",
		"setAlignment",
		"setDefault",
		"setFixedFocus",
		"setImage",
		"setRadioFocus",
		"setRadioSelection",
		"setSavedFocus",
		"setSelection",
		"setText",
		"widgetStyle",
		"windowClass",
		"windowProc",
		"WM_GETDLGCODE",
		"WM_KILLFOCUS",
		"WM_LBUTTONDOWN",
		"WM_LBUTTONUP",
		"WM_SETFOCUS",
		"WM_SYSCOLORCHANGE",
		"wmColorChild",
		"wmCommandChild",
		"wmDrawChild",
		"LoadBitmap",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"GetObject",
		"DeleteObject",
		"GetClassInfo",
		"checkStyle",
		"IsAppThemed",
		"SendMessage",
		"dispose",
		"add",
		"getHandle",
		"getCodePage",
		"SetWindowText",
		"SendMessage",
		"getCodePage",
		"SetWindowText",
		"SendMessage",
		"dispose",
		"getBounds",
		"getImageData",
		"getTransparencyType",
		"getTransparencyMask",
		"setBackground",
		"getBackground",
		"fillRectangle",
		"drawImage",
		"dispose",
		"VERSION",
		"getBounds",
		"GetDC",
		"CreateCompatibleDC",
		"CreateCompatibleBitmap",
		"SelectObject",
		"SetLayout",
		"CreateCompatibleDC",
		"SelectObject",
		"SetLayout",
		"BitBlt",
		"SelectObject",
		"DeleteDC",
		"CreateSolidBrush",
		"getBackgroundPixel",
		"SelectObject",
		"PatBlt",
		"DrawIconEx",
		"SelectObject",
		"DeleteObject",
		"SelectObject",
		"DeleteDC",
		"ReleaseDC",
		"dispose",
		"win32_new",
		"GetWindowLong",
		"SetWindowLong",
		"SendMessage",
		"checkWidget",
		"error",
		"addListener",
		"addListener",
		"CallWindowProc",
		"checkBits",
		"checkBits",
		"checkBits",
		"checkBits",
		"SendMessage",
		"checkWidget",
		"getBorderWidth",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"IsAppThemed",
		"SendMessage",
		"GetWindowLong",
		"GetDC",
		"SendMessage",
		"SelectObject",
		"GetTextMetrics",
		"length",
		"max",
		"getCodePage",
		"DrawText",
		"SelectObject",
		"ReleaseDC",
		"getBounds",
		"max",
		"GetSysColor",
		"defaultBackground",
		"GetSysColor",
		"enableWidget",
		"IsAppThemed",
		"GetWindowLong",
		"getCodePage",
		"SetWindowText",
		"checkWidget",
		"GetWindowLong",
		"checkWidget",
		"getText",
		"checkWidget",
		"SendMessage",
		"checkWidget",
		"isTabItem",
		"setFocus",
		"click",
		"findMnemonic",
		"getText",
		"toUpperCase",
		"toUpperCase",
		"releaseWidget",
		"dispose",
		"dispose",
		"checkWidget",
		"error",
		"unhook",
		"unhook",
		"_getChildren",
		"setRadioSelection",
		"setSelection",
		"checkWidget",
		"InvalidateRect",
		"GetWindowLong",
		"SetWindowLong",
		"IsAppThemed",
		"getHandle",
		"SendMessage",
		"InvalidateRect",
		"menuShell",
		"GetWindowLong",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"getSelection",
		"setFixedFocus",
		"checkWidget",
		"isDisposed",
		"error",
		"_setImage",
		"getSelection",
		"setFocus",
		"getSelection",
		"setSelection",
		"postEvent",
		"getSelection",
		"setSavedFocus",
		"checkWidget",
		"GetWindowLong",
		"SendMessage",
		"SetWindowLong",
		"checkWidget",
		"error",
		"IsAppThemed",
		"SendMessage",
		"dispose",
		"GetWindowLong",
		"SetWindowLong",
		"IsAppThemed",
		"IsWindowEnabled",
		"getCodePage",
		"SetWindowText",
		"widgetStyle",
		"WM_GETDLGCODE",
		"WM_KILLFOCUS",
		"getDefault",
		"setDefaultButton",
		"menuShell",
		"WM_LBUTTONDOWN",
		"WM_LBUTTONUP",
		"GetWindowLong",
		"WM_SETFOCUS",
		"SetWindowLong",
		"setDefaultButton",
		"menuShell",
		"WM_SYSCOLORCHANGE",
		"_setImage",
		"wmColorChild",
		"IsAppThemed",
		"findThemeControl",
		"SetBkMode",
		"GetClientRect",
		"MapWindowPoints",
		"drawThemeBackground",
		"GetStockObject",
		"setSelection",
		"getSelection",
		"getStyle",
		"setSelection",
		"getSelection",
		"selectRadio",
		"postEvent",
		"wmCommandChild",
		"wmDrawChild",
		"MoveMemory",
		"SetRect",
		"IsAppThemed",
		"OpenThemeData",
		"getEnabled",
		"DrawThemeBackground",
		"CloseThemeData",
		"getEnabled",
		"DrawFrameControl",
		"TCHAR",
		"BITMAP",
		"WNDCLASS",
		"ImageList",
		"BUTTON_IMAGELIST",
		"TCHAR",
		"TCHAR",
		"Image",
		"Image",
		"GC",
		"TypedListener",
		"Point",
		"BUTTON_IMAGELIST",
		"TEXTMETRICW",
		"TEXTMETRICA",
		"TCHAR",
		"RECT",
		"Point",
		"TCHAR",
		"BUTTON_IMAGELIST",
		"TCHAR",
		"LRESULT",
		"RECT",
		"LRESULT",
		"DRAWITEMSTRUCT",
		"RECT"
	],
	"methodsBody":{
		"boolean mnemonicMatch(char key)":{
			"methodBody":"{\n    char mnemonic = findMnemonic(getText());\n    if (mnemonic == '\\0')\n        return false;\n    return Character.toUpperCase(key) == Character.toUpperCase(mnemonic);\n}",
			"comments":"",
			"methodName":"boolean mnemonicMatch(char key)"
		},
		"public void setText(String string)":{
			"methodBody":"{\n    checkWidget();\n    if (string == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if ((style & SWT.ARROW) != 0)\n        return;\n    if (OS.COMCTL32_MAJOR >= 6 && OS.IsAppThemed()) {\n        OS.SendMessage(handle, OS.BCM_SETIMAGELIST, 0, 0);\n        if (imageList != null)\n            imageList.dispose();\n        imageList = null;\n    } else {\n        int newBits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n        int oldBits = newBits;\n        newBits &= ~(OS.BS_BITMAP | OS.BS_ICON);\n        if (newBits != oldBits) {\n            OS.SetWindowLong(handle, OS.GWL_STYLE, newBits);\n        }\n    }\n    text = string;\n    \n    if ((style & SWT.RIGHT_TO_LEFT) != 0) {\n        if (OS.COMCTL32_MAJOR < 6 || !OS.IsAppThemed()) {\n            string = OS.IsWindowEnabled(handle) ? text : text + \" \";\n        }\n    }\n    TCHAR buffer = new TCHAR(getCodePage(), string, true);\n    OS.SetWindowText(handle, buffer);\n}",
			"comments":"/**\n* Sets the receiver's text.\n* <p>\n* This method sets the button label.  The label may include\n* the mnemonic character but must not contain line delimiters.\n* </p>\n* <p>\n* Mnemonics are indicated by an '&amp' that causes the next\n* character to be the mnemonic.  When the user presses a\n* key sequence that matches the mnemonic, a selection\n* event occurs. On most platforms, the mnemonic appears\n* underlined but may be emphasised in a platform specific\n* manner.  The mnemonic indicator character '&amp' can be\n* escaped by doubling it in the string, causing a single\n*'&amp' to be displayed.\n* </p>\n*\n* @param string the new text\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the text is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* Bug in Windows.  When a Button control is right-to-left and\n* is disabled, the first pixel of the text is clipped.  The fix\n* is to append a space to the text.\n*/\n",
			"methodName":"public void setText(String string)"
		},
		"void _setImage(Image image)":{
			"methodBody":"{\n    if (OS.COMCTL32_MAJOR >= 6 && OS.IsAppThemed()) {\n        OS.SendMessage(handle, OS.BCM_SETIMAGELIST, 0, 0);\n        if (imageList != null)\n            imageList.dispose();\n        imageList = null;\n        if (image != null) {\n            imageList = new ImageList(style & SWT.RIGHT_TO_LEFT);\n            imageList.add(image);\n            BUTTON_IMAGELIST buttonImageList = new BUTTON_IMAGELIST();\n            buttonImageList.himl = imageList.getHandle();\n            if ((style & SWT.LEFT) != 0)\n                buttonImageList.uAlign = OS.BUTTON_IMAGELIST_ALIGN_LEFT;\n            if ((style & SWT.CENTER) != 0)\n                buttonImageList.uAlign = OS.BUTTON_IMAGELIST_ALIGN_CENTER;\n            if ((style & SWT.RIGHT) != 0)\n                buttonImageList.uAlign = OS.BUTTON_IMAGELIST_ALIGN_RIGHT;\n            TCHAR buffer = new TCHAR(getCodePage(), \"\", true);\n            OS.SetWindowText(handle, buffer);\n            OS.SendMessage(handle, OS.BCM_SETIMAGELIST, 0, buttonImageList);\n        } else {\n            TCHAR buffer = new TCHAR(getCodePage(), text, true);\n            OS.SetWindowText(handle, buffer);\n            OS.SendMessage(handle, OS.BCM_SETIMAGELIST, 0, 0);\n        }\n    } else {\n        if (image2 != null)\n            image2.dispose();\n        image2 = null;\n        int hImage = 0, imageBits = 0, fImageType = 0;\n        if (image != null) {\n            switch(image.type) {\n                case SWT.BITMAP:\n                    {\n                        Rectangle rect = image.getBounds();\n                        ImageData data = image.getImageData();\n                        switch(data.getTransparencyType()) {\n                            case SWT.TRANSPARENCY_PIXEL:\n                                if (rect.width <= ICON_WIDTH && rect.height <= ICON_HEIGHT) {\n                                    image2 = new Image(display, data, data.getTransparencyMask());\n                                    hImage = image2.handle;\n                                    imageBits = OS.BS_ICON;\n                                    fImageType = OS.IMAGE_ICON;\n                                    break;\n                                }\n                            \n                            case SWT.TRANSPARENCY_ALPHA:\n                                image2 = new Image(display, rect.width, rect.height);\n                                GC gc = new GC(image2);\n                                gc.setBackground(getBackground());\n                                gc.fillRectangle(rect);\n                                gc.drawImage(image, 0, 0);\n                                gc.dispose();\n                                hImage = image2.handle;\n                                imageBits = OS.BS_BITMAP;\n                                fImageType = OS.IMAGE_BITMAP;\n                                break;\n                            case SWT.TRANSPARENCY_NONE:\n                                hImage = image.handle;\n                                imageBits = OS.BS_BITMAP;\n                                fImageType = OS.IMAGE_BITMAP;\n                                break;\n                        }\n                        break;\n                    }\n                case SWT.ICON:\n                    {\n                        hImage = image.handle;\n                        imageBits = OS.BS_ICON;\n                        fImageType = OS.IMAGE_ICON;\n                        break;\n                    }\n            }\n            \n            if ((style & SWT.RIGHT_TO_LEFT) != 0) {\n                if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION(4, 10)) {\n                    Rectangle rect = image.getBounds();\n                    int hDC = OS.GetDC(handle);\n                    int dstHdc = OS.CreateCompatibleDC(hDC);\n                    int hBitmap = OS.CreateCompatibleBitmap(hDC, rect.width, rect.height);\n                    int oldBitmap = OS.SelectObject(dstHdc, hBitmap);\n                    OS.SetLayout(dstHdc, OS.LAYOUT_RTL);\n                    if (fImageType == OS.IMAGE_BITMAP) {\n                        int srcHdc = OS.CreateCompatibleDC(hDC);\n                        int oldSrcBitmap = OS.SelectObject(srcHdc, hImage);\n                        OS.SetLayout(dstHdc, 0);\n                        OS.BitBlt(dstHdc, 0, 0, rect.width, rect.height, srcHdc, 0, 0, OS.SRCCOPY);\n                        OS.SelectObject(srcHdc, oldSrcBitmap);\n                        OS.DeleteDC(srcHdc);\n                    } else {\n                        int newBrush = OS.CreateSolidBrush(getBackgroundPixel());\n                        int oldBrush = OS.SelectObject(dstHdc, newBrush);\n                        OS.PatBlt(dstHdc, 0, 0, rect.width, rect.height, OS.PATCOPY);\n                        OS.DrawIconEx(dstHdc, 0, 0, hImage, 0, 0, 0, 0, OS.DI_NORMAL);\n                        OS.SelectObject(dstHdc, oldBrush);\n                        OS.DeleteObject(newBrush);\n                    }\n                    OS.SelectObject(dstHdc, oldBitmap);\n                    OS.DeleteDC(dstHdc);\n                    OS.ReleaseDC(handle, hDC);\n                    if (image2 != null)\n                        image2.dispose();\n                    image2 = Image.win32_new(display, SWT.BITMAP, hBitmap);\n                    imageBits = OS.BS_BITMAP;\n                    fImageType = OS.IMAGE_BITMAP;\n                    hImage = hBitmap;\n                }\n            }\n        }\n        int newBits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n        int oldBits = newBits;\n        newBits &= ~(OS.BS_BITMAP | OS.BS_ICON);\n        newBits |= imageBits;\n        if (newBits != oldBits)\n            OS.SetWindowLong(handle, OS.GWL_STYLE, newBits);\n        OS.SendMessage(handle, OS.BM_SETIMAGE, fImageType, hImage);\n    }\n}",
			"comments":"//FALL THROUGH\n/*\n* Feature in Windows.  The button control mirrors its image when the\n* flag WS_EX_LAYOUTRTL is set. This behaviour is not desirable in SWT.\n* The fix is to set a mirrored version of real image in the button.\n*/\n",
			"methodName":"void _setImage(Image image)"
		},
		"void enableWidget(boolean enabled)":{
			"methodBody":"{\n    super.enableWidget(enabled);\n    \n    if ((style & SWT.RIGHT_TO_LEFT) != 0) {\n        if (OS.COMCTL32_MAJOR < 6 || !OS.IsAppThemed()) {\n            int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n            boolean hasImage = (bits & (OS.BS_BITMAP | OS.BS_ICON)) != 0;\n            if (!hasImage) {\n                String string = enabled ? text : text + \" \";\n                TCHAR buffer = new TCHAR(getCodePage(), string, true);\n                OS.SetWindowText(handle, buffer);\n            }\n        }\n    }\n}",
			"comments":"/*\n* Bug in Windows.  When a Button control is right-to-left and\n* is disabled, the first pixel of the text is clipped.  The fix\n* is to append a space to the text.\n*/\n",
			"methodName":"void enableWidget(boolean enabled)"
		},
		"boolean getDefault()":{
			"methodBody":"{\n    if ((style & SWT.PUSH) == 0)\n        return false;\n    int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n    return (bits & OS.BS_DEFPUSHBUTTON) != 0;\n}",
			"comments":"",
			"methodName":"boolean getDefault()"
		},
		"public boolean getSelection()":{
			"methodBody":"{\n    checkWidget();\n    if ((style & (SWT.CHECK | SWT.RADIO | SWT.TOGGLE)) == 0)\n        return false;\n    int state = OS.SendMessage(handle, OS.BM_GETCHECK, 0, 0);\n    return (state & OS.BST_CHECKED) != 0;\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver is selected,\n* and false otherwise.\n* <p>\n* When the receiver is of type <code>CHECK</code> or <code>RADIO</code>,\n* it is selected when it is checked. When it is of type <code>TOGGLE</code>,\n* it is selected when it is pushed in. If the receiver is of any other type,\n* this method returns false.\n*\n* @return the selection state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public boolean getSelection()"
		},
		"void setDefault(boolean value)":{
			"methodBody":"{\n    if ((style & SWT.PUSH) == 0)\n        return;\n    int hwndShell = menuShell().handle;\n    int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n    if (value) {\n        bits |= OS.BS_DEFPUSHBUTTON;\n        OS.SendMessage(hwndShell, OS.DM_SETDEFID, handle, 0);\n    } else {\n        bits &= ~OS.BS_DEFPUSHBUTTON;\n        OS.SendMessage(hwndShell, OS.DM_SETDEFID, 0, 0);\n    }\n    OS.SendMessage(handle, OS.BM_SETSTYLE, bits, 1);\n}",
			"comments":"",
			"methodName":"void setDefault(boolean value)"
		},
		"LRESULT wmColorChild(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.wmColorChild(wParam, lParam);\n    if (OS.COMCTL32_MAJOR >= 6 && OS.IsAppThemed()) {\n        Control control = findThemeControl();\n        if (control != null) {\n            OS.SetBkMode(wParam, OS.TRANSPARENT);\n            RECT rect = new RECT();\n            OS.GetClientRect(control.handle, rect);\n            OS.MapWindowPoints(control.handle, handle, rect, 2);\n            control.drawThemeBackground(wParam, rect);\n            return new LRESULT(OS.GetStockObject(OS.NULL_BRUSH));\n        }\n    }\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT wmColorChild(int wParam, int lParam)"
		},
		"int defaultForeground()":{
			"methodBody":"{\n    return OS.GetSysColor(OS.COLOR_BTNTEXT);\n}",
			"comments":"",
			"methodName":"int defaultForeground()"
		},
		"boolean mnemonicHit(char ch)":{
			"methodBody":"{\n    if (!setFocus())\n        return false;\n    \n    if ((style & SWT.RADIO) == 0)\n        click();\n    return true;\n}",
			"comments":"/*\n* Feature in Windows.  When a radio button gets focus,\n* it selects the button in WM_SETFOCUS.  Therefore, it\n* is not necessary to click the button or send events\n* because this has already happened in WM_SETFOCUS.\n*/\n",
			"methodName":"boolean mnemonicHit(char ch)"
		},
		"boolean setFixedFocus()":{
			"methodBody":"{\n    \n    if ((style & SWT.RADIO) != 0 && !getSelection())\n        return false;\n    return super.setFixedFocus();\n}",
			"comments":"/*\n* Feature in Windows.  When a radio button gets focus,\n* it selects the button in WM_SETFOCUS.  The fix is to\n* not assign focus to an unselected radio button.\n*/\n",
			"methodName":"boolean setFixedFocus()"
		},
		"LRESULT WM_SETFOCUS(int wParam, int lParam)":{
			"methodBody":"{\n    \n    int bits = 0;\n    if ((style & SWT.RADIO) != 0) {\n        bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n    }\n    LRESULT result = super.WM_SETFOCUS(wParam, lParam);\n    if ((style & SWT.RADIO) != 0) {\n        OS.SetWindowLong(handle, OS.GWL_STYLE, bits);\n    }\n    if ((style & SWT.PUSH) != 0) {\n        menuShell().setDefaultButton(this, false);\n    }\n    return result;\n}",
			"comments":"/*\n* Feature in Windows. When Windows sets focus to\n* a radio button, it sets the WM_TABSTOP style.\n* This is undocumented and unwanted.  The fix is\n* to save and restore the window style bits.\n*/\n",
			"methodName":"LRESULT WM_SETFOCUS(int wParam, int lParam)"
		},
		"LRESULT wmCommandChild(int wParam, int lParam)":{
			"methodBody":"{\n    int code = wParam >> 16;\n    switch(code) {\n        case OS.BN_CLICKED:\n        case OS.BN_DOUBLECLICKED:\n            if ((style & (SWT.CHECK | SWT.TOGGLE)) != 0) {\n                setSelection(!getSelection());\n            } else {\n                if ((style & SWT.RADIO) != 0) {\n                    if ((parent.getStyle() & SWT.NO_RADIO_GROUP) != 0) {\n                        setSelection(!getSelection());\n                    } else {\n                        selectRadio();\n                    }\n                }\n            }\n            postEvent(SWT.Selection);\n    }\n    return super.wmCommandChild(wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT wmCommandChild(int wParam, int lParam)"
		},
		"boolean setSavedFocus()":{
			"methodBody":"{\n    \n    if ((style & SWT.RADIO) != 0 && !getSelection())\n        return false;\n    return super.setSavedFocus();\n}",
			"comments":"/*\n* Feature in Windows.  When a radio button gets focus,\n* it selects the button in WM_SETFOCUS.  If the previous\n* saved focus widget was a radio button, allowing the shell\n* to automatically restore the focus to the previous radio\n* button will unexpectedly check that button.  The fix is to\n* not assign focus to an unselected radio button.\n*/\n",
			"methodName":"boolean setSavedFocus()"
		},
		"void selectRadio()":{
			"methodBody":"{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Control[] children = parent._getChildren();\n    for (int i = 0; i < children.length; i++) {\n        Control child = children[i];\n        if (this != child)\n            child.setRadioSelection(false);\n    }\n    setSelection(true);\n}",
			"comments":"/*\n* This code is intentionally commented.  When two groups\n* of radio buttons with the same parent are separated by\n* another control, the correct behavior should be that\n* the two groups act independently.  This is consistent\n* with radio tool and menu items.  The commented code\n* implements this behavior.\n*/\n//\tint index = 0;\n//\tControl [] children = parent._getChildren ();\n//\twhile (index < children.length && children [index] != this) index++;\n//\tint i = index - 1;\n//\twhile (i >= 0 && children [i].setRadioSelection (false)) --i;\n//\tint j = index + 1;\n//\twhile (j < children.length && children [j].setRadioSelection (false)) j++;\n//\tsetSelection (true);\n",
			"methodName":"void selectRadio()"
		},
		"LRESULT WM_LBUTTONUP(int wParam, int lParam)":{
			"methodBody":"{\n    if (ignoreMouse)\n        return null;\n    return super.WM_LBUTTONUP(wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_LBUTTONUP(int wParam, int lParam)"
		},
		"static int checkStyle(int style)":{
			"methodBody":"{\n    style = checkBits(style, SWT.PUSH, SWT.ARROW, SWT.CHECK, SWT.RADIO, SWT.TOGGLE, 0);\n    if ((style & (SWT.PUSH | SWT.TOGGLE)) != 0) {\n        return checkBits(style, SWT.CENTER, SWT.LEFT, SWT.RIGHT, 0, 0, 0);\n    }\n    if ((style & (SWT.CHECK | SWT.RADIO)) != 0) {\n        return checkBits(style, SWT.LEFT, SWT.RIGHT, SWT.CENTER, 0, 0, 0);\n    }\n    if ((style & SWT.ARROW) != 0) {\n        style |= SWT.NO_FOCUS;\n        return checkBits(style, SWT.UP, SWT.DOWN, SWT.LEFT, SWT.RIGHT, 0, 0);\n    }\n    return style;\n}",
			"comments":"",
			"methodName":"static int checkStyle(int style)"
		},
		"public void removeSelectionListener(SelectionListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.Selection, listener);\n    eventTable.unhook(SWT.DefaultSelection, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when the control is selected.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see SelectionListener\n* @see #addSelectionListener\n*/\n",
			"methodName":"public void removeSelectionListener(SelectionListener listener)"
		},
		"boolean isTabItem()":{
			"methodBody":"{\n    \n    return super.isTabItem();\n}",
			"comments":"//TEMPORARY CODE\n//if ((style & SWT.PUSH) != 0) return true;\n",
			"methodName":"boolean isTabItem()"
		},
		"LRESULT WM_LBUTTONDOWN(int wParam, int lParam)":{
			"methodBody":"{\n    if (ignoreMouse)\n        return null;\n    return super.WM_LBUTTONDOWN(wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_LBUTTONDOWN(int wParam, int lParam)"
		},
		"LRESULT wmDrawChild(int wParam, int lParam)":{
			"methodBody":"{\n    if ((style & SWT.ARROW) == 0)\n        return super.wmDrawChild(wParam, lParam);\n    DRAWITEMSTRUCT struct = new DRAWITEMSTRUCT();\n    OS.MoveMemory(struct, lParam, DRAWITEMSTRUCT.sizeof);\n    RECT rect = new RECT();\n    OS.SetRect(rect, struct.left, struct.top, struct.right, struct.bottom);\n    if (OS.COMCTL32_MAJOR >= 6 && OS.IsAppThemed()) {\n        int hTheme = OS.OpenThemeData(handle, SCROLLBAR);\n        int iStateId = OS.ABS_LEFTNORMAL;\n        switch(style & (SWT.UP | SWT.DOWN | SWT.LEFT | SWT.RIGHT)) {\n            case SWT.UP:\n                iStateId = OS.ABS_UPNORMAL;\n                break;\n            case SWT.DOWN:\n                iStateId = OS.ABS_DOWNNORMAL;\n                break;\n            case SWT.LEFT:\n                iStateId = OS.ABS_LEFTNORMAL;\n                break;\n            case SWT.RIGHT:\n                iStateId = OS.ABS_RIGHTNORMAL;\n                break;\n        }\n        \n        if (!getEnabled())\n            iStateId += OS.ABS_UPDISABLED - OS.ABS_UPNORMAL;\n        if ((struct.itemState & OS.ODS_SELECTED) != 0)\n            iStateId += OS.ABS_UPPRESSED - OS.ABS_UPNORMAL;\n        OS.DrawThemeBackground(hTheme, struct.hDC, OS.SBP_ARROWBTN, iStateId, rect, null);\n        OS.CloseThemeData(hTheme);\n    } else {\n        int uState = OS.DFCS_SCROLLLEFT;\n        switch(style & (SWT.UP | SWT.DOWN | SWT.LEFT | SWT.RIGHT)) {\n            case SWT.UP:\n                uState = OS.DFCS_SCROLLUP;\n                break;\n            case SWT.DOWN:\n                uState = OS.DFCS_SCROLLDOWN;\n                break;\n            case SWT.LEFT:\n                uState = OS.DFCS_SCROLLLEFT;\n                break;\n            case SWT.RIGHT:\n                uState = OS.DFCS_SCROLLRIGHT;\n                break;\n        }\n        if (!getEnabled())\n            uState |= OS.DFCS_INACTIVE;\n        if ((style & SWT.FLAT) == SWT.FLAT)\n            uState |= OS.DFCS_FLAT;\n        if ((struct.itemState & OS.ODS_SELECTED) != 0)\n            uState |= OS.DFCS_PUSHED;\n        OS.DrawFrameControl(struct.hDC, rect, OS.DFC_SCROLL, uState);\n    }\n    return null;\n}",
			"comments":"/*\n* NOTE: The normal, hot, pressed and disabled state is\n* computed relying on the fact that the increment between\n* the direction states is invariant (always separated by 4).\n*/\n",
			"methodName":"LRESULT wmDrawChild(int wParam, int lParam)"
		},
		"public int getAlignment()":{
			"methodBody":"{\n    checkWidget();\n    if ((style & SWT.ARROW) != 0) {\n        if ((style & SWT.UP) != 0)\n            return SWT.UP;\n        if ((style & SWT.DOWN) != 0)\n            return SWT.DOWN;\n        if ((style & SWT.LEFT) != 0)\n            return SWT.LEFT;\n        if ((style & SWT.RIGHT) != 0)\n            return SWT.RIGHT;\n        return SWT.UP;\n    }\n    if ((style & SWT.LEFT) != 0)\n        return SWT.LEFT;\n    if ((style & SWT.CENTER) != 0)\n        return SWT.CENTER;\n    if ((style & SWT.RIGHT) != 0)\n        return SWT.RIGHT;\n    return SWT.LEFT;\n}",
			"comments":"/**\n* Returns a value which describes the position of the\n* text or image in the receiver. The value will be one of\n* <code>LEFT</code>, <code>RIGHT</code> or <code>CENTER</code>\n* unless the receiver is an <code>ARROW</code> button, in\n* which case, the alignment will indicate the direction of\n* the arrow (one of <code>LEFT</code>, <code>RIGHT</code>,\n* <code>UP</code> or <code>DOWN</code>).\n*\n* @return the alignment\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getAlignment()"
		},
		"public Point computeSize(int wHint, int hHint, boolean changed)":{
			"methodBody":"{\n    checkWidget();\n    int border = getBorderWidth();\n    int width = 0, height = 0;\n    if ((style & SWT.ARROW) != 0) {\n        if ((style & (SWT.UP | SWT.DOWN)) != 0) {\n            width += OS.GetSystemMetrics(OS.SM_CXVSCROLL);\n            height += OS.GetSystemMetrics(OS.SM_CYVSCROLL);\n        } else {\n            width += OS.GetSystemMetrics(OS.SM_CXHSCROLL);\n            height += OS.GetSystemMetrics(OS.SM_CYHSCROLL);\n        }\n        if (wHint != SWT.DEFAULT)\n            width = wHint;\n        if (hHint != SWT.DEFAULT)\n            height = hHint;\n        width += border * 2;\n        height += border * 2;\n        return new Point(width, height);\n    }\n    int extra = 0;\n    boolean hasImage;\n    if (OS.COMCTL32_MAJOR >= 6 && OS.IsAppThemed()) {\n        BUTTON_IMAGELIST buttonImageList = new BUTTON_IMAGELIST();\n        OS.SendMessage(handle, OS.BCM_GETIMAGELIST, 0, buttonImageList);\n        hasImage = buttonImageList.himl != 0;\n    } else {\n        int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n        hasImage = (bits & (OS.BS_BITMAP | OS.BS_ICON)) != 0;\n    }\n    if (!hasImage) {\n        int oldFont = 0;\n        int hDC = OS.GetDC(handle);\n        int newFont = OS.SendMessage(handle, OS.WM_GETFONT, 0, 0);\n        if (newFont != 0)\n            oldFont = OS.SelectObject(hDC, newFont);\n        TEXTMETRIC lptm = OS.IsUnicode ? (TEXTMETRIC) new TEXTMETRICW() : new TEXTMETRICA();\n        OS.GetTextMetrics(hDC, lptm);\n        int length = text.length();\n        if (length == 0) {\n            height += lptm.tmHeight;\n        } else {\n            extra = Math.max(8, lptm.tmAveCharWidth);\n            TCHAR buffer = new TCHAR(getCodePage(), text, true);\n            RECT rect = new RECT();\n            int flags = OS.DT_CALCRECT | OS.DT_SINGLELINE;\n            OS.DrawText(hDC, buffer, -1, rect, flags);\n            width += rect.right - rect.left;\n            height += rect.bottom - rect.top;\n        }\n        if (newFont != 0)\n            OS.SelectObject(hDC, oldFont);\n        OS.ReleaseDC(handle, hDC);\n    } else {\n        if (image != null) {\n            Rectangle rect = image.getBounds();\n            width = rect.width;\n            height = rect.height;\n            extra = 8;\n        }\n    }\n    if ((style & (SWT.CHECK | SWT.RADIO)) != 0) {\n        width += CHECK_WIDTH + extra;\n        height = Math.max(height, CHECK_HEIGHT + 3);\n    }\n    if ((style & (SWT.PUSH | SWT.TOGGLE)) != 0) {\n        width += 12;\n        height += 10;\n    }\n    if (wHint != SWT.DEFAULT)\n        width = wHint;\n    if (hHint != SWT.DEFAULT)\n        height = hHint;\n    width += border * 2;\n    height += border * 2;\n    return new Point(width, height);\n}",
			"comments":"",
			"methodName":"public Point computeSize(int wHint, int hHint, boolean changed)"
		},
		"int defaultBackground()":{
			"methodBody":"{\n    if ((style & (SWT.PUSH | SWT.TOGGLE)) != 0) {\n        return OS.GetSysColor(OS.COLOR_BTNFACE);\n    }\n    return super.defaultBackground();\n}",
			"comments":"",
			"methodName":"int defaultBackground()"
		},
		"boolean setRadioFocus()":{
			"methodBody":"{\n    if ((style & SWT.RADIO) == 0 || !getSelection())\n        return false;\n    return setFocus();\n}",
			"comments":"",
			"methodName":"boolean setRadioFocus()"
		},
		"public Image getImage()":{
			"methodBody":"{\n    checkWidget();\n    return image;\n}",
			"comments":"/**\n* Returns the receiver's image if it has one, or null\n* if it does not.\n*\n* @return the receiver's image\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Image getImage()"
		},
		"TCHAR windowClass()":{
			"methodBody":"{\n    return ButtonClass;\n}",
			"comments":"",
			"methodName":"TCHAR windowClass()"
		},
		"public void setSelection(boolean selected)":{
			"methodBody":"{\n    checkWidget();\n    if ((style & (SWT.CHECK | SWT.RADIO | SWT.TOGGLE)) == 0)\n        return;\n    int flags = selected ? OS.BST_CHECKED : OS.BST_UNCHECKED;\n    \n    int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n    OS.SendMessage(handle, OS.BM_SETCHECK, flags, 0);\n    OS.SetWindowLong(handle, OS.GWL_STYLE, bits);\n}",
			"comments":"/**\n* Sets the selection state of the receiver, if it is of type <code>CHECK</code>,\n* <code>RADIO</code>, or <code>TOGGLE</code>.\n*\n* <p>\n* When the receiver is of type <code>CHECK</code> or <code>RADIO</code>,\n* it is selected when it is checked. When it is of type <code>TOGGLE</code>,\n* it is selected when it is pushed in.\n*\n* @param selected the new selection state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* Feature in Windows. When BM_SETCHECK is used\n* to set the checked state of a radio or check\n* button, it sets the WM_TABSTOP style.  This\n* is undocumented and unwanted.  The fix is\n* to save and restore the window style bits.\n*/\n",
			"methodName":"public void setSelection(boolean selected)"
		},
		"public void setImage(Image image)":{
			"methodBody":"{\n    checkWidget();\n    if (image != null && image.isDisposed())\n        error(SWT.ERROR_INVALID_ARGUMENT);\n    _setImage(this.image = image);\n}",
			"comments":"/**\n* Sets the receiver's image to the argument, which may be\n* <code>null</code> indicating that no image should be displayed.\n*\n* @param image the image to display on the receiver (may be <code>null</code>)\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the image has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setImage(Image image)"
		},
		"boolean setRadioSelection(boolean value)":{
			"methodBody":"{\n    if ((style & SWT.RADIO) == 0)\n        return false;\n    if (getSelection() != value) {\n        setSelection(value);\n        postEvent(SWT.Selection);\n    }\n    return true;\n}",
			"comments":"",
			"methodName":"boolean setRadioSelection(boolean value)"
		},
		"void click()":{
			"methodBody":"{\n    \n    ignoreMouse = true;\n    OS.SendMessage(handle, OS.BM_CLICK, 0, 0);\n    ignoreMouse = false;\n}",
			"comments":"/*\n* Feature in Windows.  BM_CLICK sends a fake WM_LBUTTONDOWN and\n* WM_LBUTTONUP in order to click the button.  This causes the\n* application to get unexpected mouse events.  The fix is to\n* ignore mouse events when they are caused by BM_CLICK.\n*/\n",
			"methodName":"void click()"
		},
		"LRESULT WM_SYSCOLORCHANGE(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_SYSCOLORCHANGE(wParam, lParam);\n    if (result != null)\n        return result;\n    if (image2 != null)\n        _setImage(image);\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_SYSCOLORCHANGE(int wParam, int lParam)"
		},
		"String getNameText()":{
			"methodBody":"{\n    return getText();\n}",
			"comments":"",
			"methodName":"String getNameText()"
		},
		"public void setAlignment(int alignment)":{
			"methodBody":"{\n    checkWidget();\n    if ((style & SWT.ARROW) != 0) {\n        if ((style & (SWT.UP | SWT.DOWN | SWT.LEFT | SWT.RIGHT)) == 0)\n            return;\n        style &= ~(SWT.UP | SWT.DOWN | SWT.LEFT | SWT.RIGHT);\n        style |= alignment & (SWT.UP | SWT.DOWN | SWT.LEFT | SWT.RIGHT);\n        OS.InvalidateRect(handle, null, true);\n        return;\n    }\n    if ((alignment & (SWT.LEFT | SWT.RIGHT | SWT.CENTER)) == 0)\n        return;\n    style &= ~(SWT.LEFT | SWT.RIGHT | SWT.CENTER);\n    style |= alignment & (SWT.LEFT | SWT.RIGHT | SWT.CENTER);\n    int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n    bits &= ~(OS.BS_LEFT | OS.BS_CENTER | OS.BS_RIGHT);\n    if ((style & SWT.LEFT) != 0)\n        bits |= OS.BS_LEFT;\n    if ((style & SWT.CENTER) != 0)\n        bits |= OS.BS_CENTER;\n    if ((style & SWT.RIGHT) != 0)\n        bits |= OS.BS_RIGHT;\n    OS.SetWindowLong(handle, OS.GWL_STYLE, bits);\n    if (OS.COMCTL32_MAJOR >= 6 && OS.IsAppThemed()) {\n        if (imageList != null) {\n            BUTTON_IMAGELIST buttonImageList = new BUTTON_IMAGELIST();\n            buttonImageList.himl = imageList.getHandle();\n            if ((style & SWT.LEFT) != 0)\n                buttonImageList.uAlign = OS.BUTTON_IMAGELIST_ALIGN_LEFT;\n            if ((style & SWT.CENTER) != 0)\n                buttonImageList.uAlign = OS.BUTTON_IMAGELIST_ALIGN_CENTER;\n            if ((style & SWT.RIGHT) != 0)\n                buttonImageList.uAlign = OS.BUTTON_IMAGELIST_ALIGN_RIGHT;\n            OS.SendMessage(handle, OS.BCM_SETIMAGELIST, 0, buttonImageList);\n        }\n    }\n    OS.InvalidateRect(handle, null, true);\n}",
			"comments":"/**\n* Controls how text, images and arrows will be displayed\n* in the receiver. The argument should be one of\n* <code>LEFT</code>, <code>RIGHT</code> or <code>CENTER</code>\n* unless the receiver is an <code>ARROW</code> button, in\n* which case, the argument indicates the direction of\n* the arrow (one of <code>LEFT</code>, <code>RIGHT</code>,\n* <code>UP</code> or <code>DOWN</code>).\n*\n* @param alignment the new alignment\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setAlignment(int alignment)"
		},
		"LRESULT WM_KILLFOCUS(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_KILLFOCUS(wParam, lParam);\n    if ((style & SWT.PUSH) != 0 && getDefault()) {\n        menuShell().setDefaultButton(null, false);\n    }\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_KILLFOCUS(int wParam, int lParam)"
		},
		"void releaseWidget()":{
			"methodBody":"{\n    super.releaseWidget();\n    if (imageList != null)\n        imageList.dispose();\n    imageList = null;\n    if (image2 != null)\n        image2.dispose();\n    image2 = null;\n    text = null;\n    image = null;\n}",
			"comments":"",
			"methodName":"void releaseWidget()"
		},
		"public String getText()":{
			"methodBody":"{\n    checkWidget();\n    if ((style & SWT.ARROW) != 0)\n        return \"\";\n    return text;\n}",
			"comments":"/**\n* Returns the receiver's text, which will be an empty\n* string if it has never been set or if the receiver is\n* an <code>ARROW</code> button.\n*\n* @return the receiver's text\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public String getText()"
		},
		"LRESULT WM_GETDLGCODE(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_GETDLGCODE(wParam, lParam);\n    if (result != null)\n        return result;\n    if ((style & SWT.ARROW) != 0) {\n        return new LRESULT(OS.DLGC_STATIC);\n    }\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_GETDLGCODE(int wParam, int lParam)"
		},
		"int windowProc()":{
			"methodBody":"{\n    return ButtonProc;\n}",
			"comments":"",
			"methodName":"int windowProc()"
		},
		"public void addSelectionListener(SelectionListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.Selection, typedListener);\n    addListener(SWT.DefaultSelection, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when the control is selected, by sending\n* it one of the messages defined in the <code>SelectionListener</code>\n* interface.\n* <p>\n* <code>widgetSelected</code> is called when the control is selected.\n* <code>widgetDefaultSelected</code> is not called.\n* </p>\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see SelectionListener\n* @see #removeSelectionListener\n* @see SelectionEvent\n*/\n",
			"methodName":"public void addSelectionListener(SelectionListener listener)"
		},
		"int callWindowProc(int hwnd, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    if (handle == 0)\n        return 0;\n    return OS.CallWindowProc(ButtonProc, hwnd, msg, wParam, lParam);\n}",
			"comments":"",
			"methodName":"int callWindowProc(int hwnd, int msg, int wParam, int lParam)"
		},
		"int widgetStyle()":{
			"methodBody":"{\n    int bits = super.widgetStyle();\n    if ((style & SWT.FLAT) != 0)\n        bits |= OS.BS_FLAT;\n    if ((style & SWT.ARROW) != 0)\n        return bits | OS.BS_OWNERDRAW;\n    if ((style & SWT.LEFT) != 0)\n        bits |= OS.BS_LEFT;\n    if ((style & SWT.CENTER) != 0)\n        bits |= OS.BS_CENTER;\n    if ((style & SWT.RIGHT) != 0)\n        bits |= OS.BS_RIGHT;\n    if ((style & SWT.PUSH) != 0)\n        return bits | OS.BS_PUSHBUTTON | OS.WS_TABSTOP;\n    if ((style & SWT.CHECK) != 0)\n        return bits | OS.BS_CHECKBOX | OS.WS_TABSTOP;\n    if ((style & SWT.RADIO) != 0)\n        return bits | OS.BS_RADIOBUTTON;\n    if ((style & SWT.TOGGLE) != 0)\n        return bits | OS.BS_PUSHLIKE | OS.BS_CHECKBOX | OS.WS_TABSTOP;\n    return bits | OS.BS_PUSHBUTTON | OS.WS_TABSTOP;\n}",
			"comments":"",
			"methodName":"int widgetStyle()"
		}
	},
	"ClassORInterfaceName":[
		"Button"
	]
}
