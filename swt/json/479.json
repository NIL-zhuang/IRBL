{
	"variables":[
		"items",
		"columns",
		"hwndParent",
		"hwndHeader",
		"hAnchor",
		"hInsert",
		"imageList",
		"dragStarted",
		"gestureCompleted",
		"insertAfter",
		"ignoreSelect",
		"ignoreExpand",
		"ignoreDeselect",
		"ignoreResize",
		"lockSelection",
		"oldSelected",
		"newSelected",
		"linesVisible",
		"customDraw",
		"printClient",
		"INSET",
		"GRID_WIDTH",
		"HEADER_MARGIN",
		"TreeProc",
		"TreeClass",
		"BUTTON",
		"lpWndClass",
		"pixel",
		"oldPixel",
		"typedListener",
		"typedListener",
		"display",
		"code",
		"code",
		"hRoot",
		"hParent",
		"width",
		"height",
		"hdItem",
		"count",
		"i",
		"rect",
		"rect",
		"hItem",
		"border",
		"hFont",
		"columnCount",
		"newColumns",
		"i",
		"item",
		"strings",
		"temp",
		"images",
		"temp",
		"cellBackground",
		"temp",
		"cellForeground",
		"temp",
		"cellFont",
		"temp",
		"hHeap",
		"pszText",
		"hdItem",
		"bits",
		"id",
		"newItems",
		"tvInsert",
		"hItem",
		"hChild",
		"rect",
		"rect",
		"oldStyle",
		"newStyle",
		"bits",
		"hIMC",
		"oldExStyle",
		"hFont",
		"hImageList",
		"hwndInsertAfter",
		"flags",
		"info",
		"hwndFocus",
		"tvItem",
		"hItem",
		"oldProc",
		"i",
		"item",
		"columnCount",
		"index",
		"i",
		"item",
		"strings",
		"temp",
		"images",
		"temp",
		"cellBackground",
		"temp",
		"cellForeground",
		"temp",
		"cellFont",
		"temp",
		"bits",
		"hdItem",
		"rect",
		"itemRect",
		"i",
		"hItem",
		"hParent",
		"fixRedraw",
		"rect",
		"tvItem",
		"rect",
		"count",
		"tvItem",
		"lParam",
		"pixel",
		"rect",
		"bits",
		"count",
		"count",
		"result",
		"hItem",
		"tvItem",
		"lpht",
		"tvItem",
		"hItem",
		"count",
		"hItem",
		"count",
		"hItem",
		"index",
		"result",
		"tvItem",
		"item",
		"newResult",
		"hItem",
		"tvItem",
		"count",
		"guess",
		"tvItem",
		"oldProc",
		"i",
		"item",
		"result",
		"index",
		"i",
		"item",
		"hItem",
		"tvItem",
		"count",
		"tvItem",
		"oldProc",
		"i",
		"item",
		"hItem",
		"tvItem",
		"hOldList",
		"bounds",
		"index",
		"hImageList",
		"index",
		"index",
		"count",
		"i",
		"hItem",
		"hItem",
		"i",
		"item",
		"sons",
		"columnCount",
		"i",
		"item",
		"i",
		"column",
		"hOldList",
		"hOldList",
		"redraw",
		"result",
		"i",
		"item",
		"hItem",
		"count",
		"tvItem",
		"oldProc",
		"i",
		"item",
		"fixSelection",
		"hItem",
		"cursor",
		"hCursor",
		"count",
		"height",
		"width",
		"flags",
		"hImageList",
		"hDC",
		"memDC",
		"hBitmap",
		"hOldBitmap",
		"rect",
		"clrBackground",
		"hBrush",
		"oldFont",
		"tm",
		"itemWidth",
		"itemHeight",
		"left",
		"top",
		"hTheme",
		"hOldList",
		"bits",
		"hItem",
		"count",
		"tvInsert",
		"width",
		"hdItem",
		"count",
		"i",
		"left",
		"rect",
		"info",
		"hHeap",
		"playout",
		"pos",
		"w",
		"h",
		"oldIgnore",
		"length",
		"item",
		"hOldItem",
		"hNewItem",
		"fixScroll",
		"tvItem",
		"tvItem",
		"oldProc",
		"i",
		"index",
		"hItem",
		"fixScroll",
		"fixScroll",
		"scroll",
		"itemRect",
		"rect",
		"pt",
		"fixScroll",
		"itemRect",
		"rect",
		"pt",
		"info",
		"index",
		"count",
		"rect",
		"x",
		"hdItem",
		"i",
		"pt",
		"info",
		"hItem",
		"tvItem",
		"tvItem",
		"oldProc",
		"index",
		"item",
		"hwndToolTip",
		"columnCount",
		"info",
		"itemCount",
		"bits",
		"code",
		"info",
		"code",
		"code",
		"result",
		"hItem",
		"tvItem",
		"state",
		"id",
		"event",
		"event",
		"hItem",
		"tvItem",
		"result",
		"hItem",
		"code",
		"hNewItem",
		"tvItem",
		"hDeselectItem",
		"rect1",
		"rect2",
		"flags",
		"hSelectItem",
		"event",
		"hItem",
		"tvItem",
		"oldSelected",
		"hNewItem",
		"rect",
		"clientRect",
		"hVisible",
		"newSelected",
		"rect1",
		"rect2",
		"bits",
		"fItemRect",
		"flags",
		"code",
		"result",
		"lpht",
		"tvItem",
		"state",
		"id",
		"event",
		"result",
		"event",
		"tvItem",
		"lpht",
		"fixSelection",
		"deselected",
		"hSelection",
		"tvItem",
		"hParent",
		"hLast",
		"hNext",
		"code",
		"tvItem",
		"event",
		"tvItem",
		"state",
		"id",
		"event",
		"tvItem",
		"hittestSelected",
		"hOldItem",
		"code",
		"hNewItem",
		"rect1",
		"rect2",
		"bits",
		"fItemRect",
		"flags",
		"oldProc",
		"i",
		"item",
		"rect1",
		"rect2",
		"flags",
		"hItem",
		"event",
		"event",
		"hdr",
		"phdn",
		"column",
		"phdn",
		"newItem",
		"oldItem",
		"deltaX",
		"rect",
		"itemRect",
		"gridWidth",
		"count",
		"i",
		"flags",
		"phdn",
		"pitem",
		"column",
		"count",
		"newColumns",
		"i",
		"phdn",
		"column",
		"phdn",
		"column",
		"lpht",
		"tvItem",
		"result",
		"code",
		"result",
		"result",
		"result",
		"hdr",
		"lptvdi",
		"item",
		"string",
		"buffer",
		"byteCount",
		"image",
		"nmcd",
		"hDC",
		"x",
		"rect",
		"hdItem",
		"count",
		"i",
		"rect",
		"hItem",
		"height",
		"top",
		"item",
		"hDC",
		"rect",
		"count",
		"hdItem",
		"hRgn",
		"hFont",
		"tvItem",
		"clrText",
		"clrTextBk",
		"item",
		"hDC",
		"useColor",
		"tvItem",
		"clrForeground",
		"clrBackground",
		"data",
		"gc",
		"x",
		"gridWidth",
		"size",
		"rect",
		"hdItem",
		"count",
		"i",
		"clrTextBk",
		"image",
		"bounds",
		"hFont",
		"clrText",
		"flags",
		"column",
		"buffer",
		"count",
		"hdItem",
		"rect",
		"rect",
		"hItem",
		"tvItem",
		"tvItem",
		"offset",
		"tvItem",
		"offset",
		"tvItem",
		"offset",
		"event",
		"tvItem",
		"offset1",
		"offset2",
		"tvItem",
		"offset",
		"item",
		"event",
		"action",
		"tvItem",
		"offset",
		"hasMenu",
		"hasMenu",
		"nmrg",
		"OS",
		"OS",
		"TreeClass",
		"lpWndClass",
		"TreeProc",
		"lpWndClass",
		"parent",
		"style",
		"style",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"OS",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"pixel",
		"OS",
		"OS",
		"pixel",
		"OS",
		"handle",
		"OS",
		"oldPixel",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"pixel",
		"style",
		"SWT",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"SWT",
		"typedListener",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"SWT",
		"typedListener",
		"hwndParent",
		"hwndParent",
		"handle",
		"handle",
		"hwndParent",
		"hwnd",
		"hwndParent",
		"OS",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"msg",
		"OS",
		"OS",
		"OS",
		"OS",
		"display",
		"OS",
		"TreeProc",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"display",
		"code",
		"OS",
		"OS",
		"TreeProc",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"code",
		"OS",
		"TreeProc",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"hwnd",
		"handle",
		"hwndParent",
		"hwnd",
		"hwndParent",
		"drawCount",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"hItem",
		"hParent",
		"hRoot",
		"hParent",
		"hParent",
		"OS",
		"handle",
		"OS",
		"OS",
		"hParent",
		"hParent",
		"SWT",
		"hwndHeader",
		"hdItem",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"i",
		"count",
		"i",
		"OS",
		"hwndHeader",
		"OS",
		"i",
		"hdItem",
		"width",
		"hdItem",
		"OS",
		"hwndHeader",
		"rect",
		"height",
		"rect",
		"rect",
		"OS",
		"handle",
		"OS",
		"OS",
		"hItem",
		"rect",
		"hItem",
		"OS",
		"handle",
		"OS",
		"rect",
		"width",
		"Math",
		"width",
		"rect",
		"height",
		"rect",
		"rect",
		"hItem",
		"OS",
		"handle",
		"OS",
		"OS",
		"hItem",
		"width",
		"width",
		"DEFAULT_WIDTH",
		"height",
		"height",
		"DEFAULT_HEIGHT",
		"wHint",
		"SWT",
		"width",
		"wHint",
		"hHint",
		"SWT",
		"height",
		"hHint",
		"width",
		"border",
		"height",
		"border",
		"style",
		"SWT",
		"width",
		"OS",
		"OS",
		"style",
		"SWT",
		"height",
		"OS",
		"OS",
		"width",
		"height",
		"state",
		"CANVAS",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"style",
		"SWT",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"hFont",
		"hwndHeader",
		"OS",
		"hwndHeader",
		"OS",
		"index",
		"index",
		"columnCount",
		"SWT",
		"columnCount",
		"columns",
		"columns",
		"System",
		"columns",
		"newColumns",
		"columns",
		"columns",
		"newColumns",
		"i",
		"items",
		"i",
		"items",
		"i",
		"item",
		"item",
		"strings",
		"columnCount",
		"System",
		"strings",
		"temp",
		"index",
		"System",
		"strings",
		"index",
		"temp",
		"index",
		"columnCount",
		"index",
		"item",
		"temp",
		"item",
		"images",
		"columnCount",
		"System",
		"images",
		"temp",
		"index",
		"System",
		"images",
		"index",
		"temp",
		"index",
		"columnCount",
		"index",
		"item",
		"temp",
		"index",
		"columnCount",
		"strings",
		"item",
		"columnCount",
		"item",
		"item",
		"item",
		"images",
		"item",
		"columnCount",
		"item",
		"item",
		"item",
		"item",
		"item",
		"columnCount",
		"System",
		"cellBackground",
		"temp",
		"index",
		"System",
		"cellBackground",
		"index",
		"temp",
		"index",
		"columnCount",
		"index",
		"temp",
		"index",
		"item",
		"temp",
		"item",
		"item",
		"columnCount",
		"System",
		"cellForeground",
		"temp",
		"index",
		"System",
		"cellForeground",
		"index",
		"temp",
		"index",
		"columnCount",
		"index",
		"temp",
		"index",
		"item",
		"temp",
		"item",
		"item",
		"columnCount",
		"System",
		"cellFont",
		"temp",
		"index",
		"System",
		"cellFont",
		"index",
		"temp",
		"index",
		"columnCount",
		"index",
		"temp",
		"index",
		"item",
		"temp",
		"System",
		"columns",
		"index",
		"columns",
		"index",
		"columnCount",
		"index",
		"columns",
		"index",
		"column",
		"OS",
		"OS",
		"hHeap",
		"OS",
		"TCHAR",
		"hdItem",
		"OS",
		"OS",
		"hdItem",
		"pszText",
		"column",
		"SWT",
		"SWT",
		"hdItem",
		"OS",
		"column",
		"SWT",
		"SWT",
		"hdItem",
		"OS",
		"column",
		"SWT",
		"SWT",
		"hdItem",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"index",
		"hdItem",
		"pszText",
		"OS",
		"hHeap",
		"pszText",
		"columnCount",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"OS",
		"handle",
		"OS",
		"bits",
		"columnCount",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"id",
		"items",
		"items",
		"id",
		"id",
		"id",
		"items",
		"items",
		"System",
		"items",
		"newItems",
		"items",
		"items",
		"newItems",
		"tvInsert",
		"hParent",
		"tvInsert",
		"hInsertAfter",
		"tvInsert",
		"id",
		"tvInsert",
		"OS",
		"tvInsert",
		"tvInsert",
		"OS",
		"tvInsert",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"style",
		"SWT",
		"tvInsert",
		"tvInsert",
		"OS",
		"tvInsert",
		"tvInsert",
		"OS",
		"OS",
		"handle",
		"OS",
		"tvInsert",
		"hItem",
		"SWT",
		"item",
		"hItem",
		"items",
		"id",
		"item",
		"OS",
		"handle",
		"drawCount",
		"OS",
		"handle",
		"OS",
		"OS",
		"hParent",
		"hChild",
		"OS",
		"handle",
		"OS",
		"OS",
		"hChild",
		"rect",
		"hParent",
		"OS",
		"handle",
		"OS",
		"rect",
		"OS",
		"handle",
		"rect",
		"OS",
		"handle",
		"rect",
		"OS",
		"parent",
		"rect",
		"OS",
		"handle",
		"OS",
		"OS",
		"oldStyle",
		"OS",
		"newStyle",
		"OS",
		"hwndParent",
		"OS",
		"newStyle",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"parent",
		"OS",
		"hwndParent",
		"SWT",
		"OS",
		"hwndParent",
		"OS",
		"hwndParent",
		"OS",
		"OS",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"hwndHeader",
		"OS",
		"bits",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"hwndParent",
		"OS",
		"hwndHeader",
		"SWT",
		"OS",
		"hwndHeader",
		"OS",
		"hwndHeader",
		"OS",
		"OS",
		"handle",
		"OS",
		"hwndParent",
		"hIMC",
		"OS",
		"hwndHeader",
		"hIMC",
		"OS",
		"handle",
		"hIMC",
		"OS",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"oldExStyle",
		"OS",
		"OS",
		"handle",
		"OS",
		"oldExStyle",
		"OS",
		"handle",
		"OS",
		"hFont",
		"OS",
		"hwndHeader",
		"OS",
		"hFont",
		"OS",
		"handle",
		"OS",
		"OS",
		"hImageList",
		"OS",
		"hwndHeader",
		"OS",
		"hImageList",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"OS",
		"hwndParent",
		"hwndInsertAfter",
		"flags",
		"info",
		"SCROLLINFO",
		"info",
		"OS",
		"OS",
		"OS",
		"hwndParent",
		"OS",
		"info",
		"info",
		"info",
		"OS",
		"hwndParent",
		"OS",
		"info",
		"OS",
		"hwndParent",
		"OS",
		"info",
		"info",
		"info",
		"OS",
		"hwndParent",
		"OS",
		"info",
		"customDraw",
		"oldStyle",
		"OS",
		"OS",
		"hwndParent",
		"OS",
		"OS",
		"hwndFocus",
		"handle",
		"OS",
		"hwndParent",
		"OS",
		"handle",
		"hwndParent",
		"hwndFocus",
		"handle",
		"OS",
		"handle",
		"items",
		"columns",
		"OS",
		"OS",
		"hwndParent",
		"display",
		"hwndParent",
		"tvItem",
		"OS",
		"tvItem",
		"OS",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"OS",
		"hItem",
		"tvItem",
		"hItem",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"TreeProc",
		"i",
		"items",
		"i",
		"items",
		"i",
		"item",
		"tvItem",
		"item",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"OS",
		"handle",
		"OS",
		"oldProc",
		"hwndHeader",
		"SWT",
		"OS",
		"hwndHeader",
		"OS",
		"index",
		"columnCount",
		"columns",
		"index",
		"column",
		"index",
		"OS",
		"hwndHeader",
		"OS",
		"index",
		"SWT",
		"System",
		"columns",
		"index",
		"columns",
		"index",
		"columnCount",
		"index",
		"columns",
		"columnCount",
		"i",
		"items",
		"i",
		"items",
		"i",
		"item",
		"columnCount",
		"item",
		"item",
		"item",
		"item",
		"item",
		"item",
		"item",
		"index",
		"item",
		"strings",
		"strings",
		"columnCount",
		"System",
		"strings",
		"temp",
		"index",
		"System",
		"strings",
		"index",
		"temp",
		"index",
		"columnCount",
		"index",
		"item",
		"temp",
		"index",
		"item",
		"item",
		"item",
		"index",
		"item",
		"images",
		"columnCount",
		"System",
		"images",
		"temp",
		"index",
		"System",
		"images",
		"index",
		"temp",
		"index",
		"columnCount",
		"index",
		"item",
		"temp",
		"index",
		"item",
		"item",
		"item",
		"columnCount",
		"System",
		"cellBackground",
		"temp",
		"index",
		"System",
		"cellBackground",
		"index",
		"temp",
		"index",
		"columnCount",
		"index",
		"item",
		"temp",
		"item",
		"item",
		"columnCount",
		"System",
		"cellForeground",
		"temp",
		"index",
		"System",
		"cellForeground",
		"index",
		"temp",
		"index",
		"columnCount",
		"index",
		"item",
		"temp",
		"item",
		"item",
		"columnCount",
		"System",
		"cellFont",
		"temp",
		"index",
		"System",
		"cellFont",
		"index",
		"temp",
		"index",
		"columnCount",
		"index",
		"item",
		"temp",
		"columnCount",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"handle",
		"index",
		"columns",
		"SWT",
		"SWT",
		"SWT",
		"columns",
		"SWT",
		"hdItem",
		"OS",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"index",
		"hdItem",
		"hdItem",
		"OS",
		"hdItem",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"index",
		"hdItem",
		"OS",
		"handle",
		"rect",
		"OS",
		"hwndHeader",
		"OS",
		"index",
		"itemRect",
		"rect",
		"itemRect",
		"OS",
		"handle",
		"rect",
		"index",
		"i",
		"columnCount",
		"i",
		"columns",
		"i",
		"SWT",
		"item",
		"drawCount",
		"OS",
		"handle",
		"rect",
		"hItem",
		"fixRedraw",
		"OS",
		"handle",
		"OS",
		"rect",
		"fixRedraw",
		"hParent",
		"OS",
		"handle",
		"OS",
		"OS",
		"hItem",
		"OS",
		"handle",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"OS",
		"OS",
		"item",
		"tvItem",
		"item",
		"tvItem",
		"style",
		"SWT",
		"ignoreDeselect",
		"ignoreSelect",
		"lockSelection",
		"OS",
		"handle",
		"OS",
		"hItem",
		"style",
		"SWT",
		"ignoreDeselect",
		"ignoreSelect",
		"lockSelection",
		"fixRedraw",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"handle",
		"OS",
		"OS",
		"hParent",
		"rect",
		"hParent",
		"OS",
		"handle",
		"OS",
		"rect",
		"OS",
		"handle",
		"rect",
		"OS",
		"handle",
		"OS",
		"count",
		"imageList",
		"OS",
		"handle",
		"OS",
		"hwndHeader",
		"OS",
		"hwndHeader",
		"OS",
		"display",
		"imageList",
		"imageList",
		"hwndParent",
		"customDraw",
		"items",
		"enabled",
		"background",
		"enabled",
		"background",
		"hwndParent",
		"OS",
		"hwndParent",
		"enabled",
		"tvItem",
		"OS",
		"OS",
		"tvItem",
		"id",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"tvItem",
		"lParam",
		"lParam",
		"items",
		"items",
		"lParam",
		"OS",
		"OS",
		"handle",
		"background",
		"background",
		"OS",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"pixel",
		"OS",
		"OS",
		"pixel",
		"GRID_WIDTH",
		"hwndHeader",
		"OS",
		"hwndHeader",
		"rect",
		"rect",
		"rect",
		"hwndHeader",
		"OS",
		"hwndHeader",
		"OS",
		"bits",
		"OS",
		"imageList",
		"imageList",
		"hwndHeader",
		"SWT",
		"OS",
		"hwndHeader",
		"OS",
		"index",
		"index",
		"count",
		"SWT",
		"columns",
		"index",
		"hwndHeader",
		"OS",
		"hwndHeader",
		"OS",
		"hwndHeader",
		"OS",
		"hwndHeader",
		"OS",
		"count",
		"System",
		"columns",
		"result",
		"count",
		"result",
		"index",
		"SWT",
		"OS",
		"handle",
		"OS",
		"OS",
		"index",
		"hItem",
		"hItem",
		"OS",
		"handle",
		"OS",
		"OS",
		"hItem",
		"hItem",
		"SWT",
		"tvItem",
		"OS",
		"OS",
		"tvItem",
		"hItem",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"items",
		"tvItem",
		"point",
		"SWT",
		"lpht",
		"point",
		"lpht",
		"point",
		"OS",
		"handle",
		"OS",
		"lpht",
		"lpht",
		"style",
		"SWT",
		"lpht",
		"OS",
		"tvItem",
		"OS",
		"OS",
		"tvItem",
		"lpht",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"items",
		"tvItem",
		"OS",
		"handle",
		"OS",
		"OS",
		"hItem",
		"hItem",
		"hItem",
		"hItem",
		"OS",
		"handle",
		"OS",
		"OS",
		"hItem",
		"count",
		"count",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"hItem",
		"hItem",
		"hTreeItem",
		"hItem",
		"hItem",
		"OS",
		"handle",
		"OS",
		"OS",
		"hItem",
		"count",
		"count",
		"tvItem",
		"OS",
		"OS",
		"tvItem",
		"hTreeItem",
		"tvItem",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"items",
		"tvItem",
		"item",
		"result",
		"index",
		"item",
		"tvItem",
		"OS",
		"handle",
		"OS",
		"OS",
		"tvItem",
		"index",
		"count",
		"index",
		"System",
		"result",
		"newResult",
		"index",
		"result",
		"newResult",
		"result",
		"linesVisible",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"OS",
		"hItem",
		"tvItem",
		"OS",
		"OS",
		"tvItem",
		"hItem",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"tvItem",
		"OS",
		"items",
		"tvItem",
		"tvItem",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"TreeProc",
		"i",
		"items",
		"i",
		"items",
		"i",
		"item",
		"tvItem",
		"item",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"tvItem",
		"OS",
		"count",
		"guess",
		"guess",
		"count",
		"item",
		"count",
		"OS",
		"handle",
		"OS",
		"oldProc",
		"count",
		"count",
		"guess",
		"guess",
		"count",
		"count",
		"guess",
		"System",
		"guess",
		"result",
		"count",
		"result",
		"OS",
		"handle",
		"OS",
		"TreeProc",
		"i",
		"items",
		"i",
		"items",
		"i",
		"item",
		"tvItem",
		"item",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"tvItem",
		"OS",
		"result",
		"index",
		"item",
		"OS",
		"handle",
		"OS",
		"oldProc",
		"result",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"OS",
		"hItem",
		"tvItem",
		"OS",
		"tvItem",
		"hItem",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"tvItem",
		"OS",
		"tvItem",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"TreeProc",
		"i",
		"items",
		"i",
		"items",
		"i",
		"item",
		"tvItem",
		"item",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"tvItem",
		"OS",
		"count",
		"OS",
		"handle",
		"OS",
		"oldProc",
		"count",
		"OS",
		"handle",
		"OS",
		"OS",
		"hItem",
		"tvItem",
		"OS",
		"tvItem",
		"hItem",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"items",
		"tvItem",
		"image",
		"OS",
		"imageList",
		"OS",
		"handle",
		"OS",
		"OS",
		"hOldList",
		"OS",
		"hOldList",
		"image",
		"imageList",
		"display",
		"style",
		"SWT",
		"bounds",
		"bounds",
		"imageList",
		"image",
		"index",
		"index",
		"imageList",
		"image",
		"imageList",
		"OS",
		"handle",
		"OS",
		"OS",
		"hImageList",
		"hwndHeader",
		"OS",
		"hwndHeader",
		"OS",
		"hImageList",
		"index",
		"imageList",
		"image",
		"index",
		"index",
		"imageList",
		"image",
		"hItem",
		"hItem",
		"hChild",
		"hItem",
		"OS",
		"handle",
		"OS",
		"OS",
		"hItem",
		"index",
		"hItem",
		"hChild",
		"index",
		"column",
		"SWT",
		"column",
		"SWT",
		"hwndHeader",
		"OS",
		"hwndHeader",
		"OS",
		"i",
		"count",
		"i",
		"columns",
		"i",
		"column",
		"i",
		"item",
		"SWT",
		"item",
		"SWT",
		"OS",
		"handle",
		"OS",
		"OS",
		"hItem",
		"hItem",
		"item",
		"hwndParent",
		"display",
		"hwndParent",
		"item",
		"hItem",
		"hAnchor",
		"hAnchor",
		"hItem",
		"hInsert",
		"hInsert",
		"item",
		"tvItem",
		"hItem",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"items",
		"tvItem",
		"i",
		"nodes",
		"i",
		"nodes",
		"i",
		"item",
		"sons",
		"sons",
		"tvItem",
		"item",
		"tvItem",
		"item",
		"hwndParent",
		"hwndHeader",
		"OS",
		"hwndHeader",
		"OS",
		"i",
		"items",
		"i",
		"items",
		"i",
		"item",
		"item",
		"item",
		"items",
		"i",
		"columnCount",
		"i",
		"columns",
		"i",
		"column",
		"column",
		"columns",
		"customDraw",
		"imageList",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"display",
		"imageList",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"hOldList",
		"OS",
		"hOldList",
		"imageList",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"hOldList",
		"OS",
		"hOldList",
		"ignoreDeselect",
		"ignoreSelect",
		"drawCount",
		"OS",
		"handle",
		"redraw",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"redraw",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"ignoreDeselect",
		"ignoreSelect",
		"result",
		"SWT",
		"i",
		"items",
		"i",
		"items",
		"i",
		"item",
		"item",
		"item",
		"imageList",
		"OS",
		"handle",
		"OS",
		"hwndHeader",
		"OS",
		"hwndHeader",
		"OS",
		"display",
		"imageList",
		"imageList",
		"hwndParent",
		"customDraw",
		"items",
		"hAnchor",
		"hInsert",
		"listener",
		"SWT",
		"eventTable",
		"SWT",
		"listener",
		"eventTable",
		"SWT",
		"listener",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"eventTable",
		"SWT",
		"listener",
		"item",
		"item",
		"SWT",
		"hItem",
		"item",
		"hInsert",
		"hItem",
		"insertAfter",
		"before",
		"OS",
		"handle",
		"OS",
		"insertAfter",
		"hInsert",
		"linesVisible",
		"show",
		"linesVisible",
		"show",
		"OS",
		"handle",
		"hwndHeader",
		"handle",
		"OS",
		"hwndHeader",
		"OS",
		"count",
		"handle",
		"hwndParent",
		"style",
		"SWT",
		"tvItem",
		"OS",
		"tvItem",
		"OS",
		"tvItem",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"TreeProc",
		"i",
		"items",
		"i",
		"items",
		"i",
		"item",
		"tvItem",
		"item",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"OS",
		"handle",
		"OS",
		"oldProc",
		"background",
		"pixel",
		"background",
		"pixel",
		"OS",
		"handle",
		"pixel",
		"flags",
		"OS",
		"width",
		"height",
		"OS",
		"handle",
		"OS",
		"fixSelection",
		"x",
		"y",
		"width",
		"height",
		"flags",
		"fixSelection",
		"OS",
		"handle",
		"OS",
		"OS",
		"hItem",
		"hItem",
		"cursor",
		"OS",
		"OS",
		"cursor",
		"OS",
		"hCursor",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"height",
		"ImageList",
		"style",
		"SWT",
		"flags",
		"OS",
		"OS",
		"OS",
		"flags",
		"OS",
		"OS",
		"width",
		"height",
		"flags",
		"count",
		"count",
		"OS",
		"handle",
		"OS",
		"hDC",
		"OS",
		"hDC",
		"width",
		"count",
		"height",
		"OS",
		"memDC",
		"hBitmap",
		"OS",
		"rect",
		"width",
		"count",
		"height",
		"OS",
		"clrBackground",
		"OS",
		"memDC",
		"rect",
		"hBrush",
		"OS",
		"hBrush",
		"OS",
		"hDC",
		"OS",
		"OS",
		"hDC",
		"tm",
		"OS",
		"hDC",
		"oldFont",
		"Math",
		"tm",
		"width",
		"Math",
		"tm",
		"height",
		"width",
		"itemWidth",
		"height",
		"itemHeight",
		"OS",
		"rect",
		"left",
		"width",
		"top",
		"left",
		"width",
		"itemWidth",
		"top",
		"itemHeight",
		"OS",
		"OS",
		"OS",
		"handle",
		"BUTTON",
		"OS",
		"hTheme",
		"memDC",
		"OS",
		"OS",
		"rect",
		"rect",
		"width",
		"rect",
		"width",
		"OS",
		"hTheme",
		"memDC",
		"OS",
		"OS",
		"rect",
		"rect",
		"width",
		"rect",
		"width",
		"OS",
		"hTheme",
		"memDC",
		"OS",
		"OS",
		"rect",
		"rect",
		"width",
		"rect",
		"width",
		"OS",
		"hTheme",
		"memDC",
		"OS",
		"OS",
		"rect",
		"OS",
		"hTheme",
		"OS",
		"memDC",
		"rect",
		"OS",
		"OS",
		"OS",
		"rect",
		"width",
		"rect",
		"width",
		"OS",
		"memDC",
		"rect",
		"OS",
		"OS",
		"OS",
		"OS",
		"rect",
		"width",
		"rect",
		"width",
		"OS",
		"memDC",
		"rect",
		"OS",
		"OS",
		"OS",
		"OS",
		"rect",
		"width",
		"rect",
		"width",
		"OS",
		"memDC",
		"rect",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"memDC",
		"hOldBitmap",
		"OS",
		"memDC",
		"OS",
		"handle",
		"hDC",
		"OS",
		"OS",
		"OS",
		"hImageList",
		"hBitmap",
		"OS",
		"hImageList",
		"hBitmap",
		"clrBackground",
		"OS",
		"hBitmap",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"hImageList",
		"hOldList",
		"OS",
		"hOldList",
		"foreground",
		"pixel",
		"foreground",
		"pixel",
		"OS",
		"handle",
		"OS",
		"pixel",
		"hwndHeader",
		"show",
		"OS",
		"hwndHeader",
		"OS",
		"show",
		"bits",
		"OS",
		"bits",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"bits",
		"OS",
		"hwndHeader",
		"OS",
		"bits",
		"OS",
		"bits",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"bits",
		"OS",
		"hwndHeader",
		"OS",
		"redraw",
		"drawCount",
		"OS",
		"handle",
		"OS",
		"count",
		"tvInsert",
		"OS",
		"hItem",
		"OS",
		"handle",
		"OS",
		"tvInsert",
		"redraw",
		"hItem",
		"OS",
		"handle",
		"OS",
		"hItem",
		"hwndHeader",
		"hwndParent",
		"OS",
		"hwndHeader",
		"OS",
		"i",
		"count",
		"i",
		"hdItem",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"i",
		"hdItem",
		"width",
		"hdItem",
		"info",
		"SCROLLINFO",
		"info",
		"OS",
		"OS",
		"count",
		"OS",
		"hwndParent",
		"OS",
		"info",
		"info",
		"info",
		"OS",
		"hwndParent",
		"OS",
		"info",
		"OS",
		"hwndParent",
		"OS",
		"info",
		"info",
		"info",
		"OS",
		"hwndParent",
		"OS",
		"info",
		"OS",
		"hwndParent",
		"rect",
		"OS",
		"hwndParent",
		"OS",
		"info",
		"info",
		"width",
		"info",
		"rect",
		"rect",
		"OS",
		"hwndParent",
		"OS",
		"info",
		"info",
		"OS",
		"OS",
		"hwndParent",
		"OS",
		"info",
		"left",
		"info",
		"OS",
		"hwndParent",
		"rect",
		"OS",
		"playout",
		"OS",
		"hHeap",
		"OS",
		"RECT",
		"playout",
		"OS",
		"hHeap",
		"OS",
		"WINDOWPOS",
		"OS",
		"playout",
		"rect",
		"RECT",
		"OS",
		"hwndHeader",
		"OS",
		"playout",
		"OS",
		"pos",
		"playout",
		"WINDOWPOS",
		"playout",
		"OS",
		"hHeap",
		"playout",
		"playout",
		"OS",
		"hHeap",
		"playout",
		"hwndHeader",
		"OS",
		"pos",
		"left",
		"pos",
		"pos",
		"left",
		"pos",
		"OS",
		"pos",
		"count",
		"OS",
		"OS",
		"rect",
		"rect",
		"pos",
		"ignoreResize",
		"ignoreResize",
		"handle",
		"pos",
		"left",
		"pos",
		"pos",
		"w",
		"left",
		"h",
		"OS",
		"OS",
		"ignoreResize",
		"oldIgnore",
		"items",
		"SWT",
		"items",
		"length",
		"style",
		"SWT",
		"length",
		"items",
		"item",
		"item",
		"SWT",
		"OS",
		"handle",
		"OS",
		"OS",
		"hAnchor",
		"item",
		"hNewItem",
		"fixScroll",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"ignoreSelect",
		"OS",
		"handle",
		"OS",
		"OS",
		"hNewItem",
		"ignoreSelect",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"hNewItem",
		"fixScroll",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"hOldItem",
		"hNewItem",
		"tvItem",
		"OS",
		"tvItem",
		"OS",
		"tvItem",
		"OS",
		"tvItem",
		"hNewItem",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"hNewItem",
		"style",
		"SWT",
		"tvItem",
		"OS",
		"tvItem",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"TreeProc",
		"i",
		"i",
		"item",
		"i",
		"item",
		"index",
		"length",
		"items",
		"index",
		"item",
		"index",
		"tvItem",
		"item",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"tvItem",
		"OS",
		"index",
		"length",
		"tvItem",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"index",
		"length",
		"tvItem",
		"OS",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"OS",
		"handle",
		"OS",
		"oldProc",
		"item",
		"SWT",
		"SWT",
		"item",
		"SWT",
		"SWT",
		"item",
		"hItem",
		"fixScroll",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"hItem",
		"fixScroll",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"hItem",
		"fixScroll",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"hItem",
		"OS",
		"handle",
		"OS",
		"OS",
		"fixScroll",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"itemRect",
		"hItem",
		"OS",
		"handle",
		"OS",
		"itemRect",
		"OS",
		"handle",
		"rect",
		"pt",
		"itemRect",
		"pt",
		"itemRect",
		"OS",
		"rect",
		"pt",
		"pt",
		"itemRect",
		"OS",
		"rect",
		"pt",
		"scroll",
		"scroll",
		"hItem",
		"fixScroll",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"hItem",
		"fixScroll",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"hwndParent",
		"itemRect",
		"hItem",
		"OS",
		"handle",
		"OS",
		"itemRect",
		"OS",
		"hwndParent",
		"rect",
		"OS",
		"hwndParent",
		"handle",
		"rect",
		"pt",
		"itemRect",
		"pt",
		"itemRect",
		"OS",
		"rect",
		"pt",
		"pt",
		"itemRect",
		"OS",
		"rect",
		"pt",
		"info",
		"SCROLLINFO",
		"info",
		"OS",
		"info",
		"Math",
		"pt",
		"Tree",
		"OS",
		"hwndParent",
		"OS",
		"info",
		"column",
		"SWT",
		"column",
		"SWT",
		"column",
		"column",
		"index",
		"OS",
		"hwndHeader",
		"OS",
		"index",
		"index",
		"count",
		"hwndParent",
		"OS",
		"hwndParent",
		"rect",
		"OS",
		"hwndParent",
		"handle",
		"rect",
		"i",
		"index",
		"i",
		"hdItem",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"i",
		"hdItem",
		"x",
		"hdItem",
		"pt",
		"x",
		"pt",
		"rect",
		"OS",
		"rect",
		"pt",
		"info",
		"SCROLLINFO",
		"info",
		"OS",
		"info",
		"Math",
		"pt",
		"Tree",
		"OS",
		"hwndParent",
		"OS",
		"info",
		"item",
		"SWT",
		"item",
		"SWT",
		"item",
		"style",
		"SWT",
		"hItem",
		"OS",
		"handle",
		"OS",
		"OS",
		"hItem",
		"tvItem",
		"OS",
		"tvItem",
		"hItem",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"tvItem",
		"OS",
		"tvItem",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"TreeProc",
		"index",
		"items",
		"items",
		"index",
		"item",
		"tvItem",
		"item",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"tvItem",
		"OS",
		"hItem",
		"tvItem",
		"index",
		"OS",
		"handle",
		"OS",
		"oldProc",
		"hItem",
		"hItem",
		"visible",
		"hwndParent",
		"OS",
		"hwndParent",
		"visible",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"hwndToolTip",
		"hdr",
		"toolTipText",
		"hdr",
		"hwndParent",
		"hwndParent",
		"handle",
		"hwndParent",
		"OS",
		"hwndHeader",
		"OS",
		"columnCount",
		"info",
		"SCROLLINFO",
		"info",
		"OS",
		"OS",
		"handle",
		"OS",
		"itemCount",
		"OS",
		"hwndParent",
		"OS",
		"info",
		"info",
		"info",
		"OS",
		"hwndParent",
		"OS",
		"info",
		"OS",
		"handle",
		"OS",
		"info",
		"OS",
		"hwndParent",
		"OS",
		"info",
		"OS",
		"OS",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"bits",
		"OS",
		"bits",
		"TreeClass",
		"TreeProc",
		"hwndParent",
		"hwnd",
		"hwndParent",
		"msg",
		"OS",
		"SWT",
		"OS",
		"ignoreResize",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"SWT",
		"layout",
		"code",
		"OS",
		"OS",
		"OS",
		"OS",
		"handle",
		"msg",
		"wParam",
		"lParam",
		"OS",
		"info",
		"SCROLLINFO",
		"info",
		"OS",
		"OS",
		"hwndParent",
		"OS",
		"info",
		"OS",
		"handle",
		"OS",
		"info",
		"OS",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"OS",
		"handle",
		"OS",
		"info",
		"OS",
		"hwndParent",
		"OS",
		"info",
		"code",
		"OS",
		"horizontalBar",
		"lParam",
		"lParam",
		"hwndParent",
		"horizontalBar",
		"hwndParent",
		"OS",
		"wParam",
		"lParam",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"handle",
		"msg",
		"wParam",
		"lParam",
		"msg",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"code",
		"wParam",
		"lParam",
		"result",
		"result",
		"wParam",
		"OS",
		"handle",
		"OS",
		"OS",
		"hItem",
		"hAnchor",
		"hItem",
		"OS",
		"handle",
		"OS",
		"hItem",
		"tvItem",
		"OS",
		"OS",
		"tvItem",
		"hItem",
		"style",
		"SWT",
		"tvItem",
		"OS",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"tvItem",
		"state",
		"state",
		"state",
		"tvItem",
		"state",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"OS",
		"hItem",
		"OS",
		"id",
		"OS",
		"handle",
		"OS",
		"hItem",
		"OS",
		"OS",
		"handle",
		"OS",
		"id",
		"tvItem",
		"OS",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"style",
		"SWT",
		"OS",
		"OS",
		"tvItem",
		"OS",
		"tvItem",
		"OS",
		"tvItem",
		"OS",
		"tvItem",
		"OS",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"event",
		"items",
		"tvItem",
		"SWT",
		"event",
		"style",
		"SWT",
		"event",
		"event",
		"items",
		"tvItem",
		"event",
		"SWT",
		"SWT",
		"event",
		"LRESULT",
		"SWT",
		"OS",
		"handle",
		"OS",
		"OS",
		"hItem",
		"tvItem",
		"hItem",
		"tvItem",
		"OS",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"event",
		"items",
		"tvItem",
		"SWT",
		"event",
		"LRESULT",
		"SWT",
		"LRESULT",
		"result",
		"style",
		"SWT",
		"hwndParent",
		"accessible",
		"accessible",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"result",
		"result",
		"wParam",
		"OS",
		"LRESULT",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"style",
		"SWT",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"hItem",
		"hAnchor",
		"hAnchor",
		"hItem",
		"ignoreSelect",
		"ignoreDeselect",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"ignoreSelect",
		"ignoreDeselect",
		"OS",
		"handle",
		"OS",
		"OS",
		"tvItem",
		"OS",
		"tvItem",
		"OS",
		"hItem",
		"rect1",
		"hAnchor",
		"OS",
		"handle",
		"OS",
		"rect1",
		"rect2",
		"rect2",
		"hDeselectItem",
		"OS",
		"handle",
		"OS",
		"rect2",
		"rect1",
		"rect2",
		"OS",
		"OS",
		"hDeselectItem",
		"hAnchor",
		"tvItem",
		"hDeselectItem",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"hDeselectItem",
		"OS",
		"handle",
		"OS",
		"flags",
		"hDeselectItem",
		"hAnchor",
		"rect1",
		"hNewItem",
		"OS",
		"handle",
		"OS",
		"rect1",
		"rect2",
		"hSelectItem",
		"OS",
		"handle",
		"OS",
		"rect2",
		"tvItem",
		"OS",
		"flags",
		"rect1",
		"rect2",
		"OS",
		"OS",
		"hSelectItem",
		"hNewItem",
		"tvItem",
		"hSelectItem",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"hSelectItem",
		"OS",
		"handle",
		"OS",
		"flags",
		"hSelectItem",
		"tvItem",
		"hNewItem",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"tvItem",
		"OS",
		"tvItem",
		"hNewItem",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"event",
		"items",
		"tvItem",
		"SWT",
		"event",
		"code",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"hItem",
		"tvItem",
		"OS",
		"tvItem",
		"OS",
		"tvItem",
		"hItem",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"tvItem",
		"OS",
		"wParam",
		"OS",
		"hNewItem",
		"OS",
		"handle",
		"OS",
		"OS",
		"hItem",
		"OS",
		"hNewItem",
		"OS",
		"handle",
		"OS",
		"OS",
		"hItem",
		"OS",
		"hNewItem",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"hNewItem",
		"OS",
		"handle",
		"OS",
		"OS",
		"hNewItem",
		"hItem",
		"OS",
		"handle",
		"OS",
		"OS",
		"hNewItem",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"OS",
		"handle",
		"clientRect",
		"hNewItem",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"hNewItem",
		"hVisible",
		"rect",
		"hVisible",
		"OS",
		"handle",
		"OS",
		"rect",
		"rect",
		"clientRect",
		"hNewItem",
		"hVisible",
		"hItem",
		"OS",
		"handle",
		"OS",
		"OS",
		"hNewItem",
		"OS",
		"hNewItem",
		"OS",
		"handle",
		"OS",
		"OS",
		"hNewItem",
		"OS",
		"handle",
		"OS",
		"hNewItem",
		"tvItem",
		"hNewItem",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"tvItem",
		"OS",
		"newSelected",
		"drawCount",
		"OS",
		"handle",
		"OS",
		"handle",
		"OS",
		"ignoreSelect",
		"OS",
		"handle",
		"OS",
		"OS",
		"hNewItem",
		"ignoreSelect",
		"oldSelected",
		"tvItem",
		"OS",
		"tvItem",
		"hItem",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"newSelected",
		"tvItem",
		"tvItem",
		"hNewItem",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"newSelected",
		"drawCount",
		"rect1",
		"hItem",
		"rect2",
		"hNewItem",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"OS",
		"handle",
		"OS",
		"fItemRect",
		"rect1",
		"OS",
		"handle",
		"OS",
		"fItemRect",
		"rect2",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"handle",
		"rect1",
		"OS",
		"handle",
		"rect2",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"handle",
		"rect1",
		"flags",
		"OS",
		"handle",
		"rect2",
		"flags",
		"LRESULT",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"hAnchor",
		"OS",
		"handle",
		"OS",
		"OS",
		"code",
		"result",
		"wParam",
		"lParam",
		"style",
		"SWT",
		"result",
		"OS",
		"handle",
		"result",
		"lpht",
		"lParam",
		"lpht",
		"lParam",
		"OS",
		"handle",
		"OS",
		"lpht",
		"style",
		"SWT",
		"lpht",
		"OS",
		"SWT",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"SWT",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"OS",
		"handle",
		"OS",
		"handle",
		"tvItem",
		"lpht",
		"tvItem",
		"OS",
		"OS",
		"tvItem",
		"OS",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"tvItem",
		"state",
		"state",
		"state",
		"tvItem",
		"state",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"OS",
		"tvItem",
		"OS",
		"id",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"OS",
		"OS",
		"handle",
		"OS",
		"id",
		"event",
		"items",
		"tvItem",
		"event",
		"SWT",
		"SWT",
		"event",
		"LRESULT",
		"wParam",
		"lParam",
		"lpht",
		"style",
		"SWT",
		"lpht",
		"OS",
		"tvItem",
		"lpht",
		"tvItem",
		"OS",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"event",
		"items",
		"tvItem",
		"SWT",
		"event",
		"result",
		"lpht",
		"lParam",
		"lpht",
		"lParam",
		"OS",
		"handle",
		"OS",
		"lpht",
		"lpht",
		"lpht",
		"OS",
		"SWT",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"lpht",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"OS",
		"hSelection",
		"tvItem",
		"OS",
		"OS",
		"tvItem",
		"lpht",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"tvItem",
		"OS",
		"fixSelection",
		"tvItem",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"lpht",
		"OS",
		"handle",
		"OS",
		"OS",
		"lpht",
		"OS",
		"handle",
		"OS",
		"OS",
		"lpht",
		"hNext",
		"hNext",
		"hLast",
		"tvItem",
		"hNext",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"tvItem",
		"OS",
		"deselected",
		"tvItem",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"hNext",
		"OS",
		"handle",
		"OS",
		"OS",
		"hNext",
		"hParent",
		"OS",
		"handle",
		"OS",
		"OS",
		"hNext",
		"dragStarted",
		"gestureCompleted",
		"fixSelection",
		"ignoreDeselect",
		"ignoreSelect",
		"lockSelection",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"fixSelection",
		"ignoreDeselect",
		"ignoreSelect",
		"lockSelection",
		"dragStarted",
		"OS",
		"handle",
		"OS",
		"handle",
		"deselected",
		"tvItem",
		"OS",
		"tvItem",
		"lpht",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"event",
		"items",
		"tvItem",
		"SWT",
		"event",
		"code",
		"style",
		"SWT",
		"lpht",
		"OS",
		"SWT",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"OS",
		"handle",
		"OS",
		"handle",
		"tvItem",
		"lpht",
		"tvItem",
		"OS",
		"OS",
		"tvItem",
		"OS",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"tvItem",
		"state",
		"state",
		"state",
		"tvItem",
		"state",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"OS",
		"tvItem",
		"OS",
		"id",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"OS",
		"OS",
		"handle",
		"OS",
		"id",
		"event",
		"items",
		"tvItem",
		"event",
		"SWT",
		"SWT",
		"event",
		"LRESULT",
		"tvItem",
		"OS",
		"tvItem",
		"OS",
		"style",
		"SWT",
		"tvItem",
		"lpht",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"hittestSelected",
		"tvItem",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"style",
		"SWT",
		"tvItem",
		"hOldItem",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"hittestSelected",
		"wParam",
		"OS",
		"drawCount",
		"OS",
		"handle",
		"OS",
		"handle",
		"OS",
		"SWT",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"dragStarted",
		"gestureCompleted",
		"ignoreDeselect",
		"ignoreSelect",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"ignoreDeselect",
		"ignoreSelect",
		"dragStarted",
		"OS",
		"handle",
		"OS",
		"handle",
		"OS",
		"handle",
		"OS",
		"OS",
		"style",
		"SWT",
		"hOldItem",
		"hNewItem",
		"tvItem",
		"OS",
		"tvItem",
		"OS",
		"tvItem",
		"OS",
		"tvItem",
		"hNewItem",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"style",
		"SWT",
		"hittestSelected",
		"wParam",
		"OS",
		"hOldItem",
		"hNewItem",
		"hOldItem",
		"lpht",
		"wParam",
		"OS",
		"tvItem",
		"OS",
		"dragStarted",
		"tvItem",
		"OS",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"tvItem",
		"OS",
		"tvItem",
		"OS",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"wParam",
		"OS",
		"dragStarted",
		"hittestSelected",
		"tvItem",
		"tvItem",
		"lpht",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"drawCount",
		"rect1",
		"hOldItem",
		"rect2",
		"hNewItem",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"OS",
		"handle",
		"OS",
		"fItemRect",
		"rect1",
		"OS",
		"handle",
		"OS",
		"fItemRect",
		"rect2",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"handle",
		"rect1",
		"OS",
		"handle",
		"rect2",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"handle",
		"rect1",
		"flags",
		"OS",
		"handle",
		"rect2",
		"flags",
		"wParam",
		"OS",
		"hittestSelected",
		"dragStarted",
		"tvItem",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"TreeProc",
		"i",
		"items",
		"i",
		"items",
		"i",
		"item",
		"item",
		"hNewItem",
		"tvItem",
		"item",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"tvItem",
		"hNewItem",
		"tvItem",
		"OS",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"OS",
		"handle",
		"OS",
		"oldProc",
		"wParam",
		"OS",
		"hAnchor",
		"hAnchor",
		"hNewItem",
		"rect1",
		"hAnchor",
		"OS",
		"handle",
		"OS",
		"rect1",
		"rect2",
		"rect2",
		"hNewItem",
		"OS",
		"handle",
		"OS",
		"rect2",
		"rect1",
		"rect2",
		"OS",
		"OS",
		"tvItem",
		"OS",
		"tvItem",
		"hAnchor",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"hItem",
		"hNewItem",
		"tvItem",
		"hItem",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"hItem",
		"OS",
		"handle",
		"OS",
		"flags",
		"hItem",
		"wParam",
		"OS",
		"hAnchor",
		"hNewItem",
		"gestureCompleted",
		"tvItem",
		"hNewItem",
		"tvItem",
		"OS",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"event",
		"items",
		"tvItem",
		"SWT",
		"event",
		"gestureCompleted",
		"dragStarted",
		"event",
		"lParam",
		"event",
		"lParam",
		"SWT",
		"event",
		"SWT",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"dragStarted",
		"code",
		"ignoreResize",
		"wParam",
		"lParam",
		"OS",
		"hdr",
		"lParam",
		"NMHDR",
		"hwndHeader",
		"hdr",
		"hwndHeader",
		"hdr",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"phdn",
		"lParam",
		"NMHEADER",
		"columns",
		"phdn",
		"column",
		"column",
		"LRESULT",
		"OS",
		"OS",
		"OS",
		"phdn",
		"lParam",
		"NMHEADER",
		"phdn",
		"OS",
		"newItem",
		"phdn",
		"HDITEM",
		"newItem",
		"OS",
		"oldItem",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"phdn",
		"oldItem",
		"newItem",
		"oldItem",
		"OS",
		"handle",
		"rect",
		"OS",
		"hwndHeader",
		"OS",
		"phdn",
		"itemRect",
		"GRID_WIDTH",
		"rect",
		"itemRect",
		"gridWidth",
		"OS",
		"hwndHeader",
		"OS",
		"phdn",
		"count",
		"phdn",
		"i",
		"count",
		"i",
		"OS",
		"hwndHeader",
		"OS",
		"i",
		"itemRect",
		"rect",
		"itemRect",
		"OS",
		"OS",
		"OS",
		"handle",
		"deltaX",
		"rect",
		"flags",
		"phdn",
		"OS",
		"hwndHeader",
		"OS",
		"phdn",
		"itemRect",
		"rect",
		"itemRect",
		"rect",
		"itemRect",
		"OS",
		"handle",
		"rect",
		"OS",
		"OS",
		"OS",
		"phdn",
		"lParam",
		"NMHEADER",
		"phdn",
		"OS",
		"pitem",
		"phdn",
		"HDITEM",
		"pitem",
		"OS",
		"columns",
		"phdn",
		"column",
		"column",
		"SWT",
		"LRESULT",
		"OS",
		"hwndHeader",
		"OS",
		"count",
		"System",
		"columns",
		"newColumns",
		"count",
		"phdn",
		"i",
		"count",
		"i",
		"newColumns",
		"i",
		"newColumns",
		"i",
		"SWT",
		"OS",
		"OS",
		"OS",
		"phdn",
		"lParam",
		"NMHEADER",
		"columns",
		"phdn",
		"column",
		"column",
		"SWT",
		"OS",
		"OS",
		"OS",
		"phdn",
		"lParam",
		"NMHEADER",
		"columns",
		"phdn",
		"column",
		"column",
		"SWT",
		"wParam",
		"lParam",
		"SWT",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"lpht",
		"lParam",
		"lpht",
		"lParam",
		"OS",
		"handle",
		"OS",
		"lpht",
		"lpht",
		"lpht",
		"OS",
		"OS",
		"wParam",
		"OS",
		"OS",
		"tvItem",
		"OS",
		"tvItem",
		"OS",
		"tvItem",
		"lpht",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"tvItem",
		"OS",
		"ignoreSelect",
		"OS",
		"handle",
		"OS",
		"OS",
		"ignoreSelect",
		"OS",
		"handle",
		"OS",
		"OS",
		"lpht",
		"LRESULT",
		"wParam",
		"lParam",
		"result",
		"result",
		"printClient",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"printClient",
		"code",
		"wParam",
		"lParam",
		"style",
		"SWT",
		"result",
		"OS",
		"handle",
		"result",
		"wParam",
		"lParam",
		"result",
		"result",
		"hwndHeader",
		"OS",
		"hwndHeader",
		"OS",
		"wParam",
		"lParam",
		"result",
		"ignoreResize",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"result",
		"result",
		"style",
		"SWT",
		"result",
		"OS",
		"hdr",
		"lParam",
		"NMHDR",
		"hdr",
		"OS",
		"OS",
		"OS",
		"lptvdi",
		"lParam",
		"NMTVDISPINFO",
		"items",
		"items",
		"lptvdi",
		"item",
		"lptvdi",
		"OS",
		"item",
		"string",
		"Math",
		"buffer",
		"lptvdi",
		"TCHAR",
		"OS",
		"lptvdi",
		"buffer",
		"byteCount",
		"OS",
		"lptvdi",
		"byteCount",
		"TCHAR",
		"TCHAR",
		"lptvdi",
		"Math",
		"lptvdi",
		"string",
		"lptvdi",
		"OS",
		"OS",
		"item",
		"lptvdi",
		"lptvdi",
		"OS",
		"image",
		"lptvdi",
		"lptvdi",
		"image",
		"OS",
		"lParam",
		"lptvdi",
		"NMTVDISPINFO",
		"OS",
		"customDraw",
		"OS",
		"nmcd",
		"lParam",
		"NMTVCUSTOMDRAW",
		"nmcd",
		"OS",
		"OS",
		"OS",
		"OS",
		"linesVisible",
		"nmcd",
		"hwndHeader",
		"hdItem",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"i",
		"count",
		"i",
		"OS",
		"hwndHeader",
		"OS",
		"i",
		"hdItem",
		"OS",
		"rect",
		"x",
		"nmcd",
		"x",
		"hdItem",
		"nmcd",
		"OS",
		"hDC",
		"rect",
		"OS",
		"OS",
		"x",
		"hdItem",
		"OS",
		"handle",
		"OS",
		"OS",
		"rect",
		"hItem",
		"OS",
		"handle",
		"OS",
		"rect",
		"rect",
		"rect",
		"rect",
		"nmcd",
		"rect",
		"height",
		"OS",
		"rect",
		"rect",
		"top",
		"rect",
		"top",
		"height",
		"OS",
		"hDC",
		"rect",
		"OS",
		"OS",
		"OS",
		"OS",
		"items",
		"nmcd",
		"item",
		"nmcd",
		"nmcd",
		"nmcd",
		"nmcd",
		"nmcd",
		"OS",
		"hDC",
		"linesVisible",
		"OS",
		"rect",
		"nmcd",
		"nmcd",
		"nmcd",
		"nmcd",
		"OS",
		"hDC",
		"rect",
		"OS",
		"OS",
		"printClient",
		"style",
		"SWT",
		"hwndHeader",
		"OS",
		"hwndHeader",
		"OS",
		"count",
		"hdItem",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"hdItem",
		"OS",
		"nmcd",
		"nmcd",
		"nmcd",
		"hdItem",
		"nmcd",
		"OS",
		"hDC",
		"hRgn",
		"OS",
		"hRgn",
		"item",
		"item",
		"item",
		"item",
		"item",
		"item",
		"OS",
		"OS",
		"item",
		"item",
		"item",
		"hFont",
		"OS",
		"hDC",
		"hFont",
		"OS",
		"handle",
		"tvItem",
		"OS",
		"tvItem",
		"item",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"tvItem",
		"OS",
		"OS",
		"item",
		"item",
		"item",
		"nmcd",
		"clrText",
		"clrText",
		"item",
		"item",
		"item",
		"nmcd",
		"clrTextBk",
		"clrTextBk",
		"OS",
		"lParam",
		"nmcd",
		"NMTVCUSTOMDRAW",
		"OS",
		"OS",
		"OS",
		"items",
		"nmcd",
		"item",
		"nmcd",
		"nmcd",
		"nmcd",
		"nmcd",
		"nmcd",
		"OS",
		"hDC",
		"OS",
		"hDC",
		"OS",
		"OS",
		"handle",
		"useColor",
		"style",
		"SWT",
		"tvItem",
		"OS",
		"tvItem",
		"item",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"tvItem",
		"OS",
		"useColor",
		"OS",
		"hDC",
		"clrForeground",
		"OS",
		"OS",
		"OS",
		"hDC",
		"clrBackground",
		"OS",
		"OS",
		"useColor",
		"OS",
		"hDC",
		"hwndHeader",
		"data",
		"display",
		"GC",
		"hDC",
		"data",
		"linesVisible",
		"GRID_WIDTH",
		"hdItem",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"i",
		"count",
		"i",
		"OS",
		"hwndHeader",
		"OS",
		"i",
		"hdItem",
		"i",
		"OS",
		"rect",
		"x",
		"nmcd",
		"x",
		"hdItem",
		"nmcd",
		"gridWidth",
		"printClient",
		"style",
		"SWT",
		"hDC",
		"OS",
		"hDC",
		"rect",
		"useColor",
		"item",
		"item",
		"i",
		"item",
		"clrTextBk",
		"hDC",
		"clrTextBk",
		"rect",
		"item",
		"item",
		"i",
		"image",
		"image",
		"size",
		"size",
		"gc",
		"image",
		"bounds",
		"bounds",
		"rect",
		"rect",
		"size",
		"size",
		"OS",
		"rect",
		"rect",
		"size",
		"INSET",
		"rect",
		"rect",
		"INSET",
		"rect",
		"OS",
		"rect",
		"rect",
		"INSET",
		"rect",
		"rect",
		"INSET",
		"rect",
		"rect",
		"rect",
		"item",
		"item",
		"i",
		"item",
		"item",
		"i",
		"item",
		"hFont",
		"hFont",
		"OS",
		"hDC",
		"hFont",
		"useColor",
		"clrText",
		"item",
		"item",
		"i",
		"item",
		"clrText",
		"clrText",
		"OS",
		"hDC",
		"clrText",
		"OS",
		"OS",
		"OS",
		"OS",
		"columns",
		"i",
		"column",
		"SWT",
		"flags",
		"OS",
		"column",
		"SWT",
		"flags",
		"OS",
		"column",
		"SWT",
		"flags",
		"OS",
		"item",
		"i",
		"OS",
		"hDC",
		"buffer",
		"buffer",
		"rect",
		"flags",
		"hFont",
		"OS",
		"hDC",
		"hFont",
		"clrText",
		"OS",
		"hDC",
		"clrText",
		"x",
		"hdItem",
		"count",
		"printClient",
		"style",
		"SWT",
		"OS",
		"rect",
		"x",
		"nmcd",
		"nmcd",
		"nmcd",
		"gridWidth",
		"hDC",
		"OS",
		"hDC",
		"rect",
		"gc",
		"linesVisible",
		"printClient",
		"style",
		"SWT",
		"hwndHeader",
		"OS",
		"hwndHeader",
		"OS",
		"count",
		"printClient",
		"hdItem",
		"OS",
		"OS",
		"hwndHeader",
		"OS",
		"hdItem",
		"OS",
		"rect",
		"nmcd",
		"hdItem",
		"nmcd",
		"nmcd",
		"nmcd",
		"OS",
		"hDC",
		"rect",
		"OS",
		"OS",
		"OS",
		"style",
		"SWT",
		"OS",
		"rect",
		"nmcd",
		"nmcd",
		"nmcd",
		"nmcd",
		"rect",
		"item",
		"OS",
		"handle",
		"OS",
		"rect",
		"OS",
		"handle",
		"OS",
		"OS",
		"hItem",
		"item",
		"OS",
		"rect",
		"rect",
		"nmcd",
		"nmcd",
		"nmcd",
		"tvItem",
		"OS",
		"tvItem",
		"item",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"tvItem",
		"OS",
		"OS",
		"rect",
		"rect",
		"nmcd",
		"nmcd",
		"nmcd",
		"OS",
		"rect",
		"rect",
		"nmcd",
		"nmcd",
		"nmcd",
		"rect",
		"OS",
		"hDC",
		"rect",
		"OS",
		"OS",
		"OS",
		"OS",
		"SWT",
		"LRESULT",
		"OS",
		"OS",
		"style",
		"SWT",
		"lockSelection",
		"oldSelected",
		"NMHDR",
		"OS",
		"tvItem",
		"lParam",
		"offset",
		"TVITEM",
		"tvItem",
		"OS",
		"tvItem",
		"OS",
		"tvItem",
		"OS",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"newSelected",
		"ignoreSelect",
		"NMHDR",
		"TVITEM",
		"OS",
		"tvItem",
		"lParam",
		"offset",
		"TVITEM",
		"tvItem",
		"OS",
		"tvItem",
		"OS",
		"tvItem",
		"OS",
		"handle",
		"OS",
		"tvItem",
		"ignoreSelect",
		"NMHDR",
		"TVITEM",
		"OS",
		"tvItem",
		"lParam",
		"offset",
		"TVITEM",
		"hAnchor",
		"tvItem",
		"event",
		"items",
		"tvItem",
		"SWT",
		"event",
		"OS",
		"OS",
		"style",
		"SWT",
		"lockSelection",
		"NMHDR",
		"OS",
		"tvItem",
		"lParam",
		"offset1",
		"TVITEM",
		"oldSelected",
		"tvItem",
		"OS",
		"NMHDR",
		"TVITEM",
		"OS",
		"tvItem",
		"lParam",
		"offset2",
		"TVITEM",
		"newSelected",
		"tvItem",
		"OS",
		"ignoreSelect",
		"ignoreDeselect",
		"hAnchor",
		"style",
		"SWT",
		"OS",
		"OS",
		"hInsert",
		"OS",
		"handle",
		"OS",
		"insertAfter",
		"hInsert",
		"OS",
		"OS",
		"hInsert",
		"OS",
		"handle",
		"OS",
		"ignoreExpand",
		"NMHDR",
		"TVITEM",
		"OS",
		"tvItem",
		"lParam",
		"offset",
		"TVITEM",
		"items",
		"items",
		"tvItem",
		"item",
		"event",
		"item",
		"OS",
		"action",
		"lParam",
		"NMHDR",
		"action",
		"OS",
		"tvItem",
		"OS",
		"SWT",
		"event",
		"LRESULT",
		"OS",
		"SWT",
		"event",
		"LRESULT",
		"OS",
		"OS",
		"OS",
		"OS",
		"NMHDR",
		"TVITEM",
		"OS",
		"tvItem",
		"lParam",
		"offset",
		"TVITEM",
		"tvItem",
		"tvItem",
		"OS",
		"ignoreSelect",
		"ignoreDeselect",
		"OS",
		"handle",
		"OS",
		"OS",
		"tvItem",
		"ignoreSelect",
		"ignoreDeselect",
		"dragStarted",
		"OS",
		"OS",
		"menu",
		"menu",
		"hasMenu",
		"SWT",
		"LRESULT",
		"OS",
		"OS",
		"menu",
		"menu",
		"hasMenu",
		"SWT",
		"OS",
		"nmrg",
		"lParam",
		"NMRGINFO",
		"nmrg",
		"nmrg",
		"gestureCompleted",
		"LRESULT",
		"wParam",
		"lParam",
		"WC_TREEVIEW",
		"lpfnWndProc",
		"H_SCROLL",
		"V_SCROLL",
		"SINGLE",
		"MULTI",
		"IsWinCE",
		"COLOR_WINDOW",
		"TVM_GETBKCOLOR",
		"COLOR_WINDOW",
		"TVM_GETBKCOLOR",
		"TVM_SETBKCOLOR",
		"TVM_SETBKCOLOR",
		"CHECK",
		"ERROR_NULL_ARGUMENT",
		"Selection",
		"DefaultSelection",
		"ERROR_NULL_ARGUMENT",
		"Expand",
		"Collapse",
		"WM_LBUTTONDOWN",
		"WM_MBUTTONDOWN",
		"WM_RBUTTONDOWN",
		"WM_XBUTTONDOWN",
		"display",
		"ignoreMsgFilter",
		"ignoreMsgFilter",
		"WM_MOUSEWHEEL",
		"TVM_GETNEXTITEM",
		"TVGN_ROOT",
		"TVM_GETNEXTITEM",
		"TVGN_PARENT",
		"TVM_GETNEXTITEM",
		"TVGN_PARENT",
		"ERROR_INVALID_SUBCLASS",
		"mask",
		"HDI_WIDTH",
		"HDM_GETITEMCOUNT",
		"HDM_GETITEM",
		"cxy",
		"bottom",
		"top",
		"TVM_GETNEXTITEM",
		"TVGN_ROOT",
		"left",
		"TVM_GETITEMRECT",
		"right",
		"bottom",
		"top",
		"TVM_GETNEXTITEM",
		"TVGN_NEXT",
		"DEFAULT",
		"DEFAULT",
		"V_SCROLL",
		"SM_CXVSCROLL",
		"H_SCROLL",
		"SM_CYHSCROLL",
		"IsWinCE",
		"COMCTL32_MAJOR",
		"CCM_SETVERSION",
		"CHECK",
		"SYSTEM_FONT",
		"WM_SETFONT",
		"HDM_GETITEMCOUNT",
		"ERROR_INVALID_RANGE",
		"length",
		"length",
		"length",
		"length",
		"strings",
		"strings",
		"images",
		"images",
		"strings",
		"strings",
		"text",
		"text",
		"images",
		"images",
		"image",
		"image",
		"cellBackground",
		"cellBackground",
		"cellBackground",
		"cellForeground",
		"cellForeground",
		"cellForeground",
		"cellFont",
		"cellFont",
		"cellFont",
		"HEAP_ZERO_MEMORY",
		"sizeof",
		"mask",
		"HDI_TEXT",
		"HDI_FORMAT",
		"pszText",
		"style",
		"LEFT",
		"LEFT",
		"fmt",
		"HDF_LEFT",
		"style",
		"CENTER",
		"CENTER",
		"fmt",
		"HDF_CENTER",
		"style",
		"RIGHT",
		"RIGHT",
		"fmt",
		"HDF_RIGHT",
		"HDM_INSERTITEM",
		"GWL_STYLE",
		"TVS_NOHSCROLL",
		"GWL_STYLE",
		"TVM_GETCOUNT",
		"length",
		"length",
		"length",
		"length",
		"hParent",
		"hInsertAfter",
		"lParam",
		"pszText",
		"LPSTR_TEXTCALLBACK",
		"iImage",
		"iSelectedImage",
		"I_IMAGECALLBACK",
		"mask",
		"TVIF_TEXT",
		"TVIF_IMAGE",
		"TVIF_SELECTEDIMAGE",
		"TVIF_HANDLE",
		"TVIF_PARAM",
		"CHECK",
		"mask",
		"mask",
		"TVIF_STATE",
		"state",
		"stateMask",
		"TVIS_STATEIMAGEMASK",
		"TVM_INSERTITEM",
		"ERROR_ITEM_NOT_ADDED",
		"handle",
		"TVM_GETNEXTITEM",
		"TVGN_CHILD",
		"TVM_GETNEXTITEM",
		"TVGN_NEXT",
		"left",
		"TVM_GETITEMRECT",
		"handle",
		"GWL_STYLE",
		"WS_VISIBLE",
		"WS_DISABLED",
		"WS_DISABLED",
		"left",
		"top",
		"right",
		"left",
		"bottom",
		"top",
		"handle",
		"ERROR_NO_HANDLES",
		"GWL_ID",
		"WIN32_VERSION",
		"WS_EX_NOINHERITLAYOUT",
		"RIGHT_TO_LEFT",
		"WS_EX_LAYOUTRTL",
		"WC_HEADER",
		"HDS_BUTTONS",
		"HDS_FULLDRAG",
		"HDS_HIDDEN",
		"WS_CHILD",
		"WS_CLIPSIBLINGS",
		"ERROR_NO_HANDLES",
		"GWL_ID",
		"IsDBLocale",
		"IsPPC",
		"BORDER",
		"GWL_EXSTYLE",
		"WS_EX_CLIENTEDGE",
		"GWL_EXSTYLE",
		"WM_GETFONT",
		"WM_SETFONT",
		"TVM_GETIMAGELIST",
		"TVSIL_NORMAL",
		"HDM_SETIMAGELIST",
		"GW_HWNDPREV",
		"SWP_NOSIZE",
		"SWP_NOMOVE",
		"SWP_NOACTIVATE",
		"cbSize",
		"sizeof",
		"fMask",
		"SIF_RANGE",
		"SIF_PAGE",
		"SB_HORZ",
		"nPage",
		"nMax",
		"SB_HORZ",
		"SB_VERT",
		"nPage",
		"nMax",
		"SB_VERT",
		"WS_VISIBLE",
		"SW_SHOW",
		"COLOR_WINDOW",
		"mask",
		"TVIF_STATE",
		"stateMask",
		"TVIS_SELECTED",
		"SINGLE",
		"TVM_GETNEXTITEM",
		"TVGN_CARET",
		"hItem",
		"TVM_SETITEM",
		"GWL_WNDPROC",
		"GWL_WNDPROC",
		"length",
		"hItem",
		"handle",
		"TVM_SETITEM",
		"GWL_WNDPROC",
		"ERROR_ITEM_NOT_REMOVED",
		"HDM_GETITEMCOUNT",
		"HDM_DELETEITEM",
		"ERROR_ITEM_NOT_REMOVED",
		"length",
		"strings",
		"images",
		"cellBackground",
		"cellForeground",
		"cellFont",
		"strings",
		"strings",
		"text",
		"strings",
		"text",
		"images",
		"images",
		"image",
		"images",
		"image",
		"cellBackground",
		"cellBackground",
		"cellBackground",
		"cellForeground",
		"cellForeground",
		"cellForeground",
		"cellFont",
		"cellFont",
		"cellFont",
		"GWL_STYLE",
		"TVS_NOHSCROLL",
		"GWL_STYLE",
		"style",
		"LEFT",
		"RIGHT",
		"CENTER",
		"style",
		"LEFT",
		"mask",
		"HDI_FORMAT",
		"HDI_IMAGE",
		"HDM_GETITEM",
		"fmt",
		"HDF_JUSTIFYMASK",
		"fmt",
		"HDF_LEFT",
		"HDM_SETITEM",
		"HDM_GETITEMRECT",
		"left",
		"right",
		"Move",
		"handle",
		"left",
		"TVM_GETITEMRECT",
		"TVM_GETNEXTITEM",
		"TVGN_PARENT",
		"WM_SETREDRAW",
		"mask",
		"TVIF_HANDLE",
		"TVIF_PARAM",
		"MULTI",
		"TVM_DELETEITEM",
		"MULTI",
		"WM_SETREDRAW",
		"TVM_GETNEXTITEM",
		"TVGN_CHILD",
		"left",
		"TVM_GETITEMRECT",
		"TVM_GETCOUNT",
		"TVM_SETIMAGELIST",
		"HDM_SETIMAGELIST",
		"mask",
		"TVIF_HANDLE",
		"TVIF_PARAM",
		"hItem",
		"TVM_GETITEM",
		"lParam",
		"length",
		"IsWinCE",
		"IsWinCE",
		"COLOR_WINDOWTEXT",
		"TVM_GETTEXTCOLOR",
		"COLOR_WINDOWTEXT",
		"bottom",
		"top",
		"GWL_STYLE",
		"WS_VISIBLE",
		"ERROR_INVALID_RANGE",
		"HDM_GETITEMCOUNT",
		"ERROR_INVALID_RANGE",
		"HDM_GETITEMCOUNT",
		"HDM_GETITEMCOUNT",
		"ERROR_INVALID_RANGE",
		"TVM_GETNEXTITEM",
		"TVGN_ROOT",
		"TVM_GETNEXTITEM",
		"TVGN_NEXT",
		"ERROR_INVALID_RANGE",
		"mask",
		"TVIF_HANDLE",
		"TVIF_PARAM",
		"hItem",
		"TVM_GETITEM",
		"lParam",
		"ERROR_NULL_ARGUMENT",
		"x",
		"x",
		"y",
		"y",
		"TVM_HITTEST",
		"hItem",
		"FULL_SELECTION",
		"flags",
		"TVHT_ONITEM",
		"mask",
		"TVIF_HANDLE",
		"TVIF_PARAM",
		"hItem",
		"hItem",
		"TVM_GETITEM",
		"lParam",
		"TVM_GETNEXTITEM",
		"TVGN_ROOT",
		"TVM_GETNEXTITEM",
		"TVGN_NEXT",
		"TVM_GETITEMHEIGHT",
		"TVM_GETNEXTITEM",
		"TVGN_ROOT",
		"TVM_GETNEXTITEM",
		"TVGN_NEXT",
		"mask",
		"TVIF_HANDLE",
		"TVIF_PARAM",
		"hItem",
		"hItem",
		"TVM_GETITEM",
		"lParam",
		"hItem",
		"TVM_GETNEXTITEM",
		"TVGN_NEXT",
		"hItem",
		"SINGLE",
		"TVM_GETNEXTITEM",
		"TVGN_CARET",
		"mask",
		"TVIF_PARAM",
		"TVIF_STATE",
		"hItem",
		"TVM_GETITEM",
		"state",
		"TVIS_SELECTED",
		"lParam",
		"mask",
		"TVIF_PARAM",
		"TVIF_STATE",
		"GWL_WNDPROC",
		"GWL_WNDPROC",
		"length",
		"hItem",
		"handle",
		"TVM_GETITEM",
		"state",
		"TVIS_SELECTED",
		"length",
		"GWL_WNDPROC",
		"length",
		"length",
		"GWL_WNDPROC",
		"length",
		"hItem",
		"handle",
		"TVM_GETITEM",
		"state",
		"TVIS_SELECTED",
		"GWL_WNDPROC",
		"SINGLE",
		"TVM_GETNEXTITEM",
		"TVGN_CARET",
		"mask",
		"TVIF_STATE",
		"hItem",
		"TVM_GETITEM",
		"state",
		"TVIS_SELECTED",
		"mask",
		"TVIF_STATE",
		"GWL_WNDPROC",
		"GWL_WNDPROC",
		"length",
		"hItem",
		"handle",
		"TVM_GETITEM",
		"state",
		"TVIS_SELECTED",
		"GWL_WNDPROC",
		"TVM_GETNEXTITEM",
		"TVGN_FIRSTVISIBLE",
		"mask",
		"TVIF_PARAM",
		"hItem",
		"TVM_GETITEM",
		"lParam",
		"I_IMAGENONE",
		"TVM_GETIMAGELIST",
		"TVSIL_NORMAL",
		"RIGHT_TO_LEFT",
		"width",
		"height",
		"TVM_SETIMAGELIST",
		"TVSIL_NORMAL",
		"HDM_SETIMAGELIST",
		"TVM_GETNEXTITEM",
		"TVGN_NEXT",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"HDM_GETITEMCOUNT",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"TVM_GETNEXTITEM",
		"TVGN_ROOT",
		"handle",
		"handle",
		"hItem",
		"TVM_GETITEM",
		"lParam",
		"length",
		"length",
		"HDM_GETITEMCOUNT",
		"length",
		"TVM_SETIMAGELIST",
		"TVSIL_NORMAL",
		"HDM_SETIMAGELIST",
		"TVM_GETIMAGELIST",
		"TVSIL_NORMAL",
		"TVM_SETIMAGELIST",
		"TVSIL_NORMAL",
		"HDM_SETIMAGELIST",
		"TVM_GETIMAGELIST",
		"TVSIL_STATE",
		"TVM_SETIMAGELIST",
		"TVSIL_STATE",
		"WM_SETREDRAW",
		"TVM_DELETEITEM",
		"TVI_ROOT",
		"WM_SETREDRAW",
		"ERROR_ITEM_NOT_REMOVED",
		"length",
		"TVM_SETIMAGELIST",
		"HDM_SETIMAGELIST",
		"ERROR_NULL_ARGUMENT",
		"Selection",
		"DefaultSelection",
		"ERROR_NULL_ARGUMENT",
		"Expand",
		"Collapse",
		"ERROR_INVALID_ARGUMENT",
		"handle",
		"TVM_SETINSERTMARK",
		"HDM_GETITEMCOUNT",
		"SINGLE",
		"mask",
		"TVIF_STATE",
		"state",
		"TVIS_SELECTED",
		"stateMask",
		"TVIS_SELECTED",
		"GWL_WNDPROC",
		"GWL_WNDPROC",
		"length",
		"hItem",
		"handle",
		"TVM_SETITEM",
		"GWL_WNDPROC",
		"SWP_NOSIZE",
		"TVM_GETVISIBLECOUNT",
		"TVM_GETNEXTITEM",
		"TVGN_CARET",
		"IDC_ARROW",
		"handle",
		"CHECK",
		"TVM_GETITEMHEIGHT",
		"COLOR_FLAGS",
		"RIGHT_TO_LEFT",
		"ILC_MIRROR",
		"COMCTL32_MAJOR",
		"ILC_MASK",
		"IsUnicode",
		"tmHeight",
		"tmHeight",
		"COMCTL32_MAJOR",
		"BP_CHECKBOX",
		"CBS_UNCHECKEDNORMAL",
		"left",
		"right",
		"BP_CHECKBOX",
		"CBS_CHECKEDNORMAL",
		"left",
		"right",
		"BP_CHECKBOX",
		"CBS_UNCHECKEDNORMAL",
		"left",
		"right",
		"BP_CHECKBOX",
		"CBS_MIXEDNORMAL",
		"DFC_BUTTON",
		"DFCS_BUTTONCHECK",
		"DFCS_FLAT",
		"left",
		"right",
		"DFC_BUTTON",
		"DFCS_BUTTONCHECK",
		"DFCS_CHECKED",
		"DFCS_FLAT",
		"left",
		"right",
		"DFC_BUTTON",
		"DFCS_BUTTONCHECK",
		"DFCS_INACTIVE",
		"DFCS_FLAT",
		"left",
		"right",
		"DFC_BUTTON",
		"DFCS_BUTTONCHECK",
		"DFCS_CHECKED",
		"DFCS_INACTIVE",
		"DFCS_FLAT",
		"COMCTL32_MAJOR",
		"TVM_GETIMAGELIST",
		"TVSIL_STATE",
		"TVM_SETIMAGELIST",
		"TVSIL_STATE",
		"TVM_SETTEXTCOLOR",
		"GWL_STYLE",
		"HDS_HIDDEN",
		"HDS_HIDDEN",
		"GWL_STYLE",
		"SW_SHOW",
		"HDS_HIDDEN",
		"HDS_HIDDEN",
		"GWL_STYLE",
		"SW_HIDE",
		"TVM_GETCOUNT",
		"hInsertAfter",
		"TVI_FIRST",
		"TVM_INSERTITEM",
		"TVM_DELETEITEM",
		"HDM_GETITEMCOUNT",
		"mask",
		"HDI_WIDTH",
		"HDM_GETITEM",
		"cxy",
		"cbSize",
		"sizeof",
		"fMask",
		"SIF_RANGE",
		"SIF_PAGE",
		"SB_HORZ",
		"nPage",
		"nMax",
		"SB_HORZ",
		"SB_VERT",
		"nPage",
		"nMax",
		"SB_VERT",
		"SB_HORZ",
		"nMax",
		"nPage",
		"right",
		"left",
		"SB_HORZ",
		"fMask",
		"SIF_POS",
		"SB_HORZ",
		"nPos",
		"prc",
		"HEAP_ZERO_MEMORY",
		"sizeof",
		"pwpos",
		"HEAP_ZERO_MEMORY",
		"sizeof",
		"prc",
		"sizeof",
		"HDM_LAYOUT",
		"pwpos",
		"sizeof",
		"prc",
		"prc",
		"pwpos",
		"pwpos",
		"HWND_TOP",
		"x",
		"y",
		"cx",
		"cy",
		"SWP_NOACTIVATE",
		"cx",
		"SM_CXVSCROLL",
		"bottom",
		"top",
		"cy",
		"x",
		"y",
		"cy",
		"SWP_NOACTIVATE",
		"SWP_NOZORDER",
		"ERROR_NULL_ARGUMENT",
		"length",
		"SINGLE",
		"ERROR_INVALID_ARGUMENT",
		"TVM_GETNEXTITEM",
		"TVGN_CARET",
		"handle",
		"WM_SETREDRAW",
		"WM_SETREDRAW",
		"TVM_SELECTITEM",
		"TVGN_CARET",
		"TVM_GETVISIBLECOUNT",
		"TVM_SELECTITEM",
		"TVGN_FIRSTVISIBLE",
		"WM_SETREDRAW",
		"WM_SETREDRAW",
		"mask",
		"TVIF_STATE",
		"state",
		"TVIS_SELECTED",
		"stateMask",
		"TVIS_SELECTED",
		"hItem",
		"TVM_SETITEM",
		"SINGLE",
		"mask",
		"TVIF_STATE",
		"stateMask",
		"TVIS_SELECTED",
		"GWL_WNDPROC",
		"GWL_WNDPROC",
		"length",
		"items",
		"items",
		"hItem",
		"handle",
		"TVM_GETITEM",
		"state",
		"TVIS_SELECTED",
		"state",
		"TVM_SETITEM",
		"state",
		"TVIS_SELECTED",
		"TVM_SETITEM",
		"GWL_WNDPROC",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"handle",
		"WM_SETREDRAW",
		"WM_SETREDRAW",
		"TVM_SELECTITEM",
		"TVGN_FIRSTVISIBLE",
		"WM_SETREDRAW",
		"WM_SETREDRAW",
		"TVM_GETVISIBLECOUNT",
		"WM_SETREDRAW",
		"WM_SETREDRAW",
		"TVM_SELECTITEM",
		"TVGN_FIRSTVISIBLE",
		"WM_HSCROLL",
		"SB_TOP",
		"WM_SETREDRAW",
		"WM_SETREDRAW",
		"left",
		"TVM_GETITEMRECT",
		"x",
		"left",
		"y",
		"top",
		"y",
		"bottom",
		"WM_SETREDRAW",
		"WM_SETREDRAW",
		"TVM_ENSUREVISIBLE",
		"WM_SETREDRAW",
		"WM_SETREDRAW",
		"left",
		"TVM_GETITEMRECT",
		"x",
		"left",
		"y",
		"top",
		"y",
		"bottom",
		"cbSize",
		"sizeof",
		"fMask",
		"SIF_POS",
		"nPos",
		"x",
		"INSET",
		"SB_HORZ",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"parent",
		"HDM_GETITEMCOUNT",
		"mask",
		"HDI_WIDTH",
		"HDM_GETITEM",
		"cxy",
		"x",
		"y",
		"top",
		"cbSize",
		"sizeof",
		"fMask",
		"SIF_POS",
		"nPos",
		"x",
		"INSET",
		"SB_HORZ",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"handle",
		"SINGLE",
		"TVM_GETNEXTITEM",
		"TVGN_CARET",
		"mask",
		"TVIF_STATE",
		"hItem",
		"TVM_GETITEM",
		"state",
		"TVIS_SELECTED",
		"mask",
		"TVIF_STATE",
		"GWL_WNDPROC",
		"GWL_WNDPROC",
		"length",
		"hItem",
		"handle",
		"TVM_GETITEM",
		"state",
		"TVIS_SELECTED",
		"hItem",
		"GWL_WNDPROC",
		"SW_SHOW",
		"SW_HIDE",
		"TVM_GETTOOLTIPS",
		"hwndFrom",
		"HDM_GETITEMCOUNT",
		"cbSize",
		"sizeof",
		"fMask",
		"SIF_ALL",
		"TVM_GETCOUNT",
		"SB_VERT",
		"nPage",
		"nMax",
		"SB_VERT",
		"SB_VERT",
		"SB_VERT",
		"TVS_SHOWSELALWAYS",
		"TVS_LINESATROOT",
		"TVS_HASBUTTONS",
		"FULL_SELECTION",
		"TVS_FULLROWSELECT",
		"TVS_HASLINES",
		"WM_MOVE",
		"Move",
		"WM_SIZE",
		"WM_SIZE",
		"Resize",
		"WM_COMMAND",
		"WM_NOTIFY",
		"WM_SYSCOLORCHANGE",
		"WM_VSCROLL",
		"cbSize",
		"sizeof",
		"fMask",
		"SIF_ALL",
		"SB_VERT",
		"SB_VERT",
		"WM_VSCROLL",
		"SB_VERT",
		"SB_VERT",
		"WM_HSCROLL",
		"WM_HSCROLL",
		"WM_CHAR",
		"WM_IME_CHAR",
		"WM_KEYDOWN",
		"WM_KEYUP",
		"WM_SYSCHAR",
		"WM_SYSKEYDOWN",
		"WM_SYSKEYUP",
		"WM_LBUTTONDBLCLK",
		"WM_LBUTTONDOWN",
		"WM_LBUTTONUP",
		"WM_MBUTTONDBLCLK",
		"WM_MBUTTONDOWN",
		"WM_MBUTTONUP",
		"WM_MOUSEHOVER",
		"WM_MOUSELEAVE",
		"WM_MOUSEMOVE",
		"WM_MOUSEWHEEL",
		"WM_RBUTTONDBLCLK",
		"WM_RBUTTONDOWN",
		"WM_RBUTTONUP",
		"WM_XBUTTONDBLCLK",
		"WM_XBUTTONDOWN",
		"WM_XBUTTONUP",
		"WM_SIZE",
		"WM_SETFONT",
		"WM_TIMER",
		"TVM_GETNEXTITEM",
		"TVGN_CARET",
		"TVM_ENSUREVISIBLE",
		"mask",
		"TVIF_STATE",
		"TVIF_PARAM",
		"hItem",
		"CHECK",
		"stateMask",
		"TVIS_STATEIMAGEMASK",
		"TVM_GETITEM",
		"state",
		"state",
		"TVM_SETITEM",
		"IsWinCE",
		"COMCTL32_MAJOR",
		"TVM_MAPHTREEITEMTOACCID",
		"EVENT_OBJECT_FOCUS",
		"OBJID_CLIENT",
		"stateMask",
		"TVIS_SELECTED",
		"TVM_GETITEM",
		"MULTI",
		"VK_CONTROL",
		"state",
		"TVIS_SELECTED",
		"state",
		"TVIS_SELECTED",
		"state",
		"TVIS_SELECTED",
		"state",
		"TVIS_SELECTED",
		"TVM_SETITEM",
		"item",
		"lParam",
		"Selection",
		"CHECK",
		"item",
		"lParam",
		"detail",
		"CHECK",
		"Selection",
		"ZERO",
		"CR",
		"TVM_GETNEXTITEM",
		"TVGN_CARET",
		"hItem",
		"mask",
		"TVIF_PARAM",
		"TVM_GETITEM",
		"item",
		"lParam",
		"DefaultSelection",
		"ZERO",
		"ESC",
		"ZERO",
		"CHECK",
		"VK_SPACE",
		"ZERO",
		"VK_UP",
		"VK_DOWN",
		"VK_PRIOR",
		"VK_NEXT",
		"VK_HOME",
		"VK_END",
		"WM_CHANGEUISTATE",
		"UIS_INITIALIZE",
		"SINGLE",
		"VK_SHIFT",
		"TVM_GETNEXTITEM",
		"TVGN_CARET",
		"WM_KEYDOWN",
		"TVM_GETNEXTITEM",
		"TVGN_CARET",
		"mask",
		"TVIF_STATE",
		"stateMask",
		"TVIS_SELECTED",
		"left",
		"TVM_GETITEMRECT",
		"left",
		"TVM_GETITEMRECT",
		"top",
		"top",
		"TVGN_PREVIOUSVISIBLE",
		"TVGN_NEXTVISIBLE",
		"hItem",
		"TVM_SETITEM",
		"TVM_GETNEXTITEM",
		"left",
		"TVM_GETITEMRECT",
		"left",
		"TVM_GETITEMRECT",
		"state",
		"TVIS_SELECTED",
		"top",
		"top",
		"TVGN_PREVIOUSVISIBLE",
		"TVGN_NEXTVISIBLE",
		"hItem",
		"TVM_SETITEM",
		"TVM_GETNEXTITEM",
		"hItem",
		"TVM_SETITEM",
		"mask",
		"TVIF_PARAM",
		"hItem",
		"TVM_GETITEM",
		"item",
		"lParam",
		"Selection",
		"VK_CONTROL",
		"TVM_GETNEXTITEM",
		"TVGN_CARET",
		"mask",
		"TVIF_STATE",
		"stateMask",
		"TVIS_SELECTED",
		"hItem",
		"TVM_GETITEM",
		"state",
		"TVIS_SELECTED",
		"VK_UP",
		"TVM_GETNEXTITEM",
		"TVGN_PREVIOUSVISIBLE",
		"VK_DOWN",
		"TVM_GETNEXTITEM",
		"TVGN_NEXTVISIBLE",
		"VK_HOME",
		"TVM_GETNEXTITEM",
		"TVGN_ROOT",
		"VK_PRIOR",
		"TVM_GETNEXTITEM",
		"TVGN_FIRSTVISIBLE",
		"WM_VSCROLL",
		"SB_PAGEUP",
		"TVM_GETNEXTITEM",
		"TVGN_FIRSTVISIBLE",
		"VK_NEXT",
		"TVM_GETNEXTITEM",
		"TVGN_FIRSTVISIBLE",
		"TVM_GETNEXTITEM",
		"TVGN_NEXTVISIBLE",
		"left",
		"TVM_GETITEMRECT",
		"bottom",
		"bottom",
		"WM_VSCROLL",
		"SB_PAGEDOWN",
		"VK_END",
		"TVM_GETNEXTITEM",
		"TVGN_LASTVISIBLE",
		"TVM_ENSUREVISIBLE",
		"hItem",
		"TVM_GETITEM",
		"state",
		"TVIS_SELECTED",
		"WM_SETREDRAW",
		"TVM_SELECTITEM",
		"TVGN_CARET",
		"state",
		"TVIS_SELECTED",
		"hItem",
		"TVM_SETITEM",
		"state",
		"hItem",
		"TVM_SETITEM",
		"left",
		"left",
		"GWL_STYLE",
		"TVS_FULLROWSELECT",
		"TVM_GETITEMRECT",
		"TVM_GETITEMRECT",
		"WM_SETREDRAW",
		"IsWinCE",
		"RDW_UPDATENOW",
		"RDW_INVALIDATE",
		"ZERO",
		"WM_KEYDOWN",
		"TVM_GETNEXTITEM",
		"TVGN_CARET",
		"SINGLE",
		"x",
		"y",
		"TVM_HITTEST",
		"CHECK",
		"flags",
		"TVHT_ONITEMSTATEICON",
		"MouseDown",
		"WM_LBUTTONDOWN",
		"MouseDoubleClick",
		"WM_LBUTTONDBLCLK",
		"hItem",
		"hItem",
		"mask",
		"TVIF_PARAM",
		"TVIF_STATE",
		"stateMask",
		"TVIS_STATEIMAGEMASK",
		"TVM_GETITEM",
		"state",
		"state",
		"TVM_SETITEM",
		"IsWinCE",
		"hItem",
		"COMCTL32_MAJOR",
		"TVM_MAPHTREEITEMTOACCID",
		"hItem",
		"EVENT_OBJECT_FOCUS",
		"OBJID_CLIENT",
		"item",
		"lParam",
		"detail",
		"CHECK",
		"Selection",
		"ZERO",
		"hItem",
		"FULL_SELECTION",
		"flags",
		"TVHT_ONITEM",
		"hItem",
		"hItem",
		"mask",
		"TVIF_PARAM",
		"TVM_GETITEM",
		"item",
		"lParam",
		"DefaultSelection",
		"x",
		"y",
		"TVM_HITTEST",
		"hItem",
		"flags",
		"TVHT_ONITEMBUTTON",
		"MouseDown",
		"WM_LBUTTONDOWN",
		"hItem",
		"MULTI",
		"TVM_GETNEXTITEM",
		"TVGN_CARET",
		"mask",
		"TVIF_STATE",
		"TVIF_PARAM",
		"hItem",
		"hItem",
		"TVM_GETITEM",
		"state",
		"TVIS_EXPANDED",
		"stateMask",
		"TVIS_SELECTED",
		"TVM_GETNEXTITEM",
		"TVGN_PARENT",
		"hItem",
		"TVM_GETNEXTITEM",
		"TVGN_LASTVISIBLE",
		"hItem",
		"TVM_GETNEXTITEM",
		"TVGN_NEXTVISIBLE",
		"hItem",
		"hItem",
		"TVM_GETITEM",
		"state",
		"TVIS_SELECTED",
		"state",
		"TVM_SETITEM",
		"TVM_GETNEXTITEM",
		"TVGN_NEXTVISIBLE",
		"TVM_GETNEXTITEM",
		"TVGN_PARENT",
		"WM_LBUTTONDOWN",
		"mask",
		"TVIF_PARAM",
		"hItem",
		"hItem",
		"TVM_GETITEM",
		"item",
		"lParam",
		"Selection",
		"CHECK",
		"flags",
		"TVHT_ONITEMSTATEICON",
		"MouseDown",
		"WM_LBUTTONDOWN",
		"hItem",
		"hItem",
		"mask",
		"TVIF_PARAM",
		"TVIF_STATE",
		"stateMask",
		"TVIS_STATEIMAGEMASK",
		"TVM_GETITEM",
		"state",
		"state",
		"TVM_SETITEM",
		"IsWinCE",
		"hItem",
		"COMCTL32_MAJOR",
		"TVM_MAPHTREEITEMTOACCID",
		"hItem",
		"EVENT_OBJECT_FOCUS",
		"OBJID_CLIENT",
		"item",
		"lParam",
		"detail",
		"CHECK",
		"Selection",
		"ZERO",
		"mask",
		"TVIF_STATE",
		"stateMask",
		"TVIS_SELECTED",
		"MULTI",
		"hItem",
		"hItem",
		"TVM_GETITEM",
		"state",
		"TVIS_SELECTED",
		"TVM_GETNEXTITEM",
		"TVGN_CARET",
		"MULTI",
		"hItem",
		"TVM_GETITEM",
		"MK_CONTROL",
		"WM_SETREDRAW",
		"MouseDown",
		"WM_LBUTTONDOWN",
		"WM_LBUTTONDOWN",
		"TVM_GETNEXTITEM",
		"TVGN_CARET",
		"SINGLE",
		"mask",
		"TVIF_STATE",
		"state",
		"TVIS_SELECTED",
		"stateMask",
		"TVIS_SELECTED",
		"hItem",
		"TVM_SETITEM",
		"MULTI",
		"MK_CONTROL",
		"hItem",
		"MK_CONTROL",
		"state",
		"TVIS_SELECTED",
		"state",
		"TVIS_SELECTED",
		"TVM_SETITEM",
		"state",
		"TVIS_SELECTED",
		"state",
		"TVIS_SELECTED",
		"TVM_SETITEM",
		"MK_CONTROL",
		"state",
		"hItem",
		"hItem",
		"TVM_SETITEM",
		"left",
		"left",
		"GWL_STYLE",
		"TVS_FULLROWSELECT",
		"TVM_GETITEMRECT",
		"TVM_GETITEMRECT",
		"WM_SETREDRAW",
		"IsWinCE",
		"RDW_UPDATENOW",
		"RDW_INVALIDATE",
		"MK_CONTROL",
		"state",
		"GWL_WNDPROC",
		"GWL_WNDPROC",
		"length",
		"handle",
		"hItem",
		"handle",
		"TVM_SETITEM",
		"hItem",
		"state",
		"TVIS_SELECTED",
		"TVM_SETITEM",
		"GWL_WNDPROC",
		"MK_SHIFT",
		"left",
		"TVM_GETITEMRECT",
		"left",
		"TVM_GETITEMRECT",
		"top",
		"top",
		"TVGN_NEXTVISIBLE",
		"TVGN_PREVIOUSVISIBLE",
		"state",
		"TVIS_SELECTED",
		"hItem",
		"TVM_SETITEM",
		"hItem",
		"TVM_SETITEM",
		"TVM_GETNEXTITEM",
		"MK_SHIFT",
		"hItem",
		"mask",
		"TVIF_PARAM",
		"TVM_GETITEM",
		"item",
		"lParam",
		"Selection",
		"x",
		"y",
		"DragDetect",
		"MouseUp",
		"WM_LBUTTONUP",
		"sizeof",
		"hwndFrom",
		"code",
		"HDN_BEGINTRACKW",
		"HDN_BEGINTRACKA",
		"HDN_DIVIDERDBLCLICKW",
		"HDN_DIVIDERDBLCLICKA",
		"sizeof",
		"iItem",
		"ONE",
		"HDN_ITEMCHANGINGW",
		"HDN_ITEMCHANGINGA",
		"sizeof",
		"pitem",
		"pitem",
		"sizeof",
		"mask",
		"HDI_WIDTH",
		"mask",
		"HDI_WIDTH",
		"HDM_GETITEM",
		"iItem",
		"cxy",
		"cxy",
		"HDM_GETITEMRECT",
		"iItem",
		"left",
		"right",
		"HDM_GETITEMCOUNT",
		"iItem",
		"iItem",
		"HDM_GETITEMRECT",
		"right",
		"right",
		"SW_INVALIDATE",
		"SW_ERASE",
		"iItem",
		"HDM_GETITEMRECT",
		"iItem",
		"left",
		"left",
		"right",
		"right",
		"HDN_ITEMCHANGEDW",
		"HDN_ITEMCHANGEDA",
		"sizeof",
		"pitem",
		"pitem",
		"sizeof",
		"mask",
		"HDI_WIDTH",
		"iItem",
		"Resize",
		"ZERO",
		"HDM_GETITEMCOUNT",
		"iItem",
		"Move",
		"HDN_ITEMCLICKW",
		"HDN_ITEMCLICKA",
		"sizeof",
		"iItem",
		"Selection",
		"HDN_ITEMDBLCLICKW",
		"HDN_ITEMDBLCLICKA",
		"sizeof",
		"iItem",
		"DefaultSelection",
		"MouseDown",
		"WM_RBUTTONDOWN",
		"x",
		"y",
		"TVM_HITTEST",
		"hItem",
		"flags",
		"TVHT_ONITEMICON",
		"TVHT_ONITEMLABEL",
		"MK_CONTROL",
		"MK_SHIFT",
		"mask",
		"TVIF_STATE",
		"stateMask",
		"TVIS_SELECTED",
		"hItem",
		"hItem",
		"TVM_GETITEM",
		"state",
		"TVIS_SELECTED",
		"TVM_SELECTITEM",
		"TVGN_CARET",
		"TVM_SELECTITEM",
		"TVGN_CARET",
		"hItem",
		"ZERO",
		"WM_PRINTCLIENT",
		"SINGLE",
		"WM_SETFONT",
		"CHECK",
		"sizeof",
		"code",
		"TVN_GETDISPINFOA",
		"TVN_GETDISPINFOW",
		"sizeof",
		"lParam",
		"mask",
		"TVIF_TEXT",
		"text",
		"cchTextMax",
		"sizeof",
		"pszText",
		"pszText",
		"sizeof",
		"sizeof",
		"cchTextMax",
		"cchTextMax",
		"mask",
		"TVIF_IMAGE",
		"TVIF_SELECTEDIMAGE",
		"image",
		"iImage",
		"iSelectedImage",
		"I_IMAGENONE",
		"iImage",
		"iSelectedImage",
		"sizeof",
		"NM_CUSTOMDRAW",
		"sizeof",
		"dwDrawStage",
		"CDDS_PREPAINT",
		"CDRF_NOTIFYITEMDRAW",
		"CDRF_NOTIFYPOSTPAINT",
		"CDDS_POSTPAINT",
		"hdc",
		"mask",
		"HDI_WIDTH",
		"HDM_GETITEMCOUNT",
		"HDM_GETITEM",
		"top",
		"cxy",
		"bottom",
		"BDR_SUNKENINNER",
		"BF_RIGHT",
		"cxy",
		"TVM_GETNEXTITEM",
		"TVGN_LASTVISIBLE",
		"left",
		"TVM_GETITEMRECT",
		"bottom",
		"top",
		"bottom",
		"bottom",
		"top",
		"left",
		"right",
		"BDR_SUNKENINNER",
		"BF_BOTTOM",
		"CDRF_DODEFAULT",
		"CDDS_ITEMPREPAINT",
		"lItemlParam",
		"left",
		"right",
		"top",
		"bottom",
		"hdc",
		"left",
		"top",
		"right",
		"bottom",
		"BDR_SUNKENINNER",
		"BF_BOTTOM",
		"FULL_SELECTION",
		"HDM_GETITEMCOUNT",
		"mask",
		"HDI_WIDTH",
		"HDM_GETITEM",
		"left",
		"top",
		"left",
		"cxy",
		"bottom",
		"font",
		"foreground",
		"background",
		"cellForeground",
		"cellBackground",
		"cellFont",
		"CDRF_DODEFAULT",
		"CDRF_NOTIFYPOSTPAINT",
		"cellFont",
		"cellFont",
		"font",
		"mask",
		"TVIF_STATE",
		"hItem",
		"handle",
		"TVM_GETITEM",
		"state",
		"TVIS_SELECTED",
		"TVIS_DROPHILITED",
		"cellForeground",
		"cellForeground",
		"foreground",
		"clrText",
		"cellBackground",
		"cellBackground",
		"background",
		"clrTextBk",
		"sizeof",
		"CDRF_NEWFONT",
		"CDRF_NOTIFYPOSTPAINT",
		"CDDS_ITEMPOSTPAINT",
		"lItemlParam",
		"left",
		"right",
		"top",
		"bottom",
		"hdc",
		"TRANSPARENT",
		"FULL_SELECTION",
		"mask",
		"TVIF_STATE",
		"hItem",
		"handle",
		"TVM_GETITEM",
		"state",
		"TVIS_SELECTED",
		"COLOR_HIGHLIGHTTEXT",
		"COLOR_HIGHLIGHT",
		"device",
		"mask",
		"HDI_WIDTH",
		"HDM_GETITEMCOUNT",
		"HDM_GETITEM",
		"top",
		"cxy",
		"bottom",
		"FULL_SELECTION",
		"cellBackground",
		"cellBackground",
		"background",
		"images",
		"images",
		"width",
		"height",
		"left",
		"top",
		"x",
		"y",
		"left",
		"x",
		"top",
		"right",
		"bottom",
		"left",
		"top",
		"right",
		"bottom",
		"left",
		"right",
		"strings",
		"strings",
		"cellFont",
		"cellFont",
		"font",
		"cellForeground",
		"cellForeground",
		"foreground",
		"DT_NOPREFIX",
		"DT_SINGLELINE",
		"DT_VCENTER",
		"DT_ENDELLIPSIS",
		"style",
		"LEFT",
		"DT_LEFT",
		"style",
		"CENTER",
		"DT_CENTER",
		"style",
		"RIGHT",
		"DT_RIGHT",
		"strings",
		"cxy",
		"FULL_SELECTION",
		"top",
		"right",
		"bottom",
		"FULL_SELECTION",
		"HDM_GETITEMCOUNT",
		"mask",
		"HDI_WIDTH",
		"HDM_GETITEM",
		"left",
		"cxy",
		"top",
		"right",
		"bottom",
		"BDR_SUNKENINNER",
		"BF_BOTTOM",
		"COMCTL32_MAJOR",
		"FULL_SELECTION",
		"left",
		"top",
		"right",
		"bottom",
		"left",
		"handle",
		"TVM_GETITEMRECT",
		"TVM_GETNEXTITEM",
		"TVGN_CARET",
		"handle",
		"right",
		"top",
		"right",
		"bottom",
		"mask",
		"TVIF_STATE",
		"hItem",
		"handle",
		"TVM_GETITEM",
		"state",
		"TVIS_SELECTED",
		"right",
		"top",
		"right",
		"bottom",
		"left",
		"top",
		"right",
		"bottom",
		"left",
		"BDR_SUNKENINNER",
		"BF_BOTTOM",
		"CDRF_DODEFAULT",
		"NM_DBLCLK",
		"DefaultSelection",
		"ONE",
		"TVN_SELCHANGEDA",
		"TVN_SELCHANGEDW",
		"MULTI",
		"sizeof",
		"sizeof",
		"mask",
		"TVIF_STATE",
		"stateMask",
		"TVIS_SELECTED",
		"state",
		"TVIS_SELECTED",
		"TVM_SETITEM",
		"sizeof",
		"sizeof",
		"sizeof",
		"mask",
		"TVIF_STATE",
		"stateMask",
		"TVIS_SELECTED",
		"state",
		"TVM_SETITEM",
		"sizeof",
		"sizeof",
		"sizeof",
		"hItem",
		"item",
		"lParam",
		"Selection",
		"TVN_SELCHANGINGA",
		"TVN_SELCHANGINGW",
		"MULTI",
		"sizeof",
		"sizeof",
		"state",
		"TVIS_SELECTED",
		"sizeof",
		"sizeof",
		"sizeof",
		"state",
		"TVIS_SELECTED",
		"MULTI",
		"TVN_ITEMEXPANDEDA",
		"TVN_ITEMEXPANDEDW",
		"TVM_SETINSERTMARK",
		"TVN_ITEMEXPANDINGA",
		"TVN_ITEMEXPANDINGW",
		"TVM_SETINSERTMARK",
		"sizeof",
		"sizeof",
		"sizeof",
		"lParam",
		"item",
		"sizeof",
		"TVE_EXPAND",
		"state",
		"TVIS_EXPANDED",
		"Expand",
		"ZERO",
		"TVE_COLLAPSE",
		"Collapse",
		"ZERO",
		"TVN_BEGINDRAGA",
		"TVN_BEGINDRAGW",
		"TVN_BEGINRDRAGA",
		"TVN_BEGINRDRAGW",
		"sizeof",
		"sizeof",
		"sizeof",
		"hItem",
		"state",
		"TVIS_SELECTED",
		"TVM_SELECTITEM",
		"TVGN_CARET",
		"hItem",
		"NM_RECOGNIZEGESTURE",
		"IsPPC",
		"MenuDetect",
		"ONE",
		"GN_CONTEXTMENU",
		"IsPPC",
		"MenuDetect",
		"sizeof",
		"x",
		"y",
		"ONE",
		"parent",
		"style",
		"style",
		"pixel",
		"listener",
		"listener",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"hwnd",
		"hItem",
		"wHint",
		"hHint",
		"changed",
		"column",
		"index",
		"item",
		"hParent",
		"hInsertAfter",
		"column",
		"item",
		"enabled",
		"id",
		"index",
		"index",
		"point",
		"hItem",
		"hTreeItem",
		"image",
		"hItem",
		"hChild",
		"column",
		"item",
		"item",
		"tvItem",
		"nodes",
		"tvItem",
		"listener",
		"listener",
		"item",
		"before",
		"show",
		"pixel",
		"x",
		"y",
		"width",
		"height",
		"flags",
		"pixel",
		"show",
		"redraw",
		"items",
		"item",
		"hItem",
		"column",
		"item",
		"visible",
		"hdr",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam"
	],
	"extendORImplementFiles":[
		"Composite"
	],
	"package":[
		"org.eclipse.swt.widgets"
	],
	"import":[
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt",
		"org.eclipse.swt.graphics",
		"org.eclipse.swt.events"
	],
	"methods":[
		"checkStyle",
		"_getBackgroundPixel",
		"_setBackgroundPixel",
		"addSelectionListener",
		"addTreeListener",
		"borderHandle",
		"callWindowProc",
		"checkHandle",
		"checkScroll",
		"checkSubclass",
		"computeSize",
		"createHandle",
		"createItem",
		"createItem",
		"createParent",
		"createWidget",
		"defaultBackground",
		"deregister",
		"deselectAll",
		"destroyItem",
		"destroyItem",
		"enableWidget",
		"findItem",
		"getBackgroundPixel",
		"getForegroundPixel",
		"getGridLineWidth",
		"getHeaderHeight",
		"getHeaderVisible",
		"getImageSize",
		"getColumn",
		"getColumnCount",
		"getColumns",
		"getItem",
		"getItem",
		"getItemCount",
		"getItemCount",
		"getItemHeight",
		"getItems",
		"getItems",
		"getLinesVisible",
		"getParentItem",
		"getSelection",
		"getSelectionCount",
		"getTopItem",
		"imageIndex",
		"indexOf",
		"indexOf",
		"indexOf",
		"register",
		"releaseItem",
		"releaseItems",
		"releaseHandle",
		"releaseWidget",
		"removeAll",
		"removeSelectionListener",
		"removeTreeListener",
		"setInsertMark",
		"setLinesVisible",
		"scrolledHandle",
		"selectAll",
		"setBackgroundPixel",
		"setBounds",
		"setCursor",
		"setCheckboxImageList",
		"setForegroundPixel",
		"setHeaderVisible",
		"setRedraw",
		"setScrollWidth",
		"setSelection",
		"setTopItem",
		"showItem",
		"showColumn",
		"showItem",
		"showSelection",
		"showWidget",
		"toolTipText",
		"topHandle",
		"updateScrollBar",
		"widgetStyle",
		"windowClass",
		"windowProc",
		"windowProc",
		"WM_CHAR",
		"WM_GETOBJECT",
		"WM_KEYDOWN",
		"WM_KILLFOCUS",
		"WM_LBUTTONDBLCLK",
		"WM_LBUTTONDOWN",
		"WM_MOVE",
		"WM_NOTIFY",
		"WM_RBUTTONDOWN",
		"WM_PRINTCLIENT",
		"WM_SETFOCUS",
		"WM_SETFONT",
		"WM_SIZE",
		"WM_SYSCOLORCHANGE",
		"wmColorChild",
		"wmNotifyChild",
		"GetClassInfo",
		"checkStyle",
		"checkBits",
		"GetSysColor",
		"SendMessage",
		"GetSysColor",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"setCheckboxImageList",
		"checkWidget",
		"error",
		"addListener",
		"addListener",
		"checkWidget",
		"error",
		"addListener",
		"addListener",
		"DefWindowProc",
		"CallWindowProc",
		"CallWindowProc",
		"updateScrollBar",
		"CallWindowProc",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"isValidSubclass",
		"error",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"GetWindowRect",
		"SendMessage",
		"SendMessage",
		"max",
		"SendMessage",
		"getBorderWidth",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"createHandle",
		"SendMessage",
		"setCheckboxImageList",
		"GetStockObject",
		"SendMessage",
		"createParent",
		"SendMessage",
		"error",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"GetProcessHeap",
		"HeapAlloc",
		"SendMessage",
		"HeapFree",
		"GetWindowLong",
		"SetWindowLong",
		"setScrollWidth",
		"updateScrollBar",
		"SendMessage",
		"InvalidateRect",
		"arraycopy",
		"SendMessage",
		"error",
		"IsWindowVisible",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"InvalidateRect",
		"updateScrollBar",
		"forceResize",
		"GetWindowRect",
		"MapWindowPoints",
		"GetWindowLong",
		"widgetStyle",
		"CreateWindowEx",
		"widgetExtStyle",
		"windowClass",
		"GetModuleHandle",
		"error",
		"SetWindowLong",
		"VERSION",
		"CreateWindowEx",
		"GetModuleHandle",
		"error",
		"SetWindowLong",
		"ImmGetContext",
		"ImmAssociateContext",
		"ImmAssociateContext",
		"ImmReleaseContext",
		"GetWindowLong",
		"SetWindowLong",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"GetWindow",
		"SetWindowPos",
		"GetScrollInfo",
		"SetScrollInfo",
		"GetScrollInfo",
		"SetScrollInfo",
		"deregister",
		"ShowWindow",
		"GetFocus",
		"SetFocus",
		"SetParent",
		"SetFocus",
		"register",
		"createWidget",
		"GetSysColor",
		"deregister",
		"removeControl",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"GetWindowLong",
		"SetWindowLong",
		"SendMessage",
		"SetWindowLong",
		"error",
		"SendMessage",
		"SendMessage",
		"error",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"GetWindowLong",
		"SetWindowLong",
		"InvalidateRect",
		"SendMessage",
		"SendMessage",
		"GetClientRect",
		"SendMessage",
		"InvalidateRect",
		"setScrollWidth",
		"sendEvent",
		"IsWindowVisible",
		"SendMessage",
		"SendMessage",
		"UpdateWindow",
		"SendMessage",
		"releaseItems",
		"getItems",
		"releaseItem",
		"SendMessage",
		"SendMessage",
		"ValidateRect",
		"SendMessage",
		"SendMessage",
		"InvalidateRect",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"releaseImageList",
		"updateScrollBar",
		"enableWidget",
		"_setBackgroundPixel",
		"EnableWindow",
		"SendMessage",
		"_getBackgroundPixel",
		"IsWindowEnabled",
		"_getBackgroundPixel",
		"GetSysColor",
		"SendMessage",
		"GetSysColor",
		"checkWidget",
		"checkWidget",
		"GetWindowRect",
		"checkWidget",
		"GetWindowLong",
		"getImageSize",
		"getItemHeight",
		"checkWidget",
		"error",
		"SendMessage",
		"error",
		"checkWidget",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"arraycopy",
		"checkWidget",
		"error",
		"SendMessage",
		"SendMessage",
		"error",
		"SendMessage",
		"checkWidget",
		"error",
		"SendMessage",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"getItemCount",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"getItems",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"arraycopy",
		"checkWidget",
		"checkWidget",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"GetWindowLong",
		"SetWindowLong",
		"SendMessage",
		"SetWindowLong",
		"arraycopy",
		"SetWindowLong",
		"SendMessage",
		"SetWindowLong",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"GetWindowLong",
		"SetWindowLong",
		"SendMessage",
		"SetWindowLong",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"ImageList_Destroy",
		"getBounds",
		"getImageList",
		"indexOf",
		"add",
		"getHandle",
		"SendMessage",
		"SendMessage",
		"updateScrollBar",
		"indexOf",
		"add",
		"SendMessage",
		"checkWidget",
		"error",
		"isDisposed",
		"error",
		"SendMessage",
		"checkWidget",
		"error",
		"isDisposed",
		"error",
		"SendMessage",
		"indexOf",
		"register",
		"addControl",
		"isDisposed",
		"SendMessage",
		"getItems",
		"releaseItems",
		"releaseItem",
		"releaseResources",
		"releaseHandle",
		"SendMessage",
		"isDisposed",
		"releaseResources",
		"isDisposed",
		"releaseResources",
		"SendMessage",
		"SendMessage",
		"releaseImageList",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"ImageList_Destroy",
		"SendMessage",
		"SendMessage",
		"ImageList_Destroy",
		"releaseWidget",
		"checkWidget",
		"IsWindowVisible",
		"DefWindowProc",
		"SendMessage",
		"DefWindowProc",
		"InvalidateRect",
		"error",
		"isDisposed",
		"releaseResources",
		"SendMessage",
		"SendMessage",
		"releaseImageList",
		"updateScrollBar",
		"checkWidget",
		"error",
		"unhook",
		"unhook",
		"checkWidget",
		"error",
		"unhook",
		"unhook",
		"checkWidget",
		"isDisposed",
		"error",
		"SendMessage",
		"checkWidget",
		"InvalidateRect",
		"SendMessage",
		"checkWidget",
		"GetWindowLong",
		"SetWindowLong",
		"SendMessage",
		"SetWindowLong",
		"IsWindowEnabled",
		"_setBackgroundPixel",
		"SendMessage",
		"setBounds",
		"SendMessage",
		"showItem",
		"findCursor",
		"LoadCursor",
		"SetCursor",
		"SendMessage",
		"IsAppThemed",
		"ImageList_Create",
		"GetDC",
		"CreateCompatibleDC",
		"CreateCompatibleBitmap",
		"SelectObject",
		"SetRect",
		"_getBackgroundPixel",
		"CreateSolidBrush",
		"FillRect",
		"DeleteObject",
		"SelectObject",
		"defaultFont",
		"GetTextMetrics",
		"SelectObject",
		"min",
		"min",
		"SetRect",
		"IsAppThemed",
		"OpenThemeData",
		"DrawThemeBackground",
		"DrawThemeBackground",
		"DrawThemeBackground",
		"DrawThemeBackground",
		"CloseThemeData",
		"DrawFrameControl",
		"DrawFrameControl",
		"DrawFrameControl",
		"DrawFrameControl",
		"SelectObject",
		"DeleteDC",
		"ReleaseDC",
		"IsAppThemed",
		"ImageList_Add",
		"ImageList_AddMasked",
		"DeleteObject",
		"SendMessage",
		"SendMessage",
		"ImageList_Destroy",
		"SendMessage",
		"checkWidget",
		"createParent",
		"GetWindowLong",
		"SetWindowLong",
		"ShowWindow",
		"SetWindowLong",
		"ShowWindow",
		"setScrollWidth",
		"updateScrollBar",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"setRedraw",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"GetScrollInfo",
		"SetScrollInfo",
		"GetScrollInfo",
		"SetScrollInfo",
		"GetClientRect",
		"GetScrollInfo",
		"SetScrollInfo",
		"GetScrollInfo",
		"GetClientRect",
		"GetProcessHeap",
		"HeapAlloc",
		"HeapAlloc",
		"MoveMemory",
		"SendMessage",
		"MoveMemory",
		"HeapFree",
		"HeapFree",
		"SetWindowPos",
		"GetSystemMetrics",
		"SetWindowPos",
		"checkWidget",
		"error",
		"deselectAll",
		"isDisposed",
		"error",
		"SendMessage",
		"checkScroll",
		"SendMessage",
		"DefWindowProc",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"DefWindowProc",
		"SendMessage",
		"SendMessage",
		"showItem",
		"GetWindowLong",
		"SetWindowLong",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SetWindowLong",
		"checkWidget",
		"error",
		"isDisposed",
		"error",
		"checkScroll",
		"SendMessage",
		"DefWindowProc",
		"SendMessage",
		"DefWindowProc",
		"SendMessage",
		"updateScrollBar",
		"SendMessage",
		"checkScroll",
		"SendMessage",
		"DefWindowProc",
		"SendMessage",
		"SendMessage",
		"DefWindowProc",
		"SendMessage",
		"SendMessage",
		"forceResize",
		"GetClientRect",
		"PtInRect",
		"PtInRect",
		"checkScroll",
		"SendMessage",
		"DefWindowProc",
		"SendMessage",
		"DefWindowProc",
		"SendMessage",
		"SendMessage",
		"forceResize",
		"GetClientRect",
		"MapWindowPoints",
		"PtInRect",
		"PtInRect",
		"max",
		"SetScrollInfo",
		"setScrollWidth",
		"updateScrollBar",
		"checkWidget",
		"error",
		"isDisposed",
		"error",
		"indexOf",
		"SendMessage",
		"forceResize",
		"GetClientRect",
		"MapWindowPoints",
		"SendMessage",
		"PtInRect",
		"max",
		"SetScrollInfo",
		"setScrollWidth",
		"checkWidget",
		"error",
		"isDisposed",
		"error",
		"showItem",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"GetWindowLong",
		"SetWindowLong",
		"SendMessage",
		"SetWindowLong",
		"showItem",
		"showWidget",
		"ShowWindow",
		"SendMessage",
		"toolTipText",
		"SendMessage",
		"SendMessage",
		"GetScrollInfo",
		"SetScrollInfo",
		"GetScrollInfo",
		"SetScrollInfo",
		"widgetStyle",
		"sendEvent",
		"setScrollWidth",
		"setResizeChildren",
		"callWindowProc",
		"sendEvent",
		"isDisposed",
		"markLayout",
		"updateLayout",
		"setResizeChildren",
		"SendMessage",
		"GetScrollInfo",
		"SetScrollInfo",
		"SendMessage",
		"GetScrollInfo",
		"SetScrollInfo",
		"wmScroll",
		"setScrollWidth",
		"callWindowProc",
		"windowProc",
		"updateScrollBar",
		"WM_CHAR",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"NotifyWinEvent",
		"SendMessage",
		"GetKeyState",
		"SendMessage",
		"postEvent",
		"postEvent",
		"SendMessage",
		"SendMessage",
		"postEvent",
		"new_Accessible",
		"WM_GETOBJECT",
		"WM_KEYDOWN",
		"SendMessage",
		"GetKeyState",
		"SendMessage",
		"callWindowProc",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"postEvent",
		"GetKeyState",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"GetClientRect",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"UpdateWindow",
		"DefWindowProc",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"GetWindowLong",
		"SendMessage",
		"SendMessage",
		"DefWindowProc",
		"InvalidateRect",
		"InvalidateRect",
		"UpdateWindow",
		"RedrawWindow",
		"RedrawWindow",
		"callWindowProc",
		"SendMessage",
		"WM_KILLFOCUS",
		"InvalidateRect",
		"SendMessage",
		"sendMouseEvent",
		"sendMouseEvent",
		"GetCapture",
		"SetCapture",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"NotifyWinEvent",
		"postEvent",
		"WM_LBUTTONDBLCLK",
		"SendMessage",
		"postEvent",
		"SendMessage",
		"sendMouseEvent",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"callWindowProc",
		"GetCapture",
		"SetCapture",
		"SendMessage",
		"postEvent",
		"sendMouseEvent",
		"GetCapture",
		"SetCapture",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"NotifyWinEvent",
		"postEvent",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"UpdateWindow",
		"DefWindowProc",
		"deselectAll",
		"sendMouseEvent",
		"callWindowProc",
		"GetCapture",
		"SetCapture",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"GetWindowLong",
		"SendMessage",
		"SendMessage",
		"DefWindowProc",
		"InvalidateRect",
		"InvalidateRect",
		"UpdateWindow",
		"RedrawWindow",
		"RedrawWindow",
		"GetWindowLong",
		"SetWindowLong",
		"SendMessage",
		"SendMessage",
		"SetWindowLong",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"postEvent",
		"postEvent",
		"sendMouseEvent",
		"WM_MOVE",
		"MoveMemory",
		"MoveMemory",
		"getResizable",
		"MoveMemory",
		"MoveMemory",
		"SendMessage",
		"GetClientRect",
		"SendMessage",
		"getLinesVisible",
		"SendMessage",
		"SendMessage",
		"ScrollWindowEx",
		"SendMessage",
		"InvalidateRect",
		"setScrollWidth",
		"MoveMemory",
		"MoveMemory",
		"sendEvent",
		"isDisposed",
		"SendMessage",
		"arraycopy",
		"isDisposed",
		"sendEvent",
		"setScrollWidth",
		"MoveMemory",
		"postEvent",
		"MoveMemory",
		"postEvent",
		"WM_NOTIFY",
		"sendMouseEvent",
		"setFocus",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"WM_PRINTCLIENT",
		"callWindowProc",
		"WM_SETFOCUS",
		"InvalidateRect",
		"WM_SETFONT",
		"SendMessage",
		"WM_SIZE",
		"WM_SYSCOLORCHANGE",
		"setCheckboxImageList",
		"MoveMemory",
		"MoveMemory",
		"getCodePage",
		"min",
		"length",
		"MoveMemory",
		"MoveMemory",
		"min",
		"length",
		"imageIndex",
		"MoveMemory",
		"MoveMemory",
		"SendMessage",
		"SendMessage",
		"SetRect",
		"DrawEdge",
		"SendMessage",
		"SendMessage",
		"SetRect",
		"DrawEdge",
		"SaveDC",
		"SetRect",
		"DrawEdge",
		"SendMessage",
		"SendMessage",
		"CreateRectRgn",
		"SelectClipRgn",
		"DeleteObject",
		"SelectObject",
		"IsWindowEnabled",
		"SendMessage",
		"getForegroundPixel",
		"getBackgroundPixel",
		"MoveMemory",
		"RestoreDC",
		"SetBkMode",
		"IsWindowEnabled",
		"SendMessage",
		"GetTextColor",
		"GetSysColor",
		"GetBkColor",
		"GetSysColor",
		"SetTextColor",
		"getForegroundPixel",
		"win32_new",
		"SendMessage",
		"SendMessage",
		"SetRect",
		"drawBackground",
		"GetBkColor",
		"drawBackground",
		"getBounds",
		"getImageSize",
		"drawImage",
		"SetRect",
		"SetRect",
		"SelectObject",
		"SetTextColor",
		"getCodePage",
		"DrawText",
		"length",
		"SelectObject",
		"SetTextColor",
		"SetRect",
		"drawBackground",
		"GetBkColor",
		"dispose",
		"SendMessage",
		"SendMessage",
		"SetRect",
		"DrawEdge",
		"SetRect",
		"SendMessage",
		"SendMessage",
		"SetRect",
		"SendMessage",
		"SetRect",
		"SetRect",
		"DrawEdge",
		"hooks",
		"MoveMemory",
		"SendMessage",
		"MoveMemory",
		"SendMessage",
		"MoveMemory",
		"postEvent",
		"updateScrollBar",
		"MoveMemory",
		"MoveMemory",
		"deselectAll",
		"SendMessage",
		"updateScrollBar",
		"SendMessage",
		"MoveMemory",
		"MoveMemory",
		"sendEvent",
		"isDisposed",
		"sendEvent",
		"isDisposed",
		"MoveMemory",
		"SendMessage",
		"isDisposed",
		"hooks",
		"isDisposed",
		"hooks",
		"MoveMemory",
		"showMenu",
		"wmNotifyChild",
		"TCHAR",
		"WNDCLASS",
		"TypedListener",
		"TypedListener",
		"HDITEM",
		"RECT",
		"RECT",
		"Point",
		"HDITEM",
		"TVINSERTSTRUCT",
		"RECT",
		"RECT",
		"TCHAR",
		"SCROLLINFO",
		"TVITEM",
		"HDITEM",
		"RECT",
		"RECT",
		"RECT",
		"TVITEM",
		"RECT",
		"TVITEM",
		"RECT",
		"Point",
		"TVITEM",
		"TVHITTESTINFO",
		"TVITEM",
		"TVITEM",
		"TVITEM",
		"TVITEM",
		"TVITEM",
		"TVITEM",
		"TVITEM",
		"TVITEM",
		"RECT",
		"TEXTMETRICW",
		"TEXTMETRICA",
		"TVINSERTSTRUCT",
		"HDITEM",
		"RECT",
		"SCROLLINFO",
		"HDLAYOUT",
		"WINDOWPOS",
		"TVITEM",
		"TVITEM",
		"RECT",
		"RECT",
		"POINT",
		"RECT",
		"RECT",
		"POINT",
		"SCROLLINFO",
		"RECT",
		"HDITEM",
		"POINT",
		"SCROLLINFO",
		"TVITEM",
		"TVITEM",
		"SCROLLINFO",
		"SCROLLINFO",
		"TVITEM",
		"Event",
		"Event",
		"Event",
		"TVITEM",
		"TVITEM",
		"RECT",
		"RECT",
		"Event",
		"LRESULT",
		"TVITEM",
		"RECT",
		"RECT",
		"RECT",
		"RECT",
		"LRESULT",
		"TVHITTESTINFO",
		"TVITEM",
		"Event",
		"Event",
		"TVITEM",
		"TVHITTESTINFO",
		"TVITEM",
		"TVITEM",
		"Event",
		"LRESULT",
		"TVITEM",
		"Event",
		"TVITEM",
		"RECT",
		"RECT",
		"RECT",
		"RECT",
		"Event",
		"Event",
		"LRESULT",
		"NMHDR",
		"NMHEADER",
		"NMHEADER",
		"HDITEM",
		"HDITEM",
		"RECT",
		"RECT",
		"NMHEADER",
		"HDITEM",
		"NMHEADER",
		"NMHEADER",
		"TVHITTESTINFO",
		"TVITEM",
		"LRESULT",
		"NMHDR",
		"NMTVDISPINFO",
		"TCHAR",
		"NMTVCUSTOMDRAW",
		"LRESULT",
		"RECT",
		"HDITEM",
		"RECT",
		"LRESULT",
		"RECT",
		"HDITEM",
		"LRESULT",
		"TVITEM",
		"LRESULT",
		"TVITEM",
		"GCData",
		"RECT",
		"HDITEM",
		"TCHAR",
		"HDITEM",
		"RECT",
		"RECT",
		"TVITEM",
		"LRESULT",
		"TVITEM",
		"TVITEM",
		"TVITEM",
		"Event",
		"TVITEM",
		"TVITEM",
		"Event",
		"TVITEM",
		"NMRGINFO"
	],
	"methodsBody":{
		"public void setHeaderVisible(boolean show)":{
			"methodBody":"{\n    checkWidget();\n    if (hwndHeader == 0) {\n        if (!show)\n            return;\n        createParent();\n    }\n    int bits = OS.GetWindowLong(hwndHeader, OS.GWL_STYLE);\n    if (show) {\n        if ((bits & OS.HDS_HIDDEN) == 0)\n            return;\n        bits &= ~OS.HDS_HIDDEN;\n        OS.SetWindowLong(hwndHeader, OS.GWL_STYLE, bits);\n        OS.ShowWindow(hwndHeader, OS.SW_SHOW);\n    } else {\n        if ((bits & OS.HDS_HIDDEN) != 0)\n            return;\n        bits |= OS.HDS_HIDDEN;\n        OS.SetWindowLong(hwndHeader, OS.GWL_STYLE, bits);\n        OS.ShowWindow(hwndHeader, OS.SW_HIDE);\n    }\n    setScrollWidth();\n    updateScrollBar();\n}",
			"comments":"/**\n* Marks the receiver's header as visible if the argument is <code>true</code>,\n* and marks it invisible otherwise.\n* <p>\n* If one of the receiver's ancestors is not visible or some\n* other condition makes the receiver not visible, marking\n* it visible may not actually cause it to be displayed.\n* </p>\n*\n* @param show the new visibility state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public void setHeaderVisible(boolean show)"
		},
		"public boolean getLinesVisible()":{
			"methodBody":"{\n    checkWidget();\n    return linesVisible;\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver's lines are visible,\n* and <code>false</code> otherwise.\n* <p>\n* If one of the receiver's ancestors is not visible or some\n* other condition makes the receiver not visible, this method\n* may still indicate that it is considered visible even though\n* it may not actually be showing.\n* </p>\n*\n* @return the visibility state of the lines\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public boolean getLinesVisible()"
		},
		"public void selectAll()":{
			"methodBody":"{\n    checkWidget();\n    if ((style & SWT.SINGLE) != 0)\n        return;\n    TVITEM tvItem = new TVITEM();\n    tvItem.mask = OS.TVIF_STATE;\n    tvItem.state = OS.TVIS_SELECTED;\n    tvItem.stateMask = OS.TVIS_SELECTED;\n    int oldProc = OS.GetWindowLong(handle, OS.GWL_WNDPROC);\n    OS.SetWindowLong(handle, OS.GWL_WNDPROC, TreeProc);\n    for (int i = 0; i < items.length; i++) {\n        TreeItem item = items[i];\n        if (item != null) {\n            tvItem.hItem = item.handle;\n            OS.SendMessage(handle, OS.TVM_SETITEM, 0, tvItem);\n        }\n    }\n    OS.SetWindowLong(handle, OS.GWL_WNDPROC, oldProc);\n}",
			"comments":"/**\n* Selects all of the items in the receiver.\n* <p>\n* If the receiver is single-select, do nothing.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void selectAll()"
		},
		"public void removeTreeListener(TreeListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.Expand, listener);\n    eventTable.unhook(SWT.Collapse, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when items in the receiver are expanded or collapsed..\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see TreeListener\n* @see #addTreeListener\n*/\n",
			"methodName":"public void removeTreeListener(TreeListener listener)"
		},
		"LRESULT WM_LBUTTONDBLCLK(int wParam, int lParam)":{
			"methodBody":"{\n    TVHITTESTINFO lpht = new TVHITTESTINFO();\n    lpht.x = (short) (lParam & 0xFFFF);\n    lpht.y = (short) (lParam >> 16);\n    OS.SendMessage(handle, OS.TVM_HITTEST, 0, lpht);\n    if ((style & SWT.CHECK) != 0) {\n        if ((lpht.flags & OS.TVHT_ONITEMSTATEICON) != 0) {\n            sendMouseEvent(SWT.MouseDown, 1, handle, OS.WM_LBUTTONDOWN, wParam, lParam);\n            sendMouseEvent(SWT.MouseDoubleClick, 1, handle, OS.WM_LBUTTONDBLCLK, wParam, lParam);\n            if (OS.GetCapture() != handle)\n                OS.SetCapture(handle);\n            TVITEM tvItem = new TVITEM();\n            tvItem.hItem = lpht.hItem;\n            tvItem.mask = OS.TVIF_PARAM | OS.TVIF_STATE;\n            tvItem.stateMask = OS.TVIS_STATEIMAGEMASK;\n            OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem);\n            int state = tvItem.state >> 12;\n            if ((state & 0x1) != 0) {\n                state++;\n            } else {\n                --state;\n            }\n            tvItem.state = state << 12;\n            OS.SendMessage(handle, OS.TVM_SETITEM, 0, tvItem);\n            if (!OS.IsWinCE) {\n                int id = tvItem.hItem;\n                if (OS.COMCTL32_MAJOR >= 6) {\n                    id = OS.SendMessage(handle, OS.TVM_MAPHTREEITEMTOACCID, tvItem.hItem, 0);\n                }\n                OS.NotifyWinEvent(OS.EVENT_OBJECT_FOCUS, handle, OS.OBJID_CLIENT, id);\n            }\n            Event event = new Event();\n            event.item = items[tvItem.lParam];\n            event.detail = SWT.CHECK;\n            postEvent(SWT.Selection, event);\n            return LRESULT.ZERO;\n        }\n    }\n    LRESULT result = super.WM_LBUTTONDBLCLK(wParam, lParam);\n    if (lpht.hItem != 0) {\n        if ((style & SWT.FULL_SELECTION) != 0 || (lpht.flags & OS.TVHT_ONITEM) != 0) {\n            Event event = new Event();\n            TVITEM tvItem = new TVITEM();\n            tvItem.hItem = lpht.hItem;\n            tvItem.mask = OS.TVIF_PARAM;\n            OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem);\n            event.item = items[tvItem.lParam];\n            postEvent(SWT.DefaultSelection, event);\n        }\n    }\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_LBUTTONDBLCLK(int wParam, int lParam)"
		},
		"LRESULT WM_SETFOCUS(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_SETFOCUS(wParam, lParam);\n    if ((style & SWT.SINGLE) != 0)\n        return result;\n    \n    OS.InvalidateRect(handle, null, false);\n    return result;\n}",
			"comments":"/*\n* Feature in Windows.  When multiple item have\n* the TVIS_SELECTED state, Windows redraws only\n* the focused item in the color used to show the\n* selection when the tree loses or gains focus.\n* The fix is to force Windows to redraw all the\n* visible items when focus is gained or lost.\n*/\n",
			"methodName":"LRESULT WM_SETFOCUS(int wParam, int lParam)"
		},
		"void releaseItems(TreeItem[] nodes, TVITEM tvItem)":{
			"methodBody":"{\n    for (int i = 0; i < nodes.length; i++) {\n        TreeItem item = nodes[i];\n        TreeItem[] sons = item.getItems();\n        if (sons.length != 0) {\n            releaseItems(sons, tvItem);\n        }\n        if (releaseItem(item, tvItem)) {\n            item.releaseResources();\n        }\n    }\n}",
			"comments":"",
			"methodName":"void releaseItems(TreeItem[] nodes, TVITEM tvItem)"
		},
		"LRESULT WM_MOVE(int wParam, int lParam)":{
			"methodBody":"{\n    if (ignoreResize)\n        return null;\n    return super.WM_MOVE(wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_MOVE(int wParam, int lParam)"
		},
		"public void removeSelectionListener(SelectionListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    eventTable.unhook(SWT.Selection, listener);\n    eventTable.unhook(SWT.DefaultSelection, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when the receiver's selection changes.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see SelectionListener\n* @see #addSelectionListener\n*/\n",
			"methodName":"public void removeSelectionListener(SelectionListener listener)"
		},
		"void createWidget()":{
			"methodBody":"{\n    super.createWidget();\n    items = new TreeItem[4];\n    columns = new TreeColumn[4];\n}",
			"comments":"",
			"methodName":"void createWidget()"
		},
		"public TreeColumn[] getColumns()":{
			"methodBody":"{\n    checkWidget();\n    if (hwndHeader == 0)\n        return new TreeColumn[0];\n    int count = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n    TreeColumn[] result = new TreeColumn[count];\n    System.arraycopy(columns, 0, result, 0, count);\n    return result;\n}",
			"comments":"/**\n* Returns an array of <code>TreeColumn</code>s which are the\n* columns in the receiver. If no <code>TreeColumn</code>s were\n* created by the programmer, the array is empty, despite the fact\n* that visually, one column of items may be visible. This occurs\n* when the programmer uses the tree like a list, adding items but\n* never creating a column.\n* <p>\n* Note: This is not the actual structure used by the receiver\n* to maintain its list of items, so modifying the array will\n* not affect the receiver.\n* </p>\n*\n* @return the items in the receiver\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public TreeColumn[] getColumns()"
		},
		"public void setRedraw(boolean redraw)":{
			"methodBody":"{\n    checkWidget();\n    \n    int hItem = 0;\n    if (redraw && drawCount == 1) {\n        int count = OS.SendMessage(handle, OS.TVM_GETCOUNT, 0, 0);\n        if (count == 0) {\n            TVINSERTSTRUCT tvInsert = new TVINSERTSTRUCT();\n            tvInsert.hInsertAfter = OS.TVI_FIRST;\n            hItem = OS.SendMessage(handle, OS.TVM_INSERTITEM, 0, tvInsert);\n        }\n    }\n    super.setRedraw(redraw);\n    if (hItem != 0) {\n        OS.SendMessage(handle, OS.TVM_DELETEITEM, 0, hItem);\n    }\n}",
			"comments":"/*\n* Bug in Windows.  For some reason, when WM_SETREDRAW\n* is used to turn redraw on for a tree and the tree\n* contains no items, the last item in the tree does\n* not redraw properly.  If the tree has only one item,\n* that item is not drawn.  If another window is dragged\n* on top of the item, parts of the item are redrawn\n* and erased at random.  The fix is to ensure that this\n* case doesn't happen by inserting and deleting an item\n* when redraw is turned on and there are no items in\n* the tree.\n*/\n",
			"methodName":"public void setRedraw(boolean redraw)"
		},
		"LRESULT WM_SIZE(int wParam, int lParam)":{
			"methodBody":"{\n    if (ignoreResize)\n        return null;\n    return super.WM_SIZE(wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_SIZE(int wParam, int lParam)"
		},
		"boolean checkScroll(int hItem)":{
			"methodBody":"{\n    \n    if (drawCount == 0)\n        return false;\n    int hRoot = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_ROOT, 0);\n    int hParent = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_PARENT, hItem);\n    while (hParent != hRoot && hParent != 0) {\n        hParent = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_PARENT, hParent);\n    }\n    return hParent == 0;\n}",
			"comments":"/*\n* Feature in Windows.  If redraw is turned off using WM_SETREDRAW\n* and a tree item that is not a child of the first root is selected or\n* scrolled using TVM_SELECTITEM or TVM_ENSUREVISIBLE, then scrolling\n* does not occur.  The fix is to detect this case, and make sure\n* that redraw is temporarly enabled.  To avoid flashing, DefWindowProc()\n* is called to disable redrawing.\n*\n* NOTE:  The code that actually works around the problem is in the\n* callers of this method.\n*/\n",
			"methodName":"boolean checkScroll(int hItem)"
		},
		"void destroyItem(TreeColumn column)":{
			"methodBody":"{\n    if (hwndHeader == 0)\n        error(SWT.ERROR_ITEM_NOT_REMOVED);\n    int columnCount = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n    int index = 0;\n    while (index < columnCount) {\n        if (columns[index] == column)\n            break;\n        index++;\n    }\n    if (OS.SendMessage(hwndHeader, OS.HDM_DELETEITEM, index, 0) == 0) {\n        error(SWT.ERROR_ITEM_NOT_REMOVED);\n    }\n    System.arraycopy(columns, index + 1, columns, index, --columnCount - index);\n    columns[columnCount] = null;\n    for (int i = 0; i < items.length; i++) {\n        TreeItem item = items[i];\n        if (item != null) {\n            if (columnCount == 0) {\n                item.strings = null;\n                item.images = null;\n                item.cellBackground = null;\n                item.cellForeground = null;\n                item.cellFont = null;\n            } else {\n                if (item.strings != null) {\n                    String[] strings = item.strings;\n                    if (index == 0) {\n                        item.text = strings[1] != null ? strings[1] : \"\";\n                    }\n                    String[] temp = new String[columnCount];\n                    System.arraycopy(strings, 0, temp, 0, index);\n                    System.arraycopy(strings, index + 1, temp, index, columnCount - index);\n                    item.strings = temp;\n                } else {\n                    if (index == 0)\n                        item.text = \"\";\n                }\n                if (item.images != null) {\n                    Image[] images = item.images;\n                    if (index == 0)\n                        item.image = images[1];\n                    Image[] temp = new Image[columnCount];\n                    System.arraycopy(images, 0, temp, 0, index);\n                    System.arraycopy(images, index + 1, temp, index, columnCount - index);\n                    item.images = temp;\n                } else {\n                    if (index == 0)\n                        item.image = null;\n                }\n                if (item.cellBackground != null) {\n                    int[] cellBackground = item.cellBackground;\n                    int[] temp = new int[columnCount];\n                    System.arraycopy(cellBackground, 0, temp, 0, index);\n                    System.arraycopy(cellBackground, index + 1, temp, index, columnCount - index);\n                    item.cellBackground = temp;\n                }\n                if (item.cellForeground != null) {\n                    int[] cellForeground = item.cellForeground;\n                    int[] temp = new int[columnCount];\n                    System.arraycopy(cellForeground, 0, temp, 0, index);\n                    System.arraycopy(cellForeground, index + 1, temp, index, columnCount - index);\n                    item.cellForeground = temp;\n                }\n                if (item.cellFont != null) {\n                    int[] cellFont = item.cellFont;\n                    int[] temp = new int[columnCount];\n                    System.arraycopy(cellFont, 0, temp, 0, index);\n                    System.arraycopy(cellFont, index + 1, temp, index, columnCount - index);\n                    item.cellFont = temp;\n                }\n            }\n        }\n    }\n    \n    if (columnCount == 0) {\n        int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n        bits &= ~OS.TVS_NOHSCROLL;\n        OS.SetWindowLong(handle, OS.GWL_STYLE, bits);\n        OS.InvalidateRect(handle, null, true);\n    } else {\n        if (index == 0) {\n            columns[0].style &= ~(SWT.LEFT | SWT.RIGHT | SWT.CENTER);\n            columns[0].style |= SWT.LEFT;\n            HDITEM hdItem = new HDITEM();\n            hdItem.mask = OS.HDI_FORMAT | OS.HDI_IMAGE;\n            OS.SendMessage(hwndHeader, OS.HDM_GETITEM, index, hdItem);\n            hdItem.fmt &= ~OS.HDF_JUSTIFYMASK;\n            hdItem.fmt |= OS.HDF_LEFT;\n            OS.SendMessage(hwndHeader, OS.HDM_SETITEM, index, hdItem);\n        }\n        RECT rect = new RECT(), itemRect = new RECT();\n        OS.GetClientRect(handle, rect);\n        OS.SendMessage(hwndHeader, OS.HDM_GETITEMRECT, index - 1, itemRect);\n        rect.left = itemRect.right;\n        OS.InvalidateRect(handle, rect, true);\n    }\n    setScrollWidth();\n    for (int i = index; i < columnCount; i++) {\n        columns[i].sendEvent(SWT.Move);\n    }\n}",
			"comments":"/*\n* When the last column is deleted, show the horizontal\n* scroll bar.   Otherwise, left align the first column\n* and redraw the columns to the right.\n*/\n",
			"methodName":"void destroyItem(TreeColumn column)"
		},
		"int borderHandle()":{
			"methodBody":"{\n    return hwndParent != 0 ? hwndParent : handle;\n}",
			"comments":"",
			"methodName":"int borderHandle()"
		},
		"public TreeItem getItem(int index)":{
			"methodBody":"{\n    checkWidget();\n    if (index < 0)\n        error(SWT.ERROR_INVALID_RANGE);\n    int hItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_ROOT, 0);\n    while (index-- > 0 && hItem != 0) {\n        hItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_NEXT, hItem);\n    }\n    if (hItem == 0)\n        error(SWT.ERROR_INVALID_RANGE);\n    TVITEM tvItem = new TVITEM();\n    tvItem.mask = OS.TVIF_HANDLE | OS.TVIF_PARAM;\n    tvItem.hItem = hItem;\n    OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem);\n    return items[tvItem.lParam];\n}",
			"comments":"/**\n* Returns the item at the given, zero-relative index in the\n* receiver. Throws an exception if the index is out of range.\n*\n* @param index the index of the item to return\n* @return the item at the given index\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_RANGE - if the index is not between 0 and the number of elements in the list minus 1 (inclusive)</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public TreeItem getItem(int index)"
		},
		"int windowProc()":{
			"methodBody":"{\n    return TreeProc;\n}",
			"comments":"",
			"methodName":"int windowProc()"
		},
		"public int getSelectionCount()":{
			"methodBody":"{\n    checkWidget();\n    if ((style & SWT.SINGLE) != 0) {\n        int hItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);\n        if (hItem == 0)\n            return 0;\n        TVITEM tvItem = new TVITEM();\n        tvItem.mask = OS.TVIF_STATE;\n        tvItem.hItem = hItem;\n        OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem);\n        if ((tvItem.state & OS.TVIS_SELECTED) == 0)\n            return 0;\n        return 1;\n    }\n    int count = 0;\n    TVITEM tvItem = new TVITEM();\n    tvItem.mask = OS.TVIF_STATE;\n    int oldProc = OS.GetWindowLong(handle, OS.GWL_WNDPROC);\n    OS.SetWindowLong(handle, OS.GWL_WNDPROC, TreeProc);\n    for (int i = 0; i < items.length; i++) {\n        TreeItem item = items[i];\n        if (item != null) {\n            tvItem.hItem = item.handle;\n            OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem);\n            if ((tvItem.state & OS.TVIS_SELECTED) != 0)\n                count++;\n        }\n    }\n    OS.SetWindowLong(handle, OS.GWL_WNDPROC, oldProc);\n    return count;\n}",
			"comments":"/**\n* Returns the number of selected items contained in the receiver.\n*\n* @return the number of selected items\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getSelectionCount()"
		},
		"public void removeAll()":{
			"methodBody":"{\n    checkWidget();\n    ignoreDeselect = ignoreSelect = true;\n    boolean redraw = drawCount == 0 && OS.IsWindowVisible(handle);\n    if (redraw) {\n        OS.DefWindowProc(handle, OS.WM_SETREDRAW, 0, 0);\n    \n    \n    }\n    int result = OS.SendMessage(handle, OS.TVM_DELETEITEM, 0, OS.TVI_ROOT);\n    if (redraw) {\n        OS.DefWindowProc(handle, OS.WM_SETREDRAW, 1, 0);\n        \n        \n        OS.InvalidateRect(handle, null, true);\n    }\n    ignoreDeselect = ignoreSelect = false;\n    if (result == 0)\n        error(SWT.ERROR_ITEM_NOT_REMOVED);\n    for (int i = 0; i < items.length; i++) {\n        TreeItem item = items[i];\n        if (item != null && !item.isDisposed()) {\n            item.releaseResources();\n        }\n    }\n    if (imageList != null) {\n        OS.SendMessage(handle, OS.TVM_SETIMAGELIST, 0, 0);\n        if (hwndHeader != 0) {\n            OS.SendMessage(hwndHeader, OS.HDM_SETIMAGELIST, 0, 0);\n        }\n        display.releaseImageList(imageList);\n    }\n    imageList = null;\n    if (hwndParent == 0)\n        customDraw = false;\n    items = new TreeItem[4];\n    hAnchor = hInsert = 0;\n    updateScrollBar();\n}",
			"comments":"/**\n* Removes all of the items from the receiver.\n* <p>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* This code is intentionally commented.\n*/\n//\t\tOS.SendMessage (handle, OS.WM_SETREDRAW, 0, 0);\n/*\n* This code is intentionally commented.\n*/\n//\t\tOS.SendMessage (handle, OS.WM_SETREDRAW, 1, 0);\n",
			"methodName":"public void removeAll()"
		},
		"public void addSelectionListener(SelectionListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.Selection, typedListener);\n    addListener(SWT.DefaultSelection, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when the receiver's selection changes, by sending\n* it one of the messages defined in the <code>SelectionListener</code>\n* interface.\n* <p>\n* When <code>widgetSelected</code> is called, the item field of the event object is valid.\n* If the reciever has <code>SWT.CHECK</code> style set and the check selection changes,\n* the event object detail field contains the value <code>SWT.CHECK</code>.\n* <code>widgetDefaultSelected</code> is typically called when an item is double-clicked.\n* The item field of the event object is valid for default selection, but the detail field is not used.\n* </p>\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see SelectionListener\n* @see #removeSelectionListener\n* @see SelectionEvent\n*/\n",
			"methodName":"public void addSelectionListener(SelectionListener listener)"
		},
		"void setBounds(int x, int y, int width, int height, int flags)":{
			"methodBody":"{\n    \n    boolean fixSelection = false;\n    if ((flags & OS.SWP_NOSIZE) == 0 && (width != 0 || height != 0)) {\n        if (OS.SendMessage(handle, OS.TVM_GETVISIBLECOUNT, 0, 0) == 0) {\n            fixSelection = true;\n        }\n    }\n    super.setBounds(x, y, width, height, flags);\n    if (fixSelection) {\n        int hItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);\n        if (hItem != 0)\n            showItem(hItem);\n    }\n}",
			"comments":"/*\n* Ensure that the selection is visible when the tree is resized\n* from a zero size to a size that can show the selection.\n*/\n",
			"methodName":"void setBounds(int x, int y, int width, int height, int flags)"
		},
		"public int getGridLineWidth()":{
			"methodBody":"{\n    checkWidget();\n    return GRID_WIDTH;\n}",
			"comments":"/**\n* Returns the width in pixels of a grid line.\n*\n* @return the width of a grid line in pixels\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public int getGridLineWidth()"
		},
		"int getItemCount(int hItem)":{
			"methodBody":"{\n    int count = 0;\n    while (hItem != 0) {\n        hItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_NEXT, hItem);\n        count++;\n    }\n    return count;\n}",
			"comments":"",
			"methodName":"int getItemCount(int hItem)"
		},
		"public void deselectAll()":{
			"methodBody":"{\n    checkWidget();\n    TVITEM tvItem = new TVITEM();\n    tvItem.mask = OS.TVIF_STATE;\n    tvItem.stateMask = OS.TVIS_SELECTED;\n    if ((style & SWT.SINGLE) != 0) {\n        int hItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);\n        if (hItem != 0) {\n            tvItem.hItem = hItem;\n            OS.SendMessage(handle, OS.TVM_SETITEM, 0, tvItem);\n        }\n    } else {\n        int oldProc = OS.GetWindowLong(handle, OS.GWL_WNDPROC);\n        OS.SetWindowLong(handle, OS.GWL_WNDPROC, TreeProc);\n        for (int i = 0; i < items.length; i++) {\n            TreeItem item = items[i];\n            if (item != null) {\n                tvItem.hItem = item.handle;\n                OS.SendMessage(handle, OS.TVM_SETITEM, 0, tvItem);\n            }\n        }\n        OS.SetWindowLong(handle, OS.GWL_WNDPROC, oldProc);\n    }\n}",
			"comments":"/**\n* Deselects all selected items in the receiver.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void deselectAll()"
		},
		"public boolean getHeaderVisible()":{
			"methodBody":"{\n    checkWidget();\n    if (hwndHeader == 0)\n        return false;\n    int bits = OS.GetWindowLong(hwndHeader, OS.GWL_STYLE);\n    return (bits & OS.WS_VISIBLE) != 0;\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver's header is visible,\n* and <code>false</code> otherwise.\n* <p>\n* If one of the receiver's ancestors is not visible or some\n* other condition makes the receiver not visible, this method\n* may still indicate that it is considered visible even though\n* it may not actually be showing.\n* </p>\n*\n* @return the receiver's header's visibility state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public boolean getHeaderVisible()"
		},
		"public int indexOf(TreeItem item)":{
			"methodBody":"{\n    checkWidget();\n    if (item == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (item.isDisposed())\n        error(SWT.ERROR_INVALID_ARGUMENT);\n    int hItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_ROOT, 0);\n    return hItem == 0 ? -1 : indexOf(hItem, item.handle);\n}",
			"comments":"/**\n* Searches the receiver's list starting at the first item\n* (index 0) until an item is found that is equal to the\n* argument, and returns the index of that item. If no item\n* is found, returns -1.\n*\n* @param item the search item\n* @return the index of the item\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the tool item is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the tool item has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public int indexOf(TreeItem item)"
		},
		"void createItem(TreeColumn column, int index)":{
			"methodBody":"{\n    if (hwndHeader == 0)\n        createParent();\n    int columnCount = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n    if (!(0 <= index && index <= columnCount))\n        error(SWT.ERROR_INVALID_RANGE);\n    if (columnCount == columns.length) {\n        TreeColumn[] newColumns = new TreeColumn[columns.length + 4];\n        System.arraycopy(columns, 0, newColumns, 0, columns.length);\n        columns = newColumns;\n    }\n    for (int i = 0; i < items.length; i++) {\n        TreeItem item = items[i];\n        if (item != null) {\n            String[] strings = item.strings;\n            if (strings != null) {\n                String[] temp = new String[columnCount + 1];\n                System.arraycopy(strings, 0, temp, 0, index);\n                System.arraycopy(strings, index, temp, index + 1, columnCount - index);\n                item.strings = temp;\n            }\n            Image[] images = item.images;\n            if (images != null) {\n                Image[] temp = new Image[columnCount + 1];\n                System.arraycopy(images, 0, temp, 0, index);\n                System.arraycopy(images, index, temp, index + 1, columnCount - index);\n                item.images = temp;\n            }\n            if (index == 0) {\n                if (columnCount != 0) {\n                    if (strings == null) {\n                        item.strings = new String[columnCount + 1];\n                        item.strings[1] = item.text;\n                    }\n                    item.text = \"\";\n                    if (images == null) {\n                        item.images = new Image[columnCount + 1];\n                        item.images[1] = item.image;\n                    }\n                    item.image = null;\n                }\n            }\n            if (item.cellBackground != null) {\n                int[] cellBackground = item.cellBackground;\n                int[] temp = new int[columnCount + 1];\n                System.arraycopy(cellBackground, 0, temp, 0, index);\n                System.arraycopy(cellBackground, index, temp, index + 1, columnCount - index);\n                temp[index] = -1;\n                item.cellBackground = temp;\n            }\n            if (item.cellForeground != null) {\n                int[] cellForeground = item.cellForeground;\n                int[] temp = new int[columnCount + 1];\n                System.arraycopy(cellForeground, 0, temp, 0, index);\n                System.arraycopy(cellForeground, index, temp, index + 1, columnCount - index);\n                temp[index] = -1;\n                item.cellForeground = temp;\n            }\n            if (item.cellFont != null) {\n                int[] cellFont = item.cellFont;\n                int[] temp = new int[columnCount + 1];\n                System.arraycopy(cellFont, 0, temp, 0, index);\n                System.arraycopy(cellFont, index, temp, index + 1, columnCount - index);\n                temp[index] = -1;\n                item.cellFont = temp;\n            }\n        }\n    }\n    System.arraycopy(columns, index, columns, index + 1, columnCount - index);\n    columns[index] = column;\n    \n    int hHeap = OS.GetProcessHeap();\n    int pszText = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, TCHAR.sizeof);\n    HDITEM hdItem = new HDITEM();\n    hdItem.mask = OS.HDI_TEXT | OS.HDI_FORMAT;\n    hdItem.pszText = pszText;\n    if ((column.style & SWT.LEFT) == SWT.LEFT)\n        hdItem.fmt = OS.HDF_LEFT;\n    if ((column.style & SWT.CENTER) == SWT.CENTER)\n        hdItem.fmt = OS.HDF_CENTER;\n    if ((column.style & SWT.RIGHT) == SWT.RIGHT)\n        hdItem.fmt = OS.HDF_RIGHT;\n    OS.SendMessage(hwndHeader, OS.HDM_INSERTITEM, index, hdItem);\n    if (pszText != 0)\n        OS.HeapFree(hHeap, 0, pszText);\n    \n    if (columnCount == 0) {\n        int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n        bits |= OS.TVS_NOHSCROLL;\n        OS.SetWindowLong(handle, OS.GWL_STYLE, bits);\n    }\n    setScrollWidth();\n    updateScrollBar();\n    \n    if (columnCount == 0 && OS.SendMessage(handle, OS.TVM_GETCOUNT, 0, 0) != 0) {\n        OS.InvalidateRect(handle, null, true);\n    }\n}",
			"comments":"/*\n* Bug in Windows.  For some reason, when HDM_INSERTITEM\n* is used to insert an item into a header without text,\n* if is not possible to set the text at a later time.\n* The fix is to insert the item with an empty string.\n*/\n/* When the first column is created, hide the horizontal scroll bar */\n/* Redraw to hide the items when the first column is created */\n",
			"methodName":"void createItem(TreeColumn column, int index)"
		},
		"static int checkStyle(int style)":{
			"methodBody":"{\n    \n    style |= SWT.H_SCROLL | SWT.V_SCROLL;\n    return checkBits(style, SWT.SINGLE, SWT.MULTI, 0, 0, 0, 0);\n}",
			"comments":"/*\n* Feature in Windows.  It is not possible to create\n* a tree that scrolls and does not have scroll bars.\n* The TVS_NOSCROLL style will remove the scroll bars\n* but the tree will never scroll.  Therefore, no matter\n* what style bits are specified, set the H_SCROLL and\n* V_SCROLL bits so that the SWT style will match the\n* widget that Windows creates.\n*/\n",
			"methodName":"static int checkStyle(int style)"
		},
		"void showItem(int hItem)":{
			"methodBody":"{\n    \n    if (OS.SendMessage(handle, OS.TVM_GETVISIBLECOUNT, 0, 0) == 0) {\n        boolean fixScroll = checkScroll(hItem);\n        if (fixScroll) {\n            OS.SendMessage(handle, OS.WM_SETREDRAW, 1, 0);\n            OS.DefWindowProc(handle, OS.WM_SETREDRAW, 0, 0);\n        }\n        OS.SendMessage(handle, OS.TVM_SELECTITEM, OS.TVGN_FIRSTVISIBLE, hItem);\n        OS.SendMessage(handle, OS.WM_HSCROLL, OS.SB_TOP, 0);\n        if (fixScroll) {\n            OS.DefWindowProc(handle, OS.WM_SETREDRAW, 1, 0);\n            OS.SendMessage(handle, OS.WM_SETREDRAW, 0, 0);\n        }\n    } else {\n        boolean scroll = true;\n        RECT itemRect = new RECT();\n        itemRect.left = hItem;\n        if (OS.SendMessage(handle, OS.TVM_GETITEMRECT, 1, itemRect) != 0) {\n            forceResize();\n            RECT rect = new RECT();\n            OS.GetClientRect(handle, rect);\n            POINT pt = new POINT();\n            pt.x = itemRect.left;\n            pt.y = itemRect.top;\n            if (OS.PtInRect(rect, pt)) {\n                pt.y = itemRect.bottom;\n                if (OS.PtInRect(rect, pt))\n                    scroll = false;\n            }\n        }\n        if (scroll) {\n            boolean fixScroll = checkScroll(hItem);\n            if (fixScroll) {\n                OS.SendMessage(handle, OS.WM_SETREDRAW, 1, 0);\n                OS.DefWindowProc(handle, OS.WM_SETREDRAW, 0, 0);\n            }\n            OS.SendMessage(handle, OS.TVM_ENSUREVISIBLE, 0, hItem);\n            if (fixScroll) {\n                OS.DefWindowProc(handle, OS.WM_SETREDRAW, 1, 0);\n                OS.SendMessage(handle, OS.WM_SETREDRAW, 0, 0);\n            }\n        }\n    }\n    if (hwndParent != 0) {\n        RECT itemRect = new RECT();\n        itemRect.left = hItem;\n        if (OS.SendMessage(handle, OS.TVM_GETITEMRECT, 1, itemRect) != 0) {\n            forceResize();\n            RECT rect = new RECT();\n            OS.GetClientRect(hwndParent, rect);\n            OS.MapWindowPoints(hwndParent, handle, rect, 2);\n            POINT pt = new POINT();\n            pt.x = itemRect.left;\n            pt.y = itemRect.top;\n            if (!OS.PtInRect(rect, pt)) {\n                pt.y = itemRect.bottom;\n                if (!OS.PtInRect(rect, pt)) {\n                    SCROLLINFO info = new SCROLLINFO();\n                    info.cbSize = SCROLLINFO.sizeof;\n                    info.fMask = OS.SIF_POS;\n                    info.nPos = Math.max(0, pt.x - Tree.INSET / 2);\n                    OS.SetScrollInfo(hwndParent, OS.SB_HORZ, info, true);\n                    setScrollWidth();\n                }\n            }\n        }\n    }\n    updateScrollBar();\n}",
			"comments":"/*\n* Bug in Windows.  When TVM_ENSUREVISIBLE is used to ensure\n* that an item is visible and the client area of the tree is\n* smaller that the size of one item, TVM_ENSUREVISIBLE makes\n* the next item in the tree visible by making it the top item\n* instead of making the desired item visible.  The fix is to\n* detect the case when the client area is too small and make\n* the desired visible item be the top item in the tree.\n*/\n",
			"methodName":"void showItem(int hItem)"
		},
		"int getBackgroundPixel()":{
			"methodBody":"{\n    if (!OS.IsWinCE)\n        return _getBackgroundPixel();\n    \n    if (!OS.IsWindowEnabled(handle) && background != -1) {\n        return background;\n    }\n    return _getBackgroundPixel();\n}",
			"comments":"/*\n* Feature in Windows.  When a tree is given a background color\n* using TVM_SETBKCOLOR and the tree is disabled, Windows draws\n* the tree using the background color rather than the disabled\n* colors.  This is different from the table which draws grayed.\n* The fix is to set the default background color while the tree\n* is disabled and restore it when enabled.\n*/\n",
			"methodName":"int getBackgroundPixel()"
		},
		"public Point computeSize(int wHint, int hHint, boolean changed)":{
			"methodBody":"{\n    checkWidget();\n    int width = 0, height = 0;\n    if (hwndHeader != 0) {\n        HDITEM hdItem = new HDITEM();\n        hdItem.mask = OS.HDI_WIDTH;\n        int count = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n        for (int i = 0; i < count; i++) {\n            OS.SendMessage(hwndHeader, OS.HDM_GETITEM, i, hdItem);\n            width += hdItem.cxy;\n        }\n        RECT rect = new RECT();\n        OS.GetWindowRect(hwndHeader, rect);\n        height += rect.bottom - rect.top;\n    }\n    RECT rect = new RECT();\n    int hItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_ROOT, 0);\n    while (hItem != 0) {\n        rect.left = hItem;\n        if (OS.SendMessage(handle, OS.TVM_GETITEMRECT, 1, rect) != 0) {\n            width = Math.max(width, rect.right);\n            height += rect.bottom - rect.top;\n        }\n        hItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_NEXT, hItem);\n    }\n    if (width == 0)\n        width = DEFAULT_WIDTH;\n    if (height == 0)\n        height = DEFAULT_HEIGHT;\n    if (wHint != SWT.DEFAULT)\n        width = wHint;\n    if (hHint != SWT.DEFAULT)\n        height = hHint;\n    int border = getBorderWidth();\n    width += border * 2;\n    height += border * 2;\n    if ((style & SWT.V_SCROLL) != 0) {\n        width += OS.GetSystemMetrics(OS.SM_CXVSCROLL);\n    }\n    if ((style & SWT.H_SCROLL) != 0) {\n        height += OS.GetSystemMetrics(OS.SM_CYHSCROLL);\n    }\n    return new Point(width, height);\n}",
			"comments":"",
			"methodName":"public Point computeSize(int wHint, int hHint, boolean changed)"
		},
		"public TreeColumn getColumn(int index)":{
			"methodBody":"{\n    checkWidget();\n    if (hwndHeader == 0)\n        error(SWT.ERROR_INVALID_RANGE);\n    int count = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n    if (!(0 <= index && index < count))\n        error(SWT.ERROR_INVALID_RANGE);\n    return columns[index];\n}",
			"comments":"/**\n* Returns the column at the given, zero-relative index in the\n* receiver. Throws an exception if the index is out of range.\n* If no <code>TreeColumn</code>s were created by the programmer,\n* this method will throw <code>ERROR_INVALID_RANGE</code> despite\n* the fact that a single column of data may be visible in the tree.\n* This occurs when the programmer uses the tree like a list, adding\n* items but never creating a column.\n*\n* @param index the index of the column to return\n* @return the column at the given index\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_RANGE - if the index is not between 0 and the number of elements in the list minus 1 (inclusive)</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public TreeColumn getColumn(int index)"
		},
		"public void setLinesVisible(boolean show)":{
			"methodBody":"{\n    checkWidget();\n    if (linesVisible == show)\n        return;\n    linesVisible = show;\n    OS.InvalidateRect(handle, null, true);\n}",
			"comments":"/**\n* Marks the receiver's lines as visible if the argument is <code>true</code>,\n* and marks it invisible otherwise.\n* <p>\n* If one of the receiver's ancestors is not visible or some\n* other condition makes the receiver not visible, marking\n* it visible may not actually cause it to be displayed.\n* </p>\n*\n* @param show the new visibility state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public void setLinesVisible(boolean show)"
		},
		"void register()":{
			"methodBody":"{\n    super.register();\n    if (hwndParent != 0)\n        display.addControl(hwndParent, this);\n}",
			"comments":"",
			"methodName":"void register()"
		},
		"TCHAR windowClass()":{
			"methodBody":"{\n    return TreeClass;\n}",
			"comments":"",
			"methodName":"TCHAR windowClass()"
		},
		"void setCursor()":{
			"methodBody":"{\n    \n    Cursor cursor = findCursor();\n    int hCursor = cursor == null ? OS.LoadCursor(0, OS.IDC_ARROW) : cursor.handle;\n    OS.SetCursor(hCursor);\n}",
			"comments":"/*\n* Bug in Windows.  Under certain circumstances, when WM_SETCURSOR\n* is sent from SendMessage(), Windows GP's in the window proc for\n* the tree.  The fix is to avoid calling the tree window proc and\n* set the cursor for the tree outside of WM_SETCURSOR.\n*\n* NOTE:  This code assumes that the default cursor for the tree\n* is IDC_ARROW.\n*/\n",
			"methodName":"void setCursor()"
		},
		"LRESULT WM_RBUTTONDOWN(int wParam, int lParam)":{
			"methodBody":"{\n    \n    sendMouseEvent(SWT.MouseDown, 3, handle, OS.WM_RBUTTONDOWN, wParam, lParam);\n    \n    \n    setFocus();\n    \n    TVHITTESTINFO lpht = new TVHITTESTINFO();\n    lpht.x = (short) (lParam & 0xFFFF);\n    lpht.y = (short) (lParam >> 16);\n    OS.SendMessage(handle, OS.TVM_HITTEST, 0, lpht);\n    if (lpht.hItem != 0 && (lpht.flags & (OS.TVHT_ONITEMICON | OS.TVHT_ONITEMLABEL)) != 0) {\n        if ((wParam & (OS.MK_CONTROL | OS.MK_SHIFT)) == 0) {\n            TVITEM tvItem = new TVITEM();\n            tvItem.mask = OS.TVIF_STATE;\n            tvItem.stateMask = OS.TVIS_SELECTED;\n            tvItem.hItem = lpht.hItem;\n            OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem);\n            if ((tvItem.state & OS.TVIS_SELECTED) == 0) {\n                ignoreSelect = true;\n                OS.SendMessage(handle, OS.TVM_SELECTITEM, OS.TVGN_CARET, 0);\n                ignoreSelect = false;\n                OS.SendMessage(handle, OS.TVM_SELECTITEM, OS.TVGN_CARET, lpht.hItem);\n            }\n        }\n    }\n    return LRESULT.ZERO;\n}",
			"comments":"/*\n* Feature in Windows.  The receiver uses WM_RBUTTONDOWN\n* to initiate a drag/drop operation depending on how the\n* user moves the mouse.  If the user clicks the right button,\n* without moving the mouse, the tree consumes the corresponding\n* WM_RBUTTONUP.  The fix is to avoid calling the window proc for\n* the tree.\n*/\n/*\n* This code is intentionally commented.\n*/\n//\tif (OS.GetCapture () != handle) OS.SetCapture (handle);\n/*\n* Feature in Windows.  When the user selects a tree item\n* with the right mouse button, the item remains selected\n* only as long as the user does not release or move the\n* mouse.  As soon as this happens, the selection snaps\n* back to the previous selection.  This behavior can be\n* observed in the Explorer but is not instantly apparent\n* because the Explorer explicity sets the selection when\n* the user chooses a menu item.  If the user cancels the\n* menu, the selection snaps back.  The fix is to avoid\n* calling the window proc and do the selection ourselves.\n* This behavior is consistent with the table.\n*/\n",
			"methodName":"LRESULT WM_RBUTTONDOWN(int wParam, int lParam)"
		},
		"String toolTipText(NMTTDISPINFO hdr)":{
			"methodBody":"{\n    int hwndToolTip = OS.SendMessage(handle, OS.TVM_GETTOOLTIPS, 0, 0);\n    \n    if (hwndToolTip == hdr.hwndFrom && toolTipText != null)\n        return \"\";\n    return super.toolTipText(hdr);\n}",
			"comments":"//$NON-NLS-1$\n",
			"methodName":"String toolTipText(NMTTDISPINFO hdr)"
		},
		"void releaseWidget()":{
			"methodBody":"{\n    int columnCount = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n    for (int i = 0; i < items.length; i++) {\n        TreeItem item = items[i];\n        if (item != null && !item.isDisposed()) {\n            item.releaseResources();\n        }\n    }\n    items = null;\n    for (int i = 0; i < columnCount; i++) {\n        TreeColumn column = columns[i];\n        if (!column.isDisposed())\n            column.releaseResources();\n    }\n    columns = null;\n    \n    customDraw = false;\n    if (imageList != null) {\n        OS.SendMessage(handle, OS.TVM_SETIMAGELIST, OS.TVSIL_NORMAL, 0);\n        OS.SendMessage(hwndHeader, OS.HDM_SETIMAGELIST, 0, 0);\n        display.releaseImageList(imageList);\n    } else {\n        int hOldList = OS.SendMessage(handle, OS.TVM_GETIMAGELIST, OS.TVSIL_NORMAL, 0);\n        OS.SendMessage(handle, OS.TVM_SETIMAGELIST, OS.TVSIL_NORMAL, 0);\n        OS.SendMessage(hwndHeader, OS.HDM_SETIMAGELIST, 0, 0);\n        if (hOldList != 0)\n            OS.ImageList_Destroy(hOldList);\n    }\n    imageList = null;\n    int hOldList = OS.SendMessage(handle, OS.TVM_GETIMAGELIST, OS.TVSIL_STATE, 0);\n    OS.SendMessage(handle, OS.TVM_SETIMAGELIST, OS.TVSIL_STATE, 0);\n    if (hOldList != 0)\n        OS.ImageList_Destroy(hOldList);\n    super.releaseWidget();\n}",
			"comments":"/*\n* Feature in Windows.  For some reason, when TVM_GETIMAGELIST\n* or TVM_SETIMAGELIST is sent, the tree issues NM_CUSTOMDRAW\n* messages.  This behavior is unwanted when the tree is being\n* disposed.  The fix is to ingore NM_CUSTOMDRAW messages by\n* clearing the custom draw flag.\n*\n* NOTE: This only happens on Windows XP.\n*/\n",
			"methodName":"void releaseWidget()"
		},
		"int callWindowProc(int hwnd, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    if (handle == 0)\n        return 0;\n    if (hwndParent != 0 && hwnd == hwndParent) {\n        return OS.DefWindowProc(hwnd, msg, wParam, lParam);\n    }\n    switch(msg) {\n        \n        case OS.WM_LBUTTONDOWN:\n        case OS.WM_MBUTTONDOWN:\n        case OS.WM_RBUTTONDOWN:\n        case OS.WM_XBUTTONDOWN:\n            {\n                Display display = this.display;\n                display.ignoreMsgFilter = true;\n                int code = OS.CallWindowProc(TreeProc, hwnd, msg, wParam, lParam);\n                display.ignoreMsgFilter = false;\n                return code;\n            }\n        case OS.WM_MOUSEWHEEL:\n            {\n                int code = OS.CallWindowProc(TreeProc, hwnd, msg, wParam, lParam);\n                updateScrollBar();\n                return code;\n            }\n    }\n    return OS.CallWindowProc(TreeProc, hwnd, msg, wParam, lParam);\n}",
			"comments":"/*\n* Bug in Windows.  For some reason, when the user clicks\n* on this control, the Windows hook WH_MSGFILTER is sent\n* despite the fact that an input event from a dialog box,\n* message box, menu, or scroll bar did not seem to occur.\n* The fix is to ignore the hook.\n*/\n",
			"methodName":"int callWindowProc(int hwnd, int msg, int wParam, int lParam)"
		},
		"int scrolledHandle()":{
			"methodBody":"{\n    if (hwndHeader == 0)\n        return handle;\n    int count = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n    return count == 0 ? handle : hwndParent;\n}",
			"comments":"",
			"methodName":"int scrolledHandle()"
		},
		"int windowProc(int hwnd, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    if (hwndParent != 0 && hwnd == hwndParent) {\n        switch(msg) {\n            case OS.WM_MOVE:\n                {\n                    sendEvent(SWT.Move);\n                    return 0;\n                }\n            case OS.WM_SIZE:\n                {\n                    setScrollWidth();\n                    if (ignoreResize)\n                        return 0;\n                    setResizeChildren(false);\n                    int code = callWindowProc(hwnd, OS.WM_SIZE, wParam, lParam);\n                    sendEvent(SWT.Resize);\n                    if (isDisposed())\n                        return 0;\n                    if (layout != null) {\n                        markLayout(false, false);\n                        updateLayout(false, false);\n                    }\n                    setResizeChildren(true);\n                    return code;\n                }\n            case OS.WM_COMMAND:\n            case OS.WM_NOTIFY:\n            case OS.WM_SYSCOLORCHANGE:\n                {\n                    return OS.SendMessage(handle, msg, wParam, lParam);\n                }\n            case OS.WM_VSCROLL:\n                {\n                    SCROLLINFO info = new SCROLLINFO();\n                    info.cbSize = SCROLLINFO.sizeof;\n                    info.fMask = OS.SIF_ALL;\n                    OS.GetScrollInfo(hwndParent, OS.SB_VERT, info);\n                    OS.SetScrollInfo(handle, OS.SB_VERT, info, true);\n                    int code = OS.SendMessage(handle, OS.WM_VSCROLL, wParam, lParam);\n                    OS.GetScrollInfo(handle, OS.SB_VERT, info);\n                    OS.SetScrollInfo(hwndParent, OS.SB_VERT, info, true);\n                    return code;\n                }\n            case OS.WM_HSCROLL:\n                {\n                    \n                    if (horizontalBar != null && (lParam == 0 || lParam == hwndParent)) {\n                        wmScroll(horizontalBar, true, hwndParent, OS.WM_HSCROLL, wParam, lParam);\n                    }\n                    setScrollWidth();\n                    break;\n                }\n        }\n        return callWindowProc(hwnd, msg, wParam, lParam);\n    }\n    int code = super.windowProc(handle, msg, wParam, lParam);\n    switch(msg) {\n        \n        case OS.WM_CHAR:\n        case OS.WM_IME_CHAR:\n        case OS.WM_KEYDOWN:\n        case OS.WM_KEYUP:\n        case OS.WM_SYSCHAR:\n        case OS.WM_SYSKEYDOWN:\n        case OS.WM_SYSKEYUP:\n        \n        case OS.WM_LBUTTONDBLCLK:\n        case OS.WM_LBUTTONDOWN:\n        case OS.WM_LBUTTONUP:\n        case OS.WM_MBUTTONDBLCLK:\n        case OS.WM_MBUTTONDOWN:\n        case OS.WM_MBUTTONUP:\n        case OS.WM_MOUSEHOVER:\n        case OS.WM_MOUSELEAVE:\n        case OS.WM_MOUSEMOVE:\n        case OS.WM_MOUSEWHEEL:\n        case OS.WM_RBUTTONDBLCLK:\n        case OS.WM_RBUTTONDOWN:\n        case OS.WM_RBUTTONUP:\n        case OS.WM_XBUTTONDBLCLK:\n        case OS.WM_XBUTTONDOWN:\n        case OS.WM_XBUTTONUP:\n        \n        case OS.WM_SIZE:\n        case OS.WM_SETFONT:\n        case OS.WM_TIMER:\n            {\n                updateScrollBar();\n            }\n    }\n    return code;\n}",
			"comments":"/*\n* Bug on WinCE.  lParam should be NULL when the message is not sent\n* by a scroll bar control, but it contains the handle to the window.\n* When the message is sent by a scroll bar control, it correctly\n* contains the handle to the scroll bar.  The fix is to check for\n* both.\n*/\n/* Keyboard messages */\n/* Mouse messages */\n/* Other messages */\n",
			"methodName":"int windowProc(int hwnd, int msg, int wParam, int lParam)"
		},
		"void enableWidget(boolean enabled)":{
			"methodBody":"{\n    super.enableWidget(enabled);\n    \n    if (background != -1) {\n        _setBackgroundPixel(enabled ? background : -1);\n    }\n    if (hwndParent != 0)\n        OS.EnableWindow(hwndParent, enabled);\n}",
			"comments":"/*\n* Feature in Windows.  When a tree is given a background color\n* using TVM_SETBKCOLOR and the tree is disabled, Windows draws\n* the tree using the background color rather than the disabled\n* colors.  This is different from the table which draws grayed.\n* The fix is to set the default background color while the tree\n* is disabled and restore it when enabled.\n*/\n",
			"methodName":"void enableWidget(boolean enabled)"
		},
		"void deregister()":{
			"methodBody":"{\n    super.deregister();\n    if (hwndParent != 0)\n        display.removeControl(hwndParent);\n}",
			"comments":"",
			"methodName":"void deregister()"
		},
		"protected void checkSubclass()":{
			"methodBody":"{\n    if (!isValidSubclass())\n        error(SWT.ERROR_INVALID_SUBCLASS);\n}",
			"comments":"",
			"methodName":"protected void checkSubclass()"
		},
		"public TreeItem[] getItems()":{
			"methodBody":"{\n    checkWidget();\n    int hItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_ROOT, 0);\n    if (hItem == 0)\n        return new TreeItem[0];\n    return getItems(hItem);\n}",
			"comments":"/**\n* Returns a (possibly empty) array of items contained in the\n* receiver that are direct item children of the receiver.  These\n* are the roots of the tree.\n* <p>\n* Note: This is not the actual structure used by the receiver\n* to maintain its list of items, so modifying the array will\n* not affect the receiver.\n* </p>\n*\n* @return the items\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public TreeItem[] getItems()"
		},
		"public int getColumnCount()":{
			"methodBody":"{\n    checkWidget();\n    if (hwndHeader == 0)\n        return 0;\n    return OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n}",
			"comments":"/**\n* Returns the number of columns contained in the receiver.\n* If no <code>TreeColumn</code>s were created by the programmer,\n* this value is zero, despite the fact that visually, one column\n* of items may be visible. This occurs when the programmer uses\n* the tree like a list, adding items but never creating a column.\n*\n* @return the number of columns\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public int getColumnCount()"
		},
		"void setCheckboxImageList()":{
			"methodBody":"{\n    if ((style & SWT.CHECK) == 0)\n        return;\n    int count = 5;\n    int height = OS.SendMessage(handle, OS.TVM_GETITEMHEIGHT, 0, 0), width = height;\n    int flags = ImageList.COLOR_FLAGS;\n    if ((style & SWT.RIGHT_TO_LEFT) != 0)\n        flags |= OS.ILC_MIRROR;\n    if (OS.COMCTL32_MAJOR < 6 || !OS.IsAppThemed())\n        flags |= OS.ILC_MASK;\n    int hImageList = OS.ImageList_Create(width, height, flags, count, count);\n    int hDC = OS.GetDC(handle);\n    int memDC = OS.CreateCompatibleDC(hDC);\n    int hBitmap = OS.CreateCompatibleBitmap(hDC, width * count, height);\n    int hOldBitmap = OS.SelectObject(memDC, hBitmap);\n    RECT rect = new RECT();\n    OS.SetRect(rect, 0, 0, width * count, height);\n    int clrBackground = _getBackgroundPixel();\n    int hBrush = OS.CreateSolidBrush(clrBackground);\n    OS.FillRect(memDC, rect, hBrush);\n    OS.DeleteObject(hBrush);\n    int oldFont = OS.SelectObject(hDC, defaultFont());\n    TEXTMETRIC tm = OS.IsUnicode ? (TEXTMETRIC) new TEXTMETRICW() : new TEXTMETRICA();\n    OS.GetTextMetrics(hDC, tm);\n    OS.SelectObject(hDC, oldFont);\n    int itemWidth = Math.min(tm.tmHeight, width);\n    int itemHeight = Math.min(tm.tmHeight, height);\n    int left = (width - itemWidth) / 2, top = (height - itemHeight) / 2 + 1;\n    OS.SetRect(rect, left + width, top, left + width + itemWidth, top + itemHeight);\n    if (OS.COMCTL32_MAJOR >= 6 && OS.IsAppThemed()) {\n        int hTheme = OS.OpenThemeData(handle, BUTTON);\n        OS.DrawThemeBackground(hTheme, memDC, OS.BP_CHECKBOX, OS.CBS_UNCHECKEDNORMAL, rect, null);\n        rect.left += width;\n        rect.right += width;\n        OS.DrawThemeBackground(hTheme, memDC, OS.BP_CHECKBOX, OS.CBS_CHECKEDNORMAL, rect, null);\n        rect.left += width;\n        rect.right += width;\n        OS.DrawThemeBackground(hTheme, memDC, OS.BP_CHECKBOX, OS.CBS_UNCHECKEDNORMAL, rect, null);\n        rect.left += width;\n        rect.right += width;\n        OS.DrawThemeBackground(hTheme, memDC, OS.BP_CHECKBOX, OS.CBS_MIXEDNORMAL, rect, null);\n        OS.CloseThemeData(hTheme);\n    } else {\n        OS.DrawFrameControl(memDC, rect, OS.DFC_BUTTON, OS.DFCS_BUTTONCHECK | OS.DFCS_FLAT);\n        rect.left += width;\n        rect.right += width;\n        OS.DrawFrameControl(memDC, rect, OS.DFC_BUTTON, OS.DFCS_BUTTONCHECK | OS.DFCS_CHECKED | OS.DFCS_FLAT);\n        rect.left += width;\n        rect.right += width;\n        OS.DrawFrameControl(memDC, rect, OS.DFC_BUTTON, OS.DFCS_BUTTONCHECK | OS.DFCS_INACTIVE | OS.DFCS_FLAT);\n        rect.left += width;\n        rect.right += width;\n        OS.DrawFrameControl(memDC, rect, OS.DFC_BUTTON, OS.DFCS_BUTTONCHECK | OS.DFCS_CHECKED | OS.DFCS_INACTIVE | OS.DFCS_FLAT);\n    }\n    OS.SelectObject(memDC, hOldBitmap);\n    OS.DeleteDC(memDC);\n    OS.ReleaseDC(handle, hDC);\n    if (OS.COMCTL32_MAJOR >= 6 && OS.IsAppThemed()) {\n        OS.ImageList_Add(hImageList, hBitmap, 0);\n    } else {\n        OS.ImageList_AddMasked(hImageList, hBitmap, clrBackground);\n    }\n    OS.DeleteObject(hBitmap);\n    int hOldList = OS.SendMessage(handle, OS.TVM_GETIMAGELIST, OS.TVSIL_STATE, 0);\n    OS.SendMessage(handle, OS.TVM_SETIMAGELIST, OS.TVSIL_STATE, hImageList);\n    if (hOldList != 0)\n        OS.ImageList_Destroy(hOldList);\n}",
			"comments":"",
			"methodName":"void setCheckboxImageList()"
		},
		"int defaultBackground()":{
			"methodBody":"{\n    return OS.GetSysColor(OS.COLOR_WINDOW);\n}",
			"comments":"",
			"methodName":"int defaultBackground()"
		},
		"public void showColumn(TreeColumn column)":{
			"methodBody":"{\n    checkWidget();\n    if (column == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (column.isDisposed())\n        error(SWT.ERROR_INVALID_ARGUMENT);\n    if (column.parent != this)\n        return;\n    int index = indexOf(column);\n    if (index == -1)\n        return;\n    int count = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n    if (0 <= index && index < count) {\n        if (hwndParent != 0) {\n            forceResize();\n            RECT rect = new RECT();\n            OS.GetClientRect(hwndParent, rect);\n            OS.MapWindowPoints(hwndParent, handle, rect, 2);\n            int x = 0;\n            HDITEM hdItem = new HDITEM();\n            for (int i = 0; i < index; i++) {\n                hdItem.mask = OS.HDI_WIDTH;\n                OS.SendMessage(hwndHeader, OS.HDM_GETITEM, i, hdItem);\n                x += hdItem.cxy;\n            }\n            POINT pt = new POINT();\n            pt.x = x;\n            pt.y = rect.top;\n            if (!OS.PtInRect(rect, pt)) {\n                SCROLLINFO info = new SCROLLINFO();\n                info.cbSize = SCROLLINFO.sizeof;\n                info.fMask = OS.SIF_POS;\n                info.nPos = Math.max(0, pt.x - Tree.INSET / 2);\n                OS.SetScrollInfo(hwndParent, OS.SB_HORZ, info, true);\n                setScrollWidth();\n            }\n        }\n    }\n}",
			"comments":"/**\n* Shows the column.  If the column is already showing in the receiver,\n* this method simply returns.  Otherwise, the columns are scrolled until\n* the column is visible.\n*\n* @param column the column to be shown\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the item is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the item has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public void showColumn(TreeColumn column)"
		},
		"public void showItem(TreeItem item)":{
			"methodBody":"{\n    checkWidget();\n    if (item == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (item.isDisposed())\n        error(SWT.ERROR_INVALID_ARGUMENT);\n    showItem(item.handle);\n}",
			"comments":"/**\n* Shows the item.  If the item is already showing in the receiver,\n* this method simply returns.  Otherwise, the items are scrolled\n* and expanded until the item is visible.\n*\n* @param item the item to be shown\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the item is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the item has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see Tree#showSelection()\n*/\n",
			"methodName":"public void showItem(TreeItem item)"
		},
		"public int getHeaderHeight()":{
			"methodBody":"{\n    checkWidget();\n    if (hwndHeader == 0)\n        return 0;\n    RECT rect = new RECT();\n    OS.GetWindowRect(hwndHeader, rect);\n    return rect.bottom - rect.top;\n}",
			"comments":"/**\n* Returns the height of the receiver's header\n*\n* @return the height of the header or zero if the header is not visible\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public int getHeaderHeight()"
		},
		"void _setBackgroundPixel(int pixel)":{
			"methodBody":"{\n    \n    int oldPixel = OS.SendMessage(handle, OS.TVM_GETBKCOLOR, 0, 0);\n    if (oldPixel != -1)\n        OS.SendMessage(handle, OS.TVM_SETBKCOLOR, 0, -1);\n    OS.SendMessage(handle, OS.TVM_SETBKCOLOR, 0, pixel);\n    if ((style & SWT.CHECK) != 0)\n        setCheckboxImageList();\n}",
			"comments":"/*\n* Bug in Windows.  When TVM_GETBKCOLOR is used more\n* than once to set the background color of a tree,\n* the background color of the lines and the plus/minus\n* does not change to the new color.  The fix is to set\n* the background color to the default before setting\n* the new color.\n*/\n",
			"methodName":"void _setBackgroundPixel(int pixel)"
		},
		"LRESULT WM_CHAR(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_CHAR(wParam, lParam);\n    if (result != null)\n        return result;\n    \n    switch(wParam) {\n        case ' ':\n            {\n                int hItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);\n                if (hItem != 0) {\n                    hAnchor = hItem;\n                    OS.SendMessage(handle, OS.TVM_ENSUREVISIBLE, 0, hItem);\n                    TVITEM tvItem = new TVITEM();\n                    tvItem.mask = OS.TVIF_STATE | OS.TVIF_PARAM;\n                    tvItem.hItem = hItem;\n                    if ((style & SWT.CHECK) != 0) {\n                        tvItem.stateMask = OS.TVIS_STATEIMAGEMASK;\n                        OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem);\n                        int state = tvItem.state >> 12;\n                        if ((state & 0x1) != 0) {\n                            state++;\n                        } else {\n                            --state;\n                        }\n                        tvItem.state = state << 12;\n                        OS.SendMessage(handle, OS.TVM_SETITEM, 0, tvItem);\n                        if (!OS.IsWinCE) {\n                            int id = hItem;\n                            if (OS.COMCTL32_MAJOR >= 6) {\n                                id = OS.SendMessage(handle, OS.TVM_MAPHTREEITEMTOACCID, hItem, 0);\n                            }\n                            OS.NotifyWinEvent(OS.EVENT_OBJECT_FOCUS, handle, OS.OBJID_CLIENT, id);\n                        }\n                    }\n                    tvItem.stateMask = OS.TVIS_SELECTED;\n                    OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem);\n                    if ((style & SWT.MULTI) != 0 && OS.GetKeyState(OS.VK_CONTROL) < 0) {\n                        if ((tvItem.state & OS.TVIS_SELECTED) != 0) {\n                            tvItem.state &= ~OS.TVIS_SELECTED;\n                        } else {\n                            tvItem.state |= OS.TVIS_SELECTED;\n                        }\n                    } else {\n                        tvItem.state |= OS.TVIS_SELECTED;\n                    }\n                    OS.SendMessage(handle, OS.TVM_SETITEM, 0, tvItem);\n                    Event event = new Event();\n                    event.item = items[tvItem.lParam];\n                    postEvent(SWT.Selection, event);\n                    if ((style & SWT.CHECK) != 0) {\n                        event = new Event();\n                        event.item = items[tvItem.lParam];\n                        event.detail = SWT.CHECK;\n                        postEvent(SWT.Selection, event);\n                    }\n                }\n                return LRESULT.ZERO;\n            }\n        case SWT.CR:\n            {\n                \n                Event event = new Event();\n                int hItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);\n                if (hItem != 0) {\n                    TVITEM tvItem = new TVITEM();\n                    tvItem.hItem = hItem;\n                    tvItem.mask = OS.TVIF_PARAM;\n                    OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem);\n                    event.item = items[tvItem.lParam];\n                }\n                postEvent(SWT.DefaultSelection, event);\n                return LRESULT.ZERO;\n            }\n        case SWT.ESC:\n            return LRESULT.ZERO;\n    }\n    return result;\n}",
			"comments":"/*\n* Feature in Windows.  The tree control beeps\n* in WM_CHAR when the search for the item that\n* matches the key stroke fails.  This is the\n* standard tree behavior but is unexpected when\n* the key that was typed was ESC, CR or SPACE.\n* The fix is to avoid calling the tree window\n* proc in these cases.\n*/\n/*\n* Feature in Windows.  Windows sends NM_RETURN from WM_KEYDOWN\n* instead of using WM_CHAR.  This means that application code\n* that expects to consume the key press and therefore avoid a\n* SWT.DefaultSelection event from WM_CHAR will fail.  The fix\n* is to implement SWT.DefaultSelection in WM_CHAR instead of\n* using NM_RETURN.\n*/\n",
			"methodName":"LRESULT WM_CHAR(int wParam, int lParam)"
		},
		"void createHandle()":{
			"methodBody":"{\n    super.createHandle();\n    state &= ~CANVAS;\n    \n    if (!OS.IsWinCE) {\n        if (OS.COMCTL32_MAJOR < 6) {\n            OS.SendMessage(handle, OS.CCM_SETVERSION, 5, 0);\n        }\n    }\n    \n    if ((style & SWT.CHECK) != 0)\n        setCheckboxImageList();\n    \n    int hFont = OS.GetStockObject(OS.SYSTEM_FONT);\n    OS.SendMessage(handle, OS.WM_SETFONT, hFont, 0);\n}",
			"comments":"/*\n* Feature in Windows.  In version 5.8 of COMCTL32.DLL,\n* if the font is changed for an item, the bounds for the\n* item are not updated, causing the text to be clipped.\n* The fix is to detect the version of COMCTL32.DLL, and\n* if it is one of the versions with the problem, then\n* use version 5.00 of the control (a version that does\n* not have the problem).  This is the recomended work\n* around from the MSDN.\n*/\n/* Set the checkbox image list */\n/*\n* Feature in Windows.  When the control is created,\n* it does not use the default system font.  A new HFONT\n* is created and destroyed when the control is destroyed.\n* This means that a program that queries the font from\n* this control, uses the font in another control and then\n* destroys this control will have the font unexpectedly\n* destroyed in the other control.  The fix is to assign\n* the font ourselves each time the control is created.\n* The control will not destroy a font that it did not\n* create.\n*/\n",
			"methodName":"void createHandle()"
		},
		"LRESULT WM_SYSCOLORCHANGE(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_SYSCOLORCHANGE(wParam, lParam);\n    if (result != null)\n        return result;\n    if ((style & SWT.CHECK) != 0)\n        setCheckboxImageList();\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_SYSCOLORCHANGE(int wParam, int lParam)"
		},
		"public TreeItem getItem(Point point)":{
			"methodBody":"{\n    checkWidget();\n    if (point == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TVHITTESTINFO lpht = new TVHITTESTINFO();\n    lpht.x = point.x;\n    lpht.y = point.y;\n    OS.SendMessage(handle, OS.TVM_HITTEST, 0, lpht);\n    if (lpht.hItem != 0) {\n        if ((style & SWT.FULL_SELECTION) != 0 || (lpht.flags & OS.TVHT_ONITEM) != 0) {\n            TVITEM tvItem = new TVITEM();\n            tvItem.mask = OS.TVIF_HANDLE | OS.TVIF_PARAM;\n            tvItem.hItem = lpht.hItem;\n            OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem);\n            return items[tvItem.lParam];\n        }\n    }\n    return null;\n}",
			"comments":"/**\n* Returns the item at the given point in the receiver\n* or null if no such item exists. The point is in the\n* coordinate system of the receiver.\n*\n* @param point the point used to locate the item\n* @return the item at the given point\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the point is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public TreeItem getItem(Point point)"
		},
		"public int indexOf(TreeColumn column)":{
			"methodBody":"{\n    checkWidget();\n    if (column == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (column.isDisposed())\n        error(SWT.ERROR_INVALID_ARGUMENT);\n    if (hwndHeader == 0)\n        return -1;\n    int count = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n    for (int i = 0; i < count; i++) {\n        if (columns[i] == column)\n            return i;\n    }\n    return -1;\n}",
			"comments":"/**\n* Searches the receiver's list starting at the first column\n* (index 0) until a column is found that is equal to the\n* argument, and returns the index of that column. If no column\n* is found, returns -1.\n*\n* @param column the search column\n* @return the index of the column\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the string is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public int indexOf(TreeColumn column)"
		},
		"int topHandle()":{
			"methodBody":"{\n    return hwndParent != 0 ? hwndParent : handle;\n}",
			"comments":"",
			"methodName":"int topHandle()"
		},
		"int indexOf(int hItem, int hChild)":{
			"methodBody":"{\n    int index = 0;\n    while (hItem != 0 && hItem != hChild) {\n        hItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_NEXT, hItem);\n        index++;\n    }\n    return hItem == hChild ? index : -1;\n}",
			"comments":"",
			"methodName":"int indexOf(int hItem, int hChild)"
		},
		"void createParent()":{
			"methodBody":"{\n    forceResize();\n    RECT rect = new RECT();\n    OS.GetWindowRect(handle, rect);\n    OS.MapWindowPoints(0, parent.handle, rect, 2);\n    int oldStyle = OS.GetWindowLong(handle, OS.GWL_STYLE);\n    int newStyle = super.widgetStyle() & ~OS.WS_VISIBLE;\n    if ((oldStyle & OS.WS_DISABLED) != 0)\n        newStyle |= OS.WS_DISABLED;\n    \n    hwndParent = OS.CreateWindowEx(super.widgetExtStyle(), super.windowClass(), null, newStyle, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, parent.handle, 0, OS.GetModuleHandle(null), null);\n    if (hwndParent == 0)\n        error(SWT.ERROR_NO_HANDLES);\n    OS.SetWindowLong(hwndParent, OS.GWL_ID, hwndParent);\n    int bits = 0;\n    if (OS.WIN32_VERSION >= OS.VERSION(4, 10)) {\n        bits |= OS.WS_EX_NOINHERITLAYOUT;\n        if ((style & SWT.RIGHT_TO_LEFT) != 0)\n            bits |= OS.WS_EX_LAYOUTRTL;\n    }\n    hwndHeader = OS.CreateWindowEx(bits, new TCHAR(0, OS.WC_HEADER, true), null, OS.HDS_BUTTONS | OS.HDS_FULLDRAG | OS.HDS_HIDDEN | OS.WS_CHILD | OS.WS_CLIPSIBLINGS, 0, 0, 0, 0, hwndParent, 0, OS.GetModuleHandle(null), null);\n    if (hwndHeader == 0)\n        error(SWT.ERROR_NO_HANDLES);\n    OS.SetWindowLong(hwndHeader, OS.GWL_ID, hwndHeader);\n    if (OS.IsDBLocale) {\n        int hIMC = OS.ImmGetContext(handle);\n        OS.ImmAssociateContext(hwndParent, hIMC);\n        OS.ImmAssociateContext(hwndHeader, hIMC);\n        OS.ImmReleaseContext(handle, hIMC);\n    }\n    if (!OS.IsPPC) {\n        if ((style & SWT.BORDER) != 0) {\n            int oldExStyle = OS.GetWindowLong(handle, OS.GWL_EXSTYLE);\n            oldExStyle &= ~OS.WS_EX_CLIENTEDGE;\n            OS.SetWindowLong(handle, OS.GWL_EXSTYLE, oldExStyle);\n        }\n    }\n    int hFont = OS.SendMessage(handle, OS.WM_GETFONT, 0, 0);\n    if (hFont != 0)\n        OS.SendMessage(hwndHeader, OS.WM_SETFONT, hFont, 0);\n    int hImageList = OS.SendMessage(handle, OS.TVM_GETIMAGELIST, OS.TVSIL_NORMAL, 0);\n    if (hImageList != 0) {\n        OS.SendMessage(hwndHeader, OS.HDM_SETIMAGELIST, 0, hImageList);\n    }\n    int hwndInsertAfter = OS.GetWindow(handle, OS.GW_HWNDPREV);\n    int flags = OS.SWP_NOSIZE | OS.SWP_NOMOVE | OS.SWP_NOACTIVATE;\n    SetWindowPos(hwndParent, hwndInsertAfter, 0, 0, 0, 0, flags);\n    SCROLLINFO info = new SCROLLINFO();\n    info.cbSize = SCROLLINFO.sizeof;\n    info.fMask = OS.SIF_RANGE | OS.SIF_PAGE;\n    OS.GetScrollInfo(hwndParent, OS.SB_HORZ, info);\n    info.nPage = info.nMax + 1;\n    OS.SetScrollInfo(hwndParent, OS.SB_HORZ, info, true);\n    OS.GetScrollInfo(hwndParent, OS.SB_VERT, info);\n    info.nPage = info.nMax + 1;\n    OS.SetScrollInfo(hwndParent, OS.SB_VERT, info, true);\n    customDraw = true;\n    deregister();\n    if ((oldStyle & OS.WS_VISIBLE) != 0) {\n        OS.ShowWindow(hwndParent, OS.SW_SHOW);\n    }\n    int hwndFocus = OS.GetFocus();\n    if (hwndFocus == handle)\n        OS.SetFocus(hwndParent);\n    OS.SetParent(handle, hwndParent);\n    if (hwndFocus == handle)\n        OS.SetFocus(handle);\n    register();\n}",
			"comments":"//\tif ((oldStyle & OS.WS_VISIBLE) != 0) newStyle |= OS.WS_VISIBLE;\n",
			"methodName":"void createParent()"
		},
		"public TreeItem[] getSelection()":{
			"methodBody":"{\n    checkWidget();\n    if ((style & SWT.SINGLE) != 0) {\n        int hItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);\n        if (hItem == 0)\n            return new TreeItem[0];\n        TVITEM tvItem = new TVITEM();\n        tvItem.mask = OS.TVIF_PARAM | OS.TVIF_STATE;\n        tvItem.hItem = hItem;\n        OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem);\n        if ((tvItem.state & OS.TVIS_SELECTED) == 0)\n            return new TreeItem[0];\n        return new TreeItem[] { items[tvItem.lParam] };\n    }\n    int count = 0;\n    TreeItem[] guess = new TreeItem[8];\n    TVITEM tvItem = new TVITEM();\n    tvItem.mask = OS.TVIF_PARAM | OS.TVIF_STATE;\n    int oldProc = OS.GetWindowLong(handle, OS.GWL_WNDPROC);\n    OS.SetWindowLong(handle, OS.GWL_WNDPROC, TreeProc);\n    for (int i = 0; i < items.length; i++) {\n        TreeItem item = items[i];\n        if (item != null) {\n            tvItem.hItem = item.handle;\n            OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem);\n            if ((tvItem.state & OS.TVIS_SELECTED) != 0) {\n                if (count < guess.length)\n                    guess[count] = item;\n                count++;\n            }\n        }\n    }\n    OS.SetWindowLong(handle, OS.GWL_WNDPROC, oldProc);\n    if (count == 0)\n        return new TreeItem[0];\n    if (count == guess.length)\n        return guess;\n    TreeItem[] result = new TreeItem[count];\n    if (count < guess.length) {\n        System.arraycopy(guess, 0, result, 0, count);\n        return result;\n    }\n    OS.SetWindowLong(handle, OS.GWL_WNDPROC, TreeProc);\n    int index = 0;\n    for (int i = 0; i < items.length; i++) {\n        TreeItem item = items[i];\n        if (item != null) {\n            tvItem.hItem = item.handle;\n            OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem);\n            if ((tvItem.state & OS.TVIS_SELECTED) != 0) {\n                result[index++] = item;\n            }\n        }\n    }\n    OS.SetWindowLong(handle, OS.GWL_WNDPROC, oldProc);\n    return result;\n}",
			"comments":"/**\n* Returns an array of <code>TreeItem</code>s that are currently\n* selected in the receiver. The order of the items is unspecified.\n* An empty array indicates that no items are selected.\n* <p>\n* Note: This is not the actual structure used by the receiver\n* to maintain its selection, so modifying the array will\n* not affect the receiver.\n* </p>\n* @return an array representing the selection\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public TreeItem[] getSelection()"
		},
		"boolean releaseItem(TreeItem item, TVITEM tvItem)":{
			"methodBody":"{\n    int hItem = item.handle;\n    if (hItem == hAnchor)\n        hAnchor = 0;\n    if (hItem == hInsert)\n        hInsert = 0;\n    if (item.isDisposed())\n        return false;\n    tvItem.hItem = hItem;\n    OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem);\n    items[tvItem.lParam] = null;\n    return true;\n}",
			"comments":"",
			"methodName":"boolean releaseItem(TreeItem item, TVITEM tvItem)"
		},
		"void setScrollWidth()":{
			"methodBody":"{\n    if (hwndHeader == 0 || hwndParent == 0)\n        return;\n    int width = 0;\n    HDITEM hdItem = new HDITEM();\n    int count = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n    for (int i = 0; i < count; i++) {\n        hdItem.mask = OS.HDI_WIDTH;\n        OS.SendMessage(hwndHeader, OS.HDM_GETITEM, i, hdItem);\n        width += hdItem.cxy;\n    }\n    int left = 0;\n    RECT rect = new RECT();\n    SCROLLINFO info = new SCROLLINFO();\n    info.cbSize = SCROLLINFO.sizeof;\n    info.fMask = OS.SIF_RANGE | OS.SIF_PAGE;\n    if (count == 0) {\n        OS.GetScrollInfo(hwndParent, OS.SB_HORZ, info);\n        info.nPage = info.nMax + 1;\n        OS.SetScrollInfo(hwndParent, OS.SB_HORZ, info, true);\n        OS.GetScrollInfo(hwndParent, OS.SB_VERT, info);\n        info.nPage = info.nMax + 1;\n        OS.SetScrollInfo(hwndParent, OS.SB_VERT, info, true);\n    } else {\n        OS.GetClientRect(hwndParent, rect);\n        OS.GetScrollInfo(hwndParent, OS.SB_HORZ, info);\n        info.nMax = width;\n        info.nPage = rect.right - rect.left;\n        OS.SetScrollInfo(hwndParent, OS.SB_HORZ, info, true);\n        info.fMask = OS.SIF_POS;\n        OS.GetScrollInfo(hwndParent, OS.SB_HORZ, info);\n        left = info.nPos;\n    }\n    OS.GetClientRect(hwndParent, rect);\n    int hHeap = OS.GetProcessHeap();\n    HDLAYOUT playout = new HDLAYOUT();\n    playout.prc = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, RECT.sizeof);\n    playout.pwpos = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, WINDOWPOS.sizeof);\n    OS.MoveMemory(playout.prc, rect, RECT.sizeof);\n    OS.SendMessage(hwndHeader, OS.HDM_LAYOUT, 0, playout);\n    WINDOWPOS pos = new WINDOWPOS();\n    OS.MoveMemory(pos, playout.pwpos, WINDOWPOS.sizeof);\n    if (playout.prc != 0)\n        OS.HeapFree(hHeap, 0, playout.prc);\n    if (playout.pwpos != 0)\n        OS.HeapFree(hHeap, 0, playout.pwpos);\n    SetWindowPos(hwndHeader, OS.HWND_TOP, pos.x - left, pos.y, pos.cx + left, pos.cy, OS.SWP_NOACTIVATE);\n    int w = pos.cx + (count == 0 ? 0 : OS.GetSystemMetrics(OS.SM_CXVSCROLL));\n    int h = rect.bottom - rect.top - pos.cy;\n    boolean oldIgnore = ignoreResize;\n    ignoreResize = true;\n    SetWindowPos(handle, 0, pos.x - left, pos.y + pos.cy, w + left, h, OS.SWP_NOACTIVATE | OS.SWP_NOZORDER);\n    ignoreResize = oldIgnore;\n}",
			"comments":"",
			"methodName":"void setScrollWidth()"
		},
		"LRESULT WM_GETOBJECT(int wParam, int lParam)":{
			"methodBody":"{\n    \n    if ((style & SWT.CHECK) != 0 || hwndParent != 0) {\n        if (accessible == null)\n            accessible = new_Accessible(this);\n    }\n    return super.WM_GETOBJECT(wParam, lParam);\n}",
			"comments":"/*\n* Ensure that there is an accessible object created for this\n* control because support for checked item and tree column\n* accessibility is temporarily implemented in the accessibility\n* package.\n*/\n",
			"methodName":"LRESULT WM_GETOBJECT(int wParam, int lParam)"
		},
		"boolean checkHandle(int hwnd)":{
			"methodBody":"{\n    return hwnd == handle || (hwndParent != 0 && hwnd == hwndParent);\n}",
			"comments":"",
			"methodName":"boolean checkHandle(int hwnd)"
		},
		"int widgetStyle()":{
			"methodBody":"{\n    int bits = super.widgetStyle() | OS.TVS_SHOWSELALWAYS | OS.TVS_LINESATROOT | OS.TVS_HASBUTTONS;\n    if ((style & SWT.FULL_SELECTION) != 0) {\n        bits |= OS.TVS_FULLROWSELECT;\n    } else {\n        bits |= OS.TVS_HASLINES;\n    }\n    \n    return bits;\n}",
			"comments":"//\tbits |= OS.TVS_NOTOOLTIPS;\n",
			"methodName":"int widgetStyle()"
		},
		"TreeItem[] getItems(int hTreeItem)":{
			"methodBody":"{\n    int count = 0, hItem = hTreeItem;\n    while (hItem != 0) {\n        hItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_NEXT, hItem);\n        count++;\n    }\n    int index = 0;\n    TreeItem[] result = new TreeItem[count];\n    TVITEM tvItem = new TVITEM();\n    tvItem.mask = OS.TVIF_HANDLE | OS.TVIF_PARAM;\n    tvItem.hItem = hTreeItem;\n    \n    while (tvItem.hItem != 0) {\n        OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem);\n        TreeItem item = items[tvItem.lParam];\n        if (item != null)\n            result[index++] = item;\n        tvItem.hItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_NEXT, tvItem.hItem);\n    }\n    if (index != count) {\n        TreeItem[] newResult = new TreeItem[index];\n        System.arraycopy(result, 0, newResult, 0, index);\n        result = newResult;\n    }\n    return result;\n}",
			"comments":"/*\n* Feature in Windows.  In some cases an expand or collapse message\n* can occurs from within TVM_DELETEITEM.  When this happens, the item\n* being destroyed has been removed from the list of items but has not\n* been deleted from the tree.  The fix is to check for null items and\n* remove them from the list.\n*/\n",
			"methodName":"TreeItem[] getItems(int hTreeItem)"
		},
		"public int getItemCount()":{
			"methodBody":"{\n    checkWidget();\n    int hItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_ROOT, 0);\n    if (hItem == 0)\n        return 0;\n    return getItemCount(hItem);\n}",
			"comments":"/**\n* Returns the number of items contained in the receiver\n* that are direct item children of the receiver.  The\n* number that is returned is the number of roots in the\n* tree.\n*\n* @return the number of items\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getItemCount()"
		},
		"LRESULT wmNotifyChild(int wParam, int lParam)":{
			"methodBody":"{\n    NMHDR hdr = new NMHDR();\n    OS.MoveMemory(hdr, lParam, NMHDR.sizeof);\n    switch(hdr.code) {\n        case OS.TVN_GETDISPINFOA:\n        case OS.TVN_GETDISPINFOW:\n            {\n                NMTVDISPINFO lptvdi = new NMTVDISPINFO();\n                OS.MoveMemory(lptvdi, lParam, NMTVDISPINFO.sizeof);\n                \n                if (items == null)\n                    break;\n                TreeItem item = items[lptvdi.lParam];\n                if (item == null)\n                    break;\n                if ((lptvdi.mask & OS.TVIF_TEXT) != 0) {\n                    String string = item.text;\n                    TCHAR buffer = new TCHAR(getCodePage(), string, false);\n                    int byteCount = Math.min(buffer.length(), lptvdi.cchTextMax - 1) * TCHAR.sizeof;\n                    OS.MoveMemory(lptvdi.pszText, buffer, byteCount);\n                    OS.MoveMemory(lptvdi.pszText + byteCount, new byte[TCHAR.sizeof], TCHAR.sizeof);\n                    lptvdi.cchTextMax = Math.min(lptvdi.cchTextMax, string.length() + 1);\n                }\n                if ((lptvdi.mask & (OS.TVIF_IMAGE | OS.TVIF_SELECTEDIMAGE)) != 0) {\n                    Image image = item.image;\n                    lptvdi.iImage = lptvdi.iSelectedImage = OS.I_IMAGENONE;\n                    if (image != null) {\n                        lptvdi.iImage = lptvdi.iSelectedImage = imageIndex(image);\n                    }\n                }\n                OS.MoveMemory(lParam, lptvdi, NMTVDISPINFO.sizeof);\n                break;\n            }\n        case OS.NM_CUSTOMDRAW:\n            {\n                if (!customDraw)\n                    break;\n                NMTVCUSTOMDRAW nmcd = new NMTVCUSTOMDRAW();\n                OS.MoveMemory(nmcd, lParam, NMTVCUSTOMDRAW.sizeof);\n                switch(nmcd.dwDrawStage) {\n                    case OS.CDDS_PREPAINT:\n                        {\n                            return new LRESULT(OS.CDRF_NOTIFYITEMDRAW | OS.CDRF_NOTIFYPOSTPAINT);\n                        }\n                    case OS.CDDS_POSTPAINT:\n                        {\n                            if (linesVisible) {\n                                int hDC = nmcd.hdc;\n                                if (hwndHeader != 0) {\n                                    int x = 0;\n                                    RECT rect = new RECT();\n                                    HDITEM hdItem = new HDITEM();\n                                    hdItem.mask = OS.HDI_WIDTH;\n                                    int count = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n                                    for (int i = 0; i < count; i++) {\n                                        OS.SendMessage(hwndHeader, OS.HDM_GETITEM, i, hdItem);\n                                        OS.SetRect(rect, x, nmcd.top, x + hdItem.cxy, nmcd.bottom);\n                                        OS.DrawEdge(hDC, rect, OS.BDR_SUNKENINNER, OS.BF_RIGHT);\n                                        x += hdItem.cxy;\n                                    }\n                                }\n                                RECT rect = new RECT();\n                                int hItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_LASTVISIBLE, 0);\n                                rect.left = hItem;\n                                if (OS.SendMessage(handle, OS.TVM_GETITEMRECT, 0, rect) != 0) {\n                                    int height = rect.bottom - rect.top;\n                                    while (rect.bottom < nmcd.bottom) {\n                                        int top = rect.top + height;\n                                        OS.SetRect(rect, rect.left, top, rect.right, top + height);\n                                        OS.DrawEdge(hDC, rect, OS.BDR_SUNKENINNER, OS.BF_BOTTOM);\n                                    }\n                                }\n                            }\n                            return new LRESULT(OS.CDRF_DODEFAULT);\n                        }\n                    case OS.CDDS_ITEMPREPAINT:\n                        {\n                            \n                            TreeItem item = items[nmcd.lItemlParam];\n                            if (item == null)\n                                break;\n                            if (nmcd.left >= nmcd.right || nmcd.top >= nmcd.bottom) {\n                                break;\n                            }\n                            int hDC = nmcd.hdc;\n                            OS.SaveDC(hDC);\n                            if (linesVisible) {\n                                RECT rect = new RECT();\n                                OS.SetRect(rect, nmcd.left, nmcd.top, nmcd.right, nmcd.bottom);\n                                OS.DrawEdge(hDC, rect, OS.BDR_SUNKENINNER, OS.BF_BOTTOM);\n                            }\n                            if (!printClient && (style & SWT.FULL_SELECTION) == 0) {\n                                if (hwndHeader != 0) {\n                                    int count = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n                                    if (count != 0) {\n                                        HDITEM hdItem = new HDITEM();\n                                        hdItem.mask = OS.HDI_WIDTH;\n                                        OS.SendMessage(hwndHeader, OS.HDM_GETITEM, 0, hdItem);\n                                        int hRgn = OS.CreateRectRgn(nmcd.left, nmcd.top, nmcd.left + hdItem.cxy, nmcd.bottom);\n                                        OS.SelectClipRgn(hDC, hRgn);\n                                        OS.DeleteObject(hRgn);\n                                    }\n                                }\n                            }\n                            if (item.font == -1 && item.foreground == -1 && item.background == -1) {\n                                if (item.cellForeground == null && item.cellBackground == null && item.cellFont == null) {\n                                    return new LRESULT(OS.CDRF_DODEFAULT | OS.CDRF_NOTIFYPOSTPAINT);\n                                }\n                            }\n                            int hFont = item.cellFont != null ? item.cellFont[0] : item.font;\n                            if (hFont != -1)\n                                OS.SelectObject(hDC, hFont);\n                            if (OS.IsWindowEnabled(handle)) {\n                                TVITEM tvItem = new TVITEM();\n                                tvItem.mask = OS.TVIF_STATE;\n                                tvItem.hItem = item.handle;\n                                OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem);\n                                if ((tvItem.state & (OS.TVIS_SELECTED | OS.TVIS_DROPHILITED)) == 0) {\n                                    int clrText = item.cellForeground != null ? item.cellForeground[0] : item.foreground;\n                                    nmcd.clrText = clrText == -1 ? getForegroundPixel() : clrText;\n                                    int clrTextBk = item.cellBackground != null ? item.cellBackground[0] : item.background;\n                                    nmcd.clrTextBk = clrTextBk == -1 ? getBackgroundPixel() : clrTextBk;\n                                    OS.MoveMemory(lParam, nmcd, NMTVCUSTOMDRAW.sizeof);\n                                }\n                            }\n                            return new LRESULT(OS.CDRF_NEWFONT | OS.CDRF_NOTIFYPOSTPAINT);\n                        }\n                    case OS.CDDS_ITEMPOSTPAINT:\n                        {\n                            TreeItem item = items[nmcd.lItemlParam];\n                            if (item == null)\n                                break;\n                            \n                            if (nmcd.left >= nmcd.right || nmcd.top >= nmcd.bottom) {\n                                break;\n                            }\n                            int hDC = nmcd.hdc;\n                            OS.RestoreDC(hDC, -1);\n                            OS.SetBkMode(hDC, OS.TRANSPARENT);\n                            boolean useColor = OS.IsWindowEnabled(handle);\n                            if (useColor) {\n                                if ((style & SWT.FULL_SELECTION) != 0) {\n                                    TVITEM tvItem = new TVITEM();\n                                    tvItem.mask = OS.TVIF_STATE;\n                                    tvItem.hItem = item.handle;\n                                    OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem);\n                                    if ((tvItem.state & OS.TVIS_SELECTED) != 0) {\n                                        useColor = false;\n                                    } else {\n                                        \n                                        int clrForeground = OS.GetTextColor(hDC);\n                                        if (clrForeground == OS.GetSysColor(OS.COLOR_HIGHLIGHTTEXT)) {\n                                            int clrBackground = OS.GetBkColor(hDC);\n                                            if (clrBackground == OS.GetSysColor(OS.COLOR_HIGHLIGHT)) {\n                                                useColor = false;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    OS.SetTextColor(hDC, getForegroundPixel());\n                                }\n                            }\n                            if (hwndHeader != 0) {\n                                GCData data = new GCData();\n                                data.device = display;\n                                GC gc = GC.win32_new(hDC, data);\n                                int x = 0, gridWidth = linesVisible ? GRID_WIDTH : 0;\n                                Point size = null;\n                                RECT rect = new RECT();\n                                HDITEM hdItem = new HDITEM();\n                                hdItem.mask = OS.HDI_WIDTH;\n                                int count = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n                                for (int i = 0; i < count; i++) {\n                                    OS.SendMessage(hwndHeader, OS.HDM_GETITEM, i, hdItem);\n                                    if (i > 0) {\n                                        OS.SetRect(rect, x, nmcd.top, x + hdItem.cxy, nmcd.bottom - gridWidth);\n                                        if (printClient || (style & SWT.FULL_SELECTION) != 0) {\n                                            drawBackground(hDC, OS.GetBkColor(hDC), rect);\n                                        }\n                                        if (useColor) {\n                                            int clrTextBk = item.cellBackground != null ? item.cellBackground[i] : item.background;\n                                            if (clrTextBk != -1)\n                                                drawBackground(hDC, clrTextBk, rect);\n                                        }\n                                        Image image = item.images != null ? item.images[i] : null;\n                                        if (image != null) {\n                                            Rectangle bounds = image.getBounds();\n                                            if (size == null)\n                                                size = getImageSize();\n                                            gc.drawImage(image, 0, 0, bounds.width, bounds.height, rect.left, rect.top, size.x, size.y);\n                                            OS.SetRect(rect, rect.left + size.x + INSET, rect.top, rect.right - INSET, rect.bottom);\n                                        } else {\n                                            OS.SetRect(rect, rect.left + INSET, rect.top, rect.right - INSET, rect.bottom);\n                                        }\n                                        \n                                        if (rect.left < rect.right) {\n                                            if (item.strings != null && item.strings[i] != null) {\n                                                int hFont = item.cellFont != null ? item.cellFont[i] : item.font;\n                                                hFont = hFont != -1 ? OS.SelectObject(hDC, hFont) : -1;\n                                                int clrText = -1;\n                                                if (useColor) {\n                                                    clrText = item.cellForeground != null ? item.cellForeground[i] : item.foreground;\n                                                    clrText = clrText != -1 ? OS.SetTextColor(hDC, clrText) : -1;\n                                                }\n                                                int flags = OS.DT_NOPREFIX | OS.DT_SINGLELINE | OS.DT_VCENTER | OS.DT_ENDELLIPSIS;\n                                                TreeColumn column = columns[i];\n                                                if ((column.style & SWT.LEFT) != 0)\n                                                    flags |= OS.DT_LEFT;\n                                                if ((column.style & SWT.CENTER) != 0)\n                                                    flags |= OS.DT_CENTER;\n                                                if ((column.style & SWT.RIGHT) != 0)\n                                                    flags |= OS.DT_RIGHT;\n                                                TCHAR buffer = new TCHAR(getCodePage(), item.strings[i], false);\n                                                OS.DrawText(hDC, buffer, buffer.length(), rect, flags);\n                                                if (hFont != -1)\n                                                    OS.SelectObject(hDC, hFont);\n                                                if (clrText != -1)\n                                                    OS.SetTextColor(hDC, clrText);\n                                            }\n                                        }\n                                    }\n                                    x += hdItem.cxy;\n                                }\n                                if (count > 0) {\n                                    if (printClient || (style & SWT.FULL_SELECTION) != 0) {\n                                        OS.SetRect(rect, x, nmcd.top, nmcd.right, nmcd.bottom - gridWidth);\n                                        drawBackground(hDC, OS.GetBkColor(hDC), rect);\n                                    }\n                                }\n                                gc.dispose();\n                            }\n                            if (linesVisible) {\n                                if (printClient && (style & SWT.FULL_SELECTION) == 0) {\n                                    if (hwndHeader != 0) {\n                                        int count = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n                                        if (count != 0 && printClient) {\n                                            HDITEM hdItem = new HDITEM();\n                                            hdItem.mask = OS.HDI_WIDTH;\n                                            OS.SendMessage(hwndHeader, OS.HDM_GETITEM, 0, hdItem);\n                                            RECT rect = new RECT();\n                                            OS.SetRect(rect, nmcd.left + hdItem.cxy, nmcd.top, nmcd.right, nmcd.bottom);\n                                            OS.DrawEdge(hDC, rect, OS.BDR_SUNKENINNER, OS.BF_BOTTOM);\n                                        }\n                                    }\n                                }\n                                RECT rect = new RECT();\n                                if (OS.COMCTL32_MAJOR < 6 || (style & SWT.FULL_SELECTION) != 0) {\n                                    OS.SetRect(rect, nmcd.left, nmcd.top, nmcd.right, nmcd.bottom);\n                                } else {\n                                    rect.left = item.handle;\n                                    if (OS.SendMessage(handle, OS.TVM_GETITEMRECT, 1, rect) != 0) {\n                                        int hItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);\n                                        if (hItem == item.handle) {\n                                            OS.SetRect(rect, rect.right, nmcd.top, nmcd.right, nmcd.bottom);\n                                        } else {\n                                            TVITEM tvItem = new TVITEM();\n                                            tvItem.mask = OS.TVIF_STATE;\n                                            tvItem.hItem = item.handle;\n                                            OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem);\n                                            if ((tvItem.state & OS.TVIS_SELECTED) != 0) {\n                                                OS.SetRect(rect, rect.right, nmcd.top, nmcd.right, nmcd.bottom);\n                                            } else {\n                                                OS.SetRect(rect, rect.left, nmcd.top, nmcd.right, nmcd.bottom);\n                                            }\n                                        }\n                                    } else {\n                                        rect.left = 0;\n                                    }\n                                }\n                                OS.DrawEdge(hDC, rect, OS.BDR_SUNKENINNER, OS.BF_BOTTOM);\n                            }\n                            return new LRESULT(OS.CDRF_DODEFAULT);\n                        }\n                }\n                break;\n            }\n        case OS.NM_DBLCLK:\n            {\n                if (hooks(SWT.DefaultSelection))\n                    return LRESULT.ONE;\n                break;\n            }\n        case OS.TVN_SELCHANGEDA:\n        case OS.TVN_SELCHANGEDW:\n            {\n                if ((style & SWT.MULTI) != 0) {\n                    if (lockSelection) {\n                        \n                        if (oldSelected) {\n                            TVITEM tvItem = new TVITEM();\n                            int offset = NMHDR.sizeof + 4;\n                            OS.MoveMemory(tvItem, lParam + offset, TVITEM.sizeof);\n                            tvItem.mask = OS.TVIF_STATE;\n                            tvItem.stateMask = OS.TVIS_SELECTED;\n                            tvItem.state = OS.TVIS_SELECTED;\n                            OS.SendMessage(handle, OS.TVM_SETITEM, 0, tvItem);\n                        }\n                        if (!newSelected && ignoreSelect) {\n                            TVITEM tvItem = new TVITEM();\n                            int offset = NMHDR.sizeof + 4 + TVITEM.sizeof;\n                            OS.MoveMemory(tvItem, lParam + offset, TVITEM.sizeof);\n                            tvItem.mask = OS.TVIF_STATE;\n                            tvItem.stateMask = OS.TVIS_SELECTED;\n                            tvItem.state = 0;\n                            OS.SendMessage(handle, OS.TVM_SETITEM, 0, tvItem);\n                        }\n                    }\n                }\n                if (!ignoreSelect) {\n                    TVITEM tvItem = new TVITEM();\n                    int offset = NMHDR.sizeof + 4 + TVITEM.sizeof;\n                    OS.MoveMemory(tvItem, lParam + offset, TVITEM.sizeof);\n                    hAnchor = tvItem.hItem;\n                    Event event = new Event();\n                    event.item = items[tvItem.lParam];\n                    postEvent(SWT.Selection, event);\n                }\n                updateScrollBar();\n                break;\n            }\n        case OS.TVN_SELCHANGINGA:\n        case OS.TVN_SELCHANGINGW:\n            {\n                if ((style & SWT.MULTI) != 0) {\n                    if (lockSelection) {\n                        \n                        TVITEM tvItem = new TVITEM();\n                        int offset1 = NMHDR.sizeof + 4;\n                        OS.MoveMemory(tvItem, lParam + offset1, TVITEM.sizeof);\n                        oldSelected = (tvItem.state & OS.TVIS_SELECTED) != 0;\n                        int offset2 = NMHDR.sizeof + 4 + TVITEM.sizeof;\n                        OS.MoveMemory(tvItem, lParam + offset2, TVITEM.sizeof);\n                        newSelected = (tvItem.state & OS.TVIS_SELECTED) != 0;\n                    }\n                }\n                if (!ignoreSelect && !ignoreDeselect) {\n                    hAnchor = 0;\n                    if ((style & SWT.MULTI) != 0)\n                        deselectAll();\n                }\n                break;\n            }\n        case OS.TVN_ITEMEXPANDEDA:\n        case OS.TVN_ITEMEXPANDEDW:\n            {\n                \n                if (hInsert != 0) {\n                    OS.SendMessage(handle, OS.TVM_SETINSERTMARK, insertAfter ? 1 : 0, hInsert);\n                }\n                updateScrollBar();\n                break;\n            }\n        case OS.TVN_ITEMEXPANDINGA:\n        case OS.TVN_ITEMEXPANDINGW:\n            {\n                \n                if (hInsert != 0) {\n                    OS.SendMessage(handle, OS.TVM_SETINSERTMARK, 0, 0);\n                }\n                if (!ignoreExpand) {\n                    TVITEM tvItem = new TVITEM();\n                    int offset = NMHDR.sizeof + 4 + TVITEM.sizeof;\n                    OS.MoveMemory(tvItem, lParam + offset, TVITEM.sizeof);\n                    \n                    if (items == null)\n                        break;\n                    TreeItem item = items[tvItem.lParam];\n                    if (item == null)\n                        break;\n                    Event event = new Event();\n                    event.item = item;\n                    int[] action = new int[1];\n                    OS.MoveMemory(action, lParam + NMHDR.sizeof, 4);\n                    switch(action[0]) {\n                        case OS.TVE_EXPAND:\n                            \n                            if ((tvItem.state & OS.TVIS_EXPANDED) == 0) {\n                                sendEvent(SWT.Expand, event);\n                                if (isDisposed())\n                                    return LRESULT.ZERO;\n                            }\n                            break;\n                        case OS.TVE_COLLAPSE:\n                            sendEvent(SWT.Collapse, event);\n                            if (isDisposed())\n                                return LRESULT.ZERO;\n                            break;\n                    }\n                }\n                break;\n            }\n        case OS.TVN_BEGINDRAGA:\n        case OS.TVN_BEGINDRAGW:\n        case OS.TVN_BEGINRDRAGA:\n        case OS.TVN_BEGINRDRAGW:\n            {\n                TVITEM tvItem = new TVITEM();\n                int offset = NMHDR.sizeof + 4 + TVITEM.sizeof;\n                OS.MoveMemory(tvItem, lParam + offset, TVITEM.sizeof);\n                if (tvItem.hItem != 0 && (tvItem.state & OS.TVIS_SELECTED) == 0) {\n                    ignoreSelect = ignoreDeselect = true;\n                    OS.SendMessage(handle, OS.TVM_SELECTITEM, OS.TVGN_CARET, tvItem.hItem);\n                    ignoreSelect = ignoreDeselect = false;\n                }\n                dragStarted = true;\n                break;\n            }\n        case OS.NM_RECOGNIZEGESTURE:\n            {\n                \n                if (OS.IsPPC) {\n                    boolean hasMenu = menu != null && !menu.isDisposed();\n                    if (!hasMenu && !hooks(SWT.MenuDetect))\n                        return LRESULT.ONE;\n                }\n                break;\n            }\n        case OS.GN_CONTEXTMENU:\n            {\n                if (OS.IsPPC) {\n                    boolean hasMenu = menu != null && !menu.isDisposed();\n                    if (hasMenu || hooks(SWT.MenuDetect)) {\n                        NMRGINFO nmrg = new NMRGINFO();\n                        OS.MoveMemory(nmrg, lParam, NMRGINFO.sizeof);\n                        showMenu(nmrg.x, nmrg.y);\n                        gestureCompleted = true;\n                        return LRESULT.ONE;\n                    }\n                }\n                break;\n            }\n    }\n    return super.wmNotifyChild(wParam, lParam);\n}",
			"comments":"/*\n* Feature in Windows.  When a new tree item is inserted\n* using TVM_INSERTITEM, a TVN_GETDISPINFO is sent before\n* TVM_INSERTITEM returns and before the item is added to\n* the items array.  The fix is to check for null.\n*\n* NOTE: This only happens on XP with the version 6.00 of\n* COMCTL32.DLL,\n*/\n/*\n* Feature in Windows.  When a new tree item is inserted\n* using TVM_INSERTITEM and the tree is using custom draw,\n* a NM_CUSTOMDRAW is sent before TVM_INSERTITEM returns\n* and before the item is added to the items array.  The\n* fix is to check for null.\n*\n* NOTE: This only happens on XP with the version 6.00 of\n* COMCTL32.DLL,\n*/\n/*\n* Feature in Windows.  Under certain circumstances, Windows\n* sends CDDS_ITEMPOSTPAINT for an empty rectangle.  This is\n* not a problem providing that graphics do not occur outside\n* the rectangle.  The fix is to test for the rectangle and\n* draw nothing.\n*\n* NOTE:  This seems to happen when both I_IMAGECALLBACK\n* and LPSTR_TEXTCALLBACK are used at the same time with\n* TVM_SETITEM.\n*/\n/*\n* Feature in Windows.  When the mouse is pressed and the\n* selection is first drawn for a tree, the item is drawn\n* selected, but the TVIS_SELECTED bits for the item are\n* not set.  When the user moves the mouse slightly and\n* a drag and drop operation is not started, the item is\n* drawn again and this time TVIS_SELECTED is set.  This\n* means that an item that is in a tree that has the style\n* TVS_FULLROWSELECT and that also contains colored cells\n* will not draw the entire row selected until the user\n* moves the mouse.  The fix is to test for the selection\n* colors and guess that the item is selected.\n*\n* NOTE: This code doesn't work when the foreground and\n* background of the tree are set to the selection colors\n* but this does not happen in a regular application.\n*/\n/*\n* Bug in Windows.  When DrawText() is used with DT_VCENTER\n* and DT_ENDELLIPSIS, the ellipsis can draw outside of the\n* rectangle when the rectangle is empty.  The fix is avoid\n* all text drawing for empty rectangles.\n*/\n/* Restore the old selection state of both items */\n/* Save the old selection state for both items */\n/*\n* Bug in Windows.  When TVM_SETINSERTMARK is used to set\n* an insert mark for a tree and an item is expanded or\n* collapsed near the insert mark, the tree does not redraw\n* the insert mark properly.  The fix is to hide and show\n* the insert mark whenever an item is expanded or collapsed.\n*/\n/*\n* Bug in Windows.  When TVM_SETINSERTMARK is used to set\n* an insert mark for a tree and an item is expanded or\n* collapsed near the insert mark, the tree does not redraw\n* the insert mark properly.  The fix is to hide and show\n* the insert mark whenever an item is expanded or collapsed.\n*/\n/*\n* Feature in Windows.  In some cases, TVM_ITEMEXPANDING\n* is sent from within TVM_DELETEITEM for the tree item\n* being destroyed.  By the time the message is sent,\n* the item has already been removed from the list of\n* items.  The fix is to check for null.\n*/\n/*\n* Bug in Windows.  When the numeric keypad asterisk\n* key is used to expand every item in the tree, Windows\n* sends TVN_ITEMEXPANDING to items in the tree that\n* have already been expanded.  The fix is to detect\n* that the item is already expanded and ignore the\n* notification.\n*/\n/*\n* Feature in Pocket PC.  The tree and table controls detect the tap\n* and hold gesture by default. They send a GN_CONTEXTMENU message to show\n* the popup menu.  This default behaviour is unwanted on Pocket PC 2002\n* when no menu has been set, as it still draws a red circle.  The fix\n* is to disable this default behaviour when no menu is set by returning\n* TRUE when receiving the Pocket PC 2002 specific NM_RECOGNIZEGESTURE\n* message.\n*/\n",
			"methodName":"LRESULT wmNotifyChild(int wParam, int lParam)"
		},
		"Point getImageSize()":{
			"methodBody":"{\n    if (imageList != null)\n        return imageList.getImageSize();\n    return new Point(0, getItemHeight());\n}",
			"comments":"",
			"methodName":"Point getImageSize()"
		},
		"void setBackgroundPixel(int pixel)":{
			"methodBody":"{\n    if (background == pixel)\n        return;\n    background = pixel;\n    \n    if (OS.IsWindowEnabled(handle))\n        _setBackgroundPixel(pixel);\n}",
			"comments":"/*\n* Feature in Windows.  When a tree is given a background color\n* using TVM_SETBKCOLOR and the tree is disabled, Windows draws\n* the tree using the background color rather than the disabled\n* colors.  This is different from the table which draws grayed.\n* The fix is to set the default background color while the tree\n* is disabled and restore it when enabled.\n*/\n",
			"methodName":"void setBackgroundPixel(int pixel)"
		},
		"public void showSelection()":{
			"methodBody":"{\n    checkWidget();\n    int hItem = 0;\n    if ((style & SWT.SINGLE) != 0) {\n        hItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);\n        if (hItem == 0)\n            return;\n        TVITEM tvItem = new TVITEM();\n        tvItem.mask = OS.TVIF_STATE;\n        tvItem.hItem = hItem;\n        OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem);\n        if ((tvItem.state & OS.TVIS_SELECTED) == 0)\n            return;\n    } else {\n        TVITEM tvItem = new TVITEM();\n        tvItem.mask = OS.TVIF_STATE;\n        int oldProc = OS.GetWindowLong(handle, OS.GWL_WNDPROC);\n        OS.SetWindowLong(handle, OS.GWL_WNDPROC, TreeProc);\n        int index = 0;\n        while (index < items.length) {\n            TreeItem item = items[index];\n            if (item != null) {\n                tvItem.hItem = item.handle;\n                OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem);\n                if ((tvItem.state & OS.TVIS_SELECTED) != 0) {\n                    hItem = tvItem.hItem;\n                    break;\n                }\n            }\n            index++;\n        }\n        OS.SetWindowLong(handle, OS.GWL_WNDPROC, oldProc);\n    }\n    if (hItem != 0)\n        showItem(hItem);\n}",
			"comments":"/**\n* Shows the selection.  If the selection is already showing in the receiver,\n* this method simply returns.  Otherwise, the items are scrolled until\n* the selection is visible.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see Tree#showItem(TreeItem)\n*/\n",
			"methodName":"public void showSelection()"
		},
		"void destroyItem(TreeItem item)":{
			"methodBody":"{\n    \n    int hItem = item.handle, hParent = 0;\n    boolean fixRedraw = false;\n    if (drawCount == 0 && OS.IsWindowVisible(handle)) {\n        RECT rect = new RECT();\n        rect.left = hItem;\n        fixRedraw = OS.SendMessage(handle, OS.TVM_GETITEMRECT, 0, rect) == 0;\n    }\n    if (fixRedraw) {\n        hParent = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_PARENT, hItem);\n        OS.UpdateWindow(handle);\n        OS.SendMessage(handle, OS.WM_SETREDRAW, 0, 0);\n    }\n    TVITEM tvItem = new TVITEM();\n    tvItem.mask = OS.TVIF_HANDLE | OS.TVIF_PARAM;\n    releaseItems(item.getItems(), tvItem);\n    releaseItem(item, tvItem);\n    if ((style & SWT.MULTI) != 0) {\n        ignoreDeselect = ignoreSelect = lockSelection = true;\n    }\n    OS.SendMessage(handle, OS.TVM_DELETEITEM, 0, hItem);\n    if ((style & SWT.MULTI) != 0) {\n        ignoreDeselect = ignoreSelect = lockSelection = false;\n    }\n    if (fixRedraw) {\n        OS.SendMessage(handle, OS.WM_SETREDRAW, 1, 0);\n        OS.ValidateRect(handle, null);\n        \n        if (OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_CHILD, hParent) == 0) {\n            RECT rect = new RECT();\n            rect.left = hParent;\n            if (OS.SendMessage(handle, OS.TVM_GETITEMRECT, 0, rect) != 0) {\n                OS.InvalidateRect(handle, rect, true);\n            }\n        }\n    }\n    int count = OS.SendMessage(handle, OS.TVM_GETCOUNT, 0, 0);\n    if (count == 0) {\n        if (imageList != null) {\n            OS.SendMessage(handle, OS.TVM_SETIMAGELIST, 0, 0);\n            if (hwndHeader != 0) {\n                OS.SendMessage(hwndHeader, OS.HDM_SETIMAGELIST, 0, 0);\n            }\n            display.releaseImageList(imageList);\n        }\n        imageList = null;\n        if (hwndParent == 0)\n            customDraw = false;\n        items = new TreeItem[4];\n    }\n    updateScrollBar();\n}",
			"comments":"/*\n* Feature in Windows.  When an item is removed that is not\n* visible in the tree because it belongs to a collapsed branch,\n* Windows redraws the tree causing a flash for each item that\n* is removed.  The fix is to detect whether the item is visible,\n* force the widget to be fully painted, turn off redraw, remove\n* the item and validate the damage caused by the removing of\n* the item.\n*/\n/*\n* If the item that was deleted was the last child of a tree item that\n* is visible, redraw the parent item to force the +/- to be updated.\n*/\n",
			"methodName":"void destroyItem(TreeItem item)"
		},
		"public int getItemHeight()":{
			"methodBody":"{\n    checkWidget();\n    return OS.SendMessage(handle, OS.TVM_GETITEMHEIGHT, 0, 0);\n}",
			"comments":"/**\n* Returns the height of the area which would be used to\n* display <em>one</em> of the items in the tree.\n*\n* @return the height of one item\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getItemHeight()"
		},
		"int getForegroundPixel()":{
			"methodBody":"{\n    if (OS.IsWinCE)\n        return OS.GetSysColor(OS.COLOR_WINDOWTEXT);\n    int pixel = OS.SendMessage(handle, OS.TVM_GETTEXTCOLOR, 0, 0);\n    if (pixel == -1)\n        return OS.GetSysColor(OS.COLOR_WINDOWTEXT);\n    return pixel;\n}",
			"comments":"",
			"methodName":"int getForegroundPixel()"
		},
		"LRESULT wmColorChild(int wParam, int lParam)":{
			"methodBody":"{\n    \n    return null;\n}",
			"comments":"/*\n* Feature in Windows.  Tree controls send WM_CTLCOLOREDIT\n* to allow application code to change the default colors.\n* This is undocumented and conflicts with TVM_SETTEXTCOLOR\n* and TVM_SETBKCOLOR, the documented way to do this.  The\n* fix is to ignore WM_CTLCOLOREDIT messages from trees.\n*/\n",
			"methodName":"LRESULT wmColorChild(int wParam, int lParam)"
		},
		"public void setTopItem(TreeItem item)":{
			"methodBody":"{\n    checkWidget();\n    if (item == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (item.isDisposed())\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    int hItem = item.handle;\n    boolean fixScroll = checkScroll(hItem);\n    if (fixScroll) {\n        OS.SendMessage(handle, OS.WM_SETREDRAW, 1, 0);\n        OS.DefWindowProc(handle, OS.WM_SETREDRAW, 0, 0);\n    }\n    OS.SendMessage(handle, OS.TVM_SELECTITEM, OS.TVGN_FIRSTVISIBLE, hItem);\n    if (fixScroll) {\n        OS.DefWindowProc(handle, OS.WM_SETREDRAW, 1, 0);\n        OS.SendMessage(handle, OS.WM_SETREDRAW, 0, 0);\n    }\n    updateScrollBar();\n}",
			"comments":"/**\n* Sets the item which is currently at the top of the receiver.\n* This item can change when items are expanded, collapsed, scrolled\n* or new items are added or removed.\n*\n* @param item the item to be shown\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the item is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the item has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see Tree#getTopItem()\n*\n* @since 2.1\n*/\n",
			"methodName":"public void setTopItem(TreeItem item)"
		},
		"LRESULT WM_NOTIFY(int wParam, int lParam)":{
			"methodBody":"{\n    NMHDR hdr = new NMHDR();\n    OS.MoveMemory(hdr, lParam, NMHDR.sizeof);\n    if (hwndHeader != 0 && hdr.hwndFrom == hwndHeader) {\n        \n        switch(hdr.code) {\n            case OS.HDN_BEGINTRACKW:\n            case OS.HDN_BEGINTRACKA:\n            case OS.HDN_DIVIDERDBLCLICKW:\n            case OS.HDN_DIVIDERDBLCLICKA:\n                {\n                    NMHEADER phdn = new NMHEADER();\n                    OS.MoveMemory(phdn, lParam, NMHEADER.sizeof);\n                    TreeColumn column = columns[phdn.iItem];\n                    if (column != null && !column.getResizable()) {\n                        return LRESULT.ONE;\n                    }\n                    break;\n                }\n            case OS.HDN_ITEMCHANGINGW:\n            case OS.HDN_ITEMCHANGINGA:\n                {\n                    NMHEADER phdn = new NMHEADER();\n                    OS.MoveMemory(phdn, lParam, NMHEADER.sizeof);\n                    if (phdn.pitem != 0) {\n                        HDITEM newItem = new HDITEM();\n                        OS.MoveMemory(newItem, phdn.pitem, HDITEM.sizeof);\n                        if ((newItem.mask & OS.HDI_WIDTH) != 0) {\n                            HDITEM oldItem = new HDITEM();\n                            oldItem.mask = OS.HDI_WIDTH;\n                            OS.SendMessage(hwndHeader, OS.HDM_GETITEM, phdn.iItem, oldItem);\n                            int deltaX = newItem.cxy - oldItem.cxy;\n                            RECT rect = new RECT(), itemRect = new RECT();\n                            OS.GetClientRect(handle, rect);\n                            OS.SendMessage(hwndHeader, OS.HDM_GETITEMRECT, phdn.iItem, itemRect);\n                            int gridWidth = getLinesVisible() ? GRID_WIDTH : 0;\n                            rect.left = itemRect.right - gridWidth;\n                            int count = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n                            if (phdn.iItem < count - 1) {\n                                for (int i = phdn.iItem; i < count; i++) {\n                                    OS.SendMessage(hwndHeader, OS.HDM_GETITEMRECT, i, itemRect);\n                                }\n                                rect.right = itemRect.right;\n                            }\n                            int flags = OS.SW_INVALIDATE | OS.SW_ERASE;\n                            OS.ScrollWindowEx(handle, deltaX, 0, rect, null, 0, null, flags);\n                            \n                            if (phdn.iItem != 0) {\n                                OS.SendMessage(hwndHeader, OS.HDM_GETITEMRECT, phdn.iItem, itemRect);\n                                rect.left = itemRect.left;\n                                rect.right = itemRect.right;\n                                OS.InvalidateRect(handle, rect, true);\n                            }\n                            setScrollWidth();\n                        }\n                    }\n                    break;\n                }\n            case OS.HDN_ITEMCHANGEDW:\n            case OS.HDN_ITEMCHANGEDA:\n                {\n                    NMHEADER phdn = new NMHEADER();\n                    OS.MoveMemory(phdn, lParam, NMHEADER.sizeof);\n                    if (phdn.pitem != 0) {\n                        HDITEM pitem = new HDITEM();\n                        OS.MoveMemory(pitem, phdn.pitem, HDITEM.sizeof);\n                        if ((pitem.mask & OS.HDI_WIDTH) != 0) {\n                            TreeColumn column = columns[phdn.iItem];\n                            if (column != null) {\n                                column.sendEvent(SWT.Resize);\n                                if (isDisposed())\n                                    return LRESULT.ZERO;\n                                int count = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n                                TreeColumn[] newColumns = new TreeColumn[count];\n                                System.arraycopy(columns, 0, newColumns, 0, count);\n                                for (int i = phdn.iItem + 1; i < count; i++) {\n                                    if (!newColumns[i].isDisposed()) {\n                                        newColumns[i].sendEvent(SWT.Move);\n                                    }\n                                }\n                            }\n                        }\n                        setScrollWidth();\n                    }\n                    break;\n                }\n            case OS.HDN_ITEMCLICKW:\n            case OS.HDN_ITEMCLICKA:\n                {\n                    NMHEADER phdn = new NMHEADER();\n                    OS.MoveMemory(phdn, lParam, NMHEADER.sizeof);\n                    TreeColumn column = columns[phdn.iItem];\n                    if (column != null) {\n                        column.postEvent(SWT.Selection);\n                    }\n                    break;\n                }\n            case OS.HDN_ITEMDBLCLICKW:\n            case OS.HDN_ITEMDBLCLICKA:\n                {\n                    NMHEADER phdn = new NMHEADER();\n                    OS.MoveMemory(phdn, lParam, NMHEADER.sizeof);\n                    TreeColumn column = columns[phdn.iItem];\n                    if (column != null) {\n                        column.postEvent(SWT.DefaultSelection);\n                    }\n                    break;\n                }\n        }\n    }\n    return super.WM_NOTIFY(wParam, lParam);\n}",
			"comments":"/*\n* Feature in Windows.  On NT, the automatically created\n* header control is created as a UNICODE window, not an\n* ANSI window despite the fact that the parent is created\n* as an ANSI window.  This means that it sends UNICODE\n* notification messages to the parent window on NT for\n* no good reason.  The data and size in the NMHEADER and\n* HDITEM structs is identical between the platforms so no\n* different message is actually necessary.  Despite this,\n* Windows sends different messages.  The fix is to look\n* for both messages, despite the platform.  This works\n* because only one will be sent on either platform, never\n* both.\n*/\n//TODO - column flashes when resized\n",
			"methodName":"LRESULT WM_NOTIFY(int wParam, int lParam)"
		},
		"void releaseHandle()":{
			"methodBody":"{\n    super.releaseHandle();\n    hwndParent = hwndHeader = 0;\n}",
			"comments":"",
			"methodName":"void releaseHandle()"
		},
		"public TreeItem getTopItem()":{
			"methodBody":"{\n    checkWidget();\n    int hItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_FIRSTVISIBLE, 0);\n    if (hItem == 0)\n        return null;\n    TVITEM tvItem = new TVITEM();\n    tvItem.mask = OS.TVIF_PARAM;\n    tvItem.hItem = hItem;\n    if (OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem) == 0)\n        return null;\n    return items[tvItem.lParam];\n}",
			"comments":"/**\n* Returns the item which is currently at the top of the receiver.\n* This item can change when items are expanded, collapsed, scrolled\n* or new items are added or removed.\n*\n* @return the item at the top of the receiver\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 2.1\n*/\n",
			"methodName":"public TreeItem getTopItem()"
		},
		"LRESULT WM_PRINTCLIENT(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_PRINTCLIENT(wParam, lParam);\n    if (result != null)\n        return result;\n    \n    printClient = true;\n    int code = callWindowProc(handle, OS.WM_PRINTCLIENT, wParam, lParam);\n    printClient = false;\n    return new LRESULT(code);\n}",
			"comments":"/*\n* Feature in Windows.  For some reason, when WM_PRINT is used\n* to capture an image of a hierarchy that contains a tree with\n* columns, the clipping that is used to stop the first column\n* from drawing on top of subsequent columns stops the first\n* column and the tree lines from drawing.  This does not happen\n* during WM_PAINT.  The fix is to draw without clipping and\n* then draw the rest of the columns on top.  Since the drawing\n* is happening in WM_PRINTCLIENT, the redrawing is not visible.\n*/\n",
			"methodName":"LRESULT WM_PRINTCLIENT(int wParam, int lParam)"
		},
		"LRESULT WM_LBUTTONDOWN(int wParam, int lParam)":{
			"methodBody":"{\n    \n    TVHITTESTINFO lpht = new TVHITTESTINFO();\n    lpht.x = (short) (lParam & 0xFFFF);\n    lpht.y = (short) (lParam >> 16);\n    OS.SendMessage(handle, OS.TVM_HITTEST, 0, lpht);\n    if (lpht.hItem == 0 || (lpht.flags & OS.TVHT_ONITEMBUTTON) != 0) {\n        sendMouseEvent(SWT.MouseDown, 1, handle, OS.WM_LBUTTONDOWN, wParam, lParam);\n        boolean fixSelection = false, deselected = false;\n        if (lpht.hItem != 0 && (style & SWT.MULTI) != 0) {\n            int hSelection = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);\n            if (hSelection != 0) {\n                TVITEM tvItem = new TVITEM();\n                tvItem.mask = OS.TVIF_STATE | OS.TVIF_PARAM;\n                tvItem.hItem = lpht.hItem;\n                OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem);\n                if ((tvItem.state & OS.TVIS_EXPANDED) != 0) {\n                    fixSelection = true;\n                    tvItem.stateMask = OS.TVIS_SELECTED;\n                    int hParent = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_PARENT, lpht.hItem);\n                    int hLast = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_LASTVISIBLE, lpht.hItem);\n                    int hNext = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_NEXTVISIBLE, lpht.hItem);\n                    while (hNext != 0 && hNext != hLast) {\n                        tvItem.hItem = hNext;\n                        OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem);\n                        if ((tvItem.state & OS.TVIS_SELECTED) != 0)\n                            deselected = true;\n                        tvItem.state = 0;\n                        OS.SendMessage(handle, OS.TVM_SETITEM, 0, tvItem);\n                        if ((hNext = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_NEXTVISIBLE, hNext)) == 0)\n                            break;\n                        if (hParent == OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_PARENT, hNext))\n                            break;\n                    }\n                }\n            }\n        }\n        dragStarted = gestureCompleted = false;\n        if (fixSelection)\n            ignoreDeselect = ignoreSelect = lockSelection = true;\n        int code = callWindowProc(handle, OS.WM_LBUTTONDOWN, wParam, lParam);\n        if (fixSelection)\n            ignoreDeselect = ignoreSelect = lockSelection = false;\n        if (dragStarted && OS.GetCapture() != handle)\n            OS.SetCapture(handle);\n        if (deselected) {\n            TVITEM tvItem = new TVITEM();\n            tvItem.mask = OS.TVIF_PARAM;\n            tvItem.hItem = lpht.hItem;\n            OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem);\n            Event event = new Event();\n            event.item = items[tvItem.lParam];\n            postEvent(SWT.Selection, event);\n        }\n        return new LRESULT(code);\n    }\n    \n    if ((style & SWT.CHECK) != 0) {\n        if ((lpht.flags & OS.TVHT_ONITEMSTATEICON) != 0) {\n            sendMouseEvent(SWT.MouseDown, 1, handle, OS.WM_LBUTTONDOWN, wParam, lParam);\n            if (OS.GetCapture() != handle)\n                OS.SetCapture(handle);\n            TVITEM tvItem = new TVITEM();\n            tvItem.hItem = lpht.hItem;\n            tvItem.mask = OS.TVIF_PARAM | OS.TVIF_STATE;\n            tvItem.stateMask = OS.TVIS_STATEIMAGEMASK;\n            OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem);\n            int state = tvItem.state >> 12;\n            if ((state & 0x1) != 0) {\n                state++;\n            } else {\n                --state;\n            }\n            tvItem.state = state << 12;\n            OS.SendMessage(handle, OS.TVM_SETITEM, 0, tvItem);\n            if (!OS.IsWinCE) {\n                int id = tvItem.hItem;\n                if (OS.COMCTL32_MAJOR >= 6) {\n                    id = OS.SendMessage(handle, OS.TVM_MAPHTREEITEMTOACCID, tvItem.hItem, 0);\n                }\n                OS.NotifyWinEvent(OS.EVENT_OBJECT_FOCUS, handle, OS.OBJID_CLIENT, id);\n            }\n            Event event = new Event();\n            event.item = items[tvItem.lParam];\n            event.detail = SWT.CHECK;\n            postEvent(SWT.Selection, event);\n            return LRESULT.ZERO;\n        }\n    }\n    \n    TVITEM tvItem = new TVITEM();\n    tvItem.mask = OS.TVIF_STATE;\n    tvItem.stateMask = OS.TVIS_SELECTED;\n    boolean hittestSelected = false;\n    if ((style & SWT.MULTI) != 0) {\n        tvItem.hItem = lpht.hItem;\n        OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem);\n        hittestSelected = (tvItem.state & OS.TVIS_SELECTED) != 0;\n    }\n    \n    int hOldItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);\n    if ((style & SWT.MULTI) != 0) {\n        tvItem.hItem = hOldItem;\n        OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem);\n        \n        if (hittestSelected || (wParam & OS.MK_CONTROL) != 0) {\n            if (drawCount == 0) {\n                OS.UpdateWindow(handle);\n                OS.DefWindowProc(handle, OS.WM_SETREDRAW, 0, 0);\n            \n            \n            }\n        } else {\n            deselectAll();\n        }\n    }\n    \n    sendMouseEvent(SWT.MouseDown, 1, handle, OS.WM_LBUTTONDOWN, wParam, lParam);\n    dragStarted = gestureCompleted = false;\n    ignoreDeselect = ignoreSelect = true;\n    int code = callWindowProc(handle, OS.WM_LBUTTONDOWN, wParam, lParam);\n    ignoreDeselect = ignoreSelect = false;\n    if (dragStarted && OS.GetCapture() != handle)\n        OS.SetCapture(handle);\n    int hNewItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);\n    \n    if ((style & SWT.SINGLE) != 0) {\n        if (hOldItem == hNewItem) {\n            tvItem.mask = OS.TVIF_STATE;\n            tvItem.state = OS.TVIS_SELECTED;\n            tvItem.stateMask = OS.TVIS_SELECTED;\n            tvItem.hItem = hNewItem;\n            OS.SendMessage(handle, OS.TVM_SETITEM, 0, tvItem);\n        }\n    }\n    \n    if ((style & SWT.MULTI) != 0) {\n        \n        if (hittestSelected || (wParam & OS.MK_CONTROL) != 0) {\n            if (hOldItem == hNewItem && hOldItem == lpht.hItem) {\n                if ((wParam & OS.MK_CONTROL) != 0) {\n                    tvItem.state ^= OS.TVIS_SELECTED;\n                    if (dragStarted)\n                        tvItem.state = OS.TVIS_SELECTED;\n                    OS.SendMessage(handle, OS.TVM_SETITEM, 0, tvItem);\n                }\n            } else {\n                if ((tvItem.state & OS.TVIS_SELECTED) != 0) {\n                    tvItem.state = OS.TVIS_SELECTED;\n                    OS.SendMessage(handle, OS.TVM_SETITEM, 0, tvItem);\n                }\n                if ((wParam & OS.MK_CONTROL) != 0 && !dragStarted) {\n                    if (hittestSelected) {\n                        tvItem.state = 0;\n                        tvItem.hItem = lpht.hItem;\n                        OS.SendMessage(handle, OS.TVM_SETITEM, 0, tvItem);\n                    }\n                }\n            }\n            if (drawCount == 0) {\n                RECT rect1 = new RECT(), rect2 = new RECT();\n                rect1.left = hOldItem;\n                rect2.left = hNewItem;\n                int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n                int fItemRect = (bits & OS.TVS_FULLROWSELECT) != 0 ? 0 : 1;\n                OS.SendMessage(handle, OS.TVM_GETITEMRECT, fItemRect, rect1);\n                OS.SendMessage(handle, OS.TVM_GETITEMRECT, fItemRect, rect2);\n                \n                \n                OS.DefWindowProc(handle, OS.WM_SETREDRAW, 1, 0);\n                if (OS.IsWinCE) {\n                    OS.InvalidateRect(handle, rect1, false);\n                    OS.InvalidateRect(handle, rect2, false);\n                    OS.UpdateWindow(handle);\n                } else {\n                    int flags = OS.RDW_UPDATENOW | OS.RDW_INVALIDATE;\n                    OS.RedrawWindow(handle, rect1, 0, flags);\n                    OS.RedrawWindow(handle, rect2, 0, flags);\n                }\n            }\n        }\n        \n        if ((wParam & OS.MK_CONTROL) == 0) {\n            if (!hittestSelected || !dragStarted) {\n                tvItem.state = 0;\n                int oldProc = OS.GetWindowLong(handle, OS.GWL_WNDPROC);\n                OS.SetWindowLong(handle, OS.GWL_WNDPROC, TreeProc);\n                for (int i = 0; i < items.length; i++) {\n                    TreeItem item = items[i];\n                    if (item != null && item.handle != hNewItem) {\n                        tvItem.hItem = item.handle;\n                        OS.SendMessage(handle, OS.TVM_SETITEM, 0, tvItem);\n                    }\n                }\n                tvItem.hItem = hNewItem;\n                tvItem.state = OS.TVIS_SELECTED;\n                OS.SendMessage(handle, OS.TVM_SETITEM, 0, tvItem);\n                OS.SetWindowLong(handle, OS.GWL_WNDPROC, oldProc);\n                if ((wParam & OS.MK_SHIFT) != 0) {\n                    RECT rect1 = new RECT();\n                    if (hAnchor == 0)\n                        hAnchor = hNewItem;\n                    rect1.left = hAnchor;\n                    if (OS.SendMessage(handle, OS.TVM_GETITEMRECT, 1, rect1) != 0) {\n                        RECT rect2 = rect2 = new RECT();\n                        rect2.left = hNewItem;\n                        OS.SendMessage(handle, OS.TVM_GETITEMRECT, 1, rect2);\n                        int flags = rect1.top < rect2.top ? OS.TVGN_NEXTVISIBLE : OS.TVGN_PREVIOUSVISIBLE;\n                        tvItem.state = OS.TVIS_SELECTED;\n                        int hItem = tvItem.hItem = hAnchor;\n                        OS.SendMessage(handle, OS.TVM_SETITEM, 0, tvItem);\n                        while (hItem != hNewItem) {\n                            tvItem.hItem = hItem;\n                            OS.SendMessage(handle, OS.TVM_SETITEM, 0, tvItem);\n                            hItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, flags, hItem);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if ((wParam & OS.MK_SHIFT) == 0)\n        hAnchor = hNewItem;\n    \n    if (!gestureCompleted) {\n        tvItem.hItem = hNewItem;\n        tvItem.mask = OS.TVIF_PARAM;\n        OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem);\n        Event event = new Event();\n        event.item = items[tvItem.lParam];\n        postEvent(SWT.Selection, event);\n    }\n    gestureCompleted = false;\n    \n    if (dragStarted) {\n        Event event = new Event();\n        event.x = (short) (lParam & 0xFFFF);\n        event.y = (short) (lParam >> 16);\n        postEvent(SWT.DragDetect, event);\n    } else {\n        sendMouseEvent(SWT.MouseUp, 1, handle, OS.WM_LBUTTONUP, wParam, lParam);\n    }\n    dragStarted = false;\n    return new LRESULT(code);\n}",
			"comments":"/*\n* In a multi-select tree, if the user is collapsing a subtree that\n* contains selected items, clear the selection from these items and\n* issue a selection event.  Only items that are selected and visible\n* are cleared.  This code also runs in the case when no item is selected.\n*/\n/* Look for check/uncheck */\n/* Get the selected state of the item under the mouse */\n/* Get the selected state of the last selected item */\n/* Check for CONTROL or drag selection */\n/*\n* This code is intentionally commented.\n*/\n//\t\t\t\tOS.SendMessage (handle, OS.WM_SETREDRAW, 0, 0);\n/* Do the selection */\n/*\n* Feature in Windows.  When the old and new focused item\n* are the same, Windows does not check to make sure that\n* the item is actually selected, not just focused.  The\n* fix is to force the item to draw selected by setting\n* the state mask.  This is only necessary when the tree\n* is single select.\n*/\n/* Reselect the last item that was unselected */\n/* Check for CONTROL and reselect the last item */\n/*\n* This code is intentionally commented.\n*/\n//\t\t\t\tOS.SendMessage (handle, OS.WM_SETREDRAW, 1, 0);\n/* Check for SHIFT or normal select and delect/reselect items */\n/* Issue notification */\n/*\n* Feature in Windows.  Inside WM_LBUTTONDOWN and WM_RBUTTONDOWN,\n* the widget starts a modal loop to determine if the user wants\n* to begin a drag/drop operation or marque select.  Unfortunately,\n* this modal loop eats the corresponding mouse up.  The fix is to\n* detect the cases when the modal loop has eaten the mouse up and\n* issue a fake mouse up.\n*/\n",
			"methodName":"LRESULT WM_LBUTTONDOWN(int wParam, int lParam)"
		},
		"void updateScrollBar()":{
			"methodBody":"{\n    if (hwndParent != 0) {\n        int columnCount = OS.SendMessage(hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);\n        if (columnCount != 0) {\n            SCROLLINFO info = new SCROLLINFO();\n            info.cbSize = SCROLLINFO.sizeof;\n            info.fMask = OS.SIF_ALL;\n            int itemCount = OS.SendMessage(handle, OS.TVM_GETCOUNT, 0, 0);\n            if (itemCount == 0) {\n                OS.GetScrollInfo(hwndParent, OS.SB_VERT, info);\n                info.nPage = info.nMax + 1;\n                OS.SetScrollInfo(hwndParent, OS.SB_VERT, info, true);\n            } else {\n                OS.GetScrollInfo(handle, OS.SB_VERT, info);\n                OS.SetScrollInfo(hwndParent, OS.SB_VERT, info, true);\n            }\n        }\n    }\n}",
			"comments":"",
			"methodName":"void updateScrollBar()"
		},
		"Widget findItem(int id)":{
			"methodBody":"{\n    TVITEM tvItem = new TVITEM();\n    tvItem.mask = OS.TVIF_HANDLE | OS.TVIF_PARAM;\n    tvItem.hItem = id;\n    if (OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem) != 0) {\n        int lParam = tvItem.lParam;\n        if (0 <= lParam && lParam < items.length)\n            return items[lParam];\n    }\n    return null;\n}",
			"comments":"",
			"methodName":"Widget findItem(int id)"
		},
		"void showWidget(boolean visible)":{
			"methodBody":"{\n    super.showWidget(visible);\n    if (hwndParent != 0) {\n        OS.ShowWindow(hwndParent, visible ? OS.SW_SHOW : OS.SW_HIDE);\n    }\n}",
			"comments":"",
			"methodName":"void showWidget(boolean visible)"
		},
		"int _getBackgroundPixel()":{
			"methodBody":"{\n    if (OS.IsWinCE)\n        return OS.GetSysColor(OS.COLOR_WINDOW);\n    int pixel = OS.SendMessage(handle, OS.TVM_GETBKCOLOR, 0, 0);\n    if (pixel == -1)\n        return OS.GetSysColor(OS.COLOR_WINDOW);\n    return pixel;\n}",
			"comments":"",
			"methodName":"int _getBackgroundPixel()"
		},
		"LRESULT WM_SETFONT(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_SETFONT(wParam, lParam);\n    if (result != null)\n        return result;\n    if (hwndHeader != 0)\n        OS.SendMessage(hwndHeader, OS.WM_SETFONT, wParam, lParam);\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_SETFONT(int wParam, int lParam)"
		},
		"void createItem(TreeItem item, int hParent, int hInsertAfter)":{
			"methodBody":"{\n    int id = 0;\n    while (id < items.length && items[id] != null) id++;\n    if (id == items.length) {\n        TreeItem[] newItems = new TreeItem[items.length + 4];\n        System.arraycopy(items, 0, newItems, 0, items.length);\n        items = newItems;\n    }\n    TVINSERTSTRUCT tvInsert = new TVINSERTSTRUCT();\n    tvInsert.hParent = hParent;\n    tvInsert.hInsertAfter = hInsertAfter;\n    tvInsert.lParam = id;\n    tvInsert.pszText = OS.LPSTR_TEXTCALLBACK;\n    tvInsert.iImage = tvInsert.iSelectedImage = OS.I_IMAGECALLBACK;\n    tvInsert.mask = OS.TVIF_TEXT | OS.TVIF_IMAGE | OS.TVIF_SELECTEDIMAGE | OS.TVIF_HANDLE | OS.TVIF_PARAM;\n    if ((style & SWT.CHECK) != 0) {\n        tvInsert.mask = tvInsert.mask | OS.TVIF_STATE;\n        tvInsert.state = 1 << 12;\n        tvInsert.stateMask = OS.TVIS_STATEIMAGEMASK;\n    }\n    int hItem = OS.SendMessage(handle, OS.TVM_INSERTITEM, 0, tvInsert);\n    if (hItem == 0)\n        error(SWT.ERROR_ITEM_NOT_ADDED);\n    item.handle = hItem;\n    items[id] = item;\n    \n    if (OS.IsWindowVisible(handle) && drawCount == 0) {\n        int hChild = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_CHILD, hParent);\n        if (hChild != 0 && OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_NEXT, hChild) == 0) {\n            RECT rect = new RECT();\n            rect.left = hParent;\n            if (OS.SendMessage(handle, OS.TVM_GETITEMRECT, 0, rect) != 0) {\n                OS.InvalidateRect(handle, rect, true);\n            }\n        }\n    }\n    updateScrollBar();\n}",
			"comments":"/*\n* This code is intentionally commented.\n*/\n//\tif (hParent != 0) {\n//\t\tint bits = OS.GetWindowLong (handle, OS.GWL_STYLE);\n//\t\tbits |= OS.TVS_LINESATROOT;\n//\t\tOS.SetWindowLong (handle, OS.GWL_STYLE, bits);\n//\t}\n/*\n* Bug in Windows.  When a child item is added to a parent item\n* that has no children outside of WM_NOTIFY with control code\n* TVN_ITEMEXPANDED, the tree widget does not redraw the +/-\n* indicator.  The fix is to detect the case when the first\n* child is added to a visible parent item and redraw the parent.\n*/\n",
			"methodName":"void createItem(TreeItem item, int hParent, int hInsertAfter)"
		},
		"public void setInsertMark(TreeItem item, boolean before)":{
			"methodBody":"{\n    checkWidget();\n    int hItem = 0;\n    if (item != null) {\n        if (item.isDisposed())\n            error(SWT.ERROR_INVALID_ARGUMENT);\n        hItem = item.handle;\n    }\n    hInsert = hItem;\n    insertAfter = !before;\n    OS.SendMessage(handle, OS.TVM_SETINSERTMARK, insertAfter ? 1 : 0, hInsert);\n}",
			"comments":"/**\n* Display a mark indicating the point at which an item will be inserted.\n* The drop insert item has a visual hint to show where a dragged item\n* will be inserted when dropped on the tree.\n*\n* @param item the insert item.  Null will clear the insertion mark.\n* @param before true places the insert mark above 'item'. false places\n*\tthe insert mark below 'item'.\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the item has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setInsertMark(TreeItem item, boolean before)"
		},
		"public void setSelection(TreeItem[] items)":{
			"methodBody":"{\n    checkWidget();\n    if (items == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    int length = items.length;\n    if (length == 0 || ((style & SWT.SINGLE) != 0 && length > 1)) {\n        deselectAll();\n        return;\n    }\n    \n    TreeItem item = items[0];\n    if (item != null) {\n        if (item.isDisposed())\n            error(SWT.ERROR_INVALID_ARGUMENT);\n        int hOldItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);\n        int hNewItem = hAnchor = item.handle;\n        \n        boolean fixScroll = checkScroll(hNewItem);\n        if (fixScroll) {\n            OS.SendMessage(handle, OS.WM_SETREDRAW, 1, 0);\n            OS.DefWindowProc(handle, OS.WM_SETREDRAW, 0, 0);\n        }\n        ignoreSelect = true;\n        OS.SendMessage(handle, OS.TVM_SELECTITEM, OS.TVGN_CARET, hNewItem);\n        ignoreSelect = false;\n        if (OS.SendMessage(handle, OS.TVM_GETVISIBLECOUNT, 0, 0) == 0) {\n            OS.SendMessage(handle, OS.TVM_SELECTITEM, OS.TVGN_FIRSTVISIBLE, hNewItem);\n        }\n        if (fixScroll) {\n            OS.DefWindowProc(handle, OS.WM_SETREDRAW, 1, 0);\n            OS.SendMessage(handle, OS.WM_SETREDRAW, 0, 0);\n        }\n        \n        if (hOldItem == hNewItem) {\n            TVITEM tvItem = new TVITEM();\n            tvItem.mask = OS.TVIF_STATE;\n            tvItem.state = OS.TVIS_SELECTED;\n            tvItem.stateMask = OS.TVIS_SELECTED;\n            tvItem.hItem = hNewItem;\n            OS.SendMessage(handle, OS.TVM_SETITEM, 0, tvItem);\n            showItem(hNewItem);\n        }\n    }\n    if ((style & SWT.SINGLE) != 0)\n        return;\n    \n    TVITEM tvItem = new TVITEM();\n    tvItem.mask = OS.TVIF_STATE;\n    tvItem.stateMask = OS.TVIS_SELECTED;\n    int oldProc = OS.GetWindowLong(handle, OS.GWL_WNDPROC);\n    OS.SetWindowLong(handle, OS.GWL_WNDPROC, TreeProc);\n    for (int i = 0; i < this.items.length; i++) {\n        item = this.items[i];\n        if (item != null) {\n            int index = 0;\n            while (index < length) {\n                if (items[index] == item)\n                    break;\n                index++;\n            }\n            tvItem.hItem = item.handle;\n            OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem);\n            if ((tvItem.state & OS.TVIS_SELECTED) != 0) {\n                if (index == length) {\n                    tvItem.state = 0;\n                    OS.SendMessage(handle, OS.TVM_SETITEM, 0, tvItem);\n                }\n            } else {\n                if (index != length) {\n                    tvItem.state = OS.TVIS_SELECTED;\n                    OS.SendMessage(handle, OS.TVM_SETITEM, 0, tvItem);\n                }\n            }\n        }\n    }\n    OS.SetWindowLong(handle, OS.GWL_WNDPROC, oldProc);\n}",
			"comments":"/**\n* Sets the receiver's selection to be the given array of items.\n* The current selection is cleared before the new items are selected.\n* <p>\n* Items that are not in the receiver are ignored.\n* If the receiver is single-select and multiple items are specified,\n* then all items are ignored.\n*\n* @param items the array of items\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the array of items is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if one of the items has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see Tree#deselectAll()\n*/\n/* Select/deselect the first item */\n/*\n* Bug in Windows.  When TVM_SELECTITEM is used to select and\n* scroll an item to be visible and the client area of the tree\n* is smaller that the size of one item, TVM_SELECTITEM makes\n* the next item in the tree visible by making it the top item\n* instead of making the desired item visible.  The fix is to\n* detect the case when the client area is too small and make\n* the desired visible item be the top item in the tree.\n*\n* Note that TVM_SELECTITEM when called with TVGN_FIRSTVISIBLE\n* also requires the work around for scrolling.\n*/\n/*\n* Feature in Windows.  When the old and new focused item\n* are the same, Windows does not check to make sure that\n* the item is actually selected, not just focused.  The\n* fix is to force the item to draw selected by setting\n* the state mask, and to ensure that it is visible.\n*/\n/* Select/deselect the rest of the items */\n",
			"methodName":"public void setSelection(TreeItem[] items)"
		},
		"int imageIndex(Image image)":{
			"methodBody":"{\n    if (image == null)\n        return OS.I_IMAGENONE;\n    if (imageList == null) {\n        int hOldList = OS.SendMessage(handle, OS.TVM_GETIMAGELIST, OS.TVSIL_NORMAL, 0);\n        if (hOldList != 0)\n            OS.ImageList_Destroy(hOldList);\n        Rectangle bounds = image.getBounds();\n        imageList = display.getImageList(style & SWT.RIGHT_TO_LEFT, bounds.width, bounds.height);\n        int index = imageList.indexOf(image);\n        if (index == -1)\n            index = imageList.add(image);\n        int hImageList = imageList.getHandle();\n        OS.SendMessage(handle, OS.TVM_SETIMAGELIST, OS.TVSIL_NORMAL, hImageList);\n        if (hwndHeader != 0) {\n            OS.SendMessage(hwndHeader, OS.HDM_SETIMAGELIST, 0, hImageList);\n        }\n        updateScrollBar();\n        return index;\n    }\n    int index = imageList.indexOf(image);\n    if (index != -1)\n        return index;\n    return imageList.add(image);\n}",
			"comments":"",
			"methodName":"int imageIndex(Image image)"
		},
		"LRESULT WM_KILLFOCUS(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_KILLFOCUS(wParam, lParam);\n    if ((style & SWT.SINGLE) != 0)\n        return result;\n    \n    OS.InvalidateRect(handle, null, false);\n    return result;\n}",
			"comments":"/*\n* Feature in Windows.  When multiple item have\n* the TVIS_SELECTED state, Windows redraws only\n* the focused item in the color used to show the\n* selection when the tree loses or gains focus.\n* The fix is to force Windows to redraw all the\n* visible items when focus is gained or lost.\n*/\n",
			"methodName":"LRESULT WM_KILLFOCUS(int wParam, int lParam)"
		},
		"public void addTreeListener(TreeListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.Expand, typedListener);\n    addListener(SWT.Collapse, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when an item in the receiver is expanded or collapsed\n* by sending it one of the messages defined in the <code>TreeListener</code>\n* interface.\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see TreeListener\n* @see #removeTreeListener\n*/\n",
			"methodName":"public void addTreeListener(TreeListener listener)"
		},
		"public TreeItem getParentItem()":{
			"methodBody":"{\n    checkWidget();\n    return null;\n}",
			"comments":"/**\n* Returns the receiver's parent item, which must be a\n* <code>TreeItem</code> or null when the receiver is a\n* root.\n*\n* @return the receiver's parent item\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public TreeItem getParentItem()"
		},
		"void setForegroundPixel(int pixel)":{
			"methodBody":"{\n    if (foreground == pixel)\n        return;\n    foreground = pixel;\n    OS.SendMessage(handle, OS.TVM_SETTEXTCOLOR, 0, pixel);\n}",
			"comments":"",
			"methodName":"void setForegroundPixel(int pixel)"
		},
		"LRESULT WM_KEYDOWN(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_KEYDOWN(wParam, lParam);\n    if (result != null)\n        return result;\n    switch(wParam) {\n        case OS.VK_SPACE:\n            \n            return LRESULT.ZERO;\n        case OS.VK_UP:\n        case OS.VK_DOWN:\n        case OS.VK_PRIOR:\n        case OS.VK_NEXT:\n        case OS.VK_HOME:\n        case OS.VK_END:\n            {\n                OS.SendMessage(handle, OS.WM_CHANGEUISTATE, OS.UIS_INITIALIZE, 0);\n                if ((style & SWT.SINGLE) != 0)\n                    break;\n                if (OS.GetKeyState(OS.VK_SHIFT) < 0) {\n                    int hItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);\n                    if (hItem != 0) {\n                        if (hAnchor == 0)\n                            hAnchor = hItem;\n                        ignoreSelect = ignoreDeselect = true;\n                        int code = callWindowProc(handle, OS.WM_KEYDOWN, wParam, lParam);\n                        ignoreSelect = ignoreDeselect = false;\n                        int hNewItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);\n                        TVITEM tvItem = new TVITEM();\n                        tvItem.mask = OS.TVIF_STATE;\n                        tvItem.stateMask = OS.TVIS_SELECTED;\n                        int hDeselectItem = hItem;\n                        RECT rect1 = new RECT();\n                        rect1.left = hAnchor;\n                        OS.SendMessage(handle, OS.TVM_GETITEMRECT, 1, rect1);\n                        RECT rect2 = rect2 = new RECT();\n                        rect2.left = hDeselectItem;\n                        OS.SendMessage(handle, OS.TVM_GETITEMRECT, 1, rect2);\n                        int flags = rect1.top < rect2.top ? OS.TVGN_PREVIOUSVISIBLE : OS.TVGN_NEXTVISIBLE;\n                        while (hDeselectItem != hAnchor) {\n                            tvItem.hItem = hDeselectItem;\n                            OS.SendMessage(handle, OS.TVM_SETITEM, 0, tvItem);\n                            hDeselectItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, flags, hDeselectItem);\n                        }\n                        int hSelectItem = hAnchor;\n                        rect1.left = hNewItem;\n                        OS.SendMessage(handle, OS.TVM_GETITEMRECT, 1, rect1);\n                        rect2.left = hSelectItem;\n                        OS.SendMessage(handle, OS.TVM_GETITEMRECT, 1, rect2);\n                        tvItem.state = OS.TVIS_SELECTED;\n                        flags = rect1.top < rect2.top ? OS.TVGN_PREVIOUSVISIBLE : OS.TVGN_NEXTVISIBLE;\n                        while (hSelectItem != hNewItem) {\n                            tvItem.hItem = hSelectItem;\n                            OS.SendMessage(handle, OS.TVM_SETITEM, 0, tvItem);\n                            hSelectItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, flags, hSelectItem);\n                        }\n                        tvItem.hItem = hNewItem;\n                        OS.SendMessage(handle, OS.TVM_SETITEM, 0, tvItem);\n                        tvItem.mask = OS.TVIF_PARAM;\n                        tvItem.hItem = hNewItem;\n                        OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem);\n                        Event event = new Event();\n                        event.item = items[tvItem.lParam];\n                        postEvent(SWT.Selection, event);\n                        return new LRESULT(code);\n                    }\n                }\n                if (OS.GetKeyState(OS.VK_CONTROL) < 0) {\n                    int hItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);\n                    if (hItem != 0) {\n                        TVITEM tvItem = new TVITEM();\n                        tvItem.mask = OS.TVIF_STATE;\n                        tvItem.stateMask = OS.TVIS_SELECTED;\n                        tvItem.hItem = hItem;\n                        OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem);\n                        boolean oldSelected = (tvItem.state & OS.TVIS_SELECTED) != 0;\n                        int hNewItem = 0;\n                        switch(wParam) {\n                            case OS.VK_UP:\n                                hNewItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_PREVIOUSVISIBLE, hItem);\n                                break;\n                            case OS.VK_DOWN:\n                                hNewItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_NEXTVISIBLE, hItem);\n                                break;\n                            case OS.VK_HOME:\n                                hNewItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_ROOT, 0);\n                                break;\n                            case OS.VK_PRIOR:\n                                hNewItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_FIRSTVISIBLE, 0);\n                                if (hNewItem == hItem) {\n                                    OS.SendMessage(handle, OS.WM_VSCROLL, OS.SB_PAGEUP, 0);\n                                    hNewItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_FIRSTVISIBLE, 0);\n                                }\n                                break;\n                            case OS.VK_NEXT:\n                                RECT rect = new RECT(), clientRect = new RECT();\n                                OS.GetClientRect(handle, clientRect);\n                                hNewItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_FIRSTVISIBLE, 0);\n                                do {\n                                    int hVisible = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_NEXTVISIBLE, hNewItem);\n                                    if (hVisible == 0)\n                                        break;\n                                    rect.left = hVisible;\n                                    OS.SendMessage(handle, OS.TVM_GETITEMRECT, 1, rect);\n                                    if (rect.bottom > clientRect.bottom)\n                                        break;\n                                    if ((hNewItem = hVisible) == hItem) {\n                                        OS.SendMessage(handle, OS.WM_VSCROLL, OS.SB_PAGEDOWN, 0);\n                                    }\n                                } while (hNewItem != 0);\n                                break;\n                            case OS.VK_END:\n                                hNewItem = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_LASTVISIBLE, 0);\n                                break;\n                        }\n                        if (hNewItem != 0) {\n                            OS.SendMessage(handle, OS.TVM_ENSUREVISIBLE, 0, hNewItem);\n                            tvItem.hItem = hNewItem;\n                            OS.SendMessage(handle, OS.TVM_GETITEM, 0, tvItem);\n                            boolean newSelected = (tvItem.state & OS.TVIS_SELECTED) != 0;\n                            if (!newSelected && drawCount == 0) {\n                                OS.UpdateWindow(handle);\n                                OS.DefWindowProc(handle, OS.WM_SETREDRAW, 0, 0);\n                            \n                            \n                            }\n                            ignoreSelect = true;\n                            OS.SendMessage(handle, OS.TVM_SELECTITEM, OS.TVGN_CARET, hNewItem);\n                            ignoreSelect = false;\n                            if (oldSelected) {\n                                tvItem.state = OS.TVIS_SELECTED;\n                                tvItem.hItem = hItem;\n                                OS.SendMessage(handle, OS.TVM_SETITEM, 0, tvItem);\n                            }\n                            if (!newSelected) {\n                                tvItem.state = 0;\n                                tvItem.hItem = hNewItem;\n                                OS.SendMessage(handle, OS.TVM_SETITEM, 0, tvItem);\n                            }\n                            if (!newSelected && drawCount == 0) {\n                                RECT rect1 = new RECT(), rect2 = new RECT();\n                                rect1.left = hItem;\n                                rect2.left = hNewItem;\n                                int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n                                int fItemRect = (bits & OS.TVS_FULLROWSELECT) != 0 ? 0 : 1;\n                                OS.SendMessage(handle, OS.TVM_GETITEMRECT, fItemRect, rect1);\n                                OS.SendMessage(handle, OS.TVM_GETITEMRECT, fItemRect, rect2);\n                                \n                                \n                                OS.DefWindowProc(handle, OS.WM_SETREDRAW, 1, 0);\n                                if (OS.IsWinCE) {\n                                    OS.InvalidateRect(handle, rect1, false);\n                                    OS.InvalidateRect(handle, rect2, false);\n                                    OS.UpdateWindow(handle);\n                                } else {\n                                    int flags = OS.RDW_UPDATENOW | OS.RDW_INVALIDATE;\n                                    OS.RedrawWindow(handle, rect1, 0, flags);\n                                    OS.RedrawWindow(handle, rect2, 0, flags);\n                                }\n                            }\n                            return LRESULT.ZERO;\n                        }\n                    }\n                }\n                int code = callWindowProc(handle, OS.WM_KEYDOWN, wParam, lParam);\n                hAnchor = OS.SendMessage(handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);\n                return new LRESULT(code);\n            }\n    }\n    return result;\n}",
			"comments":"/*\n* Ensure that the window proc does not process VK_SPACE\n* so that it can be handled in WM_CHAR.  This allows the\n* application to cancel an operation that is normally\n* performed in WM_KEYDOWN from WM_CHAR.\n*/\n/*\n* This code is intentionally commented.\n*/\n//\t\t\t\t\t\t\tOS.SendMessage (handle, OS.WM_SETREDRAW, 0, 0);\n/*\n* This code is intentionally commented.\n*/\n//\t\t\t\t\t\t\tOS.SendMessage (handle, OS.WM_SETREDRAW, 1, 0);\n",
			"methodName":"LRESULT WM_KEYDOWN(int wParam, int lParam)"
		}
	},
	"ClassORInterfaceName":[
		"Tree"
	]
}
