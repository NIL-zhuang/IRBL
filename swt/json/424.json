{
	"variables":[
		"sizeof",
		"type",
		"booleanData",
		"floatData",
		"intData",
		"shortData",
		"stringData",
		"byRefPtr",
		"dispatchData",
		"unknownData",
		"oldPtr",
		"newPtr",
		"result",
		"autoVar",
		"oldPtr",
		"newPtr",
		"result",
		"autoVar",
		"oldPtr",
		"newPtr",
		"result",
		"boolVar",
		"data",
		"ptr",
		"oldPtr",
		"newPtr",
		"result",
		"floatVar",
		"oldPtr",
		"newPtr",
		"result",
		"intVar",
		"oldPtr",
		"newPtr",
		"result",
		"shortVar",
		"oldPtr",
		"newPtr",
		"result",
		"stringVar",
		"oldPtr",
		"newPtr",
		"result",
		"unknownVar",
		"dataType",
		"newByRefPtr",
		"newBooleanData",
		"newFloatData",
		"newIntData",
		"ppvObject",
		"ppvObject",
		"newShortData",
		"hMem",
		"size",
		"buffer",
		"newPData",
		"type",
		"COM",
		"type",
		"COM",
		"floatData",
		"val",
		"type",
		"COM",
		"intData",
		"val",
		"type",
		"byRefType",
		"byRefPtr",
		"ptr",
		"type",
		"COM",
		"dispatchData",
		"automation",
		"type",
		"COM",
		"dispatchData",
		"idispatch",
		"type",
		"COM",
		"unknownData",
		"unknown",
		"type",
		"COM",
		"stringData",
		"string",
		"type",
		"COM",
		"shortData",
		"val",
		"type",
		"COM",
		"booleanData",
		"val",
		"type",
		"COM",
		"COM",
		"type",
		"COM",
		"COM",
		"COM",
		"COM",
		"COM",
		"COM",
		"COM",
		"dispatchData",
		"COM",
		"unknownData",
		"type",
		"COM",
		"OLE",
		"OLE",
		"type",
		"COM",
		"dispatchData",
		"OS",
		"COM",
		"COM",
		"sizeof",
		"OS",
		"COM",
		"COM",
		"sizeof",
		"oldPtr",
		"COM",
		"newPtr",
		"oldPtr",
		"COM",
		"result",
		"COM",
		"OLE",
		"OLE",
		"result",
		"autoVar",
		"newPtr",
		"autoVar",
		"COM",
		"oldPtr",
		"OS",
		"oldPtr",
		"COM",
		"newPtr",
		"OS",
		"newPtr",
		"type",
		"COM",
		"OLE",
		"OLE",
		"type",
		"COM",
		"dispatchData",
		"OS",
		"COM",
		"COM",
		"sizeof",
		"OS",
		"COM",
		"COM",
		"sizeof",
		"oldPtr",
		"COM",
		"newPtr",
		"oldPtr",
		"COM",
		"result",
		"COM",
		"OLE",
		"OLE",
		"result",
		"autoVar",
		"newPtr",
		"autoVar",
		"COM",
		"oldPtr",
		"OS",
		"oldPtr",
		"COM",
		"newPtr",
		"OS",
		"newPtr",
		"type",
		"COM",
		"OLE",
		"OLE",
		"type",
		"COM",
		"booleanData",
		"OS",
		"COM",
		"COM",
		"sizeof",
		"OS",
		"COM",
		"COM",
		"sizeof",
		"oldPtr",
		"COM",
		"newPtr",
		"oldPtr",
		"COM",
		"result",
		"COM",
		"OLE",
		"OLE",
		"result",
		"boolVar",
		"newPtr",
		"boolVar",
		"COM",
		"oldPtr",
		"OS",
		"oldPtr",
		"COM",
		"newPtr",
		"OS",
		"newPtr",
		"type",
		"COM",
		"OLE",
		"OLE",
		"type",
		"COM",
		"COM",
		"byRefPtr",
		"pData",
		"OLE",
		"OLE",
		"COM",
		"pData",
		"type",
		"COM",
		"COM",
		"COM",
		"pData",
		"type",
		"COM",
		"pData",
		"byRefPtr",
		"type",
		"COM",
		"COM",
		"COM",
		"pData",
		"type",
		"COM",
		"pData",
		"booleanData",
		"COM",
		"COM",
		"COM",
		"COM",
		"pData",
		"type",
		"COM",
		"pData",
		"floatData",
		"COM",
		"COM",
		"pData",
		"type",
		"COM",
		"pData",
		"intData",
		"COM",
		"dispatchData",
		"COM",
		"pData",
		"type",
		"COM",
		"pData",
		"dispatchData",
		"COM",
		"unknownData",
		"COM",
		"pData",
		"type",
		"COM",
		"pData",
		"unknownData",
		"COM",
		"COM",
		"pData",
		"type",
		"COM",
		"pData",
		"shortData",
		"COM",
		"COM",
		"pData",
		"type",
		"stringData",
		"COM",
		"data",
		"COM",
		"pData",
		"ptr",
		"OLE",
		"SWT",
		"type",
		"COM",
		"OLE",
		"OLE",
		"type",
		"COM",
		"floatData",
		"OS",
		"COM",
		"COM",
		"sizeof",
		"OS",
		"COM",
		"COM",
		"sizeof",
		"oldPtr",
		"COM",
		"newPtr",
		"oldPtr",
		"COM",
		"result",
		"COM",
		"OLE",
		"OLE",
		"result",
		"floatVar",
		"newPtr",
		"floatVar",
		"COM",
		"oldPtr",
		"OS",
		"oldPtr",
		"COM",
		"newPtr",
		"OS",
		"newPtr",
		"type",
		"COM",
		"OLE",
		"OLE",
		"type",
		"COM",
		"intData",
		"OS",
		"COM",
		"COM",
		"sizeof",
		"OS",
		"COM",
		"COM",
		"sizeof",
		"oldPtr",
		"COM",
		"newPtr",
		"oldPtr",
		"COM",
		"result",
		"COM",
		"OLE",
		"OLE",
		"result",
		"intVar",
		"newPtr",
		"intVar",
		"COM",
		"oldPtr",
		"OS",
		"oldPtr",
		"COM",
		"newPtr",
		"OS",
		"newPtr",
		"type",
		"COM",
		"OLE",
		"OLE",
		"type",
		"COM",
		"shortData",
		"OS",
		"COM",
		"COM",
		"sizeof",
		"OS",
		"COM",
		"COM",
		"sizeof",
		"oldPtr",
		"COM",
		"newPtr",
		"oldPtr",
		"COM",
		"result",
		"COM",
		"OLE",
		"OLE",
		"result",
		"shortVar",
		"newPtr",
		"shortVar",
		"COM",
		"oldPtr",
		"OS",
		"oldPtr",
		"COM",
		"newPtr",
		"OS",
		"newPtr",
		"type",
		"COM",
		"OLE",
		"OLE",
		"type",
		"COM",
		"stringData",
		"OS",
		"COM",
		"COM",
		"sizeof",
		"OS",
		"COM",
		"COM",
		"sizeof",
		"oldPtr",
		"COM",
		"newPtr",
		"oldPtr",
		"COM",
		"result",
		"COM",
		"OLE",
		"OLE",
		"result",
		"stringVar",
		"newPtr",
		"stringVar",
		"COM",
		"oldPtr",
		"OS",
		"oldPtr",
		"COM",
		"newPtr",
		"OS",
		"newPtr",
		"type",
		"type",
		"COM",
		"OLE",
		"OLE",
		"type",
		"COM",
		"unknownData",
		"OS",
		"COM",
		"COM",
		"sizeof",
		"OS",
		"COM",
		"COM",
		"sizeof",
		"oldPtr",
		"COM",
		"newPtr",
		"oldPtr",
		"COM",
		"result",
		"COM",
		"OLE",
		"OLE",
		"result",
		"unknownVar",
		"newPtr",
		"unknownVar",
		"COM",
		"oldPtr",
		"OS",
		"oldPtr",
		"COM",
		"newPtr",
		"OS",
		"newPtr",
		"type",
		"COM",
		"type",
		"COM",
		"OLE",
		"OLE",
		"COM",
		"byRefPtr",
		"val",
		"COM",
		"COM",
		"type",
		"COM",
		"type",
		"COM",
		"OLE",
		"OLE",
		"COM",
		"byRefPtr",
		"val",
		"type",
		"COM",
		"type",
		"COM",
		"OLE",
		"OLE",
		"COM",
		"byRefPtr",
		"val",
		"type",
		"COM",
		"type",
		"COM",
		"OLE",
		"OLE",
		"COM",
		"byRefPtr",
		"val",
		"pData",
		"OLE",
		"OLE",
		"COM",
		"dataType",
		"pData",
		"type",
		"dataType",
		"type",
		"COM",
		"COM",
		"OS",
		"newByRefPtr",
		"pData",
		"byRefPtr",
		"newByRefPtr",
		"type",
		"COM",
		"COM",
		"COM",
		"newBooleanData",
		"pData",
		"booleanData",
		"newBooleanData",
		"COM",
		"COM",
		"COM",
		"newFloatData",
		"pData",
		"floatData",
		"newFloatData",
		"COM",
		"OS",
		"newIntData",
		"pData",
		"intData",
		"newIntData",
		"COM",
		"OS",
		"ppvObject",
		"pData",
		"ppvObject",
		"type",
		"COM",
		"dispatchData",
		"ppvObject",
		"dispatchData",
		"COM",
		"OS",
		"ppvObject",
		"pData",
		"ppvObject",
		"type",
		"COM",
		"unknownData",
		"ppvObject",
		"unknownData",
		"COM",
		"COM",
		"newShortData",
		"pData",
		"shortData",
		"newShortData",
		"COM",
		"OS",
		"hMem",
		"pData",
		"hMem",
		"type",
		"COM",
		"COM",
		"hMem",
		"size",
		"size",
		"COM",
		"buffer",
		"hMem",
		"size",
		"stringData",
		"buffer",
		"stringData",
		"OS",
		"OS",
		"OS",
		"Variant",
		"COM",
		"newPData",
		"pData",
		"COM",
		"COM",
		"newPData",
		"COM",
		"newPData",
		"pData",
		"COM",
		"COM",
		"newPData",
		"COM",
		"newPData",
		"pData",
		"COM",
		"COM",
		"newPData",
		"COM",
		"newPData",
		"OS",
		"newPData",
		"type",
		"COM",
		"booleanData",
		"COM",
		"shortData",
		"COM",
		"intData",
		"COM",
		"floatData",
		"COM",
		"stringData",
		"COM",
		"dispatchData",
		"dispatchData",
		"COM",
		"unknownData",
		"unknownData",
		"COM",
		"type",
		"COM",
		"type",
		"COM",
		"byRefPtr",
		"type",
		"VT_EMPTY",
		"VT_R4",
		"VT_I4",
		"VT_DISPATCH",
		"VT_DISPATCH",
		"VT_UNKNOWN",
		"VT_BSTR",
		"VT_I2",
		"VT_BOOL",
		"VT_BYREF",
		"VT_BYREF",
		"VT_EMPTY",
		"VT_BOOL",
		"VT_R4",
		"VT_I4",
		"VT_I2",
		"VT_BSTR",
		"VT_DISPATCH",
		"VT_UNKNOWN",
		"VT_EMPTY",
		"ERROR_CANNOT_CHANGE_VARIANT_TYPE",
		"VT_DISPATCH",
		"GMEM_FIXED",
		"GMEM_ZEROINIT",
		"GMEM_FIXED",
		"GMEM_ZEROINIT",
		"VT_DISPATCH",
		"S_OK",
		"ERROR_CANNOT_CHANGE_VARIANT_TYPE",
		"VT_EMPTY",
		"ERROR_CANNOT_CHANGE_VARIANT_TYPE",
		"VT_DISPATCH",
		"GMEM_FIXED",
		"GMEM_ZEROINIT",
		"GMEM_FIXED",
		"GMEM_ZEROINIT",
		"VT_DISPATCH",
		"S_OK",
		"ERROR_CANNOT_CHANGE_VARIANT_TYPE",
		"VT_EMPTY",
		"ERROR_CANNOT_CHANGE_VARIANT_TYPE",
		"VT_BOOL",
		"GMEM_FIXED",
		"GMEM_ZEROINIT",
		"GMEM_FIXED",
		"GMEM_ZEROINIT",
		"VT_BOOL",
		"S_OK",
		"ERROR_CANNOT_CHANGE_VARIANT_TYPE",
		"VT_EMPTY",
		"ERROR_CANNOT_CHANGE_VARIANT_TYPE",
		"VT_BYREF",
		"VT_BYREF",
		"ERROR_OUT_OF_MEMORY",
		"VT_BYREF",
		"VT_BYREF",
		"VT_EMPTY",
		"VT_BOOL",
		"VARIANT_TRUE",
		"VARIANT_FALSE",
		"VT_R4",
		"VT_I4",
		"VT_DISPATCH",
		"VT_UNKNOWN",
		"VT_I2",
		"VT_BSTR",
		"ERROR_NOT_IMPLEMENTED",
		"VT_EMPTY",
		"ERROR_CANNOT_CHANGE_VARIANT_TYPE",
		"VT_R4",
		"GMEM_FIXED",
		"GMEM_ZEROINIT",
		"GMEM_FIXED",
		"GMEM_ZEROINIT",
		"VT_R4",
		"S_OK",
		"ERROR_CANNOT_CHANGE_VARIANT_TYPE",
		"VT_EMPTY",
		"ERROR_CANNOT_CHANGE_VARIANT_TYPE",
		"VT_I4",
		"GMEM_FIXED",
		"GMEM_ZEROINIT",
		"GMEM_FIXED",
		"GMEM_ZEROINIT",
		"VT_I4",
		"S_OK",
		"ERROR_CANNOT_CHANGE_VARIANT_TYPE",
		"VT_EMPTY",
		"ERROR_CANNOT_CHANGE_VARIANT_TYPE",
		"VT_I2",
		"GMEM_FIXED",
		"GMEM_ZEROINIT",
		"GMEM_FIXED",
		"GMEM_ZEROINIT",
		"VT_I2",
		"S_OK",
		"ERROR_CANNOT_CHANGE_VARIANT_TYPE",
		"VT_EMPTY",
		"ERROR_CANNOT_CHANGE_VARIANT_TYPE",
		"VT_BSTR",
		"GMEM_FIXED",
		"GMEM_ZEROINIT",
		"GMEM_FIXED",
		"GMEM_ZEROINIT",
		"VT_BSTR",
		"S_OK",
		"ERROR_CANNOT_CHANGE_VARIANT_TYPE",
		"VT_EMPTY",
		"ERROR_CANNOT_CHANGE_VARIANT_TYPE",
		"VT_UNKNOWN",
		"GMEM_FIXED",
		"GMEM_ZEROINIT",
		"GMEM_FIXED",
		"GMEM_ZEROINIT",
		"VT_UNKNOWN",
		"S_OK",
		"ERROR_CANNOT_CHANGE_VARIANT_TYPE",
		"VT_BYREF",
		"VT_BOOL",
		"ERROR_CANNOT_CHANGE_VARIANT_TYPE",
		"VARIANT_TRUE",
		"VARIANT_FALSE",
		"VT_BYREF",
		"VT_R4",
		"ERROR_CANNOT_CHANGE_VARIANT_TYPE",
		"VT_BYREF",
		"VT_I4",
		"ERROR_CANNOT_CHANGE_VARIANT_TYPE",
		"VT_BYREF",
		"VT_I2",
		"ERROR_CANNOT_CHANGE_VARIANT_TYPE",
		"ERROR_INVALID_ARGUMENT",
		"VT_BYREF",
		"VT_BYREF",
		"VT_EMPTY",
		"VT_BOOL",
		"VARIANT_FALSE",
		"VT_R4",
		"VT_I4",
		"VT_DISPATCH",
		"VT_EMPTY",
		"VT_UNKNOWN",
		"VT_EMPTY",
		"VT_I2",
		"VT_BSTR",
		"VT_EMPTY",
		"GMEM_FIXED",
		"GMEM_ZEROINIT",
		"sizeof",
		"VT_R4",
		"S_OK",
		"VT_I4",
		"S_OK",
		"VT_BSTR",
		"S_OK",
		"VT_BOOL",
		"VT_I2",
		"VT_I4",
		"VT_R4",
		"VT_BSTR",
		"VT_DISPATCH",
		"VT_UNKNOWN",
		"VT_EMPTY",
		"VT_BYREF",
		"VT_BYREF",
		"val",
		"val",
		"ptr",
		"byRefType",
		"automation",
		"idispatch",
		"unknown",
		"string",
		"val",
		"val",
		"pData",
		"val",
		"val",
		"val",
		"val",
		"pData"
	],
	"extendORImplementFiles":[],
	"package":[
		"org.eclipse.swt.ole.win32"
	],
	"import":[
		"org.eclipse.swt",
		"org.eclipse.swt.internal.ole.win32",
		"org.eclipse.swt.internal.win32"
	],
	"methods":[
		"dispose",
		"getAutomation",
		"getDispatch",
		"getBoolean",
		"getByRef",
		"getData",
		"getFloat",
		"getInt",
		"getShort",
		"getString",
		"getType",
		"getUnknown",
		"setByRef",
		"setByRef",
		"setByRef",
		"setByRef",
		"setData",
		"toString",
		"getAddress",
		"Release",
		"Release",
		"error",
		"GlobalAlloc",
		"GlobalAlloc",
		"getData",
		"VariantChangeType",
		"error",
		"setData",
		"getAutomation",
		"VariantClear",
		"GlobalFree",
		"VariantClear",
		"GlobalFree",
		"error",
		"GlobalAlloc",
		"GlobalAlloc",
		"getData",
		"VariantChangeType",
		"error",
		"setData",
		"getDispatch",
		"VariantClear",
		"GlobalFree",
		"VariantClear",
		"GlobalFree",
		"error",
		"GlobalAlloc",
		"GlobalAlloc",
		"getData",
		"VariantChangeType",
		"error",
		"setData",
		"getBoolean",
		"VariantClear",
		"GlobalFree",
		"VariantClear",
		"GlobalFree",
		"error",
		"error",
		"VariantInit",
		"MoveMemory",
		"MoveMemory",
		"MoveMemory",
		"MoveMemory",
		"MoveMemory",
		"MoveMemory",
		"MoveMemory",
		"MoveMemory",
		"AddRef",
		"MoveMemory",
		"MoveMemory",
		"getAddress",
		"AddRef",
		"MoveMemory",
		"MoveMemory",
		"getAddress",
		"MoveMemory",
		"MoveMemory",
		"MoveMemory",
		"toCharArray",
		"SysAllocString",
		"MoveMemory",
		"error",
		"error",
		"GlobalAlloc",
		"GlobalAlloc",
		"getData",
		"VariantChangeType",
		"error",
		"setData",
		"getFloat",
		"VariantClear",
		"GlobalFree",
		"VariantClear",
		"GlobalFree",
		"error",
		"GlobalAlloc",
		"GlobalAlloc",
		"getData",
		"VariantChangeType",
		"error",
		"setData",
		"getInt",
		"VariantClear",
		"GlobalFree",
		"VariantClear",
		"GlobalFree",
		"error",
		"GlobalAlloc",
		"GlobalAlloc",
		"getData",
		"VariantChangeType",
		"error",
		"setData",
		"getShort",
		"VariantClear",
		"GlobalFree",
		"VariantClear",
		"GlobalFree",
		"error",
		"GlobalAlloc",
		"GlobalAlloc",
		"getData",
		"VariantChangeType",
		"error",
		"setData",
		"getString",
		"VariantClear",
		"GlobalFree",
		"VariantClear",
		"GlobalFree",
		"error",
		"GlobalAlloc",
		"GlobalAlloc",
		"getData",
		"VariantChangeType",
		"error",
		"setData",
		"getUnknown",
		"VariantClear",
		"GlobalFree",
		"VariantClear",
		"GlobalFree",
		"error",
		"MoveMemory",
		"error",
		"MoveMemory",
		"error",
		"MoveMemory",
		"error",
		"MoveMemory",
		"error",
		"MoveMemory",
		"MoveMemory",
		"MoveMemory",
		"MoveMemory",
		"MoveMemory",
		"MoveMemory",
		"AddRef",
		"MoveMemory",
		"AddRef",
		"MoveMemory",
		"MoveMemory",
		"SysStringByteLen",
		"MoveMemory",
		"GlobalAlloc",
		"VariantChangeType",
		"setData",
		"VariantChangeType",
		"setData",
		"VariantChangeType",
		"setData",
		"VariantClear",
		"GlobalFree",
		"getAddress",
		"getAddress",
		"IDispatch",
		"OleAutomation",
		"Variant",
		"Variant",
		"Variant",
		"Variant",
		"Variant",
		"Variant",
		"Variant",
		"Variant",
		"IDispatch",
		"IUnknown",
		"String"
	],
	"methodsBody":{
		"public void dispose()":{
			"methodBody":"{\n    if ((type & COM.VT_BYREF) == COM.VT_BYREF) {\n        return;\n    }\n    switch(type) {\n        case COM.VT_EMPTY:\n        case COM.VT_BOOL:\n        case COM.VT_R4:\n        case COM.VT_I4:\n        case COM.VT_I2:\n        case COM.VT_BSTR:\n            break;\n        case COM.VT_DISPATCH:\n            dispatchData.Release();\n            break;\n        case COM.VT_UNKNOWN:\n            unknownData.Release();\n            break;\n    }\n}",
			"comments":"/**\n* Calling dispose will release resources associated with this Variant.\n* If the resource is an IDispatch or IUnknown interface, Release will be called.\n* If the resource is a ByRef pointer, nothing is released.\n*\n* @since 2.1\n*/\n",
			"methodName":"public void dispose()"
		},
		"public float getFloat()":{
			"methodBody":"{\n    if (type == COM.VT_EMPTY) {\n        OLE.error(OLE.ERROR_CANNOT_CHANGE_VARIANT_TYPE, -1);\n    }\n    if (type == COM.VT_R4) {\n        return floatData;\n    }\n    \n    int oldPtr = OS.GlobalAlloc(COM.GMEM_FIXED | COM.GMEM_ZEROINIT, sizeof);\n    int newPtr = OS.GlobalAlloc(COM.GMEM_FIXED | COM.GMEM_ZEROINIT, sizeof);\n    try {\n        getData(oldPtr);\n        int result = COM.VariantChangeType(newPtr, oldPtr, (short) 0, COM.VT_R4);\n        if (result != COM.S_OK)\n            OLE.error(OLE.ERROR_CANNOT_CHANGE_VARIANT_TYPE, result);\n        Variant floatVar = new Variant();\n        floatVar.setData(newPtr);\n        return floatVar.getFloat();\n    } finally {\n        COM.VariantClear(oldPtr);\n        OS.GlobalFree(oldPtr);\n        COM.VariantClear(newPtr);\n        OS.GlobalFree(newPtr);\n    }\n}",
			"comments":"/**\n* Returns the Java float represented by this Variant.\n*\n* <p>If this Variant does not contain a Java float, an attempt is made to\n* coerce the Variant type into a Java float.  If this fails, an error is thrown.\n*\n* @return the Java float represented by this Variant\n*\n* @exception SWTException <ul>\n*     <li>ERROR_CANNOT_CHANGE_VARIANT_TYPE when type of Variant can not be coerced into a float</li>\n* </ul>\n*/\n// try to coerce the value to the desired type\n",
			"methodName":"public float getFloat()"
		},
		"public OleAutomation getAutomation()":{
			"methodBody":"{\n    if (type == COM.VT_EMPTY) {\n        OLE.error(OLE.ERROR_CANNOT_CHANGE_VARIANT_TYPE, -1);\n    }\n    if (type == COM.VT_DISPATCH) {\n        return new OleAutomation(dispatchData);\n    }\n    \n    int oldPtr = OS.GlobalAlloc(COM.GMEM_FIXED | COM.GMEM_ZEROINIT, sizeof);\n    int newPtr = OS.GlobalAlloc(COM.GMEM_FIXED | COM.GMEM_ZEROINIT, sizeof);\n    try {\n        getData(oldPtr);\n        int result = COM.VariantChangeType(newPtr, oldPtr, (short) 0, COM.VT_DISPATCH);\n        if (result != COM.S_OK)\n            OLE.error(OLE.ERROR_CANNOT_CHANGE_VARIANT_TYPE, result);\n        Variant autoVar = new Variant();\n        autoVar.setData(newPtr);\n        return autoVar.getAutomation();\n    } finally {\n        COM.VariantClear(oldPtr);\n        OS.GlobalFree(oldPtr);\n        \n        COM.VariantClear(newPtr);\n        \n        \n        \n        OS.GlobalFree(newPtr);\n    }\n}",
			"comments":"/**\n* Returns the OleAutomation object represented by this Variant.\n*\n* <p>If this Variant does not contain an OleAutomation object, an attempt is made to\n* coerce the Variant type into an OleAutomation object.  If this fails, an error is\n* thrown.  Note that OleAutomation objects must be disposed when no longer\n* needed.\n*\n* @return the OleAutomation object represented by this Variant\n*\n* @exception SWTException <ul>\n*     <li>ERROR_CANNOT_CHANGE_VARIANT_TYPE when type of Variant can not be coerced into an OleAutomation object</li>\n* </ul>\n*/\n// try to coerce the value to the desired type\n// Note: This must absolutely be done AFTER the\n// OleAutomation object is created as Variant Clear\n// will result in a Release being performed on the\n// Dispatch object\n",
			"methodName":"public OleAutomation getAutomation()"
		},
		"public void setByRef(short val)":{
			"methodBody":"{\n    if ((type & COM.VT_BYREF) == 0 || (type & COM.VT_I2) == 0) {\n        OLE.error(OLE.ERROR_CANNOT_CHANGE_VARIANT_TYPE);\n    }\n    COM.MoveMemory(byRefPtr, new short[] { val }, 2);\n}",
			"comments":"/**\n* Update the by reference value of this variant with a new short value.\n*\n* @param val the new short value\n*\n* @exception SWTException <ul>\n*     <li>ERROR_CANNOT_CHANGE_VARIANT_TYPE when type of Variant is not a (VT_BYREF | VT_I2) object\n* </ul>\n*\n* @since 2.1\n*/\n",
			"methodName":"public void setByRef(short val)"
		},
		"public int getByRef()":{
			"methodBody":"{\n    if (type == COM.VT_EMPTY) {\n        OLE.error(OLE.ERROR_CANNOT_CHANGE_VARIANT_TYPE, -1);\n    }\n    if ((type & COM.VT_BYREF) == COM.VT_BYREF) {\n        return byRefPtr;\n    }\n    return 0;\n}",
			"comments":"/**\n* Returns a pointer to the referenced data represented by this Variant.\n*\n* <p>If this Variant does not contain a reference to data, zero is returned.\n*\n* @return a pointer to the referenced data represented by this Variant or 0\n*\n*/\n",
			"methodName":"public int getByRef()"
		},
		"public IDispatch getDispatch()":{
			"methodBody":"{\n    if (type == COM.VT_EMPTY) {\n        OLE.error(OLE.ERROR_CANNOT_CHANGE_VARIANT_TYPE, -1);\n    }\n    if (type == COM.VT_DISPATCH) {\n        return dispatchData;\n    }\n    \n    int oldPtr = OS.GlobalAlloc(COM.GMEM_FIXED | COM.GMEM_ZEROINIT, sizeof);\n    int newPtr = OS.GlobalAlloc(COM.GMEM_FIXED | COM.GMEM_ZEROINIT, sizeof);\n    try {\n        getData(oldPtr);\n        int result = COM.VariantChangeType(newPtr, oldPtr, (short) 0, COM.VT_DISPATCH);\n        if (result != COM.S_OK)\n            OLE.error(OLE.ERROR_CANNOT_CHANGE_VARIANT_TYPE, result);\n        Variant autoVar = new Variant();\n        autoVar.setData(newPtr);\n        return autoVar.getDispatch();\n    } finally {\n        COM.VariantClear(oldPtr);\n        OS.GlobalFree(oldPtr);\n        \n        COM.VariantClear(newPtr);\n        \n        \n        \n        OS.GlobalFree(newPtr);\n    }\n}",
			"comments":"/**\n* Returns the IDispatch object represented by this Variant.\n*\n* <p>If this Variant does not contain an IDispatch object, an attempt is made to\n* coerce the Variant type into an IDIspatch object.  If this fails, an error is\n* thrown.\n*\n* @since 2.0\n*\n* @return the IDispatch object represented by this Variant\n*\n* @exception SWTException <ul>\n*     <li>ERROR_CANNOT_CHANGE_VARIANT_TYPE when type of Variant can not be coerced into an IDispatch object</li>\n* </ul>\n*/\n// try to coerce the value to the desired type\n// Note: This must absolutely be done AFTER the\n// OleAutomation object is created as Variant Clear\n// will result in a Release being performed on the\n// Dispatch object\n",
			"methodName":"public IDispatch getDispatch()"
		},
		"public void setByRef(boolean val)":{
			"methodBody":"{\n    if ((type & COM.VT_BYREF) == 0 || (type & COM.VT_BOOL) == 0) {\n        OLE.error(OLE.ERROR_CANNOT_CHANGE_VARIANT_TYPE);\n    }\n    COM.MoveMemory(byRefPtr, new short[] { val ? COM.VARIANT_TRUE : COM.VARIANT_FALSE }, 2);\n}",
			"comments":"/**\n* Update the by reference value of this variant with a new boolean value.\n*\n* @param val the new boolean value\n*\n* @exception SWTException <ul>\n*     <li>ERROR_CANNOT_CHANGE_VARIANT_TYPE when type of Variant is not\n*\t\t\ta (VT_BYREF | VT_BOOL) object</li>\n* </ul>\n*\n* @since 2.1\n*/\n",
			"methodName":"public void setByRef(boolean val)"
		},
		"public String toString()":{
			"methodBody":"{\n    switch(type) {\n        case COM.VT_BOOL:\n            return \"VT_BOOL{\" + booleanData + \"}\";\n        case COM.VT_I2:\n            return \"VT_I2{\" + shortData + \"}\";\n        case COM.VT_I4:\n            return \"VT_I4{\" + intData + \"}\";\n        case COM.VT_R4:\n            return \"VT_R4{\" + floatData + \"}\";\n        case COM.VT_BSTR:\n            return \"VT_BSTR{\" + stringData + \"}\";\n        case COM.VT_DISPATCH:\n            return \"VT_DISPATCH{\" + (dispatchData == null ? 0 : dispatchData.getAddress()) + \"}\";\n        case COM.VT_UNKNOWN:\n            return \"VT_UNKNOWN{\" + (unknownData == null ? 0 : unknownData.getAddress()) + \"}\";\n        case COM.VT_EMPTY:\n            return \"VT_EMPTY\";\n    }\n    if ((type & COM.VT_BYREF) != 0) {\n        return \"VT_BYREF|\" + (type & ~COM.VT_BYREF) + \"{\" + byRefPtr + \"}\";\n    }\n    return \"Unsupported Type \" + type;\n}",
			"comments":"/**\n* Returns a string containing a concise, human-readable\n* description of the receiver.\n*\n* @return a string representation of the event\n*/\n",
			"methodName":"public String toString()"
		},
		"void getData(int pData)":{
			"methodBody":"{\n    if (pData == 0)\n        OLE.error(OLE.ERROR_OUT_OF_MEMORY);\n    COM.VariantInit(pData);\n    if ((type & COM.VT_BYREF) == COM.VT_BYREF) {\n        COM.MoveMemory(pData, new short[] { type }, 2);\n        COM.MoveMemory(pData + 8, new int[] { byRefPtr }, 4);\n        return;\n    }\n    switch(type) {\n        case COM.VT_EMPTY:\n            break;\n        case COM.VT_BOOL:\n            COM.MoveMemory(pData, new short[] { type }, 2);\n            COM.MoveMemory(pData + 8, new int[] { (booleanData) ? COM.VARIANT_TRUE : COM.VARIANT_FALSE }, 2);\n            break;\n        case COM.VT_R4:\n            COM.MoveMemory(pData, new short[] { type }, 2);\n            COM.MoveMemory(pData + 8, new float[] { floatData }, 4);\n            break;\n        case COM.VT_I4:\n            COM.MoveMemory(pData, new short[] { type }, 2);\n            COM.MoveMemory(pData + 8, new int[] { intData }, 4);\n            break;\n        case COM.VT_DISPATCH:\n            dispatchData.AddRef();\n            COM.MoveMemory(pData, new short[] { type }, 2);\n            COM.MoveMemory(pData + 8, new int[] { dispatchData.getAddress() }, 4);\n            break;\n        case COM.VT_UNKNOWN:\n            unknownData.AddRef();\n            COM.MoveMemory(pData, new short[] { type }, 2);\n            COM.MoveMemory(pData + 8, new int[] { unknownData.getAddress() }, 4);\n            break;\n        case COM.VT_I2:\n            COM.MoveMemory(pData, new short[] { type }, 2);\n            COM.MoveMemory(pData + 8, new short[] { shortData }, 2);\n            break;\n        case COM.VT_BSTR:\n            COM.MoveMemory(pData, new short[] { type }, 2);\n            char[] data = (stringData + \"\\0\").toCharArray();\n            int ptr = COM.SysAllocString(data);\n            COM.MoveMemory(pData + 8, new int[] { ptr }, 4);\n            break;\n        default:\n            OLE.error(SWT.ERROR_NOT_IMPLEMENTED);\n    }\n}",
			"comments":"",
			"methodName":"void getData(int pData)"
		},
		"public void setByRef(float val)":{
			"methodBody":"{\n    if ((type & COM.VT_BYREF) == 0 || (type & COM.VT_R4) == 0) {\n        OLE.error(OLE.ERROR_CANNOT_CHANGE_VARIANT_TYPE);\n    }\n    COM.MoveMemory(byRefPtr, new float[] { val }, 4);\n}",
			"comments":"/**\n* Update the by reference value of this variant with a new float value.\n*\n* @param val the new float value\n*\n* @exception SWTException <ul>\n*     <li>ERROR_CANNOT_CHANGE_VARIANT_TYPE when type of Variant is not\n*\t\t\ta (VT_BYREF | VT_R4) object</li>\n* </ul>\n*\n* @since 2.1\n*/\n",
			"methodName":"public void setByRef(float val)"
		},
		"public void setByRef(int val)":{
			"methodBody":"{\n    if ((type & COM.VT_BYREF) == 0 || (type & COM.VT_I4) == 0) {\n        OLE.error(OLE.ERROR_CANNOT_CHANGE_VARIANT_TYPE);\n    }\n    COM.MoveMemory(byRefPtr, new int[] { val }, 4);\n}",
			"comments":"/**\n* Update the by reference value of this variant with a new integer value.\n*\n* @param val the new integer value\n*\n* @exception SWTException <ul>\n*     <li>ERROR_CANNOT_CHANGE_VARIANT_TYPE when type of Variant is not a (VT_BYREF | VT_I4) object</li>\n* </ul>\n*\n* @since 2.1\n*/\n",
			"methodName":"public void setByRef(int val)"
		},
		"void setData(int pData)":{
			"methodBody":"{\n    if (pData == 0)\n        OLE.error(OLE.ERROR_INVALID_ARGUMENT);\n    short[] dataType = new short[1];\n    COM.MoveMemory(dataType, pData, 2);\n    type = dataType[0];\n    if ((type & COM.VT_BYREF) == COM.VT_BYREF) {\n        int[] newByRefPtr = new int[1];\n        OS.MoveMemory(newByRefPtr, pData + 8, 4);\n        byRefPtr = newByRefPtr[0];\n        return;\n    }\n    switch(type) {\n        case COM.VT_EMPTY:\n            break;\n        case COM.VT_BOOL:\n            short[] newBooleanData = new short[1];\n            COM.MoveMemory(newBooleanData, pData + 8, 2);\n            booleanData = (newBooleanData[0] != COM.VARIANT_FALSE);\n            break;\n        case COM.VT_R4:\n            float[] newFloatData = new float[1];\n            COM.MoveMemory(newFloatData, pData + 8, 4);\n            floatData = newFloatData[0];\n            break;\n        case COM.VT_I4:\n            int[] newIntData = new int[1];\n            OS.MoveMemory(newIntData, pData + 8, 4);\n            intData = newIntData[0];\n            break;\n        case COM.VT_DISPATCH:\n            {\n                int[] ppvObject = new int[1];\n                OS.MoveMemory(ppvObject, pData + 8, 4);\n                if (ppvObject[0] == 0) {\n                    type = COM.VT_EMPTY;\n                    break;\n                }\n                dispatchData = new IDispatch(ppvObject[0]);\n                dispatchData.AddRef();\n                break;\n            }\n        case COM.VT_UNKNOWN:\n            {\n                int[] ppvObject = new int[1];\n                OS.MoveMemory(ppvObject, pData + 8, 4);\n                if (ppvObject[0] == 0) {\n                    type = COM.VT_EMPTY;\n                    break;\n                }\n                unknownData = new IUnknown(ppvObject[0]);\n                unknownData.AddRef();\n                break;\n            }\n        case COM.VT_I2:\n            short[] newShortData = new short[1];\n            COM.MoveMemory(newShortData, pData + 8, 2);\n            shortData = newShortData[0];\n            break;\n        case COM.VT_BSTR:\n            \n            int[] hMem = new int[1];\n            OS.MoveMemory(hMem, pData + 8, 4);\n            if (hMem[0] == 0) {\n                type = COM.VT_EMPTY;\n                break;\n            }\n            \n            \n            int size = COM.SysStringByteLen(hMem[0]);\n            if (size > 0) {\n                \n                \n                char[] buffer = new char[(size + 1) / 2];\n                COM.MoveMemory(buffer, hMem[0], size);\n                stringData = new String(buffer);\n            } else {\n                \n                stringData = \"\";\n            }\n            break;\n        default:\n            \n            int newPData = OS.GlobalAlloc(OS.GMEM_FIXED | OS.GMEM_ZEROINIT, Variant.sizeof);\n            if (COM.VariantChangeType(newPData, pData, (short) 0, COM.VT_R4) == COM.S_OK) {\n                setData(newPData);\n            } else if (COM.VariantChangeType(newPData, pData, (short) 0, COM.VT_I4) == COM.S_OK) {\n                setData(newPData);\n            } else if (COM.VariantChangeType(newPData, pData, (short) 0, COM.VT_BSTR) == COM.S_OK) {\n                setData(newPData);\n            }\n            COM.VariantClear(newPData);\n            OS.GlobalFree(newPData);\n            break;\n    }\n}",
			"comments":"// get the address of the memory in which the string resides\n// Get the size of the string from the OS - the size is expressed in number\n// of bytes - each unicode character is 2 bytes.\n// get the unicode character array from the global memory and create a String\n// add one to avoid rounding errors\n//$NON-NLS-1$\n// try coercing it into one of the known forms\n",
			"methodName":"void setData(int pData)"
		},
		"public short getShort()":{
			"methodBody":"{\n    if (type == COM.VT_EMPTY) {\n        OLE.error(OLE.ERROR_CANNOT_CHANGE_VARIANT_TYPE, -1);\n    }\n    if (type == COM.VT_I2) {\n        return shortData;\n    }\n    \n    int oldPtr = OS.GlobalAlloc(COM.GMEM_FIXED | COM.GMEM_ZEROINIT, sizeof);\n    int newPtr = OS.GlobalAlloc(COM.GMEM_FIXED | COM.GMEM_ZEROINIT, sizeof);\n    try {\n        getData(oldPtr);\n        int result = COM.VariantChangeType(newPtr, oldPtr, (short) 0, COM.VT_I2);\n        if (result != COM.S_OK)\n            OLE.error(OLE.ERROR_CANNOT_CHANGE_VARIANT_TYPE, result);\n        Variant shortVar = new Variant();\n        shortVar.setData(newPtr);\n        return shortVar.getShort();\n    } finally {\n        COM.VariantClear(oldPtr);\n        OS.GlobalFree(oldPtr);\n        COM.VariantClear(newPtr);\n        OS.GlobalFree(newPtr);\n    }\n}",
			"comments":"/**\n* Returns the Java short represented by this Variant.\n*\n* <p>If this Variant does not contain a Java short, an attempt is made to\n* coerce the Variant type into a Java short.  If this fails, an error is thrown.\n*\n* @return the Java short represented by this Variant\n*\n* @exception SWTException <ul>\n*     <li>ERROR_CANNOT_CHANGE_VARIANT_TYPE when type of Variant can not be coerced into a short</li>\n* </ul>\n*/\n// try to coerce the value to the desired type\n",
			"methodName":"public short getShort()"
		},
		"public String getString()":{
			"methodBody":"{\n    if (type == COM.VT_EMPTY) {\n        OLE.error(OLE.ERROR_CANNOT_CHANGE_VARIANT_TYPE, -1);\n    }\n    if (type == COM.VT_BSTR) {\n        return stringData;\n    }\n    \n    int oldPtr = OS.GlobalAlloc(COM.GMEM_FIXED | COM.GMEM_ZEROINIT, sizeof);\n    int newPtr = OS.GlobalAlloc(COM.GMEM_FIXED | COM.GMEM_ZEROINIT, sizeof);\n    try {\n        getData(oldPtr);\n        int result = COM.VariantChangeType(newPtr, oldPtr, (short) 0, COM.VT_BSTR);\n        if (result != COM.S_OK)\n            OLE.error(OLE.ERROR_CANNOT_CHANGE_VARIANT_TYPE, result);\n        Variant stringVar = new Variant();\n        stringVar.setData(newPtr);\n        return stringVar.getString();\n    } finally {\n        COM.VariantClear(oldPtr);\n        OS.GlobalFree(oldPtr);\n        COM.VariantClear(newPtr);\n        OS.GlobalFree(newPtr);\n    }\n}",
			"comments":"/**\n* Returns the Java String represented by this Variant.\n*\n* <p>If this Variant does not contain a Java String, an attempt is made to\n* coerce the Variant type into a Java String.  If this fails, an error is thrown.\n*\n* @return the Java String represented by this Variant\n*\n* @exception SWTException <ul>\n*     <li>ERROR_CANNOT_CHANGE_VARIANT_TYPE when type of Variant can not be coerced into a String</li>\n* </ul>\n*/\n// try to coerce the value to the desired type\n",
			"methodName":"public String getString()"
		},
		"public int getInt()":{
			"methodBody":"{\n    if (type == COM.VT_EMPTY) {\n        OLE.error(OLE.ERROR_CANNOT_CHANGE_VARIANT_TYPE, -1);\n    }\n    if (type == COM.VT_I4) {\n        return intData;\n    }\n    \n    int oldPtr = OS.GlobalAlloc(COM.GMEM_FIXED | COM.GMEM_ZEROINIT, sizeof);\n    int newPtr = OS.GlobalAlloc(COM.GMEM_FIXED | COM.GMEM_ZEROINIT, sizeof);\n    try {\n        getData(oldPtr);\n        int result = COM.VariantChangeType(newPtr, oldPtr, (short) 0, COM.VT_I4);\n        if (result != COM.S_OK)\n            OLE.error(OLE.ERROR_CANNOT_CHANGE_VARIANT_TYPE, result);\n        Variant intVar = new Variant();\n        intVar.setData(newPtr);\n        return intVar.getInt();\n    } finally {\n        COM.VariantClear(oldPtr);\n        OS.GlobalFree(oldPtr);\n        COM.VariantClear(newPtr);\n        OS.GlobalFree(newPtr);\n    }\n}",
			"comments":"/**\n* Returns the Java int represented by this Variant.\n*\n* <p>If this Variant does not contain a Java int, an attempt is made to\n* coerce the Variant type into a Java int.  If this fails, an error is thrown.\n*\n* @return the Java int represented by this Variant\n*\n* @exception SWTException <ul>\n*     <li>ERROR_CANNOT_CHANGE_VARIANT_TYPE when type of Variant can not be coerced into a int</li>\n* </ul>\n*/\n// try to coerce the value to the desired type\n",
			"methodName":"public int getInt()"
		},
		"public boolean getBoolean()":{
			"methodBody":"{\n    if (type == COM.VT_EMPTY) {\n        OLE.error(OLE.ERROR_CANNOT_CHANGE_VARIANT_TYPE, -1);\n    }\n    if (type == COM.VT_BOOL) {\n        return booleanData;\n    }\n    \n    int oldPtr = OS.GlobalAlloc(COM.GMEM_FIXED | COM.GMEM_ZEROINIT, sizeof);\n    int newPtr = OS.GlobalAlloc(COM.GMEM_FIXED | COM.GMEM_ZEROINIT, sizeof);\n    try {\n        getData(oldPtr);\n        int result = COM.VariantChangeType(newPtr, oldPtr, (short) 0, COM.VT_BOOL);\n        if (result != COM.S_OK)\n            OLE.error(OLE.ERROR_CANNOT_CHANGE_VARIANT_TYPE, result);\n        Variant boolVar = new Variant();\n        boolVar.setData(newPtr);\n        return boolVar.getBoolean();\n    } finally {\n        COM.VariantClear(oldPtr);\n        OS.GlobalFree(oldPtr);\n        COM.VariantClear(newPtr);\n        OS.GlobalFree(newPtr);\n    }\n}",
			"comments":"/**\n* Returns the Java boolean represented by this Variant.\n*\n* <p>If this Variant does not contain a Java boolean, an attempt is made to\n* coerce the Variant type into a Java boolean.  If this fails, an error is thrown.\n*\n* @return the Java boolean represented by this Variant\n*\n* @exception SWTException <ul>\n*     <li>ERROR_CANNOT_CHANGE_VARIANT_TYPE when type of Variant can not be coerced into a boolean</li>\n* </ul>\n*\n*/\n// try to coerce the value to the desired type\n",
			"methodName":"public boolean getBoolean()"
		},
		"public short getType()":{
			"methodBody":"{\n    return type;\n}",
			"comments":"/**\n* Returns the type of the variant type.  This will be an OLE.VT_* value or\n* a bitwise combination of OLE.VT_* values as in the case of\n* OLE.VT_BSTR | OLE.VT_BYREF.\n*\n* @return the type of the variant data\n*\n* @since 2.0\n*/\n",
			"methodName":"public short getType()"
		},
		"public IUnknown getUnknown()":{
			"methodBody":"{\n    if (type == COM.VT_EMPTY) {\n        OLE.error(OLE.ERROR_CANNOT_CHANGE_VARIANT_TYPE, -1);\n    }\n    if (type == COM.VT_UNKNOWN) {\n        return unknownData;\n    }\n    \n    int oldPtr = OS.GlobalAlloc(COM.GMEM_FIXED | COM.GMEM_ZEROINIT, sizeof);\n    int newPtr = OS.GlobalAlloc(COM.GMEM_FIXED | COM.GMEM_ZEROINIT, sizeof);\n    try {\n        getData(oldPtr);\n        int result = COM.VariantChangeType(newPtr, oldPtr, (short) 0, COM.VT_UNKNOWN);\n        if (result != COM.S_OK)\n            OLE.error(OLE.ERROR_CANNOT_CHANGE_VARIANT_TYPE, result);\n        Variant unknownVar = new Variant();\n        unknownVar.setData(newPtr);\n        return unknownVar.getUnknown();\n    } finally {\n        COM.VariantClear(oldPtr);\n        OS.GlobalFree(oldPtr);\n        \n        COM.VariantClear(newPtr);\n        \n        \n        \n        OS.GlobalFree(newPtr);\n    }\n}",
			"comments":"/**\n* Returns the IUnknown object represented by this Variant.\n*\n* <p>If this Variant does not contain an IUnknown object, an attempt is made to\n* coerce the Variant type into an IUnknown object.  If this fails, an error is\n* thrown.\n*\n* @return the IUnknown object represented by this Variant\n*\n* @exception SWTException <ul>\n*     <li>ERROR_CANNOT_CHANGE_VARIANT_TYPE when type of Variant can not be coerced into\n*\t\t\tan IUnknown object</li>\n* </ul>\n*/\n// try to coerce the value to the desired type\n// Note: This must absolutely be done AFTER the\n// IUnknown object is created as Variant Clear\n// will result in a Release being performed on the\n// Dispatch object\n",
			"methodName":"public IUnknown getUnknown()"
		}
	},
	"ClassORInterfaceName":[
		"Variant"
	]
}
