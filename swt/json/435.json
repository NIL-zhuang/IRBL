{
	"variables":[
		"handle",
		"parent",
		"cursor",
		"menu",
		"toolTipText",
		"layoutData",
		"accessible",
		"drawCount",
		"foreground",
		"background",
		"typedListener",
		"typedListener",
		"typedListener",
		"typedListener",
		"typedListener",
		"typedListener",
		"typedListener",
		"typedListener",
		"typedListener",
		"bits",
		"width",
		"height",
		"border",
		"tabList",
		"index",
		"hwndParent",
		"bits",
		"hIMC",
		"hwnd",
		"rect",
		"control",
		"hPalette",
		"hBrush",
		"rect2",
		"index",
		"length",
		"shell",
		"control",
		"shell",
		"lpwp",
		"i",
		"wp",
		"borderHandle",
		"bits1",
		"bits2",
		"rect",
		"hwndParent",
		"width",
		"height",
		"hFont",
		"logFont",
		"cs",
		"lpCs",
		"string",
		"hMem",
		"byteCount",
		"ptr",
		"buffer",
		"hFont",
		"rect",
		"hwndParent",
		"hmonitor",
		"lpmi",
		"monitor",
		"count",
		"shell",
		"control",
		"result",
		"rect",
		"width",
		"height",
		"bits",
		"rect",
		"pt",
		"hwndFocus",
		"hwnd",
		"hDC",
		"mask",
		"flags",
		"hwnd",
		"dialogShell",
		"shell",
		"modalShells",
		"bits",
		"index",
		"modal",
		"control",
		"control",
		"size",
		"tabList",
		"i",
		"bits",
		"tabList",
		"i",
		"bits",
		"code",
		"point",
		"topHandle",
		"hwndAbove",
		"hwnd",
		"flags",
		"topHandle",
		"hwndAbove",
		"flags",
		"flags",
		"rect",
		"flags",
		"shell",
		"shell",
		"display",
		"pixel",
		"flags",
		"flags",
		"topHandle",
		"lpwp",
		"index",
		"newLpwp",
		"wp",
		"lParam",
		"hCursor",
		"hwndCursor",
		"pt",
		"hwnd",
		"control",
		"hFont",
		"control",
		"fixFocus",
		"hFont",
		"pixel",
		"flags",
		"bits",
		"flags",
		"flags",
		"shell",
		"bits",
		"control",
		"fixFocus",
		"length",
		"gap",
		"i",
		"j",
		"swap",
		"oldProc",
		"newProc",
		"pt",
		"pt",
		"hwnd",
		"code",
		"shell",
		"event",
		"key",
		"shell",
		"hwndShell",
		"hwnd",
		"detail",
		"doit",
		"all",
		"lastVirtual",
		"lastKey",
		"lastAscii",
		"code",
		"code",
		"next",
		"code",
		"code",
		"next",
		"code",
		"event",
		"shell",
		"control",
		"hwndShell",
		"event",
		"root",
		"group",
		"list",
		"length",
		"index",
		"start",
		"offset",
		"control",
		"children",
		"length",
		"index",
		"start",
		"offset",
		"child",
		"newProc",
		"oldProc",
		"flags",
		"sameFont",
		"bits",
		"bits",
		"newShell",
		"oldShell",
		"newDecorations",
		"oldDecorations",
		"menus",
		"topHandle",
		"flags",
		"result",
		"shell",
		"id",
		"item",
		"control",
		"hPalette",
		"control",
		"struct",
		"item",
		"control",
		"result",
		"lphi",
		"shell",
		"item",
		"widget",
		"menu",
		"hwndShell",
		"control",
		"shell",
		"oldMenu",
		"newMenu",
		"menu",
		"ancestor",
		"struct",
		"item",
		"hwnd",
		"control",
		"type",
		"code",
		"shell",
		"menu",
		"item",
		"menuShell",
		"index",
		"info",
		"newMenu",
		"newMenu",
		"id",
		"oldMenu",
		"ancestor",
		"flags",
		"hdr",
		"hwnd",
		"control",
		"hitTest",
		"control",
		"cursor",
		"shell",
		"item",
		"cmd",
		"hwndShell",
		"bits",
		"shell",
		"menu",
		"control",
		"shell",
		"menu",
		"key",
		"items",
		"i",
		"item",
		"text",
		"mnemonic",
		"ch",
		"shell",
		"control",
		"shell",
		"lpwp",
		"rect",
		"hwndParent",
		"forePixel",
		"backPixel",
		"parent",
		"style",
		"parent",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"SWT",
		"typedListener",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"SWT",
		"typedListener",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"SWT",
		"typedListener",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"SWT",
		"typedListener",
		"SWT",
		"typedListener",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"SWT",
		"typedListener",
		"SWT",
		"typedListener",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"handle",
		"style",
		"SWT",
		"style",
		"SWT",
		"hwnd",
		"handle",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"style",
		"SWT",
		"wHint",
		"hHint",
		"DEFAULT_WIDTH",
		"DEFAULT_HEIGHT",
		"wHint",
		"SWT",
		"width",
		"wHint",
		"hHint",
		"SWT",
		"height",
		"hHint",
		"width",
		"border",
		"height",
		"border",
		"width",
		"height",
		"parent",
		"parent",
		"tabList",
		"index",
		"tabList",
		"tabList",
		"index",
		"index",
		"index",
		"tabList",
		"parent",
		"handle",
		"OS",
		"OS",
		"OS",
		"hwndParent",
		"OS",
		"handle",
		"SWT",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"OS",
		"handle",
		"OS",
		"handle",
		"OS",
		"hwndParent",
		"OS",
		"hwndParent",
		"OS",
		"handle",
		"hIMC",
		"OS",
		"hwndParent",
		"hIMC",
		"foreground",
		"background",
		"parent",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"display",
		"OS",
		"OS",
		"display",
		"handle",
		"hwnd",
		"OS",
		"hwnd",
		"OS",
		"handle",
		"rect",
		"hDC",
		"rect",
		"OS",
		"OS",
		"control",
		"control",
		"display",
		"hPalette",
		"OS",
		"hDC",
		"hPalette",
		"OS",
		"hDC",
		"pixel",
		"OS",
		"hDC",
		"rect",
		"hBrush",
		"OS",
		"control",
		"rect2",
		"OS",
		"handle",
		"rect2",
		"control",
		"hDC",
		"rect2",
		"hDC",
		"rect",
		"OS",
		"handle",
		"enabled",
		"parent",
		"pixel",
		"cursor",
		"cursor",
		"parent",
		"background",
		"parent",
		"menu",
		"control",
		"menu",
		"string",
		"index",
		"length",
		"string",
		"index",
		"index",
		"index",
		"length",
		"string",
		"index",
		"string",
		"index",
		"index",
		"index",
		"length",
		"oldShell",
		"newShell",
		"oldDecorations",
		"newDecorations",
		"menus",
		"control",
		"shell",
		"control",
		"control",
		"control",
		"shell",
		"focusControl",
		"OS",
		"display",
		"SWT",
		"shell",
		"shell",
		"OS",
		"handle",
		"shell",
		"parent",
		"parent",
		"lpwp",
		"i",
		"lpwp",
		"i",
		"lpwp",
		"i",
		"wp",
		"wp",
		"handle",
		"wp",
		"wp",
		"wp",
		"wp",
		"wp",
		"wp",
		"lpwp",
		"i",
		"accessible",
		"accessible",
		"accessible",
		"Color",
		"display",
		"background",
		"background",
		"OS",
		"borderHandle",
		"OS",
		"bits1",
		"OS",
		"OS",
		"OS",
		"bits1",
		"OS",
		"OS",
		"OS",
		"OS",
		"borderHandle",
		"OS",
		"bits2",
		"OS",
		"OS",
		"OS",
		"OS",
		"rect",
		"parent",
		"parent",
		"OS",
		"hwndParent",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"width",
		"height",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"hFont",
		"LOGFONT",
		"logFont",
		"logFont",
		"OS",
		"cs",
		"lpCs",
		"OS",
		"lpCs",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"hMem",
		"OS",
		"hMem",
		"TCHAR",
		"TCHAR",
		"OS",
		"hMem",
		"ptr",
		"byteCount",
		"TCHAR",
		"OS",
		"buffer",
		"ptr",
		"byteCount",
		"string",
		"buffer",
		"buffer",
		"OS",
		"hMem",
		"OS",
		"string",
		"OS",
		"handle",
		"OS",
		"handle",
		"OS",
		"hFont",
		"hFont",
		"Font",
		"display",
		"hFont",
		"Color",
		"display",
		"foreground",
		"foreground",
		"layoutData",
		"OS",
		"rect",
		"parent",
		"parent",
		"OS",
		"hwndParent",
		"rect",
		"rect",
		"rect",
		"menu",
		"OS",
		"OS",
		"OS",
		"display",
		"OS",
		"handle",
		"OS",
		"lpmi",
		"MONITORINFO",
		"OS",
		"hmonitor",
		"lpmi",
		"monitor",
		"hmonitor",
		"monitor",
		"lpmi",
		"monitor",
		"lpmi",
		"monitor",
		"lpmi",
		"lpmi",
		"monitor",
		"lpmi",
		"lpmi",
		"monitor",
		"lpmi",
		"monitor",
		"lpmi",
		"monitor",
		"lpmi",
		"lpmi",
		"monitor",
		"lpmi",
		"lpmi",
		"monitor",
		"parent",
		"control",
		"shell",
		"count",
		"control",
		"control",
		"control",
		"count",
		"control",
		"shell",
		"result",
		"count",
		"control",
		"control",
		"control",
		"result",
		"parent",
		"OS",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"width",
		"height",
		"toolTipText",
		"drawCount",
		"state",
		"HIDDEN",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"OS",
		"handle",
		"rect",
		"OS",
		"handle",
		"rect",
		"OS",
		"pt",
		"OS",
		"rect",
		"pt",
		"OS",
		"hwndFocus",
		"hwndFocus",
		"handle",
		"display",
		"hwndFocus",
		"hwndFocus",
		"OS",
		"hwndFocus",
		"handle",
		"data",
		"data",
		"hwnd",
		"data",
		"data",
		"data",
		"hwnd",
		"data",
		"data",
		"hDC",
		"OS",
		"hwnd",
		"hDC",
		"OS",
		"hwnd",
		"data",
		"hDC",
		"SWT",
		"SWT",
		"data",
		"OS",
		"OS",
		"OS",
		"SWT",
		"SWT",
		"data",
		"mask",
		"data",
		"data",
		"SWT",
		"OS",
		"OS",
		"hDC",
		"flags",
		"OS",
		"data",
		"SWT",
		"SWT",
		"data",
		"SWT",
		"data",
		"SWT",
		"data",
		"display",
		"data",
		"data",
		"data",
		"OS",
		"hwnd",
		"OS",
		"hDC",
		"handle",
		"data",
		"data",
		"hwnd",
		"data",
		"data",
		"data",
		"OS",
		"hwnd",
		"hDC",
		"OS",
		"hwnd",
		"data",
		"display",
		"dialogShell",
		"dialogShell",
		"display",
		"modalShells",
		"SWT",
		"SWT",
		"modalShells",
		"index",
		"modalShells",
		"index",
		"modal",
		"modal",
		"bits",
		"control",
		"control",
		"modal",
		"control",
		"control",
		"control",
		"modal",
		"modal",
		"SWT",
		"shell",
		"shell",
		"modal",
		"shell",
		"shell",
		"shell",
		"shell",
		"parent",
		"control",
		"control",
		"control",
		"control",
		"control",
		"control",
		"control",
		"size",
		"size",
		"control",
		"control",
		"parent",
		"tabList",
		"i",
		"tabList",
		"i",
		"tabList",
		"i",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"parent",
		"tabList",
		"i",
		"tabList",
		"i",
		"tabList",
		"i",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"OS",
		"handle",
		"OS",
		"code",
		"OS",
		"code",
		"OS",
		"code",
		"OS",
		"code",
		"OS",
		"OS",
		"handle",
		"parent",
		"hwnd",
		"handle",
		"point",
		"event",
		"point",
		"event",
		"OS",
		"hwnd",
		"handle",
		"point",
		"event",
		"point",
		"event",
		"point",
		"parent",
		"OS",
		"control",
		"control",
		"SWT",
		"parent",
		"control",
		"control",
		"hwnd",
		"hwnd",
		"topHandle",
		"hwndAbove",
		"OS",
		"hwnd",
		"OS",
		"hwndAbove",
		"hwndAbove",
		"hwnd",
		"hwndAbove",
		"OS",
		"OS",
		"OS",
		"OS",
		"topHandle",
		"hwndAbove",
		"flags",
		"OS",
		"control",
		"control",
		"SWT",
		"parent",
		"control",
		"hwndAbove",
		"control",
		"hwndAbove",
		"hwndAbove",
		"topHandle",
		"OS",
		"OS",
		"OS",
		"topHandle",
		"hwndAbove",
		"flags",
		"Accessible",
		"GC",
		"data",
		"SWT",
		"SWT",
		"changed",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"OS",
		"handle",
		"flags",
		"width",
		"height",
		"OS",
		"handle",
		"OS",
		"rect",
		"x",
		"y",
		"x",
		"width",
		"y",
		"height",
		"OS",
		"OS",
		"handle",
		"rect",
		"OS",
		"OS",
		"OS",
		"all",
		"flags",
		"OS",
		"OS",
		"handle",
		"rect",
		"flags",
		"display",
		"handle",
		"parent",
		"handle",
		"OS",
		"OS",
		"handle",
		"toolTipText",
		"shell",
		"handle",
		"toolTipText",
		"menu",
		"menu",
		"menu",
		"menu",
		"cursor",
		"parent",
		"layoutData",
		"accessible",
		"accessible",
		"accessible",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"eventTable",
		"SWT",
		"listener",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"eventTable",
		"SWT",
		"listener",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"eventTable",
		"SWT",
		"listener",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"eventTable",
		"SWT",
		"listener",
		"eventTable",
		"SWT",
		"listener",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"eventTable",
		"SWT",
		"listener",
		"eventTable",
		"SWT",
		"listener",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"OS",
		"handle",
		"visible",
		"OS",
		"OS",
		"display",
		"type",
		"display",
		"type",
		"display",
		"SWT",
		"display",
		"shell",
		"type",
		"SWT",
		"shell",
		"SWT",
		"shell",
		"display",
		"shell",
		"color",
		"color",
		"SWT",
		"SWT",
		"pixel",
		"color",
		"pixel",
		"background",
		"pixel",
		"background",
		"pixel",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"OS",
		"handle",
		"flags",
		"OS",
		"OS",
		"OS",
		"x",
		"y",
		"Math",
		"width",
		"Math",
		"height",
		"flags",
		"x",
		"y",
		"width",
		"height",
		"flags",
		"defer",
		"parent",
		"parent",
		"lpwp",
		"topHandle",
		"x",
		"y",
		"width",
		"height",
		"flags",
		"index",
		"lpwp",
		"lpwp",
		"index",
		"index",
		"index",
		"lpwp",
		"lpwp",
		"System",
		"lpwp",
		"newLpwp",
		"lpwp",
		"parent",
		"lpwp",
		"newLpwp",
		"wp",
		"topHandle",
		"wp",
		"x",
		"wp",
		"y",
		"wp",
		"width",
		"wp",
		"height",
		"wp",
		"flags",
		"lpwp",
		"index",
		"wp",
		"topHandle",
		"x",
		"y",
		"width",
		"height",
		"flags",
		"rect",
		"SWT",
		"rect",
		"rect",
		"rect",
		"rect",
		"capture",
		"OS",
		"handle",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"handle",
		"lParam",
		"cursor",
		"cursor",
		"SWT",
		"SWT",
		"cursor",
		"OS",
		"cursor",
		"cursor",
		"OS",
		"hCursor",
		"OS",
		"hwndCursor",
		"OS",
		"pt",
		"hwndCursor",
		"OS",
		"pt",
		"hwnd",
		"hwnd",
		"handle",
		"hwnd",
		"OS",
		"hwnd",
		"hwnd",
		"display",
		"hwndCursor",
		"control",
		"control",
		"control",
		"display",
		"OS",
		"handle",
		"OS",
		"hFont",
		"enabled",
		"display",
		"SWT",
		"control",
		"display",
		"fixFocus",
		"control",
		"enabled",
		"fixFocus",
		"control",
		"style",
		"SWT",
		"style",
		"SWT",
		"font",
		"font",
		"SWT",
		"SWT",
		"hFont",
		"font",
		"hFont",
		"hFont",
		"OS",
		"handle",
		"OS",
		"hFont",
		"color",
		"color",
		"SWT",
		"SWT",
		"pixel",
		"color",
		"pixel",
		"foreground",
		"pixel",
		"foreground",
		"pixel",
		"OS",
		"handle",
		"layoutData",
		"OS",
		"OS",
		"OS",
		"OS",
		"flags",
		"OS",
		"x",
		"y",
		"flags",
		"location",
		"SWT",
		"location",
		"location",
		"menu",
		"menu",
		"SWT",
		"SWT",
		"menu",
		"SWT",
		"SWT",
		"menu",
		"SWT",
		"menu",
		"drawCount",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"state",
		"HIDDEN",
		"redraw",
		"drawCount",
		"OS",
		"handle",
		"OS",
		"state",
		"HIDDEN",
		"state",
		"HIDDEN",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"handle",
		"flags",
		"drawCount",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"Math",
		"width",
		"Math",
		"height",
		"flags",
		"size",
		"SWT",
		"size",
		"size",
		"shell",
		"handle",
		"toolTipText",
		"string",
		"drawCount",
		"state",
		"HIDDEN",
		"visible",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"visible",
		"visible",
		"SWT",
		"visible",
		"display",
		"SWT",
		"control",
		"display",
		"fixFocus",
		"control",
		"drawCount",
		"state",
		"visible",
		"state",
		"HIDDEN",
		"state",
		"HIDDEN",
		"visible",
		"visible",
		"SWT",
		"fixFocus",
		"control",
		"items",
		"length",
		"gap",
		"gap",
		"gap",
		"i",
		"length",
		"i",
		"i",
		"gap",
		"j",
		"j",
		"gap",
		"items",
		"j",
		"items",
		"j",
		"gap",
		"items",
		"j",
		"items",
		"j",
		"items",
		"j",
		"gap",
		"items",
		"j",
		"gap",
		"swap",
		"display",
		"oldProc",
		"newProc",
		"OS",
		"handle",
		"OS",
		"newProc",
		"pt",
		"x",
		"pt",
		"y",
		"OS",
		"handle",
		"pt",
		"pt",
		"pt",
		"point",
		"SWT",
		"point",
		"point",
		"pt",
		"x",
		"pt",
		"y",
		"OS",
		"handle",
		"pt",
		"pt",
		"pt",
		"point",
		"SWT",
		"point",
		"point",
		"handle",
		"msg",
		"control",
		"event",
		"event",
		"event",
		"msg",
		"msg",
		"OS",
		"OS",
		"OS",
		"hwnd",
		"OS",
		"code",
		"OS",
		"code",
		"OS",
		"shell",
		"shell",
		"display",
		"msg",
		"display",
		"display",
		"event",
		"SWT",
		"event",
		"SWT",
		"msg",
		"msg",
		"event",
		"shell",
		"event",
		"msg",
		"key",
		"OS",
		"shell",
		"OS",
		"hwndShell",
		"OS",
		"OS",
		"msg",
		"SWT",
		"key",
		"key",
		"OS",
		"all",
		"lastAscii",
		"OS",
		"hwnd",
		"OS",
		"code",
		"OS",
		"code",
		"OS",
		"doit",
		"detail",
		"SWT",
		"OS",
		"all",
		"lastAscii",
		"OS",
		"hwnd",
		"OS",
		"code",
		"OS",
		"doit",
		"detail",
		"SWT",
		"OS",
		"lastAscii",
		"OS",
		"OS",
		"OS",
		"hwnd",
		"OS",
		"code",
		"OS",
		"OS",
		"code",
		"OS",
		"next",
		"OS",
		"OS",
		"doit",
		"doit",
		"parent",
		"parent",
		"SWT",
		"key",
		"OS",
		"key",
		"OS",
		"next",
		"next",
		"detail",
		"next",
		"SWT",
		"SWT",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"key",
		"OS",
		"key",
		"OS",
		"lastVirtual",
		"OS",
		"hwnd",
		"OS",
		"code",
		"OS",
		"doit",
		"key",
		"OS",
		"key",
		"OS",
		"detail",
		"next",
		"SWT",
		"SWT",
		"OS",
		"OS",
		"all",
		"lastVirtual",
		"OS",
		"OS",
		"OS",
		"hwnd",
		"OS",
		"code",
		"OS",
		"code",
		"OS",
		"doit",
		"detail",
		"key",
		"OS",
		"SWT",
		"SWT",
		"event",
		"doit",
		"event",
		"detail",
		"display",
		"lastKey",
		"display",
		"lastAscii",
		"display",
		"lastVirtual",
		"display",
		"display",
		"event",
		"SWT",
		"msg",
		"msg",
		"control",
		"event",
		"shell",
		"OS",
		"hwndShell",
		"OS",
		"OS",
		"event",
		"control",
		"SWT",
		"control",
		"shell",
		"control",
		"control",
		"all",
		"control",
		"SWT",
		"event",
		"event",
		"event",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"event",
		"SWT",
		"SWT",
		"event",
		"event",
		"traversal",
		"event",
		"root",
		"list",
		"index",
		"length",
		"list",
		"index",
		"group",
		"index",
		"index",
		"length",
		"index",
		"next",
		"index",
		"index",
		"offset",
		"length",
		"length",
		"start",
		"list",
		"index",
		"control",
		"control",
		"group",
		"group",
		"parent",
		"children",
		"index",
		"length",
		"children",
		"index",
		"index",
		"index",
		"length",
		"index",
		"next",
		"index",
		"index",
		"offset",
		"length",
		"length",
		"start",
		"children",
		"index",
		"child",
		"child",
		"child",
		"key",
		"display",
		"oldProc",
		"newProc",
		"OS",
		"handle",
		"OS",
		"newProc",
		"OS",
		"OS",
		"handle",
		"OS",
		"all",
		"flags",
		"OS",
		"OS",
		"handle",
		"flags",
		"oldFont",
		"sameFont",
		"newFont",
		"sameFont",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"OS",
		"OS",
		"bits",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"bits",
		"parent",
		"OS",
		"OS",
		"OS",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"bits",
		"parent",
		"SWT",
		"parent",
		"SWT",
		"SWT",
		"parent",
		"parent",
		"parent",
		"oldShell",
		"newShell",
		"oldDecorations",
		"newDecorations",
		"oldShell",
		"newShell",
		"oldShell",
		"newDecorations",
		"oldDecorations",
		"menus",
		"OS",
		"topHandle",
		"parent",
		"parent",
		"OS",
		"OS",
		"OS",
		"topHandle",
		"OS",
		"flags",
		"msg",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"wParam",
		"lParam",
		"result",
		"result",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"handle",
		"wParam",
		"lParam",
		"handle",
		"wParam",
		"lParam",
		"lParam",
		"shell",
		"wParam",
		"display",
		"id",
		"item",
		"item",
		"item",
		"wParam",
		"lParam",
		"display",
		"lParam",
		"control",
		"control",
		"wParam",
		"lParam",
		"handle",
		"wParam",
		"lParam",
		"display",
		"hPalette",
		"OS",
		"wParam",
		"hPalette",
		"OS",
		"wParam",
		"display",
		"lParam",
		"control",
		"control",
		"wParam",
		"lParam",
		"OS",
		"struct",
		"lParam",
		"DRAWITEMSTRUCT",
		"struct",
		"OS",
		"display",
		"struct",
		"item",
		"item",
		"wParam",
		"lParam",
		"display",
		"struct",
		"control",
		"control",
		"wParam",
		"lParam",
		"accessible",
		"accessible",
		"wParam",
		"lParam",
		"result",
		"result",
		"OS",
		"OS",
		"lphi",
		"lParam",
		"HELPINFO",
		"shell",
		"lphi",
		"OS",
		"display",
		"lphi",
		"item",
		"item",
		"item",
		"SWT",
		"widget",
		"item",
		"item",
		"menu",
		"SWT",
		"widget",
		"menu",
		"widget",
		"shell",
		"OS",
		"hwndShell",
		"OS",
		"widget",
		"SWT",
		"LRESULT",
		"SWT",
		"SWT",
		"LRESULT",
		"lParam",
		"display",
		"lParam",
		"control",
		"control",
		"wParam",
		"lParam",
		"handle",
		"wParam",
		"lParam",
		"display",
		"shell",
		"lParam",
		"newMenu",
		"wParam",
		"newMenu",
		"newMenu",
		"newMenu",
		"menu",
		"menu",
		"oldMenu",
		"menu",
		"menu",
		"menu",
		"menu",
		"shell",
		"menu",
		"menu",
		"SWT",
		"menu",
		"menu",
		"menu",
		"newMenu",
		"ancestor",
		"ancestor",
		"menu",
		"ancestor",
		"ancestor",
		"ancestor",
		"newMenu",
		"newMenu",
		"newMenu",
		"shell",
		"newMenu",
		"newMenu",
		"newMenu",
		"oldMenu",
		"newMenu",
		"SWT",
		"handle",
		"wParam",
		"lParam",
		"handle",
		"wParam",
		"lParam",
		"handle",
		"wParam",
		"lParam",
		"handle",
		"wParam",
		"lParam",
		"handle",
		"wParam",
		"lParam",
		"handle",
		"wParam",
		"lParam",
		"handle",
		"wParam",
		"lParam",
		"handle",
		"wParam",
		"lParam",
		"handle",
		"wParam",
		"lParam",
		"OS",
		"struct",
		"lParam",
		"MEASUREITEMSTRUCT",
		"struct",
		"OS",
		"display",
		"struct",
		"item",
		"item",
		"wParam",
		"lParam",
		"OS",
		"handle",
		"struct",
		"display",
		"hwnd",
		"control",
		"control",
		"wParam",
		"lParam",
		"wParam",
		"type",
		"type",
		"OS",
		"display",
		"OS",
		"wParam",
		"code",
		"lParam",
		"shell",
		"menu",
		"display",
		"menu",
		"SWT",
		"menu",
		"menu",
		"menu",
		"shell",
		"code",
		"OS",
		"code",
		"OS",
		"code",
		"OS",
		"wParam",
		"info",
		"MENUITEMINFO",
		"info",
		"OS",
		"OS",
		"lParam",
		"index",
		"info",
		"menuShell",
		"info",
		"newMenu",
		"item",
		"newMenu",
		"menuShell",
		"lParam",
		"newMenu",
		"wParam",
		"item",
		"display",
		"id",
		"shell",
		"oldMenu",
		"oldMenu",
		"ancestor",
		"ancestor",
		"newMenu",
		"ancestor",
		"ancestor",
		"ancestor",
		"newMenu",
		"ancestor",
		"oldMenu",
		"ancestor",
		"newMenu",
		"ancestor",
		"SWT",
		"ancestor",
		"ancestor",
		"ancestor",
		"shell",
		"newMenu",
		"newMenu",
		"newMenu",
		"shell",
		"newMenu",
		"item",
		"item",
		"item",
		"item",
		"item",
		"SWT",
		"handle",
		"wParam",
		"lParam",
		"handle",
		"wParam",
		"lParam",
		"handle",
		"wParam",
		"lParam",
		"handle",
		"wParam",
		"lParam",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"OS",
		"handle",
		"flags",
		"SWT",
		"OS",
		"handle",
		"OS",
		"OS",
		"hdr",
		"lParam",
		"NMHDR",
		"hdr",
		"hwnd",
		"display",
		"hwnd",
		"control",
		"control",
		"wParam",
		"lParam",
		"handle",
		"wParam",
		"lParam",
		"handle",
		"wParam",
		"lParam",
		"handle",
		"wParam",
		"lParam",
		"handle",
		"wParam",
		"lParam",
		"lParam",
		"hitTest",
		"OS",
		"display",
		"wParam",
		"control",
		"control",
		"cursor",
		"OS",
		"cursor",
		"LRESULT",
		"handle",
		"wParam",
		"lParam",
		"SWT",
		"handle",
		"wParam",
		"lParam",
		"wParam",
		"shell",
		"display",
		"wParam",
		"item",
		"item",
		"wParam",
		"lParam",
		"LRESULT",
		"wParam",
		"cmd",
		"OS",
		"OS",
		"hwndShell",
		"OS",
		"bits",
		"OS",
		"LRESULT",
		"OS",
		"lParam",
		"shell",
		"menu",
		"display",
		"control",
		"control",
		"SWT",
		"control",
		"SWT",
		"display",
		"LRESULT",
		"SWT",
		"SWT",
		"lParam",
		"shell",
		"menu",
		"Display",
		"lParam",
		"key",
		"key",
		"Character",
		"key",
		"menu",
		"i",
		"items",
		"i",
		"items",
		"i",
		"item",
		"text",
		"text",
		"mnemonic",
		"text",
		"Character",
		"ch",
		"key",
		"display",
		"LRESULT",
		"display",
		"OS",
		"OS",
		"shell",
		"shell",
		"LRESULT",
		"OS",
		"handle",
		"wParam",
		"lParam",
		"handle",
		"wParam",
		"lParam",
		"lParam",
		"display",
		"lParam",
		"control",
		"control",
		"wParam",
		"lParam",
		"drawCount",
		"shell",
		"OS",
		"lpwp",
		"lParam",
		"WINDOWPOS",
		"lpwp",
		"OS",
		"lpwp",
		"OS",
		"OS",
		"rect",
		"parent",
		"parent",
		"OS",
		"hwndParent",
		"rect",
		"OS",
		"hwndParent",
		"rect",
		"handle",
		"wParam",
		"lParam",
		"handle",
		"wParam",
		"lParam",
		"handle",
		"wParam",
		"lParam",
		"background",
		"foreground",
		"foreground",
		"background",
		"forePixel",
		"forePixel",
		"backPixel",
		"backPixel",
		"OS",
		"wParam",
		"forePixel",
		"OS",
		"wParam",
		"backPixel",
		"backPixel",
		"parent",
		"ERROR_NULL_ARGUMENT",
		"Resize",
		"Move",
		"ERROR_NULL_ARGUMENT",
		"FocusIn",
		"FocusOut",
		"ERROR_NULL_ARGUMENT",
		"Help",
		"ERROR_NULL_ARGUMENT",
		"KeyUp",
		"KeyDown",
		"ERROR_NULL_ARGUMENT",
		"MouseDown",
		"MouseUp",
		"MouseDoubleClick",
		"ERROR_NULL_ARGUMENT",
		"MouseEnter",
		"MouseExit",
		"MouseHover",
		"ERROR_NULL_ARGUMENT",
		"MouseMove",
		"ERROR_NULL_ARGUMENT",
		"Paint",
		"ERROR_NULL_ARGUMENT",
		"Traverse",
		"BORDER",
		"DOUBLE_BUFFERED",
		"RIGHT_TO_LEFT",
		"GWL_EXSTYLE",
		"WS_EX_LAYOUTRTL",
		"MIRRORED",
		"DEFAULT",
		"DEFAULT",
		"length",
		"length",
		"CW_USEDEFAULT",
		"CW_USEDEFAULT",
		"ERROR_NO_HANDLES",
		"GWL_STYLE",
		"WS_CHILD",
		"GWL_ID",
		"IsDBLocale",
		"IsWinCE",
		"COLOR_WINDOW",
		"COLOR_BTNFACE",
		"COLOR_WINDOWTEXT",
		"COMCTL32_MAJOR",
		"hPalette",
		"handle",
		"parent",
		"focusEvent",
		"FocusOut",
		"lpwp",
		"length",
		"hwnd",
		"hwnd",
		"x",
		"y",
		"cx",
		"cy",
		"flags",
		"GWL_EXSTYLE",
		"WS_EX_CLIENTEDGE",
		"SM_CXEDGE",
		"WS_EX_STATICEDGE",
		"SM_CXBORDER",
		"GWL_STYLE",
		"WS_BORDER",
		"SM_CXBORDER",
		"handle",
		"right",
		"left",
		"bottom",
		"top",
		"left",
		"top",
		"IsUnicode",
		"CP_ACP",
		"WM_GETFONT",
		"IsUnicode",
		"sizeof",
		"lfCharSet",
		"TCI_SRCCHARSET",
		"IsUnicode",
		"CF_UNICODETEXT",
		"CF_TEXT",
		"sizeof",
		"sizeof",
		"sizeof",
		"WM_GETFONT",
		"handle",
		"left",
		"top",
		"IsWinCE",
		"WIN32_VERSION",
		"MONITOR_DEFAULTTONEAREST",
		"cbSize",
		"sizeof",
		"handle",
		"x",
		"rcMonitor_left",
		"y",
		"rcMonitor_top",
		"width",
		"rcMonitor_right",
		"rcMonitor_left",
		"height",
		"rcMonitor_bottom",
		"rcMonitor_top",
		"clientX",
		"rcWork_left",
		"clientY",
		"rcWork_top",
		"clientWidth",
		"rcWork_right",
		"rcWork_left",
		"clientHeight",
		"rcWork_bottom",
		"rcWork_top",
		"parent",
		"parent",
		"right",
		"left",
		"bottom",
		"top",
		"GWL_STYLE",
		"WS_VISIBLE",
		"hwnd",
		"hwnd",
		"hwnd",
		"ps",
		"ps",
		"ERROR_NO_HANDLES",
		"IsWinCE",
		"WIN32_VERSION",
		"LEFT_TO_RIGHT",
		"RIGHT_TO_LEFT",
		"style",
		"layout",
		"style",
		"RIGHT_TO_LEFT",
		"LAYOUT_RTL",
		"LAYOUT_RTL",
		"style",
		"RIGHT_TO_LEFT",
		"MIRRORED",
		"style",
		"LEFT_TO_RIGHT",
		"style",
		"LEFT_TO_RIGHT",
		"device",
		"foreground",
		"background",
		"hFont",
		"WM_GETFONT",
		"hwnd",
		"hwnd",
		"ps",
		"ps",
		"modalShells",
		"APPLICATION_MODAL",
		"SYSTEM_MODAL",
		"length",
		"style",
		"parent",
		"style",
		"PRIMARY_MODAL",
		"parent",
		"parent",
		"x",
		"y",
		"parent",
		"length",
		"GWL_STYLE",
		"WS_TABSTOP",
		"length",
		"GWL_STYLE",
		"WS_TABSTOP",
		"WM_GETDLGCODE",
		"DLGC_STATIC",
		"DLGC_WANTALLKEYS",
		"DLGC_WANTARROWS",
		"DLGC_WANTTAB",
		"x",
		"x",
		"y",
		"y",
		"x",
		"x",
		"y",
		"y",
		"HWND_TOP",
		"ERROR_INVALID_ARGUMENT",
		"parent",
		"GW_HWNDPREV",
		"HWND_TOP",
		"SWP_NOSIZE",
		"SWP_NOMOVE",
		"SWP_NOACTIVATE",
		"HWND_BOTTOM",
		"ERROR_INVALID_ARGUMENT",
		"parent",
		"SWP_NOSIZE",
		"SWP_NOMOVE",
		"SWP_NOACTIVATE",
		"DEFAULT",
		"DEFAULT",
		"IsWinCE",
		"RDW_ERASE",
		"RDW_FRAME",
		"RDW_INVALIDATE",
		"IsWinCE",
		"RDW_ERASE",
		"RDW_FRAME",
		"RDW_INVALIDATE",
		"RDW_ALLCHILDREN",
		"IsDBLocale",
		"ERROR_NULL_ARGUMENT",
		"Move",
		"Resize",
		"ERROR_NULL_ARGUMENT",
		"FocusIn",
		"FocusOut",
		"ERROR_NULL_ARGUMENT",
		"Help",
		"ERROR_NULL_ARGUMENT",
		"KeyUp",
		"KeyDown",
		"ERROR_NULL_ARGUMENT",
		"MouseEnter",
		"MouseExit",
		"MouseHover",
		"ERROR_NULL_ARGUMENT",
		"MouseDown",
		"MouseUp",
		"MouseDoubleClick",
		"ERROR_NULL_ARGUMENT",
		"MouseMove",
		"ERROR_NULL_ARGUMENT",
		"Paint",
		"ERROR_NULL_ARGUMENT",
		"Traverse",
		"SW_SHOW",
		"SW_HIDE",
		"display",
		"focusEvent",
		"focusControl",
		"focusEvent",
		"None",
		"focusControl",
		"FocusIn",
		"FocusOut",
		"ERROR_INVALID_ARGUMENT",
		"handle",
		"IsWinCE",
		"RDW_ERASE",
		"RDW_FRAME",
		"RDW_INVALIDATE",
		"SWP_NOZORDER",
		"SWP_DRAWFRAME",
		"SWP_NOACTIVATE",
		"lpwp",
		"length",
		"length",
		"length",
		"length",
		"lpwp",
		"hwnd",
		"x",
		"y",
		"cx",
		"cy",
		"flags",
		"ERROR_NULL_ARGUMENT",
		"x",
		"y",
		"width",
		"height",
		"HTCLIENT",
		"WM_MOUSEMOVE",
		"WM_SETCURSOR",
		"ERROR_INVALID_ARGUMENT",
		"cursor",
		"IsWinCE",
		"handle",
		"WM_SETFONT",
		"focusEvent",
		"FocusOut",
		"NO_FOCUS",
		"NO_FOCUS",
		"ERROR_INVALID_ARGUMENT",
		"handle",
		"WM_SETFONT",
		"ERROR_INVALID_ARGUMENT",
		"handle",
		"layoutData",
		"SWP_NOSIZE",
		"SWP_NOZORDER",
		"SWP_NOACTIVATE",
		"IsWinCE",
		"SWP_DRAWFRAME",
		"ERROR_NULL_ARGUMENT",
		"x",
		"y",
		"ERROR_INVALID_ARGUMENT",
		"style",
		"POP_UP",
		"ERROR_MENU_NOT_POP_UP",
		"parent",
		"ERROR_INVALID_PARENT",
		"menu",
		"GWL_STYLE",
		"WS_VISIBLE",
		"WM_SETREDRAW",
		"SW_HIDE",
		"IsWinCE",
		"RDW_ERASE",
		"RDW_FRAME",
		"RDW_INVALIDATE",
		"RDW_ALLCHILDREN",
		"WM_SETREDRAW",
		"SWP_NOMOVE",
		"SWP_NOZORDER",
		"SWP_DRAWFRAME",
		"SWP_NOACTIVATE",
		"ERROR_NULL_ARGUMENT",
		"x",
		"y",
		"GWL_STYLE",
		"WS_VISIBLE",
		"Show",
		"focusEvent",
		"FocusOut",
		"Hide",
		"length",
		"windowProc",
		"GWL_WNDPROC",
		"x",
		"y",
		"x",
		"y",
		"ERROR_NULL_ARGUMENT",
		"x",
		"y",
		"x",
		"y",
		"x",
		"y",
		"ERROR_NULL_ARGUMENT",
		"x",
		"y",
		"doit",
		"character",
		"wParam",
		"hwnd",
		"VK_MENU",
		"WM_GETDLGCODE",
		"DLGC_WANTALLKEYS",
		"DLGC_BUTTON",
		"lastAscii",
		"wParam",
		"lastNull",
		"lastDead",
		"detail",
		"TRAVERSE_MNEMONIC",
		"Traverse",
		"wParam",
		"lParam",
		"wParam",
		"VK_MENU",
		"handle",
		"WM_CHANGEUISTATE",
		"UIS_INITIALIZE",
		"hwnd",
		"TRAVERSE_NONE",
		"VK_ESCAPE",
		"WM_GETDLGCODE",
		"DLGC_WANTALLKEYS",
		"DLGC_HASSETSEL",
		"TRAVERSE_ESCAPE",
		"VK_RETURN",
		"WM_GETDLGCODE",
		"DLGC_WANTALLKEYS",
		"TRAVERSE_RETURN",
		"VK_TAB",
		"VK_SHIFT",
		"WM_GETDLGCODE",
		"DLGC_WANTTAB",
		"DLGC_WANTALLKEYS",
		"DLGC_HASSETSEL",
		"VK_CONTROL",
		"style",
		"MIRRORED",
		"VK_LEFT",
		"VK_RIGHT",
		"TRAVERSE_TAB_NEXT",
		"TRAVERSE_TAB_PREVIOUS",
		"VK_UP",
		"VK_LEFT",
		"VK_DOWN",
		"VK_RIGHT",
		"IsSP",
		"VK_LEFT",
		"VK_RIGHT",
		"WM_GETDLGCODE",
		"DLGC_WANTARROWS",
		"VK_DOWN",
		"VK_RIGHT",
		"TRAVERSE_ARROW_NEXT",
		"TRAVERSE_ARROW_PREVIOUS",
		"VK_PRIOR",
		"VK_NEXT",
		"VK_CONTROL",
		"WM_GETDLGCODE",
		"DLGC_WANTALLKEYS",
		"DLGC_HASSETSEL",
		"VK_PRIOR",
		"TRAVERSE_PAGE_PREVIOUS",
		"TRAVERSE_PAGE_NEXT",
		"doit",
		"detail",
		"lastKey",
		"lastAscii",
		"lastVirtual",
		"lastNull",
		"lastDead",
		"Traverse",
		"wParam",
		"lParam",
		"handle",
		"WM_CHANGEUISTATE",
		"UIS_INITIALIZE",
		"doit",
		"Traverse",
		"parent",
		"Traverse",
		"doit",
		"detail",
		"TRAVERSE_NONE",
		"TRAVERSE_ESCAPE",
		"TRAVERSE_RETURN",
		"TRAVERSE_TAB_NEXT",
		"TRAVERSE_TAB_PREVIOUS",
		"TRAVERSE_ARROW_NEXT",
		"TRAVERSE_ARROW_PREVIOUS",
		"TRAVERSE_MNEMONIC",
		"character",
		"TRAVERSE_PAGE_NEXT",
		"TRAVERSE_PAGE_PREVIOUS",
		"doit",
		"detail",
		"length",
		"length",
		"windowProc",
		"GWL_WNDPROC",
		"IsWinCE",
		"RDW_UPDATENOW",
		"RDW_ALLCHILDREN",
		"IsPPC",
		"BORDER",
		"WS_EX_CLIENTEDGE",
		"WIN32_VERSION",
		"WS_EX_NOINHERITLAYOUT",
		"RIGHT_TO_LEFT",
		"WS_EX_LAYOUTRTL",
		"handle",
		"WS_CHILD",
		"WS_VISIBLE",
		"WS_CLIPSIBLINGS",
		"IsPPC",
		"BORDER",
		"WS_BORDER",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"parent",
		"handle",
		"parent",
		"SWP_NOSIZE",
		"SWP_NOMOVE",
		"SWP_NOACTIVATE",
		"HWND_BOTTOM",
		"WM_ACTIVATE",
		"WM_CAPTURECHANGED",
		"WM_CHAR",
		"WM_CLEAR",
		"WM_CLOSE",
		"WM_COMMAND",
		"WM_CONTEXTMENU",
		"WM_CTLCOLORBTN",
		"WM_CTLCOLORDLG",
		"WM_CTLCOLOREDIT",
		"WM_CTLCOLORLISTBOX",
		"WM_CTLCOLORMSGBOX",
		"WM_CTLCOLORSCROLLBAR",
		"WM_CTLCOLORSTATIC",
		"WM_CUT",
		"WM_DESTROY",
		"WM_DRAWITEM",
		"WM_ENDSESSION",
		"WM_ENTERIDLE",
		"WM_ERASEBKGND",
		"WM_GETDLGCODE",
		"WM_GETFONT",
		"WM_GETOBJECT",
		"WM_GETMINMAXINFO",
		"WM_HELP",
		"WM_HSCROLL",
		"WM_IME_CHAR",
		"WM_IME_COMPOSITION",
		"WM_INITMENUPOPUP",
		"WM_INPUTLANGCHANGE",
		"WM_HOTKEY",
		"WM_KEYDOWN",
		"WM_KEYUP",
		"WM_KILLFOCUS",
		"WM_LBUTTONDBLCLK",
		"WM_LBUTTONDOWN",
		"WM_LBUTTONUP",
		"WM_MBUTTONDBLCLK",
		"WM_MBUTTONDOWN",
		"WM_MBUTTONUP",
		"WM_MEASUREITEM",
		"WM_MENUCHAR",
		"WM_MENUSELECT",
		"WM_MOUSEACTIVATE",
		"WM_MOUSEHOVER",
		"WM_MOUSELEAVE",
		"WM_MOUSEMOVE",
		"WM_MOUSEWHEEL",
		"WM_MOVE",
		"WM_NCACTIVATE",
		"WM_NCCALCSIZE",
		"WM_NCHITTEST",
		"WM_NCLBUTTONDOWN",
		"WM_NOTIFY",
		"WM_PAINT",
		"WM_PALETTECHANGED",
		"WM_PARENTNOTIFY",
		"WM_PASTE",
		"WM_PRINTCLIENT",
		"WM_QUERYENDSESSION",
		"WM_QUERYNEWPALETTE",
		"WM_QUERYOPEN",
		"WM_RBUTTONDBLCLK",
		"WM_RBUTTONDOWN",
		"WM_RBUTTONUP",
		"WM_SETCURSOR",
		"WM_SETFOCUS",
		"WM_SETFONT",
		"WM_SETTINGCHANGE",
		"WM_SETREDRAW",
		"WM_SHOWWINDOW",
		"WM_SIZE",
		"WM_SYSCHAR",
		"WM_SYSCOLORCHANGE",
		"WM_SYSCOMMAND",
		"WM_SYSKEYDOWN",
		"WM_SYSKEYUP",
		"WM_TIMER",
		"WM_UNDO",
		"WM_VSCROLL",
		"WM_WINDOWPOSCHANGED",
		"WM_WINDOWPOSCHANGING",
		"WM_XBUTTONDBLCLK",
		"WM_XBUTTONDOWN",
		"WM_XBUTTONUP",
		"value",
		"hPalette",
		"sizeof",
		"CtlType",
		"ODT_MENU",
		"itemID",
		"hwndItem",
		"IsWinCE",
		"sizeof",
		"iContextType",
		"HELPINFO_MENUITEM",
		"iCtrlId",
		"Help",
		"parent",
		"Help",
		"handle",
		"WM_CANCELMODE",
		"Help",
		"ONE",
		"Help",
		"Help",
		"ONE",
		"accelKeyHit",
		"activeMenu",
		"activeMenu",
		"Hide",
		"activeMenu",
		"Show",
		"sizeof",
		"CtlType",
		"ODT_MENU",
		"itemID",
		"CtlID",
		"MF_SYSMENU",
		"mnemonicKeyHit",
		"MNC_CLOSE",
		"activeMenu",
		"mnemonicKeyHit",
		"Hide",
		"activeMenu",
		"MF_SYSMENU",
		"MF_HILITE",
		"MF_POPUP",
		"cbSize",
		"sizeof",
		"fMask",
		"MIIM_SUBMENU",
		"hSubMenu",
		"cascade",
		"activeMenu",
		"Hide",
		"activeMenu",
		"Arm",
		"COMCTL32_MAJOR",
		"RDW_ERASE",
		"RDW_INVALIDATE",
		"RDW_ALLCHILDREN",
		"Move",
		"HTTRANSPARENT",
		"sizeof",
		"hwndFrom",
		"HTCLIENT",
		"handle",
		"ONE",
		"Resize",
		"ZERO",
		"SC_CLOSE",
		"handle",
		"GWL_STYLE",
		"WS_SYSMENU",
		"ZERO",
		"SC_KEYMENU",
		"KeyDown",
		"KeyUp",
		"mnemonicKeyHit",
		"ZERO",
		"KeyDown",
		"KeyUp",
		"length",
		"mnemonicKeyHit",
		"ZERO",
		"mnemonicKeyHit",
		"SC_HSCROLL",
		"SC_VSCROLL",
		"ZERO",
		"SC_MINIMIZE",
		"sizeof",
		"flags",
		"SWP_NOMOVE",
		"flags",
		"SWP_NOSIZE",
		"handle",
		"parent",
		"style",
		"listener",
		"listener",
		"listener",
		"listener",
		"listener",
		"listener",
		"listener",
		"listener",
		"listener",
		"hwnd",
		"wHint",
		"hHint",
		"wHint",
		"hHint",
		"changed",
		"hDC",
		"hDC",
		"pixel",
		"rect",
		"hDC",
		"rect",
		"hDC",
		"rect",
		"enabled",
		"pixel",
		"control",
		"string",
		"newShell",
		"oldShell",
		"newDecorations",
		"oldDecorations",
		"menus",
		"focusControl",
		"data",
		"hDC",
		"data",
		"control",
		"hwnd",
		"event",
		"changed",
		"all",
		"key",
		"key",
		"control",
		"control",
		"control",
		"data",
		"changed",
		"x",
		"y",
		"width",
		"height",
		"all",
		"listener",
		"listener",
		"listener",
		"listener",
		"listener",
		"listener",
		"listener",
		"listener",
		"listener",
		"visible",
		"type",
		"color",
		"pixel",
		"x",
		"y",
		"width",
		"height",
		"x",
		"y",
		"width",
		"height",
		"flags",
		"x",
		"y",
		"width",
		"height",
		"flags",
		"defer",
		"rect",
		"capture",
		"cursor",
		"enabled",
		"font",
		"color",
		"pixel",
		"layoutData",
		"x",
		"y",
		"location",
		"menu",
		"value",
		"redraw",
		"width",
		"height",
		"size",
		"string",
		"visible",
		"items",
		"x",
		"y",
		"point",
		"x",
		"y",
		"point",
		"msg",
		"event",
		"control",
		"msg",
		"msg",
		"event",
		"traversal",
		"next",
		"next",
		"key",
		"next",
		"all",
		"oldFont",
		"newFont",
		"resize",
		"all",
		"parent",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam"
	],
	"extendORImplementFiles":[
		"Widget",
		"Drawable"
	],
	"package":[
		"org.eclipse.swt.widgets"
	],
	"import":[
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt.graphics",
		"org.eclipse.swt",
		"org.eclipse.swt.events",
		"org.eclipse.swt.accessibility"
	],
	"methods":[
		"addControlListener",
		"addFocusListener",
		"addHelpListener",
		"addKeyListener",
		"addMouseListener",
		"addMouseTrackListener",
		"addMouseMoveListener",
		"addPaintListener",
		"addTraverseListener",
		"borderHandle",
		"checkBorder",
		"checkBuffered",
		"checkHandle",
		"checkMirrored",
		"computeSize",
		"computeSize",
		"computeTabGroup",
		"computeTabRoot",
		"computeTabList",
		"createHandle",
		"createWidget",
		"defaultBackground",
		"defaultFont",
		"defaultForeground",
		"deregister",
		"destroyWidget",
		"drawBackground",
		"drawBackground",
		"drawBackground",
		"drawThemeBackground",
		"enableWidget",
		"findBrush",
		"findCursor",
		"findThemeControl",
		"findMenus",
		"findMnemonic",
		"fixChildren",
		"fixFocus",
		"forceFocus",
		"forceResize",
		"getAccessible",
		"getBackground",
		"getBackgroundPixel",
		"getBorderWidth",
		"getBounds",
		"getCodePage",
		"getClipboardText",
		"getEnabled",
		"getFont",
		"getForeground",
		"getForegroundPixel",
		"getLayoutData",
		"getLocation",
		"getMenu",
		"getMonitor",
		"getParent",
		"getPath",
		"getShell",
		"getSize",
		"getToolTipText",
		"getVisible",
		"hasCursor",
		"hasFocus",
		"internal_new_GC",
		"internal_dispose_GC",
		"isActive",
		"isEnabled",
		"isFocusControl",
		"isFocusAncestor",
		"isReparentable",
		"isShowing",
		"isTabGroup",
		"isTabItem",
		"isVisible",
		"mapEvent",
		"markLayout",
		"menuShell",
		"mnemonicHit",
		"mnemonicMatch",
		"moveAbove",
		"moveBelow",
		"new_Accessible",
		"new_GC",
		"pack",
		"pack",
		"redraw",
		"redraw",
		"register",
		"releaseChild",
		"releaseHandle",
		"releaseWidget",
		"removeControlListener",
		"removeFocusListener",
		"removeHelpListener",
		"removeKeyListener",
		"removeMouseTrackListener",
		"removeMouseListener",
		"removeMouseMoveListener",
		"removePaintListener",
		"removeTraverseListener",
		"showWidget",
		"sendFocusEvent",
		"setBackground",
		"setBackgroundPixel",
		"setBounds",
		"setBounds",
		"setBounds",
		"setBounds",
		"setCapture",
		"setCursor",
		"setCursor",
		"setDefaultFont",
		"setEnabled",
		"setFixedFocus",
		"setFocus",
		"setFont",
		"setForeground",
		"setForegroundPixel",
		"setLayoutData",
		"setLocation",
		"setLocation",
		"setMenu",
		"setRadioFocus",
		"setRadioSelection",
		"setRedraw",
		"setSavedFocus",
		"setSize",
		"setSize",
		"setTabGroupFocus",
		"setTabItemFocus",
		"setToolTipText",
		"setVisible",
		"sort",
		"subclass",
		"toControl",
		"toControl",
		"toDisplay",
		"toDisplay",
		"topHandle",
		"translateAccelerator",
		"translateMnemonic",
		"translateMnemonic",
		"translateTraversal",
		"traverse",
		"traverse",
		"traverseEscape",
		"traverseGroup",
		"traverseItem",
		"traverseMnemonic",
		"traversePage",
		"traverseReturn",
		"unsubclass",
		"update",
		"update",
		"updateFont",
		"updateLayout",
		"widgetCreateStruct",
		"widgetExtStyle",
		"widgetParent",
		"widgetStyle",
		"setParent",
		"windowClass",
		"windowProc",
		"windowProc",
		"WM_ACTIVATE",
		"WM_CAPTURECHANGED",
		"WM_CHAR",
		"WM_CLEAR",
		"WM_CLOSE",
		"WM_COMMAND",
		"WM_CONTEXTMENU",
		"WM_CTLCOLOR",
		"WM_CUT",
		"WM_DESTROY",
		"WM_DRAWITEM",
		"WM_ENDSESSION",
		"WM_ENTERIDLE",
		"WM_ERASEBKGND",
		"WM_GETDLGCODE",
		"WM_GETFONT",
		"WM_GETOBJECT",
		"WM_GETMINMAXINFO",
		"WM_HOTKEY",
		"WM_HELP",
		"WM_HSCROLL",
		"WM_IME_CHAR",
		"WM_IME_COMPOSITION",
		"WM_INITMENUPOPUP",
		"WM_INPUTLANGCHANGE",
		"WM_KEYDOWN",
		"WM_KEYUP",
		"WM_KILLFOCUS",
		"WM_LBUTTONDBLCLK",
		"WM_LBUTTONDOWN",
		"WM_LBUTTONUP",
		"WM_MBUTTONDBLCLK",
		"WM_MBUTTONDOWN",
		"WM_MBUTTONUP",
		"WM_MEASUREITEM",
		"WM_MENUCHAR",
		"WM_MENUSELECT",
		"WM_MOUSEACTIVATE",
		"WM_MOUSEHOVER",
		"WM_MOUSELEAVE",
		"WM_MOUSEMOVE",
		"WM_MOUSEWHEEL",
		"WM_MOVE",
		"WM_NCACTIVATE",
		"WM_NCCALCSIZE",
		"WM_NCHITTEST",
		"WM_NCLBUTTONDOWN",
		"WM_NOTIFY",
		"WM_PAINT",
		"WM_PALETTECHANGED",
		"WM_PARENTNOTIFY",
		"WM_PASTE",
		"WM_PRINTCLIENT",
		"WM_QUERYENDSESSION",
		"WM_QUERYNEWPALETTE",
		"WM_QUERYOPEN",
		"WM_RBUTTONDBLCLK",
		"WM_RBUTTONDOWN",
		"WM_RBUTTONUP",
		"WM_SETCURSOR",
		"WM_SETFOCUS",
		"WM_SETTINGCHANGE",
		"WM_SETFONT",
		"WM_SETREDRAW",
		"WM_SHOWWINDOW",
		"WM_SIZE",
		"WM_SYSCHAR",
		"WM_SYSCOLORCHANGE",
		"WM_SYSCOMMAND",
		"WM_SYSKEYDOWN",
		"WM_SYSKEYUP",
		"WM_TIMER",
		"WM_UNDO",
		"WM_VSCROLL",
		"WM_WINDOWPOSCHANGED",
		"WM_WINDOWPOSCHANGING",
		"WM_XBUTTONDBLCLK",
		"WM_XBUTTONDOWN",
		"WM_XBUTTONUP",
		"wmColorChild",
		"wmCommandChild",
		"wmDrawChild",
		"wmMeasureChild",
		"wmNotifyChild",
		"wmScrollChild",
		"createWidget",
		"checkWidget",
		"error",
		"addListener",
		"addListener",
		"checkWidget",
		"error",
		"addListener",
		"addListener",
		"checkWidget",
		"error",
		"addListener",
		"checkWidget",
		"error",
		"addListener",
		"addListener",
		"checkWidget",
		"error",
		"addListener",
		"addListener",
		"addListener",
		"checkWidget",
		"error",
		"addListener",
		"addListener",
		"addListener",
		"checkWidget",
		"error",
		"addListener",
		"checkWidget",
		"error",
		"addListener",
		"checkWidget",
		"error",
		"addListener",
		"getBorderWidth",
		"GetWindowLong",
		"computeSize",
		"checkWidget",
		"getBorderWidth",
		"isTabGroup",
		"computeTabGroup",
		"_getTabList",
		"isTabGroup",
		"computeTabRoot",
		"isTabGroup",
		"getVisible",
		"getEnabled",
		"widgetParent",
		"CreateWindowEx",
		"widgetExtStyle",
		"windowClass",
		"widgetStyle",
		"GetModuleHandle",
		"widgetCreateStruct",
		"error",
		"GetWindowLong",
		"SetWindowLong",
		"ImmGetContext",
		"ImmAssociateContext",
		"ImmReleaseContext",
		"checkOrientation",
		"createHandle",
		"checkBuffered",
		"register",
		"subclass",
		"setDefaultFont",
		"checkMirrored",
		"checkBorder",
		"GetSysColor",
		"GetSysColor",
		"systemFont",
		"GetSysColor",
		"removeControl",
		"topHandle",
		"releaseHandle",
		"DestroyWindow",
		"GetClientRect",
		"drawBackground",
		"getBackgroundPixel",
		"IsAppThemed",
		"findThemeControl",
		"SelectPalette",
		"RealizePalette",
		"findBrush",
		"FillRect",
		"GetWindowRect",
		"MapWindowPoints",
		"drawThemeBackground",
		"drawBackground",
		"getBackgroundPixel",
		"EnableWindow",
		"findBrush",
		"findCursor",
		"findThemeControl",
		"length",
		"charAt",
		"charAt",
		"charAt",
		"fixShell",
		"fixDecorations",
		"getShell",
		"setFixedFocus",
		"setSavedFocus",
		"SetFocus",
		"checkWidget",
		"menuShell",
		"setSavedFocus",
		"isEnabled",
		"isVisible",
		"isActive",
		"isFocusControl",
		"setSavedFocus",
		"SetFocus",
		"isDisposed",
		"setSavedFocus",
		"isFocusControl",
		"SetWindowPos",
		"checkWidget",
		"new_Accessible",
		"checkWidget",
		"win32_new",
		"getBackgroundPixel",
		"defaultBackground",
		"checkWidget",
		"borderHandle",
		"GetWindowLong",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"GetWindowLong",
		"GetSystemMetrics",
		"checkWidget",
		"forceResize",
		"GetWindowRect",
		"topHandle",
		"MapWindowPoints",
		"SendMessage",
		"GetObject",
		"TranslateCharsetInfo",
		"GetACP",
		"OpenClipboard",
		"GetClipboardData",
		"GlobalSize",
		"GlobalLock",
		"MoveMemory",
		"toString",
		"strlen",
		"GlobalUnlock",
		"CloseClipboard",
		"checkWidget",
		"IsWindowEnabled",
		"checkWidget",
		"SendMessage",
		"defaultFont",
		"win32_new",
		"checkWidget",
		"win32_new",
		"getForegroundPixel",
		"defaultForeground",
		"checkWidget",
		"checkWidget",
		"forceResize",
		"GetWindowRect",
		"topHandle",
		"MapWindowPoints",
		"checkWidget",
		"checkWidget",
		"VERSION",
		"getPrimaryMonitor",
		"MonitorFromWindow",
		"GetMonitorInfo",
		"checkWidget",
		"getShell",
		"checkWidget",
		"getShell",
		"checkWidget",
		"forceResize",
		"GetWindowRect",
		"topHandle",
		"checkWidget",
		"checkWidget",
		"GetWindowLong",
		"GetClientRect",
		"MapWindowPoints",
		"GetCursorPos",
		"PtInRect",
		"GetFocus",
		"getControl",
		"GetParent",
		"checkWidget",
		"GetDC",
		"BeginPaint",
		"error",
		"VERSION",
		"GetLayout",
		"getForegroundPixel",
		"getBackgroundPixel",
		"SendMessage",
		"checkWidget",
		"ReleaseDC",
		"EndPaint",
		"getModalDialogShell",
		"getShell",
		"getShell",
		"getShell",
		"getEnabled",
		"checkWidget",
		"getEnabled",
		"isEnabled",
		"checkWidget",
		"hasFocus",
		"checkWidget",
		"isVisible",
		"getSize",
		"_getTabList",
		"GetWindowLong",
		"_getTabList",
		"GetWindowLong",
		"SendMessage",
		"checkWidget",
		"IsWindowVisible",
		"getVisible",
		"isVisible",
		"MapWindowPoints",
		"menuShell",
		"checkWidget",
		"topHandle",
		"isDisposed",
		"error",
		"topHandle",
		"GetWindow",
		"SetWindowPos",
		"checkWidget",
		"topHandle",
		"isDisposed",
		"error",
		"topHandle",
		"SetWindowPos",
		"internal_new_Accessible",
		"win32_new",
		"checkWidget",
		"pack",
		"checkWidget",
		"setSize",
		"computeSize",
		"checkWidget",
		"IsWindowVisible",
		"InvalidateRect",
		"RedrawWindow",
		"checkWidget",
		"IsWindowVisible",
		"SetRect",
		"InvalidateRect",
		"RedrawWindow",
		"addControl",
		"removeControl",
		"releaseHandle",
		"releaseWidget",
		"ImmAssociateContext",
		"getShell",
		"setToolTipText",
		"isDisposed",
		"dispose",
		"deregister",
		"unsubclass",
		"internal_dispose_Accessible",
		"checkWidget",
		"error",
		"unhook",
		"unhook",
		"checkWidget",
		"error",
		"unhook",
		"unhook",
		"checkWidget",
		"error",
		"unhook",
		"checkWidget",
		"error",
		"unhook",
		"unhook",
		"checkWidget",
		"error",
		"unhook",
		"unhook",
		"unhook",
		"checkWidget",
		"error",
		"unhook",
		"unhook",
		"unhook",
		"checkWidget",
		"error",
		"unhook",
		"checkWidget",
		"error",
		"unhook",
		"checkWidget",
		"error",
		"unhook",
		"ShowWindow",
		"getShell",
		"sendEvent",
		"isDisposed",
		"setActiveControl",
		"getActiveShell",
		"setActiveControl",
		"checkWidget",
		"isDisposed",
		"error",
		"setBackgroundPixel",
		"InvalidateRect",
		"RedrawWindow",
		"checkWidget",
		"setBounds",
		"max",
		"max",
		"setBounds",
		"topHandle",
		"forceResize",
		"SetWindowPos",
		"arraycopy",
		"SetWindowPos",
		"checkWidget",
		"error",
		"setBounds",
		"checkWidget",
		"SetCapture",
		"GetCapture",
		"ReleaseCapture",
		"SendMessage",
		"checkWidget",
		"isDisposed",
		"error",
		"SetCursor",
		"GetCapture",
		"GetCursorPos",
		"WindowFromPoint",
		"GetParent",
		"getControl",
		"setCursor",
		"systemFont",
		"SendMessage",
		"checkWidget",
		"getFocusControl",
		"isFocusAncestor",
		"enableWidget",
		"fixFocus",
		"forceFocus",
		"checkWidget",
		"forceFocus",
		"checkWidget",
		"isDisposed",
		"error",
		"defaultFont",
		"SendMessage",
		"checkWidget",
		"isDisposed",
		"error",
		"setForegroundPixel",
		"InvalidateRect",
		"checkWidget",
		"checkWidget",
		"setBounds",
		"checkWidget",
		"error",
		"setLocation",
		"checkWidget",
		"isDisposed",
		"error",
		"error",
		"menuShell",
		"error",
		"checkWidget",
		"GetWindowLong",
		"SendMessage",
		"ShowWindow",
		"InvalidateRect",
		"RedrawWindow",
		"SendMessage",
		"forceFocus",
		"checkWidget",
		"setBounds",
		"max",
		"max",
		"checkWidget",
		"error",
		"setSize",
		"setTabItemFocus",
		"isShowing",
		"forceFocus",
		"checkWidget",
		"getShell",
		"setToolTipText",
		"checkWidget",
		"GetWindowLong",
		"sendEvent",
		"isDisposed",
		"getFocusControl",
		"isFocusAncestor",
		"showWidget",
		"isDisposed",
		"sendEvent",
		"isDisposed",
		"fixFocus",
		"windowProc",
		"SetWindowLong",
		"checkWidget",
		"ScreenToClient",
		"checkWidget",
		"error",
		"toControl",
		"checkWidget",
		"ClientToScreen",
		"checkWidget",
		"error",
		"toDisplay",
		"translateAccelerator",
		"menuShell",
		"isVisible",
		"isEnabled",
		"mnemonicMatch",
		"traverse",
		"GetKeyState",
		"SendMessage",
		"menuShell",
		"isVisible",
		"isEnabled",
		"setKeyState",
		"translateMnemonic",
		"translateMnemonic",
		"getShell",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"GetKeyState",
		"SendMessage",
		"GetKeyState",
		"SendMessage",
		"GetKeyState",
		"SendMessage",
		"setKeyState",
		"getShell",
		"traverse",
		"SendMessage",
		"hooks",
		"sendEvent",
		"isDisposed",
		"traverseEscape",
		"traverseReturn",
		"traverseGroup",
		"traverseGroup",
		"traverseItem",
		"traverseItem",
		"traverseMnemonic",
		"traversePage",
		"traversePage",
		"checkWidget",
		"traverse",
		"computeTabRoot",
		"computeTabGroup",
		"computeTabList",
		"isDisposed",
		"setTabGroupFocus",
		"isDisposed",
		"setTabGroupFocus",
		"_getChildren",
		"isDisposed",
		"isTabItem",
		"setTabItemFocus",
		"mnemonicHit",
		"windowProc",
		"SetWindowLong",
		"checkWidget",
		"update",
		"UpdateWindow",
		"RedrawWindow",
		"equals",
		"getFont",
		"setFont",
		"VERSION",
		"checkWidget",
		"error",
		"isDisposed",
		"error",
		"isReparentable",
		"releaseChild",
		"getShell",
		"getShell",
		"menuShell",
		"menuShell",
		"findMenus",
		"fixChildren",
		"topHandle",
		"SetParent",
		"SetWindowPos",
		"WM_ACTIVATE",
		"WM_CAPTURECHANGED",
		"WM_CHAR",
		"WM_CLEAR",
		"WM_CLOSE",
		"WM_COMMAND",
		"WM_CONTEXTMENU",
		"WM_CTLCOLOR",
		"WM_CUT",
		"WM_DESTROY",
		"WM_DRAWITEM",
		"WM_ENDSESSION",
		"WM_ENTERIDLE",
		"WM_ERASEBKGND",
		"WM_GETDLGCODE",
		"WM_GETFONT",
		"WM_GETOBJECT",
		"WM_GETMINMAXINFO",
		"WM_HELP",
		"WM_HSCROLL",
		"WM_IME_CHAR",
		"WM_IME_COMPOSITION",
		"WM_INITMENUPOPUP",
		"WM_INPUTLANGCHANGE",
		"WM_HOTKEY",
		"WM_KEYDOWN",
		"WM_KEYUP",
		"WM_KILLFOCUS",
		"WM_LBUTTONDBLCLK",
		"WM_LBUTTONDOWN",
		"WM_LBUTTONUP",
		"WM_MBUTTONDBLCLK",
		"WM_MBUTTONDOWN",
		"WM_MBUTTONUP",
		"WM_MEASUREITEM",
		"WM_MENUCHAR",
		"WM_MENUSELECT",
		"WM_MOUSEACTIVATE",
		"WM_MOUSEHOVER",
		"WM_MOUSELEAVE",
		"WM_MOUSEMOVE",
		"WM_MOUSEWHEEL",
		"WM_MOVE",
		"WM_NCACTIVATE",
		"WM_NCCALCSIZE",
		"WM_NCHITTEST",
		"WM_NCLBUTTONDOWN",
		"WM_NOTIFY",
		"WM_PAINT",
		"WM_PALETTECHANGED",
		"WM_PARENTNOTIFY",
		"WM_PASTE",
		"WM_PRINTCLIENT",
		"WM_QUERYENDSESSION",
		"WM_QUERYNEWPALETTE",
		"WM_QUERYOPEN",
		"WM_RBUTTONDBLCLK",
		"WM_RBUTTONDOWN",
		"WM_RBUTTONUP",
		"WM_SETCURSOR",
		"WM_SETFOCUS",
		"WM_SETFONT",
		"WM_SETTINGCHANGE",
		"WM_SETREDRAW",
		"WM_SHOWWINDOW",
		"WM_SIZE",
		"WM_SYSCHAR",
		"WM_SYSCOLORCHANGE",
		"WM_SYSCOMMAND",
		"WM_SYSKEYDOWN",
		"WM_SYSKEYUP",
		"WM_TIMER",
		"WM_UNDO",
		"WM_VSCROLL",
		"WM_WINDOWPOSCHANGED",
		"WM_WINDOWPOSCHANGING",
		"WM_XBUTTONDBLCLK",
		"WM_XBUTTONDOWN",
		"WM_XBUTTONUP",
		"callWindowProc",
		"wmCaptureChanged",
		"wmChar",
		"menuShell",
		"isEnabled",
		"getMenuItem",
		"isEnabled",
		"wmCommandChild",
		"getControl",
		"wmCommandChild",
		"wmContextMenu",
		"SelectPalette",
		"RealizePalette",
		"getControl",
		"wmColorChild",
		"MoveMemory",
		"getMenuItem",
		"wmDrawChild",
		"getControl",
		"wmDrawChild",
		"internal_WM_GETOBJECT",
		"MoveMemory",
		"menuShell",
		"isEnabled",
		"getMenuItem",
		"isEnabled",
		"hooks",
		"hooks",
		"SendMessage",
		"postEvent",
		"hooks",
		"postEvent",
		"getControl",
		"wmScrollChild",
		"wmIMEChar",
		"getShell",
		"findMenu",
		"menuShell",
		"update",
		"getParentMenu",
		"sendEvent",
		"isDisposed",
		"getParentMenu",
		"getParentMenu",
		"isDisposed",
		"sendEvent",
		"wmKeyDown",
		"wmKeyUp",
		"wmKillFocus",
		"wmLButtonDblClk",
		"wmLButtonDown",
		"wmLButtonUp",
		"wmMButtonDblClk",
		"wmMButtonDown",
		"wmMButtonUp",
		"MoveMemory",
		"getMenuItem",
		"wmMeasureChild",
		"GetDlgItem",
		"getControl",
		"wmMeasureChild",
		"getShell",
		"sendEvent",
		"isDisposed",
		"getParentMenu",
		"menuShell",
		"GetMenuItemInfo",
		"findMenu",
		"findMenu",
		"getMenuItem",
		"getParentMenu",
		"sendEvent",
		"isDisposed",
		"getParentMenu",
		"isDisposed",
		"isDisposed",
		"isDisposed",
		"sendEvent",
		"wmMouseHover",
		"wmMouseLeave",
		"wmMouseMove",
		"wmMouseWheel",
		"IsAppThemed",
		"IsWindowVisible",
		"findThemeControl",
		"RedrawWindow",
		"sendEvent",
		"IsWindowEnabled",
		"isActive",
		"MoveMemory",
		"getControl",
		"wmNotifyChild",
		"wmPaint",
		"wmRButtonDblClk",
		"wmRButtonDown",
		"wmRButtonUp",
		"getControl",
		"findCursor",
		"SetCursor",
		"wmSetFocus",
		"sendEvent",
		"wmSysChar",
		"menuShell",
		"isEnabled",
		"getMenuItem",
		"wmCommandChild",
		"menuShell",
		"GetWindowLong",
		"menuShell",
		"getMenuBar",
		"_getFocusControl",
		"hooks",
		"hooks",
		"hooks",
		"hooks",
		"menuShell",
		"getMenuBar",
		"mbcsToWcs",
		"toUpperCase",
		"getItems",
		"getText",
		"findMnemonic",
		"length",
		"charAt",
		"toUpperCase",
		"menuShell",
		"isEnabled",
		"isActive",
		"saveFocus",
		"menuShell",
		"wmSysKeyDown",
		"wmSysKeyUp",
		"getControl",
		"wmScrollChild",
		"getShell",
		"MoveMemory",
		"GetWindowRect",
		"topHandle",
		"MapWindowPoints",
		"InvalidateRect",
		"wmXButtonDblClk",
		"wmXButtonDown",
		"wmXButtonUp",
		"defaultForeground",
		"defaultBackground",
		"SetTextColor",
		"SetBkColor",
		"findBrush",
		"TypedListener",
		"TypedListener",
		"TypedListener",
		"TypedListener",
		"TypedListener",
		"TypedListener",
		"TypedListener",
		"TypedListener",
		"TypedListener",
		"Point",
		"RECT",
		"RECT",
		"RECT",
		"Rectangle",
		"LOGFONTW",
		"LOGFONTA",
		"TCHAR",
		"RECT",
		"Point",
		"MONITORINFO",
		"Monitor",
		"RECT",
		"Point",
		"RECT",
		"POINT",
		"POINT",
		"RECT",
		"WINDOWPOS",
		"POINT",
		"POINT",
		"Point",
		"POINT",
		"Point",
		"Event",
		"Event",
		"Event",
		"DRAWITEMSTRUCT",
		"LRESULT",
		"HELPINFO",
		"MEASUREITEMSTRUCT",
		"LRESULT",
		"MENUITEMINFO",
		"LRESULT",
		"NMHDR",
		"WINDOWPOS",
		"RECT",
		"LRESULT"
	],
	"methodsBody":{
		"public void redraw(int x, int y, int width, int height, boolean all)":{
			"methodBody":"{\n    checkWidget();\n    if (width <= 0 || height <= 0)\n        return;\n    if (!OS.IsWindowVisible(handle))\n        return;\n    RECT rect = new RECT();\n    OS.SetRect(rect, x, y, x + width, y + height);\n    if (OS.IsWinCE) {\n        OS.InvalidateRect(handle, rect, true);\n    } else {\n        int flags = OS.RDW_ERASE | OS.RDW_FRAME | OS.RDW_INVALIDATE;\n        if (all)\n            flags |= OS.RDW_ALLCHILDREN;\n        OS.RedrawWindow(handle, rect, 0, flags);\n    }\n}",
			"comments":"/**\n* Causes the rectangular area of the receiver specified by\n* the arguments to be marked as needing to be redrawn.\n* The next time a paint request is processed, that area of\n* the receiver will be painted, including the background.\n* If the <code>all</code> flag is <code>true</code>, any\n* children of the receiver which intersect with the specified\n* area will also paint their intersecting areas. If the\n* <code>all</code> flag is <code>false</code>, the children\n* will not be painted.\n*\n* @param x the x coordinate of the area to draw\n* @param y the y coordinate of the area to draw\n* @param width the width of the area to draw\n* @param height the height of the area to draw\n* @param all <code>true</code> if children should redraw, and <code>false</code> otherwise\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #update\n* @see PaintListener\n* @see SWT#Paint\n* @see SWT#NO_BACKGROUND\n* @see SWT#NO_REDRAW_RESIZE\n* @see SWT#NO_MERGE_PAINTS\n*/\n",
			"methodName":"public void redraw(int x, int y, int width, int height, boolean all)"
		},
		"LRESULT WM_LBUTTONDBLCLK(int wParam, int lParam)":{
			"methodBody":"{\n    return wmLButtonDblClk(handle, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_LBUTTONDBLCLK(int wParam, int lParam)"
		},
		"boolean mnemonicHit(char key)":{
			"methodBody":"{\n    return false;\n}",
			"comments":"",
			"methodName":"boolean mnemonicHit(char key)"
		},
		"LRESULT WM_SETFOCUS(int wParam, int lParam)":{
			"methodBody":"{\n    return wmSetFocus(handle, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_SETFOCUS(int wParam, int lParam)"
		},
		"LRESULT WM_SETREDRAW(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_SETREDRAW(int wParam, int lParam)"
		},
		"public void internal_dispose_GC(int hDC, GCData data)":{
			"methodBody":"{\n    checkWidget();\n    int hwnd = handle;\n    if (data != null && data.hwnd != 0) {\n        hwnd = data.hwnd;\n    }\n    if (data == null || data.ps == null) {\n        OS.ReleaseDC(hwnd, hDC);\n    } else {\n        OS.EndPaint(hwnd, data.ps);\n    }\n}",
			"comments":"/**\n* Invokes platform specific functionality to dispose a GC handle.\n* <p>\n* <b>IMPORTANT:</b> This method is <em>not</em> part of the public\n* API for <code>Control</code>. It is marked public only so that it\n* can be shared within the packages provided by SWT. It is not\n* available on all platforms, and should never be called from\n* application code.\n* </p>\n*\n* @param hDC the platform specific GC handle\n* @param data the platform specific GC data\n*/\n",
			"methodName":"public void internal_dispose_GC(int hDC, GCData data)"
		},
		"public void setEnabled(boolean enabled)":{
			"methodBody":"{\n    checkWidget();\n    \n    Control control = null;\n    boolean fixFocus = false;\n    if (!enabled) {\n        if (display.focusEvent != SWT.FocusOut) {\n            control = display.getFocusControl();\n            fixFocus = isFocusAncestor(control);\n        }\n    }\n    enableWidget(enabled);\n    if (fixFocus)\n        fixFocus(control);\n}",
			"comments":"/**\n* Enables the receiver if the argument is <code>true</code>,\n* and disables it otherwise. A disabled control is typically\n* not selectable from the user interface and draws with an\n* inactive or \"grayed\" look.\n*\n* @param enabled the new enabled state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* Feature in Windows.  If the receiver has focus, disabling\n* the receiver causes no window to have focus.  The fix is\n* to assign focus to the first ancestor window that takes\n* focus.  If no window will take focus, set focus to the\n* desktop.\n*/\n",
			"methodName":"public void setEnabled(boolean enabled)"
		},
		"LRESULT WM_MOVE(int wParam, int lParam)":{
			"methodBody":"{\n    if (OS.COMCTL32_MAJOR >= 6 && OS.IsAppThemed()) {\n        if (OS.IsWindowVisible(handle)) {\n            if (findThemeControl() != null) {\n                int flags = OS.RDW_ERASE | OS.RDW_INVALIDATE | OS.RDW_ALLCHILDREN;\n                OS.RedrawWindow(handle, null, 0, flags);\n            }\n        }\n    }\n    sendEvent(SWT.Move);\n    \n    return null;\n}",
			"comments":"// widget could be disposed at this point\n",
			"methodName":"LRESULT WM_MOVE(int wParam, int lParam)"
		},
		"void createWidget()":{
			"methodBody":"{\n    foreground = background = -1;\n    checkOrientation(parent);\n    createHandle();\n    checkBuffered();\n    register();\n    subclass();\n    setDefaultFont();\n    checkMirrored();\n    checkBorder();\n}",
			"comments":"",
			"methodName":"void createWidget()"
		},
		"LRESULT WM_SHOWWINDOW(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_SHOWWINDOW(int wParam, int lParam)"
		},
		"GC new_GC(GCData data)":{
			"methodBody":"{\n    return GC.win32_new(this, data);\n}",
			"comments":"",
			"methodName":"GC new_GC(GCData data)"
		},
		"boolean traverseReturn()":{
			"methodBody":"{\n    return false;\n}",
			"comments":"",
			"methodName":"boolean traverseReturn()"
		},
		"void destroyWidget()":{
			"methodBody":"{\n    int hwnd = topHandle();\n    releaseHandle();\n    if (hwnd != 0) {\n        OS.DestroyWindow(hwnd);\n    }\n}",
			"comments":"",
			"methodName":"void destroyWidget()"
		},
		"void updateLayout(boolean resize, boolean all)":{
			"methodBody":"{\n\n}",
			"comments":"/* Do nothing */\n",
			"methodName":"void updateLayout(boolean resize, boolean all)"
		},
		"LRESULT WM_SIZE(int wParam, int lParam)":{
			"methodBody":"{\n    sendEvent(SWT.Resize);\n    \n    return null;\n}",
			"comments":"// widget could be disposed at this point\n",
			"methodName":"LRESULT WM_SIZE(int wParam, int lParam)"
		},
		"LRESULT WM_HOTKEY(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_HOTKEY(int wParam, int lParam)"
		},
		"public Rectangle getBounds()":{
			"methodBody":"{\n    checkWidget();\n    forceResize();\n    RECT rect = new RECT();\n    OS.GetWindowRect(topHandle(), rect);\n    int hwndParent = parent == null ? 0 : parent.handle;\n    OS.MapWindowPoints(0, hwndParent, rect, 2);\n    int width = rect.right - rect.left;\n    int height = rect.bottom - rect.top;\n    return new Rectangle(rect.left, rect.top, width, height);\n}",
			"comments":"/**\n* Returns a rectangle describing the receiver's size and location\n* relative to its parent (or its display if its parent is null),\n* unless the receiver is a shell. In this case, the location is\n* relative to the display.\n*\n* @return the receiver's bounding rectangle\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Rectangle getBounds()"
		},
		"int borderHandle()":{
			"methodBody":"{\n    return handle;\n}",
			"comments":"",
			"methodName":"int borderHandle()"
		},
		"void drawThemeBackground(int hDC, RECT rect)":{
			"methodBody":"{\n\n}",
			"comments":"/* Do nothing */\n",
			"methodName":"void drawThemeBackground(int hDC, RECT rect)"
		},
		"boolean setTabGroupFocus()":{
			"methodBody":"{\n    return setTabItemFocus();\n}",
			"comments":"",
			"methodName":"boolean setTabGroupFocus()"
		},
		"public void setFont(Font font)":{
			"methodBody":"{\n    checkWidget();\n    int hFont = 0;\n    if (font != null) {\n        if (font.isDisposed())\n            SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n        hFont = font.handle;\n    }\n    if (hFont == 0)\n        hFont = defaultFont();\n    OS.SendMessage(handle, OS.WM_SETFONT, hFont, 1);\n}",
			"comments":"/**\n* Sets the font that the receiver will use to paint textual information\n* to the font specified by the argument, or to the default font for that\n* kind of control if the argument is null.\n*\n* @param font the new font (or null)\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setFont(Font font)"
		},
		"LRESULT WM_ENTERIDLE(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_ENTERIDLE(int wParam, int lParam)"
		},
		"public boolean getVisible()":{
			"methodBody":"{\n    checkWidget();\n    if (drawCount != 0)\n        return (state & HIDDEN) == 0;\n    int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n    return (bits & OS.WS_VISIBLE) != 0;\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver is visible, and\n* <code>false</code> otherwise.\n* <p>\n* If one of the receiver's ancestors is not visible or some\n* other condition makes the receiver not visible, this method\n* may still indicate that it is considered visible even though\n* it may not actually be showing.\n* </p>\n*\n* @return the receiver's visibility state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public boolean getVisible()"
		},
		"int findBrush(int pixel)":{
			"methodBody":"{\n    return parent.findBrush(pixel);\n}",
			"comments":"",
			"methodName":"int findBrush(int pixel)"
		},
		"LRESULT WM_MOUSEWHEEL(int wParam, int lParam)":{
			"methodBody":"{\n    return wmMouseWheel(handle, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_MOUSEWHEEL(int wParam, int lParam)"
		},
		"void setBounds(int x, int y, int width, int height, int flags)":{
			"methodBody":"{\n    setBounds(x, y, width, height, flags, true);\n}",
			"comments":"",
			"methodName":"void setBounds(int x, int y, int width, int height, int flags)"
		},
		"public void addMouseTrackListener(MouseTrackListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.MouseEnter, typedListener);\n    addListener(SWT.MouseExit, typedListener);\n    addListener(SWT.MouseHover, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when the mouse passes or hovers over controls, by sending\n* it one of the messages defined in the <code>MouseTrackListener</code>\n* interface.\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see MouseTrackListener\n* @see #removeMouseTrackListener\n*/\n",
			"methodName":"public void addMouseTrackListener(MouseTrackListener listener)"
		},
		"boolean translateMnemonic(Event event, Control control)":{
			"methodBody":"{\n    if (control == this)\n        return false;\n    if (!isVisible() || !isEnabled())\n        return false;\n    event.doit = mnemonicMatch(event.character);\n    return traverse(event);\n}",
			"comments":"",
			"methodName":"boolean translateMnemonic(Event event, Control control)"
		},
		"public Color getForeground()":{
			"methodBody":"{\n    checkWidget();\n    return Color.win32_new(display, getForegroundPixel());\n}",
			"comments":"/**\n* Returns the foreground color that the receiver will use to draw.\n*\n* @return the receiver's foreground color\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Color getForeground()"
		},
		"boolean translateAccelerator(MSG msg)":{
			"methodBody":"{\n    return menuShell().translateAccelerator(msg);\n}",
			"comments":"",
			"methodName":"boolean translateAccelerator(MSG msg)"
		},
		"void update(boolean all)":{
			"methodBody":"{\n    \n    if (OS.IsWinCE) {\n        OS.UpdateWindow(handle);\n    } else {\n        int flags = OS.RDW_UPDATENOW;\n        if (all)\n            flags |= OS.RDW_ALLCHILDREN;\n        OS.RedrawWindow(handle, null, 0, flags);\n    }\n}",
			"comments":"//\tcheckWidget ();\n",
			"methodName":"void update(boolean all)"
		},
		"LRESULT WM_CONTEXTMENU(int wParam, int lParam)":{
			"methodBody":"{\n    return wmContextMenu(handle, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_CONTEXTMENU(int wParam, int lParam)"
		},
		"LRESULT WM_NCHITTEST(int wParam, int lParam)":{
			"methodBody":"{\n    if (!OS.IsWindowEnabled(handle))\n        return null;\n    if (!isActive())\n        return new LRESULT(OS.HTTRANSPARENT);\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_NCHITTEST(int wParam, int lParam)"
		},
		"Control computeTabGroup()":{
			"methodBody":"{\n    if (isTabGroup())\n        return this;\n    return parent.computeTabGroup();\n}",
			"comments":"",
			"methodName":"Control computeTabGroup()"
		},
		"void drawBackground(int hDC, RECT rect)":{
			"methodBody":"{\n    drawBackground(hDC, getBackgroundPixel(), rect);\n}",
			"comments":"",
			"methodName":"void drawBackground(int hDC, RECT rect)"
		},
		"LRESULT WM_PALETTECHANGED(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_PALETTECHANGED(int wParam, int lParam)"
		},
		"LRESULT WM_MBUTTONDBLCLK(int wParam, int lParam)":{
			"methodBody":"{\n    return wmMButtonDblClk(handle, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_MBUTTONDBLCLK(int wParam, int lParam)"
		},
		"public Composite getParent()":{
			"methodBody":"{\n    checkWidget();\n    return parent;\n}",
			"comments":"/**\n* Returns the receiver's parent, which must be a <code>Composite</code>\n* or null when the receiver is a shell that was created with null or\n* a display for a parent.\n*\n* @return the receiver's parent\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Composite getParent()"
		},
		"LRESULT WM_SETTINGCHANGE(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_SETTINGCHANGE(int wParam, int lParam)"
		},
		"int getBackgroundPixel()":{
			"methodBody":"{\n    if (background == -1)\n        return defaultBackground();\n    return background;\n}",
			"comments":"",
			"methodName":"int getBackgroundPixel()"
		},
		"public void setMenu(Menu menu)":{
			"methodBody":"{\n    checkWidget();\n    if (menu != null) {\n        if (menu.isDisposed())\n            SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n        if ((menu.style & SWT.POP_UP) == 0) {\n            error(SWT.ERROR_MENU_NOT_POP_UP);\n        }\n        if (menu.parent != menuShell()) {\n            error(SWT.ERROR_INVALID_PARENT);\n        }\n    }\n    this.menu = menu;\n}",
			"comments":"/**\n* Sets the receiver's pop up menu to the argument.\n* All controls may optionally have a pop up\n* menu that is displayed when the user requests one for\n* the control. The sequence of key strokes, button presses\n* and/or button releases that are used to request a pop up\n* menu is platform specific.\n*\n* @param menu the new pop up menu\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_MENU_NOT_POP_UP - the menu is not a pop up menu</li>\n*    <li>ERROR_INVALID_PARENT - if the menu is not in the same widget tree</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the menu has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setMenu(Menu menu)"
		},
		"boolean setRadioFocus()":{
			"methodBody":"{\n    return false;\n}",
			"comments":"",
			"methodName":"boolean setRadioFocus()"
		},
		"void markLayout(boolean changed, boolean all)":{
			"methodBody":"{\n\n}",
			"comments":"/* Do nothing */\n",
			"methodName":"void markLayout(boolean changed, boolean all)"
		},
		"LRESULT WM_WINDOWPOSCHANGING(int wParam, int lParam)":{
			"methodBody":"{\n    \n    if (drawCount != 0) {\n        Shell shell = getShell();\n        if (shell != this) {\n            WINDOWPOS lpwp = new WINDOWPOS();\n            OS.MoveMemory(lpwp, lParam, WINDOWPOS.sizeof);\n            if ((lpwp.flags & OS.SWP_NOMOVE) == 0 || (lpwp.flags & OS.SWP_NOSIZE) == 0) {\n                RECT rect = new RECT();\n                OS.GetWindowRect(topHandle(), rect);\n                int hwndParent = parent == null ? 0 : parent.handle;\n                OS.MapWindowPoints(0, hwndParent, rect, 2);\n                OS.InvalidateRect(hwndParent, rect, true);\n            }\n        }\n    }\n    return null;\n}",
			"comments":"/*\n* Bug in Windows.  When WM_SETREDRAW is used to turn off drawing\n* for a control and the control is moved or resized, Windows does\n* not redraw the area where the control once was in the parent.\n* The fix is to detect this case and redraw the area.\n*/\n",
			"methodName":"LRESULT WM_WINDOWPOSCHANGING(int wParam, int lParam)"
		},
		"void register()":{
			"methodBody":"{\n    display.addControl(handle, this);\n}",
			"comments":"",
			"methodName":"void register()"
		},
		"public boolean isReparentable()":{
			"methodBody":"{\n    checkWidget();\n    return true;\n}",
			"comments":"/**\n* Returns <code>true</code> if the underlying operating\n* system supports this reparenting, otherwise <code>false</code>\n*\n* @return <code>true</code> if the widget can be reparented, otherwise <code>false</code>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public boolean isReparentable()"
		},
		"LRESULT WM_WINDOWPOSCHANGED(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_WINDOWPOSCHANGED(int wParam, int lParam)"
		},
		"String getClipboardText()":{
			"methodBody":"{\n    String string = \"\";\n    if (OS.OpenClipboard(0)) {\n        int hMem = OS.GetClipboardData(OS.IsUnicode ? OS.CF_UNICODETEXT : OS.CF_TEXT);\n        if (hMem != 0) {\n            \n            int byteCount = OS.GlobalSize(hMem) / TCHAR.sizeof * TCHAR.sizeof;\n            int ptr = OS.GlobalLock(hMem);\n            if (ptr != 0) {\n                \n                TCHAR buffer = new TCHAR(0, byteCount / TCHAR.sizeof);\n                OS.MoveMemory(buffer, ptr, byteCount);\n                string = buffer.toString(0, buffer.strlen());\n                OS.GlobalUnlock(hMem);\n            }\n        }\n        OS.CloseClipboard();\n    }\n    return string;\n}",
			"comments":"/* Ensure byteCount is a multiple of 2 bytes on UNICODE platforms */\n/* Use the character encoding for the default locale */\n",
			"methodName":"String getClipboardText()"
		},
		"public void setBounds(Rectangle rect)":{
			"methodBody":"{\n    checkWidget();\n    if (rect == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    setBounds(rect.x, rect.y, rect.width, rect.height);\n}",
			"comments":"/**\n* Sets the receiver's size and location to the rectangular\n* area specified by the argument. The <code>x</code> and\n* <code>y</code> fields of the rectangle are relative to\n* the receiver's parent (or its display if its parent is null).\n* <p>\n* Note: Attempting to set the width or height of the\n* receiver to a negative number will cause that\n* value to be set to zero instead.\n* </p>\n*\n* @param rect the new bounds for the receiver\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setBounds(Rectangle rect)"
		},
		"LRESULT WM_RBUTTONDOWN(int wParam, int lParam)":{
			"methodBody":"{\n    return wmRButtonDown(handle, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_RBUTTONDOWN(int wParam, int lParam)"
		},
		"void setDefaultFont()":{
			"methodBody":"{\n    int hFont = display.systemFont();\n    OS.SendMessage(handle, OS.WM_SETFONT, hFont, 0);\n}",
			"comments":"",
			"methodName":"void setDefaultFont()"
		},
		"public void addPaintListener(PaintListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.Paint, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when the receiver needs to be painted, by sending it\n* one of the messages defined in the <code>PaintListener</code>\n* interface.\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see PaintListener\n* @see #removePaintListener\n*/\n",
			"methodName":"public void addPaintListener(PaintListener listener)"
		},
		"LRESULT WM_DESTROY(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_DESTROY(int wParam, int lParam)"
		},
		"LRESULT WM_MENUCHAR(int wParam, int lParam)":{
			"methodBody":"{\n    \n    int type = wParam >> 16;\n    if (type == 0 || type == OS.MF_SYSMENU) {\n        display.mnemonicKeyHit = false;\n        return new LRESULT(OS.MNC_CLOSE << 16);\n    }\n    return null;\n}",
			"comments":"/*\n* Feature in Windows.  When the user types Alt+<key>\n* and <key> does not match a mnemonic in the System\n* menu or the menu bar, Windows beeps.  This beep is\n* unexpected and unwanted by applications that look\n* for Alt+<key>.  The fix is to detect the case and\n* stop Windows from beeping by closing the menu.\n*/\n",
			"methodName":"LRESULT WM_MENUCHAR(int wParam, int lParam)"
		},
		"void fixFocus(Control focusControl)":{
			"methodBody":"{\n    Shell shell = getShell();\n    Control control = this;\n    while (control != shell && (control = control.parent) != null) {\n        if (control.setFixedFocus())\n            return;\n    }\n    shell.setSavedFocus(focusControl);\n    OS.SetFocus(0);\n}",
			"comments":"",
			"methodName":"void fixFocus(Control focusControl)"
		},
		"LRESULT WM_NCCALCSIZE(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_NCCALCSIZE(int wParam, int lParam)"
		},
		"public String getToolTipText()":{
			"methodBody":"{\n    checkWidget();\n    return toolTipText;\n}",
			"comments":"/**\n* Returns the receiver's tool tip text, or null if it has\n* not been set.\n*\n* @return the receiver's tool tip text\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public String getToolTipText()"
		},
		"void fixChildren(Shell newShell, Shell oldShell, Decorations newDecorations, Decorations oldDecorations, Menu[] menus)":{
			"methodBody":"{\n    oldShell.fixShell(newShell, this);\n    oldDecorations.fixDecorations(newDecorations, this, menus);\n}",
			"comments":"",
			"methodName":"void fixChildren(Shell newShell, Shell oldShell, Decorations newDecorations, Decorations oldDecorations, Menu[] menus)"
		},
		"LRESULT WM_CLOSE(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_CLOSE(int wParam, int lParam)"
		},
		"public Point toControl(Point point)":{
			"methodBody":"{\n    checkWidget();\n    if (point == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    return toControl(point.x, point.y);\n}",
			"comments":"/**\n* Returns a point which is the result of converting the\n* argument, which is specified in display relative coordinates,\n* to coordinates relative to the receiver.\n* <p>\n* @param point the point to be translated (must not be null)\n* @return the translated coordinates\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the point is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Point toControl(Point point)"
		},
		"public Object getLayoutData()":{
			"methodBody":"{\n    checkWidget();\n    return layoutData;\n}",
			"comments":"/**\n* Returns layout data which is associated with the receiver.\n*\n* @return the receiver's layout data\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Object getLayoutData()"
		},
		"public void removeKeyListener(KeyListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.KeyUp, listener);\n    eventTable.unhook(SWT.KeyDown, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when keys are pressed and released on the system keyboard.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see KeyListener\n* @see #addKeyListener\n*/\n",
			"methodName":"public void removeKeyListener(KeyListener listener)"
		},
		"boolean traversePage(boolean next)":{
			"methodBody":"{\n    return false;\n}",
			"comments":"",
			"methodName":"boolean traversePage(boolean next)"
		},
		"int windowProc(int hwnd, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = null;\n    switch(msg) {\n        case OS.WM_ACTIVATE:\n            result = WM_ACTIVATE(wParam, lParam);\n            break;\n        case OS.WM_CAPTURECHANGED:\n            result = WM_CAPTURECHANGED(wParam, lParam);\n            break;\n        case OS.WM_CHAR:\n            result = WM_CHAR(wParam, lParam);\n            break;\n        case OS.WM_CLEAR:\n            result = WM_CLEAR(wParam, lParam);\n            break;\n        case OS.WM_CLOSE:\n            result = WM_CLOSE(wParam, lParam);\n            break;\n        case OS.WM_COMMAND:\n            result = WM_COMMAND(wParam, lParam);\n            break;\n        case OS.WM_CONTEXTMENU:\n            result = WM_CONTEXTMENU(wParam, lParam);\n            break;\n        case OS.WM_CTLCOLORBTN:\n        case OS.WM_CTLCOLORDLG:\n        case OS.WM_CTLCOLOREDIT:\n        case OS.WM_CTLCOLORLISTBOX:\n        case OS.WM_CTLCOLORMSGBOX:\n        case OS.WM_CTLCOLORSCROLLBAR:\n        case OS.WM_CTLCOLORSTATIC:\n            result = WM_CTLCOLOR(wParam, lParam);\n            break;\n        case OS.WM_CUT:\n            result = WM_CUT(wParam, lParam);\n            break;\n        case OS.WM_DESTROY:\n            result = WM_DESTROY(wParam, lParam);\n            break;\n        case OS.WM_DRAWITEM:\n            result = WM_DRAWITEM(wParam, lParam);\n            break;\n        case OS.WM_ENDSESSION:\n            result = WM_ENDSESSION(wParam, lParam);\n            break;\n        case OS.WM_ENTERIDLE:\n            result = WM_ENTERIDLE(wParam, lParam);\n            break;\n        case OS.WM_ERASEBKGND:\n            result = WM_ERASEBKGND(wParam, lParam);\n            break;\n        case OS.WM_GETDLGCODE:\n            result = WM_GETDLGCODE(wParam, lParam);\n            break;\n        case OS.WM_GETFONT:\n            result = WM_GETFONT(wParam, lParam);\n            break;\n        case OS.WM_GETOBJECT:\n            result = WM_GETOBJECT(wParam, lParam);\n            break;\n        case OS.WM_GETMINMAXINFO:\n            result = WM_GETMINMAXINFO(wParam, lParam);\n            break;\n        case OS.WM_HELP:\n            result = WM_HELP(wParam, lParam);\n            break;\n        case OS.WM_HSCROLL:\n            result = WM_HSCROLL(wParam, lParam);\n            break;\n        case OS.WM_IME_CHAR:\n            result = WM_IME_CHAR(wParam, lParam);\n            break;\n        case OS.WM_IME_COMPOSITION:\n            result = WM_IME_COMPOSITION(wParam, lParam);\n            break;\n        case OS.WM_INITMENUPOPUP:\n            result = WM_INITMENUPOPUP(wParam, lParam);\n            break;\n        case OS.WM_INPUTLANGCHANGE:\n            result = WM_INPUTLANGCHANGE(wParam, lParam);\n            break;\n        case OS.WM_HOTKEY:\n            result = WM_HOTKEY(wParam, lParam);\n            break;\n        case OS.WM_KEYDOWN:\n            result = WM_KEYDOWN(wParam, lParam);\n            break;\n        case OS.WM_KEYUP:\n            result = WM_KEYUP(wParam, lParam);\n            break;\n        case OS.WM_KILLFOCUS:\n            result = WM_KILLFOCUS(wParam, lParam);\n            break;\n        case OS.WM_LBUTTONDBLCLK:\n            result = WM_LBUTTONDBLCLK(wParam, lParam);\n            break;\n        case OS.WM_LBUTTONDOWN:\n            result = WM_LBUTTONDOWN(wParam, lParam);\n            break;\n        case OS.WM_LBUTTONUP:\n            result = WM_LBUTTONUP(wParam, lParam);\n            break;\n        case OS.WM_MBUTTONDBLCLK:\n            result = WM_MBUTTONDBLCLK(wParam, lParam);\n            break;\n        case OS.WM_MBUTTONDOWN:\n            result = WM_MBUTTONDOWN(wParam, lParam);\n            break;\n        case OS.WM_MBUTTONUP:\n            result = WM_MBUTTONUP(wParam, lParam);\n            break;\n        case OS.WM_MEASUREITEM:\n            result = WM_MEASUREITEM(wParam, lParam);\n            break;\n        case OS.WM_MENUCHAR:\n            result = WM_MENUCHAR(wParam, lParam);\n            break;\n        case OS.WM_MENUSELECT:\n            result = WM_MENUSELECT(wParam, lParam);\n            break;\n        case OS.WM_MOUSEACTIVATE:\n            result = WM_MOUSEACTIVATE(wParam, lParam);\n            break;\n        case OS.WM_MOUSEHOVER:\n            result = WM_MOUSEHOVER(wParam, lParam);\n            break;\n        case OS.WM_MOUSELEAVE:\n            result = WM_MOUSELEAVE(wParam, lParam);\n            break;\n        case OS.WM_MOUSEMOVE:\n            result = WM_MOUSEMOVE(wParam, lParam);\n            break;\n        case OS.WM_MOUSEWHEEL:\n            result = WM_MOUSEWHEEL(wParam, lParam);\n            break;\n        case OS.WM_MOVE:\n            result = WM_MOVE(wParam, lParam);\n            break;\n        case OS.WM_NCACTIVATE:\n            result = WM_NCACTIVATE(wParam, lParam);\n            break;\n        case OS.WM_NCCALCSIZE:\n            result = WM_NCCALCSIZE(wParam, lParam);\n            break;\n        case OS.WM_NCHITTEST:\n            result = WM_NCHITTEST(wParam, lParam);\n            break;\n        case OS.WM_NCLBUTTONDOWN:\n            result = WM_NCLBUTTONDOWN(wParam, lParam);\n            break;\n        case OS.WM_NOTIFY:\n            result = WM_NOTIFY(wParam, lParam);\n            break;\n        case OS.WM_PAINT:\n            result = WM_PAINT(wParam, lParam);\n            break;\n        case OS.WM_PALETTECHANGED:\n            result = WM_PALETTECHANGED(wParam, lParam);\n            break;\n        case OS.WM_PARENTNOTIFY:\n            result = WM_PARENTNOTIFY(wParam, lParam);\n            break;\n        case OS.WM_PASTE:\n            result = WM_PASTE(wParam, lParam);\n            break;\n        case OS.WM_PRINTCLIENT:\n            result = WM_PRINTCLIENT(wParam, lParam);\n            break;\n        case OS.WM_QUERYENDSESSION:\n            result = WM_QUERYENDSESSION(wParam, lParam);\n            break;\n        case OS.WM_QUERYNEWPALETTE:\n            result = WM_QUERYNEWPALETTE(wParam, lParam);\n            break;\n        case OS.WM_QUERYOPEN:\n            result = WM_QUERYOPEN(wParam, lParam);\n            break;\n        case OS.WM_RBUTTONDBLCLK:\n            result = WM_RBUTTONDBLCLK(wParam, lParam);\n            break;\n        case OS.WM_RBUTTONDOWN:\n            result = WM_RBUTTONDOWN(wParam, lParam);\n            break;\n        case OS.WM_RBUTTONUP:\n            result = WM_RBUTTONUP(wParam, lParam);\n            break;\n        case OS.WM_SETCURSOR:\n            result = WM_SETCURSOR(wParam, lParam);\n            break;\n        case OS.WM_SETFOCUS:\n            result = WM_SETFOCUS(wParam, lParam);\n            break;\n        case OS.WM_SETFONT:\n            result = WM_SETFONT(wParam, lParam);\n            break;\n        case OS.WM_SETTINGCHANGE:\n            result = WM_SETTINGCHANGE(wParam, lParam);\n            break;\n        case OS.WM_SETREDRAW:\n            result = WM_SETREDRAW(wParam, lParam);\n            break;\n        case OS.WM_SHOWWINDOW:\n            result = WM_SHOWWINDOW(wParam, lParam);\n            break;\n        case OS.WM_SIZE:\n            result = WM_SIZE(wParam, lParam);\n            break;\n        case OS.WM_SYSCHAR:\n            result = WM_SYSCHAR(wParam, lParam);\n            break;\n        case OS.WM_SYSCOLORCHANGE:\n            result = WM_SYSCOLORCHANGE(wParam, lParam);\n            break;\n        case OS.WM_SYSCOMMAND:\n            result = WM_SYSCOMMAND(wParam, lParam);\n            break;\n        case OS.WM_SYSKEYDOWN:\n            result = WM_SYSKEYDOWN(wParam, lParam);\n            break;\n        case OS.WM_SYSKEYUP:\n            result = WM_SYSKEYUP(wParam, lParam);\n            break;\n        case OS.WM_TIMER:\n            result = WM_TIMER(wParam, lParam);\n            break;\n        case OS.WM_UNDO:\n            result = WM_UNDO(wParam, lParam);\n            break;\n        case OS.WM_VSCROLL:\n            result = WM_VSCROLL(wParam, lParam);\n            break;\n        case OS.WM_WINDOWPOSCHANGED:\n            result = WM_WINDOWPOSCHANGED(wParam, lParam);\n            break;\n        case OS.WM_WINDOWPOSCHANGING:\n            result = WM_WINDOWPOSCHANGING(wParam, lParam);\n            break;\n        case OS.WM_XBUTTONDBLCLK:\n            result = WM_XBUTTONDBLCLK(wParam, lParam);\n            break;\n        case OS.WM_XBUTTONDOWN:\n            result = WM_XBUTTONDOWN(wParam, lParam);\n            break;\n        case OS.WM_XBUTTONUP:\n            result = WM_XBUTTONUP(wParam, lParam);\n            break;\n    }\n    if (result != null)\n        return result.value;\n    return callWindowProc(hwnd, msg, wParam, lParam);\n}",
			"comments":"",
			"methodName":"int windowProc(int hwnd, int msg, int wParam, int lParam)"
		},
		"public void addKeyListener(KeyListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.KeyUp, typedListener);\n    addListener(SWT.KeyDown, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when keys are pressed and released on the system keyboard, by sending\n* it one of the messages defined in the <code>KeyListener</code>\n* interface.\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see KeyListener\n* @see #removeKeyListener\n*/\n",
			"methodName":"public void addKeyListener(KeyListener listener)"
		},
		"LRESULT WM_KEYUP(int wParam, int lParam)":{
			"methodBody":"{\n    return wmKeyUp(handle, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_KEYUP(int wParam, int lParam)"
		},
		"LRESULT WM_SYSKEYDOWN(int wParam, int lParam)":{
			"methodBody":"{\n    return wmSysKeyDown(handle, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_SYSKEYDOWN(int wParam, int lParam)"
		},
		"public void removeFocusListener(FocusListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.FocusIn, listener);\n    eventTable.unhook(SWT.FocusOut, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when the control gains or loses focus.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see FocusListener\n* @see #addFocusListener\n*/\n",
			"methodName":"public void removeFocusListener(FocusListener listener)"
		},
		"LRESULT WM_TIMER(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_TIMER(int wParam, int lParam)"
		},
		"LRESULT wmCommandChild(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT wmCommandChild(int wParam, int lParam)"
		},
		"void mapEvent(int hwnd, Event event)":{
			"methodBody":"{\n    if (hwnd != handle) {\n        POINT point = new POINT();\n        point.x = event.x;\n        point.y = event.y;\n        OS.MapWindowPoints(hwnd, handle, point, 1);\n        event.x = point.x;\n        event.y = point.y;\n    }\n}",
			"comments":"",
			"methodName":"void mapEvent(int hwnd, Event event)"
		},
		"LRESULT WM_VSCROLL(int wParam, int lParam)":{
			"methodBody":"{\n    if (lParam == 0)\n        return null;\n    Control control = display.getControl(lParam);\n    if (control == null)\n        return null;\n    return control.wmScrollChild(wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_VSCROLL(int wParam, int lParam)"
		},
		"public void setForeground(Color color)":{
			"methodBody":"{\n    checkWidget();\n    int pixel = -1;\n    if (color != null) {\n        if (color.isDisposed())\n            SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n        pixel = color.handle;\n    }\n    setForegroundPixel(pixel);\n}",
			"comments":"/**\n* Sets the receiver's foreground color to the color specified\n* by the argument, or to the default system color for the control\n* if the argument is null.\n*\n* @param color the new color (or null)\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setForeground(Color color)"
		},
		"int widgetParent()":{
			"methodBody":"{\n    return parent.handle;\n}",
			"comments":"",
			"methodName":"int widgetParent()"
		},
		"public boolean traverse(int traversal)":{
			"methodBody":"{\n    checkWidget();\n    Event event = new Event();\n    event.doit = true;\n    event.detail = traversal;\n    return traverse(event);\n}",
			"comments":"/**\n* Based on the argument, perform one of the expected platform\n* traversal action. The argument should be one of the constants:\n* <code>SWT.TRAVERSE_ESCAPE</code>, <code>SWT.TRAVERSE_RETURN</code>,\n* <code>SWT.TRAVERSE_TAB_NEXT</code>, <code>SWT.TRAVERSE_TAB_PREVIOUS</code>,\n* <code>SWT.TRAVERSE_ARROW_NEXT</code> and <code>SWT.TRAVERSE_ARROW_PREVIOUS</code>.\n*\n* @param traversal the type of traversal\n* @return true if the traversal succeeded\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public boolean traverse(int traversal)"
		},
		"void checkBorder()":{
			"methodBody":"{\n    if (getBorderWidth() == 0)\n        style &= ~SWT.BORDER;\n}",
			"comments":"",
			"methodName":"void checkBorder()"
		},
		"int defaultBackground()":{
			"methodBody":"{\n    if (OS.IsWinCE)\n        return OS.GetSysColor(OS.COLOR_WINDOW);\n    return OS.GetSysColor(OS.COLOR_BTNFACE);\n}",
			"comments":"",
			"methodName":"int defaultBackground()"
		},
		"LRESULT WM_PARENTNOTIFY(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_PARENTNOTIFY(int wParam, int lParam)"
		},
		"public void addHelpListener(HelpListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.Help, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when help events are generated for the control,\n* by sending it one of the messages defined in the\n* <code>HelpListener</code> interface.\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see HelpListener\n* @see #removeHelpListener\n*/\n",
			"methodName":"public void addHelpListener(HelpListener listener)"
		},
		"boolean setRadioSelection(boolean value)":{
			"methodBody":"{\n    return false;\n}",
			"comments":"",
			"methodName":"boolean setRadioSelection(boolean value)"
		},
		"LRESULT WM_CHAR(int wParam, int lParam)":{
			"methodBody":"{\n    return wmChar(handle, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_CHAR(int wParam, int lParam)"
		},
		"LRESULT WM_PAINT(int wParam, int lParam)":{
			"methodBody":"{\n    return super.wmPaint(handle, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_PAINT(int wParam, int lParam)"
		},
		"public Point getSize()":{
			"methodBody":"{\n    checkWidget();\n    forceResize();\n    RECT rect = new RECT();\n    OS.GetWindowRect(topHandle(), rect);\n    int width = rect.right - rect.left;\n    int height = rect.bottom - rect.top;\n    return new Point(width, height);\n}",
			"comments":"/**\n* Returns a point describing the receiver's size. The\n* x coordinate of the result is the width of the receiver.\n* The y coordinate of the result is the height of the\n* receiver.\n*\n* @return the receiver's size\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Point getSize()"
		},
		"public void addControlListener(ControlListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.Resize, typedListener);\n    addListener(SWT.Move, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when the control is moved or resized, by sending\n* it one of the messages defined in the <code>ControlListener</code>\n* interface.\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see ControlListener\n* @see #removeControlListener\n*/\n",
			"methodName":"public void addControlListener(ControlListener listener)"
		},
		"LRESULT WM_PASTE(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_PASTE(int wParam, int lParam)"
		},
		"public void addFocusListener(FocusListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.FocusIn, typedListener);\n    addListener(SWT.FocusOut, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when the control gains or loses focus, by sending\n* it one of the messages defined in the <code>FocusListener</code>\n* interface.\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see FocusListener\n* @see #removeFocusListener\n*/\n",
			"methodName":"public void addFocusListener(FocusListener listener)"
		},
		"void createHandle()":{
			"methodBody":"{\n    int hwndParent = widgetParent();\n    handle = OS.CreateWindowEx(widgetExtStyle(), windowClass(), null, widgetStyle(), OS.CW_USEDEFAULT, 0, OS.CW_USEDEFAULT, 0, hwndParent, 0, OS.GetModuleHandle(null), widgetCreateStruct());\n    if (handle == 0)\n        error(SWT.ERROR_NO_HANDLES);\n    int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n    if ((bits & OS.WS_CHILD) != 0) {\n        OS.SetWindowLong(handle, OS.GWL_ID, handle);\n    }\n    if (OS.IsDBLocale && hwndParent != 0) {\n        int hIMC = OS.ImmGetContext(hwndParent);\n        OS.ImmAssociateContext(handle, hIMC);\n        OS.ImmReleaseContext(hwndParent, hIMC);\n    }\n}",
			"comments":"",
			"methodName":"void createHandle()"
		},
		"LRESULT WM_DRAWITEM(int wParam, int lParam)":{
			"methodBody":"{\n    DRAWITEMSTRUCT struct = new DRAWITEMSTRUCT();\n    OS.MoveMemory(struct, lParam, DRAWITEMSTRUCT.sizeof);\n    if (struct.CtlType == OS.ODT_MENU) {\n        MenuItem item = display.getMenuItem(struct.itemID);\n        if (item == null)\n            return null;\n        return item.wmDrawChild(wParam, lParam);\n    }\n    Control control = display.getControl(struct.hwndItem);\n    if (control == null)\n        return null;\n    return control.wmDrawChild(wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_DRAWITEM(int wParam, int lParam)"
		},
		"public Accessible getAccessible()":{
			"methodBody":"{\n    checkWidget();\n    if (accessible == null)\n        accessible = new_Accessible(this);\n    return accessible;\n}",
			"comments":"/**\n* Returns the accessible object for the receiver.\n* If this is the first time this object is requested,\n* then the object is created and returned.\n*\n* @return the accessible object\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see Accessible#addAccessibleListener\n* @see Accessible#addAccessibleControlListener\n*\n* @since 2.0\n*/\n",
			"methodName":"public Accessible getAccessible()"
		},
		"public void removeMouseListener(MouseListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.MouseDown, listener);\n    eventTable.unhook(SWT.MouseUp, listener);\n    eventTable.unhook(SWT.MouseDoubleClick, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when mouse buttons are pressed and released.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see MouseListener\n* @see #addMouseListener\n*/\n",
			"methodName":"public void removeMouseListener(MouseListener listener)"
		},
		"LRESULT WM_GETDLGCODE(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_GETDLGCODE(int wParam, int lParam)"
		},
		"public void removePaintListener(PaintListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.Paint, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when the receiver needs to be painted.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see PaintListener\n* @see #addPaintListener\n*/\n",
			"methodName":"public void removePaintListener(PaintListener listener)"
		},
		"void releaseChild()":{
			"methodBody":"{\n    parent.removeControl(this);\n}",
			"comments":"",
			"methodName":"void releaseChild()"
		},
		"public boolean setParent(Composite parent)":{
			"methodBody":"{\n    checkWidget();\n    if (parent == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (parent.isDisposed())\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    if (this.parent == parent)\n        return true;\n    if (!isReparentable())\n        return false;\n    releaseChild();\n    Shell newShell = parent.getShell(), oldShell = getShell();\n    Decorations newDecorations = parent.menuShell(), oldDecorations = menuShell();\n    if (oldShell != newShell || oldDecorations != newDecorations) {\n        Menu[] menus = oldShell.findMenus(this);\n        fixChildren(newShell, oldShell, newDecorations, oldDecorations, menus);\n    }\n    int topHandle = topHandle();\n    if (OS.SetParent(topHandle, parent.handle) == 0)\n        return false;\n    this.parent = parent;\n    int flags = OS.SWP_NOSIZE | OS.SWP_NOMOVE | OS.SWP_NOACTIVATE;\n    SetWindowPos(topHandle, OS.HWND_BOTTOM, 0, 0, 0, 0, flags);\n    return true;\n}",
			"comments":"/**\n* Changes the parent of the widget to be the one provided if\n* the underlying operating system supports this feature.\n* Answers <code>true</code> if the parent is successfully changed.\n*\n* @param parent the new parent for the control.\n* @return <code>true</code> if the parent is changed and <code>false</code> otherwise.\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li>\n*    <li>ERROR_NULL_ARGUMENT - if the parent is <code>null</code></li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*\t</ul>\n*/\n",
			"methodName":"public boolean setParent(Composite parent)"
		},
		"int widgetStyle()":{
			"methodBody":"{\n    \n    int bits = OS.WS_CHILD | OS.WS_VISIBLE | OS.WS_CLIPSIBLINGS;\n    \n    if (OS.IsPPC) {\n        if ((style & SWT.BORDER) != 0)\n            bits |= OS.WS_BORDER;\n    }\n    return bits;\n\n\n\n\n\n}",
			"comments":"/* Force clipping of siblings by setting WS_CLIPSIBLINGS */\n//\tif ((style & SWT.BORDER) != 0) {\n//\t\tif ((style & SWT.FLAT) != 0) bits |= OS.WS_BORDER;\n//\t}\n/*\n* This code is intentionally commented.  When clipping\n* of both siblings and children is not enforced, it is\n* possible for application code to draw outside of the\n* control.\n*/\n//\tint bits = OS.WS_CHILD | OS.WS_VISIBLE;\n//\tif ((style & SWT.CLIP_SIBLINGS) != 0) bits |= OS.WS_CLIPSIBLINGS;\n//\tif ((style & SWT.CLIP_CHILDREN) != 0) bits |= OS.WS_CLIPCHILDREN;\n//\treturn bits;\n",
			"methodName":"int widgetStyle()"
		},
		"public Shell getShell()":{
			"methodBody":"{\n    checkWidget();\n    return parent.getShell();\n}",
			"comments":"/**\n* Returns the receiver's shell. For all controls other than\n* shells, this simply returns the control's nearest ancestor\n* shell. Shells return themselves, even if they are children\n* of other shells.\n*\n* @return the receiver's shell\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #getParent\n*/\n",
			"methodName":"public Shell getShell()"
		},
		"public void setToolTipText(String string)":{
			"methodBody":"{\n    checkWidget();\n    Shell shell = getShell();\n    shell.setToolTipText(handle, toolTipText = string);\n}",
			"comments":"/**\n* Sets the receiver's tool tip text to the argument, which\n* may be null indicating that no tool tip text should be shown.\n*\n* @param string the new tool tip text (or null)\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setToolTipText(String string)"
		},
		"public Point toControl(int x, int y)":{
			"methodBody":"{\n    checkWidget();\n    POINT pt = new POINT();\n    pt.x = x;\n    pt.y = y;\n    OS.ScreenToClient(handle, pt);\n    return new Point(pt.x, pt.y);\n}",
			"comments":"/**\n* Returns a point which is the result of converting the\n* argument, which is specified in display relative coordinates,\n* to coordinates relative to the receiver.\n* <p>\n* @param x the x coordinate to be translated\n* @param y the y coordinate to be translated\n* @return the translated coordinates\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 2.1\n*/\n",
			"methodName":"public Point toControl(int x, int y)"
		},
		"boolean mnemonicMatch(char key)":{
			"methodBody":"{\n    return false;\n}",
			"comments":"",
			"methodName":"boolean mnemonicMatch(char key)"
		},
		"Accessible new_Accessible(Control control)":{
			"methodBody":"{\n    return Accessible.internal_new_Accessible(this);\n}",
			"comments":"",
			"methodName":"Accessible new_Accessible(Control control)"
		},
		"boolean traverse(Event event)":{
			"methodBody":"{\n    \n    sendEvent(SWT.Traverse, event);\n    if (isDisposed())\n        return true;\n    if (!event.doit)\n        return false;\n    switch(event.detail) {\n        case SWT.TRAVERSE_NONE:\n            return true;\n        case SWT.TRAVERSE_ESCAPE:\n            return traverseEscape();\n        case SWT.TRAVERSE_RETURN:\n            return traverseReturn();\n        case SWT.TRAVERSE_TAB_NEXT:\n            return traverseGroup(true);\n        case SWT.TRAVERSE_TAB_PREVIOUS:\n            return traverseGroup(false);\n        case SWT.TRAVERSE_ARROW_NEXT:\n            return traverseItem(true);\n        case SWT.TRAVERSE_ARROW_PREVIOUS:\n            return traverseItem(false);\n        case SWT.TRAVERSE_MNEMONIC:\n            return traverseMnemonic(event.character);\n        case SWT.TRAVERSE_PAGE_NEXT:\n            return traversePage(true);\n        case SWT.TRAVERSE_PAGE_PREVIOUS:\n            return traversePage(false);\n    }\n    return false;\n}",
			"comments":"/*\n* It is possible (but unlikely), that application\n* code could have disposed the widget in the traverse\n* event.  If this happens, return true to stop further\n* event processing.\n*/\n",
			"methodName":"boolean traverse(Event event)"
		},
		"public void pack()":{
			"methodBody":"{\n    checkWidget();\n    pack(true);\n}",
			"comments":"/**\n* Causes the receiver to be resized to its preferred size.\n* For a composite, this involves computing the preferred size\n* from its layout, if there is one.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #computeSize(int, int, boolean)\n*/\n",
			"methodName":"public void pack()"
		},
		"void unsubclass()":{
			"methodBody":"{\n    int newProc = windowProc();\n    int oldProc = display.windowProc;\n    if (oldProc == newProc)\n        return;\n    OS.SetWindowLong(handle, OS.GWL_WNDPROC, newProc);\n}",
			"comments":"",
			"methodName":"void unsubclass()"
		},
		"boolean sendFocusEvent(int type)":{
			"methodBody":"{\n    Shell shell = getShell();\n    \n    Display display = this.display;\n    display.focusEvent = type;\n    display.focusControl = this;\n    sendEvent(type);\n    \n    display.focusEvent = SWT.None;\n    display.focusControl = null;\n    \n    if (!shell.isDisposed()) {\n        switch(type) {\n            case SWT.FocusIn:\n                shell.setActiveControl(this);\n                break;\n            case SWT.FocusOut:\n                if (shell != display.getActiveShell()) {\n                    shell.setActiveControl(null);\n                }\n                break;\n        }\n    }\n    return true;\n}",
			"comments":"/*\n* Feature in Windows.  During the processing of WM_KILLFOCUS,\n* when the focus window is queried using GetFocus(), it has\n* already been assigned to the new window.  The fix is to\n* remember the control that is losing or gaining focus and\n* answer it during WM_KILLFOCUS.  If a WM_SETFOCUS occurs\n* during WM_KILLFOCUS, the focus control needs to be updated\n* to the current control.  At any other time, the focus\n* control matches Windows.\n*/\n// widget could be disposed at this point\n/*\n* It is possible that the shell may be\n* disposed at this point.  If this happens\n* don't send the activate and deactivate\n* events.\n*/\n",
			"methodName":"boolean sendFocusEvent(int type)"
		},
		"int getForegroundPixel()":{
			"methodBody":"{\n    if (foreground == -1)\n        return defaultForeground();\n    return foreground;\n}",
			"comments":"",
			"methodName":"int getForegroundPixel()"
		},
		"LRESULT WM_SYSCHAR(int wParam, int lParam)":{
			"methodBody":"{\n    return wmSysChar(handle, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_SYSCHAR(int wParam, int lParam)"
		},
		"LRESULT wmColorChild(int wParam, int lParam)":{
			"methodBody":"{\n    if (background == -1 && foreground == -1)\n        return null;\n    int forePixel = foreground, backPixel = background;\n    if (forePixel == -1)\n        forePixel = defaultForeground();\n    if (backPixel == -1)\n        backPixel = defaultBackground();\n    OS.SetTextColor(wParam, forePixel);\n    OS.SetBkColor(wParam, backPixel);\n    return new LRESULT(findBrush(backPixel));\n}",
			"comments":"",
			"methodName":"LRESULT wmColorChild(int wParam, int lParam)"
		},
		"boolean setFixedFocus()":{
			"methodBody":"{\n    if ((style & SWT.NO_FOCUS) != 0)\n        return false;\n    return forceFocus();\n}",
			"comments":"",
			"methodName":"boolean setFixedFocus()"
		},
		"LRESULT WM_NCLBUTTONDOWN(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_NCLBUTTONDOWN(int wParam, int lParam)"
		},
		"LRESULT WM_GETFONT(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_GETFONT(int wParam, int lParam)"
		},
		"LRESULT WM_CAPTURECHANGED(int wParam, int lParam)":{
			"methodBody":"{\n    return wmCaptureChanged(handle, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_CAPTURECHANGED(int wParam, int lParam)"
		},
		"void releaseHandle()":{
			"methodBody":"{\n    super.releaseHandle();\n    handle = 0;\n}",
			"comments":"",
			"methodName":"void releaseHandle()"
		},
		"Cursor findCursor()":{
			"methodBody":"{\n    if (cursor != null)\n        return cursor;\n    return parent.findCursor();\n}",
			"comments":"",
			"methodName":"Cursor findCursor()"
		},
		"LRESULT WM_PRINTCLIENT(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_PRINTCLIENT(int wParam, int lParam)"
		},
		"boolean isTabItem()":{
			"methodBody":"{\n    Control[] tabList = parent._getTabList();\n    if (tabList != null) {\n        for (int i = 0; i < tabList.length; i++) {\n            if (tabList[i] == this)\n                return false;\n        }\n    }\n    int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n    if ((bits & OS.WS_TABSTOP) != 0)\n        return false;\n    int code = OS.SendMessage(handle, OS.WM_GETDLGCODE, 0, 0);\n    if ((code & OS.DLGC_STATIC) != 0)\n        return false;\n    if ((code & OS.DLGC_WANTALLKEYS) != 0)\n        return false;\n    if ((code & OS.DLGC_WANTARROWS) != 0)\n        return false;\n    if ((code & OS.DLGC_WANTTAB) != 0)\n        return false;\n    return true;\n}",
			"comments":"",
			"methodName":"boolean isTabItem()"
		},
		"LRESULT WM_IME_CHAR(int wParam, int lParam)":{
			"methodBody":"{\n    return wmIMEChar(handle, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_IME_CHAR(int wParam, int lParam)"
		},
		"LRESULT WM_SETCURSOR(int wParam, int lParam)":{
			"methodBody":"{\n    int hitTest = (short) (lParam & 0xFFFF);\n    if (hitTest == OS.HTCLIENT) {\n        Control control = display.getControl(wParam);\n        if (control == null)\n            return null;\n        Cursor cursor = control.findCursor();\n        if (cursor != null) {\n            OS.SetCursor(cursor.handle);\n            return LRESULT.ONE;\n        }\n    }\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_SETCURSOR(int wParam, int lParam)"
		},
		"void showWidget(boolean visible)":{
			"methodBody":"{\n    OS.ShowWindow(handle, visible ? OS.SW_SHOW : OS.SW_HIDE);\n}",
			"comments":"",
			"methodName":"void showWidget(boolean visible)"
		},
		"LRESULT WM_SYSCOMMAND(int wParam, int lParam)":{
			"methodBody":"{\n    \n    if ((wParam & 0xF000) == 0) {\n        Decorations shell = menuShell();\n        if (shell.isEnabled()) {\n            MenuItem item = display.getMenuItem(wParam & 0xFFFF);\n            if (item != null)\n                item.wmCommandChild(wParam, lParam);\n        }\n        return LRESULT.ZERO;\n    }\n    \n    int cmd = wParam & 0xFFF0;\n    switch(cmd) {\n        case OS.SC_CLOSE:\n            int hwndShell = menuShell().handle;\n            int bits = OS.GetWindowLong(hwndShell, OS.GWL_STYLE);\n            if ((bits & OS.WS_SYSMENU) == 0)\n                return LRESULT.ZERO;\n            break;\n        case OS.SC_KEYMENU:\n            \n            if (lParam == 0) {\n                Decorations shell = menuShell();\n                Menu menu = shell.getMenuBar();\n                if (menu == null) {\n                    Control control = display._getFocusControl();\n                    if (control != null) {\n                        if (control.hooks(SWT.KeyDown) || control.hooks(SWT.KeyUp)) {\n                            display.mnemonicKeyHit = false;\n                            return LRESULT.ZERO;\n                        }\n                    }\n                }\n            } else {\n                \n                if (hooks(SWT.KeyDown) || hooks(SWT.KeyUp)) {\n                    if (lParam != ' ') {\n                        Decorations shell = menuShell();\n                        Menu menu = shell.getMenuBar();\n                        if (menu != null) {\n                            char key = Display.mbcsToWcs(lParam);\n                            if (key != 0) {\n                                key = Character.toUpperCase(key);\n                                MenuItem[] items = menu.getItems();\n                                for (int i = 0; i < items.length; i++) {\n                                    MenuItem item = items[i];\n                                    String text = item.getText();\n                                    char mnemonic = findMnemonic(text);\n                                    if (text.length() > 0 && mnemonic == 0) {\n                                        char ch = text.charAt(0);\n                                        if (Character.toUpperCase(ch) == key) {\n                                            display.mnemonicKeyHit = false;\n                                            return LRESULT.ZERO;\n                                        }\n                                    }\n                                }\n                            }\n                        } else {\n                            display.mnemonicKeyHit = false;\n                        }\n                    }\n                }\n            }\n        \n        case OS.SC_HSCROLL:\n        case OS.SC_VSCROLL:\n            \n            Decorations shell = menuShell();\n            if (!shell.isEnabled() || !shell.isActive()) {\n                return LRESULT.ZERO;\n            }\n            break;\n        case OS.SC_MINIMIZE:\n            \n            menuShell().saveFocus();\n            break;\n    }\n    return null;\n}",
			"comments":"/*\n* Check to see if the command is a system command or\n* a user menu item that was added to the System menu.\n* When a user item is added to the System menu,\n* WM_SYSCOMMAND must always return zero.\n*/\n/* Process the System Command */\n/*\n* When lParam is zero, one of F10, Shift+F10, Ctrl+F10 or\n* Ctrl+Shift+F10 was pressed.  If there is no menu bar and\n* the focus control is interested in keystrokes, give the\n* key to the focus control.  Normally, F10 with no menu bar\n* moves focus to the System menu but this can be achieved\n* using Alt+Space.  To allow the application to see F10,\n* avoid running the default window proc.\n*\n* NOTE:  When F10 is pressed, WM_SYSCOMMAND is sent to the\n* shell, not the focus control.  This is undocumented Windows\n* behavior.\n*/\n/*\n* When lParam is not zero, Alt+<key> was pressed.  If the\n* application is interested in keystrokes and there is a\n* menu bar, check to see whether the key that was pressed\n* matches a mnemonic on the menu bar.  Normally, Windows\n* matches the first character of a menu item as well as\n* matching the mnemonic character.  To allow the application\n* to see the keystrokes in this case, avoid running the default\n* window proc.\n*\n* NOTE: When the user types Alt+Space, the System menu is\n* activated.  In this case the application should not see\n* the keystroke.\n*/\n// FALL THROUGH\n/*\n* Do not allow keyboard traversal of the menu bar\n* or scrolling when the shell is not enabled.\n*/\n/* Save the focus widget when the shell is minimized */\n",
			"methodName":"LRESULT WM_SYSCOMMAND(int wParam, int lParam)"
		},
		"LRESULT WM_SETFONT(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_SETFONT(int wParam, int lParam)"
		},
		"void forceResize()":{
			"methodBody":"{\n    if (parent == null)\n        return;\n    WINDOWPOS[] lpwp = parent.lpwp;\n    if (lpwp == null)\n        return;\n    for (int i = 0; i < lpwp.length; i++) {\n        WINDOWPOS wp = lpwp[i];\n        if (wp != null && wp.hwnd == handle) {\n            \n            \n            \n            \n            \n            \n            SetWindowPos(wp.hwnd, 0, wp.x, wp.y, wp.cx, wp.cy, wp.flags);\n            lpwp[i] = null;\n            return;\n        }\n    }\n}",
			"comments":"/*\n* This code is intentionally commented.  All widgets that\n* are created by SWT have WS_CLIPSIBLINGS to ensure that\n* application code does not draw outside of the control.\n*/\n//\t\t\tint count = parent.getChildrenCount ();\n//\t\t\tif (count > 1) {\n//\t\t\t\tint bits = OS.GetWindowLong (handle, OS.GWL_STYLE);\n//\t\t\t\tif ((bits & OS.WS_CLIPSIBLINGS) == 0) wp.flags |= OS.SWP_NOCOPYBITS;\n//\t\t\t}\n",
			"methodName":"void forceResize()"
		},
		"public void pack(boolean changed)":{
			"methodBody":"{\n    checkWidget();\n    setSize(computeSize(SWT.DEFAULT, SWT.DEFAULT, changed));\n}",
			"comments":"/**\n* Causes the receiver to be resized to its preferred size.\n* For a composite, this involves computing the preferred size\n* from its layout, if there is one.\n* <p>\n* If the changed flag is <code>true</code>, it indicates that the receiver's\n* <em>contents</em> have changed, therefore any caches that a layout manager\n* containing the control may have been keeping need to be flushed. When the\n* control is resized, the changed flag will be <code>false</code>, so layout\n* manager caches can be retained.\n* </p>\n*\n* @param changed whether or not the receiver's contents have changed\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #computeSize(int, int, boolean)\n*/\n",
			"methodName":"public void pack(boolean changed)"
		},
		"public void setCapture(boolean capture)":{
			"methodBody":"{\n    checkWidget();\n    if (capture) {\n        OS.SetCapture(handle);\n    } else {\n        if (OS.GetCapture() == handle) {\n            OS.ReleaseCapture();\n        }\n    }\n}",
			"comments":"/**\n* If the argument is <code>true</code>, causes the receiver to have\n* all mouse events delivered to it until the method is called with\n* <code>false</code> as the argument.\n*\n* @param capture <code>true</code> to capture the mouse, and <code>false</code> to release it\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setCapture(boolean capture)"
		},
		"Decorations menuShell()":{
			"methodBody":"{\n    return parent.menuShell();\n}",
			"comments":"",
			"methodName":"Decorations menuShell()"
		},
		"CREATESTRUCT widgetCreateStruct()":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"CREATESTRUCT widgetCreateStruct()"
		},
		"LRESULT WM_QUERYNEWPALETTE(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_QUERYNEWPALETTE(int wParam, int lParam)"
		},
		"public void setLocation(int x, int y)":{
			"methodBody":"{\n    checkWidget();\n    int flags = OS.SWP_NOSIZE | OS.SWP_NOZORDER | OS.SWP_NOACTIVATE;\n    \n    if (!OS.IsWinCE)\n        flags |= OS.SWP_DRAWFRAME;\n    setBounds(x, y, 0, 0, flags);\n}",
			"comments":"/**\n* Sets the receiver's location to the point specified by\n* the arguments which are relative to the receiver's\n* parent (or its display if its parent is null), unless\n* the receiver is a shell. In this case, the point is\n* relative to the display.\n*\n* @param x the new x coordinate for the receiver\n* @param y the new y coordinate for the receiver\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* Feature in WinCE.  The SWP_DRAWFRAME flag for SetWindowPos()\n* causes a WM_SIZE message to be sent even when the SWP_NOSIZE\n* flag is specified.  The fix is to set SWP_DRAWFRAME only when\n* not running on WinCE.\n*/\n",
			"methodName":"public void setLocation(int x, int y)"
		},
		"void setForegroundPixel(int pixel)":{
			"methodBody":"{\n    if (foreground == pixel)\n        return;\n    foreground = pixel;\n    OS.InvalidateRect(handle, null, true);\n}",
			"comments":"",
			"methodName":"void setForegroundPixel(int pixel)"
		},
		"public void update()":{
			"methodBody":"{\n    checkWidget();\n    update(false);\n}",
			"comments":"/**\n* Forces all outstanding paint requests for the widget\n* to be processed before this method returns.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #redraw(int, int, int, int, boolean)\n* @see PaintListener\n* @see SWT#Paint\n*/\n",
			"methodName":"public void update()"
		},
		"int getCodePage()":{
			"methodBody":"{\n    if (OS.IsUnicode)\n        return OS.CP_ACP;\n    int hFont = OS.SendMessage(handle, OS.WM_GETFONT, 0, 0);\n    LOGFONT logFont = OS.IsUnicode ? (LOGFONT) new LOGFONTW() : new LOGFONTA();\n    OS.GetObject(hFont, LOGFONT.sizeof, logFont);\n    int cs = logFont.lfCharSet & 0xFF;\n    int[] lpCs = new int[8];\n    if (OS.TranslateCharsetInfo(cs, lpCs, OS.TCI_SRCCHARSET)) {\n        return lpCs[1];\n    }\n    return OS.GetACP();\n}",
			"comments":"",
			"methodName":"int getCodePage()"
		},
		"abstract int windowProc()":{
			"methodBody":"",
			"comments":"",
			"methodName":"abstract int windowProc()"
		},
		"LRESULT WM_XBUTTONUP(int wParam, int lParam)":{
			"methodBody":"{\n    return wmXButtonUp(handle, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_XBUTTONUP(int wParam, int lParam)"
		},
		"boolean setSavedFocus()":{
			"methodBody":"{\n    return forceFocus();\n}",
			"comments":"",
			"methodName":"boolean setSavedFocus()"
		},
		"LRESULT WM_XBUTTONDOWN(int wParam, int lParam)":{
			"methodBody":"{\n    return wmXButtonDown(handle, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_XBUTTONDOWN(int wParam, int lParam)"
		},
		"void checkMirrored()":{
			"methodBody":"{\n    if ((style & SWT.RIGHT_TO_LEFT) != 0) {\n        int bits = OS.GetWindowLong(handle, OS.GWL_EXSTYLE);\n        if ((bits & OS.WS_EX_LAYOUTRTL) != 0)\n            style |= SWT.MIRRORED;\n    }\n}",
			"comments":"",
			"methodName":"void checkMirrored()"
		},
		"public void removeHelpListener(HelpListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.Help, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when the help events are generated for the control.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see HelpListener\n* @see #addHelpListener\n*/\n",
			"methodName":"public void removeHelpListener(HelpListener listener)"
		},
		"LRESULT WM_LBUTTONUP(int wParam, int lParam)":{
			"methodBody":"{\n    return wmLButtonUp(handle, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_LBUTTONUP(int wParam, int lParam)"
		},
		"LRESULT WM_RBUTTONDBLCLK(int wParam, int lParam)":{
			"methodBody":"{\n    return wmRButtonDblClk(handle, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_RBUTTONDBLCLK(int wParam, int lParam)"
		},
		"public void setRedraw(boolean redraw)":{
			"methodBody":"{\n    checkWidget();\n    \n    if (drawCount == 0) {\n        int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n        if ((bits & OS.WS_VISIBLE) == 0)\n            state |= HIDDEN;\n    }\n    if (redraw) {\n        if (--drawCount == 0) {\n            OS.SendMessage(handle, OS.WM_SETREDRAW, 1, 0);\n            if ((state & HIDDEN) != 0) {\n                state &= ~HIDDEN;\n                OS.ShowWindow(handle, OS.SW_HIDE);\n            } else {\n                if (OS.IsWinCE) {\n                    OS.InvalidateRect(handle, null, true);\n                } else {\n                    int flags = OS.RDW_ERASE | OS.RDW_FRAME | OS.RDW_INVALIDATE | OS.RDW_ALLCHILDREN;\n                    OS.RedrawWindow(handle, null, 0, flags);\n                }\n            }\n        }\n    } else {\n        if (drawCount++ == 0) {\n            OS.SendMessage(handle, OS.WM_SETREDRAW, 0, 0);\n        }\n    }\n}",
			"comments":"/**\n* If the argument is <code>false</code>, causes subsequent drawing\n* operations in the receiver to be ignored. No drawing of any kind\n* can occur in the receiver until the flag is set to true.\n* Graphics operations that occurred while the flag was\n* <code>false</code> are lost. When the flag is set to <code>true</code>,\n* the entire widget is marked as needing to be redrawn.  Nested calls\n* to this method are stacked.\n* <p>\n* Note: This operation is a hint and may not be supported on some\n* platforms or for some widgets.\n* </p>\n*\n* @param redraw the new redraw state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #redraw(int, int, int, int, boolean)\n* @see #update\n*/\n/*\n* Feature in Windows.  When WM_SETREDRAW is used to turn\n* off drawing in a widget, it clears the WS_VISIBLE bits\n* and then sets them when redraw is turned back on.  This\n* means that WM_SETREDRAW will make a widget unexpectedly\n* visible.  The fix is to track the visibility state while\n* drawing is turned off and restore it when drawing is\n* turned back on.\n*/\n",
			"methodName":"public void setRedraw(boolean redraw)"
		},
		"public void setBounds(int x, int y, int width, int height)":{
			"methodBody":"{\n    checkWidget();\n    int flags = OS.SWP_NOZORDER | OS.SWP_DRAWFRAME | OS.SWP_NOACTIVATE;\n    setBounds(x, y, Math.max(0, width), Math.max(0, height), flags);\n}",
			"comments":"/**\n* Sets the receiver's size and location to the rectangular\n* area specified by the arguments. The <code>x</code> and\n* <code>y</code> arguments are relative to the receiver's\n* parent (or its display if its parent is null), unless\n* the receiver is a shell. In this case, the <code>x</code>\n* and <code>y</code> arguments are relative to the display.\n* <p>\n* Note: Attempting to set the width or height of the\n* receiver to a negative number will cause that\n* value to be set to zero instead.\n* </p>\n*\n* @param x the new x coordinate for the receiver\n* @param y the new y coordinate for the receiver\n* @param width the new width for the receiver\n* @param height the new height for the receiver\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setBounds(int x, int y, int width, int height)"
		},
		"Control[] getPath()":{
			"methodBody":"{\n    int count = 0;\n    Shell shell = getShell();\n    Control control = this;\n    while (control != shell) {\n        count++;\n        control = control.parent;\n    }\n    control = this;\n    Control[] result = new Control[count];\n    while (control != shell) {\n        result[--count] = control;\n        control = control.parent;\n    }\n    return result;\n}",
			"comments":"",
			"methodName":"Control[] getPath()"
		},
		"void subclass()":{
			"methodBody":"{\n    int oldProc = windowProc();\n    int newProc = display.windowProc;\n    if (oldProc == newProc)\n        return;\n    OS.SetWindowLong(handle, OS.GWL_WNDPROC, newProc);\n}",
			"comments":"",
			"methodName":"void subclass()"
		},
		"boolean translateMnemonic(MSG msg)":{
			"methodBody":"{\n    if (msg.wParam < 0x20)\n        return false;\n    int hwnd = msg.hwnd;\n    if (OS.GetKeyState(OS.VK_MENU) >= 0) {\n        int code = OS.SendMessage(hwnd, OS.WM_GETDLGCODE, 0, 0);\n        if ((code & OS.DLGC_WANTALLKEYS) != 0)\n            return false;\n        if ((code & OS.DLGC_BUTTON) == 0)\n            return false;\n    }\n    Decorations shell = menuShell();\n    if (shell.isVisible() && shell.isEnabled()) {\n        display.lastAscii = msg.wParam;\n        display.lastNull = display.lastDead = false;\n        Event event = new Event();\n        event.detail = SWT.TRAVERSE_MNEMONIC;\n        if (setKeyState(event, SWT.Traverse, msg.wParam, msg.lParam)) {\n            return translateMnemonic(event, null) || shell.translateMnemonic(event, this);\n        }\n    }\n    return false;\n}",
			"comments":"",
			"methodName":"boolean translateMnemonic(MSG msg)"
		},
		"public void removeMouseMoveListener(MouseMoveListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.MouseMove, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when the mouse moves.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see MouseMoveListener\n* @see #addMouseMoveListener\n*/\n",
			"methodName":"public void removeMouseMoveListener(MouseMoveListener listener)"
		},
		"LRESULT wmScrollChild(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT wmScrollChild(int wParam, int lParam)"
		},
		"public void setCursor(Cursor cursor)":{
			"methodBody":"{\n    checkWidget();\n    if (cursor != null && cursor.isDisposed())\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    this.cursor = cursor;\n    if (OS.IsWinCE) {\n        int hCursor = cursor != null ? cursor.handle : 0;\n        OS.SetCursor(hCursor);\n        return;\n    }\n    int hwndCursor = OS.GetCapture();\n    if (hwndCursor == 0) {\n        POINT pt = new POINT();\n        if (!OS.GetCursorPos(pt))\n            return;\n        int hwnd = hwndCursor = OS.WindowFromPoint(pt);\n        while (hwnd != 0 && hwnd != handle) {\n            hwnd = OS.GetParent(hwnd);\n        }\n        if (hwnd == 0)\n            return;\n    }\n    Control control = display.getControl(hwndCursor);\n    if (control == null)\n        control = this;\n    control.setCursor();\n}",
			"comments":"/**\n* Sets the receiver's cursor to the cursor specified by the\n* argument, or to the default cursor for that kind of control\n* if the argument is null.\n* <p>\n* When the mouse pointer passes over a control its appearance\n* is changed to match the control's cursor.\n* </p>\n*\n* @param cursor the new cursor (or null)\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setCursor(Cursor cursor)"
		},
		"boolean translateTraversal(MSG msg)":{
			"methodBody":"{\n    int key = msg.wParam;\n    if (key == OS.VK_MENU) {\n        Shell shell = getShell();\n        int hwndShell = shell.handle;\n        OS.SendMessage(hwndShell, OS.WM_CHANGEUISTATE, OS.UIS_INITIALIZE, 0);\n        return false;\n    }\n    int hwnd = msg.hwnd;\n    int detail = SWT.TRAVERSE_NONE;\n    boolean doit = true, all = false;\n    boolean lastVirtual = false;\n    int lastKey = key, lastAscii = 0;\n    switch(key) {\n        case OS.VK_ESCAPE:\n            {\n                all = true;\n                lastAscii = 27;\n                int code = OS.SendMessage(hwnd, OS.WM_GETDLGCODE, 0, 0);\n                if ((code & OS.DLGC_WANTALLKEYS) != 0) {\n                    \n                    if ((code & OS.DLGC_HASSETSEL) == 0)\n                        doit = false;\n                }\n                detail = SWT.TRAVERSE_ESCAPE;\n                break;\n            }\n        case OS.VK_RETURN:\n            {\n                all = true;\n                lastAscii = '\\r';\n                int code = OS.SendMessage(hwnd, OS.WM_GETDLGCODE, 0, 0);\n                if ((code & OS.DLGC_WANTALLKEYS) != 0)\n                    doit = false;\n                detail = SWT.TRAVERSE_RETURN;\n                break;\n            }\n        case OS.VK_TAB:\n            {\n                lastAscii = '\\t';\n                boolean next = OS.GetKeyState(OS.VK_SHIFT) >= 0;\n                int code = OS.SendMessage(hwnd, OS.WM_GETDLGCODE, 0, 0);\n                if ((code & (OS.DLGC_WANTTAB | OS.DLGC_WANTALLKEYS)) != 0) {\n                    \n                    if ((code & OS.DLGC_HASSETSEL) != 0) {\n                        if (next && OS.GetKeyState(OS.VK_CONTROL) >= 0) {\n                            doit = false;\n                        }\n                    } else {\n                        doit = false;\n                    }\n                }\n                if (parent != null && (parent.style & SWT.MIRRORED) != 0) {\n                    if (key == OS.VK_LEFT || key == OS.VK_RIGHT)\n                        next = !next;\n                }\n                detail = next ? SWT.TRAVERSE_TAB_NEXT : SWT.TRAVERSE_TAB_PREVIOUS;\n                break;\n            }\n        case OS.VK_UP:\n        case OS.VK_LEFT:\n        case OS.VK_DOWN:\n        case OS.VK_RIGHT:\n            {\n                \n                if (OS.IsSP) {\n                    if (key == OS.VK_LEFT || key == OS.VK_RIGHT)\n                        return false;\n                }\n                lastVirtual = true;\n                int code = OS.SendMessage(hwnd, OS.WM_GETDLGCODE, 0, 0);\n                if ((code & (OS.DLGC_WANTARROWS)) != 0)\n                    doit = false;\n                boolean next = key == OS.VK_DOWN || key == OS.VK_RIGHT;\n                detail = next ? SWT.TRAVERSE_ARROW_NEXT : SWT.TRAVERSE_ARROW_PREVIOUS;\n                break;\n            }\n        case OS.VK_PRIOR:\n        case OS.VK_NEXT:\n            {\n                all = true;\n                lastVirtual = true;\n                if (OS.GetKeyState(OS.VK_CONTROL) >= 0)\n                    return false;\n                int code = OS.SendMessage(hwnd, OS.WM_GETDLGCODE, 0, 0);\n                if ((code & OS.DLGC_WANTALLKEYS) != 0) {\n                    \n                    if ((code & OS.DLGC_HASSETSEL) == 0)\n                        doit = false;\n                }\n                detail = key == OS.VK_PRIOR ? SWT.TRAVERSE_PAGE_PREVIOUS : SWT.TRAVERSE_PAGE_NEXT;\n                break;\n            }\n        default:\n            return false;\n    }\n    Event event = new Event();\n    event.doit = doit;\n    event.detail = detail;\n    display.lastKey = lastKey;\n    display.lastAscii = lastAscii;\n    display.lastVirtual = lastVirtual;\n    display.lastNull = display.lastDead = false;\n    if (!setKeyState(event, SWT.Traverse, msg.wParam, msg.lParam))\n        return false;\n    Shell shell = getShell();\n    Control control = this;\n    do {\n        if (control.traverse(event)) {\n            int hwndShell = shell.handle;\n            OS.SendMessage(hwndShell, OS.WM_CHANGEUISTATE, OS.UIS_INITIALIZE, 0);\n            return true;\n        }\n        if (!event.doit && control.hooks(SWT.Traverse))\n            return false;\n        if (control == shell)\n            return false;\n        control = control.parent;\n    } while (all && control != null);\n    return false;\n}",
			"comments":"/*\n* Use DLGC_HASSETSEL to determine that the control\n* is a text widget.  A text widget normally wants\n* all keys except VK_ESCAPE.  If this bit is not\n* set, then assume the control wants all keys,\n* including VK_ESCAPE.\n*/\n/*\n* Use DLGC_HASSETSEL to determine that the control is a\n* text widget.  If the control is a text widget, then\n* Ctrl+Tab and Shift+Tab should traverse out of the widget.\n* If the control is not a text widget, the correct behavior\n* is to give every character, including Tab, Ctrl+Tab and\n* Shift+Tab to the control.\n*/\n/*\n* On WinCE SP there is no tab key.  Focus is assigned\n* using the VK_UP and VK_DOWN keys, not with VK_LEFT\n* or VK_RIGHT.\n*/\n/*| OS.DLGC_WANTALLKEYS*/\n/*\n* Use DLGC_HASSETSEL to determine that the control is a\n* text widget.  If the control is a text widget, then\n* Ctrl+PgUp and Ctrl+PgDn should traverse out of the widget.\n*/\n",
			"methodName":"boolean translateTraversal(MSG msg)"
		},
		"boolean setTabItemFocus()":{
			"methodBody":"{\n    if (!isShowing())\n        return false;\n    return forceFocus();\n}",
			"comments":"",
			"methodName":"boolean setTabItemFocus()"
		},
		"LRESULT WM_MBUTTONUP(int wParam, int lParam)":{
			"methodBody":"{\n    return wmMButtonUp(handle, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_MBUTTONUP(int wParam, int lParam)"
		},
		"public Point computeSize(int wHint, int hHint)":{
			"methodBody":"{\n    return computeSize(wHint, hHint, true);\n}",
			"comments":"/**\n* Returns the preferred size of the receiver.\n* <p>\n* The <em>preferred size</em> of a control is the size that it would\n* best be displayed at. The width hint and height hint arguments\n* allow the caller to ask a control questions such as \"Given a particular\n* width, how high does the control need to be to show all of the contents?\"\n* To indicate that the caller does not wish to constrain a particular\n* dimension, the constant <code>SWT.DEFAULT</code> is passed for the hint.\n* </p>\n*\n* @param wHint the width hint (can be <code>SWT.DEFAULT</code>)\n* @param hHint the height hint (can be <code>SWT.DEFAULT</code>)\n* @return the preferred size of the control\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see Layout\n* @see #getBorderWidth\n* @see #getBounds\n* @see #getSize\n* @see #pack(boolean)\n* @see \"computeTrim, getClientArea for controls that implement them\"\n*/\n",
			"methodName":"public Point computeSize(int wHint, int hHint)"
		},
		"public void setSize(Point size)":{
			"methodBody":"{\n    checkWidget();\n    if (size == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    setSize(size.x, size.y);\n}",
			"comments":"/**\n* Sets the receiver's size to the point specified by the argument.\n* <p>\n* Note: Attempting to set the width or height of the\n* receiver to a negative number will cause them to be\n* set to zero instead.\n* </p>\n*\n* @param size the new size for the receiver\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the point is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setSize(Point size)"
		},
		"LRESULT WM_MENUSELECT(int wParam, int lParam)":{
			"methodBody":"{\n    int code = wParam >> 16;\n    Shell shell = getShell();\n    if (code == -1 && lParam == 0) {\n        Menu menu = shell.activeMenu;\n        while (menu != null) {\n            \n            display.mnemonicKeyHit = true;\n            \n            menu.sendEvent(SWT.Hide);\n            if (menu.isDisposed())\n                break;\n            menu = menu.getParentMenu();\n        }\n        \n        shell.activeMenu = null;\n        return null;\n    }\n    if ((code & OS.MF_SYSMENU) != 0)\n        return null;\n    if ((code & OS.MF_HILITE) != 0) {\n        MenuItem item = null;\n        Decorations menuShell = menuShell();\n        if ((code & OS.MF_POPUP) != 0) {\n            int index = wParam & 0xFFFF;\n            MENUITEMINFO info = new MENUITEMINFO();\n            info.cbSize = MENUITEMINFO.sizeof;\n            info.fMask = OS.MIIM_SUBMENU;\n            if (OS.GetMenuItemInfo(lParam, index, true, info)) {\n                Menu newMenu = menuShell.findMenu(info.hSubMenu);\n                if (newMenu != null)\n                    item = newMenu.cascade;\n            }\n        } else {\n            Menu newMenu = menuShell.findMenu(lParam);\n            if (newMenu != null) {\n                int id = wParam & 0xFFFF;\n                item = display.getMenuItem(id);\n            }\n            Menu oldMenu = shell.activeMenu;\n            if (oldMenu != null) {\n                Menu ancestor = oldMenu;\n                while (ancestor != null && ancestor != newMenu) {\n                    ancestor = ancestor.getParentMenu();\n                }\n                if (ancestor == newMenu) {\n                    ancestor = oldMenu;\n                    while (ancestor != newMenu) {\n                        \n                        ancestor.sendEvent(SWT.Hide);\n                        if (ancestor.isDisposed())\n                            break;\n                        ancestor = ancestor.getParentMenu();\n                    }\n                    \n                    if (!shell.isDisposed()) {\n                        if (newMenu != null && newMenu.isDisposed()) {\n                            newMenu = null;\n                        }\n                        shell.activeMenu = newMenu;\n                    }\n                    if (item != null && item.isDisposed())\n                        item = null;\n                }\n            }\n        }\n        if (item != null)\n            item.sendEvent(SWT.Arm);\n    }\n    return null;\n}",
			"comments":"/*\n* When the user cancels any menu that is not the\n* menu bar, assume a mnemonic key was pressed to open\n* the menu from WM_SYSCHAR.  When the menu was invoked\n* using the mouse, this assumption is wrong but not\n* harmful.  This variable is only used in WM_SYSCHAR\n* and WM_SYSCHAR is only sent after the user has pressed\n* a mnemonic.\n*/\n/*\n* It is possible (but unlikely), that application\n* code could have disposed the widget in the hide\n* event.  If this happens, stop searching up the\n* parent list because there is no longer a link\n* to follow.\n*/\n/*\n* The shell may be disposed because of sending the hide\n* event to the last active menu menu but setting a field\n* to null in a destroyed widget is not harmful.\n*/\n/*\n* It is possible (but unlikely), that application\n* code could have disposed the widget in the hide\n* event or the item about to be armed.  If this\n* happens, stop searching up the ancestor list\n* because there is no longer a link to follow.\n*/\n/*\n* The shell and/or the item could be disposed when\n* processing hide events from above.  If this happens,\n* ensure that the shell is not accessed and that no\n* arm event is sent to the item.\n*/\n",
			"methodName":"LRESULT WM_MENUSELECT(int wParam, int lParam)"
		},
		"LRESULT WM_ERASEBKGND(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_ERASEBKGND(int wParam, int lParam)"
		},
		"LRESULT WM_INPUTLANGCHANGE(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_INPUTLANGCHANGE(int wParam, int lParam)"
		},
		"public void moveBelow(Control control)":{
			"methodBody":"{\n    checkWidget();\n    int topHandle = topHandle(), hwndAbove = OS.HWND_BOTTOM;\n    if (control != null) {\n        if (control.isDisposed())\n            error(SWT.ERROR_INVALID_ARGUMENT);\n        if (parent != control.parent)\n            return;\n        hwndAbove = control.topHandle();\n    }\n    if (hwndAbove == 0 || hwndAbove == topHandle)\n        return;\n    int flags = OS.SWP_NOSIZE | OS.SWP_NOMOVE | OS.SWP_NOACTIVATE;\n    SetWindowPos(topHandle, hwndAbove, 0, 0, 0, 0, flags);\n}",
			"comments":"/**\n* Moves the receiver below the specified control in the\n* drawing order. If the argument is null, then the receiver\n* is moved to the bottom of the drawing order. The control at\n* the bottom of the drawing order will be covered by all other\n* controls which occupy intersecting areas.\n*\n* @param control the sibling control (or null)\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the control has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see Control#moveAbove\n* @see Composite#getChildren\n*/\n",
			"methodName":"public void moveBelow(Control control)"
		},
		"LRESULT WM_QUERYOPEN(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_QUERYOPEN(int wParam, int lParam)"
		},
		"LRESULT WM_MOUSEHOVER(int wParam, int lParam)":{
			"methodBody":"{\n    return wmMouseHover(handle, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_MOUSEHOVER(int wParam, int lParam)"
		},
		"public Color getBackground()":{
			"methodBody":"{\n    checkWidget();\n    return Color.win32_new(display, getBackgroundPixel());\n}",
			"comments":"/**\n* Returns the receiver's background color.\n*\n* @return the background color\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Color getBackground()"
		},
		"public Point toDisplay(int x, int y)":{
			"methodBody":"{\n    checkWidget();\n    POINT pt = new POINT();\n    pt.x = x;\n    pt.y = y;\n    OS.ClientToScreen(handle, pt);\n    return new Point(pt.x, pt.y);\n}",
			"comments":"/**\n* Returns a point which is the result of converting the\n* argument, which is specified in coordinates relative to\n* the receiver, to display relative coordinates.\n* <p>\n* @param x the x coordinate to be translated\n* @param y the y coordinate to be translated\n* @return the translated coordinates\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 2.1\n*/\n",
			"methodName":"public Point toDisplay(int x, int y)"
		},
		"LRESULT WM_IME_COMPOSITION(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_IME_COMPOSITION(int wParam, int lParam)"
		},
		"boolean traverseItem(boolean next)":{
			"methodBody":"{\n    Control[] children = parent._getChildren();\n    int length = children.length;\n    int index = 0;\n    while (index < length) {\n        if (children[index] == this)\n            break;\n        index++;\n    }\n    \n    if (index == length)\n        return false;\n    int start = index, offset = (next) ? 1 : -1;\n    while ((index = (index + offset + length) % length) != start) {\n        Control child = children[index];\n        if (!child.isDisposed() && child.isTabItem()) {\n            if (child.setTabItemFocus())\n                return true;\n        }\n    }\n    return false;\n}",
			"comments":"/*\n* It is possible (but unlikely), that application\n* code could have disposed the widget in focus in\n* or out events.  Ensure that a disposed widget is\n* not accessed.\n*/\n",
			"methodName":"boolean traverseItem(boolean next)"
		},
		"LRESULT WM_CUT(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_CUT(int wParam, int lParam)"
		},
		"char findMnemonic(String string)":{
			"methodBody":"{\n    int index = 0;\n    int length = string.length();\n    do {\n        while (index < length && string.charAt(index) != '&') index++;\n        if (++index >= length)\n            return '\\0';\n        if (string.charAt(index) != '&')\n            return string.charAt(index);\n        index++;\n    } while (index < length);\n    return '\\0';\n}",
			"comments":"",
			"methodName":"char findMnemonic(String string)"
		},
		"boolean isFocusAncestor(Control control)":{
			"methodBody":"{\n    while (control != null && control != this) {\n        control = control.parent;\n    }\n    return control == this;\n}",
			"comments":"",
			"methodName":"boolean isFocusAncestor(Control control)"
		},
		"LRESULT WM_MOUSELEAVE(int wParam, int lParam)":{
			"methodBody":"{\n    return wmMouseLeave(handle, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_MOUSELEAVE(int wParam, int lParam)"
		},
		"public Point computeSize(int wHint, int hHint, boolean changed)":{
			"methodBody":"{\n    checkWidget();\n    int width = DEFAULT_WIDTH;\n    int height = DEFAULT_HEIGHT;\n    if (wHint != SWT.DEFAULT)\n        width = wHint;\n    if (hHint != SWT.DEFAULT)\n        height = hHint;\n    int border = getBorderWidth();\n    width += border * 2;\n    height += border * 2;\n    return new Point(width, height);\n}",
			"comments":"/**\n* Returns the preferred size of the receiver.\n* <p>\n* The <em>preferred size</em> of a control is the size that it would\n* best be displayed at. The width hint and height hint arguments\n* allow the caller to ask a control questions such as \"Given a particular\n* width, how high does the control need to be to show all of the contents?\"\n* To indicate that the caller does not wish to constrain a particular\n* dimension, the constant <code>SWT.DEFAULT</code> is passed for the hint.\n* </p><p>\n* If the changed flag is <code>true</code>, it indicates that the receiver's\n* <em>contents</em> have changed, therefore any caches that a layout manager\n* containing the control may have been keeping need to be flushed. When the\n* control is resized, the changed flag will be <code>false</code>, so layout\n* manager caches can be retained.\n* </p>\n*\n* @param wHint the width hint (can be <code>SWT.DEFAULT</code>)\n* @param hHint the height hint (can be <code>SWT.DEFAULT</code>)\n* @param changed <code>true</code> if the control's contents have changed, and <code>false</code> otherwise\n* @return the preferred size of the control.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see Layout\n* @see #getBorderWidth\n* @see #getBounds\n* @see #getSize\n* @see #pack(boolean)\n* @see \"computeTrim, getClientArea for controls that implement them\"\n*/\n",
			"methodName":"public Point computeSize(int wHint, int hHint, boolean changed)"
		},
		"LRESULT WM_ENDSESSION(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_ENDSESSION(int wParam, int lParam)"
		},
		"public void addTraverseListener(TraverseListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.Traverse, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when traversal events occur, by sending it\n* one of the messages defined in the <code>TraverseListener</code>\n* interface.\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see TraverseListener\n* @see #removeTraverseListener\n*/\n",
			"methodName":"public void addTraverseListener(TraverseListener listener)"
		},
		"public void setVisible(boolean visible)":{
			"methodBody":"{\n    checkWidget();\n    if (drawCount != 0) {\n        if (((state & HIDDEN) == 0) == visible)\n            return;\n    } else {\n        int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n        if (((bits & OS.WS_VISIBLE) != 0) == visible)\n            return;\n    }\n    if (visible) {\n        sendEvent(SWT.Show);\n        if (isDisposed())\n            return;\n    }\n    \n    Control control = null;\n    boolean fixFocus = false;\n    if (!visible) {\n        if (display.focusEvent != SWT.FocusOut) {\n            control = display.getFocusControl();\n            fixFocus = isFocusAncestor(control);\n        }\n    }\n    if (drawCount != 0) {\n        state = visible ? state & ~HIDDEN : state | HIDDEN;\n    } else {\n        showWidget(visible);\n        if (isDisposed())\n            return;\n    }\n    if (!visible) {\n        sendEvent(SWT.Hide);\n        if (isDisposed())\n            return;\n    }\n    if (fixFocus)\n        fixFocus(control);\n}",
			"comments":"/**\n* Marks the receiver as visible if the argument is <code>true</code>,\n* and marks it invisible otherwise.\n* <p>\n* If one of the receiver's ancestors is not visible or some\n* other condition makes the receiver not visible, marking\n* it visible may not actually cause it to be displayed.\n* </p>\n*\n* @param visible the new visibility state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* Feature in Windows.  If the receiver has focus, hiding\n* the receiver causes no window to have focus.  The fix is\n* to assign focus to the first ancestor window that takes\n* focus.  If no window will take focus, set focus to the\n* desktop.\n*/\n",
			"methodName":"public void setVisible(boolean visible)"
		},
		"void drawBackground(int hDC, int pixel, RECT rect)":{
			"methodBody":"{\n    Control control = null;\n    if (OS.COMCTL32_MAJOR >= 6 && OS.IsAppThemed()) {\n        control = findThemeControl();\n    }\n    if (control == null) {\n        int hPalette = display.hPalette;\n        if (hPalette != 0) {\n            OS.SelectPalette(hDC, hPalette, false);\n            OS.RealizePalette(hDC);\n        }\n        int hBrush = findBrush(pixel);\n        OS.FillRect(hDC, rect, hBrush);\n    } else {\n        RECT rect2 = new RECT();\n        OS.GetWindowRect(control.handle, rect2);\n        OS.MapWindowPoints(0, handle, rect2, 2);\n        control.drawThemeBackground(hDC, rect2);\n    }\n}",
			"comments":"",
			"methodName":"void drawBackground(int hDC, int pixel, RECT rect)"
		},
		"public void removeControlListener(ControlListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.Move, listener);\n    eventTable.unhook(SWT.Resize, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when the control is moved or resized.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see ControlListener\n* @see #addControlListener\n*/\n",
			"methodName":"public void removeControlListener(ControlListener listener)"
		},
		"public void moveAbove(Control control)":{
			"methodBody":"{\n    checkWidget();\n    int topHandle = topHandle(), hwndAbove = OS.HWND_TOP;\n    if (control != null) {\n        if (control.isDisposed())\n            error(SWT.ERROR_INVALID_ARGUMENT);\n        if (parent != control.parent)\n            return;\n        int hwnd = control.topHandle();\n        if (hwnd == 0 || hwnd == topHandle)\n            return;\n        hwndAbove = OS.GetWindow(hwnd, OS.GW_HWNDPREV);\n        \n        if (hwndAbove == 0 || hwndAbove == hwnd) {\n            hwndAbove = OS.HWND_TOP;\n        }\n    }\n    int flags = OS.SWP_NOSIZE | OS.SWP_NOMOVE | OS.SWP_NOACTIVATE;\n    SetWindowPos(topHandle, hwndAbove, 0, 0, 0, 0, flags);\n}",
			"comments":"/**\n* Moves the receiver above the specified control in the\n* drawing order. If the argument is null, then the receiver\n* is moved to the top of the drawing order. The control at\n* the top of the drawing order will not be covered by other\n* controls even if they occupy intersecting areas.\n*\n* @param control the sibling control (or null)\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the control has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see Control#moveBelow\n* @see Composite#getChildren\n*/\n/*\n* Bug in Windows.  For some reason, when GetWindow ()\n* with GW_HWNDPREV is used to query the previous window\n* in the z-order with the first child, Windows returns\n* the first child instead of NULL.  The fix is to detect\n* this case and move the control to the top.\n*/\n",
			"methodName":"public void moveAbove(Control control)"
		},
		"LRESULT WM_MOUSEACTIVATE(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_MOUSEACTIVATE(int wParam, int lParam)"
		},
		"void setCursor()":{
			"methodBody":"{\n    int lParam = OS.HTCLIENT | (OS.WM_MOUSEMOVE << 16);\n    OS.SendMessage(handle, OS.WM_SETCURSOR, handle, lParam);\n}",
			"comments":"",
			"methodName":"void setCursor()"
		},
		"LRESULT WM_MEASUREITEM(int wParam, int lParam)":{
			"methodBody":"{\n    MEASUREITEMSTRUCT struct = new MEASUREITEMSTRUCT();\n    OS.MoveMemory(struct, lParam, MEASUREITEMSTRUCT.sizeof);\n    if (struct.CtlType == OS.ODT_MENU) {\n        MenuItem item = display.getMenuItem(struct.itemID);\n        if (item == null)\n            return null;\n        return item.wmMeasureChild(wParam, lParam);\n    }\n    int hwnd = OS.GetDlgItem(handle, struct.CtlID);\n    Control control = display.getControl(hwnd);\n    if (control == null)\n        return null;\n    return control.wmMeasureChild(wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_MEASUREITEM(int wParam, int lParam)"
		},
		"public boolean setFocus()":{
			"methodBody":"{\n    checkWidget();\n    if ((style & SWT.NO_FOCUS) != 0)\n        return false;\n    return forceFocus();\n}",
			"comments":"/**\n* Causes the receiver to have the <em>keyboard focus</em>,\n* such that all keyboard events will be delivered to it.  Focus\n* reassignment will respect applicable platform constraints.\n*\n* @return <code>true</code> if the control got focus, and <code>false</code> if it was unable to.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #forceFocus\n*/\n",
			"methodName":"public boolean setFocus()"
		},
		"LRESULT WM_MOUSEMOVE(int wParam, int lParam)":{
			"methodBody":"{\n    return wmMouseMove(handle, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_MOUSEMOVE(int wParam, int lParam)"
		},
		"LRESULT WM_MBUTTONDOWN(int wParam, int lParam)":{
			"methodBody":"{\n    return wmMButtonDown(handle, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_MBUTTONDOWN(int wParam, int lParam)"
		},
		"void drawBackground(int hDC)":{
			"methodBody":"{\n    RECT rect = new RECT();\n    OS.GetClientRect(handle, rect);\n    drawBackground(hDC, getBackgroundPixel(), rect);\n}",
			"comments":"",
			"methodName":"void drawBackground(int hDC)"
		},
		"void releaseWidget()":{
			"methodBody":"{\n    super.releaseWidget();\n    if (OS.IsDBLocale) {\n        OS.ImmAssociateContext(handle, 0);\n    }\n    if (toolTipText != null) {\n        Shell shell = getShell();\n        shell.setToolTipText(handle, null);\n    }\n    toolTipText = null;\n    if (menu != null && !menu.isDisposed()) {\n        menu.dispose();\n    }\n    menu = null;\n    cursor = null;\n    deregister();\n    unsubclass();\n    parent = null;\n    layoutData = null;\n    if (accessible != null) {\n        accessible.internal_dispose_Accessible();\n    }\n    accessible = null;\n}",
			"comments":"",
			"methodName":"void releaseWidget()"
		},
		"boolean traverseMnemonic(char key)":{
			"methodBody":"{\n    return mnemonicHit(key);\n}",
			"comments":"",
			"methodName":"boolean traverseMnemonic(char key)"
		},
		"LRESULT WM_ACTIVATE(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_ACTIVATE(int wParam, int lParam)"
		},
		"public void setLocation(Point location)":{
			"methodBody":"{\n    checkWidget();\n    if (location == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    setLocation(location.x, location.y);\n}",
			"comments":"/**\n* Sets the receiver's location to the point specified by\n* the arguments which are relative to the receiver's\n* parent (or its display if its parent is null), unless\n* the receiver is a shell. In this case, the point is\n* relative to the display.\n*\n* @param location the new location for the receiver\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setLocation(Point location)"
		},
		"public boolean isFocusControl()":{
			"methodBody":"{\n    checkWidget();\n    return hasFocus();\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver has the user-interface\n* focus, and <code>false</code> otherwise.\n*\n* @return the receiver's focus state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public boolean isFocusControl()"
		},
		"boolean traverseEscape()":{
			"methodBody":"{\n    return false;\n}",
			"comments":"",
			"methodName":"boolean traverseEscape()"
		},
		"boolean hasFocus()":{
			"methodBody":"{\n    \n    int hwndFocus = OS.GetFocus();\n    while (hwndFocus != 0) {\n        if (hwndFocus == handle)\n            return true;\n        if (display.getControl(hwndFocus) != null) {\n            return false;\n        }\n        hwndFocus = OS.GetParent(hwndFocus);\n    }\n    return false;\n}",
			"comments":"/*\n* If a non-SWT child of the control has focus,\n* then this control is considered to have focus\n* even though it does not have focus in Windows.\n*/\n",
			"methodName":"boolean hasFocus()"
		},
		"void enableWidget(boolean enabled)":{
			"methodBody":"{\n    OS.EnableWindow(handle, enabled);\n}",
			"comments":"",
			"methodName":"void enableWidget(boolean enabled)"
		},
		"void deregister()":{
			"methodBody":"{\n    display.removeControl(handle);\n}",
			"comments":"",
			"methodName":"void deregister()"
		},
		"public boolean forceFocus()":{
			"methodBody":"{\n    checkWidget();\n    if (display.focusEvent == SWT.FocusOut)\n        return false;\n    Decorations shell = menuShell();\n    shell.setSavedFocus(this);\n    if (!isEnabled() || !isVisible() || !isActive())\n        return false;\n    if (isFocusControl())\n        return true;\n    shell.setSavedFocus(null);\n    \n    \n    OS.SetFocus(handle);\n    if (isDisposed())\n        return false;\n    shell.setSavedFocus(this);\n    return isFocusControl();\n}",
			"comments":"/**\n* Forces the receiver to have the <em>keyboard focus</em>, causing\n* all keyboard events to be delivered to it.\n*\n* @return <code>true</code> if the control got focus, and <code>false</code> if it was unable to.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #setFocus\n*/\n/*\n* This code is intentionally commented.\n*\n* When setting focus to a control, it is\n* possible that application code can set\n* the focus to another control inside of\n* WM_SETFOCUS.  In this case, the original\n* control will no longer have the focus\n* and the call to setFocus() will return\n* false indicating failure.\n*\n* We are still working on a solution at\n* this time.\n*/\n//\tif (OS.GetFocus () != OS.SetFocus (handle)) return false;\n",
			"methodName":"public boolean forceFocus()"
		},
		"public Point getLocation()":{
			"methodBody":"{\n    checkWidget();\n    forceResize();\n    RECT rect = new RECT();\n    OS.GetWindowRect(topHandle(), rect);\n    int hwndParent = parent == null ? 0 : parent.handle;\n    OS.MapWindowPoints(0, hwndParent, rect, 2);\n    return new Point(rect.left, rect.top);\n}",
			"comments":"/**\n* Returns a point describing the receiver's location relative\n* to its parent (or its display if its parent is null), unless\n* the receiver is a shell. In this case, the point is\n* relative to the display.\n*\n* @return the receiver's location\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Point getLocation()"
		},
		"boolean isTabGroup()":{
			"methodBody":"{\n    Control[] tabList = parent._getTabList();\n    if (tabList != null) {\n        for (int i = 0; i < tabList.length; i++) {\n            if (tabList[i] == this)\n                return true;\n        }\n    }\n    int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n    return (bits & OS.WS_TABSTOP) != 0;\n}",
			"comments":"",
			"methodName":"boolean isTabGroup()"
		},
		"int defaultForeground()":{
			"methodBody":"{\n    return OS.GetSysColor(OS.COLOR_WINDOWTEXT);\n}",
			"comments":"",
			"methodName":"int defaultForeground()"
		},
		"public void redraw()":{
			"methodBody":"{\n    checkWidget();\n    if (!OS.IsWindowVisible(handle))\n        return;\n    if (OS.IsWinCE) {\n        OS.InvalidateRect(handle, null, true);\n    } else {\n        int flags = OS.RDW_ERASE | OS.RDW_FRAME | OS.RDW_INVALIDATE;\n        OS.RedrawWindow(handle, null, 0, flags);\n    }\n}",
			"comments":"/**\n* Causes the entire bounds of the receiver to be marked\n* as needing to be redrawn. The next time a paint request\n* is processed, the control will be completely painted,\n* including the background.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #update\n* @see PaintListener\n* @see SWT#Paint\n* @see SWT#NO_BACKGROUND\n* @see SWT#NO_REDRAW_RESIZE\n* @see SWT#NO_MERGE_PAINTS\n*/\n",
			"methodName":"public void redraw()"
		},
		"public void removeTraverseListener(TraverseListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.Traverse, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when traversal events occur.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see TraverseListener\n* @see #addTraverseListener\n*/\n",
			"methodName":"public void removeTraverseListener(TraverseListener listener)"
		},
		"public boolean isEnabled()":{
			"methodBody":"{\n    checkWidget();\n    return getEnabled() && parent.isEnabled();\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver is enabled and all\n* ancestors up to and including the receiver's nearest ancestor\n* shell are enabled.  Otherwise, <code>false</code> is returned.\n* A disabled control is typically not selectable from the user\n* interface and draws with an inactive or \"grayed\" look.\n*\n* @return the receiver's enabled state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #getEnabled\n*/\n",
			"methodName":"public boolean isEnabled()"
		},
		"LRESULT WM_GETMINMAXINFO(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_GETMINMAXINFO(int wParam, int lParam)"
		},
		"public void addMouseMoveListener(MouseMoveListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.MouseMove, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when the mouse moves, by sending it one of the\n* messages defined in the <code>MouseMoveListener</code>\n* interface.\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see MouseMoveListener\n* @see #removeMouseMoveListener\n*/\n",
			"methodName":"public void addMouseMoveListener(MouseMoveListener listener)"
		},
		"boolean isShowing()":{
			"methodBody":"{\n    \n    if (!isVisible())\n        return false;\n    Control control = this;\n    while (control != null) {\n        Point size = control.getSize();\n        if (size.x == 0 || size.y == 0) {\n            return false;\n        }\n        control = control.parent;\n    }\n    return true;\n\n\n\n\n\n\n\n}",
			"comments":"/*\n* This is not complete.  Need to check if the\n* widget is obscurred by a parent or sibling.\n*/\n/*\n* Check to see if current damage is included.\n*/\n//\tif (!OS.IsWindowVisible (handle)) return false;\n//\tint flags = OS.DCX_CACHE | OS.DCX_CLIPCHILDREN | OS.DCX_CLIPSIBLINGS;\n//\tint hDC = OS.GetDCEx (handle, 0, flags);\n//\tint result = OS.GetClipBox (hDC, new RECT ());\n//\tOS.ReleaseDC (handle, hDC);\n//\treturn result != OS.NULLREGION;\n",
			"methodName":"boolean isShowing()"
		},
		"LRESULT wmDrawChild(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT wmDrawChild(int wParam, int lParam)"
		},
		"public boolean getEnabled()":{
			"methodBody":"{\n    checkWidget();\n    return OS.IsWindowEnabled(handle);\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver is enabled, and\n* <code>false</code> otherwise. A disabled control is typically\n* not selectable from the user interface and draws with an\n* inactive or \"grayed\" look.\n*\n* @return the receiver's enabled state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #isEnabled\n*/\n",
			"methodName":"public boolean getEnabled()"
		},
		"LRESULT wmMeasureChild(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT wmMeasureChild(int wParam, int lParam)"
		},
		"public Font getFont()":{
			"methodBody":"{\n    checkWidget();\n    int hFont = OS.SendMessage(handle, OS.WM_GETFONT, 0, 0);\n    if (hFont == 0)\n        hFont = defaultFont();\n    return Font.win32_new(display, hFont);\n}",
			"comments":"/**\n* Returns the font that the receiver will use to paint textual information.\n*\n* @return the receiver's font\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Font getFont()"
		},
		"void setBounds(int x, int y, int width, int height, int flags, boolean defer)":{
			"methodBody":"{\n    int topHandle = topHandle();\n    if (defer && parent != null) {\n        forceResize();\n        WINDOWPOS[] lpwp = parent.lpwp;\n        if (lpwp == null) {\n            \n            \n            \n            \n            \n            \n            SetWindowPos(topHandle, 0, x, y, width, height, flags);\n        } else {\n            int index = 0;\n            while (index < lpwp.length) {\n                if (lpwp[index] == null)\n                    break;\n                index++;\n            }\n            if (index == lpwp.length) {\n                WINDOWPOS[] newLpwp = new WINDOWPOS[lpwp.length + 4];\n                System.arraycopy(lpwp, 0, newLpwp, 0, lpwp.length);\n                parent.lpwp = lpwp = newLpwp;\n            }\n            WINDOWPOS wp = new WINDOWPOS();\n            wp.hwnd = topHandle;\n            wp.x = x;\n            wp.y = y;\n            wp.cx = width;\n            wp.cy = height;\n            wp.flags = flags;\n            lpwp[index] = wp;\n        }\n    } else {\n        SetWindowPos(topHandle, 0, x, y, width, height, flags);\n    }\n}",
			"comments":"/*\n* This code is intentionally commented.  All widgets that\n* are created by SWT have WS_CLIPSIBLINGS to ensure that\n* application code does not draw outside of the control.\n*/\n//\t\t\tint count = parent.getChildrenCount ();\n//\t\t\tif (count > 1) {\n//\t\t\t\tint bits = OS.GetWindowLong (handle, OS.GWL_STYLE);\n//\t\t\t\tif ((bits & OS.WS_CLIPSIBLINGS) == 0) flags |= OS.SWP_NOCOPYBITS;\n//\t\t\t}\n",
			"methodName":"void setBounds(int x, int y, int width, int height, int flags, boolean defer)"
		},
		"LRESULT WM_QUERYENDSESSION(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_QUERYENDSESSION(int wParam, int lParam)"
		},
		"int widgetExtStyle()":{
			"methodBody":"{\n    int bits = 0;\n    if (!OS.IsPPC) {\n        if ((style & SWT.BORDER) != 0)\n            bits |= OS.WS_EX_CLIENTEDGE;\n    }\n    \n    if (OS.WIN32_VERSION < OS.VERSION(4, 10)) {\n        return bits;\n    }\n    bits |= OS.WS_EX_NOINHERITLAYOUT;\n    if ((style & SWT.RIGHT_TO_LEFT) != 0)\n        bits |= OS.WS_EX_LAYOUTRTL;\n    return bits;\n}",
			"comments":"//\tif ((style & SWT.BORDER) != 0) {\n//\t\tif ((style & SWT.FLAT) == 0) bits |= OS.WS_EX_CLIENTEDGE;\n//\t}\n/*\n* Feature in Windows NT.  When CreateWindowEx() is called with\n* WS_EX_LAYOUTRTL or WS_EX_NOINHERITLAYOUT, CreateWindowEx()\n* fails to create the HWND. The fix is to not use these bits.\n*/\n",
			"methodName":"int widgetExtStyle()"
		},
		"LRESULT WM_CTLCOLOR(int wParam, int lParam)":{
			"methodBody":"{\n    int hPalette = display.hPalette;\n    if (hPalette != 0) {\n        OS.SelectPalette(wParam, hPalette, false);\n        OS.RealizePalette(wParam);\n    }\n    Control control = display.getControl(lParam);\n    if (control == null)\n        return null;\n    return control.wmColorChild(wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_CTLCOLOR(int wParam, int lParam)"
		},
		"public int getBorderWidth()":{
			"methodBody":"{\n    checkWidget();\n    int borderHandle = borderHandle();\n    int bits1 = OS.GetWindowLong(borderHandle, OS.GWL_EXSTYLE);\n    if ((bits1 & OS.WS_EX_CLIENTEDGE) != 0)\n        return OS.GetSystemMetrics(OS.SM_CXEDGE);\n    if ((bits1 & OS.WS_EX_STATICEDGE) != 0)\n        return OS.GetSystemMetrics(OS.SM_CXBORDER);\n    int bits2 = OS.GetWindowLong(borderHandle, OS.GWL_STYLE);\n    if ((bits2 & OS.WS_BORDER) != 0)\n        return OS.GetSystemMetrics(OS.SM_CXBORDER);\n    return 0;\n}",
			"comments":"/**\n* Returns the receiver's border width.\n*\n* @return the border width\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getBorderWidth()"
		},
		"Control[] computeTabList()":{
			"methodBody":"{\n    if (isTabGroup()) {\n        if (getVisible() && getEnabled()) {\n            return new Control[] { this };\n        }\n    }\n    return new Control[0];\n}",
			"comments":"",
			"methodName":"Control[] computeTabList()"
		},
		"boolean updateFont(Font oldFont, Font newFont)":{
			"methodBody":"{\n    boolean sameFont = getFont().equals(oldFont);\n    \n    if (sameFont)\n        setFont(newFont);\n    return sameFont;\n}",
			"comments":"/*\n* If the font that the control is using is the\n* same one that was being used from the Control\n* Panel, then use the new Control Panel font.\n*/\n",
			"methodName":"boolean updateFont(Font oldFont, Font newFont)"
		},
		"public void setSize(int width, int height)":{
			"methodBody":"{\n    checkWidget();\n    int flags = OS.SWP_NOMOVE | OS.SWP_NOZORDER | OS.SWP_DRAWFRAME | OS.SWP_NOACTIVATE;\n    setBounds(0, 0, Math.max(0, width), Math.max(0, height), flags);\n}",
			"comments":"/**\n* Sets the receiver's size to the point specified by the arguments.\n* <p>\n* Note: Attempting to set the width or height of the\n* receiver to a negative number will cause that\n* value to be set to zero instead.\n* </p>\n*\n* @param width the new width for the receiver\n* @param height the new height for the receiver\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setSize(int width, int height)"
		},
		"LRESULT WM_SYSCOLORCHANGE(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_SYSCOLORCHANGE(int wParam, int lParam)"
		},
		"boolean isActive()":{
			"methodBody":"{\n    Shell dialogShell = display.getModalDialogShell();\n    if (dialogShell != null && dialogShell != getShell()) {\n        return false;\n    }\n    Shell shell = null;\n    Shell[] modalShells = display.modalShells;\n    if (modalShells != null) {\n        int bits = SWT.APPLICATION_MODAL | SWT.SYSTEM_MODAL;\n        int index = modalShells.length;\n        while (--index >= 0) {\n            Shell modal = modalShells[index];\n            if (modal != null) {\n                if ((modal.style & bits) != 0) {\n                    Control control = this;\n                    while (control != null) {\n                        if (control == modal)\n                            break;\n                        control = control.parent;\n                    }\n                    if (control != modal)\n                        return false;\n                    break;\n                }\n                if ((modal.style & SWT.PRIMARY_MODAL) != 0) {\n                    if (shell == null)\n                        shell = getShell();\n                    if (modal.parent == shell)\n                        return false;\n                }\n            }\n        }\n    }\n    if (shell == null)\n        shell = getShell();\n    return shell.getEnabled();\n}",
			"comments":"",
			"methodName":"boolean isActive()"
		},
		"int topHandle()":{
			"methodBody":"{\n    return handle;\n}",
			"comments":"",
			"methodName":"int topHandle()"
		},
		"LRESULT WM_GETOBJECT(int wParam, int lParam)":{
			"methodBody":"{\n    if (accessible != null) {\n        int result = accessible.internal_WM_GETOBJECT(wParam, lParam);\n        if (result != 0)\n            return new LRESULT(result);\n    }\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_GETOBJECT(int wParam, int lParam)"
		},
		"LRESULT WM_HSCROLL(int wParam, int lParam)":{
			"methodBody":"{\n    if (lParam == 0)\n        return null;\n    Control control = display.getControl(lParam);\n    if (control == null)\n        return null;\n    return control.wmScrollChild(wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_HSCROLL(int wParam, int lParam)"
		},
		"boolean checkHandle(int hwnd)":{
			"methodBody":"{\n    return hwnd == handle;\n}",
			"comments":"",
			"methodName":"boolean checkHandle(int hwnd)"
		},
		"public boolean isVisible()":{
			"methodBody":"{\n    checkWidget();\n    if (OS.IsWindowVisible(handle))\n        return true;\n    return getVisible() && parent.isVisible();\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver is visible and all\n* ancestors up to and including the receiver's nearest ancestor\n* shell are visible. Otherwise, <code>false</code> is returned.\n*\n* @return the receiver's visibility state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #getVisible\n*/\n",
			"methodName":"public boolean isVisible()"
		},
		"public Menu getMenu()":{
			"methodBody":"{\n    checkWidget();\n    return menu;\n}",
			"comments":"/**\n* Returns the receiver's pop up menu if it has one, or null\n* if it does not. All controls may optionally have a pop up\n* menu that is displayed when the user requests one for\n* the control. The sequence of key strokes, button presses\n* and/or button releases that are used to request a pop up\n* menu is platform specific.\n*\n* @return the receiver's menu\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Menu getMenu()"
		},
		"LRESULT WM_NCACTIVATE(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_NCACTIVATE(int wParam, int lParam)"
		},
		"LRESULT wmNotifyChild(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT wmNotifyChild(int wParam, int lParam)"
		},
		"Control computeTabRoot()":{
			"methodBody":"{\n    Control[] tabList = parent._getTabList();\n    if (tabList != null) {\n        int index = 0;\n        while (index < tabList.length) {\n            if (tabList[index] == this)\n                break;\n            index++;\n        }\n        if (index == tabList.length) {\n            if (isTabGroup())\n                return this;\n        }\n    }\n    return parent.computeTabRoot();\n}",
			"comments":"",
			"methodName":"Control computeTabRoot()"
		},
		"void setBackgroundPixel(int pixel)":{
			"methodBody":"{\n    if (background == pixel)\n        return;\n    background = pixel;\n    if (OS.IsWinCE) {\n        OS.InvalidateRect(handle, null, true);\n    } else {\n        int flags = OS.RDW_ERASE | OS.RDW_FRAME | OS.RDW_INVALIDATE;\n        OS.RedrawWindow(handle, null, 0, flags);\n    }\n}",
			"comments":"",
			"methodName":"void setBackgroundPixel(int pixel)"
		},
		"public Point toDisplay(Point point)":{
			"methodBody":"{\n    checkWidget();\n    if (point == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    return toDisplay(point.x, point.y);\n}",
			"comments":"/**\n* Returns a point which is the result of converting the\n* argument, which is specified in coordinates relative to\n* the receiver, to display relative coordinates.\n* <p>\n* @param point the point to be translated (must not be null)\n* @return the translated coordinates\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the point is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Point toDisplay(Point point)"
		},
		"LRESULT WM_CLEAR(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_CLEAR(int wParam, int lParam)"
		},
		"Menu[] findMenus(Control control)":{
			"methodBody":"{\n    if (menu != null && this != control)\n        return new Menu[] { menu };\n    return new Menu[0];\n}",
			"comments":"",
			"methodName":"Menu[] findMenus(Control control)"
		},
		"LRESULT WM_HELP(int wParam, int lParam)":{
			"methodBody":"{\n    if (OS.IsWinCE)\n        return null;\n    HELPINFO lphi = new HELPINFO();\n    OS.MoveMemory(lphi, lParam, HELPINFO.sizeof);\n    Decorations shell = menuShell();\n    if (!shell.isEnabled())\n        return null;\n    if (lphi.iContextType == OS.HELPINFO_MENUITEM) {\n        MenuItem item = display.getMenuItem(lphi.iCtrlId);\n        if (item != null && item.isEnabled()) {\n            Widget widget = null;\n            if (item.hooks(SWT.Help)) {\n                widget = item;\n            } else {\n                Menu menu = item.parent;\n                if (menu.hooks(SWT.Help))\n                    widget = menu;\n            }\n            if (widget != null) {\n                int hwndShell = shell.handle;\n                OS.SendMessage(hwndShell, OS.WM_CANCELMODE, 0, 0);\n                widget.postEvent(SWT.Help);\n                return LRESULT.ONE;\n            }\n        }\n        return null;\n    }\n    if (hooks(SWT.Help)) {\n        postEvent(SWT.Help);\n        return LRESULT.ONE;\n    }\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_HELP(int wParam, int lParam)"
		},
		"int defaultFont()":{
			"methodBody":"{\n    return display.systemFont();\n}",
			"comments":"",
			"methodName":"int defaultFont()"
		},
		"LRESULT WM_NOTIFY(int wParam, int lParam)":{
			"methodBody":"{\n    NMHDR hdr = new NMHDR();\n    OS.MoveMemory(hdr, lParam, NMHDR.sizeof);\n    int hwnd = hdr.hwndFrom;\n    if (hwnd == 0)\n        return null;\n    Control control = display.getControl(hwnd);\n    if (control == null)\n        return null;\n    return control.wmNotifyChild(wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_NOTIFY(int wParam, int lParam)"
		},
		"public void removeMouseTrackListener(MouseTrackListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.MouseEnter, listener);\n    eventTable.unhook(SWT.MouseExit, listener);\n    eventTable.unhook(SWT.MouseHover, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when the mouse passes or hovers over controls.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see MouseTrackListener\n* @see #addMouseTrackListener\n*/\n",
			"methodName":"public void removeMouseTrackListener(MouseTrackListener listener)"
		},
		"LRESULT WM_COMMAND(int wParam, int lParam)":{
			"methodBody":"{\n    \n    if (lParam == 0) {\n        Decorations shell = menuShell();\n        if (shell.isEnabled()) {\n            int id = wParam & 0xFFFF;\n            MenuItem item = display.getMenuItem(id);\n            if (item != null && item.isEnabled()) {\n                return item.wmCommandChild(wParam, lParam);\n            }\n        }\n        return null;\n    }\n    Control control = display.getControl(lParam);\n    if (control == null)\n        return null;\n    return control.wmCommandChild(wParam, lParam);\n}",
			"comments":"/*\n* When the WM_COMMAND message is sent from a\n* menu, the HWND parameter in LPARAM is zero.\n*/\n",
			"methodName":"LRESULT WM_COMMAND(int wParam, int lParam)"
		},
		"public int internal_new_GC(GCData data)":{
			"methodBody":"{\n    checkWidget();\n    int hwnd = handle;\n    if (data != null && data.hwnd != 0)\n        hwnd = data.hwnd;\n    if (data != null)\n        data.hwnd = hwnd;\n    int hDC = 0;\n    if (data == null || data.ps == null) {\n        hDC = OS.GetDC(hwnd);\n    } else {\n        hDC = OS.BeginPaint(hwnd, data.ps);\n    }\n    if (hDC == 0)\n        SWT.error(SWT.ERROR_NO_HANDLES);\n    if (data != null) {\n        if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION(4, 10)) {\n            int mask = SWT.LEFT_TO_RIGHT | SWT.RIGHT_TO_LEFT;\n            if ((data.style & mask) != 0) {\n                data.layout = (data.style & SWT.RIGHT_TO_LEFT) != 0 ? OS.LAYOUT_RTL : 0;\n            } else {\n                int flags = OS.GetLayout(hDC);\n                if ((flags & OS.LAYOUT_RTL) != 0) {\n                    data.style |= SWT.RIGHT_TO_LEFT | SWT.MIRRORED;\n                } else {\n                    data.style |= SWT.LEFT_TO_RIGHT;\n                }\n            }\n        } else {\n            data.style |= SWT.LEFT_TO_RIGHT;\n        }\n        data.device = display;\n        data.foreground = getForegroundPixel();\n        data.background = getBackgroundPixel();\n        data.hFont = OS.SendMessage(hwnd, OS.WM_GETFONT, 0, 0);\n    }\n    return hDC;\n}",
			"comments":"/**\n* Invokes platform specific functionality to allocate a new GC handle.\n* <p>\n* <b>IMPORTANT:</b> This method is <em>not</em> part of the public\n* API for <code>Control</code>. It is marked public only so that it\n* can be shared within the packages provided by SWT. It is not\n* available on all platforms, and should never be called from\n* application code.\n* </p>\n*\n* @param data the platform specific GC data\n* @return the platform specific GC handle\n*/\n",
			"methodName":"public int internal_new_GC(GCData data)"
		},
		"LRESULT WM_LBUTTONDOWN(int wParam, int lParam)":{
			"methodBody":"{\n    return wmLButtonDown(handle, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_LBUTTONDOWN(int wParam, int lParam)"
		},
		"public void setBackground(Color color)":{
			"methodBody":"{\n    checkWidget();\n    int pixel = -1;\n    if (color != null) {\n        if (color.isDisposed())\n            SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n        pixel = color.handle;\n    }\n    setBackgroundPixel(pixel);\n}",
			"comments":"/**\n* Sets the receiver's background color to the color specified\n* by the argument, or to the default system color for the control\n* if the argument is null.\n*\n* @param color the new color (or null)\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setBackground(Color color)"
		},
		"boolean traverseGroup(boolean next)":{
			"methodBody":"{\n    Control root = computeTabRoot();\n    Control group = computeTabGroup();\n    Control[] list = root.computeTabList();\n    int length = list.length;\n    int index = 0;\n    while (index < length) {\n        if (list[index] == group)\n            break;\n        index++;\n    }\n    \n    if (index == length)\n        return false;\n    int start = index, offset = (next) ? 1 : -1;\n    while ((index = ((index + offset + length) % length)) != start) {\n        Control control = list[index];\n        if (!control.isDisposed() && control.setTabGroupFocus()) {\n            return true;\n        }\n    }\n    if (group.isDisposed())\n        return false;\n    return group.setTabGroupFocus();\n}",
			"comments":"/*\n* It is possible (but unlikely), that application\n* code could have disposed the widget in focus in\n* or out events.  Ensure that a disposed widget is\n* not accessed.\n*/\n",
			"methodName":"boolean traverseGroup(boolean next)"
		},
		"LRESULT WM_XBUTTONDBLCLK(int wParam, int lParam)":{
			"methodBody":"{\n    return wmXButtonDblClk(handle, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_XBUTTONDBLCLK(int wParam, int lParam)"
		},
		"Control findThemeControl()":{
			"methodBody":"{\n    return background == -1 ? parent.findThemeControl() : null;\n}",
			"comments":"",
			"methodName":"Control findThemeControl()"
		},
		"boolean hasCursor()":{
			"methodBody":"{\n    RECT rect = new RECT();\n    if (!OS.GetClientRect(handle, rect))\n        return false;\n    OS.MapWindowPoints(handle, 0, rect, 2);\n    POINT pt = new POINT();\n    return OS.GetCursorPos(pt) && OS.PtInRect(rect, pt);\n}",
			"comments":"",
			"methodName":"boolean hasCursor()"
		},
		"abstract TCHAR windowClass()":{
			"methodBody":"",
			"comments":"",
			"methodName":"abstract TCHAR windowClass()"
		},
		"public Monitor getMonitor()":{
			"methodBody":"{\n    checkWidget();\n    if (OS.IsWinCE || OS.WIN32_VERSION < OS.VERSION(4, 10)) {\n        return display.getPrimaryMonitor();\n    }\n    int hmonitor = OS.MonitorFromWindow(handle, OS.MONITOR_DEFAULTTONEAREST);\n    MONITORINFO lpmi = new MONITORINFO();\n    lpmi.cbSize = MONITORINFO.sizeof;\n    OS.GetMonitorInfo(hmonitor, lpmi);\n    Monitor monitor = new Monitor();\n    monitor.handle = hmonitor;\n    monitor.x = lpmi.rcMonitor_left;\n    monitor.y = lpmi.rcMonitor_top;\n    monitor.width = lpmi.rcMonitor_right - lpmi.rcMonitor_left;\n    monitor.height = lpmi.rcMonitor_bottom - lpmi.rcMonitor_top;\n    monitor.clientX = lpmi.rcWork_left;\n    monitor.clientY = lpmi.rcWork_top;\n    monitor.clientWidth = lpmi.rcWork_right - lpmi.rcWork_left;\n    monitor.clientHeight = lpmi.rcWork_bottom - lpmi.rcWork_top;\n    return monitor;\n}",
			"comments":"/**\n* Returns the receiver's monitor.\n*\n* @return the receiver's monitor\n*\n* @since 3.0\n*/\n",
			"methodName":"public Monitor getMonitor()"
		},
		"LRESULT WM_SYSKEYUP(int wParam, int lParam)":{
			"methodBody":"{\n    return wmSysKeyUp(handle, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_SYSKEYUP(int wParam, int lParam)"
		},
		"LRESULT WM_KILLFOCUS(int wParam, int lParam)":{
			"methodBody":"{\n    return wmKillFocus(handle, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_KILLFOCUS(int wParam, int lParam)"
		},
		"void checkBuffered()":{
			"methodBody":"{\n    style &= ~SWT.DOUBLE_BUFFERED;\n}",
			"comments":"",
			"methodName":"void checkBuffered()"
		},
		"public void addMouseListener(MouseListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.MouseDown, typedListener);\n    addListener(SWT.MouseUp, typedListener);\n    addListener(SWT.MouseDoubleClick, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when mouse buttons are pressed and released, by sending\n* it one of the messages defined in the <code>MouseListener</code>\n* interface.\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see MouseListener\n* @see #removeMouseListener\n*/\n",
			"methodName":"public void addMouseListener(MouseListener listener)"
		},
		"LRESULT WM_INITMENUPOPUP(int wParam, int lParam)":{
			"methodBody":"{\n    \n    if (display.accelKeyHit)\n        return null;\n    \n    Shell shell = getShell();\n    Menu oldMenu = shell.activeMenu, newMenu = null;\n    if ((lParam >> 16) == 0) {\n        newMenu = menuShell().findMenu(wParam);\n        if (newMenu != null)\n            newMenu.update();\n    }\n    Menu menu = newMenu;\n    while (menu != null && menu != oldMenu) {\n        menu = menu.getParentMenu();\n    }\n    if (menu == null) {\n        menu = shell.activeMenu;\n        while (menu != null) {\n            \n            menu.sendEvent(SWT.Hide);\n            if (menu.isDisposed())\n                break;\n            menu = menu.getParentMenu();\n            Menu ancestor = newMenu;\n            while (ancestor != null && ancestor != menu) {\n                ancestor = ancestor.getParentMenu();\n            }\n            if (ancestor != null)\n                break;\n        }\n    }\n    \n    if (newMenu != null && newMenu.isDisposed())\n        newMenu = null;\n    shell.activeMenu = newMenu;\n    \n    if (newMenu != null && newMenu != oldMenu) {\n        newMenu.sendEvent(SWT.Show);\n    \n    }\n    return null;\n}",
			"comments":"/* Ignore WM_INITMENUPOPUP for an accelerator */\n/*\n* If the high order word of LPARAM is non-zero,\n* the menu is the system menu and we can ignore\n* WPARAM.  Otherwise, use WPARAM to find the menu.\n*/\n/*\n* It is possible (but unlikely), that application\n* code could have disposed the widget in the hide\n* event.  If this happens, stop searching up the\n* ancestor list because there is no longer a link\n* to follow.\n*/\n/*\n* The shell and the new menu may be disposed because of\n* sending the hide event to the ancestor menus but setting\n* a field to null in a disposed shell is not harmful.\n*/\n/* Send the show event */\n// widget could be disposed at this point\n",
			"methodName":"LRESULT WM_INITMENUPOPUP(int wParam, int lParam)"
		},
		"public void setLayoutData(Object layoutData)":{
			"methodBody":"{\n    checkWidget();\n    this.layoutData = layoutData;\n}",
			"comments":"/**\n* Sets the layout data associated with the receiver to the argument.\n*\n* @param layoutData the new layout data for the receiver.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setLayoutData(Object layoutData)"
		},
		"LRESULT WM_UNDO(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_UNDO(int wParam, int lParam)"
		},
		"void sort(int[] items)":{
			"methodBody":"{\n    \n    int length = items.length;\n    for (int gap = length / 2; gap > 0; gap /= 2) {\n        for (int i = gap; i < length; i++) {\n            for (int j = i - gap; j >= 0; j -= gap) {\n                if (items[j] <= items[j + gap]) {\n                    int swap = items[j];\n                    items[j] = items[j + gap];\n                    items[j + gap] = swap;\n                }\n            }\n        }\n    }\n}",
			"comments":"/* Shell Sort from K&R, pg 108 */\n",
			"methodName":"void sort(int[] items)"
		},
		"LRESULT WM_KEYDOWN(int wParam, int lParam)":{
			"methodBody":"{\n    return wmKeyDown(handle, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_KEYDOWN(int wParam, int lParam)"
		},
		"LRESULT WM_RBUTTONUP(int wParam, int lParam)":{
			"methodBody":"{\n    return wmRButtonUp(handle, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_RBUTTONUP(int wParam, int lParam)"
		}
	},
	"ClassORInterfaceName":[
		"Control"
	]
}
