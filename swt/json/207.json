{
	"variables":[
		"DefaultLuminanceQTable",
		"DefaultChrominanceQTable",
		"data",
		"data",
		"keys",
		"keysIndex",
		"totalLength",
		"ofs",
		"tq",
		"pq",
		"newKeys",
		"newKeys",
		"values",
		"valuesIndex",
		"totalLength",
		"ofs",
		"qk",
		"pq",
		"i",
		"i",
		"idx",
		"newValues",
		"newValues",
		"qFactor",
		"totalLength",
		"ofs",
		"pq",
		"i",
		"temp",
		"i",
		"temp",
		"reference",
		"byteStream",
		"DefaultChrominanceQTable",
		"System",
		"DefaultChrominanceQTable",
		"data",
		"data",
		"data",
		"DefaultLuminanceQTable",
		"System",
		"DefaultLuminanceQTable",
		"data",
		"data",
		"data",
		"totalLength",
		"reference",
		"ofs",
		"reference",
		"ofs",
		"pq",
		"ofs",
		"totalLength",
		"ofs",
		"totalLength",
		"keysIndex",
		"keys",
		"keys",
		"System",
		"keys",
		"newKeys",
		"keys",
		"keys",
		"newKeys",
		"keys",
		"keysIndex",
		"tq",
		"keysIndex",
		"keysIndex",
		"System",
		"keys",
		"newKeys",
		"keysIndex",
		"newKeys",
		"totalLength",
		"reference",
		"ofs",
		"pq",
		"i",
		"qk",
		"i",
		"qk",
		"i",
		"reference",
		"ofs",
		"i",
		"ofs",
		"totalLength",
		"i",
		"qk",
		"i",
		"i",
		"qk",
		"i",
		"reference",
		"ofs",
		"idx",
		"reference",
		"ofs",
		"idx",
		"ofs",
		"totalLength",
		"valuesIndex",
		"values",
		"values",
		"System",
		"values",
		"newValues",
		"values",
		"values",
		"newValues",
		"values",
		"valuesIndex",
		"qk",
		"valuesIndex",
		"valuesIndex",
		"System",
		"values",
		"newValues",
		"valuesIndex",
		"newValues",
		"qualityFactor",
		"qFactor",
		"qFactor",
		"qFactor",
		"qFactor",
		"qFactor",
		"qFactor",
		"qFactor",
		"qFactor",
		"qFactor",
		"totalLength",
		"reference",
		"ofs",
		"pq",
		"ofs",
		"i",
		"ofs",
		"i",
		"reference",
		"i",
		"qFactor",
		"temp",
		"temp",
		"temp",
		"temp",
		"reference",
		"i",
		"temp",
		"ofs",
		"totalLength",
		"ofs",
		"i",
		"ofs",
		"i",
		"reference",
		"i",
		"reference",
		"i",
		"qFactor",
		"temp",
		"temp",
		"temp",
		"temp",
		"reference",
		"i",
		"temp",
		"reference",
		"i",
		"temp",
		"ofs",
		"totalLength",
		"JPEGFileFormat",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"DQT",
		"reference",
		"byteStream",
		"qualityFactor"
	],
	"extendORImplementFiles":[
		"JPEGVariableSizeSegment"
	],
	"package":[
		"org.eclipse.swt.internal.image"
	],
	"import":[],
	"methods":[
		"defaultChrominanceTable",
		"defaultLuminanceTable",
		"getQuantizationTablesKeys",
		"getQuantizationTablesValues",
		"scaleBy",
		"signature",
		"arraycopy",
		"arraycopy",
		"getSegmentLength",
		"arraycopy",
		"arraycopy",
		"getSegmentLength",
		"arraycopy",
		"arraycopy",
		"getSegmentLength",
		"JPEGQuantizationTable",
		"JPEGQuantizationTable"
	],
	"methodsBody":{
		"public static JPEGQuantizationTable defaultChrominanceTable()":{
			"methodBody":"{\n    byte[] data = new byte[DefaultChrominanceQTable.length];\n    System.arraycopy(DefaultChrominanceQTable, 0, data, 0, data.length);\n    return new JPEGQuantizationTable(data);\n}",
			"comments":"",
			"methodName":"public static JPEGQuantizationTable defaultChrominanceTable()"
		},
		"public int[][] getQuantizationTablesValues()":{
			"methodBody":"{\n    int[][] values = new int[4][];\n    int valuesIndex = 0;\n    int totalLength = getSegmentLength() - 2;\n    int ofs = 4;\n    while (totalLength > 64) {\n        int[] qk = new int[64];\n        int pq = (reference[ofs] & 0xFF) / 16;\n        if (pq == 0) {\n            for (int i = 0; i < qk.length; i++) {\n                qk[i] = reference[ofs + i + 1];\n            }\n            ofs += 65;\n            totalLength -= 65;\n        } else {\n            for (int i = 0; i < qk.length; i++) {\n                int idx = (i - 1) * 2;\n                qk[i] = (reference[ofs + idx + 1] & 0xFF) * 256 + (reference[ofs + idx + 2] & 0xFF);\n            }\n            ofs += 129;\n            totalLength -= 129;\n        }\n        if (valuesIndex >= values.length) {\n            int[][] newValues = new int[values.length + 4][];\n            System.arraycopy(values, 0, newValues, 0, values.length);\n            values = newValues;\n        }\n        values[valuesIndex] = qk;\n        valuesIndex++;\n    }\n    int[][] newValues = new int[valuesIndex][];\n    System.arraycopy(values, 0, newValues, 0, valuesIndex);\n    return newValues;\n}",
			"comments":"",
			"methodName":"public int[][] getQuantizationTablesValues()"
		},
		"public void scaleBy(int qualityFactor)":{
			"methodBody":"{\n    int qFactor = qualityFactor;\n    if (qFactor <= 0) {\n        qFactor = 1;\n    }\n    if (qFactor > 100) {\n        qFactor = 100;\n    }\n    if (qFactor < 50) {\n        qFactor = 5000 / qFactor;\n    } else {\n        qFactor = 200 - (qFactor * 2);\n    }\n    int totalLength = getSegmentLength() - 2;\n    int ofs = 4;\n    while (totalLength > 64) {\n        \n        int pq = (reference[ofs] & 0xFF) / 16;\n        if (pq == 0) {\n            for (int i = ofs + 1; i <= ofs + 64; i++) {\n                int temp = ((reference[i] & 0xFF) * qFactor + 50) / 100;\n                if (temp <= 0)\n                    temp = 1;\n                if (temp > 255)\n                    temp = 255;\n                reference[i] = (byte) temp;\n            }\n            ofs += 65;\n            totalLength -= 65;\n        } else {\n            for (int i = ofs + 1; i <= ofs + 128; i += 2) {\n                int temp = (((reference[i] & 0xFF) * 256 + (reference[i + 1] & 0xFF)) * qFactor + 50) / 100;\n                if (temp <= 0)\n                    temp = 1;\n                if (temp > 32767)\n                    temp = 32767;\n                reference[i] = (byte) (temp / 256);\n                reference[i + 1] = (byte) (temp % 256);\n            }\n            ofs += 129;\n            totalLength -= 129;\n        }\n    }\n}",
			"comments":"//\t\tint tq = (reference[ofs] & 0xFF) % 16;\n",
			"methodName":"public void scaleBy(int qualityFactor)"
		},
		"public int signature()":{
			"methodBody":"{\n    return JPEGFileFormat.DQT;\n}",
			"comments":"",
			"methodName":"public int signature()"
		},
		"public static JPEGQuantizationTable defaultLuminanceTable()":{
			"methodBody":"{\n    byte[] data = new byte[DefaultLuminanceQTable.length];\n    System.arraycopy(DefaultLuminanceQTable, 0, data, 0, data.length);\n    return new JPEGQuantizationTable(data);\n}",
			"comments":"",
			"methodName":"public static JPEGQuantizationTable defaultLuminanceTable()"
		},
		"public int[] getQuantizationTablesKeys()":{
			"methodBody":"{\n    int[] keys = new int[4];\n    int keysIndex = 0;\n    int totalLength = getSegmentLength() - 2;\n    int ofs = 4;\n    while (totalLength > 64) {\n        int tq = (reference[ofs] & 0xFF) % 16;\n        int pq = (reference[ofs] & 0xFF) / 16;\n        if (pq == 0) {\n            ofs += 65;\n            totalLength -= 65;\n        } else {\n            ofs += 129;\n            totalLength -= 129;\n        }\n        if (keysIndex >= keys.length) {\n            int[] newKeys = new int[keys.length + 4];\n            System.arraycopy(keys, 0, newKeys, 0, keys.length);\n            keys = newKeys;\n        }\n        keys[keysIndex] = tq;\n        keysIndex++;\n    }\n    int[] newKeys = new int[keysIndex];\n    System.arraycopy(keys, 0, newKeys, 0, keysIndex);\n    return newKeys;\n}",
			"comments":"",
			"methodName":"public int[] getQuantizationTablesKeys()"
		}
	},
	"ClassORInterfaceName":[
		"JPEGQuantizationTable"
	]
}
