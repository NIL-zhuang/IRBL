{
	"variables":[
		"handle",
		"x",
		"y",
		"hwndCB",
		"id0",
		"id1",
		"hasLocation",
		"cascade",
		"parent",
		"imageList",
		"ID_PPC",
		"ID_SPMM",
		"ID_SPBM",
		"ID_SPMB",
		"ID_SPBB",
		"ID_SPSOFTKEY0",
		"ID_SPSOFTKEY1",
		"hwndParent",
		"flags",
		"nX",
		"nY",
		"pos",
		"success",
		"typedListener",
		"typedListener",
		"hwndShell",
		"mbi",
		"success",
		"nToolBarId",
		"mbi",
		"info",
		"item",
		"hMenu",
		"menu",
		"hMenu",
		"menu",
		"dwMask",
		"lParam",
		"hwndShell",
		"count",
		"success",
		"lpButton",
		"uFlags",
		"lpNewItem",
		"info",
		"hHeap",
		"buffer",
		"byteCount",
		"pszText",
		"info",
		"index",
		"count",
		"index",
		"info",
		"hMenu",
		"hCB",
		"items",
		"i",
		"hwndShell",
		"info",
		"width",
		"height",
		"count",
		"rect1",
		"rect2",
		"x",
		"y",
		"width",
		"height",
		"id",
		"info",
		"id",
		"lpButton",
		"result",
		"info",
		"result",
		"count",
		"lpButton",
		"result",
		"i",
		"count",
		"length",
		"items",
		"info",
		"newItems",
		"result",
		"count",
		"info",
		"result",
		"items",
		"length",
		"i",
		"popups",
		"i",
		"shell",
		"menu",
		"hOldList",
		"bounds",
		"hImageList",
		"index",
		"index",
		"info",
		"parentMenu",
		"items",
		"i",
		"item",
		"newID",
		"oldID",
		"menuBar",
		"menu",
		"hasCheck",
		"hasImage",
		"items",
		"i",
		"item",
		"info",
		"i",
		"item",
		"lpcmi",
		"parent",
		"SWT",
		"parent",
		"style",
		"parentMenu",
		"SWT",
		"parentItem",
		"parent",
		"style",
		"parent",
		"handle",
		"parent",
		"style",
		"SWT",
		"SWT",
		"parent",
		"visible",
		"OS",
		"OS",
		"OS",
		"flags",
		"OS",
		"style",
		"SWT",
		"flags",
		"OS",
		"parent",
		"SWT",
		"flags",
		"OS",
		"style",
		"SWT",
		"flags",
		"OS",
		"x",
		"y",
		"hasLocation",
		"OS",
		"nX",
		"pos",
		"nY",
		"pos",
		"OS",
		"handle",
		"flags",
		"nX",
		"nY",
		"hwndParent",
		"success",
		"handle",
		"OS",
		"hwndParent",
		"OS",
		"OS",
		"hwndParent",
		"OS",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"SWT",
		"typedListener",
		"control",
		"SWT",
		"SWT",
		"control",
		"menu",
		"SWT",
		"SWT",
		"menu",
		"item",
		"SWT",
		"SWT",
		"item",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"handle",
		"style",
		"SWT",
		"OS",
		"parent",
		"mbi",
		"SHMENUBARINFO",
		"mbi",
		"hwndShell",
		"mbi",
		"OS",
		"mbi",
		"ID_PPC",
		"mbi",
		"OS",
		"OS",
		"mbi",
		"hwndCB",
		"mbi",
		"success",
		"SWT",
		"OS",
		"hwndCB",
		"OS",
		"OS",
		"style",
		"SWT",
		"nToolBarId",
		"style",
		"SWT",
		"ID_SPBB",
		"ID_SPBM",
		"nToolBarId",
		"style",
		"SWT",
		"ID_SPMB",
		"ID_SPMM",
		"mbi",
		"SHMENUBARINFO",
		"mbi",
		"parent",
		"mbi",
		"OS",
		"mbi",
		"nToolBarId",
		"mbi",
		"OS",
		"OS",
		"mbi",
		"SWT",
		"hwndCB",
		"mbi",
		"OS",
		"hwndCB",
		"OS",
		"info",
		"TBBUTTONINFO",
		"info",
		"OS",
		"nToolBarId",
		"ID_SPMM",
		"nToolBarId",
		"ID_SPMB",
		"OS",
		"hwndCB",
		"OS",
		"ID_SPSOFTKEY0",
		"OS",
		"hMenu",
		"OS",
		"parent",
		"SWT",
		"hMenu",
		"item",
		"menu",
		"SWT",
		"item",
		"SWT",
		"info",
		"id0",
		"item",
		"OS",
		"hwndCB",
		"OS",
		"ID_SPSOFTKEY0",
		"info",
		"nToolBarId",
		"ID_SPMM",
		"nToolBarId",
		"ID_SPBM",
		"OS",
		"hwndCB",
		"OS",
		"ID_SPSOFTKEY1",
		"OS",
		"hMenu",
		"OS",
		"parent",
		"SWT",
		"hMenu",
		"item",
		"menu",
		"SWT",
		"item",
		"SWT",
		"info",
		"id1",
		"item",
		"OS",
		"hwndCB",
		"OS",
		"ID_SPSOFTKEY1",
		"info",
		"OS",
		"OS",
		"dwMask",
		"dwMask",
		"OS",
		"hwndCB",
		"OS",
		"OS",
		"lParam",
		"handle",
		"OS",
		"handle",
		"SWT",
		"OS",
		"parent",
		"hwndCB",
		"OS",
		"OS",
		"hwndShell",
		"hwndCB",
		"SWT",
		"OS",
		"hwndCB",
		"OS",
		"hwndCB",
		"handle",
		"parent",
		"SWT",
		"parent",
		"SWT",
		"OS",
		"hwndCB",
		"handle",
		"OS",
		"handle",
		"SWT",
		"handle",
		"index",
		"index",
		"count",
		"SWT",
		"display",
		"item",
		"OS",
		"OS",
		"hwndCB",
		"OS",
		"lpButton",
		"item",
		"lpButton",
		"OS",
		"item",
		"SWT",
		"lpButton",
		"OS",
		"item",
		"SWT",
		"lpButton",
		"OS",
		"lpButton",
		"OS",
		"lpButton",
		"OS",
		"success",
		"OS",
		"hwndCB",
		"OS",
		"index",
		"lpButton",
		"OS",
		"OS",
		"item",
		"SWT",
		"uFlags",
		"OS",
		"lpNewItem",
		"success",
		"OS",
		"handle",
		"index",
		"uFlags",
		"item",
		"lpNewItem",
		"success",
		"info",
		"MENUITEMINFO",
		"info",
		"OS",
		"info",
		"item",
		"success",
		"OS",
		"handle",
		"index",
		"info",
		"OS",
		"buffer",
		"TCHAR",
		"OS",
		"hHeap",
		"OS",
		"byteCount",
		"OS",
		"pszText",
		"buffer",
		"byteCount",
		"info",
		"MENUITEMINFO",
		"info",
		"OS",
		"OS",
		"OS",
		"info",
		"info",
		"item",
		"info",
		"item",
		"info",
		"pszText",
		"success",
		"OS",
		"handle",
		"index",
		"info",
		"pszText",
		"OS",
		"hHeap",
		"pszText",
		"success",
		"display",
		"item",
		"SWT",
		"parent",
		"OS",
		"OS",
		"OS",
		"OS",
		"parent",
		"OS",
		"OS",
		"OS",
		"hwndCB",
		"OS",
		"OS",
		"hwndCB",
		"OS",
		"item",
		"OS",
		"hwndCB",
		"OS",
		"index",
		"SWT",
		"OS",
		"hwndCB",
		"OS",
		"count",
		"imageList",
		"OS",
		"handle",
		"OS",
		"display",
		"imageList",
		"imageList",
		"info",
		"MENUITEMINFO",
		"info",
		"OS",
		"OS",
		"handle",
		"index",
		"info",
		"info",
		"item",
		"index",
		"info",
		"item",
		"SWT",
		"OS",
		"handle",
		"index",
		"OS",
		"SWT",
		"OS",
		"handle",
		"item",
		"OS",
		"SWT",
		"handle",
		"hwndCB",
		"OS",
		"hCB",
		"OS",
		"hCB",
		"hMenu",
		"OS",
		"hMenu",
		"i",
		"items",
		"i",
		"items",
		"i",
		"newParent",
		"parent",
		"newParent",
		"newParent",
		"OS",
		"style",
		"SWT",
		"parent",
		"parent",
		"info",
		"MENUBARINFO",
		"OS",
		"hwndShell",
		"OS",
		"info",
		"info",
		"info",
		"info",
		"info",
		"info",
		"info",
		"width",
		"height",
		"handle",
		"count",
		"OS",
		"handle",
		"rect1",
		"OS",
		"handle",
		"count",
		"rect2",
		"rect1",
		"rect1",
		"rect2",
		"rect2",
		"rect2",
		"rect1",
		"x",
		"y",
		"width",
		"height",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"id",
		"info",
		"MENUITEMINFO",
		"info",
		"OS",
		"OS",
		"handle",
		"id",
		"info",
		"display",
		"info",
		"state",
		"DISABLED",
		"OS",
		"OS",
		"hwndCB",
		"OS",
		"OS",
		"hwndCB",
		"OS",
		"index",
		"lpButton",
		"result",
		"SWT",
		"id",
		"lpButton",
		"OS",
		"index",
		"index",
		"SWT",
		"id",
		"index",
		"id0",
		"id1",
		"info",
		"MENUITEMINFO",
		"info",
		"OS",
		"OS",
		"handle",
		"index",
		"info",
		"SWT",
		"id",
		"info",
		"display",
		"id",
		"handle",
		"OS",
		"OS",
		"hwndCB",
		"OS",
		"result",
		"display",
		"id0",
		"result",
		"display",
		"id1",
		"result",
		"OS",
		"hwndCB",
		"OS",
		"count",
		"i",
		"count",
		"i",
		"OS",
		"hwndCB",
		"OS",
		"i",
		"lpButton",
		"result",
		"i",
		"display",
		"lpButton",
		"result",
		"OS",
		"OS",
		"handle",
		"length",
		"info",
		"MENUITEMINFO",
		"info",
		"OS",
		"OS",
		"handle",
		"count",
		"info",
		"count",
		"items",
		"count",
		"System",
		"items",
		"newItems",
		"count",
		"items",
		"newItems",
		"items",
		"count",
		"display",
		"info",
		"count",
		"items",
		"items",
		"count",
		"System",
		"items",
		"result",
		"count",
		"result",
		"OS",
		"OS",
		"OS",
		"hwndCB",
		"OS",
		"OS",
		"hwndCB",
		"OS",
		"info",
		"MENUITEMINFO",
		"OS",
		"handle",
		"count",
		"info",
		"count",
		"count",
		"OS",
		"handle",
		"items",
		"length",
		"i",
		"length",
		"i",
		"result",
		"result",
		"items",
		"i",
		"result",
		"result",
		"items",
		"length",
		"result",
		"parent",
		"cascade",
		"cascade",
		"cascade",
		"parent",
		"style",
		"SWT",
		"parent",
		"style",
		"SWT",
		"display",
		"popups",
		"i",
		"popups",
		"i",
		"popups",
		"i",
		"shell",
		"menu",
		"menu",
		"menu",
		"menu",
		"menu",
		"hwndCB",
		"image",
		"OS",
		"imageList",
		"OS",
		"hwndCB",
		"OS",
		"hOldList",
		"OS",
		"hOldList",
		"image",
		"imageList",
		"display",
		"style",
		"SWT",
		"bounds",
		"bounds",
		"imageList",
		"OS",
		"hwndCB",
		"OS",
		"hImageList",
		"imageList",
		"image",
		"index",
		"index",
		"imageList",
		"image",
		"imageList",
		"index",
		"image",
		"index",
		"item",
		"SWT",
		"item",
		"SWT",
		"item",
		"OS",
		"OS",
		"hwndCB",
		"OS",
		"OS",
		"hwndCB",
		"OS",
		"item",
		"OS",
		"item",
		"id0",
		"item",
		"id1",
		"info",
		"MENUITEMINFO",
		"info",
		"OS",
		"OS",
		"handle",
		"index",
		"info",
		"info",
		"item",
		"index",
		"index",
		"parentMenu",
		"parentMenu",
		"style",
		"SWT",
		"display",
		"cascade",
		"cascade",
		"style",
		"SWT",
		"display",
		"parent",
		"parent",
		"style",
		"SWT",
		"display",
		"handle",
		"hwndCB",
		"i",
		"items",
		"i",
		"items",
		"i",
		"item",
		"OS",
		"hwndCB",
		"item",
		"item",
		"OS",
		"hwndCB",
		"imageList",
		"OS",
		"hwndCB",
		"OS",
		"display",
		"imageList",
		"imageList",
		"parent",
		"parent",
		"parent",
		"cascade",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"eventTable",
		"SWT",
		"listener",
		"item",
		"item",
		"SWT",
		"item",
		"newID",
		"item",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"newID",
		"oldID",
		"OS",
		"handle",
		"newID",
		"OS",
		"state",
		"DISABLED",
		"enabled",
		"state",
		"DISABLED",
		"style",
		"SWT",
		"SWT",
		"x",
		"y",
		"hasLocation",
		"location",
		"SWT",
		"SWT",
		"location",
		"location",
		"style",
		"SWT",
		"SWT",
		"visible",
		"display",
		"display",
		"OS",
		"OS",
		"OS",
		"parent",
		"menuBar",
		"menu",
		"menu",
		"menuBar",
		"menu",
		"menu",
		"menu",
		"menuBar",
		"OS",
		"menuBar",
		"OS",
		"menuBar",
		"OS",
		"style",
		"SWT",
		"parent",
		"OS",
		"parent",
		"OS",
		"OS",
		"i",
		"items",
		"i",
		"items",
		"i",
		"item",
		"hasImage",
		"hasCheck",
		"item",
		"SWT",
		"SWT",
		"hasCheck",
		"hasImage",
		"OS",
		"info",
		"MENUITEMINFO",
		"info",
		"OS",
		"i",
		"items",
		"i",
		"items",
		"i",
		"style",
		"SWT",
		"item",
		"info",
		"hasImage",
		"OS",
		"OS",
		"handle",
		"item",
		"info",
		"lpcmi",
		"MENUINFO",
		"lpcmi",
		"OS",
		"OS",
		"handle",
		"lpcmi",
		"hasImage",
		"hasCheck",
		"lpcmi",
		"OS",
		"lpcmi",
		"OS",
		"OS",
		"handle",
		"lpcmi",
		"POP_UP",
		"parent",
		"DROP_DOWN",
		"parent",
		"parent",
		"handle",
		"BAR",
		"DROP_DOWN",
		"handle",
		"TPM_LEFTBUTTON",
		"VK_LBUTTON",
		"TPM_RIGHTBUTTON",
		"RIGHT_TO_LEFT",
		"TPM_RIGHTALIGN",
		"style",
		"MIRRORED",
		"TPM_RIGHTALIGN",
		"LEFT_TO_RIGHT",
		"TPM_RIGHTALIGN",
		"WM_MENUSELECT",
		"WM_CANCELMODE",
		"ERROR_NULL_ARGUMENT",
		"Help",
		"ERROR_NULL_ARGUMENT",
		"Hide",
		"Show",
		"ERROR_NULL_ARGUMENT",
		"ERROR_NULL_ARGUMENT",
		"ERROR_NULL_ARGUMENT",
		"POP_UP",
		"BAR",
		"DROP_DOWN",
		"BAR",
		"IsPPC",
		"handle",
		"cbSize",
		"sizeof",
		"hwndParent",
		"dwFlags",
		"SHCMBF_HIDDEN",
		"nToolBarId",
		"hInstRes",
		"hwndMB",
		"ERROR_NO_HANDLES",
		"TB_DELETEBUTTON",
		"IsSP",
		"BUTTON1",
		"BUTTON2",
		"BUTTON2",
		"cbSize",
		"sizeof",
		"hwndParent",
		"handle",
		"dwFlags",
		"SHCMBF_HIDDEN",
		"nToolBarId",
		"hInstRes",
		"ERROR_NO_HANDLES",
		"hwndMB",
		"SW_HIDE",
		"cbSize",
		"sizeof",
		"dwMask",
		"TBIF_COMMAND",
		"SHCMBM_GETSUBMENU",
		"MF_BYPOSITION",
		"DROP_DOWN",
		"CASCADE",
		"PUSH",
		"idCommand",
		"id",
		"TB_SETBUTTONINFO",
		"SHCMBM_GETSUBMENU",
		"MF_BYPOSITION",
		"DROP_DOWN",
		"CASCADE",
		"PUSH",
		"idCommand",
		"id",
		"TB_SETBUTTONINFO",
		"SHMBOF_NODEFAULT",
		"SHMBOF_NOTIFY",
		"SHCMBM_OVERRIDEKEY",
		"VK_ESCAPE",
		"ERROR_NO_HANDLES",
		"IsHPC",
		"handle",
		"ERROR_NO_HANDLES",
		"style",
		"CLOSE",
		"style",
		"TITLE",
		"ERROR_NO_HANDLES",
		"ERROR_INVALID_RANGE",
		"IsPPC",
		"IsSP",
		"IsSP",
		"idCommand",
		"id",
		"fsStyle",
		"TBSTYLE_AUTOSIZE",
		"style",
		"CASCADE",
		"fsStyle",
		"TBSTYLE_DROPDOWN",
		"style",
		"SEPARATOR",
		"fsStyle",
		"BTNS_SEP",
		"fsState",
		"TBSTATE_ENABLED",
		"iBitmap",
		"I_IMAGENONE",
		"TB_INSERTBUTTON",
		"IsWinCE",
		"MF_BYPOSITION",
		"style",
		"SEPARATOR",
		"MF_SEPARATOR",
		"id",
		"cbSize",
		"sizeof",
		"fMask",
		"MIIM_DATA",
		"dwItemData",
		"id",
		"sizeof",
		"HEAP_ZERO_MEMORY",
		"cbSize",
		"sizeof",
		"fMask",
		"MIIM_ID",
		"MIIM_TYPE",
		"MIIM_DATA",
		"wID",
		"dwItemData",
		"id",
		"fType",
		"dwTypeData",
		"ERROR_ITEM_NOT_ADDED",
		"COLOR_MENU",
		"COLOR_MENUTEXT",
		"IsWinCE",
		"IsPPC",
		"IsSP",
		"IsSP",
		"TB_COMMANDTOINDEX",
		"id",
		"TB_DELETEBUTTON",
		"ERROR_ITEM_NOT_REMOVED",
		"TB_BUTTONCOUNT",
		"TB_SETIMAGELIST",
		"cbSize",
		"sizeof",
		"fMask",
		"MIIM_DATA",
		"dwItemData",
		"id",
		"dwItemData",
		"id",
		"ERROR_ITEM_NOT_REMOVED",
		"MF_BYPOSITION",
		"ERROR_ITEM_NOT_REMOVED",
		"id",
		"MF_BYCOMMAND",
		"ERROR_ITEM_NOT_REMOVED",
		"IsWinCE",
		"length",
		"parent",
		"IsWinCE",
		"BAR",
		"menuBar",
		"handle",
		"cbSize",
		"sizeof",
		"OBJID_MENU",
		"right",
		"left",
		"bottom",
		"top",
		"left",
		"top",
		"left",
		"top",
		"right",
		"left",
		"bottom",
		"top",
		"IsWinCE",
		"MF_BYCOMMAND",
		"GMDI_USEDISABLED",
		"cbSize",
		"sizeof",
		"fMask",
		"MIIM_ID",
		"wID",
		"IsPPC",
		"IsSP",
		"IsPPC",
		"TB_GETBUTTON",
		"ERROR_CANNOT_GET_ITEM",
		"idCommand",
		"IsSP",
		"ERROR_CANNOT_GET_ITEM",
		"cbSize",
		"sizeof",
		"fMask",
		"MIIM_DATA",
		"ERROR_INVALID_RANGE",
		"dwItemData",
		"IsPPC",
		"IsSP",
		"IsSP",
		"TB_BUTTONCOUNT",
		"TB_GETBUTTON",
		"idCommand",
		"IsWinCE",
		"cbSize",
		"sizeof",
		"fMask",
		"MIIM_DATA",
		"length",
		"dwItemData",
		"length",
		"IsWinCE",
		"IsPPC",
		"IsSP",
		"IsSP",
		"TB_BUTTONCOUNT",
		"cbSize",
		"sizeof",
		"length",
		"parent",
		"BAR",
		"menuBar",
		"POP_UP",
		"popups",
		"length",
		"activeMenu",
		"I_IMAGENONE",
		"TB_GETIMAGELIST",
		"RIGHT_TO_LEFT",
		"width",
		"height",
		"TB_SETIMAGELIST",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"parent",
		"IsPPC",
		"IsSP",
		"IsPPC",
		"TB_COMMANDTOINDEX",
		"id",
		"IsSP",
		"id",
		"id",
		"cbSize",
		"sizeof",
		"fMask",
		"MIIM_DATA",
		"dwItemData",
		"id",
		"BAR",
		"BAR",
		"menuBar",
		"POP_UP",
		"length",
		"IsPPC",
		"IsPPC",
		"TB_SETIMAGELIST",
		"ERROR_NULL_ARGUMENT",
		"Help",
		"ERROR_NULL_ARGUMENT",
		"Hide",
		"Show",
		"ERROR_INVALID_ARGUMENT",
		"parent",
		"id",
		"IsWinCE",
		"MF_BYCOMMAND",
		"GMDI_USEDISABLED",
		"MF_BYCOMMAND",
		"BAR",
		"DROP_DOWN",
		"x",
		"y",
		"ERROR_NULL_ARGUMENT",
		"x",
		"y",
		"BAR",
		"DROP_DOWN",
		"IsPPC",
		"IsSP",
		"IsHPC",
		"menuBar",
		"hwndCB",
		"hwndCB",
		"IsWinCE",
		"BAR",
		"menuBar",
		"handle",
		"WIN32_VERSION",
		"length",
		"image",
		"style",
		"CHECK",
		"RADIO",
		"IsWin95",
		"cbSize",
		"sizeof",
		"fMask",
		"MIIM_BITMAP",
		"length",
		"SEPARATOR",
		"image",
		"hbmpItem",
		"HBMMENU_CALLBACK",
		"id",
		"cbSize",
		"sizeof",
		"fMask",
		"MIM_STYLE",
		"dwStyle",
		"MNS_CHECKORBMP",
		"dwStyle",
		"MNS_CHECKORBMP",
		"parent",
		"parent",
		"style",
		"parentMenu",
		"parentItem",
		"parent",
		"style",
		"handle",
		"visible",
		"listener",
		"listener",
		"control",
		"menu",
		"item",
		"style",
		"item",
		"index",
		"item",
		"newParent",
		"index",
		"handle",
		"image",
		"item",
		"listener",
		"listener",
		"item",
		"enabled",
		"x",
		"y",
		"location",
		"visible"
	],
	"extendORImplementFiles":[
		"Widget"
	],
	"package":[
		"org.eclipse.swt.widgets"
	],
	"import":[
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt",
		"org.eclipse.swt.graphics",
		"org.eclipse.swt.events"
	],
	"methods":[
		"_setVisible",
		"addHelpListener",
		"addMenuListener",
		"checkNull",
		"checkNull",
		"checkNull",
		"checkStyle",
		"createHandle",
		"createItem",
		"createWidget",
		"defaultBackground",
		"defaultForeground",
		"destroyAccelerators",
		"destroyItem",
		"destroyWidget",
		"fixMenus",
		"getBounds",
		"getDefaultItem",
		"getEnabled",
		"getItem",
		"getItemCount",
		"getItems",
		"GetMenuItemCount",
		"getNameText",
		"getParent",
		"getParentItem",
		"getParentMenu",
		"getShell",
		"getVisible",
		"imageIndex",
		"indexOf",
		"isEnabled",
		"isVisible",
		"redraw",
		"releaseChild",
		"releaseHandle",
		"releaseWidget",
		"removeHelpListener",
		"removeMenuListener",
		"setDefaultItem",
		"setEnabled",
		"setLocation",
		"setLocation",
		"setVisible",
		"update",
		"menuShell",
		"checkNull",
		"checkStyle",
		"checkNull",
		"checkNull",
		"checkStyle",
		"checkOrientation",
		"createWidget",
		"GetKeyState",
		"GetMessagePos",
		"TrackPopupMenu",
		"GetMenuItemCount",
		"SendMessage",
		"SendMessage",
		"checkWidget",
		"error",
		"addListener",
		"checkWidget",
		"error",
		"addListener",
		"addListener",
		"error",
		"error",
		"error",
		"checkBits",
		"GetLibraryHandle",
		"SHCreateMenuBar",
		"error",
		"SendMessage",
		"GetLibraryHandle",
		"SHCreateMenuBar",
		"error",
		"ShowWindow",
		"SendMessage",
		"RemoveMenu",
		"SendMessage",
		"SendMessage",
		"RemoveMenu",
		"SendMessage",
		"SendMessage",
		"CreateMenu",
		"error",
		"CommandBar_Create",
		"GetModuleHandle",
		"error",
		"CommandBar_Show",
		"CommandBar_InsertMenubarEx",
		"CommandBar_AddAdornments",
		"CreatePopupMenu",
		"error",
		"GetMenuItemCount",
		"error",
		"addMenuItem",
		"SendMessage",
		"InsertMenu",
		"SetMenuItemInfo",
		"GetProcessHeap",
		"length",
		"HeapAlloc",
		"MoveMemory",
		"widgetStyle",
		"InsertMenuItem",
		"HeapFree",
		"removeMenuItem",
		"error",
		"redraw",
		"createHandle",
		"addMenu",
		"GetSysColor",
		"GetSysColor",
		"destroyAccelerators",
		"redraw",
		"SendMessage",
		"SendMessage",
		"error",
		"SendMessage",
		"SendMessage",
		"releaseImageList",
		"GetMenuItemInfo",
		"error",
		"RemoveMenu",
		"error",
		"RemoveMenu",
		"error",
		"redraw",
		"releaseHandle",
		"CommandBar_Destroy",
		"DestroyMenu",
		"getItems",
		"fixMenus",
		"removeMenu",
		"addMenu",
		"checkWidget",
		"GetMenuBarInfo",
		"GetMenuItemCount",
		"GetMenuItemRect",
		"GetMenuItemRect",
		"checkWidget",
		"GetMenuDefaultItem",
		"GetMenuItemInfo",
		"getMenuItem",
		"checkWidget",
		"checkWidget",
		"SendMessage",
		"error",
		"error",
		"GetMenuItemInfo",
		"error",
		"getMenuItem",
		"checkWidget",
		"GetMenuItemCount",
		"checkWidget",
		"getMenuItem",
		"getMenuItem",
		"SendMessage",
		"SendMessage",
		"getMenuItem",
		"GetMenuItemCount",
		"GetMenuItemInfo",
		"arraycopy",
		"getMenuItem",
		"arraycopy",
		"SendMessage",
		"GetMenuItemInfo",
		"GetMenuItemCount",
		"getItems",
		"getNameText",
		"getNameText",
		"checkWidget",
		"checkWidget",
		"checkWidget",
		"checkWidget",
		"getShell",
		"checkWidget",
		"menuShell",
		"getShell",
		"getParentMenu",
		"SendMessage",
		"ImageList_Destroy",
		"getBounds",
		"getImageList",
		"getHandle",
		"SendMessage",
		"indexOf",
		"add",
		"put",
		"checkWidget",
		"error",
		"isDisposed",
		"error",
		"SendMessage",
		"GetMenuItemInfo",
		"checkWidget",
		"getParentMenu",
		"getEnabled",
		"getEnabled",
		"isEnabled",
		"checkWidget",
		"getVisible",
		"isVisible",
		"addBar",
		"update",
		"releaseChild",
		"releaseMenu",
		"removeBar",
		"setMenuBar",
		"removePopup",
		"releaseHandle",
		"getItems",
		"isDisposed",
		"dispose",
		"releaseResources",
		"SendMessage",
		"releaseToolImageList",
		"releaseWidget",
		"removeMenu",
		"checkWidget",
		"error",
		"unhook",
		"checkWidget",
		"error",
		"unhook",
		"unhook",
		"checkWidget",
		"isDisposed",
		"error",
		"GetMenuDefaultItem",
		"SetMenuDefaultItem",
		"redraw",
		"checkWidget",
		"checkWidget",
		"checkWidget",
		"error",
		"setLocation",
		"checkWidget",
		"addPopup",
		"removePopup",
		"_setVisible",
		"getParentMenu",
		"CommandBar_DrawMenuBar",
		"CommandBar_Show",
		"DrawMenuBar",
		"VERSION",
		"getItems",
		"SetMenuItemInfo",
		"GetMenuInfo",
		"SetMenuInfo",
		"TypedListener",
		"TypedListener",
		"SHMENUBARINFO",
		"SHMENUBARINFO",
		"TBBUTTONINFO",
		"Menu",
		"MenuItem",
		"MenuItem",
		"Menu",
		"MenuItem",
		"MenuItem",
		"TBBUTTON",
		"TCHAR",
		"MENUITEMINFO",
		"TCHAR",
		"MENUITEMINFO",
		"MENUITEMINFO",
		"Rectangle",
		"Rectangle",
		"MENUBARINFO",
		"Rectangle",
		"RECT",
		"RECT",
		"Rectangle",
		"Rectangle",
		"MENUITEMINFO",
		"TBBUTTON",
		"MENUITEMINFO",
		"TBBUTTON",
		"MENUITEMINFO",
		"MENUITEMINFO",
		"MENUITEMINFO",
		"MENUITEMINFO",
		"MENUINFO"
	],
	"methodsBody":{
		"public Menu getParentMenu()":{
			"methodBody":"{\n    checkWidget();\n    if (cascade != null)\n        return cascade.parent;\n    return null;\n}",
			"comments":"/**\n* Returns the receiver's parent item, which must be a\n* <code>Menu</code> or null when the receiver is a\n* root.\n*\n* @return the receiver's parent item\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Menu getParentMenu()"
		},
		"void _setVisible(boolean visible)":{
			"methodBody":"{\n    if ((style & (SWT.BAR | SWT.DROP_DOWN)) != 0)\n        return;\n    int hwndParent = parent.handle;\n    if (visible) {\n        int flags = OS.TPM_LEFTBUTTON;\n        if (OS.GetKeyState(OS.VK_LBUTTON) >= 0)\n            flags |= OS.TPM_RIGHTBUTTON;\n        if ((style & SWT.RIGHT_TO_LEFT) != 0)\n            flags |= OS.TPM_RIGHTALIGN;\n        if ((parent.style & SWT.MIRRORED) != 0) {\n            flags &= ~OS.TPM_RIGHTALIGN;\n            if ((style & SWT.LEFT_TO_RIGHT) != 0)\n                flags |= OS.TPM_RIGHTALIGN;\n        }\n        int nX = x, nY = y;\n        if (!hasLocation) {\n            int pos = OS.GetMessagePos();\n            nX = (short) (pos & 0xFFFF);\n            nY = (short) (pos >> 16);\n        }\n        \n        boolean success = OS.TrackPopupMenu(handle, flags, nX, nY, 0, hwndParent, null);\n        if (!success && GetMenuItemCount(handle) == 0) {\n            OS.SendMessage(hwndParent, OS.WM_MENUSELECT, 0xFFFF0000, 0);\n        }\n    } else {\n        OS.SendMessage(hwndParent, OS.WM_CANCELMODE, 0, 0);\n    }\n}",
			"comments":"/*\n* Feature in Windows.  It is legal use TrackPopupMenu()\n* to display an empty menu as long as menu items are added\n* inside of WM_INITPOPUPMENU.  If no items are added, then\n* TrackPopupMenu() fails and does not send an indication\n* that the menu has been closed.  This is not strictly a\n* bug but leads to unwanted behavior when application code\n* assumes that every WM_INITPOPUPMENU will eventually result\n* in a WM_MENUSELECT, wParam=0xFFFF0000, lParam=0 to indicate\n* that the menu has been closed.  The fix is to detect the\n* case when TrackPopupMenu() fails and the number of items in\n* the menu is zero and issue a fake WM_MENUSELECT.\n*/\n",
			"methodName":"void _setVisible(boolean visible)"
		},
		"public MenuItem getParentItem()":{
			"methodBody":"{\n    checkWidget();\n    return cascade;\n}",
			"comments":"/**\n* Returns the receiver's parent item, which must be a\n* <code>MenuItem</code> or null when the receiver is a\n* root.\n*\n* @return the receiver's parent item\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public MenuItem getParentItem()"
		},
		"void fixMenus(Decorations newParent)":{
			"methodBody":"{\n    MenuItem[] items = getItems();\n    for (int i = 0; i < items.length; i++) {\n        items[i].fixMenus(newParent);\n    }\n    parent.removeMenu(this);\n    newParent.addMenu(this);\n    this.parent = newParent;\n}",
			"comments":"",
			"methodName":"void fixMenus(Decorations newParent)"
		},
		"public MenuItem getItem(int index)":{
			"methodBody":"{\n    checkWidget();\n    int id = 0;\n    if ((OS.IsPPC || OS.IsSP) && hwndCB != 0) {\n        if (OS.IsPPC) {\n            TBBUTTON lpButton = new TBBUTTON();\n            int result = OS.SendMessage(hwndCB, OS.TB_GETBUTTON, index, lpButton);\n            if (result == 0)\n                error(SWT.ERROR_CANNOT_GET_ITEM);\n            id = lpButton.idCommand;\n        }\n        if (OS.IsSP) {\n            if (!(0 <= index && index <= 1))\n                error(SWT.ERROR_CANNOT_GET_ITEM);\n            id = index == 0 ? id0 : id1;\n        }\n    } else {\n        MENUITEMINFO info = new MENUITEMINFO();\n        info.cbSize = MENUITEMINFO.sizeof;\n        info.fMask = OS.MIIM_DATA;\n        if (!OS.GetMenuItemInfo(handle, index, true, info)) {\n            error(SWT.ERROR_INVALID_RANGE);\n        }\n        id = info.dwItemData;\n    }\n    return display.getMenuItem(id);\n}",
			"comments":"/**\n* Returns the item at the given, zero-relative index in the\n* receiver. Throws an exception if the index is out of range.\n*\n* @param index the index of the item to return\n* @return the item at the given index\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_RANGE - if the index is not between 0 and the number of elements in the list minus 1 (inclusive)</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public MenuItem getItem(int index)"
		},
		"public Decorations getParent()":{
			"methodBody":"{\n    checkWidget();\n    return parent;\n}",
			"comments":"/**\n* Returns the receiver's parent, which must be a <code>Decorations</code>.\n*\n* @return the receiver's parent\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Decorations getParent()"
		},
		"int defaultForeground()":{
			"methodBody":"{\n    return OS.GetSysColor(OS.COLOR_MENUTEXT);\n}",
			"comments":"/*\n* Currently not used.\n*/\n",
			"methodName":"int defaultForeground()"
		},
		"int GetMenuItemCount(int handle)":{
			"methodBody":"{\n    if (OS.IsWinCE) {\n        if ((OS.IsPPC || OS.IsSP) && hwndCB != 0) {\n            return OS.IsSP ? 2 : OS.SendMessage(hwndCB, OS.TB_BUTTONCOUNT, 0, 0);\n        }\n        int count = 0;\n        MENUITEMINFO info = new MENUITEMINFO();\n        info.cbSize = MENUITEMINFO.sizeof;\n        while (OS.GetMenuItemInfo(handle, count, true, info)) count++;\n        return count;\n    }\n    return OS.GetMenuItemCount(handle);\n}",
			"comments":"",
			"methodName":"int GetMenuItemCount(int handle)"
		},
		"public MenuItem getDefaultItem()":{
			"methodBody":"{\n    checkWidget();\n    if (OS.IsWinCE)\n        return null;\n    int id = OS.GetMenuDefaultItem(handle, OS.MF_BYCOMMAND, OS.GMDI_USEDISABLED);\n    if (id == -1)\n        return null;\n    MENUITEMINFO info = new MENUITEMINFO();\n    info.cbSize = MENUITEMINFO.sizeof;\n    info.fMask = OS.MIIM_ID;\n    if (OS.GetMenuItemInfo(handle, id, false, info)) {\n        return display.getMenuItem(info.wID);\n    }\n    return null;\n}",
			"comments":"/**\n* Returns the default menu item or null if none has\n* been previously set.\n*\n* @return the default menu item.\n*\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public MenuItem getDefaultItem()"
		},
		"public boolean isEnabled()":{
			"methodBody":"{\n    checkWidget();\n    Menu parentMenu = getParentMenu();\n    if (parentMenu == null)\n        return getEnabled();\n    return getEnabled() && parentMenu.isEnabled();\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver is enabled and all\n* of the receiver's ancestors are enabled, and <code>false</code>\n* otherwise. A disabled menu is typically not selectable from the\n* user interface and draws with an inactive or \"grayed\" look.\n*\n* @return the receiver's enabled state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #getEnabled\n*/\n",
			"methodName":"public boolean isEnabled()"
		},
		"public void addMenuListener(MenuListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.Hide, typedListener);\n    addListener(SWT.Show, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when menus are hidden or shown, by sending it\n* one of the messages defined in the <code>MenuListener</code>\n* interface.\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see MenuListener\n* @see #removeMenuListener\n*/\n",
			"methodName":"public void addMenuListener(MenuListener listener)"
		},
		"public void removeHelpListener(HelpListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.Help, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when the help events are generated for the control.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see HelpListener\n* @see #addHelpListener\n*/\n",
			"methodName":"public void removeHelpListener(HelpListener listener)"
		},
		"void releaseHandle()":{
			"methodBody":"{\n    super.releaseHandle();\n    handle = hwndCB = 0;\n}",
			"comments":"",
			"methodName":"void releaseHandle()"
		},
		"void destroyItem(MenuItem item)":{
			"methodBody":"{\n    if (OS.IsWinCE) {\n        if ((OS.IsPPC || OS.IsSP) && hwndCB != 0) {\n            if (OS.IsSP) {\n                redraw();\n                return;\n            }\n            int index = OS.SendMessage(hwndCB, OS.TB_COMMANDTOINDEX, item.id, 0);\n            if (OS.SendMessage(hwndCB, OS.TB_DELETEBUTTON, index, 0) == 0) {\n                error(SWT.ERROR_ITEM_NOT_REMOVED);\n            }\n            int count = OS.SendMessage(hwndCB, OS.TB_BUTTONCOUNT, 0, 0);\n            if (count == 0) {\n                if (imageList != null) {\n                    OS.SendMessage(handle, OS.TB_SETIMAGELIST, 0, 0);\n                    display.releaseImageList(imageList);\n                    imageList = null;\n                }\n            }\n        } else {\n            int index = 0;\n            MENUITEMINFO info = new MENUITEMINFO();\n            info.cbSize = MENUITEMINFO.sizeof;\n            info.fMask = OS.MIIM_DATA;\n            while (OS.GetMenuItemInfo(handle, index, true, info)) {\n                if (info.dwItemData == item.id)\n                    break;\n                index++;\n            }\n            if (info.dwItemData != item.id) {\n                error(SWT.ERROR_ITEM_NOT_REMOVED);\n            }\n            if (!OS.RemoveMenu(handle, index, OS.MF_BYPOSITION)) {\n                error(SWT.ERROR_ITEM_NOT_REMOVED);\n            }\n        }\n    } else {\n        if (!OS.RemoveMenu(handle, item.id, OS.MF_BYCOMMAND)) {\n            error(SWT.ERROR_ITEM_NOT_REMOVED);\n        }\n    }\n    redraw();\n}",
			"comments":"",
			"methodName":"void destroyItem(MenuItem item)"
		},
		"static int checkStyle(int style)":{
			"methodBody":"{\n    return checkBits(style, SWT.POP_UP, SWT.BAR, SWT.DROP_DOWN, 0, 0, 0);\n}",
			"comments":"",
			"methodName":"static int checkStyle(int style)"
		},
		"public void setEnabled(boolean enabled)":{
			"methodBody":"{\n    checkWidget();\n    state &= ~DISABLED;\n    if (!enabled)\n        state |= DISABLED;\n}",
			"comments":"/**\n* Enables the receiver if the argument is <code>true</code>,\n* and disables it otherwise. A disabled menu is typically\n* not selectable from the user interface and draws with an\n* inactive or \"grayed\" look.\n*\n* @param enabled the new enabled state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setEnabled(boolean enabled)"
		},
		"void createWidget()":{
			"methodBody":"{\n    \n    \n    createHandle();\n    parent.addMenu(this);\n}",
			"comments":"/*\n* Bug in IBM JVM 1.3.1.  For some reason, when the following code is called\n* from this method, the JVM issues this error:\n*\n* JVM Exception 0x2 (subcode 0x0) occurred in thread \"main\" (TID:0x9F19D8)\n*\n* In addition, on Windows XP, a dialog appears with following error message,\n* indicating that the problem may be in the JIT:\n*\n* AppName: java.exe\t AppVer: 0.0.0.0\t ModName: jitc.dll\n* ModVer: 0.0.0.0\t Offset: 000b6912\n*\n* The fix is to move the code to the caller of this method.\n*/\n//\tcheckOrientation (parent);\n",
			"methodName":"void createWidget()"
		},
		"public boolean getEnabled()":{
			"methodBody":"{\n    checkWidget();\n    return (state & DISABLED) == 0;\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver is enabled, and\n* <code>false</code> otherwise. A disabled menu is typically\n* not selectable from the user interface and draws with an\n* inactive or \"grayed\" look.\n*\n* @return the receiver's enabled state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #isEnabled\n*/\n",
			"methodName":"public boolean getEnabled()"
		},
		"void update()":{
			"methodBody":"{\n    if (OS.IsPPC || OS.IsSP)\n        return;\n    if (OS.IsHPC) {\n        \n        Menu menuBar = parent.menuBar;\n        if (menuBar != null) {\n            Menu menu = this;\n            while (menu != null && menu != menuBar) {\n                menu = menu.getParentMenu();\n            }\n            if (menu == menuBar) {\n                OS.CommandBar_DrawMenuBar(menuBar.hwndCB, 0);\n                OS.CommandBar_Show(menuBar.hwndCB, true);\n            }\n        }\n        return;\n    }\n    if (OS.IsWinCE)\n        return;\n    if ((style & SWT.BAR) != 0) {\n        if (this == parent.menuBar)\n            OS.DrawMenuBar(parent.handle);\n        return;\n    }\n    if (OS.WIN32_VERSION < OS.VERSION(4, 10)) {\n        return;\n    }\n    boolean hasCheck = false, hasImage = false;\n    MenuItem[] items = getItems();\n    for (int i = 0; i < items.length; i++) {\n        MenuItem item = items[i];\n        if (item.image != null) {\n            if ((hasImage = true) && hasCheck)\n                break;\n        }\n        if ((item.style & (SWT.CHECK | SWT.RADIO)) != 0) {\n            if ((hasCheck = true) && hasImage)\n                break;\n        }\n    }\n    \n    if (!OS.IsWin95) {\n        MENUITEMINFO info = new MENUITEMINFO();\n        info.cbSize = MENUITEMINFO.sizeof;\n        info.fMask = OS.MIIM_BITMAP;\n        for (int i = 0; i < items.length; i++) {\n            MenuItem item = items[i];\n            if ((style & SWT.SEPARATOR) == 0) {\n                if (item.image == null) {\n                    info.hbmpItem = hasImage ? OS.HBMMENU_CALLBACK : 0;\n                    OS.SetMenuItemInfo(handle, item.id, false, info);\n                }\n            }\n        }\n    }\n    \n    MENUINFO lpcmi = new MENUINFO();\n    lpcmi.cbSize = MENUINFO.sizeof;\n    lpcmi.fMask = OS.MIM_STYLE;\n    OS.GetMenuInfo(handle, lpcmi);\n    if (hasImage && !hasCheck) {\n        lpcmi.dwStyle |= OS.MNS_CHECKORBMP;\n    } else {\n        lpcmi.dwStyle &= ~OS.MNS_CHECKORBMP;\n    }\n    OS.SetMenuInfo(handle, lpcmi);\n}",
			"comments":"/*\n* Each time a menu has been modified, the command menu bar\n* must be redrawn or it won't update properly.  For example,\n* a submenu will not drop down.\n*/\n/*\n* Bug in Windows.  If a menu contains items that have\n* images and can be checked, Windows does not include\n* the width of the image and the width of the check when\n* computing the width of the menu.  When the longest item\n* does not have an image, the label and the accelerator\n* text can overlap.  The fix is to use SetMenuItemInfo()\n* to indicate that all items have a bitmap and then include\n* the width of the widest bitmap in WM_MEASURECHILD.\n*\n* NOTE:  This work around causes problems on Windows 98.\n* Under certain circumstances that have yet to be isolated,\n* some menus can become huge and blank.  For now, do not\n* run the code on Windows 98.\n*/\n/* Update the menu to hide or show the space for bitmaps */\n",
			"methodName":"void update()"
		},
		"int defaultBackground()":{
			"methodBody":"{\n    return OS.GetSysColor(OS.COLOR_MENU);\n}",
			"comments":"/*\n* Currently not used.\n*/\n",
			"methodName":"int defaultBackground()"
		},
		"public void setVisible(boolean visible)":{
			"methodBody":"{\n    checkWidget();\n    if ((style & (SWT.BAR | SWT.DROP_DOWN)) != 0)\n        return;\n    if (visible) {\n        display.addPopup(this);\n    } else {\n        display.removePopup(this);\n        _setVisible(false);\n    }\n}",
			"comments":"/**\n* Marks the receiver as visible if the argument is <code>true</code>,\n* and marks it invisible otherwise.\n* <p>\n* If one of the receiver's ancestors is not visible or some\n* other condition makes the receiver not visible, marking\n* it visible may not actually cause it to be displayed.\n* </p>\n*\n* @param visible the new visibility state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setVisible(boolean visible)"
		},
		"public void addHelpListener(HelpListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.Help, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when help events are generated for the control,\n* by sending it one of the messages defined in the\n* <code>HelpListener</code> interface.\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see HelpListener\n* @see #removeHelpListener\n*/\n",
			"methodName":"public void addHelpListener(HelpListener listener)"
		},
		"void destroyWidget()":{
			"methodBody":"{\n    int hMenu = handle, hCB = hwndCB;\n    releaseHandle();\n    if (OS.IsWinCE && hCB != 0) {\n        OS.CommandBar_Destroy(hCB);\n    } else {\n        if (hMenu != 0)\n            OS.DestroyMenu(hMenu);\n    }\n}",
			"comments":"",
			"methodName":"void destroyWidget()"
		},
		"public void removeMenuListener(MenuListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.Hide, listener);\n    eventTable.unhook(SWT.Show, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when the menu events are generated for the control.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see MenuListener\n* @see #addMenuListener\n*/\n",
			"methodName":"public void removeMenuListener(MenuListener listener)"
		},
		"public MenuItem[] getItems()":{
			"methodBody":"{\n    checkWidget();\n    if ((OS.IsPPC || OS.IsSP) && hwndCB != 0) {\n        if (OS.IsSP) {\n            MenuItem[] result = new MenuItem[2];\n            result[0] = display.getMenuItem(id0);\n            result[1] = display.getMenuItem(id1);\n            return result;\n        }\n        int count = OS.SendMessage(hwndCB, OS.TB_BUTTONCOUNT, 0, 0);\n        TBBUTTON lpButton = new TBBUTTON();\n        MenuItem[] result = new MenuItem[count];\n        for (int i = 0; i < count; i++) {\n            OS.SendMessage(hwndCB, OS.TB_GETBUTTON, i, lpButton);\n            result[i] = display.getMenuItem(lpButton.idCommand);\n        }\n        return result;\n    }\n    int count = 0;\n    int length = OS.IsWinCE ? 4 : OS.GetMenuItemCount(handle);\n    MenuItem[] items = new MenuItem[length];\n    MENUITEMINFO info = new MENUITEMINFO();\n    info.cbSize = MENUITEMINFO.sizeof;\n    info.fMask = OS.MIIM_DATA;\n    while (OS.GetMenuItemInfo(handle, count, true, info)) {\n        if (count == items.length) {\n            MenuItem[] newItems = new MenuItem[count + 4];\n            System.arraycopy(items, 0, newItems, 0, count);\n            items = newItems;\n        }\n        items[count++] = display.getMenuItem(info.dwItemData);\n    }\n    if (count == items.length)\n        return items;\n    MenuItem[] result = new MenuItem[count];\n    System.arraycopy(items, 0, result, 0, count);\n    return result;\n}",
			"comments":"/**\n* Returns a (possibly empty) array of <code>MenuItem</code>s which\n* are the items in the receiver.\n* <p>\n* Note: This is not the actual structure used by the receiver\n* to maintain its list of items, so modifying the array will\n* not affect the receiver.\n* </p>\n*\n* @return the items in the receiver\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public MenuItem[] getItems()"
		},
		"public void setDefaultItem(MenuItem item)":{
			"methodBody":"{\n    checkWidget();\n    int newID = -1;\n    if (item != null) {\n        if (item.isDisposed())\n            error(SWT.ERROR_INVALID_ARGUMENT);\n        if (item.parent != this)\n            return;\n        newID = item.id;\n    }\n    if (OS.IsWinCE)\n        return;\n    int oldID = OS.GetMenuDefaultItem(handle, OS.MF_BYCOMMAND, OS.GMDI_USEDISABLED);\n    if (newID == oldID)\n        return;\n    OS.SetMenuDefaultItem(handle, newID, OS.MF_BYCOMMAND);\n    redraw();\n}",
			"comments":"/**\n* Sets the default menu item to the argument or removes\n* the default emphasis when the argument is <code>null</code>.\n*\n* @param item the default menu item or null\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the menu item has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setDefaultItem(MenuItem item)"
		},
		"void createHandle()":{
			"methodBody":"{\n    if (handle != 0)\n        return;\n    if ((style & SWT.BAR) != 0) {\n        if (OS.IsPPC) {\n            int hwndShell = parent.handle;\n            SHMENUBARINFO mbi = new SHMENUBARINFO();\n            mbi.cbSize = SHMENUBARINFO.sizeof;\n            mbi.hwndParent = hwndShell;\n            mbi.dwFlags = OS.SHCMBF_HIDDEN;\n            mbi.nToolBarId = ID_PPC;\n            mbi.hInstRes = OS.GetLibraryHandle();\n            boolean success = OS.SHCreateMenuBar(mbi);\n            hwndCB = mbi.hwndMB;\n            if (!success)\n                error(SWT.ERROR_NO_HANDLES);\n            \n            OS.SendMessage(hwndCB, OS.TB_DELETEBUTTON, 0, 0);\n            return;\n        }\n        \n        if (OS.IsSP) {\n            \n            int nToolBarId;\n            if ((style & SWT.BUTTON1) != 0) {\n                nToolBarId = ((style & SWT.BUTTON2) != 0) ? ID_SPBB : ID_SPBM;\n            } else {\n                nToolBarId = ((style & SWT.BUTTON2) != 0) ? ID_SPMB : ID_SPMM;\n            }\n            \n            SHMENUBARINFO mbi = new SHMENUBARINFO();\n            mbi.cbSize = SHMENUBARINFO.sizeof;\n            mbi.hwndParent = parent.handle;\n            mbi.dwFlags = OS.SHCMBF_HIDDEN;\n            mbi.nToolBarId = nToolBarId;\n            \n            mbi.hInstRes = OS.GetLibraryHandle();\n            if (!OS.SHCreateMenuBar(mbi))\n                error(SWT.ERROR_NO_HANDLES);\n            hwndCB = mbi.hwndMB;\n            \n            OS.ShowWindow(hwndCB, OS.SW_HIDE);\n            TBBUTTONINFO info = new TBBUTTONINFO();\n            info.cbSize = TBBUTTONINFO.sizeof;\n            info.dwMask = OS.TBIF_COMMAND;\n            MenuItem item;\n            \n            if (nToolBarId == ID_SPMM || nToolBarId == ID_SPMB) {\n                int hMenu = OS.SendMessage(hwndCB, OS.SHCMBM_GETSUBMENU, 0, ID_SPSOFTKEY0);\n                \n                OS.RemoveMenu(hMenu, 0, OS.MF_BYPOSITION);\n                Menu menu = new Menu(parent, SWT.DROP_DOWN, hMenu);\n                item = new MenuItem(this, menu, SWT.CASCADE, 0);\n            } else {\n                item = new MenuItem(this, null, SWT.PUSH, 0);\n            }\n            info.idCommand = id0 = item.id;\n            OS.SendMessage(hwndCB, OS.TB_SETBUTTONINFO, ID_SPSOFTKEY0, info);\n            \n            if (nToolBarId == ID_SPMM || nToolBarId == ID_SPBM) {\n                int hMenu = OS.SendMessage(hwndCB, OS.SHCMBM_GETSUBMENU, 0, ID_SPSOFTKEY1);\n                OS.RemoveMenu(hMenu, 0, OS.MF_BYPOSITION);\n                Menu menu = new Menu(parent, SWT.DROP_DOWN, hMenu);\n                item = new MenuItem(this, menu, SWT.CASCADE, 1);\n            } else {\n                item = new MenuItem(this, null, SWT.PUSH, 1);\n            }\n            info.idCommand = id1 = item.id;\n            OS.SendMessage(hwndCB, OS.TB_SETBUTTONINFO, ID_SPSOFTKEY1, info);\n            \n            int dwMask = OS.SHMBOF_NODEFAULT | OS.SHMBOF_NOTIFY;\n            int lParam = dwMask << 16 | dwMask;\n            OS.SendMessage(hwndCB, OS.SHCMBM_OVERRIDEKEY, OS.VK_ESCAPE, lParam);\n            return;\n        }\n        handle = OS.CreateMenu();\n        if (handle == 0)\n            error(SWT.ERROR_NO_HANDLES);\n        if (OS.IsHPC) {\n            int hwndShell = parent.handle;\n            hwndCB = OS.CommandBar_Create(OS.GetModuleHandle(null), hwndShell, 1);\n            if (hwndCB == 0)\n                error(SWT.ERROR_NO_HANDLES);\n            OS.CommandBar_Show(hwndCB, false);\n            OS.CommandBar_InsertMenubarEx(hwndCB, 0, handle, 0);\n            \n            if ((parent.style & SWT.CLOSE) != 0 && (parent.style & SWT.TITLE) == 0) {\n                OS.CommandBar_AddAdornments(hwndCB, 0, 0);\n            }\n        }\n    } else {\n        handle = OS.CreatePopupMenu();\n        if (handle == 0)\n            error(SWT.ERROR_NO_HANDLES);\n    }\n}",
			"comments":"/* Remove the item from the resource file */\n/*\n* Note in WinCE SmartPhone.  The SoftBar contains only 2 items.\n* An item can either be a menu or a button.\n* SWT.BAR: creates a SoftBar with 2 menus\n* SWT.BAR | SWT.BUTTON1: creates a SoftBar with 1 button\n*    for button1, and a menu for button2\n* SWT.BAR | SWT.BUTTON1 | SWT.BUTTON2: creates a SoftBar with\n*    2 buttons\n*/\n/* Determine type of menubar */\n/* Create SHMENUBAR */\n/* as defined in .rc file */\n/*\n* Feature on WinCE SmartPhone.  The SHCMBF_HIDDEN flag causes the\n* SHMENUBAR to not be drawn. However the keyboard events still go\n* through it.  The workaround is to also hide the SHMENUBAR with\n* ShowWindow ().\n*/\n/* Set first item */\n/* Remove the item from the resource file */\n/* Set second item */\n/*\n* Override the Back key.  For some reason, the owner of the menubar\n* must be a Dialog or it won't receive the WM_HOTKEY message.  As\n* a result, Shell on WinCE SP must use the class Dialog.\n*/\n/*\n* The command bar hosts the 'close' button when the window does not\n* have a caption.\n*/\n",
			"methodName":"void createHandle()"
		},
		"int imageIndex(Image image)":{
			"methodBody":"{\n    if (hwndCB == 0 || image == null)\n        return OS.I_IMAGENONE;\n    if (imageList == null) {\n        int hOldList = OS.SendMessage(hwndCB, OS.TB_GETIMAGELIST, 0, 0);\n        if (hOldList != 0)\n            OS.ImageList_Destroy(hOldList);\n        Rectangle bounds = image.getBounds();\n        imageList = display.getImageList(style & SWT.RIGHT_TO_LEFT, bounds.width, bounds.height);\n        int hImageList = imageList.getHandle();\n        OS.SendMessage(hwndCB, OS.TB_SETIMAGELIST, 0, hImageList);\n    }\n    int index = imageList.indexOf(image);\n    if (index == -1) {\n        index = imageList.add(image);\n    } else {\n        imageList.put(index, image);\n    }\n    return index;\n}",
			"comments":"",
			"methodName":"int imageIndex(Image image)"
		},
		"void destroyAccelerators()":{
			"methodBody":"{\n    parent.destroyAccelerators();\n}",
			"comments":"",
			"methodName":"void destroyAccelerators()"
		},
		"String getNameText()":{
			"methodBody":"{\n    String result = \"\";\n    MenuItem[] items = getItems();\n    int length = items.length;\n    if (length > 0) {\n        for (int i = 0; i < length - 1; i++) {\n            result = result + items[i].getNameText() + \", \";\n        }\n        result = result + items[length - 1].getNameText();\n    }\n    return result;\n}",
			"comments":"",
			"methodName":"String getNameText()"
		},
		"void redraw()":{
			"methodBody":"{\n    if (!isVisible())\n        return;\n    if ((style & SWT.BAR) != 0) {\n        display.addBar(this);\n    } else {\n        update();\n    }\n}",
			"comments":"",
			"methodName":"void redraw()"
		},
		"static MenuItem checkNull(MenuItem item)":{
			"methodBody":"{\n    if (item == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    return item;\n}",
			"comments":"",
			"methodName":"static MenuItem checkNull(MenuItem item)"
		},
		"void releaseWidget()":{
			"methodBody":"{\n    MenuItem[] items = getItems();\n    for (int i = 0; i < items.length; i++) {\n        MenuItem item = items[i];\n        if (!item.isDisposed()) {\n            if (OS.IsPPC && hwndCB != 0) {\n                item.dispose();\n            } else {\n                item.releaseResources();\n            }\n        }\n    }\n    if (OS.IsPPC && hwndCB != 0) {\n        if (imageList != null) {\n            OS.SendMessage(hwndCB, OS.TB_SETIMAGELIST, 0, 0);\n            display.releaseToolImageList(imageList);\n            imageList = null;\n        }\n    }\n    super.releaseWidget();\n    if (parent != null)\n        parent.removeMenu(this);\n    parent = null;\n    cascade = null;\n}",
			"comments":"",
			"methodName":"void releaseWidget()"
		},
		"public boolean getVisible()":{
			"methodBody":"{\n    checkWidget();\n    if ((style & SWT.BAR) != 0) {\n        return this == parent.menuShell().menuBar;\n    }\n    if ((style & SWT.POP_UP) != 0) {\n        Menu[] popups = display.popups;\n        if (popups == null)\n            return false;\n        for (int i = 0; i < popups.length; i++) {\n            if (popups[i] == this)\n                return true;\n        }\n    }\n    Shell shell = getShell();\n    Menu menu = shell.activeMenu;\n    while (menu != null && menu != this) {\n        menu = menu.getParentMenu();\n    }\n    return this == menu;\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver is visible, and\n* <code>false</code> otherwise.\n* <p>\n* If one of the receiver's ancestors is not visible or some\n* other condition makes the receiver not visible, this method\n* may still indicate that it is considered visible even though\n* it may not actually be showing.\n* </p>\n*\n* @return the receiver's visibility state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public boolean getVisible()"
		},
		"public void setLocation(int x, int y)":{
			"methodBody":"{\n    checkWidget();\n    if ((style & (SWT.BAR | SWT.DROP_DOWN)) != 0)\n        return;\n    this.x = x;\n    this.y = y;\n    hasLocation = true;\n}",
			"comments":"/**\n* Sets the location of the receiver, which must be a popup,\n* to the point specified by the arguments which are relative\n* to the display.\n* <p>\n* Note that this is different from most widgets where the\n* location of the widget is relative to the parent.\n* </p><p>\n* Note that the platform window manager ultimately has control\n* over the location of popup menus.\n* </p>\n*\n* @param x the new x coordinate for the receiver\n* @param y the new y coordinate for the receiver\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setLocation(int x, int y)"
		},
		"static Menu checkNull(Menu menu)":{
			"methodBody":"{\n    if (menu == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    return menu;\n}",
			"comments":"",
			"methodName":"static Menu checkNull(Menu menu)"
		},
		"void createItem(MenuItem item, int index)":{
			"methodBody":"{\n    int count = GetMenuItemCount(handle);\n    if (!(0 <= index && index <= count))\n        error(SWT.ERROR_INVALID_RANGE);\n    display.addMenuItem(item);\n    boolean success = false;\n    if ((OS.IsPPC || OS.IsSP) && hwndCB != 0) {\n        if (OS.IsSP)\n            return;\n        TBBUTTON lpButton = new TBBUTTON();\n        lpButton.idCommand = item.id;\n        lpButton.fsStyle = (byte) OS.TBSTYLE_AUTOSIZE;\n        if ((item.style & SWT.CASCADE) != 0)\n            lpButton.fsStyle |= OS.TBSTYLE_DROPDOWN | 0x80;\n        if ((item.style & SWT.SEPARATOR) != 0)\n            lpButton.fsStyle = (byte) OS.BTNS_SEP;\n        lpButton.fsState = (byte) OS.TBSTATE_ENABLED;\n        lpButton.iBitmap = OS.I_IMAGENONE;\n        success = OS.SendMessage(hwndCB, OS.TB_INSERTBUTTON, index, lpButton) != 0;\n    } else {\n        if (OS.IsWinCE) {\n            int uFlags = OS.MF_BYPOSITION;\n            TCHAR lpNewItem = null;\n            if ((item.style & SWT.SEPARATOR) != 0) {\n                uFlags |= OS.MF_SEPARATOR;\n            } else {\n                lpNewItem = new TCHAR(0, \" \", true);\n            }\n            success = OS.InsertMenu(handle, index, uFlags, item.id, lpNewItem);\n            if (success) {\n                MENUITEMINFO info = new MENUITEMINFO();\n                info.cbSize = MENUITEMINFO.sizeof;\n                info.fMask = OS.MIIM_DATA;\n                info.dwItemData = item.id;\n                success = OS.SetMenuItemInfo(handle, index, true, info);\n            }\n        } else {\n            \n            int hHeap = OS.GetProcessHeap();\n            TCHAR buffer = new TCHAR(0, \" \", true);\n            int byteCount = buffer.length() * TCHAR.sizeof;\n            int pszText = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, byteCount);\n            OS.MoveMemory(pszText, buffer, byteCount);\n            MENUITEMINFO info = new MENUITEMINFO();\n            info.cbSize = MENUITEMINFO.sizeof;\n            info.fMask = OS.MIIM_ID | OS.MIIM_TYPE | OS.MIIM_DATA;\n            info.wID = info.dwItemData = item.id;\n            info.fType = item.widgetStyle();\n            info.dwTypeData = pszText;\n            success = OS.InsertMenuItem(handle, index, true, info);\n            if (pszText != 0)\n                OS.HeapFree(hHeap, 0, pszText);\n        }\n    }\n    if (!success) {\n        display.removeMenuItem(item);\n        error(SWT.ERROR_ITEM_NOT_ADDED);\n    }\n    redraw();\n}",
			"comments":"/*\n* Bug in Windows.  For some reason, when InsertMenuItem()\n* is used to insert an item without text, it is not possible\n* to use SetMenuItemInfo() to set the text at a later time.\n* The fix is to insert the item with some text.\n*\n* Feature in Windows.  When an empty string is used instead\n* of a space and InsertMenuItem() is used to set a submenu\n* before setting text to a non-empty string, the menu item\n* becomes unexpectedly disabled.  The fix is to insert a\n* space.\n*/\n",
			"methodName":"void createItem(MenuItem item, int index)"
		},
		"void releaseChild()":{
			"methodBody":"{\n    super.releaseChild();\n    if (cascade != null)\n        cascade.releaseMenu();\n    if ((style & SWT.BAR) != 0) {\n        display.removeBar(this);\n        if (this == parent.menuBar) {\n            parent.setMenuBar(null);\n        }\n    } else {\n        if ((style & SWT.POP_UP) != 0) {\n            display.removePopup(this);\n        }\n    }\n}",
			"comments":"",
			"methodName":"void releaseChild()"
		},
		"public void setLocation(Point location)":{
			"methodBody":"{\n    checkWidget();\n    if (location == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    setLocation(location.x, location.y);\n}",
			"comments":"/**\n* Sets the location of the receiver, which must be a popup,\n* to the point specified by the argument which is relative\n* to the display.\n* <p>\n* Note that this is different from most widgets where the\n* location of the widget is relative to the parent.\n* </p><p>\n* Note that the platform window manager ultimately has control\n* over the location of popup menus.\n* </p>\n*\n* @param location the new location for the receiver\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the point is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 2.1\n*/\n",
			"methodName":"public void setLocation(Point location)"
		},
		"static Control checkNull(Control control)":{
			"methodBody":"{\n    if (control == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    return control;\n}",
			"comments":"",
			"methodName":"static Control checkNull(Control control)"
		},
		"public Shell getShell()":{
			"methodBody":"{\n    checkWidget();\n    return parent.getShell();\n}",
			"comments":"/**\n* Returns the receiver's shell. For all controls other than\n* shells, this simply returns the control's nearest ancestor\n* shell. Shells return themselves, even if they are children\n* of other shells.\n*\n* @return the receiver's shell\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #getParent\n*/\n",
			"methodName":"public Shell getShell()"
		},
		"Rectangle getBounds()":{
			"methodBody":"{\n    checkWidget();\n    if (OS.IsWinCE)\n        return new Rectangle(0, 0, 0, 0);\n    if ((style & SWT.BAR) != 0) {\n        if (parent.menuBar != this) {\n            return new Rectangle(0, 0, 0, 0);\n        }\n        int hwndShell = parent.handle;\n        MENUBARINFO info = new MENUBARINFO();\n        info.cbSize = MENUBARINFO.sizeof;\n        if (OS.GetMenuBarInfo(hwndShell, OS.OBJID_MENU, 0, info)) {\n            int width = info.right - info.left;\n            int height = info.bottom - info.top;\n            return new Rectangle(info.left, info.top, width, height);\n        }\n    } else {\n        int count = GetMenuItemCount(handle);\n        if (count != 0) {\n            RECT rect1 = new RECT();\n            if (OS.GetMenuItemRect(0, handle, 0, rect1)) {\n                RECT rect2 = new RECT();\n                if (OS.GetMenuItemRect(0, handle, count - 1, rect2)) {\n                    int x = rect1.left - 2, y = rect1.top - 2;\n                    int width = (rect2.right - rect2.left) + 4;\n                    int height = (rect2.bottom - rect1.top) + 4;\n                    return new Rectangle(x, y, width, height);\n                }\n            }\n        }\n    }\n    return new Rectangle(0, 0, 0, 0);\n}",
			"comments":"/**\n* Returns a rectangle describing the receiver's size and location\n* relative to its parent (or its display if its parent is null),\n* unless the receiver is a menu or a shell. In this case, the\n* location is relative to the display.\n* <p>\n* Note that the bounds of a menu or menu item are undefined when\n* the menu is not visible.  This is because most platforms compute\n* the bounds of a menu dynamically just before it is displayed.\n* </p>\n*\n* @return the receiver's bounding rectangle\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.1\n*/\n/*public*/\n",
			"methodName":"Rectangle getBounds()"
		},
		"public int getItemCount()":{
			"methodBody":"{\n    checkWidget();\n    return GetMenuItemCount(handle);\n}",
			"comments":"/**\n* Returns the number of items contained in the receiver.\n*\n* @return the number of items\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getItemCount()"
		},
		"public int indexOf(MenuItem item)":{
			"methodBody":"{\n    checkWidget();\n    if (item == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (item.isDisposed())\n        error(SWT.ERROR_INVALID_ARGUMENT);\n    if (item.parent != this)\n        return -1;\n    if ((OS.IsPPC || OS.IsSP) && hwndCB != 0) {\n        if (OS.IsPPC) {\n            return OS.SendMessage(hwndCB, OS.TB_COMMANDTOINDEX, item.id, 0);\n        }\n        if (OS.IsSP) {\n            if (item.id == id0)\n                return 0;\n            if (item.id == id1)\n                return 1;\n            return -1;\n        }\n    }\n    int index = 0;\n    MENUITEMINFO info = new MENUITEMINFO();\n    info.cbSize = MENUITEMINFO.sizeof;\n    info.fMask = OS.MIIM_DATA;\n    while (OS.GetMenuItemInfo(handle, index, true, info)) {\n        if (info.dwItemData == item.id)\n            return index;\n        index++;\n    }\n    return -1;\n}",
			"comments":"/**\n* Searches the receiver's list starting at the first item\n* (index 0) until an item is found that is equal to the\n* argument, and returns the index of that item. If no item\n* is found, returns -1.\n*\n* @param item the search item\n* @return the index of the item\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the string is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int indexOf(MenuItem item)"
		},
		"public boolean isVisible()":{
			"methodBody":"{\n    checkWidget();\n    return getVisible();\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver is visible and all\n* of the receiver's ancestors are visible and <code>false</code>\n* otherwise.\n*\n* @return the receiver's visibility state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #getVisible\n*/\n",
			"methodName":"public boolean isVisible()"
		}
	},
	"ClassORInterfaceName":[
		"Menu"
	]
}
