{
	"variables":[
		"EXPECTED_DATA_LENGTH",
		"WIDTH_DATA_OFFSET",
		"HEIGHT_DATA_OFFSET",
		"BIT_DEPTH_OFFSET",
		"COLOR_TYPE_OFFSET",
		"COMPRESSION_METHOD_OFFSET",
		"FILTER_METHOD_OFFSET",
		"INTERLACE_METHOD_OFFSET",
		"COLOR_TYPE_GRAYSCALE",
		"COLOR_TYPE_RGB",
		"COLOR_TYPE_PALETTE",
		"COLOR_TYPE_GRAYSCALE_WITH_ALPHA",
		"COLOR_TYPE_RGB_WITH_ALPHA",
		"INTERLACE_METHOD_NONE",
		"INTERLACE_METHOD_ADAM7",
		"FILTER_NONE",
		"FILTER_SUB",
		"FILTER_UP",
		"FILTER_AVERAGE",
		"FILTER_PAETH",
		"ValidBitDepths",
		"ValidColorTypes",
		"colorTypeIsValid",
		"colorType",
		"i",
		"bitDepthIsValid",
		"bitDepth",
		"i",
		"colorType",
		"bitDepth",
		"bitDepth",
		"bitDepth",
		"max",
		"delta",
		"gray",
		"rgbs",
		"i",
		"DATA_OFFSET",
		"DATA_OFFSET",
		"DATA_OFFSET",
		"DATA_OFFSET",
		"DATA_OFFSET",
		"DATA_OFFSET",
		"DATA_OFFSET",
		"reference",
		"WIDTH_DATA_OFFSET",
		"WIDTH_DATA_OFFSET",
		"value",
		"HEIGHT_DATA_OFFSET",
		"HEIGHT_DATA_OFFSET",
		"value",
		"reference",
		"BIT_DEPTH_OFFSET",
		"reference",
		"BIT_DEPTH_OFFSET",
		"value",
		"reference",
		"COLOR_TYPE_OFFSET",
		"reference",
		"COLOR_TYPE_OFFSET",
		"value",
		"reference",
		"COMPRESSION_METHOD_OFFSET",
		"reference",
		"COMPRESSION_METHOD_OFFSET",
		"value",
		"reference",
		"FILTER_METHOD_OFFSET",
		"reference",
		"FILTER_METHOD_OFFSET",
		"value",
		"reference",
		"INTERLACE_METHOD_OFFSET",
		"reference",
		"INTERLACE_METHOD_OFFSET",
		"value",
		"readState",
		"readState",
		"readState",
		"readState",
		"SWT",
		"SWT",
		"readState",
		"readState",
		"headerChunk",
		"EXPECTED_DATA_LENGTH",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"INTERLACE_METHOD_NONE",
		"INTERLACE_METHOD_ADAM7",
		"SWT",
		"SWT",
		"i",
		"ValidColorTypes",
		"i",
		"ValidColorTypes",
		"i",
		"colorType",
		"colorTypeIsValid",
		"colorTypeIsValid",
		"SWT",
		"SWT",
		"i",
		"ValidBitDepths",
		"i",
		"ValidBitDepths",
		"i",
		"bitDepth",
		"bitDepthIsValid",
		"bitDepthIsValid",
		"SWT",
		"SWT",
		"colorType",
		"COLOR_TYPE_RGB",
		"colorType",
		"COLOR_TYPE_RGB_WITH_ALPHA",
		"colorType",
		"COLOR_TYPE_GRAYSCALE_WITH_ALPHA",
		"bitDepth",
		"SWT",
		"SWT",
		"colorType",
		"COLOR_TYPE_PALETTE",
		"bitDepth",
		"SWT",
		"SWT",
		"COLOR_TYPE_GRAYSCALE",
		"COLOR_TYPE_RGB",
		"COLOR_TYPE_PALETTE",
		"COLOR_TYPE_GRAYSCALE_WITH_ALPHA",
		"COLOR_TYPE_RGB_WITH_ALPHA",
		"FILTER_NONE",
		"FILTER_SUB",
		"FILTER_UP",
		"FILTER_AVERAGE",
		"FILTER_PAETH",
		"INTERLACE_METHOD_NONE",
		"INTERLACE_METHOD_ADAM7",
		"buffer",
		"buffer",
		"buffer",
		"buffer",
		"buffer",
		"buffer",
		"buffer",
		"buffer",
		"buffer",
		"buffer",
		"buffer",
		"buffer",
		"buffer",
		"buffer",
		"COLOR_TYPE_PALETTE",
		"colorType",
		"COLOR_TYPE_GRAYSCALE",
		"colorType",
		"COLOR_TYPE_GRAYSCALE_WITH_ALPHA",
		"COLOR_TYPE_RGB_WITH_ALPHA",
		"bitDepth",
		"COLOR_TYPE_RGB",
		"bitDepth",
		"COLOR_TYPE_GRAYSCALE_WITH_ALPHA",
		"bitDepth",
		"COLOR_TYPE_GRAYSCALE",
		"COLOR_TYPE_PALETTE",
		"bitDepth",
		"SWT",
		"SWT",
		"COLOR_TYPE_RGB_WITH_ALPHA",
		"COLOR_TYPE_RGB",
		"COLOR_TYPE_GRAYSCALE_WITH_ALPHA",
		"COLOR_TYPE_GRAYSCALE",
		"COLOR_TYPE_PALETTE",
		"Math",
		"bitDepth",
		"SWT",
		"SWT",
		"COLOR_TYPE_GRAYSCALE",
		"COLOR_TYPE_GRAYSCALE_WITH_ALPHA",
		"COLOR_TYPE_RGB",
		"COLOR_TYPE_RGB_WITH_ALPHA",
		"Math",
		"Compatibility",
		"bitDepth",
		"max",
		"max",
		"i",
		"max",
		"i",
		"rgbs",
		"i",
		"gray",
		"gray",
		"gray",
		"gray",
		"delta",
		"rgbs",
		"COLOR_TYPE_GRAYSCALE",
		"COLOR_TYPE_GRAYSCALE_WITH_ALPHA",
		"COLOR_TYPE_RGB",
		"COLOR_TYPE_RGB_WITH_ALPHA",
		"readIHDR",
		"readPLTE",
		"readIDAT",
		"readIEND",
		"ERROR_INVALID_IMAGE",
		"readIHDR",
		"ERROR_INVALID_IMAGE",
		"ERROR_INVALID_IMAGE",
		"ERROR_INVALID_IMAGE",
		"length",
		"ERROR_INVALID_IMAGE",
		"length",
		"ERROR_INVALID_IMAGE",
		"ERROR_INVALID_IMAGE",
		"ERROR_INVALID_IMAGE",
		"ERROR_INVALID_IMAGE",
		"ERROR_INVALID_IMAGE",
		"reference",
		"value",
		"value",
		"value",
		"value",
		"value",
		"value",
		"value",
		"readState",
		"headerChunk",
		"buffer"
	],
	"extendORImplementFiles":[
		"PngChunk"
	],
	"package":[
		"org.eclipse.swt.internal.image"
	],
	"import":[
		"org.eclipse.swt",
		"org.eclipse.swt.graphics",
		"org.eclipse.swt.internal.Compatibility"
	],
	"methods":[
		"getWidth",
		"setWidth",
		"getHeight",
		"setHeight",
		"getBitDepth",
		"setBitDepth",
		"getColorType",
		"setColorType",
		"getCompressionMethod",
		"setCompressionMethod",
		"getFilterMethod",
		"setFilterMethod",
		"getInterlaceMethod",
		"setInterlaceMethod",
		"validate",
		"getColorTypeString",
		"getFilterMethodString",
		"getInterlaceMethodString",
		"contributeToString",
		"getMustHavePalette",
		"getCanHavePalette",
		"getBitsPerPixel",
		"getSwtBitsPerPixel",
		"getFilterByteOffset",
		"usesDirectColor",
		"createGrayscalePalette",
		"getPaletteData",
		"getInt32",
		"setInt32",
		"getInt32",
		"setInt32",
		"error",
		"validate",
		"getLength",
		"error",
		"getCompressionMethod",
		"error",
		"getInterlaceMethod",
		"getInterlaceMethod",
		"error",
		"getColorType",
		"error",
		"getBitDepth",
		"error",
		"error",
		"error",
		"getColorType",
		"getColorType",
		"getFilterMethod",
		"getInterlaceMethod",
		"append",
		"append",
		"getWidth",
		"append",
		"append",
		"getHeight",
		"append",
		"append",
		"getBitDepth",
		"append",
		"append",
		"getColorTypeString",
		"append",
		"append",
		"getCompressionMethod",
		"append",
		"append",
		"getFilterMethodString",
		"append",
		"append",
		"getInterlaceMethodString",
		"getColorType",
		"getColorType",
		"getBitDepth",
		"getColorType",
		"error",
		"getBitDepth",
		"getColorType",
		"min",
		"error",
		"getBitDepth",
		"getBitsPerPixel",
		"getColorType",
		"min",
		"getBitDepth",
		"pow2",
		"getColorType",
		"createGrayscalePalette",
		"RGB",
		"PaletteData",
		"PaletteData"
	],
	"methodsBody":{
		"byte getInterlaceMethod()":{
			"methodBody":"{\n    return reference[INTERLACE_METHOD_OFFSET];\n}",
			"comments":"/**\n* Get the image's interlace method.\n* This value is limited to:\n* 0 - No interlacing used.\n* 1 - Adam7 interlacing used.\n*/\n",
			"methodName":"byte getInterlaceMethod()"
		},
		"String getFilterMethodString()":{
			"methodBody":"{\n    switch(getFilterMethod()) {\n        case FILTER_NONE:\n            return \"None\";\n        case FILTER_SUB:\n            return \"Sub\";\n        case FILTER_UP:\n            return \"Up\";\n        case FILTER_AVERAGE:\n            return \"Average\";\n        case FILTER_PAETH:\n            return \"Paeth\";\n        default:\n            return \"Unknown\";\n    }\n}",
			"comments":"",
			"methodName":"String getFilterMethodString()"
		},
		"byte getCompressionMethod()":{
			"methodBody":"{\n    return reference[COMPRESSION_METHOD_OFFSET];\n}",
			"comments":"/**\n* Get the image's compression method.\n* This value must be 0.\n*/\n",
			"methodName":"byte getCompressionMethod()"
		},
		"int getFilterByteOffset()":{
			"methodBody":"{\n    if (getBitDepth() < 8)\n        return 1;\n    return getBitsPerPixel() / 8;\n}",
			"comments":"",
			"methodName":"int getFilterByteOffset()"
		},
		"void setBitDepth(byte value)":{
			"methodBody":"{\n    reference[BIT_DEPTH_OFFSET] = value;\n}",
			"comments":"/**\n* Set the image's bit depth.\n* This is limited to the values 1, 2, 4, 8, or 16.\n*/\n",
			"methodName":"void setBitDepth(byte value)"
		},
		"void contributeToString(StringBuffer buffer)":{
			"methodBody":"{\n    buffer.append(\"\\n\\tWidth: \");\n    buffer.append(getWidth());\n    buffer.append(\"\\n\\tHeight: \");\n    buffer.append(getHeight());\n    buffer.append(\"\\n\\tBit Depth: \");\n    buffer.append(getBitDepth());\n    buffer.append(\"\\n\\tColor Type: \");\n    buffer.append(getColorTypeString());\n    buffer.append(\"\\n\\tCompression Method: \");\n    buffer.append(getCompressionMethod());\n    buffer.append(\"\\n\\tFilter Method: \");\n    buffer.append(getFilterMethodString());\n    buffer.append(\"\\n\\tInterlace Method: \");\n    buffer.append(getInterlaceMethodString());\n}",
			"comments":"",
			"methodName":"void contributeToString(StringBuffer buffer)"
		},
		"int getBitsPerPixel()":{
			"methodBody":"{\n    int bitDepth = getBitDepth();\n    switch(getColorType()) {\n        case COLOR_TYPE_RGB_WITH_ALPHA:\n            return 4 * bitDepth;\n        case COLOR_TYPE_RGB:\n            return 3 * bitDepth;\n        case COLOR_TYPE_GRAYSCALE_WITH_ALPHA:\n            return 2 * bitDepth;\n        case COLOR_TYPE_GRAYSCALE:\n        case COLOR_TYPE_PALETTE:\n            return bitDepth;\n        default:\n            SWT.error(SWT.ERROR_INVALID_IMAGE);\n            return 0;\n    }\n}",
			"comments":"/**\n* Answer the pixel size in bits based on the color type\n* and bit depth.\n*/\n",
			"methodName":"int getBitsPerPixel()"
		},
		"byte getBitDepth()":{
			"methodBody":"{\n    return reference[BIT_DEPTH_OFFSET];\n}",
			"comments":"/**\n* Get the image's bit depth.\n* This is limited to the values 1, 2, 4, 8, or 16.\n*/\n",
			"methodName":"byte getBitDepth()"
		},
		"boolean usesDirectColor()":{
			"methodBody":"{\n    switch(getColorType()) {\n        case COLOR_TYPE_GRAYSCALE:\n        case COLOR_TYPE_GRAYSCALE_WITH_ALPHA:\n        case COLOR_TYPE_RGB:\n        case COLOR_TYPE_RGB_WITH_ALPHA:\n            return true;\n        default:\n            return false;\n    }\n}",
			"comments":"",
			"methodName":"boolean usesDirectColor()"
		},
		"void setWidth(int value)":{
			"methodBody":"{\n    setInt32(WIDTH_DATA_OFFSET, value);\n}",
			"comments":"/**\n* Set the image's width in pixels.\n*/\n",
			"methodName":"void setWidth(int value)"
		},
		"boolean getCanHavePalette()":{
			"methodBody":"{\n    int colorType = getColorType();\n    return colorType != COLOR_TYPE_GRAYSCALE && colorType != COLOR_TYPE_GRAYSCALE_WITH_ALPHA;\n}",
			"comments":"",
			"methodName":"boolean getCanHavePalette()"
		},
		"byte getColorType()":{
			"methodBody":"{\n    return reference[COLOR_TYPE_OFFSET];\n}",
			"comments":"/**\n* Get the image's color type.\n* This is limited to the values:\n* 0 - Grayscale image.\n* 2 - RGB triple.\n* 3 - Palette.\n* 4 - Grayscale with Alpha channel.\n* 6 - RGB with Alpha channel.\n*/\n",
			"methodName":"byte getColorType()"
		},
		"void setColorType(byte value)":{
			"methodBody":"{\n    reference[COLOR_TYPE_OFFSET] = value;\n}",
			"comments":"/**\n* Set the image's color type.\n* This is limited to the values:\n* 0 - Grayscale image.\n* 2 - RGB triple.\n* 3 - Palette.\n* 4 - Grayscale with Alpha channel.\n* 6 - RGB with Alpha channel.\n*/\n",
			"methodName":"void setColorType(byte value)"
		},
		"PaletteData createGrayscalePalette()":{
			"methodBody":"{\n    int bitDepth = Math.min(getBitDepth(), 8);\n    int max = Compatibility.pow2(bitDepth) - 1;\n    int delta = 255 / max;\n    int gray = 0;\n    RGB[] rgbs = new RGB[max + 1];\n    for (int i = 0; i <= max; i++) {\n        rgbs[i] = new RGB(gray, gray, gray);\n        gray += delta;\n    }\n    return new PaletteData(rgbs);\n}",
			"comments":"",
			"methodName":"PaletteData createGrayscalePalette()"
		},
		"PaletteData getPaletteData()":{
			"methodBody":"{\n    switch(getColorType()) {\n        case COLOR_TYPE_GRAYSCALE:\n            return createGrayscalePalette();\n        case COLOR_TYPE_GRAYSCALE_WITH_ALPHA:\n        case COLOR_TYPE_RGB:\n        case COLOR_TYPE_RGB_WITH_ALPHA:\n            return new PaletteData(0xFF0000, 0xFF00, 0xFF);\n        default:\n            return null;\n    }\n}",
			"comments":"",
			"methodName":"PaletteData getPaletteData()"
		},
		"byte getFilterMethod()":{
			"methodBody":"{\n    return reference[FILTER_METHOD_OFFSET];\n}",
			"comments":"/**\n* Get the image's filter method.\n* This value must be 0.\n*/\n",
			"methodName":"byte getFilterMethod()"
		},
		"int getSwtBitsPerPixel()":{
			"methodBody":"{\n    int bitDepth = getBitDepth();\n    switch(getColorType()) {\n        case COLOR_TYPE_RGB_WITH_ALPHA:\n        case COLOR_TYPE_RGB:\n        case COLOR_TYPE_GRAYSCALE_WITH_ALPHA:\n            return 24;\n        case COLOR_TYPE_GRAYSCALE:\n        case COLOR_TYPE_PALETTE:\n            return Math.min(bitDepth, 8);\n        default:\n            SWT.error(SWT.ERROR_INVALID_IMAGE);\n            return 0;\n    }\n}",
			"comments":"/**\n* Answer the pixel size in bits based on the color type\n* and bit depth.\n*/\n",
			"methodName":"int getSwtBitsPerPixel()"
		},
		"void setFilterMethod(byte value)":{
			"methodBody":"{\n    reference[FILTER_METHOD_OFFSET] = value;\n}",
			"comments":"/**\n* Set the image's filter method.\n* This value must be 0.\n*/\n",
			"methodName":"void setFilterMethod(byte value)"
		},
		"String getColorTypeString()":{
			"methodBody":"{\n    switch(getColorType()) {\n        case COLOR_TYPE_GRAYSCALE:\n            return \"Grayscale\";\n        case COLOR_TYPE_RGB:\n            return \"RGB\";\n        case COLOR_TYPE_PALETTE:\n            return \"Palette\";\n        case COLOR_TYPE_GRAYSCALE_WITH_ALPHA:\n            return \"Grayscale with Alpha\";\n        case COLOR_TYPE_RGB_WITH_ALPHA:\n            return \"RGB with Alpha\";\n        default:\n            return \"Unknown - \" + getColorType();\n    }\n}",
			"comments":"",
			"methodName":"String getColorTypeString()"
		},
		"boolean getMustHavePalette()":{
			"methodBody":"{\n    return getColorType() == COLOR_TYPE_PALETTE;\n}",
			"comments":"",
			"methodName":"boolean getMustHavePalette()"
		},
		"int getWidth()":{
			"methodBody":"{\n    return getInt32(WIDTH_DATA_OFFSET);\n}",
			"comments":"/**\n* Get the image's width in pixels.\n*/\n",
			"methodName":"int getWidth()"
		},
		"String getInterlaceMethodString()":{
			"methodBody":"{\n    switch(getInterlaceMethod()) {\n        case INTERLACE_METHOD_NONE:\n            return \"Not Interlaced\";\n        case INTERLACE_METHOD_ADAM7:\n            return \"Interlaced - ADAM7\";\n        default:\n            return \"Unknown\";\n    }\n}",
			"comments":"",
			"methodName":"String getInterlaceMethodString()"
		},
		"void setInterlaceMethod(byte value)":{
			"methodBody":"{\n    reference[INTERLACE_METHOD_OFFSET] = value;\n}",
			"comments":"/**\n* Set the image's interlace method.\n* This value is limited to:\n* 0 - No interlacing used.\n* 1 - Adam7 interlacing used.\n*/\n",
			"methodName":"void setInterlaceMethod(byte value)"
		},
		"void setCompressionMethod(byte value)":{
			"methodBody":"{\n    reference[COMPRESSION_METHOD_OFFSET] = value;\n}",
			"comments":"/**\n* Set the image's compression method.\n* This value must be 0.\n*/\n",
			"methodName":"void setCompressionMethod(byte value)"
		},
		"int getHeight()":{
			"methodBody":"{\n    return getInt32(HEIGHT_DATA_OFFSET);\n}",
			"comments":"/**\n* Get the image's height in pixels.\n*/\n",
			"methodName":"int getHeight()"
		},
		"void validate(PngFileReadState readState, PngIhdrChunk headerChunk)":{
			"methodBody":"{\n    \n    if (readState.readIHDR || readState.readPLTE || readState.readIDAT || readState.readIEND) {\n        SWT.error(SWT.ERROR_INVALID_IMAGE);\n    } else {\n        readState.readIHDR = true;\n    }\n    super.validate(readState, headerChunk);\n    if (getLength() != EXPECTED_DATA_LENGTH)\n        SWT.error(SWT.ERROR_INVALID_IMAGE);\n    if (getCompressionMethod() != 0)\n        SWT.error(SWT.ERROR_INVALID_IMAGE);\n    if (getInterlaceMethod() != INTERLACE_METHOD_NONE && getInterlaceMethod() != INTERLACE_METHOD_ADAM7) {\n        SWT.error(SWT.ERROR_INVALID_IMAGE);\n    }\n    boolean colorTypeIsValid = false;\n    byte colorType = getColorType();\n    for (int i = 0; i < ValidColorTypes.length; i++) {\n        if (ValidColorTypes[i] == colorType) {\n            colorTypeIsValid = true;\n            break;\n        }\n    }\n    if (!colorTypeIsValid)\n        SWT.error(SWT.ERROR_INVALID_IMAGE);\n    boolean bitDepthIsValid = false;\n    byte bitDepth = getBitDepth();\n    for (int i = 0; i < ValidBitDepths.length; i++) {\n        if (ValidBitDepths[i] == bitDepth) {\n            bitDepthIsValid = true;\n            break;\n        }\n    }\n    if (!bitDepthIsValid)\n        SWT.error(SWT.ERROR_INVALID_IMAGE);\n    if ((colorType == COLOR_TYPE_RGB || colorType == COLOR_TYPE_RGB_WITH_ALPHA || colorType == COLOR_TYPE_GRAYSCALE_WITH_ALPHA) && bitDepth < 8) {\n        SWT.error(SWT.ERROR_INVALID_IMAGE);\n    }\n    if (colorType == COLOR_TYPE_PALETTE && bitDepth > 8) {\n        SWT.error(SWT.ERROR_INVALID_IMAGE);\n    }\n}",
			"comments":"/**\n* Answer whether the chunk is a valid IHDR chunk.\n*/\n// An IHDR chunk is invalid if any other chunk has\n// been read.\n",
			"methodName":"void validate(PngFileReadState readState, PngIhdrChunk headerChunk)"
		},
		"void setHeight(int value)":{
			"methodBody":"{\n    setInt32(HEIGHT_DATA_OFFSET, value);\n}",
			"comments":"/**\n* Set the image's height in pixels.\n*/\n",
			"methodName":"void setHeight(int value)"
		}
	},
	"ClassORInterfaceName":[
		"PngIhdrChunk"
	]
}
