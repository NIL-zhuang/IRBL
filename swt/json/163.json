{
	"variables":[
		"handle",
		"drawable",
		"data",
		"LINE_DOT_ZERO",
		"LINE_DASH_ZERO",
		"LINE_DASHDOT_ZERO",
		"LINE_DASHDOTDOT_ZERO",
		"data",
		"hDC",
		"device",
		"device",
		"hDC",
		"rect",
		"memHdc",
		"hOldBitmap",
		"hwnd",
		"lprcClip",
		"hrgn",
		"lprcScroll",
		"flags",
		"res",
		"deltaX",
		"deltaY",
		"disjoint",
		"newX",
		"newY",
		"colorRef",
		"rgb",
		"color",
		"brush",
		"font",
		"logFont",
		"size",
		"style",
		"chars",
		"bytes",
		"index",
		"name",
		"buffer",
		"style",
		"colorRef",
		"width",
		"size",
		"hPen",
		"logPen",
		"logPen",
		"hHeap",
		"ptr",
		"rgb",
		"color",
		"pen",
		"dashes",
		"dashStyle",
		"i",
		"dash",
		"joinStyle",
		"dashCap",
		"capStyle",
		"type",
		"nullPen",
		"nullBrush",
		"hNullBitmap",
		"image",
		"device",
		"gdipGraphics",
		"points",
		"cteX",
		"cteY",
		"index",
		"i",
		"x1",
		"y1",
		"x2",
		"y2",
		"tmp",
		"isNegative",
		"nullBrush",
		"oldBrush",
		"rect",
		"gdipImage",
		"img",
		"imgWidth",
		"imgHeight",
		"rect",
		"hHeap",
		"technology",
		"drawIcon",
		"flags",
		"srcIconInfo",
		"hBitmap",
		"bm",
		"iconWidth",
		"iconHeight",
		"failed",
		"newIconInfo",
		"srcHdc",
		"dstHdc",
		"srcColorY",
		"srcColor",
		"oldSrcBitmap",
		"oldDestBitmap",
		"stretch",
		"hIcon",
		"bm",
		"imgWidth",
		"imgHeight",
		"mustRestore",
		"memGC",
		"data",
		"hOldBitmap",
		"fixAlpha",
		"dstBitmap",
		"dstBM",
		"dstDib",
		"oldDstBitmap",
		"dstHdc",
		"dstX",
		"dstY",
		"blend",
		"srcHdc",
		"oldSrcBitmap",
		"memDib",
		"memHdc",
		"oldMemBitmap",
		"dibBM",
		"srcData",
		"apinc",
		"ap",
		"sp",
		"alphaData",
		"y",
		"x",
		"alpha",
		"rect",
		"sx1",
		"sx2",
		"sy1",
		"sy2",
		"srcHdc",
		"oldSrcBitmap",
		"memHdc",
		"memDib",
		"oldMemBitmap",
		"dibBM",
		"sizeInBytes",
		"destData",
		"srcData",
		"alpha",
		"hasAlphaChannel",
		"apinc",
		"spinc",
		"ap",
		"sp",
		"alphaData",
		"y",
		"x",
		"tempHdc",
		"tempDib",
		"oldTempBitmap",
		"dpinc",
		"dp",
		"y",
		"x",
		"rgn",
		"y",
		"x",
		"tempRgn",
		"nBytes",
		"lpRgnData",
		"lpXform",
		"tmpRgn",
		"clip",
		"result",
		"rop2",
		"dwRop",
		"mode",
		"srcColorY",
		"srcHdc",
		"oldSrcBitmap",
		"destHdc",
		"x",
		"y",
		"tempHdc",
		"tempBitmap",
		"oldTempBitmap",
		"oldBkColor",
		"oldTextColor",
		"mode",
		"transBlue",
		"transGreen",
		"transRed",
		"isDib",
		"hBitmap",
		"srcHdc",
		"oldSrcBitmap",
		"originalColors",
		"pBits",
		"oldValue",
		"mask",
		"color",
		"maxColors",
		"oldColors",
		"offset",
		"fixPalette",
		"i",
		"newColors",
		"numColors",
		"bmiHeader",
		"bmi",
		"offset",
		"pixel",
		"transparentColor",
		"mode",
		"maskHdc",
		"maskBitmap",
		"oldMaskBitmap",
		"tempHdc",
		"tempBitmap",
		"oldTempBitmap",
		"srcHdc",
		"oldSrcBitmap",
		"rop2",
		"dwRop",
		"mode",
		"gdipGraphics",
		"points",
		"gdipGraphics",
		"nullBrush",
		"oldBrush",
		"gdipGraphics",
		"gdipGraphics",
		"nullBrush",
		"oldBrush",
		"gdipGraphics",
		"length",
		"gdipGraphics",
		"hOld",
		"nullBrush",
		"oldBrush",
		"nx",
		"ny",
		"nw",
		"nh",
		"naw",
		"nah",
		"naw2",
		"nah2",
		"length",
		"buffer",
		"font",
		"pt",
		"brush",
		"format",
		"bounds",
		"rop2",
		"oldBkMode",
		"foreground",
		"size",
		"width",
		"height",
		"hBitmap",
		"memDC",
		"hOldBitmap",
		"background",
		"flags",
		"length",
		"buffer",
		"font",
		"pt",
		"brush",
		"format",
		"tabs",
		"bounds",
		"buffer",
		"length",
		"rect",
		"limit",
		"uFormat",
		"rop2",
		"oldBkMode",
		"foreground",
		"width",
		"height",
		"hBitmap",
		"memDC",
		"hOldBitmap",
		"background",
		"drawSegments",
		"points",
		"cteX",
		"cteY",
		"index",
		"i",
		"nullPen",
		"oldPen",
		"x1",
		"y1",
		"x2",
		"y2",
		"tmp",
		"isNegative",
		"nullPen",
		"oldPen",
		"fromColor",
		"toColor",
		"swapColors",
		"t",
		"rop2",
		"fromRGB",
		"toRGB",
		"dwRop",
		"p1",
		"p2",
		"rgb",
		"fromGpColor",
		"toGpColor",
		"brush",
		"hHeap",
		"pMesh",
		"pVertex",
		"gradientRect",
		"trivertex",
		"success",
		"depth",
		"bitResolution",
		"nullPen",
		"oldPen",
		"mode",
		"mode",
		"nullPen",
		"oldPen",
		"rop2",
		"dwRop",
		"nullPen",
		"oldPen",
		"nx",
		"ny",
		"nw",
		"nh",
		"naw",
		"nah",
		"naw2",
		"nah2",
		"hdc",
		"size",
		"tch",
		"buffer",
		"width",
		"mode",
		"color",
		"tch",
		"buffer",
		"width",
		"lptm",
		"size",
		"rect",
		"rect",
		"rgn",
		"matrix",
		"identity",
		"hRgn",
		"pt",
		"result",
		"rect",
		"metaRgn",
		"flags",
		"hwnd",
		"sysRgn",
		"lpCs",
		"cs",
		"hFont",
		"lptm",
		"color",
		"mode",
		"style",
		"size",
		"hPen",
		"logPen",
		"logPen",
		"hHeap",
		"ptr",
		"cap",
		"dashes",
		"style",
		"size",
		"hPen",
		"logPen",
		"logPen",
		"hHeap",
		"ptr",
		"join",
		"style",
		"size",
		"hPen",
		"logPen",
		"logPen",
		"hHeap",
		"ptr",
		"size",
		"hPen",
		"logPen",
		"logPen",
		"hHeap",
		"ptr",
		"mode",
		"gdipGraphics",
		"rop2",
		"gdipGraphics",
		"hRgn",
		"result",
		"pt",
		"foreground",
		"newPen",
		"background",
		"newBrush",
		"hFont",
		"hPalette",
		"image",
		"layout",
		"flags",
		"region",
		"result",
		"pt",
		"bounds",
		"mode",
		"newBrush",
		"hRgn",
		"gdipGraphics",
		"region",
		"pt",
		"hRgn",
		"mode",
		"mode",
		"mode",
		"capStyle",
		"i",
		"dash",
		"joinStyle",
		"style",
		"extPen",
		"changed",
		"style",
		"color",
		"width",
		"size",
		"hPen",
		"logPen",
		"logPen",
		"hHeap",
		"ptr",
		"newPen",
		"logBrush",
		"textMode",
		"type",
		"identity",
		"length",
		"font",
		"pt",
		"bounds",
		"buffer",
		"format",
		"size",
		"buffer",
		"font",
		"pt",
		"bounds",
		"buffer",
		"length",
		"format",
		"tabs",
		"size",
		"rect",
		"buffer",
		"uFormat",
		"gc",
		"hDC",
		"gc",
		"drawable",
		"SWT",
		"drawable",
		"SWT",
		"SWT",
		"data",
		"style",
		"drawable",
		"data",
		"data",
		"device",
		"device",
		"Device",
		"device",
		"SWT",
		"SWT",
		"data",
		"device",
		"drawable",
		"data",
		"hDC",
		"device",
		"device",
		"style",
		"SWT",
		"style",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"handle",
		"SWT",
		"SWT",
		"image",
		"SWT",
		"SWT",
		"image",
		"SWT",
		"image",
		"SWT",
		"SWT",
		"data",
		"device",
		"image",
		"OS",
		"hDC",
		"OS",
		"memHdc",
		"image",
		"OS",
		"memHdc",
		"rect",
		"rect",
		"handle",
		"x",
		"y",
		"OS",
		"OS",
		"memHdc",
		"hOldBitmap",
		"OS",
		"memHdc",
		"device",
		"hDC",
		"srcX",
		"srcY",
		"width",
		"height",
		"destX",
		"destY",
		"handle",
		"SWT",
		"SWT",
		"data",
		"hwnd",
		"OS",
		"handle",
		"destX",
		"destY",
		"width",
		"height",
		"handle",
		"srcX",
		"srcY",
		"OS",
		"OS",
		"OS",
		"handle",
		"hrgn",
		"lprcClip",
		"OS",
		"hrgn",
		"lprcClip",
		"OS",
		"hrgn",
		"OS",
		"lprcScroll",
		"srcX",
		"srcY",
		"srcX",
		"width",
		"srcY",
		"height",
		"paint",
		"OS",
		"OS",
		"OS",
		"hwnd",
		"destX",
		"srcX",
		"destY",
		"srcY",
		"lprcScroll",
		"lprcClip",
		"flags",
		"res",
		"OS",
		"OS",
		"handle",
		"destX",
		"destY",
		"width",
		"height",
		"handle",
		"srcX",
		"srcY",
		"OS",
		"paint",
		"destX",
		"srcX",
		"destY",
		"srcY",
		"destX",
		"width",
		"srcX",
		"srcX",
		"width",
		"destX",
		"destY",
		"height",
		"srcY",
		"srcY",
		"height",
		"destY",
		"disjoint",
		"OS",
		"hwnd",
		"lprcScroll",
		"deltaX",
		"destX",
		"deltaX",
		"deltaX",
		"newX",
		"destX",
		"width",
		"OS",
		"lprcScroll",
		"newX",
		"srcY",
		"newX",
		"Math",
		"deltaX",
		"srcY",
		"height",
		"OS",
		"hwnd",
		"lprcScroll",
		"deltaY",
		"destY",
		"deltaY",
		"deltaY",
		"newY",
		"destY",
		"height",
		"OS",
		"lprcScroll",
		"srcX",
		"newY",
		"srcX",
		"width",
		"newY",
		"Math",
		"deltaY",
		"OS",
		"hwnd",
		"lprcScroll",
		"OS",
		"handle",
		"colorRef",
		"colorRef",
		"colorRef",
		"Gdip",
		"data",
		"rgb",
		"color",
		"SWT",
		"SWT",
		"Gdip",
		"color",
		"brush",
		"SWT",
		"SWT",
		"Gdip",
		"color",
		"brush",
		"handle",
		"OS",
		"handle",
		"OS",
		"Gdip",
		"hDC",
		"hFont",
		"font",
		"SWT",
		"SWT",
		"Gdip",
		"font",
		"Gdip",
		"font",
		"OS",
		"OS",
		"hFont",
		"LOGFONT",
		"logFont",
		"Math",
		"logFont",
		"Gdip",
		"logFont",
		"style",
		"Gdip",
		"logFont",
		"style",
		"Gdip",
		"OS",
		"chars",
		"logFont",
		"chars",
		"OS",
		"logFont",
		"OS",
		"OS",
		"OS",
		"bytes",
		"bytes",
		"chars",
		"chars",
		"index",
		"chars",
		"chars",
		"index",
		"index",
		"chars",
		"index",
		"Compatibility",
		"name",
		"name",
		"name",
		"name",
		"name",
		"buffer",
		"font",
		"Gdip",
		"buffer",
		"size",
		"style",
		"Gdip",
		"font",
		"SWT",
		"SWT",
		"font",
		"OS",
		"handle",
		"OS",
		"size",
		"OS",
		"hPen",
		"LOGPEN",
		"OS",
		"hPen",
		"LOGPEN",
		"logPen",
		"colorRef",
		"logPen",
		"width",
		"logPen",
		"style",
		"logPen",
		"width",
		"style",
		"OS",
		"OS",
		"size",
		"EXTLOGPEN",
		"OS",
		"hPen",
		"size",
		"logPen",
		"OS",
		"OS",
		"hHeap",
		"OS",
		"size",
		"OS",
		"hPen",
		"size",
		"ptr",
		"OS",
		"logPen",
		"ptr",
		"EXTLOGPEN",
		"OS",
		"hHeap",
		"ptr",
		"colorRef",
		"logPen",
		"width",
		"logPen",
		"style",
		"logPen",
		"colorRef",
		"colorRef",
		"colorRef",
		"Gdip",
		"data",
		"rgb",
		"Gdip",
		"color",
		"Math",
		"width",
		"Gdip",
		"color",
		"data",
		"Gdip",
		"pen",
		"data",
		"Gdip",
		"style",
		"OS",
		"OS",
		"OS",
		"dashStyle",
		"Gdip",
		"width",
		"dashes",
		"LINE_DOT_ZERO",
		"OS",
		"dashStyle",
		"Gdip",
		"width",
		"dashes",
		"LINE_DASH_ZERO",
		"OS",
		"dashStyle",
		"Gdip",
		"width",
		"dashes",
		"LINE_DASHDOT_ZERO",
		"OS",
		"dashStyle",
		"Gdip",
		"width",
		"dashes",
		"LINE_DASHDOTDOT_ZERO",
		"OS",
		"data",
		"dashes",
		"data",
		"i",
		"data",
		"i",
		"data",
		"i",
		"Math",
		"width",
		"dashes",
		"i",
		"dash",
		"dashes",
		"i",
		"data",
		"dash",
		"dashes",
		"Gdip",
		"pen",
		"dashes",
		"dashes",
		"Gdip",
		"pen",
		"Gdip",
		"Gdip",
		"pen",
		"dashStyle",
		"style",
		"OS",
		"OS",
		"joinStyle",
		"Gdip",
		"OS",
		"joinStyle",
		"Gdip",
		"OS",
		"joinStyle",
		"Gdip",
		"Gdip",
		"pen",
		"joinStyle",
		"Gdip",
		"style",
		"OS",
		"OS",
		"capStyle",
		"Gdip",
		"OS",
		"capStyle",
		"Gdip",
		"dashCap",
		"Gdip",
		"OS",
		"capStyle",
		"Gdip",
		"Gdip",
		"pen",
		"capStyle",
		"capStyle",
		"dashCap",
		"pen",
		"Gdip",
		"brush",
		"type",
		"Gdip",
		"Gdip",
		"brush",
		"Gdip",
		"Gdip",
		"brush",
		"Gdip",
		"Gdip",
		"brush",
		"Gdip",
		"Gdip",
		"brush",
		"handle",
		"data",
		"data",
		"Gdip",
		"data",
		"data",
		"Gdip",
		"data",
		"data",
		"data",
		"data",
		"data",
		"data",
		"data",
		"OS",
		"OS",
		"OS",
		"handle",
		"nullPen",
		"OS",
		"data",
		"data",
		"data",
		"OS",
		"OS",
		"OS",
		"handle",
		"nullBrush",
		"OS",
		"data",
		"data",
		"data",
		"hNullBitmap",
		"OS",
		"handle",
		"hNullBitmap",
		"data",
		"data",
		"image",
		"image",
		"data",
		"drawable",
		"drawable",
		"handle",
		"data",
		"drawable",
		"handle",
		"data",
		"data",
		"device",
		"device",
		"data",
		"data",
		"handle",
		"SWT",
		"SWT",
		"width",
		"x",
		"x",
		"width",
		"width",
		"width",
		"height",
		"y",
		"y",
		"height",
		"height",
		"height",
		"width",
		"height",
		"arcAngle",
		"data",
		"gdipGraphics",
		"data",
		"data",
		"Gdip",
		"gdipGraphics",
		"Gdip",
		"Gdip",
		"gdipGraphics",
		"data",
		"x",
		"y",
		"width",
		"height",
		"startAngle",
		"arcAngle",
		"data",
		"data",
		"Gdip",
		"gdipGraphics",
		"Gdip",
		"OS",
		"arcAngle",
		"startAngle",
		"arcAngle",
		"arcAngle",
		"arcAngle",
		"arcAngle",
		"arcAngle",
		"arcAngle",
		"x",
		"width",
		"y",
		"height",
		"i",
		"arcAngle",
		"i",
		"points",
		"index",
		"Compatibility",
		"startAngle",
		"i",
		"width",
		"cteX",
		"points",
		"index",
		"cteY",
		"Compatibility",
		"startAngle",
		"i",
		"height",
		"OS",
		"handle",
		"points",
		"points",
		"arcAngle",
		"arcAngle",
		"x1",
		"x2",
		"x",
		"width",
		"y1",
		"y2",
		"y",
		"height",
		"isNegative",
		"arcAngle",
		"arcAngle",
		"arcAngle",
		"startAngle",
		"isNegative",
		"tmp",
		"startAngle",
		"startAngle",
		"arcAngle",
		"arcAngle",
		"tmp",
		"x1",
		"Compatibility",
		"startAngle",
		"width",
		"x",
		"width",
		"y1",
		"Compatibility",
		"startAngle",
		"height",
		"y",
		"height",
		"x2",
		"Compatibility",
		"arcAngle",
		"width",
		"x",
		"width",
		"y2",
		"Compatibility",
		"arcAngle",
		"height",
		"y",
		"height",
		"OS",
		"OS",
		"OS",
		"handle",
		"nullBrush",
		"OS",
		"handle",
		"x",
		"y",
		"x",
		"width",
		"y",
		"height",
		"x1",
		"y1",
		"x2",
		"y2",
		"OS",
		"handle",
		"oldBrush",
		"handle",
		"SWT",
		"SWT",
		"OS",
		"rect",
		"x",
		"y",
		"x",
		"width",
		"y",
		"height",
		"OS",
		"handle",
		"rect",
		"handle",
		"SWT",
		"SWT",
		"image",
		"SWT",
		"SWT",
		"image",
		"SWT",
		"SWT",
		"image",
		"x",
		"y",
		"handle",
		"SWT",
		"SWT",
		"srcWidth",
		"srcHeight",
		"destWidth",
		"destHeight",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"destWidth",
		"destHeight",
		"SWT",
		"SWT",
		"image",
		"SWT",
		"SWT",
		"image",
		"SWT",
		"SWT",
		"image",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"data",
		"srcImage",
		"gdipImage",
		"Gdip",
		"img",
		"Gdip",
		"img",
		"simple",
		"srcWidth",
		"destWidth",
		"imgWidth",
		"srcHeight",
		"destHeight",
		"imgHeight",
		"srcX",
		"srcWidth",
		"imgWidth",
		"srcY",
		"srcHeight",
		"imgHeight",
		"SWT",
		"SWT",
		"simple",
		"srcX",
		"srcY",
		"srcWidth",
		"destWidth",
		"destWidth",
		"imgWidth",
		"srcHeight",
		"destHeight",
		"destHeight",
		"imgHeight",
		"simple",
		"Gdip",
		"data",
		"img",
		"destX",
		"destY",
		"rect",
		"destX",
		"rect",
		"destY",
		"rect",
		"destWidth",
		"rect",
		"destHeight",
		"Gdip",
		"data",
		"img",
		"rect",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"Gdip",
		"Gdip",
		"img",
		"gdipImage",
		"OS",
		"OS",
		"hHeap",
		"gdipImage",
		"srcImage",
		"SWT",
		"srcImage",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"simple",
		"SWT",
		"srcImage",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"simple",
		"SWT",
		"SWT",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"flags",
		"OS",
		"OS",
		"OS",
		"OS",
		"drawIcon",
		"OS",
		"handle",
		"OS",
		"simple",
		"technology",
		"OS",
		"drawIcon",
		"OS",
		"handle",
		"destX",
		"destY",
		"srcImage",
		"flags",
		"OS",
		"Image",
		"srcImage",
		"srcIconInfo",
		"OS",
		"srcImage",
		"srcIconInfo",
		"srcIconInfo",
		"hBitmap",
		"hBitmap",
		"srcIconInfo",
		"OS",
		"hBitmap",
		"BITMAP",
		"bm",
		"bm",
		"bm",
		"hBitmap",
		"srcIconInfo",
		"iconHeight",
		"simple",
		"srcWidth",
		"destWidth",
		"iconWidth",
		"srcHeight",
		"destHeight",
		"iconHeight",
		"srcX",
		"srcWidth",
		"iconWidth",
		"srcY",
		"srcHeight",
		"iconHeight",
		"failed",
		"simple",
		"srcX",
		"srcY",
		"srcWidth",
		"destWidth",
		"srcHeight",
		"destHeight",
		"srcWidth",
		"iconWidth",
		"srcHeight",
		"iconHeight",
		"drawIcon",
		"srcImage",
		"srcIconInfo",
		"srcIconInfo",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"simple",
		"iconWidth",
		"iconHeight",
		"simple",
		"technology",
		"OS",
		"OS",
		"handle",
		"destX",
		"destY",
		"srcImage",
		"flags",
		"newIconInfo",
		"OS",
		"handle",
		"OS",
		"handle",
		"srcY",
		"srcIconInfo",
		"srcColor",
		"srcColor",
		"srcIconInfo",
		"srcColorY",
		"iconHeight",
		"OS",
		"srcHdc",
		"srcColor",
		"newIconInfo",
		"OS",
		"srcHdc",
		"destWidth",
		"destHeight",
		"newIconInfo",
		"SWT",
		"SWT",
		"OS",
		"dstHdc",
		"newIconInfo",
		"simple",
		"srcWidth",
		"destWidth",
		"srcHeight",
		"destHeight",
		"stretch",
		"OS",
		"OS",
		"dstHdc",
		"OS",
		"OS",
		"dstHdc",
		"destWidth",
		"destHeight",
		"srcHdc",
		"srcX",
		"srcColorY",
		"srcWidth",
		"srcHeight",
		"OS",
		"OS",
		"dstHdc",
		"destWidth",
		"destHeight",
		"srcHdc",
		"srcX",
		"srcColorY",
		"OS",
		"OS",
		"srcHdc",
		"srcIconInfo",
		"newIconInfo",
		"OS",
		"destWidth",
		"destHeight",
		"newIconInfo",
		"SWT",
		"SWT",
		"OS",
		"dstHdc",
		"newIconInfo",
		"stretch",
		"OS",
		"dstHdc",
		"destWidth",
		"destHeight",
		"srcHdc",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"OS",
		"OS",
		"dstHdc",
		"destWidth",
		"destHeight",
		"srcHdc",
		"srcX",
		"srcY",
		"OS",
		"technology",
		"OS",
		"OS",
		"srcHdc",
		"newIconInfo",
		"OS",
		"dstHdc",
		"newIconInfo",
		"srcHdc",
		"dstHdc",
		"destWidth",
		"destHeight",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"destWidth",
		"destHeight",
		"OS",
		"srcHdc",
		"oldSrcBitmap",
		"OS",
		"dstHdc",
		"oldDestBitmap",
		"OS",
		"srcHdc",
		"oldSrcBitmap",
		"OS",
		"dstHdc",
		"oldDestBitmap",
		"OS",
		"newIconInfo",
		"hIcon",
		"SWT",
		"SWT",
		"OS",
		"handle",
		"destX",
		"destY",
		"hIcon",
		"destWidth",
		"destHeight",
		"flags",
		"OS",
		"hIcon",
		"OS",
		"newIconInfo",
		"OS",
		"newIconInfo",
		"OS",
		"dstHdc",
		"OS",
		"srcHdc",
		"OS",
		"srcIconInfo",
		"srcIconInfo",
		"OS",
		"srcIconInfo",
		"failed",
		"SWT",
		"SWT",
		"OS",
		"srcImage",
		"BITMAP",
		"bm",
		"bm",
		"bm",
		"simple",
		"srcWidth",
		"destWidth",
		"imgWidth",
		"srcHeight",
		"destHeight",
		"imgHeight",
		"srcX",
		"srcWidth",
		"imgWidth",
		"srcY",
		"srcHeight",
		"imgHeight",
		"SWT",
		"SWT",
		"simple",
		"srcX",
		"srcY",
		"srcWidth",
		"destWidth",
		"destWidth",
		"imgWidth",
		"srcHeight",
		"destHeight",
		"destHeight",
		"imgHeight",
		"srcImage",
		"memGC",
		"memGC",
		"memGC",
		"mustRestore",
		"memGC",
		"data",
		"OS",
		"memGC",
		"data",
		"data",
		"srcImage",
		"srcImage",
		"srcImage",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"simple",
		"bm",
		"imgWidth",
		"imgHeight",
		"srcImage",
		"srcImage",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"simple",
		"bm",
		"imgWidth",
		"imgHeight",
		"srcImage",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"simple",
		"bm",
		"imgWidth",
		"imgHeight",
		"mustRestore",
		"OS",
		"memGC",
		"srcImage",
		"memGC",
		"hOldBitmap",
		"srcImage",
		"srcImage",
		"srcImage",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"simple",
		"bm",
		"imgWidth",
		"imgHeight",
		"OS",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"dstBitmap",
		"OS",
		"dstBitmap",
		"BITMAP",
		"dstBM",
		"fixAlpha",
		"dstBM",
		"dstBM",
		"handle",
		"destX",
		"destY",
		"fixAlpha",
		"dstDib",
		"Image",
		"destWidth",
		"destHeight",
		"dstDib",
		"SWT",
		"SWT",
		"dstHdc",
		"OS",
		"handle",
		"oldDstBitmap",
		"OS",
		"dstHdc",
		"dstDib",
		"OS",
		"dstHdc",
		"destWidth",
		"destHeight",
		"handle",
		"destX",
		"destY",
		"OS",
		"dstX",
		"dstY",
		"blend",
		"OS",
		"OS",
		"handle",
		"OS",
		"srcHdc",
		"srcImage",
		"srcImage",
		"blend",
		"srcImage",
		"OS",
		"dstHdc",
		"dstX",
		"dstY",
		"destWidth",
		"destHeight",
		"srcHdc",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"blend",
		"Image",
		"srcWidth",
		"srcHeight",
		"memDib",
		"SWT",
		"SWT",
		"OS",
		"handle",
		"OS",
		"memHdc",
		"memDib",
		"OS",
		"memDib",
		"BITMAP",
		"dibBM",
		"OS",
		"memHdc",
		"srcWidth",
		"srcHeight",
		"srcHdc",
		"srcX",
		"srcY",
		"OS",
		"dibBM",
		"dibBM",
		"OS",
		"srcData",
		"dibBM",
		"srcData",
		"imgWidth",
		"srcWidth",
		"srcY",
		"imgWidth",
		"srcX",
		"srcImage",
		"y",
		"srcHeight",
		"y",
		"x",
		"srcWidth",
		"x",
		"alphaData",
		"ap",
		"srcData",
		"sp",
		"srcData",
		"sp",
		"alpha",
		"srcData",
		"sp",
		"srcData",
		"sp",
		"alpha",
		"srcData",
		"sp",
		"srcData",
		"sp",
		"alpha",
		"srcData",
		"sp",
		"alpha",
		"sp",
		"ap",
		"apinc",
		"OS",
		"dibBM",
		"srcData",
		"srcData",
		"blend",
		"blend",
		"OS",
		"OS",
		"dstHdc",
		"dstX",
		"dstY",
		"destWidth",
		"destHeight",
		"memHdc",
		"srcWidth",
		"srcHeight",
		"blend",
		"OS",
		"memHdc",
		"oldMemBitmap",
		"OS",
		"memHdc",
		"OS",
		"memDib",
		"fixAlpha",
		"OS",
		"handle",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"dstHdc",
		"OS",
		"OS",
		"dstHdc",
		"oldDstBitmap",
		"OS",
		"dstHdc",
		"OS",
		"dstDib",
		"OS",
		"srcHdc",
		"oldSrcBitmap",
		"OS",
		"srcHdc",
		"rect",
		"rect",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"rect",
		"srcX",
		"rect",
		"destX",
		"srcWidth",
		"destWidth",
		"srcX",
		"rect",
		"rect",
		"destX",
		"srcWidth",
		"destWidth",
		"srcY",
		"rect",
		"destY",
		"srcHeight",
		"destHeight",
		"srcY",
		"rect",
		"rect",
		"destY",
		"srcHeight",
		"destHeight",
		"destX",
		"rect",
		"destY",
		"rect",
		"destWidth",
		"rect",
		"destHeight",
		"rect",
		"srcX",
		"sx1",
		"srcY",
		"sy1",
		"srcWidth",
		"Math",
		"sx2",
		"sx1",
		"srcHeight",
		"Math",
		"sy2",
		"sy1",
		"OS",
		"handle",
		"OS",
		"srcHdc",
		"srcImage",
		"OS",
		"handle",
		"Image",
		"Math",
		"srcWidth",
		"destWidth",
		"Math",
		"srcHeight",
		"destHeight",
		"memDib",
		"SWT",
		"SWT",
		"OS",
		"memHdc",
		"memDib",
		"OS",
		"memDib",
		"BITMAP",
		"dibBM",
		"dibBM",
		"dibBM",
		"OS",
		"memHdc",
		"destWidth",
		"destHeight",
		"handle",
		"destX",
		"destY",
		"OS",
		"sizeInBytes",
		"OS",
		"destData",
		"dibBM",
		"sizeInBytes",
		"OS",
		"memHdc",
		"srcWidth",
		"srcHeight",
		"srcHdc",
		"srcX",
		"srcY",
		"OS",
		"sizeInBytes",
		"OS",
		"srcData",
		"dibBM",
		"sizeInBytes",
		"srcImage",
		"srcImage",
		"hasAlphaChannel",
		"imgWidth",
		"srcWidth",
		"dibBM",
		"srcWidth",
		"srcY",
		"imgWidth",
		"srcX",
		"srcImage",
		"y",
		"srcHeight",
		"y",
		"x",
		"srcWidth",
		"x",
		"srcData",
		"sp",
		"alphaData",
		"ap",
		"sp",
		"ap",
		"apinc",
		"sp",
		"spinc",
		"OS",
		"dibBM",
		"srcData",
		"sizeInBytes",
		"OS",
		"destWidth",
		"srcWidth",
		"destHeight",
		"srcHeight",
		"OS",
		"OS",
		"OS",
		"handle",
		"Image",
		"destWidth",
		"destHeight",
		"tempDib",
		"SWT",
		"SWT",
		"OS",
		"tempHdc",
		"tempDib",
		"simple",
		"srcWidth",
		"destWidth",
		"srcHeight",
		"destHeight",
		"OS",
		"OS",
		"memHdc",
		"OS",
		"OS",
		"tempHdc",
		"destWidth",
		"destHeight",
		"memHdc",
		"srcWidth",
		"srcHeight",
		"OS",
		"OS",
		"tempHdc",
		"destWidth",
		"destHeight",
		"memHdc",
		"OS",
		"OS",
		"memHdc",
		"destWidth",
		"destHeight",
		"tempHdc",
		"OS",
		"OS",
		"tempHdc",
		"oldTempBitmap",
		"OS",
		"tempDib",
		"OS",
		"tempHdc",
		"simple",
		"srcWidth",
		"destWidth",
		"srcHeight",
		"destHeight",
		"OS",
		"OS",
		"memHdc",
		"OS",
		"OS",
		"memHdc",
		"destWidth",
		"destHeight",
		"memHdc",
		"srcWidth",
		"srcHeight",
		"OS",
		"OS",
		"memHdc",
		"destWidth",
		"destHeight",
		"memHdc",
		"OS",
		"OS",
		"srcData",
		"dibBM",
		"sizeInBytes",
		"dibBM",
		"destWidth",
		"y",
		"destHeight",
		"y",
		"x",
		"destWidth",
		"x",
		"hasAlphaChannel",
		"alpha",
		"srcData",
		"dp",
		"destData",
		"dp",
		"srcData",
		"dp",
		"destData",
		"dp",
		"alpha",
		"destData",
		"dp",
		"srcData",
		"dp",
		"destData",
		"dp",
		"alpha",
		"destData",
		"dp",
		"srcData",
		"dp",
		"destData",
		"dp",
		"alpha",
		"dp",
		"dp",
		"dpinc",
		"OS",
		"dibBM",
		"destData",
		"sizeInBytes",
		"OS",
		"handle",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"memHdc",
		"OS",
		"OS",
		"memHdc",
		"oldMemBitmap",
		"OS",
		"memHdc",
		"OS",
		"memDib",
		"OS",
		"srcHdc",
		"oldSrcBitmap",
		"OS",
		"srcHdc",
		"OS",
		"y",
		"imgHeight",
		"y",
		"x",
		"imgWidth",
		"x",
		"OS",
		"maskHdc",
		"x",
		"y",
		"OS",
		"x",
		"y",
		"x",
		"y",
		"OS",
		"rgn",
		"rgn",
		"tempRgn",
		"OS",
		"OS",
		"tempRgn",
		"destWidth",
		"srcWidth",
		"destHeight",
		"srcHeight",
		"OS",
		"rgn",
		"nBytes",
		"OS",
		"rgn",
		"nBytes",
		"lpRgnData",
		"destWidth",
		"srcWidth",
		"destHeight",
		"srcHeight",
		"OS",
		"lpXform",
		"nBytes",
		"lpRgnData",
		"OS",
		"rgn",
		"rgn",
		"tmpRgn",
		"OS",
		"rgn",
		"destX",
		"destY",
		"OS",
		"OS",
		"handle",
		"clip",
		"result",
		"OS",
		"rgn",
		"rgn",
		"clip",
		"OS",
		"OS",
		"handle",
		"rgn",
		"OS",
		"rop2",
		"OS",
		"handle",
		"rop2",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"rop2",
		"rop2",
		"OS",
		"OS",
		"OS",
		"simple",
		"srcWidth",
		"destWidth",
		"srcHeight",
		"destHeight",
		"OS",
		"mode",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"srcHdc",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"dwRop",
		"OS",
		"OS",
		"handle",
		"mode",
		"OS",
		"handle",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"srcHdc",
		"srcX",
		"srcY",
		"dwRop",
		"OS",
		"handle",
		"result",
		"clip",
		"OS",
		"clip",
		"OS",
		"rgn",
		"srcY",
		"srcColor",
		"srcColor",
		"srcMask",
		"srcColorY",
		"imgHeight",
		"OS",
		"handle",
		"OS",
		"srcHdc",
		"srcColor",
		"handle",
		"destX",
		"destY",
		"offscreen",
		"tempHdc",
		"OS",
		"handle",
		"tempBitmap",
		"OS",
		"handle",
		"destWidth",
		"destHeight",
		"oldTempBitmap",
		"OS",
		"tempHdc",
		"tempBitmap",
		"OS",
		"tempHdc",
		"destWidth",
		"destHeight",
		"handle",
		"destX",
		"destY",
		"OS",
		"destHdc",
		"tempHdc",
		"x",
		"y",
		"oldBkColor",
		"OS",
		"handle",
		"oldTextColor",
		"OS",
		"handle",
		"simple",
		"srcWidth",
		"destWidth",
		"srcHeight",
		"destHeight",
		"OS",
		"mode",
		"OS",
		"handle",
		"OS",
		"OS",
		"destHdc",
		"x",
		"y",
		"destWidth",
		"destHeight",
		"srcHdc",
		"srcX",
		"srcColorY",
		"srcWidth",
		"srcHeight",
		"OS",
		"OS",
		"srcHdc",
		"srcMask",
		"OS",
		"destHdc",
		"x",
		"y",
		"destWidth",
		"destHeight",
		"srcHdc",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"OS",
		"OS",
		"srcHdc",
		"srcColor",
		"OS",
		"destHdc",
		"x",
		"y",
		"destWidth",
		"destHeight",
		"srcHdc",
		"srcX",
		"srcColorY",
		"srcWidth",
		"srcHeight",
		"OS",
		"OS",
		"OS",
		"handle",
		"mode",
		"OS",
		"destHdc",
		"x",
		"y",
		"destWidth",
		"destHeight",
		"srcHdc",
		"srcX",
		"srcColorY",
		"OS",
		"OS",
		"destHdc",
		"OS",
		"srcHdc",
		"srcMask",
		"OS",
		"destHdc",
		"x",
		"y",
		"destWidth",
		"destHeight",
		"srcHdc",
		"srcX",
		"srcY",
		"OS",
		"OS",
		"srcHdc",
		"srcColor",
		"OS",
		"destHdc",
		"x",
		"y",
		"destWidth",
		"destHeight",
		"srcHdc",
		"srcX",
		"srcColorY",
		"OS",
		"offscreen",
		"OS",
		"handle",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"tempHdc",
		"OS",
		"OS",
		"tempHdc",
		"oldTempBitmap",
		"OS",
		"tempHdc",
		"OS",
		"tempBitmap",
		"OS",
		"handle",
		"oldBkColor",
		"OS",
		"handle",
		"oldTextColor",
		"OS",
		"srcHdc",
		"oldSrcBitmap",
		"OS",
		"srcHdc",
		"bm",
		"srcImage",
		"OS",
		"handle",
		"OS",
		"srcHdc",
		"hBitmap",
		"bm",
		"isDib",
		"OS",
		"OS",
		"pBits",
		"bm",
		"pBits",
		"bm",
		"pBits",
		"srcImage",
		"bm",
		"pBits",
		"mask",
		"OS",
		"bm",
		"pBits",
		"OS",
		"srcHdc",
		"pBits",
		"oldValue",
		"OS",
		"bm",
		"pBits",
		"transBlue",
		"color",
		"transGreen",
		"color",
		"transRed",
		"color",
		"bm",
		"maxColors",
		"OS",
		"srcHdc",
		"maxColors",
		"oldColors",
		"srcImage",
		"i",
		"oldColors",
		"i",
		"i",
		"offset",
		"oldColors",
		"offset",
		"oldColors",
		"i",
		"oldColors",
		"offset",
		"oldColors",
		"i",
		"oldColors",
		"offset",
		"oldColors",
		"i",
		"fixPalette",
		"fixPalette",
		"oldColors",
		"transRed",
		"transGreen",
		"transBlue",
		"newColors",
		"offset",
		"transBlue",
		"newColors",
		"offset",
		"transGreen",
		"newColors",
		"offset",
		"transRed",
		"OS",
		"srcHdc",
		"maxColors",
		"newColors",
		"originalColors",
		"oldColors",
		"transBlue",
		"oldColors",
		"offset",
		"transGreen",
		"oldColors",
		"offset",
		"transRed",
		"oldColors",
		"offset",
		"bm",
		"bmiHeader",
		"BITMAPINFOHEADER",
		"bmiHeader",
		"bm",
		"bmiHeader",
		"bm",
		"BITMAPINFOHEADER",
		"numColors",
		"OS",
		"bmi",
		"bmiHeader",
		"BITMAPINFOHEADER",
		"OS",
		"SWT",
		"SWT",
		"OS",
		"srcHdc",
		"srcImage",
		"bmi",
		"OS",
		"BITMAPINFOHEADER",
		"srcImage",
		"transRed",
		"bmi",
		"offset",
		"transGreen",
		"bmi",
		"offset",
		"transBlue",
		"bmi",
		"offset",
		"srcImage",
		"bm",
		"transBlue",
		"pixel",
		"transGreen",
		"pixel",
		"transRed",
		"pixel",
		"transBlue",
		"pixel",
		"transGreen",
		"pixel",
		"transRed",
		"pixel",
		"transBlue",
		"pixel",
		"transGreen",
		"pixel",
		"transRed",
		"pixel",
		"transBlue",
		"transGreen",
		"transRed",
		"OS",
		"OS",
		"handle",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"srcHdc",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"transparentColor",
		"originalColors",
		"OS",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"srcHdc",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"transparentColor",
		"OS",
		"handle",
		"mode",
		"OS",
		"handle",
		"OS",
		"imgWidth",
		"imgHeight",
		"OS",
		"maskHdc",
		"maskBitmap",
		"OS",
		"srcHdc",
		"transparentColor",
		"OS",
		"maskHdc",
		"imgWidth",
		"imgHeight",
		"srcHdc",
		"OS",
		"originalColors",
		"OS",
		"srcHdc",
		"bm",
		"originalColors",
		"OS",
		"handle",
		"OS",
		"OS",
		"srcHdc",
		"maskHdc",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"simple",
		"imgWidth",
		"imgHeight",
		"OS",
		"handle",
		"OS",
		"handle",
		"destWidth",
		"destHeight",
		"OS",
		"tempHdc",
		"tempBitmap",
		"OS",
		"tempHdc",
		"destWidth",
		"destHeight",
		"handle",
		"destX",
		"destY",
		"OS",
		"simple",
		"srcWidth",
		"destWidth",
		"srcHeight",
		"destHeight",
		"OS",
		"OS",
		"tempHdc",
		"OS",
		"OS",
		"tempHdc",
		"destWidth",
		"destHeight",
		"srcHdc",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"OS",
		"OS",
		"tempHdc",
		"destWidth",
		"destHeight",
		"maskHdc",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"OS",
		"OS",
		"tempHdc",
		"destWidth",
		"destHeight",
		"srcHdc",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"OS",
		"OS",
		"tempHdc",
		"destWidth",
		"destHeight",
		"srcHdc",
		"srcX",
		"srcY",
		"OS",
		"OS",
		"tempHdc",
		"destWidth",
		"destHeight",
		"maskHdc",
		"srcX",
		"srcY",
		"OS",
		"OS",
		"tempHdc",
		"destWidth",
		"destHeight",
		"srcHdc",
		"srcX",
		"srcY",
		"OS",
		"OS",
		"handle",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"tempHdc",
		"OS",
		"OS",
		"tempHdc",
		"oldTempBitmap",
		"OS",
		"tempHdc",
		"OS",
		"tempBitmap",
		"OS",
		"maskHdc",
		"oldMaskBitmap",
		"OS",
		"maskHdc",
		"OS",
		"maskBitmap",
		"OS",
		"srcHdc",
		"oldSrcBitmap",
		"hBitmap",
		"srcImage",
		"OS",
		"hBitmap",
		"OS",
		"srcHdc",
		"OS",
		"handle",
		"OS",
		"srcHdc",
		"srcImage",
		"OS",
		"rop2",
		"OS",
		"handle",
		"rop2",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"rop2",
		"rop2",
		"OS",
		"OS",
		"OS",
		"simple",
		"srcWidth",
		"destWidth",
		"srcHeight",
		"destHeight",
		"OS",
		"mode",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"srcHdc",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"dwRop",
		"OS",
		"OS",
		"handle",
		"mode",
		"OS",
		"handle",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"srcHdc",
		"srcX",
		"srcY",
		"dwRop",
		"OS",
		"srcHdc",
		"oldSrcBitmap",
		"OS",
		"srcHdc",
		"handle",
		"SWT",
		"SWT",
		"data",
		"gdipGraphics",
		"data",
		"data",
		"Gdip",
		"gdipGraphics",
		"Gdip",
		"Gdip",
		"gdipGraphics",
		"data",
		"x1",
		"y1",
		"x2",
		"y2",
		"data",
		"data",
		"Gdip",
		"gdipGraphics",
		"Gdip",
		"OS",
		"x1",
		"y1",
		"x2",
		"y2",
		"OS",
		"handle",
		"points",
		"points",
		"OS",
		"handle",
		"x1",
		"y1",
		"OS",
		"handle",
		"x2",
		"y2",
		"data",
		"OS",
		"handle",
		"x2",
		"y2",
		"OS",
		"handle",
		"handle",
		"SWT",
		"SWT",
		"data",
		"gdipGraphics",
		"data",
		"data",
		"Gdip",
		"gdipGraphics",
		"Gdip",
		"Gdip",
		"gdipGraphics",
		"data",
		"x",
		"y",
		"width",
		"height",
		"data",
		"data",
		"Gdip",
		"gdipGraphics",
		"Gdip",
		"OS",
		"OS",
		"OS",
		"handle",
		"nullBrush",
		"OS",
		"handle",
		"x",
		"y",
		"x",
		"width",
		"y",
		"height",
		"OS",
		"handle",
		"oldBrush",
		"handle",
		"SWT",
		"SWT",
		"path",
		"SWT",
		"SWT",
		"path",
		"SWT",
		"SWT",
		"data",
		"data",
		"data",
		"Gdip",
		"gdipGraphics",
		"Gdip",
		"Gdip",
		"gdipGraphics",
		"data",
		"path",
		"data",
		"data",
		"Gdip",
		"gdipGraphics",
		"Gdip",
		"handle",
		"SWT",
		"SWT",
		"OS",
		"handle",
		"x",
		"y",
		"OS",
		"handle",
		"handle",
		"SWT",
		"SWT",
		"pointArray",
		"SWT",
		"SWT",
		"data",
		"gdipGraphics",
		"data",
		"data",
		"Gdip",
		"gdipGraphics",
		"Gdip",
		"Gdip",
		"gdipGraphics",
		"data",
		"pointArray",
		"pointArray",
		"data",
		"data",
		"Gdip",
		"gdipGraphics",
		"Gdip",
		"OS",
		"OS",
		"OS",
		"handle",
		"nullBrush",
		"OS",
		"handle",
		"pointArray",
		"pointArray",
		"OS",
		"handle",
		"oldBrush",
		"handle",
		"SWT",
		"SWT",
		"pointArray",
		"SWT",
		"SWT",
		"data",
		"gdipGraphics",
		"data",
		"data",
		"Gdip",
		"gdipGraphics",
		"Gdip",
		"Gdip",
		"gdipGraphics",
		"data",
		"pointArray",
		"pointArray",
		"data",
		"data",
		"Gdip",
		"gdipGraphics",
		"Gdip",
		"OS",
		"handle",
		"pointArray",
		"pointArray",
		"pointArray",
		"length",
		"data",
		"OS",
		"handle",
		"pointArray",
		"length",
		"pointArray",
		"length",
		"OS",
		"handle",
		"handle",
		"SWT",
		"SWT",
		"data",
		"gdipGraphics",
		"data",
		"data",
		"Gdip",
		"gdipGraphics",
		"Gdip",
		"Gdip",
		"gdipGraphics",
		"data",
		"x",
		"y",
		"width",
		"height",
		"data",
		"data",
		"Gdip",
		"gdipGraphics",
		"Gdip",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"handle",
		"x",
		"y",
		"x",
		"width",
		"y",
		"height",
		"OS",
		"handle",
		"hOld",
		"rect",
		"SWT",
		"SWT",
		"rect",
		"rect",
		"rect",
		"rect",
		"handle",
		"SWT",
		"SWT",
		"data",
		"data",
		"data",
		"x",
		"y",
		"width",
		"height",
		"arcWidth",
		"arcHeight",
		"OS",
		"width",
		"height",
		"arcWidth",
		"arcHeight",
		"x",
		"y",
		"width",
		"height",
		"width",
		"x",
		"width",
		"width",
		"width",
		"height",
		"y",
		"height",
		"height",
		"height",
		"arcWidth",
		"arcWidth",
		"arcWidth",
		"arcHeight",
		"arcHeight",
		"arcHeight",
		"arcWidth",
		"width",
		"arcWidth",
		"width",
		"arcHeight",
		"height",
		"arcHeight",
		"height",
		"arcWidth",
		"width",
		"x",
		"arcWidth",
		"y",
		"x",
		"width",
		"arcWidth",
		"y",
		"x",
		"arcWidth",
		"y",
		"height",
		"x",
		"width",
		"arcWidth",
		"y",
		"height",
		"arcHeight",
		"height",
		"x",
		"y",
		"arcHeight",
		"x",
		"y",
		"height",
		"arcHeight",
		"x",
		"width",
		"y",
		"arcHeight",
		"x",
		"width",
		"y",
		"height",
		"arcHeight",
		"arcWidth",
		"arcHeight",
		"x",
		"y",
		"arcWidth",
		"arcHeight",
		"x",
		"width",
		"arcWidth",
		"y",
		"arcWidth",
		"arcHeight",
		"x",
		"width",
		"arcWidth",
		"y",
		"height",
		"arcHeight",
		"arcWidth",
		"arcHeight",
		"x",
		"y",
		"height",
		"arcHeight",
		"arcWidth",
		"arcHeight",
		"OS",
		"OS",
		"OS",
		"handle",
		"nullBrush",
		"OS",
		"handle",
		"x",
		"y",
		"x",
		"width",
		"y",
		"height",
		"arcWidth",
		"arcHeight",
		"OS",
		"handle",
		"oldBrush",
		"x",
		"y",
		"width",
		"height",
		"arcWidth",
		"arcHeight",
		"nw",
		"nw",
		"nw",
		"nx",
		"nx",
		"nw",
		"nh",
		"nh",
		"nh",
		"ny",
		"ny",
		"nh",
		"naw",
		"naw",
		"naw",
		"nah",
		"nah",
		"nah",
		"naw",
		"nah",
		"data",
		"data",
		"Gdip",
		"gdipGraphics",
		"Gdip",
		"nw",
		"naw",
		"nh",
		"nah",
		"Gdip",
		"gdipGraphics",
		"brush",
		"nx",
		"ny",
		"naw",
		"nah",
		"Gdip",
		"gdipGraphics",
		"brush",
		"nx",
		"naw2",
		"ny",
		"nx",
		"nw",
		"naw2",
		"ny",
		"Gdip",
		"gdipGraphics",
		"brush",
		"nx",
		"nw",
		"naw",
		"ny",
		"naw",
		"nah",
		"Gdip",
		"gdipGraphics",
		"brush",
		"nx",
		"nw",
		"ny",
		"nah2",
		"nx",
		"nw",
		"ny",
		"nh",
		"nah2",
		"Gdip",
		"gdipGraphics",
		"brush",
		"nx",
		"nw",
		"naw",
		"ny",
		"nh",
		"nah",
		"naw",
		"nah",
		"Gdip",
		"gdipGraphics",
		"brush",
		"nx",
		"naw2",
		"ny",
		"nh",
		"nx",
		"nw",
		"naw2",
		"ny",
		"nh",
		"Gdip",
		"gdipGraphics",
		"brush",
		"nx",
		"ny",
		"nh",
		"nah",
		"naw",
		"nah",
		"Gdip",
		"gdipGraphics",
		"brush",
		"nx",
		"ny",
		"nah2",
		"nx",
		"ny",
		"nh",
		"nah2",
		"Gdip",
		"gdipGraphics",
		"brush",
		"nx",
		"ny",
		"naw",
		"nh",
		"Gdip",
		"gdipGraphics",
		"brush",
		"nx",
		"naw2",
		"ny",
		"nx",
		"nw",
		"naw2",
		"ny",
		"Gdip",
		"gdipGraphics",
		"brush",
		"nx",
		"nw",
		"naw",
		"ny",
		"naw",
		"nh",
		"Gdip",
		"gdipGraphics",
		"brush",
		"nx",
		"naw2",
		"ny",
		"nh",
		"nx",
		"nw",
		"naw2",
		"ny",
		"nh",
		"nh",
		"nah",
		"Gdip",
		"gdipGraphics",
		"brush",
		"nx",
		"ny",
		"nw",
		"nah",
		"Gdip",
		"gdipGraphics",
		"brush",
		"nx",
		"nw",
		"ny",
		"nah2",
		"nx",
		"nw",
		"ny",
		"nh",
		"nah2",
		"Gdip",
		"gdipGraphics",
		"brush",
		"nx",
		"ny",
		"nh",
		"nah",
		"nw",
		"nah",
		"Gdip",
		"gdipGraphics",
		"brush",
		"nx",
		"ny",
		"nah2",
		"nx",
		"ny",
		"nh",
		"nah2",
		"Gdip",
		"gdipGraphics",
		"brush",
		"nx",
		"ny",
		"nw",
		"nh",
		"data",
		"data",
		"Gdip",
		"gdipGraphics",
		"Gdip",
		"string",
		"x",
		"y",
		"handle",
		"SWT",
		"SWT",
		"string",
		"SWT",
		"SWT",
		"string",
		"length",
		"length",
		"string",
		"length",
		"buffer",
		"data",
		"isTransparent",
		"pt",
		"x",
		"pt",
		"y",
		"Gdip",
		"data",
		"Gdip",
		"Gdip",
		"Gdip",
		"format",
		"Gdip",
		"format",
		"Gdip",
		"isTransparent",
		"Gdip",
		"data",
		"buffer",
		"length",
		"font",
		"pt",
		"format",
		"bounds",
		"Gdip",
		"data",
		"data",
		"bounds",
		"bounds",
		"Math",
		"bounds",
		"Math",
		"bounds",
		"Gdip",
		"data",
		"buffer",
		"length",
		"font",
		"pt",
		"format",
		"brush",
		"Gdip",
		"format",
		"Gdip",
		"font",
		"OS",
		"rop2",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"rop2",
		"rop2",
		"OS",
		"handle",
		"OS",
		"handle",
		"isTransparent",
		"OS",
		"OS",
		"rop2",
		"OS",
		"OS",
		"handle",
		"x",
		"y",
		"buffer",
		"length",
		"OS",
		"handle",
		"isTransparent",
		"OS",
		"handle",
		"buffer",
		"length",
		"size",
		"size",
		"size",
		"OS",
		"handle",
		"width",
		"height",
		"hBitmap",
		"SWT",
		"SWT",
		"OS",
		"handle",
		"OS",
		"memDC",
		"hBitmap",
		"OS",
		"memDC",
		"width",
		"height",
		"OS",
		"OS",
		"memDC",
		"OS",
		"OS",
		"memDC",
		"foreground",
		"OS",
		"memDC",
		"OS",
		"handle",
		"OS",
		"OS",
		"memDC",
		"buffer",
		"length",
		"OS",
		"handle",
		"x",
		"y",
		"width",
		"height",
		"memDC",
		"OS",
		"OS",
		"memDC",
		"hOldBitmap",
		"OS",
		"memDC",
		"OS",
		"hBitmap",
		"OS",
		"handle",
		"OS",
		"handle",
		"foreground",
		"background",
		"OS",
		"handle",
		"x",
		"y",
		"buffer",
		"length",
		"OS",
		"handle",
		"foreground",
		"OS",
		"handle",
		"oldBkMode",
		"string",
		"x",
		"y",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"isTransparent",
		"flags",
		"SWT",
		"string",
		"x",
		"y",
		"flags",
		"handle",
		"SWT",
		"SWT",
		"string",
		"SWT",
		"SWT",
		"string",
		"data",
		"flags",
		"SWT",
		"string",
		"length",
		"string",
		"length",
		"buffer",
		"pt",
		"x",
		"pt",
		"y",
		"Gdip",
		"data",
		"Gdip",
		"Gdip",
		"Gdip",
		"format",
		"Gdip",
		"format",
		"Gdip",
		"flags",
		"SWT",
		"font",
		"format",
		"Gdip",
		"format",
		"tabs",
		"tabs",
		"Gdip",
		"format",
		"flags",
		"SWT",
		"Gdip",
		"Gdip",
		"flags",
		"SWT",
		"Gdip",
		"data",
		"buffer",
		"length",
		"font",
		"pt",
		"format",
		"bounds",
		"Gdip",
		"data",
		"data",
		"bounds",
		"bounds",
		"Math",
		"bounds",
		"Math",
		"bounds",
		"Gdip",
		"data",
		"buffer",
		"length",
		"font",
		"pt",
		"format",
		"brush",
		"Gdip",
		"format",
		"Gdip",
		"font",
		"string",
		"buffer",
		"length",
		"OS",
		"OS",
		"rect",
		"x",
		"y",
		"limit",
		"limit",
		"OS",
		"flags",
		"SWT",
		"uFormat",
		"OS",
		"flags",
		"SWT",
		"uFormat",
		"OS",
		"flags",
		"SWT",
		"uFormat",
		"OS",
		"OS",
		"rop2",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"rop2",
		"rop2",
		"OS",
		"handle",
		"OS",
		"handle",
		"flags",
		"SWT",
		"OS",
		"OS",
		"rop2",
		"OS",
		"OS",
		"handle",
		"buffer",
		"length",
		"rect",
		"uFormat",
		"OS",
		"handle",
		"flags",
		"SWT",
		"OS",
		"handle",
		"buffer",
		"buffer",
		"rect",
		"uFormat",
		"OS",
		"rect",
		"rect",
		"rect",
		"rect",
		"OS",
		"handle",
		"width",
		"height",
		"hBitmap",
		"SWT",
		"SWT",
		"OS",
		"handle",
		"OS",
		"memDC",
		"hBitmap",
		"OS",
		"memDC",
		"width",
		"height",
		"OS",
		"OS",
		"memDC",
		"OS",
		"OS",
		"memDC",
		"foreground",
		"OS",
		"memDC",
		"OS",
		"handle",
		"OS",
		"OS",
		"rect",
		"OS",
		"memDC",
		"buffer",
		"length",
		"rect",
		"uFormat",
		"OS",
		"handle",
		"x",
		"y",
		"width",
		"height",
		"memDC",
		"OS",
		"OS",
		"memDC",
		"hOldBitmap",
		"OS",
		"memDC",
		"OS",
		"hBitmap",
		"OS",
		"handle",
		"OS",
		"handle",
		"foreground",
		"background",
		"OS",
		"handle",
		"buffer",
		"length",
		"rect",
		"uFormat",
		"OS",
		"handle",
		"foreground",
		"OS",
		"handle",
		"oldBkMode",
		"object",
		"object",
		"handle",
		"object",
		"handle",
		"SWT",
		"SWT",
		"width",
		"x",
		"x",
		"width",
		"width",
		"width",
		"height",
		"y",
		"y",
		"height",
		"height",
		"height",
		"width",
		"height",
		"arcAngle",
		"data",
		"Gdip",
		"data",
		"data",
		"x",
		"y",
		"width",
		"height",
		"startAngle",
		"arcAngle",
		"OS",
		"arcAngle",
		"startAngle",
		"arcAngle",
		"arcAngle",
		"arcAngle",
		"arcAngle",
		"arcAngle",
		"drawSegments",
		"arcAngle",
		"drawSegments",
		"x",
		"width",
		"y",
		"height",
		"drawSegments",
		"i",
		"arcAngle",
		"i",
		"points",
		"index",
		"Compatibility",
		"startAngle",
		"i",
		"width",
		"cteX",
		"points",
		"index",
		"cteY",
		"Compatibility",
		"startAngle",
		"i",
		"height",
		"drawSegments",
		"points",
		"points",
		"points",
		"cteX",
		"points",
		"points",
		"points",
		"cteY",
		"OS",
		"OS",
		"OS",
		"handle",
		"nullPen",
		"OS",
		"handle",
		"points",
		"points",
		"OS",
		"handle",
		"oldPen",
		"arcAngle",
		"arcAngle",
		"x1",
		"x2",
		"x",
		"width",
		"y1",
		"y2",
		"y",
		"height",
		"isNegative",
		"arcAngle",
		"arcAngle",
		"arcAngle",
		"startAngle",
		"isNegative",
		"tmp",
		"startAngle",
		"startAngle",
		"arcAngle",
		"arcAngle",
		"tmp",
		"x1",
		"Compatibility",
		"startAngle",
		"width",
		"x",
		"width",
		"y1",
		"Compatibility",
		"startAngle",
		"height",
		"y",
		"height",
		"x2",
		"Compatibility",
		"arcAngle",
		"width",
		"x",
		"width",
		"y2",
		"Compatibility",
		"arcAngle",
		"height",
		"y",
		"height",
		"OS",
		"OS",
		"OS",
		"handle",
		"nullPen",
		"OS",
		"handle",
		"x",
		"y",
		"x",
		"width",
		"y",
		"height",
		"x1",
		"y1",
		"x2",
		"y2",
		"OS",
		"handle",
		"oldPen",
		"handle",
		"SWT",
		"SWT",
		"width",
		"height",
		"OS",
		"handle",
		"fromColor",
		"OS",
		"fromColor",
		"OS",
		"OS",
		"OS",
		"handle",
		"toColor",
		"OS",
		"toColor",
		"OS",
		"OS",
		"width",
		"x",
		"width",
		"width",
		"width",
		"vertical",
		"swapColors",
		"height",
		"y",
		"height",
		"height",
		"height",
		"vertical",
		"swapColors",
		"swapColors",
		"fromColor",
		"fromColor",
		"toColor",
		"toColor",
		"t",
		"OS",
		"rop2",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"rop2",
		"rop2",
		"OS",
		"handle",
		"fromColor",
		"fromColor",
		"fromColor",
		"toColor",
		"toColor",
		"toColor",
		"fromRGB",
		"toRGB",
		"fromRGB",
		"toRGB",
		"fromRGB",
		"toRGB",
		"rop2",
		"OS",
		"OS",
		"OS",
		"OS",
		"handle",
		"x",
		"y",
		"width",
		"height",
		"dwRop",
		"data",
		"p1",
		"x",
		"p1",
		"y",
		"vertical",
		"p2",
		"p1",
		"p2",
		"p1",
		"height",
		"p2",
		"p1",
		"width",
		"p2",
		"p1",
		"fromColor",
		"fromColor",
		"fromColor",
		"Gdip",
		"data",
		"rgb",
		"fromGpColor",
		"SWT",
		"SWT",
		"rgb",
		"toColor",
		"toColor",
		"toColor",
		"Gdip",
		"data",
		"rgb",
		"toGpColor",
		"SWT",
		"SWT",
		"Gdip",
		"p1",
		"p2",
		"fromGpColor",
		"toGpColor",
		"Gdip",
		"data",
		"brush",
		"x",
		"y",
		"width",
		"height",
		"Gdip",
		"brush",
		"Gdip",
		"fromGpColor",
		"Gdip",
		"toGpColor",
		"OS",
		"rop2",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"OS",
		"hHeap",
		"OS",
		"GRADIENT_RECT",
		"TRIVERTEX",
		"pMesh",
		"GRADIENT_RECT",
		"gradientRect",
		"gradientRect",
		"OS",
		"pMesh",
		"gradientRect",
		"GRADIENT_RECT",
		"trivertex",
		"x",
		"trivertex",
		"y",
		"trivertex",
		"fromRGB",
		"fromRGB",
		"trivertex",
		"fromRGB",
		"fromRGB",
		"trivertex",
		"fromRGB",
		"fromRGB",
		"trivertex",
		"OS",
		"pVertex",
		"trivertex",
		"TRIVERTEX",
		"trivertex",
		"x",
		"width",
		"trivertex",
		"y",
		"height",
		"trivertex",
		"toRGB",
		"toRGB",
		"trivertex",
		"toRGB",
		"toRGB",
		"trivertex",
		"toRGB",
		"toRGB",
		"trivertex",
		"OS",
		"pVertex",
		"TRIVERTEX",
		"trivertex",
		"TRIVERTEX",
		"OS",
		"handle",
		"pVertex",
		"pMesh",
		"vertical",
		"OS",
		"OS",
		"OS",
		"hHeap",
		"pMesh",
		"success",
		"OS",
		"handle",
		"OS",
		"depth",
		"depth",
		"ImageData",
		"data",
		"x",
		"y",
		"width",
		"height",
		"vertical",
		"fromRGB",
		"toRGB",
		"bitResolution",
		"bitResolution",
		"bitResolution",
		"handle",
		"SWT",
		"SWT",
		"data",
		"Gdip",
		"data",
		"data",
		"x",
		"y",
		"width",
		"height",
		"OS",
		"OS",
		"OS",
		"handle",
		"nullPen",
		"OS",
		"handle",
		"x",
		"y",
		"x",
		"width",
		"y",
		"height",
		"OS",
		"handle",
		"oldPen",
		"handle",
		"SWT",
		"SWT",
		"path",
		"SWT",
		"SWT",
		"path",
		"SWT",
		"SWT",
		"OS",
		"handle",
		"OS",
		"Gdip",
		"Gdip",
		"Gdip",
		"path",
		"mode",
		"Gdip",
		"data",
		"data",
		"path",
		"handle",
		"SWT",
		"SWT",
		"pointArray",
		"SWT",
		"SWT",
		"data",
		"OS",
		"handle",
		"OS",
		"Gdip",
		"Gdip",
		"Gdip",
		"data",
		"data",
		"pointArray",
		"pointArray",
		"mode",
		"OS",
		"OS",
		"OS",
		"handle",
		"nullPen",
		"OS",
		"handle",
		"pointArray",
		"pointArray",
		"OS",
		"handle",
		"oldPen",
		"handle",
		"SWT",
		"SWT",
		"data",
		"Gdip",
		"data",
		"data",
		"x",
		"y",
		"width",
		"height",
		"OS",
		"rop2",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"rop2",
		"rop2",
		"OS",
		"handle",
		"rop2",
		"OS",
		"OS",
		"OS",
		"OS",
		"handle",
		"x",
		"y",
		"width",
		"height",
		"dwRop",
		"rect",
		"SWT",
		"SWT",
		"rect",
		"rect",
		"rect",
		"rect",
		"handle",
		"SWT",
		"SWT",
		"data",
		"data",
		"data",
		"x",
		"y",
		"width",
		"height",
		"arcWidth",
		"arcHeight",
		"OS",
		"OS",
		"OS",
		"handle",
		"nullPen",
		"OS",
		"handle",
		"x",
		"y",
		"x",
		"width",
		"y",
		"height",
		"arcWidth",
		"arcHeight",
		"OS",
		"handle",
		"oldPen",
		"x",
		"y",
		"width",
		"height",
		"arcWidth",
		"arcHeight",
		"nw",
		"nw",
		"nw",
		"nx",
		"nx",
		"nw",
		"nh",
		"nh",
		"nh",
		"ny",
		"ny",
		"nh",
		"naw",
		"naw",
		"naw",
		"nah",
		"nah",
		"nah",
		"naw",
		"nah",
		"nw",
		"naw",
		"nh",
		"nah",
		"Gdip",
		"gdipGraphics",
		"brush",
		"nx",
		"ny",
		"naw",
		"nah",
		"Gdip",
		"gdipGraphics",
		"brush",
		"nx",
		"naw2",
		"ny",
		"nw",
		"naw2",
		"nah2",
		"Gdip",
		"gdipGraphics",
		"brush",
		"nx",
		"nw",
		"naw",
		"ny",
		"naw",
		"nah",
		"Gdip",
		"gdipGraphics",
		"brush",
		"nx",
		"ny",
		"nah2",
		"nw",
		"nh",
		"nah2",
		"Gdip",
		"gdipGraphics",
		"brush",
		"nx",
		"nw",
		"naw",
		"ny",
		"nh",
		"nah",
		"naw",
		"nah",
		"Gdip",
		"gdipGraphics",
		"brush",
		"nx",
		"naw2",
		"ny",
		"nh",
		"nah2",
		"nw",
		"naw2",
		"nah2",
		"Gdip",
		"gdipGraphics",
		"brush",
		"nx",
		"ny",
		"nh",
		"nah",
		"naw",
		"nah",
		"Gdip",
		"gdipGraphics",
		"brush",
		"nx",
		"ny",
		"naw",
		"nh",
		"Gdip",
		"gdipGraphics",
		"brush",
		"nx",
		"naw2",
		"ny",
		"nw",
		"naw2",
		"nh",
		"Gdip",
		"gdipGraphics",
		"brush",
		"nx",
		"nw",
		"naw",
		"ny",
		"naw",
		"nh",
		"nh",
		"nah",
		"Gdip",
		"gdipGraphics",
		"brush",
		"nx",
		"ny",
		"nw",
		"nah",
		"Gdip",
		"gdipGraphics",
		"brush",
		"nx",
		"ny",
		"nah2",
		"nw",
		"nh",
		"nah2",
		"Gdip",
		"gdipGraphics",
		"brush",
		"nx",
		"ny",
		"nh",
		"nah",
		"nw",
		"nah",
		"Gdip",
		"gdipGraphics",
		"brush",
		"nx",
		"ny",
		"nw",
		"nh",
		"data",
		"Gdip",
		"data",
		"Gdip",
		"data",
		"Gdip",
		"data",
		"hdc",
		"handle",
		"SWT",
		"SWT",
		"OS",
		"OS",
		"handle",
		"ch",
		"size",
		"size",
		"ch",
		"ch",
		"ch",
		"tch",
		"buffer",
		"OS",
		"handle",
		"tch",
		"tch",
		"width",
		"width",
		"handle",
		"SWT",
		"SWT",
		"data",
		"handle",
		"SWT",
		"SWT",
		"data",
		"handle",
		"SWT",
		"SWT",
		"data",
		"SWT",
		"Gdip",
		"data",
		"mode",
		"Gdip",
		"SWT",
		"Gdip",
		"Gdip",
		"SWT",
		"Gdip",
		"Gdip",
		"Gdip",
		"SWT",
		"SWT",
		"handle",
		"SWT",
		"SWT",
		"OS",
		"handle",
		"color",
		"OS",
		"color",
		"OS",
		"OS",
		"Color",
		"data",
		"color",
		"handle",
		"SWT",
		"SWT",
		"data",
		"handle",
		"SWT",
		"SWT",
		"OS",
		"ch",
		"ch",
		"ch",
		"tch",
		"buffer",
		"OS",
		"handle",
		"tch",
		"tch",
		"width",
		"width",
		"OS",
		"OS",
		"handle",
		"lptm",
		"OS",
		"handle",
		"ch",
		"size",
		"size",
		"lptm",
		"handle",
		"SWT",
		"SWT",
		"data",
		"Gdip",
		"data",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"OS",
		"handle",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"handle",
		"SWT",
		"SWT",
		"region",
		"SWT",
		"SWT",
		"region",
		"SWT",
		"SWT",
		"data",
		"Gdip",
		"Gdip",
		"data",
		"rgn",
		"Gdip",
		"Gdip",
		"Gdip",
		"data",
		"matrix",
		"Gdip",
		"data",
		"identity",
		"Gdip",
		"rgn",
		"data",
		"Gdip",
		"data",
		"matrix",
		"Gdip",
		"identity",
		"Gdip",
		"matrix",
		"OS",
		"region",
		"hRgn",
		"OS",
		"Gdip",
		"rgn",
		"OS",
		"handle",
		"pt",
		"OS",
		"handle",
		"region",
		"result",
		"OS",
		"handle",
		"rect",
		"OS",
		"region",
		"rect",
		"rect",
		"rect",
		"rect",
		"OS",
		"region",
		"pt",
		"pt",
		"OS",
		"OS",
		"OS",
		"handle",
		"metaRgn",
		"OS",
		"metaRgn",
		"pt",
		"pt",
		"OS",
		"region",
		"metaRgn",
		"region",
		"OS",
		"OS",
		"metaRgn",
		"OS",
		"OS",
		"flags",
		"OS",
		"handle",
		"data",
		"hwnd",
		"data",
		"flags",
		"OS",
		"OS",
		"OS",
		"handle",
		"sysRgn",
		"OS",
		"OS",
		"OS",
		"hwnd",
		"pt",
		"OS",
		"sysRgn",
		"pt",
		"pt",
		"OS",
		"region",
		"sysRgn",
		"region",
		"OS",
		"OS",
		"sysRgn",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"cs",
		"lpCs",
		"OS",
		"lpCs",
		"handle",
		"SWT",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"handle",
		"OS",
		"SWT",
		"SWT",
		"handle",
		"SWT",
		"SWT",
		"OS",
		"handle",
		"OS",
		"Font",
		"data",
		"hFont",
		"handle",
		"SWT",
		"SWT",
		"OS",
		"OS",
		"handle",
		"lptm",
		"FontMetrics",
		"lptm",
		"handle",
		"SWT",
		"SWT",
		"OS",
		"handle",
		"color",
		"OS",
		"color",
		"OS",
		"OS",
		"Color",
		"data",
		"color",
		"handle",
		"SWT",
		"SWT",
		"data",
		"handle",
		"SWT",
		"SWT",
		"data",
		"SWT",
		"Gdip",
		"data",
		"mode",
		"Gdip",
		"SWT",
		"Gdip",
		"SWT",
		"Gdip",
		"Gdip",
		"SWT",
		"Gdip",
		"Gdip",
		"Gdip",
		"Gdip",
		"SWT",
		"SWT",
		"handle",
		"SWT",
		"SWT",
		"OS",
		"handle",
		"OS",
		"size",
		"OS",
		"hPen",
		"LOGPEN",
		"OS",
		"hPen",
		"LOGPEN",
		"logPen",
		"style",
		"logPen",
		"OS",
		"size",
		"EXTLOGPEN",
		"OS",
		"hPen",
		"size",
		"logPen",
		"OS",
		"OS",
		"hHeap",
		"OS",
		"size",
		"OS",
		"hPen",
		"size",
		"ptr",
		"OS",
		"logPen",
		"ptr",
		"EXTLOGPEN",
		"OS",
		"hHeap",
		"ptr",
		"style",
		"logPen",
		"OS",
		"SWT",
		"style",
		"OS",
		"cap",
		"SWT",
		"OS",
		"cap",
		"SWT",
		"OS",
		"cap",
		"SWT",
		"cap",
		"handle",
		"SWT",
		"SWT",
		"data",
		"data",
		"System",
		"data",
		"dashes",
		"dashes",
		"dashes",
		"handle",
		"SWT",
		"SWT",
		"OS",
		"handle",
		"OS",
		"size",
		"OS",
		"hPen",
		"LOGPEN",
		"OS",
		"hPen",
		"LOGPEN",
		"logPen",
		"style",
		"logPen",
		"OS",
		"size",
		"EXTLOGPEN",
		"OS",
		"hPen",
		"size",
		"logPen",
		"OS",
		"OS",
		"hHeap",
		"OS",
		"size",
		"OS",
		"hPen",
		"size",
		"ptr",
		"OS",
		"logPen",
		"ptr",
		"EXTLOGPEN",
		"OS",
		"hHeap",
		"ptr",
		"style",
		"logPen",
		"OS",
		"SWT",
		"style",
		"OS",
		"join",
		"SWT",
		"OS",
		"join",
		"SWT",
		"OS",
		"join",
		"SWT",
		"join",
		"handle",
		"SWT",
		"SWT",
		"OS",
		"handle",
		"OS",
		"size",
		"OS",
		"hPen",
		"LOGPEN",
		"OS",
		"hPen",
		"LOGPEN",
		"logPen",
		"style",
		"logPen",
		"size",
		"EXTLOGPEN",
		"OS",
		"hPen",
		"size",
		"logPen",
		"OS",
		"OS",
		"hHeap",
		"OS",
		"size",
		"OS",
		"hPen",
		"size",
		"ptr",
		"OS",
		"logPen",
		"ptr",
		"EXTLOGPEN",
		"OS",
		"hHeap",
		"ptr",
		"style",
		"logPen",
		"OS",
		"style",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"SWT",
		"handle",
		"SWT",
		"SWT",
		"OS",
		"handle",
		"OS",
		"size",
		"OS",
		"hPen",
		"LOGPEN",
		"OS",
		"hPen",
		"LOGPEN",
		"logPen",
		"logPen",
		"size",
		"EXTLOGPEN",
		"OS",
		"hPen",
		"size",
		"logPen",
		"OS",
		"OS",
		"hHeap",
		"OS",
		"size",
		"OS",
		"hPen",
		"size",
		"ptr",
		"OS",
		"logPen",
		"ptr",
		"EXTLOGPEN",
		"OS",
		"hHeap",
		"ptr",
		"logPen",
		"handle",
		"SWT",
		"SWT",
		"data",
		"handle",
		"SWT",
		"SWT",
		"data",
		"SWT",
		"Gdip",
		"data",
		"mode",
		"Gdip",
		"SWT",
		"Gdip",
		"Gdip",
		"SWT",
		"Gdip",
		"Gdip",
		"Gdip",
		"SWT",
		"SWT",
		"handle",
		"SWT",
		"SWT",
		"transform",
		"SWT",
		"SWT",
		"transform",
		"SWT",
		"SWT",
		"data",
		"gdipGraphics",
		"Gdip",
		"gdipGraphics",
		"transform",
		"transform",
		"handle",
		"SWT",
		"SWT",
		"OS",
		"rop2",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"rop2",
		"rop2",
		"OS",
		"handle",
		"rop2",
		"OS",
		"data",
		"data",
		"gdipGraphics",
		"OS",
		"OS",
		"handle",
		"hRgn",
		"OS",
		"handle",
		"pt",
		"OS",
		"hRgn",
		"pt",
		"pt",
		"OS",
		"handle",
		"gdipGraphics",
		"data",
		"Gdip",
		"handle",
		"gdipGraphics",
		"SWT",
		"SWT",
		"Gdip",
		"gdipGraphics",
		"Gdip",
		"result",
		"hRgn",
		"OS",
		"hRgn",
		"draw",
		"data",
		"data",
		"fill",
		"data",
		"data",
		"data",
		"foreground",
		"OS",
		"hDC",
		"foreground",
		"OS",
		"hDC",
		"foreground",
		"OS",
		"OS",
		"foreground",
		"OS",
		"hDC",
		"newPen",
		"data",
		"OS",
		"data",
		"data",
		"newPen",
		"data",
		"background",
		"OS",
		"hDC",
		"background",
		"OS",
		"hDC",
		"background",
		"OS",
		"background",
		"OS",
		"hDC",
		"newBrush",
		"data",
		"OS",
		"data",
		"data",
		"newBrush",
		"data",
		"hFont",
		"OS",
		"hDC",
		"hFont",
		"data",
		"hPalette",
		"OS",
		"hDC",
		"hPalette",
		"OS",
		"hDC",
		"data",
		"image",
		"data",
		"OS",
		"hDC",
		"image",
		"image",
		"data",
		"layout",
		"OS",
		"OS",
		"OS",
		"OS",
		"hDC",
		"flags",
		"OS",
		"layout",
		"OS",
		"flags",
		"OS",
		"OS",
		"hDC",
		"flags",
		"layout",
		"data",
		"SWT",
		"data",
		"SWT",
		"drawable",
		"data",
		"handle",
		"hDC",
		"handle",
		"handle",
		"SWT",
		"SWT",
		"OS",
		"OS",
		"handle",
		"region",
		"OS",
		"region",
		"result",
		"handle",
		"Gdip",
		"data",
		"font",
		"pt",
		"format",
		"bounds",
		"bounds",
		"handle",
		"SWT",
		"SWT",
		"advanced",
		"data",
		"advanced",
		"data",
		"Gdip",
		"data",
		"data",
		"Gdip",
		"data",
		"data",
		"data",
		"data",
		"data",
		"data",
		"data",
		"data",
		"data",
		"data",
		"OS",
		"handle",
		"data",
		"data",
		"OS",
		"handle",
		"data",
		"handle",
		"SWT",
		"SWT",
		"data",
		"antialias",
		"SWT",
		"antialias",
		"SWT",
		"mode",
		"Gdip",
		"SWT",
		"mode",
		"Gdip",
		"SWT",
		"mode",
		"Gdip",
		"SWT",
		"SWT",
		"Gdip",
		"data",
		"mode",
		"handle",
		"SWT",
		"SWT",
		"data",
		"alpha",
		"data",
		"alpha",
		"data",
		"Gdip",
		"data",
		"data",
		"data",
		"data",
		"data",
		"handle",
		"SWT",
		"SWT",
		"color",
		"SWT",
		"SWT",
		"color",
		"SWT",
		"SWT",
		"data",
		"data",
		"data",
		"data",
		"data",
		"OS",
		"handle",
		"color",
		"data",
		"color",
		"OS",
		"handle",
		"color",
		"OS",
		"color",
		"OS",
		"handle",
		"newBrush",
		"data",
		"OS",
		"data",
		"data",
		"newBrush",
		"data",
		"data",
		"data",
		"handle",
		"SWT",
		"SWT",
		"pattern",
		"pattern",
		"SWT",
		"SWT",
		"data",
		"pattern",
		"data",
		"data",
		"pattern",
		"data",
		"Gdip",
		"pattern",
		"data",
		"data",
		"pattern",
		"clipRgn",
		"data",
		"gdipGraphics",
		"hRgn",
		"Gdip",
		"hRgn",
		"Gdip",
		"gdipGraphics",
		"region",
		"Gdip",
		"Gdip",
		"region",
		"Gdip",
		"gdipGraphics",
		"hRgn",
		"pt",
		"OS",
		"handle",
		"pt",
		"OS",
		"hRgn",
		"pt",
		"pt",
		"OS",
		"handle",
		"hRgn",
		"hRgn",
		"OS",
		"hRgn",
		"pt",
		"pt",
		"hRgn",
		"hRgn",
		"clipRgn",
		"OS",
		"hRgn",
		"handle",
		"SWT",
		"SWT",
		"OS",
		"x",
		"y",
		"x",
		"width",
		"y",
		"height",
		"hRgn",
		"OS",
		"hRgn",
		"handle",
		"SWT",
		"SWT",
		"path",
		"path",
		"SWT",
		"SWT",
		"path",
		"OS",
		"handle",
		"OS",
		"Gdip",
		"Gdip",
		"Gdip",
		"path",
		"mode",
		"Gdip",
		"data",
		"path",
		"handle",
		"SWT",
		"SWT",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"handle",
		"SWT",
		"SWT",
		"region",
		"region",
		"SWT",
		"SWT",
		"region",
		"region",
		"handle",
		"SWT",
		"SWT",
		"OS",
		"OS",
		"rule",
		"SWT",
		"mode",
		"OS",
		"SWT",
		"mode",
		"OS",
		"SWT",
		"SWT",
		"OS",
		"handle",
		"mode",
		"handle",
		"SWT",
		"SWT",
		"font",
		"OS",
		"handle",
		"data",
		"font",
		"SWT",
		"SWT",
		"OS",
		"handle",
		"font",
		"handle",
		"SWT",
		"SWT",
		"color",
		"SWT",
		"SWT",
		"color",
		"SWT",
		"SWT",
		"data",
		"data",
		"Gdip",
		"data",
		"data",
		"data",
		"OS",
		"handle",
		"color",
		"data",
		"color",
		"OS",
		"handle",
		"color",
		"color",
		"data",
		"handle",
		"SWT",
		"SWT",
		"pattern",
		"pattern",
		"SWT",
		"SWT",
		"data",
		"pattern",
		"pattern",
		"data",
		"Gdip",
		"data",
		"pattern",
		"data",
		"Gdip",
		"data",
		"data",
		"data",
		"pattern",
		"handle",
		"SWT",
		"SWT",
		"data",
		"interpolation",
		"SWT",
		"interpolation",
		"SWT",
		"mode",
		"Gdip",
		"SWT",
		"mode",
		"Gdip",
		"SWT",
		"mode",
		"Gdip",
		"SWT",
		"mode",
		"Gdip",
		"SWT",
		"SWT",
		"Gdip",
		"data",
		"mode",
		"handle",
		"SWT",
		"SWT",
		"cap",
		"SWT",
		"capStyle",
		"OS",
		"SWT",
		"capStyle",
		"OS",
		"SWT",
		"capStyle",
		"OS",
		"SWT",
		"SWT",
		"capStyle",
		"data",
		"handle",
		"SWT",
		"SWT",
		"dashes",
		"dashes",
		"data",
		"dashes",
		"i",
		"dashes",
		"i",
		"dashes",
		"i",
		"dash",
		"SWT",
		"SWT",
		"data",
		"i",
		"dash",
		"data",
		"data",
		"OS",
		"OS",
		"data",
		"handle",
		"SWT",
		"SWT",
		"join",
		"SWT",
		"joinStyle",
		"OS",
		"SWT",
		"joinStyle",
		"OS",
		"SWT",
		"joinStyle",
		"OS",
		"SWT",
		"SWT",
		"joinStyle",
		"data",
		"handle",
		"SWT",
		"SWT",
		"lineStyle",
		"SWT",
		"style",
		"OS",
		"SWT",
		"style",
		"OS",
		"SWT",
		"style",
		"OS",
		"SWT",
		"style",
		"OS",
		"SWT",
		"style",
		"OS",
		"SWT",
		"style",
		"data",
		"OS",
		"OS",
		"SWT",
		"SWT",
		"OS",
		"handle",
		"style",
		"OS",
		"OS",
		"OS",
		"style",
		"data",
		"handle",
		"SWT",
		"SWT",
		"lineWidth",
		"data",
		"OS",
		"handle",
		"OS",
		"size",
		"OS",
		"hPen",
		"LOGPEN",
		"OS",
		"hPen",
		"LOGPEN",
		"logPen",
		"color",
		"logPen",
		"width",
		"logPen",
		"style",
		"logPen",
		"width",
		"newWidth",
		"lineStyle",
		"OS",
		"capStyle",
		"capStyle",
		"OS",
		"joinStyle",
		"joinStyle",
		"OS",
		"size",
		"EXTLOGPEN",
		"OS",
		"hPen",
		"size",
		"logPen",
		"OS",
		"OS",
		"hHeap",
		"OS",
		"size",
		"OS",
		"hPen",
		"size",
		"ptr",
		"OS",
		"logPen",
		"ptr",
		"EXTLOGPEN",
		"OS",
		"hHeap",
		"ptr",
		"color",
		"logPen",
		"width",
		"logPen",
		"style",
		"logPen",
		"extPen",
		"newWidth",
		"dashes",
		"style",
		"OS",
		"OS",
		"style",
		"OS",
		"OS",
		"style",
		"OS",
		"OS",
		"OS",
		"extPen",
		"newColor",
		"newColor",
		"color",
		"color",
		"newColor",
		"changed",
		"newWidth",
		"newWidth",
		"width",
		"width",
		"newWidth",
		"changed",
		"lineStyle",
		"style",
		"OS",
		"lineStyle",
		"style",
		"OS",
		"OS",
		"style",
		"style",
		"OS",
		"lineStyle",
		"changed",
		"capStyle",
		"style",
		"OS",
		"capStyle",
		"style",
		"style",
		"OS",
		"capStyle",
		"changed",
		"joinStyle",
		"style",
		"OS",
		"joinStyle",
		"style",
		"style",
		"OS",
		"joinStyle",
		"changed",
		"changed",
		"style",
		"OS",
		"OS",
		"dashes",
		"OS",
		"extPen",
		"width",
		"style",
		"OS",
		"OS",
		"logBrush",
		"OS",
		"logBrush",
		"color",
		"newPen",
		"OS",
		"style",
		"OS",
		"Math",
		"width",
		"logBrush",
		"dashes",
		"dashes",
		"dashes",
		"newPen",
		"OS",
		"style",
		"width",
		"color",
		"OS",
		"handle",
		"newPen",
		"data",
		"OS",
		"data",
		"data",
		"newPen",
		"data",
		"width",
		"data",
		"Gdip",
		"data",
		"data",
		"handle",
		"SWT",
		"SWT",
		"OS",
		"handle",
		"xor",
		"OS",
		"OS",
		"handle",
		"SWT",
		"SWT",
		"data",
		"antialias",
		"SWT",
		"antialias",
		"SWT",
		"textMode",
		"Gdip",
		"SWT",
		"textMode",
		"Gdip",
		"SWT",
		"OS",
		"OS",
		"type",
		"type",
		"OS",
		"textMode",
		"Gdip",
		"textMode",
		"Gdip",
		"SWT",
		"SWT",
		"Gdip",
		"data",
		"textMode",
		"handle",
		"SWT",
		"SWT",
		"transform",
		"transform",
		"SWT",
		"SWT",
		"data",
		"transform",
		"transform",
		"Gdip",
		"data",
		"transform",
		"Gdip",
		"Gdip",
		"data",
		"identity",
		"Gdip",
		"identity",
		"handle",
		"SWT",
		"SWT",
		"string",
		"SWT",
		"SWT",
		"string",
		"data",
		"length",
		"buffer",
		"length",
		"string",
		"length",
		"buffer",
		"buffer",
		"Gdip",
		"Gdip",
		"Gdip",
		"format",
		"Gdip",
		"format",
		"Gdip",
		"Gdip",
		"data",
		"buffer",
		"buffer",
		"font",
		"pt",
		"format",
		"bounds",
		"Gdip",
		"format",
		"Gdip",
		"font",
		"length",
		"Math",
		"bounds",
		"Math",
		"bounds",
		"length",
		"OS",
		"handle",
		"size",
		"size",
		"length",
		"string",
		"length",
		"buffer",
		"OS",
		"handle",
		"buffer",
		"length",
		"size",
		"size",
		"size",
		"string",
		"SWT",
		"SWT",
		"handle",
		"SWT",
		"SWT",
		"string",
		"SWT",
		"SWT",
		"data",
		"string",
		"length",
		"buffer",
		"length",
		"string",
		"length",
		"buffer",
		"buffer",
		"Gdip",
		"Gdip",
		"Gdip",
		"format",
		"Gdip",
		"format",
		"Gdip",
		"flags",
		"SWT",
		"font",
		"format",
		"Gdip",
		"format",
		"tabs",
		"tabs",
		"Gdip",
		"format",
		"flags",
		"SWT",
		"Gdip",
		"Gdip",
		"Gdip",
		"data",
		"buffer",
		"buffer",
		"font",
		"pt",
		"format",
		"bounds",
		"Gdip",
		"format",
		"Gdip",
		"font",
		"length",
		"Math",
		"bounds",
		"Math",
		"bounds",
		"string",
		"OS",
		"handle",
		"size",
		"size",
		"string",
		"OS",
		"OS",
		"flags",
		"SWT",
		"uFormat",
		"OS",
		"flags",
		"SWT",
		"uFormat",
		"OS",
		"flags",
		"SWT",
		"uFormat",
		"OS",
		"OS",
		"handle",
		"buffer",
		"buffer",
		"rect",
		"uFormat",
		"rect",
		"rect",
		"handle",
		"drawable",
		"data",
		"gc",
		"drawable",
		"data",
		"hDC",
		"gc",
		"gc",
		"data",
		"hDC",
		"gc",
		"NONE",
		"ERROR_NULL_ARGUMENT",
		"style",
		"device",
		"ERROR_NULL_ARGUMENT",
		"device",
		"device",
		"tracking",
		"LEFT_TO_RIGHT",
		"RIGHT_TO_LEFT",
		"LEFT_TO_RIGHT",
		"RIGHT_TO_LEFT",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_NULL_ARGUMENT",
		"type",
		"BITMAP",
		"ERROR_INVALID_ARGUMENT",
		"device",
		"handle",
		"width",
		"height",
		"SRCCOPY",
		"ERROR_GRAPHIC_DISPOSED",
		"hwnd",
		"SRCCOPY",
		"SW_INVALIDATE",
		"SW_ERASE",
		"IsWinCE",
		"SRCCOPY",
		"alpha",
		"ERROR_NO_HANDLES",
		"ERROR_NO_HANDLES",
		"OBJ_FONT",
		"ERROR_NO_HANDLES",
		"IsUnicode",
		"sizeof",
		"lfHeight",
		"FontStyleRegular",
		"lfWeight",
		"FontStyleBold",
		"lfItalic",
		"FontStyleItalic",
		"IsUnicode",
		"lfFaceName",
		"LF_FACESIZE",
		"lfFaceName",
		"CP_ACP",
		"MB_PRECOMPOSED",
		"length",
		"length",
		"length",
		"UnitPixel",
		"ERROR_NO_HANDLES",
		"OBJ_PEN",
		"sizeof",
		"sizeof",
		"lopnColor",
		"x",
		"lopnStyle",
		"PS_ENDCAP_FLAT",
		"PS_JOIN_MITER",
		"sizeof",
		"HEAP_ZERO_MEMORY",
		"sizeof",
		"elpColor",
		"elpWidth",
		"elpPenStyle",
		"alpha",
		"foregroundPattern",
		"handle",
		"foregroundPattern",
		"DashStyleSolid",
		"PS_STYLE_MASK",
		"PS_SOLID",
		"PS_DOT",
		"DashStyleDot",
		"PS_DASH",
		"DashStyleDash",
		"PS_DASHDOT",
		"DashStyleDashDot",
		"PS_DASHDOTDOT",
		"DashStyleDashDotDot",
		"PS_USERSTYLE",
		"dashes",
		"length",
		"dashes",
		"length",
		"dashes",
		"dashes",
		"length",
		"dashes",
		"length",
		"DashStyleCustom",
		"PS_JOIN_MASK",
		"PS_JOIN_MITER",
		"LineJoinMiter",
		"PS_JOIN_BEVEL",
		"LineJoinBevel",
		"PS_JOIN_ROUND",
		"LineJoinRound",
		"DashCapFlat",
		"PS_ENDCAP_MASK",
		"PS_ENDCAP_FLAT",
		"LineCapFlat",
		"PS_ENDCAP_ROUND",
		"LineCapRound",
		"DashCapRound",
		"PS_ENDCAP_SQUARE",
		"LineCapSquare",
		"BrushTypeSolidColor",
		"BrushTypeHatchFill",
		"BrushTypeLinearGradient",
		"BrushTypeTextureFill",
		"device",
		"gdipGraphics",
		"gdipGraphics",
		"gdipPen",
		"gdipPen",
		"gdipBrush",
		"gdipBrush",
		"gdipBrush",
		"gdipPen",
		"gdipGraphics",
		"hPen",
		"NULL_PEN",
		"hPen",
		"hPen",
		"hBrush",
		"NULL_BRUSH",
		"hBrush",
		"hBrush",
		"hNullBitmap",
		"hNullBitmap",
		"image",
		"memGC",
		"device",
		"image",
		"ps",
		"tracking",
		"device",
		"ERROR_GRAPHIC_DISPOSED",
		"gdipGraphics",
		"lineWidth",
		"lineWidth",
		"PixelOffsetModeNone",
		"gdipPen",
		"lineWidth",
		"lineWidth",
		"PixelOffsetModeHalf",
		"IsWinCE",
		"length",
		"NULL_BRUSH",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"gdipGraphics",
		"ERROR_INVALID_ARGUMENT",
		"gdipGraphics",
		"X",
		"Y",
		"Width",
		"Height",
		"gdipGraphics",
		"UnitPixel",
		"type",
		"BITMAP",
		"ICON",
		"ERROR_UNSUPPORTED_FORMAT",
		"TECHNOLOGY",
		"DI_NORMAL",
		"IsWinCE",
		"WIN32_VERSION",
		"DI_NOMIRROR",
		"IsWinCE",
		"WIN32_VERSION",
		"LAYOUT_RTL",
		"DT_RASPRINTER",
		"handle",
		"IsWinCE",
		"handle",
		"hbmColor",
		"hbmMask",
		"sizeof",
		"bmWidth",
		"bmHeight",
		"hbmMask",
		"hbmColor",
		"hbmMask",
		"DT_RASPRINTER",
		"handle",
		"fIcon",
		"hbmColor",
		"hbmMask",
		"hbmColor",
		"hbmColor",
		"ERROR_NO_HANDLES",
		"hbmColor",
		"IsWinCE",
		"COLORONCOLOR",
		"SRCCOPY",
		"SRCCOPY",
		"hbmMask",
		"hbmMask",
		"hbmMask",
		"ERROR_NO_HANDLES",
		"hbmMask",
		"SRCCOPY",
		"SRCCOPY",
		"DT_RASPRINTER",
		"hbmColor",
		"hbmMask",
		"ERROR_NO_HANDLES",
		"hbmMask",
		"hbmColor",
		"hbmMask",
		"hbmColor",
		"hbmColor",
		"ERROR_INVALID_ARGUMENT",
		"handle",
		"sizeof",
		"bmWidth",
		"bmHeight",
		"ERROR_INVALID_ARGUMENT",
		"memGC",
		"data",
		"hNullBitmap",
		"handle",
		"hNullBitmap",
		"hNullBitmap",
		"alpha",
		"alphaData",
		"transparentPixel",
		"handle",
		"handle",
		"hNullBitmap",
		"data",
		"alpha",
		"alpha",
		"IsWinCE",
		"WIN32_VERSION",
		"OBJ_BITMAP",
		"sizeof",
		"bmPlanes",
		"bmBitsPixel",
		"ERROR_NO_HANDLES",
		"SRCCOPY",
		"BlendOp",
		"AC_SRC_OVER",
		"handle",
		"alpha",
		"SourceConstantAlpha",
		"alpha",
		"ERROR_NO_HANDLES",
		"sizeof",
		"SRCCOPY",
		"bmWidthBytes",
		"bmHeight",
		"bmBits",
		"length",
		"alphaData",
		"bmBits",
		"length",
		"SourceConstantAlpha",
		"AlphaFormat",
		"AC_SRC_ALPHA",
		"SRCCOPY",
		"x",
		"x",
		"width",
		"y",
		"y",
		"height",
		"x",
		"y",
		"width",
		"height",
		"handle",
		"ERROR_NO_HANDLES",
		"sizeof",
		"bmWidthBytes",
		"bmHeight",
		"SRCCOPY",
		"bmBits",
		"SRCCOPY",
		"bmBits",
		"alpha",
		"alpha",
		"bmWidthBytes",
		"alphaData",
		"bmBits",
		"IsWinCE",
		"IsWinNT",
		"IsWinCE",
		"ERROR_NO_HANDLES",
		"IsWinCE",
		"COLORONCOLOR",
		"SRCCOPY",
		"SRCCOPY",
		"SRCCOPY",
		"IsWinCE",
		"COLORONCOLOR",
		"SRCCOPY",
		"SRCCOPY",
		"bmBits",
		"bmWidthBytes",
		"bmBits",
		"SRCCOPY",
		"RGN_OR",
		"RGN_AND",
		"IsWinCE",
		"R2_COPYPEN",
		"R2_XORPEN",
		"SRCINVERT",
		"SRCCOPY",
		"IsWinCE",
		"COLORONCOLOR",
		"IsWinCE",
		"SRCCOPY",
		"IsWinCE",
		"COLORONCOLOR",
		"SRCINVERT",
		"SRCAND",
		"SRCINVERT",
		"IsWinCE",
		"SRCINVERT",
		"SRCAND",
		"SRCINVERT",
		"SRCCOPY",
		"bmBits",
		"handle",
		"bmBitsPixel",
		"IsWinCE",
		"bmBits",
		"bmBitsPixel",
		"transparentPixel",
		"bmBitsPixel",
		"bmBits",
		"bmBits",
		"bmBitsPixel",
		"transparentPixel",
		"length",
		"length",
		"bmBitsPixel",
		"biSize",
		"sizeof",
		"biPlanes",
		"bmPlanes",
		"biBitCount",
		"bmBitsPixel",
		"sizeof",
		"sizeof",
		"IsWinCE",
		"ERROR_NOT_IMPLEMENTED",
		"handle",
		"DIB_RGB_COLORS",
		"sizeof",
		"transparentPixel",
		"transparentPixel",
		"bmBitsPixel",
		"IsWinCE",
		"IsWinNT",
		"WIN32_VERSION",
		"COLORONCOLOR",
		"SRCCOPY",
		"bmBitsPixel",
		"TECHNOLOGY",
		"DT_RASPRINTER",
		"SRCCOPY",
		"IsWinCE",
		"COLORONCOLOR",
		"SRCINVERT",
		"SRCAND",
		"SRCINVERT",
		"SRCINVERT",
		"SRCAND",
		"SRCINVERT",
		"SRCCOPY",
		"handle",
		"handle",
		"IsWinCE",
		"R2_COPYPEN",
		"R2_XORPEN",
		"SRCINVERT",
		"SRCCOPY",
		"IsWinCE",
		"COLORONCOLOR",
		"IsWinCE",
		"ERROR_GRAPHIC_DISPOSED",
		"gdipGraphics",
		"lineWidth",
		"lineWidth",
		"PixelOffsetModeNone",
		"gdipPen",
		"lineWidth",
		"lineWidth",
		"PixelOffsetModeHalf",
		"IsWinCE",
		"length",
		"lineWidth",
		"ERROR_GRAPHIC_DISPOSED",
		"gdipGraphics",
		"lineWidth",
		"lineWidth",
		"PixelOffsetModeNone",
		"gdipPen",
		"lineWidth",
		"lineWidth",
		"PixelOffsetModeHalf",
		"NULL_BRUSH",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_NULL_ARGUMENT",
		"handle",
		"ERROR_INVALID_ARGUMENT",
		"gdipGraphics",
		"lineWidth",
		"lineWidth",
		"PixelOffsetModeNone",
		"gdipPen",
		"handle",
		"lineWidth",
		"lineWidth",
		"PixelOffsetModeHalf",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_NULL_ARGUMENT",
		"gdipGraphics",
		"lineWidth",
		"lineWidth",
		"PixelOffsetModeNone",
		"gdipPen",
		"length",
		"lineWidth",
		"lineWidth",
		"PixelOffsetModeHalf",
		"NULL_BRUSH",
		"length",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_NULL_ARGUMENT",
		"gdipGraphics",
		"lineWidth",
		"lineWidth",
		"PixelOffsetModeNone",
		"gdipPen",
		"length",
		"lineWidth",
		"lineWidth",
		"PixelOffsetModeHalf",
		"length",
		"length",
		"lineWidth",
		"ERROR_GRAPHIC_DISPOSED",
		"gdipGraphics",
		"lineWidth",
		"lineWidth",
		"PixelOffsetModeNone",
		"gdipPen",
		"lineWidth",
		"lineWidth",
		"PixelOffsetModeHalf",
		"NULL_BRUSH",
		"ERROR_NULL_ARGUMENT",
		"x",
		"y",
		"width",
		"height",
		"ERROR_GRAPHIC_DISPOSED",
		"gdipGraphics",
		"gdipGraphics",
		"gdipPen",
		"IsWinCE",
		"NULL_BRUSH",
		"lineWidth",
		"lineWidth",
		"PixelOffsetModeNone",
		"lineWidth",
		"lineWidth",
		"PixelOffsetModeHalf",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_NULL_ARGUMENT",
		"gdipGraphics",
		"X",
		"Y",
		"gdipPen",
		"StringFormatFlagsMeasureTrailingSpaces",
		"gdipGraphics",
		"gdipGraphics",
		"gdipBrush",
		"X",
		"Y",
		"Width",
		"Height",
		"gdipGraphics",
		"IsWinCE",
		"R2_COPYPEN",
		"TRANSPARENT",
		"OPAQUE",
		"R2_XORPEN",
		"cx",
		"cy",
		"ERROR_NO_HANDLES",
		"BLACKNESS",
		"TRANSPARENT",
		"OBJ_FONT",
		"SRCINVERT",
		"DRAW_DELIMITER",
		"DRAW_TAB",
		"DRAW_DELIMITER",
		"DRAW_TAB",
		"DRAW_TRANSPARENT",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_NULL_ARGUMENT",
		"gdipGraphics",
		"DRAW_TRANSPARENT",
		"X",
		"Y",
		"gdipPen",
		"StringFormatFlagsMeasureTrailingSpaces",
		"DRAW_TAB",
		"length",
		"DRAW_MNEMONIC",
		"HotkeyPrefixShow",
		"HotkeyPrefixNone",
		"DRAW_TRANSPARENT",
		"gdipGraphics",
		"gdipGraphics",
		"gdipBrush",
		"X",
		"Y",
		"Width",
		"Height",
		"gdipGraphics",
		"IsWin95",
		"DT_LEFT",
		"DRAW_DELIMITER",
		"DT_SINGLELINE",
		"DRAW_TAB",
		"DT_EXPANDTABS",
		"DRAW_MNEMONIC",
		"DT_NOPREFIX",
		"IsWinCE",
		"R2_COPYPEN",
		"DRAW_TRANSPARENT",
		"TRANSPARENT",
		"OPAQUE",
		"R2_XORPEN",
		"DRAW_TRANSPARENT",
		"DT_CALCRECT",
		"right",
		"left",
		"bottom",
		"top",
		"ERROR_NO_HANDLES",
		"BLACKNESS",
		"TRANSPARENT",
		"OBJ_FONT",
		"SRCINVERT",
		"handle",
		"ERROR_GRAPHIC_DISPOSED",
		"gdipGraphics",
		"gdipGraphics",
		"gdipBrush",
		"IsWinCE",
		"length",
		"length",
		"NULL_PEN",
		"length",
		"NULL_PEN",
		"ERROR_GRAPHIC_DISPOSED",
		"CLR_INVALID",
		"COLOR_WINDOWTEXT",
		"CLR_INVALID",
		"COLOR_WINDOW",
		"IsWinCE",
		"R2_COPYPEN",
		"red",
		"red",
		"green",
		"green",
		"blue",
		"blue",
		"R2_XORPEN",
		"PATINVERT",
		"PATCOPY",
		"gdipGraphics",
		"X",
		"Y",
		"X",
		"X",
		"Y",
		"Y",
		"X",
		"X",
		"Y",
		"Y",
		"alpha",
		"ERROR_NO_HANDLES",
		"alpha",
		"ERROR_NO_HANDLES",
		"gdipGraphics",
		"IsWinCE",
		"R2_XORPEN",
		"TECHNOLOGY",
		"DT_RASPRINTER",
		"HEAP_ZERO_MEMORY",
		"sizeof",
		"sizeof",
		"sizeof",
		"UpperLeft",
		"LowerRight",
		"sizeof",
		"x",
		"y",
		"Red",
		"red",
		"red",
		"Green",
		"green",
		"green",
		"Blue",
		"blue",
		"blue",
		"Alpha",
		"sizeof",
		"x",
		"y",
		"Red",
		"red",
		"red",
		"Green",
		"green",
		"green",
		"Blue",
		"blue",
		"blue",
		"Alpha",
		"sizeof",
		"sizeof",
		"GRADIENT_FILL_RECT_V",
		"GRADIENT_FILL_RECT_H",
		"BITSPIXEL",
		"device",
		"ERROR_GRAPHIC_DISPOSED",
		"gdipGraphics",
		"gdipGraphics",
		"gdipBrush",
		"NULL_PEN",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_NULL_ARGUMENT",
		"handle",
		"ERROR_INVALID_ARGUMENT",
		"WINDING",
		"FillModeWinding",
		"FillModeAlternate",
		"handle",
		"gdipGraphics",
		"gdipBrush",
		"handle",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_NULL_ARGUMENT",
		"gdipGraphics",
		"WINDING",
		"FillModeWinding",
		"FillModeAlternate",
		"gdipGraphics",
		"gdipBrush",
		"length",
		"NULL_PEN",
		"length",
		"ERROR_GRAPHIC_DISPOSED",
		"gdipGraphics",
		"gdipGraphics",
		"gdipBrush",
		"IsWinCE",
		"R2_COPYPEN",
		"R2_XORPEN",
		"PATINVERT",
		"PATCOPY",
		"ERROR_NULL_ARGUMENT",
		"x",
		"y",
		"width",
		"height",
		"ERROR_GRAPHIC_DISPOSED",
		"gdipGraphics",
		"gdipGraphics",
		"gdipBrush",
		"NULL_PEN",
		"gdipGraphics",
		"gdipGraphics",
		"gdipGraphics",
		"gdipGraphics",
		"ERROR_GRAPHIC_DISPOSED",
		"IsWinCE",
		"cx",
		"ERROR_GRAPHIC_DISPOSED",
		"gdipGraphics",
		"ERROR_GRAPHIC_DISPOSED",
		"alpha",
		"ERROR_GRAPHIC_DISPOSED",
		"gdipGraphics",
		"DEFAULT",
		"gdipGraphics",
		"SmoothingModeDefault",
		"DEFAULT",
		"SmoothingModeHighSpeed",
		"SmoothingModeNone",
		"OFF",
		"SmoothingModeAntiAlias",
		"SmoothingModeAntiAlias8x8",
		"SmoothingModeHighQuality",
		"ON",
		"DEFAULT",
		"ERROR_GRAPHIC_DISPOSED",
		"CLR_INVALID",
		"COLOR_WINDOW",
		"device",
		"ERROR_GRAPHIC_DISPOSED",
		"backgroundPattern",
		"ERROR_GRAPHIC_DISPOSED",
		"IsWinCE",
		"IsUnicode",
		"cx",
		"tmOverhang",
		"ERROR_GRAPHIC_DISPOSED",
		"gdipGraphics",
		"gdipGraphics",
		"X",
		"Y",
		"Width",
		"Height",
		"left",
		"top",
		"right",
		"left",
		"bottom",
		"top",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"gdipGraphics",
		"gdipGraphics",
		"gdipGraphics",
		"gdipGraphics",
		"gdipGraphics",
		"gdipGraphics",
		"handle",
		"RGN_COPY",
		"handle",
		"handle",
		"left",
		"top",
		"right",
		"bottom",
		"handle",
		"x",
		"y",
		"IsWinCE",
		"x",
		"y",
		"handle",
		"handle",
		"RGN_AND",
		"WIN32_VERSION",
		"hwnd",
		"ps",
		"LAYOUT_RTL",
		"SYSRGN",
		"IsWinNT",
		"x",
		"y",
		"handle",
		"handle",
		"RGN_AND",
		"IsUnicode",
		"CP_ACP",
		"TCI_SRCCHARSET",
		"ERROR_GRAPHIC_DISPOSED",
		"IsWinCE",
		"FILL_EVEN_ODD",
		"WINDING",
		"FILL_WINDING",
		"FILL_EVEN_ODD",
		"ERROR_GRAPHIC_DISPOSED",
		"OBJ_FONT",
		"device",
		"ERROR_GRAPHIC_DISPOSED",
		"IsUnicode",
		"ERROR_GRAPHIC_DISPOSED",
		"CLR_INVALID",
		"COLOR_WINDOWTEXT",
		"device",
		"ERROR_GRAPHIC_DISPOSED",
		"foregroundPattern",
		"ERROR_GRAPHIC_DISPOSED",
		"gdipGraphics",
		"DEFAULT",
		"gdipGraphics",
		"InterpolationModeDefault",
		"DEFAULT",
		"InterpolationModeNearestNeighbor",
		"NONE",
		"InterpolationModeBilinear",
		"InterpolationModeLowQuality",
		"LOW",
		"InterpolationModeBicubic",
		"InterpolationModeHighQualityBilinear",
		"InterpolationModeHighQualityBicubic",
		"InterpolationModeHighQuality",
		"HIGH",
		"DEFAULT",
		"ERROR_GRAPHIC_DISPOSED",
		"OBJ_PEN",
		"sizeof",
		"sizeof",
		"lopnStyle",
		"PS_ENDCAP_FLAT",
		"sizeof",
		"HEAP_ZERO_MEMORY",
		"sizeof",
		"elpPenStyle",
		"PS_ENDCAP_MASK",
		"CAP_ROUND",
		"PS_ENDCAP_ROUND",
		"CAP_ROUND",
		"PS_ENDCAP_FLAT",
		"CAP_FLAT",
		"PS_ENDCAP_SQUARE",
		"CAP_SQUARE",
		"ERROR_GRAPHIC_DISPOSED",
		"dashes",
		"length",
		"dashes",
		"dashes",
		"length",
		"ERROR_GRAPHIC_DISPOSED",
		"OBJ_PEN",
		"sizeof",
		"sizeof",
		"lopnStyle",
		"PS_JOIN_MITER",
		"sizeof",
		"HEAP_ZERO_MEMORY",
		"sizeof",
		"elpPenStyle",
		"PS_JOIN_MASK",
		"JOIN_ROUND",
		"PS_JOIN_MITER",
		"JOIN_MITER",
		"PS_JOIN_ROUND",
		"JOIN_ROUND",
		"PS_JOIN_BEVEL",
		"JOIN_BEVEL",
		"ERROR_GRAPHIC_DISPOSED",
		"OBJ_PEN",
		"sizeof",
		"sizeof",
		"lopnStyle",
		"sizeof",
		"HEAP_ZERO_MEMORY",
		"sizeof",
		"elpPenStyle",
		"PS_STYLE_MASK",
		"PS_SOLID",
		"LINE_SOLID",
		"PS_DASH",
		"LINE_DASH",
		"PS_DOT",
		"LINE_DOT",
		"PS_DASHDOT",
		"LINE_DASHDOT",
		"PS_DASHDOTDOT",
		"LINE_DASHDOTDOT",
		"PS_USERSTYLE",
		"LINE_CUSTOM",
		"LINE_SOLID",
		"ERROR_GRAPHIC_DISPOSED",
		"OBJ_PEN",
		"sizeof",
		"sizeof",
		"x",
		"sizeof",
		"HEAP_ZERO_MEMORY",
		"sizeof",
		"elpWidth",
		"ERROR_GRAPHIC_DISPOSED",
		"style",
		"ERROR_GRAPHIC_DISPOSED",
		"gdipGraphics",
		"DEFAULT",
		"gdipGraphics",
		"TextRenderingHintSystemDefault",
		"DEFAULT",
		"TextRenderingHintSingleBitPerPixel",
		"TextRenderingHintSingleBitPerPixelGridFit",
		"OFF",
		"TextRenderingHintAntiAlias",
		"TextRenderingHintAntiAliasGridFit",
		"TextRenderingHintClearTypeGridFit",
		"ON",
		"DEFAULT",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"gdipGraphics",
		"handle",
		"ERROR_GRAPHIC_DISPOSED",
		"IsWinCE",
		"R2_COPYPEN",
		"R2_XORPEN",
		"device",
		"gdipGraphics",
		"x",
		"y",
		"gdipGraphics",
		"ERROR_NO_HANDLES",
		"PixelOffsetModeHalf",
		"gdipPen",
		"gdipPen",
		"gdipBrush",
		"gdipBrush",
		"foreground",
		"PS_SOLID",
		"hPen",
		"hPen",
		"hPen",
		"background",
		"hBrush",
		"hBrush",
		"hBrush",
		"hFont",
		"hPalette",
		"device",
		"image",
		"hNullBitmap",
		"handle",
		"memGC",
		"layout",
		"IsWinCE",
		"WIN32_VERSION",
		"LAYOUT_RTL",
		"LAYOUT_RTL",
		"LAYOUT_RTL",
		"style",
		"RIGHT_TO_LEFT",
		"style",
		"MIRRORED",
		"drawable",
		"data",
		"ERROR_GRAPHIC_DISPOSED",
		"gdipGraphics",
		"Width",
		"ERROR_GRAPHIC_DISPOSED",
		"gdipGraphics",
		"gdipGraphics",
		"gdipGraphics",
		"gdipPen",
		"gdipPen",
		"gdipBrush",
		"gdipBrush",
		"gdipGraphics",
		"gdipBrush",
		"gdipPen",
		"alpha",
		"backgroundPattern",
		"foregroundPattern",
		"hPen",
		"hPen",
		"hBrush",
		"hBrush",
		"ERROR_GRAPHIC_DISPOSED",
		"gdipGraphics",
		"DEFAULT",
		"DEFAULT",
		"SmoothingModeDefault",
		"OFF",
		"SmoothingModeNone",
		"ON",
		"SmoothingModeAntiAlias",
		"ERROR_INVALID_ARGUMENT",
		"gdipGraphics",
		"ERROR_GRAPHIC_DISPOSED",
		"gdipGraphics",
		"alpha",
		"gdipPen",
		"gdipPen",
		"gdipPen",
		"gdipBrush",
		"gdipBrush",
		"gdipBrush",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"backgroundPattern",
		"gdipBrush",
		"gdipBrush",
		"gdipBrush",
		"backgroundPattern",
		"handle",
		"background",
		"handle",
		"handle",
		"handle",
		"hBrush",
		"hBrush",
		"hBrush",
		"gdipBrush",
		"gdipBrush",
		"gdipBrush",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_INVALID_ARGUMENT",
		"gdipGraphics",
		"gdipBrush",
		"gdipBrush",
		"gdipBrush",
		"handle",
		"gdipBrush",
		"backgroundPattern",
		"gdipGraphics",
		"CombineModeReplace",
		"x",
		"y",
		"x",
		"y",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_INVALID_ARGUMENT",
		"WINDING",
		"FillModeWinding",
		"FillModeAlternate",
		"handle",
		"gdipGraphics",
		"handle",
		"ERROR_GRAPHIC_DISPOSED",
		"x",
		"y",
		"width",
		"height",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_INVALID_ARGUMENT",
		"handle",
		"ERROR_GRAPHIC_DISPOSED",
		"IsWinCE",
		"ALTERNATE",
		"FILL_WINDING",
		"WINDING",
		"FILL_EVEN_ODD",
		"ALTERNATE",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_GRAPHIC_DISPOSED",
		"systemFont",
		"device",
		"ERROR_INVALID_ARGUMENT",
		"handle",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"foregroundPattern",
		"gdipPen",
		"gdipPen",
		"gdipPen",
		"foregroundPattern",
		"handle",
		"foreground",
		"handle",
		"handle",
		"handle",
		"dashes",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_INVALID_ARGUMENT",
		"gdipGraphics",
		"gdipPen",
		"gdipPen",
		"handle",
		"gdipPen",
		"gdipPen",
		"gdipPen",
		"foregroundPattern",
		"ERROR_GRAPHIC_DISPOSED",
		"gdipGraphics",
		"DEFAULT",
		"DEFAULT",
		"InterpolationModeDefault",
		"NONE",
		"InterpolationModeNearestNeighbor",
		"LOW",
		"InterpolationModeLowQuality",
		"HIGH",
		"InterpolationModeHighQuality",
		"ERROR_INVALID_ARGUMENT",
		"gdipGraphics",
		"ERROR_GRAPHIC_DISPOSED",
		"CAP_ROUND",
		"PS_ENDCAP_ROUND",
		"CAP_FLAT",
		"PS_ENDCAP_FLAT",
		"CAP_SQUARE",
		"PS_ENDCAP_SQUARE",
		"ERROR_INVALID_ARGUMENT",
		"dashes",
		"ERROR_GRAPHIC_DISPOSED",
		"length",
		"dashes",
		"length",
		"length",
		"ERROR_INVALID_ARGUMENT",
		"dashes",
		"dashes",
		"dashes",
		"PS_SOLID",
		"PS_USERSTYLE",
		"dashes",
		"ERROR_GRAPHIC_DISPOSED",
		"JOIN_MITER",
		"PS_JOIN_MITER",
		"JOIN_ROUND",
		"PS_JOIN_ROUND",
		"JOIN_BEVEL",
		"PS_JOIN_BEVEL",
		"ERROR_INVALID_ARGUMENT",
		"dashes",
		"ERROR_GRAPHIC_DISPOSED",
		"LINE_SOLID",
		"PS_SOLID",
		"LINE_DASH",
		"PS_DASH",
		"LINE_DOT",
		"PS_DOT",
		"LINE_DASHDOT",
		"PS_DASHDOT",
		"LINE_DASHDOTDOT",
		"PS_DASHDOTDOT",
		"LINE_CUSTOM",
		"dashes",
		"PS_SOLID",
		"PS_USERSTYLE",
		"ERROR_INVALID_ARGUMENT",
		"PS_SOLID",
		"OPAQUE",
		"TRANSPARENT",
		"dashes",
		"ERROR_GRAPHIC_DISPOSED",
		"dashes",
		"OBJ_PEN",
		"sizeof",
		"sizeof",
		"lopnColor",
		"x",
		"lopnStyle",
		"PS_USERSTYLE",
		"PS_ENDCAP_FLAT",
		"PS_JOIN_MITER",
		"sizeof",
		"HEAP_ZERO_MEMORY",
		"sizeof",
		"elpColor",
		"elpWidth",
		"elpPenStyle",
		"PS_ENDCAP_MASK",
		"PS_ENDCAP_FLAT",
		"PS_JOIN_MASK",
		"PS_JOIN_MITER",
		"PS_ENDCAP_MASK",
		"PS_JOIN_MASK",
		"PS_TYPE_MASK",
		"PS_STYLE_MASK",
		"PS_STYLE_MASK",
		"PS_USERSTYLE",
		"PS_STYLE_MASK",
		"PS_ENDCAP_MASK",
		"PS_ENDCAP_MASK",
		"PS_JOIN_MASK",
		"PS_JOIN_MASK",
		"PS_STYLE_MASK",
		"PS_USERSTYLE",
		"IsWinCE",
		"PS_STYLE_MASK",
		"PS_USERSTYLE",
		"lbStyle",
		"BS_SOLID",
		"lbColor",
		"PS_GEOMETRIC",
		"length",
		"hPen",
		"hPen",
		"hPen",
		"lineWidth",
		"gdipPen",
		"gdipPen",
		"gdipPen",
		"ERROR_GRAPHIC_DISPOSED",
		"R2_XORPEN",
		"R2_COPYPEN",
		"ERROR_GRAPHIC_DISPOSED",
		"gdipGraphics",
		"DEFAULT",
		"DEFAULT",
		"TextRenderingHintSystemDefault",
		"OFF",
		"TextRenderingHintSingleBitPerPixelGridFit",
		"ON",
		"SPI_GETFONTSMOOTHINGTYPE",
		"FE_FONTSMOOTHINGCLEARTYPE",
		"TextRenderingHintClearTypeGridFit",
		"TextRenderingHintAntiAliasGridFit",
		"ERROR_INVALID_ARGUMENT",
		"gdipGraphics",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_INVALID_ARGUMENT",
		"gdipGraphics",
		"gdipGraphics",
		"handle",
		"gdipGraphics",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_NULL_ARGUMENT",
		"gdipGraphics",
		"StringFormatFlagsMeasureTrailingSpaces",
		"gdipGraphics",
		"length",
		"Width",
		"Height",
		"cy",
		"cx",
		"cy",
		"DRAW_DELIMITER",
		"DRAW_TAB",
		"ERROR_GRAPHIC_DISPOSED",
		"ERROR_NULL_ARGUMENT",
		"gdipGraphics",
		"StringFormatFlagsMeasureTrailingSpaces",
		"DRAW_TAB",
		"length",
		"DRAW_MNEMONIC",
		"HotkeyPrefixShow",
		"HotkeyPrefixNone",
		"gdipGraphics",
		"length",
		"Width",
		"Height",
		"cy",
		"DT_LEFT",
		"DT_CALCRECT",
		"DRAW_DELIMITER",
		"DT_SINGLELINE",
		"DRAW_TAB",
		"DT_EXPANDTABS",
		"DRAW_MNEMONIC",
		"DT_NOPREFIX",
		"right",
		"bottom",
		"drawable",
		"drawable",
		"style",
		"style",
		"image",
		"x",
		"y",
		"srcX",
		"srcY",
		"width",
		"height",
		"destX",
		"destY",
		"srcX",
		"srcY",
		"width",
		"height",
		"destX",
		"destY",
		"paint",
		"hDC",
		"hFont",
		"brush",
		"x",
		"y",
		"width",
		"height",
		"startAngle",
		"arcAngle",
		"x",
		"y",
		"width",
		"height",
		"image",
		"x",
		"y",
		"image",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"srcImage",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"simple",
		"srcImage",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"simple",
		"srcImage",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"simple",
		"srcImage",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"simple",
		"bm",
		"imgWidth",
		"imgHeight",
		"srcHdc",
		"maskHdc",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"simple",
		"imgWidth",
		"imgHeight",
		"srcImage",
		"srcColor",
		"srcMask",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"simple",
		"imgWidth",
		"imgHeight",
		"offscreen",
		"srcImage",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"simple",
		"bm",
		"imgWidth",
		"imgHeight",
		"srcImage",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"simple",
		"bm",
		"imgWidth",
		"imgHeight",
		"x1",
		"y1",
		"x2",
		"y2",
		"x",
		"y",
		"width",
		"height",
		"path",
		"x",
		"y",
		"pointArray",
		"pointArray",
		"x",
		"y",
		"width",
		"height",
		"rect",
		"x",
		"y",
		"width",
		"height",
		"arcWidth",
		"arcHeight",
		"gdipGraphics",
		"brush",
		"x",
		"y",
		"width",
		"height",
		"arcWidth",
		"arcHeight",
		"string",
		"x",
		"y",
		"string",
		"x",
		"y",
		"isTransparent",
		"string",
		"x",
		"y",
		"string",
		"x",
		"y",
		"isTransparent",
		"string",
		"x",
		"y",
		"flags",
		"object",
		"x",
		"y",
		"width",
		"height",
		"startAngle",
		"arcAngle",
		"x",
		"y",
		"width",
		"height",
		"vertical",
		"x",
		"y",
		"width",
		"height",
		"path",
		"pointArray",
		"x",
		"y",
		"width",
		"height",
		"rect",
		"x",
		"y",
		"width",
		"height",
		"arcWidth",
		"arcHeight",
		"gdipGraphics",
		"brush",
		"x",
		"y",
		"width",
		"height",
		"arcWidth",
		"arcHeight",
		"ch",
		"ch",
		"region",
		"transform",
		"draw",
		"fill",
		"drawable",
		"data",
		"hDC",
		"font",
		"format",
		"advanced",
		"e",
		"antialias",
		"alpha",
		"color",
		"pattern",
		"clipRgn",
		"x",
		"y",
		"width",
		"height",
		"path",
		"rect",
		"region",
		"rule",
		"font",
		"color",
		"pattern",
		"interpolation",
		"cap",
		"dashes",
		"join",
		"lineStyle",
		"lineWidth",
		"newColor",
		"newWidth",
		"lineStyle",
		"capStyle",
		"joinStyle",
		"dashes",
		"xor",
		"antialias",
		"transform",
		"string",
		"string",
		"string",
		"flags",
		"drawable",
		"data",
		"hDC",
		"data"
	],
	"extendORImplementFiles":[
		"Resource"
	],
	"package":[
		"org.eclipse.swt.graphics"
	],
	"import":[
		"org.eclipse.swt.internal",
		"org.eclipse.swt.internal.gdip",
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt"
	],
	"methods":[
		"checkStyle",
		"copyArea",
		"copyArea",
		"copyArea",
		"createGdipBrush",
		"createGdipFont",
		"createGdipFont",
		"createGdipPen",
		"destroyGdipBrush",
		"dispose",
		"drawArc",
		"drawFocus",
		"drawImage",
		"drawImage",
		"drawImage",
		"drawIcon",
		"drawBitmap",
		"drawBitmapAlpha",
		"drawBitmapTransparentByClipping",
		"drawBitmapMask",
		"drawBitmapTransparent",
		"drawBitmap",
		"drawLine",
		"drawOval",
		"drawPath",
		"drawPoint",
		"drawPolygon",
		"drawPolyline",
		"drawRectangle",
		"drawRectangle",
		"drawRoundRectangle",
		"drawRoundRectangleGdip",
		"drawString",
		"drawString",
		"drawText",
		"drawText",
		"drawText",
		"equals",
		"fillArc",
		"fillGradientRectangle",
		"fillOval",
		"fillPath",
		"fillPolygon",
		"fillRectangle",
		"fillRectangle",
		"fillRoundRectangle",
		"fillRoundRectangleGdip",
		"flush",
		"getAdvanceWidth",
		"getAdvanced",
		"getAlpha",
		"getAntialias",
		"getBackground",
		"getBackgroundPattern",
		"getCharWidth",
		"getClipping",
		"getClipping",
		"getCodePage",
		"getFillRule",
		"getFont",
		"getFontMetrics",
		"getForeground",
		"getForegroundPattern",
		"getInterpolation",
		"getLineCap",
		"getLineDash",
		"getLineJoin",
		"getLineStyle",
		"getLineWidth",
		"getStyle",
		"getTextAntialias",
		"getTransform",
		"getXORMode",
		"initGdip",
		"init",
		"hashCode",
		"isClipped",
		"isDisposed",
		"measureSpace",
		"setAdvanced",
		"setAntialias",
		"setAlpha",
		"setBackground",
		"setBackgroundPattern",
		"setClipping",
		"setClipping",
		"setClipping",
		"setClipping",
		"setClipping",
		"setFillRule",
		"setFont",
		"setForeground",
		"setForegroundPattern",
		"setInterpolation",
		"setLineCap",
		"setLineDash",
		"setLineJoin",
		"setLineStyle",
		"setLineWidth",
		"setPen",
		"setXORMode",
		"setTextAntialias",
		"setTransform",
		"stringExtent",
		"textExtent",
		"textExtent",
		"toString",
		"win32_new",
		"win32_new",
		"error",
		"checkStyle",
		"internal_new_GC",
		"getDevice",
		"error",
		"init",
		"new_Object",
		"error",
		"error",
		"isDisposed",
		"error",
		"internal_new_GC",
		"getBounds",
		"CreateCompatibleDC",
		"SelectObject",
		"BitBlt",
		"SelectObject",
		"DeleteDC",
		"internal_dispose_GC",
		"copyArea",
		"error",
		"BitBlt",
		"CreateRectRgn",
		"GetClipRgn",
		"GetRgnBox",
		"DeleteObject",
		"SetRect",
		"ScrollWindowEx",
		"BitBlt",
		"InvalidateRect",
		"SetRect",
		"abs",
		"InvalidateRect",
		"SetRect",
		"abs",
		"InvalidateRect",
		"GetBkColor",
		"Color_new",
		"error",
		"SolidBrush_new",
		"error",
		"Color_delete",
		"createGdipFont",
		"GetCurrentObject",
		"Font_new",
		"error",
		"Font_IsAvailable",
		"Font_delete",
		"GetObject",
		"abs",
		"MultiByteToWideChar",
		"equalsIgnoreCase",
		"length",
		"getChars",
		"length",
		"Font_new",
		"error",
		"GetCurrentObject",
		"GetObject",
		"GetObject",
		"GetObject",
		"GetProcessHeap",
		"HeapAlloc",
		"GetObject",
		"MoveMemory",
		"HeapFree",
		"Color_new",
		"Pen_new",
		"max",
		"Color_delete",
		"Pen_SetBrush",
		"max",
		"Pen_SetDashPattern",
		"Pen_SetDashStyle",
		"Pen_SetDashStyle",
		"Pen_SetLineJoin",
		"Pen_SetLineCap",
		"Brush_GetType",
		"SolidBrush_delete",
		"HatchBrush_delete",
		"LinearGradientBrush_delete",
		"TextureBrush_delete",
		"isDisposed",
		"Graphics_delete",
		"Pen_delete",
		"destroyGdipBrush",
		"GetStockObject",
		"SelectObject",
		"DeleteObject",
		"GetStockObject",
		"SelectObject",
		"DeleteObject",
		"SelectObject",
		"internal_dispose_GC",
		"dispose_Object",
		"error",
		"initGdip",
		"Graphics_SetPixelOffsetMode",
		"Graphics_DrawArc",
		"Graphics_SetPixelOffsetMode",
		"cos",
		"sin",
		"Polyline",
		"cos",
		"sin",
		"cos",
		"sin",
		"GetStockObject",
		"SelectObject",
		"Arc",
		"SelectObject",
		"error",
		"SetRect",
		"DrawFocusRect",
		"error",
		"error",
		"isDisposed",
		"error",
		"drawImage",
		"error",
		"error",
		"error",
		"isDisposed",
		"error",
		"drawImage",
		"createGdipImage",
		"Image_GetWidth",
		"Image_GetHeight",
		"error",
		"Graphics_DrawImage",
		"Graphics_DrawImage",
		"Bitmap_delete",
		"GetProcessHeap",
		"HeapFree",
		"drawBitmap",
		"drawIcon",
		"error",
		"GetDeviceCaps",
		"VERSION",
		"VERSION",
		"GetLayout",
		"DrawIconEx",
		"GetIconInfo",
		"GetIconInfo",
		"GetObject",
		"drawBitmapMask",
		"DrawIconEx",
		"CreateCompatibleDC",
		"CreateCompatibleDC",
		"SelectObject",
		"CreateCompatibleBitmap",
		"error",
		"SelectObject",
		"SetStretchBltMode",
		"StretchBlt",
		"BitBlt",
		"SelectObject",
		"CreateBitmap",
		"error",
		"SelectObject",
		"StretchBlt",
		"BitBlt",
		"SelectObject",
		"SelectObject",
		"drawBitmapTransparentByClipping",
		"SelectObject",
		"SelectObject",
		"SelectObject",
		"SelectObject",
		"CreateIconIndirect",
		"error",
		"DrawIconEx",
		"DestroyIcon",
		"DeleteObject",
		"DeleteObject",
		"DeleteDC",
		"DeleteDC",
		"DeleteObject",
		"DeleteObject",
		"error",
		"GetObject",
		"error",
		"isDisposed",
		"flush",
		"SelectObject",
		"drawBitmapAlpha",
		"drawBitmapTransparent",
		"drawBitmap",
		"SelectObject",
		"drawBitmap",
		"VERSION",
		"GetCurrentObject",
		"GetObject",
		"createDIB",
		"error",
		"CreateCompatibleDC",
		"SelectObject",
		"BitBlt",
		"CreateCompatibleDC",
		"SelectObject",
		"AlphaBlend",
		"createDIB",
		"error",
		"CreateCompatibleDC",
		"SelectObject",
		"GetObject",
		"BitBlt",
		"MoveMemory",
		"MoveMemory",
		"AlphaBlend",
		"SelectObject",
		"DeleteDC",
		"DeleteObject",
		"BitBlt",
		"SelectObject",
		"DeleteDC",
		"DeleteObject",
		"SelectObject",
		"DeleteDC",
		"getClipping",
		"intersection",
		"isEmpty",
		"max",
		"max",
		"CreateCompatibleDC",
		"SelectObject",
		"CreateCompatibleDC",
		"createDIB",
		"max",
		"max",
		"error",
		"SelectObject",
		"GetObject",
		"BitBlt",
		"MoveMemory",
		"BitBlt",
		"MoveMemory",
		"MoveMemory",
		"CreateCompatibleDC",
		"createDIB",
		"error",
		"SelectObject",
		"SetStretchBltMode",
		"StretchBlt",
		"BitBlt",
		"BitBlt",
		"SelectObject",
		"DeleteObject",
		"DeleteDC",
		"SetStretchBltMode",
		"StretchBlt",
		"BitBlt",
		"MoveMemory",
		"MoveMemory",
		"BitBlt",
		"SelectObject",
		"DeleteDC",
		"DeleteObject",
		"SelectObject",
		"DeleteDC",
		"CreateRectRgn",
		"GetPixel",
		"CreateRectRgn",
		"CombineRgn",
		"DeleteObject",
		"GetRegionData",
		"GetRegionData",
		"ExtCreateRegion",
		"DeleteObject",
		"OffsetRgn",
		"CreateRectRgn",
		"GetClipRgn",
		"CombineRgn",
		"SelectClipRgn",
		"GetROP2",
		"SetROP2",
		"SetROP2",
		"SetStretchBltMode",
		"StretchBlt",
		"SetStretchBltMode",
		"BitBlt",
		"SelectClipRgn",
		"DeleteObject",
		"DeleteObject",
		"CreateCompatibleDC",
		"SelectObject",
		"CreateCompatibleDC",
		"CreateCompatibleBitmap",
		"SelectObject",
		"BitBlt",
		"SetBkColor",
		"SetTextColor",
		"SetStretchBltMode",
		"StretchBlt",
		"SelectObject",
		"StretchBlt",
		"SelectObject",
		"StretchBlt",
		"SetStretchBltMode",
		"BitBlt",
		"SetTextColor",
		"SelectObject",
		"BitBlt",
		"SelectObject",
		"BitBlt",
		"BitBlt",
		"SelectObject",
		"DeleteDC",
		"DeleteObject",
		"SetBkColor",
		"SetTextColor",
		"SelectObject",
		"DeleteDC",
		"CreateCompatibleDC",
		"SelectObject",
		"MoveMemory",
		"MoveMemory",
		"GetPixel",
		"MoveMemory",
		"GetDIBColorTable",
		"SetDIBColorTable",
		"MoveMemory",
		"error",
		"GetDIBits",
		"TransparentImage",
		"VERSION",
		"SetStretchBltMode",
		"TransparentBlt",
		"SetStretchBltMode",
		"CreateCompatibleDC",
		"CreateBitmap",
		"SelectObject",
		"SetBkColor",
		"BitBlt",
		"SetDIBColorTable",
		"GetDeviceCaps",
		"drawBitmapTransparentByClipping",
		"CreateCompatibleDC",
		"CreateCompatibleBitmap",
		"SelectObject",
		"BitBlt",
		"SetStretchBltMode",
		"StretchBlt",
		"StretchBlt",
		"StretchBlt",
		"BitBlt",
		"BitBlt",
		"BitBlt",
		"BitBlt",
		"SelectObject",
		"DeleteDC",
		"DeleteObject",
		"SelectObject",
		"DeleteDC",
		"DeleteObject",
		"SelectObject",
		"DeleteObject",
		"DeleteDC",
		"CreateCompatibleDC",
		"SelectObject",
		"GetROP2",
		"SetROP2",
		"SetROP2",
		"SetStretchBltMode",
		"StretchBlt",
		"SetStretchBltMode",
		"BitBlt",
		"SelectObject",
		"DeleteDC",
		"error",
		"initGdip",
		"Graphics_SetPixelOffsetMode",
		"Graphics_DrawLine",
		"Graphics_SetPixelOffsetMode",
		"Polyline",
		"MoveToEx",
		"LineTo",
		"SetPixel",
		"GetTextColor",
		"error",
		"initGdip",
		"Graphics_SetPixelOffsetMode",
		"Graphics_DrawEllipse",
		"Graphics_SetPixelOffsetMode",
		"GetStockObject",
		"SelectObject",
		"Ellipse",
		"SelectObject",
		"error",
		"error",
		"error",
		"initGdip",
		"Graphics_SetPixelOffsetMode",
		"Graphics_DrawPath",
		"Graphics_SetPixelOffsetMode",
		"error",
		"SetPixel",
		"GetTextColor",
		"error",
		"error",
		"initGdip",
		"Graphics_SetPixelOffsetMode",
		"Graphics_DrawPolygon",
		"Graphics_SetPixelOffsetMode",
		"GetStockObject",
		"SelectObject",
		"Polygon",
		"SelectObject",
		"error",
		"error",
		"initGdip",
		"Graphics_SetPixelOffsetMode",
		"Graphics_DrawLines",
		"Graphics_SetPixelOffsetMode",
		"Polyline",
		"SetPixel",
		"GetTextColor",
		"error",
		"initGdip",
		"Graphics_SetPixelOffsetMode",
		"Graphics_DrawRectangle",
		"Graphics_SetPixelOffsetMode",
		"SelectObject",
		"GetStockObject",
		"Rectangle",
		"SelectObject",
		"error",
		"drawRectangle",
		"error",
		"initGdip",
		"drawRoundRectangleGdip",
		"drawRectangle",
		"drawLine",
		"drawLine",
		"drawLine",
		"drawLine",
		"drawArc",
		"drawArc",
		"drawArc",
		"drawArc",
		"GetStockObject",
		"SelectObject",
		"RoundRect",
		"SelectObject",
		"Graphics_SetPixelOffsetMode",
		"Graphics_DrawArc",
		"Graphics_DrawLine",
		"Graphics_DrawArc",
		"Graphics_DrawLine",
		"Graphics_DrawArc",
		"Graphics_DrawLine",
		"Graphics_DrawArc",
		"Graphics_DrawLine",
		"Graphics_DrawArc",
		"Graphics_DrawLine",
		"Graphics_DrawArc",
		"Graphics_DrawLine",
		"Graphics_DrawArc",
		"Graphics_DrawLine",
		"Graphics_DrawArc",
		"Graphics_DrawLine",
		"Graphics_DrawArc",
		"Graphics_SetPixelOffsetMode",
		"drawString",
		"error",
		"error",
		"length",
		"getChars",
		"initGdip",
		"createGdipFont",
		"Pen_GetBrush",
		"StringFormat_Clone",
		"StringFormat_GenericTypographic",
		"StringFormat_SetFormatFlags",
		"StringFormat_GetFormatFlags",
		"Graphics_MeasureString",
		"Graphics_FillRectangle",
		"round",
		"round",
		"Graphics_DrawString",
		"StringFormat_delete",
		"Font_delete",
		"SetROP2",
		"SetROP2",
		"GetROP2",
		"SetBkMode",
		"ExtTextOutW",
		"GetTextColor",
		"GetTextExtentPoint32W",
		"CreateCompatibleBitmap",
		"error",
		"CreateCompatibleDC",
		"SelectObject",
		"PatBlt",
		"SetBkMode",
		"SetTextColor",
		"SelectObject",
		"GetCurrentObject",
		"ExtTextOutW",
		"BitBlt",
		"SelectObject",
		"DeleteDC",
		"DeleteObject",
		"GetBkColor",
		"SetTextColor",
		"ExtTextOutW",
		"SetTextColor",
		"SetBkMode",
		"drawText",
		"drawText",
		"error",
		"error",
		"length",
		"initGdip",
		"length",
		"getChars",
		"createGdipFont",
		"Pen_GetBrush",
		"StringFormat_Clone",
		"StringFormat_GenericTypographic",
		"StringFormat_SetFormatFlags",
		"StringFormat_GetFormatFlags",
		"measureSpace",
		"StringFormat_SetTabStops",
		"StringFormat_SetHotkeyPrefix",
		"Graphics_MeasureString",
		"Graphics_FillRectangle",
		"round",
		"round",
		"Graphics_DrawString",
		"StringFormat_delete",
		"Font_delete",
		"getCodePage",
		"length",
		"SetRect",
		"SetROP2",
		"SetROP2",
		"GetROP2",
		"SetBkMode",
		"DrawText",
		"GetTextColor",
		"DrawText",
		"length",
		"CreateCompatibleBitmap",
		"error",
		"CreateCompatibleDC",
		"SelectObject",
		"PatBlt",
		"SetBkMode",
		"SetTextColor",
		"SelectObject",
		"GetCurrentObject",
		"SetRect",
		"DrawText",
		"BitBlt",
		"SelectObject",
		"DeleteDC",
		"DeleteObject",
		"GetBkColor",
		"SetTextColor",
		"DrawText",
		"SetTextColor",
		"SetBkMode",
		"error",
		"initGdip",
		"Graphics_FillPie",
		"cos",
		"sin",
		"GetStockObject",
		"SelectObject",
		"Polygon",
		"SelectObject",
		"cos",
		"sin",
		"cos",
		"sin",
		"GetStockObject",
		"SelectObject",
		"Pie",
		"SelectObject",
		"error",
		"GetTextColor",
		"GetSysColor",
		"GetBkColor",
		"GetSysColor",
		"SetROP2",
		"SetROP2",
		"GetROP2",
		"PatBlt",
		"initGdip",
		"Color_new",
		"error",
		"Color_new",
		"error",
		"LinearGradientBrush_new",
		"Graphics_FillRectangle",
		"LinearGradientBrush_delete",
		"Color_delete",
		"Color_delete",
		"GetDeviceCaps",
		"GetProcessHeap",
		"HeapAlloc",
		"MoveMemory",
		"MoveMemory",
		"MoveMemory",
		"GradientFill",
		"HeapFree",
		"GetDeviceCaps",
		"fillGradientRectangle",
		"error",
		"initGdip",
		"Graphics_FillEllipse",
		"GetStockObject",
		"SelectObject",
		"Ellipse",
		"SelectObject",
		"error",
		"error",
		"error",
		"initGdip",
		"GetPolyFillMode",
		"GraphicsPath_SetFillMode",
		"Graphics_FillPath",
		"error",
		"error",
		"initGdip",
		"GetPolyFillMode",
		"Graphics_FillPolygon",
		"GetStockObject",
		"SelectObject",
		"Polygon",
		"SelectObject",
		"error",
		"initGdip",
		"Graphics_FillRectangle",
		"SetROP2",
		"SetROP2",
		"GetROP2",
		"PatBlt",
		"error",
		"fillRectangle",
		"error",
		"initGdip",
		"fillRoundRectangleGdip",
		"GetStockObject",
		"SelectObject",
		"RoundRect",
		"SelectObject",
		"Graphics_FillPie",
		"Graphics_FillRectangle",
		"Graphics_FillPie",
		"Graphics_FillRectangle",
		"Graphics_FillPie",
		"Graphics_FillRectangle",
		"Graphics_FillPie",
		"Graphics_FillPie",
		"Graphics_FillRectangle",
		"Graphics_FillPie",
		"Graphics_FillPie",
		"Graphics_FillRectangle",
		"Graphics_FillPie",
		"Graphics_FillPie",
		"Graphics_Flush",
		"Graphics_GetHDC",
		"Graphics_ReleaseHDC",
		"error",
		"GetTextExtentPoint32W",
		"getCodePage",
		"tcharAt",
		"GetCharWidth",
		"error",
		"error",
		"error",
		"Graphics_GetSmoothingMode",
		"error",
		"GetBkColor",
		"GetSysColor",
		"win32_new",
		"error",
		"error",
		"getCodePage",
		"tcharAt",
		"GetCharABCWidths",
		"GetTextMetrics",
		"GetTextExtentPoint32W",
		"error",
		"Graphics_GetClipBounds",
		"GetClipBox",
		"error",
		"error",
		"isDisposed",
		"error",
		"Region_new",
		"Graphics_GetClip",
		"Matrix_new",
		"Matrix_new",
		"Graphics_GetTransform",
		"Graphics_SetTransform",
		"Region_GetHRGN",
		"Graphics_SetTransform",
		"Matrix_delete",
		"Matrix_delete",
		"CombineRgn",
		"Region_delete",
		"GetWindowOrgEx",
		"GetClipRgn",
		"GetClipBox",
		"SetRectRgn",
		"OffsetRgn",
		"CreateRectRgn",
		"GetMetaRgn",
		"OffsetRgn",
		"CombineRgn",
		"DeleteObject",
		"VERSION",
		"GetLayout",
		"CreateRectRgn",
		"GetRandomRgn",
		"MapWindowPoints",
		"OffsetRgn",
		"CombineRgn",
		"DeleteObject",
		"GetTextCharset",
		"TranslateCharsetInfo",
		"error",
		"GetPolyFillMode",
		"error",
		"GetCurrentObject",
		"win32_new",
		"error",
		"GetTextMetrics",
		"win32_new",
		"error",
		"GetTextColor",
		"GetSysColor",
		"win32_new",
		"error",
		"error",
		"Graphics_GetInterpolationMode",
		"error",
		"GetCurrentObject",
		"GetObject",
		"GetObject",
		"GetObject",
		"GetProcessHeap",
		"HeapAlloc",
		"GetObject",
		"MoveMemory",
		"HeapFree",
		"error",
		"arraycopy",
		"error",
		"GetCurrentObject",
		"GetObject",
		"GetObject",
		"GetObject",
		"GetProcessHeap",
		"HeapAlloc",
		"GetObject",
		"MoveMemory",
		"HeapFree",
		"error",
		"GetCurrentObject",
		"GetObject",
		"GetObject",
		"GetObject",
		"GetProcessHeap",
		"HeapAlloc",
		"GetObject",
		"MoveMemory",
		"HeapFree",
		"error",
		"GetCurrentObject",
		"GetObject",
		"GetObject",
		"GetObject",
		"GetProcessHeap",
		"HeapAlloc",
		"GetObject",
		"MoveMemory",
		"HeapFree",
		"error",
		"error",
		"Graphics_GetTextRenderingHint",
		"error",
		"error",
		"isDisposed",
		"error",
		"Graphics_GetTransform",
		"setElements",
		"error",
		"SetROP2",
		"SetROP2",
		"GetROP2",
		"checkGDIP",
		"CreateRectRgn",
		"GetClipRgn",
		"GetWindowOrgEx",
		"OffsetRgn",
		"SelectClipRgn",
		"Graphics_new",
		"error",
		"Graphics_SetPixelOffsetMode",
		"setClipping",
		"DeleteObject",
		"createGdipPen",
		"createGdipBrush",
		"GetTextColor",
		"SetTextColor",
		"CreatePen",
		"SelectObject",
		"DeleteObject",
		"GetBkColor",
		"SetBkColor",
		"CreateSolidBrush",
		"SelectObject",
		"DeleteObject",
		"SelectObject",
		"SelectPalette",
		"RealizePalette",
		"SelectObject",
		"VERSION",
		"GetLayout",
		"SetLayout",
		"error",
		"CreateRectRgn",
		"GetClipRgn",
		"DeleteObject",
		"Graphics_MeasureString",
		"error",
		"initGdip",
		"Graphics_delete",
		"Pen_delete",
		"destroyGdipBrush",
		"setClipping",
		"SelectObject",
		"SelectObject",
		"error",
		"error",
		"initGdip",
		"Graphics_SetSmoothingMode",
		"error",
		"initGdip",
		"Pen_delete",
		"destroyGdipBrush",
		"error",
		"error",
		"isDisposed",
		"error",
		"destroyGdipBrush",
		"GetBkColor",
		"SetBkColor",
		"CreateSolidBrush",
		"SelectObject",
		"DeleteObject",
		"destroyGdipBrush",
		"error",
		"isDisposed",
		"error",
		"initGdip",
		"destroyGdipBrush",
		"Brush_Clone",
		"Region_new",
		"Graphics_SetClip",
		"Region_delete",
		"Graphics_ResetClip",
		"GetWindowOrgEx",
		"OffsetRgn",
		"SelectClipRgn",
		"OffsetRgn",
		"DeleteObject",
		"error",
		"CreateRectRgn",
		"setClipping",
		"DeleteObject",
		"error",
		"isDisposed",
		"error",
		"setClipping",
		"initGdip",
		"GetPolyFillMode",
		"GraphicsPath_SetFillMode",
		"Graphics_SetClip",
		"error",
		"setClipping",
		"setClipping",
		"error",
		"isDisposed",
		"error",
		"setClipping",
		"error",
		"error",
		"SetPolyFillMode",
		"error",
		"SelectObject",
		"isDisposed",
		"error",
		"SelectObject",
		"error",
		"error",
		"isDisposed",
		"error",
		"Pen_delete",
		"GetTextColor",
		"SetTextColor",
		"setPen",
		"error",
		"isDisposed",
		"error",
		"initGdip",
		"Pen_SetBrush",
		"Pen_delete",
		"error",
		"error",
		"initGdip",
		"Graphics_SetInterpolationMode",
		"error",
		"error",
		"setPen",
		"error",
		"error",
		"setPen",
		"error",
		"error",
		"setPen",
		"error",
		"error",
		"SetBkMode",
		"setPen",
		"error",
		"setPen",
		"GetCurrentObject",
		"GetObject",
		"GetObject",
		"GetObject",
		"GetProcessHeap",
		"HeapAlloc",
		"GetObject",
		"MoveMemory",
		"HeapFree",
		"ExtCreatePen",
		"max",
		"CreatePen",
		"SelectObject",
		"DeleteObject",
		"Pen_delete",
		"error",
		"SetROP2",
		"error",
		"SystemParametersInfo",
		"error",
		"initGdip",
		"Graphics_SetTextRenderingHint",
		"error",
		"isDisposed",
		"error",
		"initGdip",
		"Graphics_SetTransform",
		"Matrix_new",
		"Graphics_SetTransform",
		"Matrix_delete",
		"error",
		"error",
		"length",
		"createGdipFont",
		"getChars",
		"StringFormat_Clone",
		"StringFormat_GenericTypographic",
		"StringFormat_SetFormatFlags",
		"StringFormat_GetFormatFlags",
		"Graphics_MeasureString",
		"StringFormat_delete",
		"Font_delete",
		"round",
		"round",
		"GetTextExtentPoint32W",
		"getChars",
		"GetTextExtentPoint32W",
		"textExtent",
		"error",
		"error",
		"createGdipFont",
		"length",
		"getChars",
		"StringFormat_Clone",
		"StringFormat_GenericTypographic",
		"StringFormat_SetFormatFlags",
		"StringFormat_GetFormatFlags",
		"measureSpace",
		"StringFormat_SetTabStops",
		"StringFormat_SetHotkeyPrefix",
		"Graphics_MeasureString",
		"StringFormat_delete",
		"Font_delete",
		"round",
		"round",
		"length",
		"GetTextExtentPoint32W",
		"getCodePage",
		"DrawText",
		"length",
		"isDisposed",
		"internal_new_GC",
		"init",
		"init",
		"GCData",
		"RECT",
		"RECT",
		"LOGFONTW",
		"LOGFONTA",
		"String",
		"LOGPEN",
		"EXTLOGPEN",
		"RECT",
		"Rect",
		"ICONINFO",
		"BITMAP",
		"ICONINFO",
		"BITMAP",
		"BITMAP",
		"BLENDFUNCTION",
		"BITMAP",
		"Rectangle",
		"BITMAP",
		"BITMAPINFOHEADER",
		"PointF",
		"RectF",
		"SIZE",
		"PointF",
		"RectF",
		"TCHAR",
		"RECT",
		"RGB",
		"RGB",
		"PointF",
		"PointF",
		"GRADIENT_RECT",
		"TRIVERTEX",
		"SIZE",
		"TCHAR",
		"TCHAR",
		"TEXTMETRICW",
		"TEXTMETRICA",
		"SIZE",
		"Rect",
		"Rectangle",
		"RECT",
		"Rectangle",
		"POINT",
		"RECT",
		"TEXTMETRICW",
		"TEXTMETRICA",
		"LOGPEN",
		"EXTLOGPEN",
		"LOGPEN",
		"EXTLOGPEN",
		"LOGPEN",
		"EXTLOGPEN",
		"LOGPEN",
		"EXTLOGPEN",
		"POINT",
		"PointF",
		"RectF",
		"POINT",
		"LOGPEN",
		"EXTLOGPEN",
		"LOGBRUSH",
		"PointF",
		"RectF",
		"Point",
		"SIZE",
		"Point",
		"Point",
		"PointF",
		"RectF",
		"Point",
		"SIZE",
		"Point",
		"RECT",
		"TCHAR",
		"Point",
		"GC",
		"GC"
	],
	"methodsBody":{
		"public static GC win32_new(Drawable drawable, GCData data)":{
			"methodBody":"{\n    GC gc = new GC();\n    int hDC = drawable.internal_new_GC(data);\n    gc.init(drawable, data, hDC);\n    return gc;\n}",
			"comments":"/**\n* Invokes platform specific functionality to allocate a new graphics context.\n* <p>\n* <b>IMPORTANT:</b> This method is <em>not</em> part of the public\n* API for <code>GC</code>. It is marked public only so that it\n* can be shared within the packages provided by SWT. It is not\n* available on all platforms, and should never be called from\n* application code.\n* </p>\n*\n* @param drawable the Drawable for the receiver.\n* @param data the data for the receiver.\n*\n* @return a new <code>GC</code>\n*/\n",
			"methodName":"public static GC win32_new(Drawable drawable, GCData data)"
		},
		"public void fillRoundRectangle(int x, int y, int width, int height, int arcWidth, int arcHeight)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (data.gdipGraphics != 0) {\n        initGdip(false, true);\n        fillRoundRectangleGdip(data.gdipGraphics, data.gdipBrush, x, y, width, height, arcWidth, arcHeight);\n        return;\n    }\n    int nullPen = OS.GetStockObject(OS.NULL_PEN);\n    int oldPen = OS.SelectObject(handle, nullPen);\n    OS.RoundRect(handle, x, y, x + width + 1, y + height + 1, arcWidth, arcHeight);\n    OS.SelectObject(handle, oldPen);\n}",
			"comments":"/**\n* Fills the interior of the round-cornered rectangle specified by\n* the arguments, using the receiver's background color.\n*\n* @param x the x coordinate of the rectangle to be filled\n* @param y the y coordinate of the rectangle to be filled\n* @param width the width of the rectangle to be filled\n* @param height the height of the rectangle to be filled\n* @param arcWidth the width of the arc\n* @param arcHeight the height of the arc\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #drawRoundRectangle\n*/\n",
			"methodName":"public void fillRoundRectangle(int x, int y, int width, int height, int arcWidth, int arcHeight)"
		},
		"public void setAntialias(int antialias)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (data.gdipGraphics == 0 && antialias == SWT.DEFAULT)\n        return;\n    int mode = 0;\n    switch(antialias) {\n        case SWT.DEFAULT:\n            mode = Gdip.SmoothingModeDefault;\n            break;\n        case SWT.OFF:\n            mode = Gdip.SmoothingModeNone;\n            break;\n        case SWT.ON:\n            mode = Gdip.SmoothingModeAntiAlias;\n            break;\n        default:\n            SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    }\n    initGdip(false, false);\n    Gdip.Graphics_SetSmoothingMode(data.gdipGraphics, mode);\n}",
			"comments":"/**\n* Sets the receiver's anti-aliasing value to the parameter,\n* which must be one of <code>SWT.DEFAULT</code>, <code>SWT.OFF</code>\n* or <code>SWT.ON</code>. Note that this controls anti-aliasing for all\n* <em>non-text drawing</em> operations.\n*\n* @param antialias the anti-aliasing setting\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the parameter is not one of <code>SWT.DEFAULT</code>,\n*                                 <code>SWT.OFF</code> or <code>SWT.ON</code></li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #setTextAntialias\n*\n* @since 3.1\n*/\n",
			"methodName":"public void setAntialias(int antialias)"
		},
		"int getCodePage()":{
			"methodBody":"{\n    if (OS.IsUnicode)\n        return OS.CP_ACP;\n    int[] lpCs = new int[8];\n    int cs = OS.GetTextCharset(handle);\n    OS.TranslateCharsetInfo(cs, lpCs, OS.TCI_SRCCHARSET);\n    return lpCs[1];\n}",
			"comments":"",
			"methodName":"int getCodePage()"
		},
		"void initGdip(boolean draw, boolean fill)":{
			"methodBody":"{\n    data.device.checkGDIP();\n    int gdipGraphics = data.gdipGraphics;\n    if (gdipGraphics == 0) {\n        \n        int hRgn = OS.CreateRectRgn(0, 0, 0, 0);\n        int result = OS.GetClipRgn(handle, hRgn);\n        POINT pt = new POINT();\n        OS.GetWindowOrgEx(handle, pt);\n        OS.OffsetRgn(hRgn, pt.x, pt.y);\n        OS.SelectClipRgn(handle, 0);\n        gdipGraphics = data.gdipGraphics = Gdip.Graphics_new(handle);\n        if (gdipGraphics == 0)\n            SWT.error(SWT.ERROR_NO_HANDLES);\n        Gdip.Graphics_SetPixelOffsetMode(gdipGraphics, Gdip.PixelOffsetModeHalf);\n        if (result == 1)\n            setClipping(hRgn);\n        OS.DeleteObject(hRgn);\n    }\n    if (draw && data.gdipPen == 0)\n        data.gdipPen = createGdipPen();\n    if (fill && data.gdipBrush == 0)\n        data.gdipBrush = createGdipBrush();\n}",
			"comments":"/*\n* Feature in GDI+. The GDI+ clipping set with Graphics->SetClip()\n* is always intersected with the GDI clipping at the time the\n* GDI+ graphics is created.  This means that the clipping\n* cannot be reset.  The fix is to clear the clipping before\n* the GDI+ graphics is created and reset it afterwards.\n*/\n",
			"methodName":"void initGdip(boolean draw, boolean fill)"
		},
		"public boolean getAdvanced()":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    return data.gdipGraphics != 0;\n}",
			"comments":"/**\n* Returns <code>true</code> if receiver is using the operating system's\n* advanced graphics subsystem.  Otherwise, <code>false</code> is returned\n* to indicate that normal graphics are in use.\n* <p>\n* Advanced graphics may not be installed for the operating system.  In this\n* case, <code>false</code> is always returned.  Some operating system have\n* only one graphics subsystem.  If this subsystem supports advanced graphics,\n* then <code>true</code> is always returned.  If any graphics operation such\n* as alpha, antialias, patterns, interpolation, paths, clipping or transformation\n* has caused the receiver to switch from regular to advanced graphics mode,\n* <code>true</code> is returned.  If the receiver has been explicitly switched\n* to advanced mode and this mode is supported, <code>true</code> is returned.\n* </p>\n*\n* @return the advanced value\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #setAdvanced\n* @since 3.1\n*/\n",
			"methodName":"public boolean getAdvanced()"
		},
		"public void setLineDash(int[] dashes)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (dashes != null && dashes.length > 0) {\n        data.dashes = new int[dashes.length];\n        for (int i = 0; i < dashes.length; i++) {\n            int dash = dashes[i];\n            if (dash <= 0)\n                SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n            data.dashes[i] = dash;\n        }\n    } else {\n        data.dashes = null;\n    }\n    setPen(-1, -1, data.dashes == null ? OS.PS_SOLID : OS.PS_USERSTYLE, -1, -1, data.dashes);\n}",
			"comments":"/**\n* Sets the receiver's line dash style to the argument. The default\n* value is <code>null</code>. If the argument is not <code>null</code>,\n* the receiver's line style is set to <code>SWT.LINE_CUSTOM</code>, otherwise\n* it is set to <code>SWT.LINE_SOLID</code>.\n*\n* @param dashes the dash style to be used for drawing lines\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if any of the values in the array is less than or equal 0</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public void setLineDash(int[] dashes)"
		},
		"public void drawRectangle(Rectangle rect)":{
			"methodBody":"{\n    if (rect == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    drawRectangle(rect.x, rect.y, rect.width, rect.height);\n}",
			"comments":"/**\n* Draws the outline of the specified rectangle, using the receiver's\n* foreground color. The left and right edges of the rectangle are at\n* <code>rect.x</code> and <code>rect.x + rect.width</code>. The top\n* and bottom edges are at <code>rect.y</code> and\n* <code>rect.y + rect.height</code>.\n*\n* @param rect the rectangle to draw\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the rectangle is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void drawRectangle(Rectangle rect)"
		},
		"void drawBitmap(Image srcImage, int srcX, int srcY, int srcWidth, int srcHeight, int destX, int destY, int destWidth, int destHeight, boolean simple)":{
			"methodBody":"{\n    BITMAP bm = new BITMAP();\n    OS.GetObject(srcImage.handle, BITMAP.sizeof, bm);\n    int imgWidth = bm.bmWidth;\n    int imgHeight = bm.bmHeight;\n    if (simple) {\n        srcWidth = destWidth = imgWidth;\n        srcHeight = destHeight = imgHeight;\n    } else {\n        if (srcX + srcWidth > imgWidth || srcY + srcHeight > imgHeight) {\n            SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n        }\n        simple = srcX == 0 && srcY == 0 && srcWidth == destWidth && destWidth == imgWidth && srcHeight == destHeight && destHeight == imgHeight;\n    }\n    boolean mustRestore = false;\n    GC memGC = srcImage.memGC;\n    if (memGC != null && !memGC.isDisposed()) {\n        memGC.flush();\n        mustRestore = true;\n        GCData data = memGC.data;\n        if (data.hNullBitmap != 0) {\n            OS.SelectObject(memGC.handle, data.hNullBitmap);\n            data.hNullBitmap = 0;\n        }\n    }\n    if (srcImage.alpha != -1 || srcImage.alphaData != null) {\n        drawBitmapAlpha(srcImage, srcX, srcY, srcWidth, srcHeight, destX, destY, destWidth, destHeight, simple, bm, imgWidth, imgHeight);\n    } else if (srcImage.transparentPixel != -1) {\n        drawBitmapTransparent(srcImage, srcX, srcY, srcWidth, srcHeight, destX, destY, destWidth, destHeight, simple, bm, imgWidth, imgHeight);\n    } else {\n        drawBitmap(srcImage, srcX, srcY, srcWidth, srcHeight, destX, destY, destWidth, destHeight, simple, bm, imgWidth, imgHeight);\n    }\n    if (mustRestore) {\n        int hOldBitmap = OS.SelectObject(memGC.handle, srcImage.handle);\n        memGC.data.hNullBitmap = hOldBitmap;\n    }\n}",
			"comments":"",
			"methodName":"void drawBitmap(Image srcImage, int srcX, int srcY, int srcWidth, int srcHeight, int destX, int destY, int destWidth, int destHeight, boolean simple)"
		},
		"public boolean getXORMode()":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    int rop2 = 0;\n    if (OS.IsWinCE) {\n        rop2 = OS.SetROP2(handle, OS.R2_COPYPEN);\n        OS.SetROP2(handle, rop2);\n    } else {\n        rop2 = OS.GetROP2(handle);\n    }\n    return rop2 == OS.R2_XORPEN;\n}",
			"comments":"/**\n* Returns <code>true</code> if this GC is drawing in the mode\n* where the resulting color in the destination is the\n* <em>exclusive or</em> of the color values in the source\n* and the destination, and <code>false</code> if it is\n* drawing in the mode where the destination color is being\n* replaced with the source color value.\n*\n* @return <code>true</code> true if the receiver is in XOR mode, and false otherwise\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public boolean getXORMode()"
		},
		"public int getAlpha()":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    return data.alpha;\n}",
			"comments":"/**\n* Returns the receiver's alpha value.\n*\n* @return the alpha value\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public int getAlpha()"
		},
		"public int getInterpolation()":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (data.gdipGraphics == 0)\n        return SWT.DEFAULT;\n    int mode = Gdip.Graphics_GetInterpolationMode(data.gdipGraphics);\n    switch(mode) {\n        case Gdip.InterpolationModeDefault:\n            return SWT.DEFAULT;\n        case Gdip.InterpolationModeNearestNeighbor:\n            return SWT.NONE;\n        case Gdip.InterpolationModeBilinear:\n        case Gdip.InterpolationModeLowQuality:\n            return SWT.LOW;\n        case Gdip.InterpolationModeBicubic:\n        case Gdip.InterpolationModeHighQualityBilinear:\n        case Gdip.InterpolationModeHighQualityBicubic:\n        case Gdip.InterpolationModeHighQuality:\n            return SWT.HIGH;\n    }\n    return SWT.DEFAULT;\n}",
			"comments":"/**\n* Returns the receiver's interpolation setting, which will be one of\n* <code>SWT.DEFAULT</code>, <code>SWT.NONE</code>,\n* <code>SWT.LOW</code> or <code>SWT.HIGH</code>.\n*\n* @return the receiver's interpolation setting\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public int getInterpolation()"
		},
		"public void setLineStyle(int lineStyle)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    int style = -1;\n    switch(lineStyle) {\n        case SWT.LINE_SOLID:\n            style = OS.PS_SOLID;\n            break;\n        case SWT.LINE_DASH:\n            style = OS.PS_DASH;\n            break;\n        case SWT.LINE_DOT:\n            style = OS.PS_DOT;\n            break;\n        case SWT.LINE_DASHDOT:\n            style = OS.PS_DASHDOT;\n            break;\n        case SWT.LINE_DASHDOTDOT:\n            style = OS.PS_DASHDOTDOT;\n            break;\n        case SWT.LINE_CUSTOM:\n            style = data.dashes == null ? OS.PS_SOLID : OS.PS_USERSTYLE;\n            break;\n        default:\n            SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    }\n    OS.SetBkMode(handle, style == OS.PS_SOLID ? OS.OPAQUE : OS.TRANSPARENT);\n    setPen(-1, -1, style, -1, -1, data.dashes);\n}",
			"comments":"/**\n* Sets the receiver's line style to the argument, which must be one\n* of the constants <code>SWT.LINE_SOLID</code>, <code>SWT.LINE_DASH</code>,\n* <code>SWT.LINE_DOT</code>, <code>SWT.LINE_DASHDOT</code> or\n* <code>SWT.LINE_DASHDOTDOT</code>.\n*\n* @param lineStyle the style to be used for drawing lines\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the style is not valid</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void setLineStyle(int lineStyle)"
		},
		"public FontMetrics getFontMetrics()":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    TEXTMETRIC lptm = OS.IsUnicode ? (TEXTMETRIC) new TEXTMETRICW() : new TEXTMETRICA();\n    OS.GetTextMetrics(handle, lptm);\n    return FontMetrics.win32_new(lptm);\n}",
			"comments":"/**\n* Returns a FontMetrics which contains information\n* about the font currently being used by the receiver\n* to draw and measure text.\n*\n* @return font metrics for the receiver's font\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public FontMetrics getFontMetrics()"
		},
		"public void setClipping(int x, int y, int width, int height)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    int hRgn = OS.CreateRectRgn(x, y, x + width, y + height);\n    setClipping(hRgn);\n    OS.DeleteObject(hRgn);\n}",
			"comments":"/**\n* Sets the area of the receiver which can be changed\n* by drawing operations to the rectangular area specified\n* by the arguments.\n*\n* @param x the x coordinate of the clipping rectangle\n* @param y the y coordinate of the clipping rectangle\n* @param width the width of the clipping rectangle\n* @param height the height of the clipping rectangle\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void setClipping(int x, int y, int width, int height)"
		},
		"public void fillPath(Path path)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (path == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (path.handle == 0)\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    initGdip(false, true);\n    int mode = OS.GetPolyFillMode(handle) == OS.WINDING ? Gdip.FillModeWinding : Gdip.FillModeAlternate;\n    Gdip.GraphicsPath_SetFillMode(path.handle, mode);\n    Gdip.Graphics_FillPath(data.gdipGraphics, data.gdipBrush, path.handle);\n}",
			"comments":"/**\n* Fills the path described by the parameter.\n*\n* @param path the path to fill\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the parameter is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the parameter has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see Path\n*\n* @since 3.1\n*/\n",
			"methodName":"public void fillPath(Path path)"
		},
		"public int getStyle()":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    return data.style;\n}",
			"comments":"/**\n* Returns the receiver's style information.\n* <p>\n* Note that the value which is returned by this method <em>may\n* not match</em> the value which was provided to the constructor\n* when the receiver was created. This can occur when the underlying\n* operating system does not support a particular combination of\n* requested styles.\n* </p>\n*\n* @return the style bits\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @since 2.1.2\n*/\n",
			"methodName":"public int getStyle()"
		},
		"public void setFont(Font font)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (font == null) {\n        OS.SelectObject(handle, data.device.systemFont);\n    } else {\n        if (font.isDisposed())\n            SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n        OS.SelectObject(handle, font.handle);\n    }\n}",
			"comments":"/**\n* Sets the font which will be used by the receiver\n* to draw and measure text to the argument. If the\n* argument is null, then a default font appropriate\n* for the platform will be used instead.\n*\n* @param font the new font for the receiver, or null to indicate a default font\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the font has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void setFont(Font font)"
		},
		"void setClipping(int clipRgn)":{
			"methodBody":"{\n    int hRgn = clipRgn;\n    int gdipGraphics = data.gdipGraphics;\n    if (gdipGraphics != 0) {\n        if (hRgn != 0) {\n            int region = Gdip.Region_new(hRgn);\n            Gdip.Graphics_SetClip(gdipGraphics, region, Gdip.CombineModeReplace);\n            Gdip.Region_delete(region);\n        } else {\n            Gdip.Graphics_ResetClip(gdipGraphics);\n        }\n    } else {\n        POINT pt = null;\n        if (hRgn != 0) {\n            pt = new POINT();\n            OS.GetWindowOrgEx(handle, pt);\n            OS.OffsetRgn(hRgn, -pt.x, -pt.y);\n        }\n        OS.SelectClipRgn(handle, hRgn);\n        if (hRgn != 0)\n            OS.OffsetRgn(hRgn, pt.x, pt.y);\n    }\n    if (hRgn != 0 && hRgn != clipRgn) {\n        OS.DeleteObject(hRgn);\n    }\n}",
			"comments":"",
			"methodName":"void setClipping(int clipRgn)"
		},
		"public void getTransform(Transform transform)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (transform == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (transform.isDisposed())\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    int gdipGraphics = data.gdipGraphics;\n    if (gdipGraphics != 0) {\n        Gdip.Graphics_GetTransform(gdipGraphics, transform.handle);\n    } else {\n        transform.setElements(1, 0, 0, 1, 0, 0);\n    }\n}",
			"comments":"/**\n* Sets the parameter to the transform that is currently being\n* used by the receiver.\n*\n* @param transform the destination to copy the transform into\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the parameter is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the parameter has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see Transform\n*\n* @since 3.1\n*/\n",
			"methodName":"public void getTransform(Transform transform)"
		},
		"public void copyArea(Image image, int x, int y)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (image == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (image.type != SWT.BITMAP || image.isDisposed())\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    \n    Device device = data.device;\n    int hDC = device.internal_new_GC(null);\n    \n    Rectangle rect = image.getBounds();\n    int memHdc = OS.CreateCompatibleDC(hDC);\n    int hOldBitmap = OS.SelectObject(memHdc, image.handle);\n    OS.BitBlt(memHdc, 0, 0, rect.width, rect.height, handle, x, y, OS.SRCCOPY);\n    OS.SelectObject(memHdc, hOldBitmap);\n    OS.DeleteDC(memHdc);\n    \n    device.internal_dispose_GC(hDC, null);\n}",
			"comments":"/**\n* Copies a rectangular area of the receiver at the specified\n* position into the image, which must be of type <code>SWT.BITMAP</code>.\n*\n* @param image the image to copy into\n* @param x the x coordinate in the receiver of the area to be copied\n* @param y the y coordinate in the receiver of the area to be copied\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the image is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the image is not a bitmap or has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n/* Get the HDC for the device */\n/* Copy the bitmap area */\n/* Release the HDC for the device */\n",
			"methodName":"public void copyArea(Image image, int x, int y)"
		},
		"public void copyArea(int srcX, int srcY, int width, int height, int destX, int destY)":{
			"methodBody":"{\n    copyArea(srcX, srcY, width, height, destX, destY, true);\n}",
			"comments":"/**\n* Copies a rectangular area of the receiver at the source\n* position onto the receiver at the destination position.\n*\n* @param srcX the x coordinate in the receiver of the area to be copied\n* @param srcY the y coordinate in the receiver of the area to be copied\n* @param width the width of the area to copy\n* @param height the height of the area to copy\n* @param destX the x coordinate in the receiver of the area to copy to\n* @param destY the y coordinate in the receiver of the area to copy to\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void copyArea(int srcX, int srcY, int width, int height, int destX, int destY)"
		},
		"void drawBitmapMask(Image srcImage, int srcColor, int srcMask, int srcX, int srcY, int srcWidth, int srcHeight, int destX, int destY, int destWidth, int destHeight, boolean simple, int imgWidth, int imgHeight, boolean offscreen)":{
			"methodBody":"{\n    int srcColorY = srcY;\n    if (srcColor == 0) {\n        srcColor = srcMask;\n        srcColorY += imgHeight;\n    }\n    int srcHdc = OS.CreateCompatibleDC(handle);\n    int oldSrcBitmap = OS.SelectObject(srcHdc, srcColor);\n    int destHdc = handle, x = destX, y = destY;\n    int tempHdc = 0, tempBitmap = 0, oldTempBitmap = 0;\n    int oldBkColor = 0, oldTextColor = 0;\n    if (offscreen) {\n        tempHdc = OS.CreateCompatibleDC(handle);\n        tempBitmap = OS.CreateCompatibleBitmap(handle, destWidth, destHeight);\n        oldTempBitmap = OS.SelectObject(tempHdc, tempBitmap);\n        OS.BitBlt(tempHdc, 0, 0, destWidth, destHeight, handle, destX, destY, OS.SRCCOPY);\n        destHdc = tempHdc;\n        x = y = 0;\n    } else {\n        oldBkColor = OS.SetBkColor(handle, 0xFFFFFF);\n        oldTextColor = OS.SetTextColor(handle, 0);\n    }\n    if (!simple && (srcWidth != destWidth || srcHeight != destHeight)) {\n        int mode = 0;\n        if (!OS.IsWinCE)\n            mode = OS.SetStretchBltMode(handle, OS.COLORONCOLOR);\n        OS.StretchBlt(destHdc, x, y, destWidth, destHeight, srcHdc, srcX, srcColorY, srcWidth, srcHeight, OS.SRCINVERT);\n        OS.SelectObject(srcHdc, srcMask);\n        OS.StretchBlt(destHdc, x, y, destWidth, destHeight, srcHdc, srcX, srcY, srcWidth, srcHeight, OS.SRCAND);\n        OS.SelectObject(srcHdc, srcColor);\n        OS.StretchBlt(destHdc, x, y, destWidth, destHeight, srcHdc, srcX, srcColorY, srcWidth, srcHeight, OS.SRCINVERT);\n        if (!OS.IsWinCE)\n            OS.SetStretchBltMode(handle, mode);\n    } else {\n        OS.BitBlt(destHdc, x, y, destWidth, destHeight, srcHdc, srcX, srcColorY, OS.SRCINVERT);\n        OS.SetTextColor(destHdc, 0);\n        OS.SelectObject(srcHdc, srcMask);\n        OS.BitBlt(destHdc, x, y, destWidth, destHeight, srcHdc, srcX, srcY, OS.SRCAND);\n        OS.SelectObject(srcHdc, srcColor);\n        OS.BitBlt(destHdc, x, y, destWidth, destHeight, srcHdc, srcX, srcColorY, OS.SRCINVERT);\n    }\n    if (offscreen) {\n        OS.BitBlt(handle, destX, destY, destWidth, destHeight, tempHdc, 0, 0, OS.SRCCOPY);\n        OS.SelectObject(tempHdc, oldTempBitmap);\n        OS.DeleteDC(tempHdc);\n        OS.DeleteObject(tempBitmap);\n    } else {\n        OS.SetBkColor(handle, oldBkColor);\n        OS.SetTextColor(handle, oldTextColor);\n    }\n    OS.SelectObject(srcHdc, oldSrcBitmap);\n    OS.DeleteDC(srcHdc);\n}",
			"comments":"",
			"methodName":"void drawBitmapMask(Image srcImage, int srcColor, int srcMask, int srcX, int srcY, int srcWidth, int srcHeight, int destX, int destY, int destWidth, int destHeight, boolean simple, int imgWidth, int imgHeight, boolean offscreen)"
		},
		"public void drawText(String string, int x, int y, int flags)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (string == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (string.length() == 0)\n        return;\n    if (data.gdipGraphics != 0) {\n        initGdip(true, (flags & SWT.DRAW_TRANSPARENT) == 0);\n        int length = string.length();\n        char[] buffer = new char[length];\n        string.getChars(0, length, buffer, 0);\n        int font = createGdipFont();\n        PointF pt = new PointF();\n        pt.X = x;\n        pt.Y = y;\n        int brush = Gdip.Pen_GetBrush(data.gdipPen);\n        int format = Gdip.StringFormat_Clone(Gdip.StringFormat_GenericTypographic());\n        Gdip.StringFormat_SetFormatFlags(format, Gdip.StringFormat_GetFormatFlags(format) | Gdip.StringFormatFlagsMeasureTrailingSpaces);\n        float[] tabs = (flags & SWT.DRAW_TAB) != 0 ? new float[] { measureSpace(font, format) * 8 } : new float[1];\n        Gdip.StringFormat_SetTabStops(format, 0, tabs.length, tabs);\n        Gdip.StringFormat_SetHotkeyPrefix(format, (flags & SWT.DRAW_MNEMONIC) != 0 ? Gdip.HotkeyPrefixShow : Gdip.HotkeyPrefixNone);\n        if ((flags & SWT.DRAW_TRANSPARENT) == 0) {\n            RectF bounds = new RectF();\n            Gdip.Graphics_MeasureString(data.gdipGraphics, buffer, length, font, pt, format, bounds);\n            Gdip.Graphics_FillRectangle(data.gdipGraphics, data.gdipBrush, (int) bounds.X, (int) bounds.Y, Math.round(bounds.Width), Math.round(bounds.Height));\n        }\n        Gdip.Graphics_DrawString(data.gdipGraphics, buffer, length, font, pt, format, brush);\n        Gdip.StringFormat_delete(format);\n        Gdip.Font_delete(font);\n        return;\n    }\n    TCHAR buffer = new TCHAR(getCodePage(), string, false);\n    int length = buffer.length();\n    if (length == 0)\n        return;\n    RECT rect = new RECT();\n    \n    int limit = OS.IsWin95 ? 0x7FFF : 0x6FFFFFF;\n    OS.SetRect(rect, x, y, limit, limit);\n    int uFormat = OS.DT_LEFT;\n    if ((flags & SWT.DRAW_DELIMITER) == 0)\n        uFormat |= OS.DT_SINGLELINE;\n    if ((flags & SWT.DRAW_TAB) != 0)\n        uFormat |= OS.DT_EXPANDTABS;\n    if ((flags & SWT.DRAW_MNEMONIC) == 0)\n        uFormat |= OS.DT_NOPREFIX;\n    int rop2 = 0;\n    if (OS.IsWinCE) {\n        rop2 = OS.SetROP2(handle, OS.R2_COPYPEN);\n        OS.SetROP2(handle, rop2);\n    } else {\n        rop2 = OS.GetROP2(handle);\n    }\n    int oldBkMode = OS.SetBkMode(handle, (flags & SWT.DRAW_TRANSPARENT) != 0 ? OS.TRANSPARENT : OS.OPAQUE);\n    if (rop2 != OS.R2_XORPEN) {\n        OS.DrawText(handle, buffer, length, rect, uFormat);\n    } else {\n        int foreground = OS.GetTextColor(handle);\n        if ((flags & SWT.DRAW_TRANSPARENT) != 0) {\n            OS.DrawText(handle, buffer, buffer.length(), rect, uFormat | OS.DT_CALCRECT);\n            int width = rect.right - rect.left;\n            int height = rect.bottom - rect.top;\n            int hBitmap = OS.CreateCompatibleBitmap(handle, width, height);\n            if (hBitmap == 0)\n                SWT.error(SWT.ERROR_NO_HANDLES);\n            int memDC = OS.CreateCompatibleDC(handle);\n            int hOldBitmap = OS.SelectObject(memDC, hBitmap);\n            OS.PatBlt(memDC, 0, 0, width, height, OS.BLACKNESS);\n            OS.SetBkMode(memDC, OS.TRANSPARENT);\n            OS.SetTextColor(memDC, foreground);\n            OS.SelectObject(memDC, OS.GetCurrentObject(handle, OS.OBJ_FONT));\n            OS.SetRect(rect, 0, 0, 0x7FFF, 0x7FFF);\n            OS.DrawText(memDC, buffer, length, rect, uFormat);\n            OS.BitBlt(handle, x, y, width, height, memDC, 0, 0, OS.SRCINVERT);\n            OS.SelectObject(memDC, hOldBitmap);\n            OS.DeleteDC(memDC);\n            OS.DeleteObject(hBitmap);\n        } else {\n            int background = OS.GetBkColor(handle);\n            OS.SetTextColor(handle, foreground ^ background);\n            OS.DrawText(handle, buffer, length, rect, uFormat);\n            OS.SetTextColor(handle, foreground);\n        }\n    }\n    OS.SetBkMode(handle, oldBkMode);\n}",
			"comments":"/**\n* Draws the given string, using the receiver's current font and\n* foreground color. Tab expansion, line delimiter and mnemonic\n* processing are performed according to the specified flags. If\n* <code>flags</code> includes <code>DRAW_TRANSPARENT</code>,\n* then the background of the rectangular area where the text is being\n* drawn will not be modified, otherwise it will be filled with the\n* receiver's background color.\n* <p>\n* The parameter <code>flags</code> may be a combination of:\n* <dl>\n* <dt><b>DRAW_DELIMITER</b></dt>\n* <dd>draw multiple lines</dd>\n* <dt><b>DRAW_TAB</b></dt>\n* <dd>expand tabs</dd>\n* <dt><b>DRAW_MNEMONIC</b></dt>\n* <dd>underline the mnemonic character</dd>\n* <dt><b>DRAW_TRANSPARENT</b></dt>\n* <dd>transparent background</dd>\n* </dl>\n* </p>\n*\n* @param string the string to be drawn\n* @param x the x coordinate of the top left corner of the rectangular area where the text is to be drawn\n* @param y the y coordinate of the top left corner of the rectangular area where the text is to be drawn\n* @param flags the flags specifing how to process the text\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the string is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n/*\n* Feature in Windows.  For some reason DrawText(), the maximum\n* value for the bottom and right coordinates for the RECT that\n* is used to position the text is different on between Windows\n* versions.  If this value is larger than the maximum, nothing\n* is drawn.  On Windows 98, the limit is 0x7FFF.  On Windows CE,\n* NT, and 2000 it is 0x6FFFFFF. And on XP, it is 0x7FFFFFFF.\n* The fix is to use the the smaller limit for Windows 98 and the\n* larger limit on the other Windows platforms.\n*/\n",
			"methodName":"public void drawText(String string, int x, int y, int flags)"
		},
		"public void setClipping(Path path)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (path != null && path.isDisposed())\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    setClipping(0);\n    if (path != null) {\n        initGdip(false, false);\n        int mode = OS.GetPolyFillMode(handle) == OS.WINDING ? Gdip.FillModeWinding : Gdip.FillModeAlternate;\n        Gdip.GraphicsPath_SetFillMode(path.handle, mode);\n        Gdip.Graphics_SetClip(data.gdipGraphics, path.handle);\n    }\n}",
			"comments":"/**\n* Sets the area of the receiver which can be changed\n* by drawing operations to the path specified\n* by the argument.\n*\n* @param path the clipping path.\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the path has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see Path\n*\n* @since 3.1\n*/\n",
			"methodName":"public void setClipping(Path path)"
		},
		"public void setFillRule(int rule)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (OS.IsWinCE)\n        return;\n    int mode = OS.ALTERNATE;\n    switch(rule) {\n        case SWT.FILL_WINDING:\n            mode = OS.WINDING;\n            break;\n        case SWT.FILL_EVEN_ODD:\n            mode = OS.ALTERNATE;\n            break;\n        default:\n            SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    }\n    OS.SetPolyFillMode(handle, mode);\n}",
			"comments":"/**\n* Sets the receiver's fill rule to the parameter, which must be one of\n* <code>SWT.FILL_EVEN_ODD</code> or <code>SWT.FILL_WINDING</code>.\n*\n* @param rule the new fill rule\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the rule is not one of <code>SWT.FILL_EVEN_ODD</code>\n*                                 or <code>SWT.FILL_WINDING</code></li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public void setFillRule(int rule)"
		},
		"void destroyGdipBrush(int brush)":{
			"methodBody":"{\n    int type = Gdip.Brush_GetType(brush);\n    switch(type) {\n        case Gdip.BrushTypeSolidColor:\n            Gdip.SolidBrush_delete(brush);\n            break;\n        case Gdip.BrushTypeHatchFill:\n            Gdip.HatchBrush_delete(brush);\n            break;\n        case Gdip.BrushTypeLinearGradient:\n            Gdip.LinearGradientBrush_delete(brush);\n            break;\n        case Gdip.BrushTypeTextureFill:\n            Gdip.TextureBrush_delete(brush);\n            break;\n    }\n}",
			"comments":"",
			"methodName":"void destroyGdipBrush(int brush)"
		},
		"public Color getForeground()":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    int color = OS.GetTextColor(handle);\n    if (color == OS.CLR_INVALID) {\n        color = OS.GetSysColor(OS.COLOR_WINDOWTEXT);\n    }\n    return Color.win32_new(data.device, color);\n}",
			"comments":"/**\n* Returns the receiver's foreground color.\n*\n* @return the color used for drawing foreground things\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public Color getForeground()"
		},
		"void drawBitmapTransparentByClipping(int srcHdc, int maskHdc, int srcX, int srcY, int srcWidth, int srcHeight, int destX, int destY, int destWidth, int destHeight, boolean simple, int imgWidth, int imgHeight)":{
			"methodBody":"{\n    \n    int rgn = OS.CreateRectRgn(0, 0, 0, 0);\n    for (int y = 0; y < imgHeight; y++) {\n        for (int x = 0; x < imgWidth; x++) {\n            if (OS.GetPixel(maskHdc, x, y) == 0) {\n                int tempRgn = OS.CreateRectRgn(x, y, x + 1, y + 1);\n                OS.CombineRgn(rgn, rgn, tempRgn, OS.RGN_OR);\n                OS.DeleteObject(tempRgn);\n            }\n        }\n    }\n    \n    if (destWidth != srcWidth || destHeight != srcHeight) {\n        int nBytes = OS.GetRegionData(rgn, 0, null);\n        int[] lpRgnData = new int[nBytes / 4];\n        OS.GetRegionData(rgn, nBytes, lpRgnData);\n        float[] lpXform = new float[] { (float) destWidth / srcWidth, 0, 0, (float) destHeight / srcHeight, 0, 0 };\n        int tmpRgn = OS.ExtCreateRegion(lpXform, nBytes, lpRgnData);\n        OS.DeleteObject(rgn);\n        rgn = tmpRgn;\n    }\n    OS.OffsetRgn(rgn, destX, destY);\n    int clip = OS.CreateRectRgn(0, 0, 0, 0);\n    int result = OS.GetClipRgn(handle, clip);\n    if (result == 1)\n        OS.CombineRgn(rgn, rgn, clip, OS.RGN_AND);\n    OS.SelectClipRgn(handle, rgn);\n    int rop2 = 0;\n    if (!OS.IsWinCE) {\n        rop2 = OS.GetROP2(handle);\n    } else {\n        rop2 = OS.SetROP2(handle, OS.R2_COPYPEN);\n        OS.SetROP2(handle, rop2);\n    }\n    int dwRop = rop2 == OS.R2_XORPEN ? OS.SRCINVERT : OS.SRCCOPY;\n    if (!simple && (srcWidth != destWidth || srcHeight != destHeight)) {\n        int mode = 0;\n        if (!OS.IsWinCE)\n            mode = OS.SetStretchBltMode(handle, OS.COLORONCOLOR);\n        OS.StretchBlt(handle, destX, destY, destWidth, destHeight, srcHdc, srcX, srcY, srcWidth, srcHeight, dwRop);\n        if (!OS.IsWinCE)\n            OS.SetStretchBltMode(handle, mode);\n    } else {\n        OS.BitBlt(handle, destX, destY, destWidth, destHeight, srcHdc, srcX, srcY, dwRop);\n    }\n    OS.SelectClipRgn(handle, result == 1 ? clip : 0);\n    OS.DeleteObject(clip);\n    OS.DeleteObject(rgn);\n}",
			"comments":"/* Create a clipping region from the mask */\n/* Stretch the clipping mask if needed */\n",
			"methodName":"void drawBitmapTransparentByClipping(int srcHdc, int maskHdc, int srcX, int srcY, int srcWidth, int srcHeight, int destX, int destY, int destWidth, int destHeight, boolean simple, int imgWidth, int imgHeight)"
		},
		"void drawBitmapTransparent(Image srcImage, int srcX, int srcY, int srcWidth, int srcHeight, int destX, int destY, int destWidth, int destHeight, boolean simple, BITMAP bm, int imgWidth, int imgHeight)":{
			"methodBody":"{\n    \n    int transBlue = 0, transGreen = 0, transRed = 0;\n    boolean isDib = bm.bmBits != 0;\n    int hBitmap = srcImage.handle;\n    int srcHdc = OS.CreateCompatibleDC(handle);\n    int oldSrcBitmap = OS.SelectObject(srcHdc, hBitmap);\n    byte[] originalColors = null;\n    if (bm.bmBitsPixel <= 8) {\n        if (isDib) {\n            \n            if (OS.IsWinCE) {\n                byte[] pBits = new byte[1];\n                OS.MoveMemory(pBits, bm.bmBits, 1);\n                byte oldValue = pBits[0];\n                int mask = (0xFF << (8 - bm.bmBitsPixel)) & 0x00FF;\n                pBits[0] = (byte) ((srcImage.transparentPixel << (8 - bm.bmBitsPixel)) | (pBits[0] & ~mask));\n                OS.MoveMemory(bm.bmBits, pBits, 1);\n                int color = OS.GetPixel(srcHdc, 0, 0);\n                pBits[0] = oldValue;\n                OS.MoveMemory(bm.bmBits, pBits, 1);\n                transBlue = (color & 0xFF0000) >> 16;\n                transGreen = (color & 0xFF00) >> 8;\n                transRed = color & 0xFF;\n            } else {\n                int maxColors = 1 << bm.bmBitsPixel;\n                byte[] oldColors = new byte[maxColors * 4];\n                OS.GetDIBColorTable(srcHdc, 0, maxColors, oldColors);\n                int offset = srcImage.transparentPixel * 4;\n                boolean fixPalette = false;\n                for (int i = 0; i < oldColors.length; i += 4) {\n                    if (i != offset) {\n                        if (oldColors[offset] == oldColors[i] && oldColors[offset + 1] == oldColors[i + 1] && oldColors[offset + 2] == oldColors[i + 2]) {\n                            fixPalette = true;\n                            break;\n                        }\n                    }\n                }\n                if (fixPalette) {\n                    byte[] newColors = new byte[oldColors.length];\n                    transRed = transGreen = transBlue = 0xff;\n                    newColors[offset] = (byte) transBlue;\n                    newColors[offset + 1] = (byte) transGreen;\n                    newColors[offset + 2] = (byte) transRed;\n                    OS.SetDIBColorTable(srcHdc, 0, maxColors, newColors);\n                    originalColors = oldColors;\n                } else {\n                    transBlue = oldColors[offset] & 0xFF;\n                    transGreen = oldColors[offset + 1] & 0xFF;\n                    transRed = oldColors[offset + 2] & 0xFF;\n                }\n            }\n        } else {\n            \n            int numColors = 1 << bm.bmBitsPixel;\n            \n            BITMAPINFOHEADER bmiHeader = new BITMAPINFOHEADER();\n            bmiHeader.biSize = BITMAPINFOHEADER.sizeof;\n            bmiHeader.biPlanes = bm.bmPlanes;\n            bmiHeader.biBitCount = bm.bmBitsPixel;\n            byte[] bmi = new byte[BITMAPINFOHEADER.sizeof + numColors * 4];\n            OS.MoveMemory(bmi, bmiHeader, BITMAPINFOHEADER.sizeof);\n            if (OS.IsWinCE)\n                SWT.error(SWT.ERROR_NOT_IMPLEMENTED);\n            OS.GetDIBits(srcHdc, srcImage.handle, 0, 0, 0, bmi, OS.DIB_RGB_COLORS);\n            int offset = BITMAPINFOHEADER.sizeof + 4 * srcImage.transparentPixel;\n            transRed = bmi[offset + 2] & 0xFF;\n            transGreen = bmi[offset + 1] & 0xFF;\n            transBlue = bmi[offset] & 0xFF;\n        }\n    } else {\n        \n        int pixel = srcImage.transparentPixel;\n        switch(bm.bmBitsPixel) {\n            case 16:\n                transBlue = (pixel & 0x1F) << 3;\n                transGreen = (pixel & 0x3E0) >> 2;\n                transRed = (pixel & 0x7C00) >> 7;\n                break;\n            case 24:\n                transBlue = (pixel & 0xFF0000) >> 16;\n                transGreen = (pixel & 0xFF00) >> 8;\n                transRed = pixel & 0xFF;\n                break;\n            case 32:\n                transBlue = (pixel & 0xFF000000) >>> 24;\n                transGreen = (pixel & 0xFF0000) >> 16;\n                transRed = (pixel & 0xFF00) >> 8;\n                break;\n        }\n    }\n    int transparentColor = transBlue << 16 | transGreen << 8 | transRed;\n    if (OS.IsWinCE) {\n        \n        OS.TransparentImage(handle, destX, destY, destWidth, destHeight, srcHdc, srcX, srcY, srcWidth, srcHeight, transparentColor);\n    } else if (originalColors == null && OS.IsWinNT && OS.WIN32_VERSION >= OS.VERSION(4, 10)) {\n        int mode = OS.SetStretchBltMode(handle, OS.COLORONCOLOR);\n        OS.TransparentBlt(handle, destX, destY, destWidth, destHeight, srcHdc, srcX, srcY, srcWidth, srcHeight, transparentColor);\n        OS.SetStretchBltMode(handle, mode);\n    } else {\n        \n        int maskHdc = OS.CreateCompatibleDC(handle);\n        int maskBitmap = OS.CreateBitmap(imgWidth, imgHeight, 1, 1, null);\n        int oldMaskBitmap = OS.SelectObject(maskHdc, maskBitmap);\n        OS.SetBkColor(srcHdc, transparentColor);\n        OS.BitBlt(maskHdc, 0, 0, imgWidth, imgHeight, srcHdc, 0, 0, OS.SRCCOPY);\n        if (originalColors != null)\n            OS.SetDIBColorTable(srcHdc, 0, 1 << bm.bmBitsPixel, originalColors);\n        if (OS.GetDeviceCaps(handle, OS.TECHNOLOGY) == OS.DT_RASPRINTER) {\n            \n            drawBitmapTransparentByClipping(srcHdc, maskHdc, srcX, srcY, srcWidth, srcHeight, destX, destY, destWidth, destHeight, simple, imgWidth, imgHeight);\n        } else {\n            \n            int tempHdc = OS.CreateCompatibleDC(handle);\n            int tempBitmap = OS.CreateCompatibleBitmap(handle, destWidth, destHeight);\n            int oldTempBitmap = OS.SelectObject(tempHdc, tempBitmap);\n            OS.BitBlt(tempHdc, 0, 0, destWidth, destHeight, handle, destX, destY, OS.SRCCOPY);\n            if (!simple && (srcWidth != destWidth || srcHeight != destHeight)) {\n                if (!OS.IsWinCE)\n                    OS.SetStretchBltMode(tempHdc, OS.COLORONCOLOR);\n                OS.StretchBlt(tempHdc, 0, 0, destWidth, destHeight, srcHdc, srcX, srcY, srcWidth, srcHeight, OS.SRCINVERT);\n                OS.StretchBlt(tempHdc, 0, 0, destWidth, destHeight, maskHdc, srcX, srcY, srcWidth, srcHeight, OS.SRCAND);\n                OS.StretchBlt(tempHdc, 0, 0, destWidth, destHeight, srcHdc, srcX, srcY, srcWidth, srcHeight, OS.SRCINVERT);\n            } else {\n                OS.BitBlt(tempHdc, 0, 0, destWidth, destHeight, srcHdc, srcX, srcY, OS.SRCINVERT);\n                OS.BitBlt(tempHdc, 0, 0, destWidth, destHeight, maskHdc, srcX, srcY, OS.SRCAND);\n                OS.BitBlt(tempHdc, 0, 0, destWidth, destHeight, srcHdc, srcX, srcY, OS.SRCINVERT);\n            }\n            OS.BitBlt(handle, destX, destY, destWidth, destHeight, tempHdc, 0, 0, OS.SRCCOPY);\n            OS.SelectObject(tempHdc, oldTempBitmap);\n            OS.DeleteDC(tempHdc);\n            OS.DeleteObject(tempBitmap);\n        }\n        OS.SelectObject(maskHdc, oldMaskBitmap);\n        OS.DeleteDC(maskHdc);\n        OS.DeleteObject(maskBitmap);\n    }\n    OS.SelectObject(srcHdc, oldSrcBitmap);\n    if (hBitmap != srcImage.handle)\n        OS.DeleteObject(hBitmap);\n    OS.DeleteDC(srcHdc);\n}",
			"comments":"/* Find the RGB values for the transparent pixel. */\n/* Palette-based DIBSECTION */\n/* Palette-based bitmap */\n/* Set the few fields necessary to get the RGB data out */\n/* Direct color image */\n/*\n* Note in WinCE. TransparentImage uses the first entry of a palette\n* based image when there are multiple entries that have the same\n* transparent color.\n*/\n/* Create the mask for the source image */\n/* Most printers do not support BitBlt(), draw the source bitmap transparently using clipping */\n/* Draw the source bitmap transparently using invert/and mask/invert */\n",
			"methodName":"void drawBitmapTransparent(Image srcImage, int srcX, int srcY, int srcWidth, int srcHeight, int destX, int destY, int destWidth, int destHeight, boolean simple, BITMAP bm, int imgWidth, int imgHeight)"
		},
		"void fillRoundRectangleGdip(int gdipGraphics, int brush, int x, int y, int width, int height, int arcWidth, int arcHeight)":{
			"methodBody":"{\n    int nx = x;\n    int ny = y;\n    int nw = width;\n    int nh = height;\n    int naw = arcWidth;\n    int nah = arcHeight;\n    if (nw < 0) {\n        nw = 0 - nw;\n        nx = nx - nw;\n    }\n    if (nh < 0) {\n        nh = 0 - nh;\n        ny = ny - nh;\n    }\n    if (naw < 0)\n        naw = 0 - naw;\n    if (nah < 0)\n        nah = 0 - nah;\n    int naw2 = naw / 2;\n    int nah2 = nah / 2;\n    if (nw > naw) {\n        if (nh > nah) {\n            Gdip.Graphics_FillPie(gdipGraphics, brush, nx, ny, naw, nah, -90, -90);\n            Gdip.Graphics_FillRectangle(gdipGraphics, brush, nx + naw2, ny, nw - naw2 * 2, nah2);\n            Gdip.Graphics_FillPie(gdipGraphics, brush, nx + nw - naw, ny, naw, nah, 0, -90);\n            Gdip.Graphics_FillRectangle(gdipGraphics, brush, nx, ny + nah2, nw, nh - nah2 * 2);\n            Gdip.Graphics_FillPie(gdipGraphics, brush, nx + nw - naw, ny + nh - nah, naw, nah, -270, -90);\n            Gdip.Graphics_FillRectangle(gdipGraphics, brush, nx + naw2, ny + nh - nah2, nw - naw2 * 2, nah2);\n            Gdip.Graphics_FillPie(gdipGraphics, brush, nx, ny + nh - nah, naw, nah, -180, -90);\n        } else {\n            Gdip.Graphics_FillPie(gdipGraphics, brush, nx, ny, naw, nh, -90, -180);\n            Gdip.Graphics_FillRectangle(gdipGraphics, brush, nx + naw2, ny, nw - naw2 * 2, nh);\n            Gdip.Graphics_FillPie(gdipGraphics, brush, nx + nw - naw, ny, naw, nh, -270, -180);\n        }\n    } else {\n        if (nh > nah) {\n            Gdip.Graphics_FillPie(gdipGraphics, brush, nx, ny, nw, nah, 0, -180);\n            Gdip.Graphics_FillRectangle(gdipGraphics, brush, nx, ny + nah2, nw, nh - nah2 * 2);\n            Gdip.Graphics_FillPie(gdipGraphics, brush, nx, ny + nh - nah, nw, nah, -180, -180);\n        } else {\n            Gdip.Graphics_FillPie(gdipGraphics, brush, nx, ny, nw, nh, 0, 360);\n        }\n    }\n}",
			"comments":"",
			"methodName":"void fillRoundRectangleGdip(int gdipGraphics, int brush, int x, int y, int width, int height, int arcWidth, int arcHeight)"
		},
		"public int getLineStyle()":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    int style, size;\n    int hPen = OS.GetCurrentObject(handle, OS.OBJ_PEN);\n    if ((size = OS.GetObject(hPen, 0, (LOGPEN) null)) == LOGPEN.sizeof) {\n        LOGPEN logPen = new LOGPEN();\n        OS.GetObject(hPen, LOGPEN.sizeof, logPen);\n        style = logPen.lopnStyle;\n    } else {\n        EXTLOGPEN logPen = new EXTLOGPEN();\n        if (size <= EXTLOGPEN.sizeof) {\n            OS.GetObject(hPen, size, logPen);\n        } else {\n            int hHeap = OS.GetProcessHeap();\n            int ptr = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, size);\n            OS.GetObject(hPen, size, ptr);\n            OS.MoveMemory(logPen, ptr, EXTLOGPEN.sizeof);\n            OS.HeapFree(hHeap, 0, ptr);\n        }\n        style = logPen.elpPenStyle & OS.PS_STYLE_MASK;\n    }\n    switch(style) {\n        case OS.PS_SOLID:\n            return SWT.LINE_SOLID;\n        case OS.PS_DASH:\n            return SWT.LINE_DASH;\n        case OS.PS_DOT:\n            return SWT.LINE_DOT;\n        case OS.PS_DASHDOT:\n            return SWT.LINE_DASHDOT;\n        case OS.PS_DASHDOTDOT:\n            return SWT.LINE_DASHDOTDOT;\n        case OS.PS_USERSTYLE:\n            return SWT.LINE_CUSTOM;\n        default:\n            return SWT.LINE_SOLID;\n    }\n}",
			"comments":"/**\n* Returns the receiver's line style, which will be one\n* of the constants <code>SWT.LINE_SOLID</code>, <code>SWT.LINE_DASH</code>,\n* <code>SWT.LINE_DOT</code>, <code>SWT.LINE_DASHDOT</code> or\n* <code>SWT.LINE_DASHDOTDOT</code>.\n*\n* @return the style used for drawing lines\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public int getLineStyle()"
		},
		"public boolean equals(Object object)":{
			"methodBody":"{\n    return (object == this) || ((object instanceof GC) && (handle == ((GC) object).handle));\n}",
			"comments":"/**\n* Compares the argument to the receiver, and returns true\n* if they represent the <em>same</em> object using a class\n* specific comparison.\n*\n* @param object the object to compare with this object\n* @return <code>true</code> if the object is the same as this object and <code>false</code> otherwise\n*\n* @see #hashCode\n*/\n",
			"methodName":"public boolean equals(Object object)"
		},
		"public Color getBackground()":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    int color = OS.GetBkColor(handle);\n    if (color == OS.CLR_INVALID) {\n        color = OS.GetSysColor(OS.COLOR_WINDOW);\n    }\n    return Color.win32_new(data.device, color);\n}",
			"comments":"/**\n* Returns the background color.\n*\n* @return the receiver's background color\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public Color getBackground()"
		},
		"void drawBitmap(Image srcImage, int srcX, int srcY, int srcWidth, int srcHeight, int destX, int destY, int destWidth, int destHeight, boolean simple, BITMAP bm, int imgWidth, int imgHeight)":{
			"methodBody":"{\n    int srcHdc = OS.CreateCompatibleDC(handle);\n    int oldSrcBitmap = OS.SelectObject(srcHdc, srcImage.handle);\n    int rop2 = 0;\n    if (!OS.IsWinCE) {\n        rop2 = OS.GetROP2(handle);\n    } else {\n        rop2 = OS.SetROP2(handle, OS.R2_COPYPEN);\n        OS.SetROP2(handle, rop2);\n    }\n    int dwRop = rop2 == OS.R2_XORPEN ? OS.SRCINVERT : OS.SRCCOPY;\n    if (!simple && (srcWidth != destWidth || srcHeight != destHeight)) {\n        int mode = 0;\n        if (!OS.IsWinCE)\n            mode = OS.SetStretchBltMode(handle, OS.COLORONCOLOR);\n        OS.StretchBlt(handle, destX, destY, destWidth, destHeight, srcHdc, srcX, srcY, srcWidth, srcHeight, dwRop);\n        if (!OS.IsWinCE)\n            OS.SetStretchBltMode(handle, mode);\n    } else {\n        OS.BitBlt(handle, destX, destY, destWidth, destHeight, srcHdc, srcX, srcY, dwRop);\n    }\n    OS.SelectObject(srcHdc, oldSrcBitmap);\n    OS.DeleteDC(srcHdc);\n}",
			"comments":"",
			"methodName":"void drawBitmap(Image srcImage, int srcX, int srcY, int srcWidth, int srcHeight, int destX, int destY, int destWidth, int destHeight, boolean simple, BITMAP bm, int imgWidth, int imgHeight)"
		},
		"public String toString()":{
			"methodBody":"{\n    if (isDisposed())\n        return \"GC {*DISPOSED*}\";\n    return \"GC {\" + handle + \"}\";\n}",
			"comments":"/**\n* Returns a string containing a concise, human-readable\n* description of the receiver.\n*\n* @return a string representation of the receiver\n*/\n",
			"methodName":"public String toString()"
		},
		"public static GC win32_new(int hDC, GCData data)":{
			"methodBody":"{\n    GC gc = new GC();\n    gc.init(null, data, hDC);\n    return gc;\n}",
			"comments":"/**\n* Invokes platform specific functionality to wrap a graphics context.\n* <p>\n* <b>IMPORTANT:</b> This method is <em>not</em> part of the public\n* API for <code>GC</code>. It is marked public only so that it\n* can be shared within the packages provided by SWT. It is not\n* available on all platforms, and should never be called from\n* application code.\n* </p>\n*\n* @param hDC the Windows HDC.\n* @param data the data for the receiver.\n*\n* @return a new <code>GC</code>\n*/\n",
			"methodName":"public static GC win32_new(int hDC, GCData data)"
		},
		"public void fillGradientRectangle(int x, int y, int width, int height, boolean vertical)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (width == 0 || height == 0)\n        return;\n    int fromColor = OS.GetTextColor(handle);\n    if (fromColor == OS.CLR_INVALID) {\n        fromColor = OS.GetSysColor(OS.COLOR_WINDOWTEXT);\n    }\n    int toColor = OS.GetBkColor(handle);\n    if (toColor == OS.CLR_INVALID) {\n        toColor = OS.GetSysColor(OS.COLOR_WINDOW);\n    }\n    boolean swapColors = false;\n    if (width < 0) {\n        x += width;\n        width = -width;\n        if (!vertical)\n            swapColors = true;\n    }\n    if (height < 0) {\n        y += height;\n        height = -height;\n        if (vertical)\n            swapColors = true;\n    }\n    if (swapColors) {\n        final int t = fromColor;\n        fromColor = toColor;\n        toColor = t;\n    }\n    int rop2 = 0;\n    if (OS.IsWinCE) {\n        rop2 = OS.SetROP2(handle, OS.R2_COPYPEN);\n        OS.SetROP2(handle, rop2);\n    } else {\n        rop2 = OS.GetROP2(handle);\n    }\n    final RGB fromRGB = new RGB(fromColor & 0xff, (fromColor >>> 8) & 0xff, (fromColor >>> 16) & 0xff);\n    final RGB toRGB = new RGB(toColor & 0xff, (toColor >>> 8) & 0xff, (toColor >>> 16) & 0xff);\n    if (fromRGB.red == toRGB.red && fromRGB.green == toRGB.green && fromRGB.blue == toRGB.blue) {\n        int dwRop = rop2 == OS.R2_XORPEN ? OS.PATINVERT : OS.PATCOPY;\n        OS.PatBlt(handle, x, y, width, height, dwRop);\n        return;\n    }\n    if (data.gdipGraphics != 0) {\n        initGdip(false, true);\n        PointF p1 = new PointF(), p2 = new PointF();\n        p1.X = x;\n        p1.Y = y;\n        if (vertical) {\n            p2.X = p1.X;\n            p2.Y = p1.Y + height;\n        } else {\n            p2.X = p1.X + width;\n            p2.Y = p1.Y;\n        }\n        int rgb = ((fromColor >> 16) & 0xFF) | (fromColor & 0xFF00) | ((fromColor & 0xFF) << 16);\n        int fromGpColor = Gdip.Color_new(data.alpha << 24 | rgb);\n        if (fromGpColor == 0)\n            SWT.error(SWT.ERROR_NO_HANDLES);\n        rgb = ((toColor >> 16) & 0xFF) | (toColor & 0xFF00) | ((toColor & 0xFF) << 16);\n        int toGpColor = Gdip.Color_new(data.alpha << 24 | rgb);\n        if (toGpColor == 0)\n            SWT.error(SWT.ERROR_NO_HANDLES);\n        int brush = Gdip.LinearGradientBrush_new(p1, p2, fromGpColor, toGpColor);\n        Gdip.Graphics_FillRectangle(data.gdipGraphics, brush, x, y, width, height);\n        Gdip.LinearGradientBrush_delete(brush);\n        Gdip.Color_delete(fromGpColor);\n        Gdip.Color_delete(toGpColor);\n        return;\n    }\n    \n    if (!OS.IsWinCE && rop2 != OS.R2_XORPEN && OS.GetDeviceCaps(handle, OS.TECHNOLOGY) != OS.DT_RASPRINTER) {\n        final int hHeap = OS.GetProcessHeap();\n        final int pMesh = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, GRADIENT_RECT.sizeof + TRIVERTEX.sizeof * 2);\n        final int pVertex = pMesh + GRADIENT_RECT.sizeof;\n        GRADIENT_RECT gradientRect = new GRADIENT_RECT();\n        gradientRect.UpperLeft = 0;\n        gradientRect.LowerRight = 1;\n        OS.MoveMemory(pMesh, gradientRect, GRADIENT_RECT.sizeof);\n        TRIVERTEX trivertex = new TRIVERTEX();\n        trivertex.x = x;\n        trivertex.y = y;\n        trivertex.Red = (short) ((fromRGB.red << 8) | fromRGB.red);\n        trivertex.Green = (short) ((fromRGB.green << 8) | fromRGB.green);\n        trivertex.Blue = (short) ((fromRGB.blue << 8) | fromRGB.blue);\n        trivertex.Alpha = -1;\n        OS.MoveMemory(pVertex, trivertex, TRIVERTEX.sizeof);\n        trivertex.x = x + width;\n        trivertex.y = y + height;\n        trivertex.Red = (short) ((toRGB.red << 8) | toRGB.red);\n        trivertex.Green = (short) ((toRGB.green << 8) | toRGB.green);\n        trivertex.Blue = (short) ((toRGB.blue << 8) | toRGB.blue);\n        trivertex.Alpha = -1;\n        OS.MoveMemory(pVertex + TRIVERTEX.sizeof, trivertex, TRIVERTEX.sizeof);\n        boolean success = OS.GradientFill(handle, pVertex, 2, pMesh, 1, vertical ? OS.GRADIENT_FILL_RECT_V : OS.GRADIENT_FILL_RECT_H);\n        OS.HeapFree(hHeap, 0, pMesh);\n        if (success)\n            return;\n    }\n    final int depth = OS.GetDeviceCaps(handle, OS.BITSPIXEL);\n    final int bitResolution = (depth >= 24) ? 8 : (depth >= 15) ? 5 : 0;\n    ImageData.fillGradientRectangle(this, data.device, x, y, width, height, vertical, fromRGB, toRGB, bitResolution, bitResolution, bitResolution);\n}",
			"comments":"/**\n* Fills the interior of the specified rectangle with a gradient\n* sweeping from left to right or top to bottom progressing\n* from the receiver's foreground color to its background color.\n*\n* @param x the x coordinate of the rectangle to be filled\n* @param y the y coordinate of the rectangle to be filled\n* @param width the width of the rectangle to be filled, may be negative\n*        (inverts direction of gradient if horizontal)\n* @param height the height of the rectangle to be filled, may be negative\n*        (inverts direction of gradient if vertical)\n* @param vertical if true sweeps from top to bottom, else\n*        sweeps from left to right\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #drawRectangle(int, int, int, int)\n*/\n/* Use GradientFill if supported, only on Windows 98, 2000 and newer. */\n/*\n* Bug in Windows: On Windows 2000 when the device is a printer,\n* GradientFill swaps red and blue color components, causing the\n* gradient to be printed in the wrong color. On Windows 98 when\n* the device is a printer, GradientFill does not fill completely\n* to the right edge of the rectangle. The fix is not to use\n* GradientFill for printer devices.\n*/\n",
			"methodName":"public void fillGradientRectangle(int x, int y, int width, int height, boolean vertical)"
		},
		"public int hashCode()":{
			"methodBody":"{\n    return handle;\n}",
			"comments":"/**\n* Returns an integer hash code for the receiver. Any two\n* objects that return <code>true</code> when passed to\n* <code>equals</code> must return the same value for this\n* method.\n*\n* @return the receiver's hash\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #equals\n*/\n",
			"methodName":"public int hashCode()"
		},
		"static int checkStyle(int style)":{
			"methodBody":"{\n    if ((style & SWT.LEFT_TO_RIGHT) != 0)\n        style &= ~SWT.RIGHT_TO_LEFT;\n    return style & (SWT.LEFT_TO_RIGHT | SWT.RIGHT_TO_LEFT);\n}",
			"comments":"",
			"methodName":"static int checkStyle(int style)"
		},
		"public void setAlpha(int alpha)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (data.gdipGraphics == 0 && (alpha & 0xFF) == 0xFF)\n        return;\n    initGdip(false, false);\n    data.alpha = alpha & 0xFF;\n    if (data.gdipPen != 0) {\n        Gdip.Pen_delete(data.gdipPen);\n        data.gdipPen = 0;\n    }\n    if (data.gdipBrush != 0) {\n        destroyGdipBrush(data.gdipBrush);\n        data.gdipBrush = 0;\n    }\n}",
			"comments":"/**\n* Sets the receiver's alpha value.\n*\n* @param alpha the alpha value\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public void setAlpha(int alpha)"
		},
		"void drawRoundRectangleGdip(int gdipGraphics, int brush, int x, int y, int width, int height, int arcWidth, int arcHeight)":{
			"methodBody":"{\n    int nx = x;\n    int ny = y;\n    int nw = width;\n    int nh = height;\n    int naw = arcWidth;\n    int nah = arcHeight;\n    if (nw < 0) {\n        nw = 0 - nw;\n        nx = nx - nw;\n    }\n    if (nh < 0) {\n        nh = 0 - nh;\n        ny = ny - nh;\n    }\n    if (naw < 0)\n        naw = 0 - naw;\n    if (nah < 0)\n        nah = 0 - nah;\n    int naw2 = naw / 2;\n    int nah2 = nah / 2;\n    if (data.lineWidth == 0 || (data.lineWidth % 2) == 1)\n        Gdip.Graphics_SetPixelOffsetMode(gdipGraphics, Gdip.PixelOffsetModeNone);\n    if (nw > naw) {\n        if (nh > nah) {\n            Gdip.Graphics_DrawArc(gdipGraphics, brush, nx, ny, naw, nah, -90, -90);\n            Gdip.Graphics_DrawLine(gdipGraphics, brush, nx + naw2, ny, nx + nw - naw2, ny);\n            Gdip.Graphics_DrawArc(gdipGraphics, brush, nx + nw - naw, ny, naw, nah, 0, -90);\n            Gdip.Graphics_DrawLine(gdipGraphics, brush, nx + nw, ny + nah2, nx + nw, ny + nh - nah2);\n            Gdip.Graphics_DrawArc(gdipGraphics, brush, nx + nw - naw, ny + nh - nah, naw, nah, -270, -90);\n            Gdip.Graphics_DrawLine(gdipGraphics, brush, nx + naw2, ny + nh, nx + nw - naw2, ny + nh);\n            Gdip.Graphics_DrawArc(gdipGraphics, brush, nx, ny + nh - nah, naw, nah, -180, -90);\n            Gdip.Graphics_DrawLine(gdipGraphics, brush, nx, ny + nah2, nx, ny + nh - nah2);\n        } else {\n            Gdip.Graphics_DrawArc(gdipGraphics, brush, nx, ny, naw, nh, 90, -180);\n            Gdip.Graphics_DrawLine(gdipGraphics, brush, nx + naw2, ny, nx + nw - naw2, ny);\n            Gdip.Graphics_DrawArc(gdipGraphics, brush, nx + nw - naw, ny, naw, nh, 270, -180);\n            Gdip.Graphics_DrawLine(gdipGraphics, brush, nx + naw2, ny + nh, nx + nw - naw2, ny + nh);\n        }\n    } else {\n        if (nh > nah) {\n            Gdip.Graphics_DrawArc(gdipGraphics, brush, nx, ny, nw, nah, 0, -180);\n            Gdip.Graphics_DrawLine(gdipGraphics, brush, nx + nw, ny + nah2, nx + nw, ny + nh - nah2);\n            Gdip.Graphics_DrawArc(gdipGraphics, brush, nx, ny + nh - nah, nw, nah, -180, -180);\n            Gdip.Graphics_DrawLine(gdipGraphics, brush, nx, ny + nah2, nx, ny + nh - nah2);\n        } else {\n            Gdip.Graphics_DrawArc(gdipGraphics, brush, nx, ny, nw, nh, 0, 360);\n        }\n    }\n    if (data.lineWidth == 0 || (data.lineWidth % 2) == 1)\n        Gdip.Graphics_SetPixelOffsetMode(gdipGraphics, Gdip.PixelOffsetModeHalf);\n}",
			"comments":"",
			"methodName":"void drawRoundRectangleGdip(int gdipGraphics, int brush, int x, int y, int width, int height, int arcWidth, int arcHeight)"
		},
		"public int getCharWidth(char ch)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    \n    if (!OS.IsWinCE) {\n        int tch = ch;\n        if (ch > 0x7F) {\n            TCHAR buffer = new TCHAR(getCodePage(), ch, false);\n            tch = buffer.tcharAt(0);\n        }\n        int[] width = new int[3];\n        if (OS.GetCharABCWidths(handle, tch, tch, width)) {\n            return width[1];\n        }\n    }\n    \n    TEXTMETRIC lptm = OS.IsUnicode ? (TEXTMETRIC) new TEXTMETRICW() : new TEXTMETRICA();\n    OS.GetTextMetrics(handle, lptm);\n    SIZE size = new SIZE();\n    OS.GetTextExtentPoint32W(handle, new char[] { ch }, 1, size);\n    return size.cx - lptm.tmOverhang;\n}",
			"comments":"/**\n* Returns the width of the specified character in the font\n* selected into the receiver.\n* <p>\n* The width is defined as the space taken up by the actual\n* character, not including the leading and tailing whitespace\n* or overhang.\n* </p>\n*\n* @param ch the character to measure\n* @return the width of the character\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n/* GetCharABCWidths only succeeds on truetype fonts */\n/* It wasn't a truetype font */\n",
			"methodName":"public int getCharWidth(char ch)"
		},
		"int createGdipBrush()":{
			"methodBody":"{\n    int colorRef = OS.GetBkColor(handle);\n    int rgb = ((colorRef >> 16) & 0xFF) | (colorRef & 0xFF00) | ((colorRef & 0xFF) << 16);\n    int color = Gdip.Color_new(data.alpha << 24 | rgb);\n    if (color == 0)\n        SWT.error(SWT.ERROR_NO_HANDLES);\n    int brush = Gdip.SolidBrush_new(color);\n    if (brush == 0)\n        SWT.error(SWT.ERROR_NO_HANDLES);\n    Gdip.Color_delete(color);\n    return brush;\n}",
			"comments":"",
			"methodName":"int createGdipBrush()"
		},
		"public void fillRectangle(Rectangle rect)":{
			"methodBody":"{\n    if (rect == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    fillRectangle(rect.x, rect.y, rect.width, rect.height);\n}",
			"comments":"/**\n* Fills the interior of the specified rectangle, using the receiver's\n* background color.\n*\n* @param rect the rectangle to be filled\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the rectangle is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #drawRectangle(int, int, int, int)\n*/\n",
			"methodName":"public void fillRectangle(Rectangle rect)"
		},
		"public Point stringExtent(String string)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (string == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    int length = string.length();\n    if (data.gdipGraphics != 0) {\n        int font = createGdipFont();\n        PointF pt = new PointF();\n        RectF bounds = new RectF();\n        char[] buffer;\n        if (length != 0) {\n            buffer = new char[length];\n            string.getChars(0, length, buffer, 0);\n        } else {\n            buffer = new char[] { ' ' };\n        }\n        int format = Gdip.StringFormat_Clone(Gdip.StringFormat_GenericTypographic());\n        Gdip.StringFormat_SetFormatFlags(format, Gdip.StringFormat_GetFormatFlags(format) | Gdip.StringFormatFlagsMeasureTrailingSpaces);\n        Gdip.Graphics_MeasureString(data.gdipGraphics, buffer, buffer.length, font, pt, format, bounds);\n        Gdip.StringFormat_delete(format);\n        Gdip.Font_delete(font);\n        return new Point(length == 0 ? 0 : Math.round(bounds.Width), Math.round(bounds.Height));\n    }\n    SIZE size = new SIZE();\n    if (length == 0) {\n        \n        OS.GetTextExtentPoint32W(handle, new char[] { ' ' }, 1, size);\n        return new Point(0, size.cy);\n    } else {\n        \n        char[] buffer = new char[length];\n        string.getChars(0, length, buffer, 0);\n        OS.GetTextExtentPoint32W(handle, buffer, length, size);\n        return new Point(size.cx, size.cy);\n    }\n}",
			"comments":"/**\n* Returns the extent of the given string. No tab\n* expansion or carriage return processing will be performed.\n* <p>\n* The <em>extent</em> of a string is the width and height of\n* the rectangular area it would cover if drawn in a particular\n* font (in this case, the current font in the receiver).\n* </p>\n*\n* @param string the string to measure\n* @return a point containing the extent of the string\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the string is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n//\t\tOS.GetTextExtentPoint32(handle, SPACE, SPACE.length(), size);\n//\t\tTCHAR buffer = new TCHAR (getCodePage(), string, false);\n",
			"methodName":"public Point stringExtent(String string)"
		},
		"public void drawRoundRectangle(int x, int y, int width, int height, int arcWidth, int arcHeight)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (data.gdipGraphics != 0) {\n        initGdip(true, false);\n        drawRoundRectangleGdip(data.gdipGraphics, data.gdipPen, x, y, width, height, arcWidth, arcHeight);\n        return;\n    }\n    if (OS.IsWinCE) {\n        \n        if (width == 0 || height == 0)\n            return;\n        if (arcWidth == 0 || arcHeight == 0) {\n            drawRectangle(x, y, width, height);\n            return;\n        }\n        if (width < 0) {\n            x += width;\n            width = -width;\n        }\n        if (height < 0) {\n            y += height;\n            height = -height;\n        }\n        if (arcWidth < 0)\n            arcWidth = -arcWidth;\n        if (arcHeight < 0)\n            arcHeight = -arcHeight;\n        if (arcWidth > width)\n            arcWidth = width;\n        if (arcHeight > height)\n            arcHeight = height;\n        if (arcWidth < width) {\n            drawLine(x + arcWidth / 2, y, x + width - arcWidth / 2, y);\n            drawLine(x + arcWidth / 2, y + height, x + width - arcWidth / 2, y + height);\n        }\n        if (arcHeight < height) {\n            drawLine(x, y + arcHeight / 2, x, y + height - arcHeight / 2);\n            drawLine(x + width, y + arcHeight / 2, x + width, y + height - arcHeight / 2);\n        }\n        if (arcWidth != 0 && arcHeight != 0) {\n            drawArc(x, y, arcWidth, arcHeight, 90, 90);\n            drawArc(x + width - arcWidth, y, arcWidth, arcHeight, 0, 90);\n            drawArc(x + width - arcWidth, y + height - arcHeight, arcWidth, arcHeight, 0, -90);\n            drawArc(x, y + height - arcHeight, arcWidth, arcHeight, 180, 90);\n        }\n    } else {\n        int nullBrush = OS.GetStockObject(OS.NULL_BRUSH);\n        int oldBrush = OS.SelectObject(handle, nullBrush);\n        OS.RoundRect(handle, x, y, x + width + 1, y + height + 1, arcWidth, arcHeight);\n        OS.SelectObject(handle, oldBrush);\n    }\n}",
			"comments":"/**\n* Draws the outline of the round-cornered rectangle specified by\n* the arguments, using the receiver's foreground color. The left and\n* right edges of the rectangle are at <code>x</code> and <code>x + width</code>.\n* The top and bottom edges are at <code>y</code> and <code>y + height</code>.\n* The <em>roundness</em> of the corners is specified by the\n* <code>arcWidth</code> and <code>arcHeight</code> arguments, which\n* are respectively the width and height of the ellipse used to draw\n* the corners.\n*\n* @param x the x coordinate of the rectangle to be drawn\n* @param y the y coordinate of the rectangle to be drawn\n* @param width the width of the rectangle to be drawn\n* @param height the height of the rectangle to be drawn\n* @param arcWidth the width of the arc\n* @param arcHeight the height of the arc\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n/*\n* Bug in WinCE PPC.  On certain devices, RoundRect does not draw\n* all the pixels.  The workaround is to draw a round rectangle\n* using lines and arcs.\n*/\n",
			"methodName":"public void drawRoundRectangle(int x, int y, int width, int height, int arcWidth, int arcHeight)"
		},
		"public void setForegroundPattern(Pattern pattern)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (pattern != null && pattern.isDisposed())\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    if (data.gdipGraphics == 0 && pattern == null)\n        return;\n    initGdip(false, false);\n    if (pattern != null) {\n        if (data.gdipPen != 0)\n            Gdip.Pen_SetBrush(data.gdipPen, pattern.handle);\n    } else {\n        if (data.gdipPen != 0) {\n            Gdip.Pen_delete(data.gdipPen);\n            data.gdipPen = 0;\n        }\n    }\n    data.foregroundPattern = pattern;\n}",
			"comments":"/**\n* Sets the foreground pattern. The default value is <code>null</code>.\n*\n* @param pattern the new foreground pattern\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the parameter has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see Pattern\n*\n* @since 3.1\n*/\n",
			"methodName":"public void setForegroundPattern(Pattern pattern)"
		},
		"public void drawOval(int x, int y, int width, int height)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    int gdipGraphics = data.gdipGraphics;\n    if (gdipGraphics != 0) {\n        initGdip(true, false);\n        if (data.lineWidth == 0 || (data.lineWidth % 2) == 1)\n            Gdip.Graphics_SetPixelOffsetMode(gdipGraphics, Gdip.PixelOffsetModeNone);\n        Gdip.Graphics_DrawEllipse(gdipGraphics, data.gdipPen, x, y, width, height);\n        if (data.lineWidth == 0 || (data.lineWidth % 2) == 1)\n            Gdip.Graphics_SetPixelOffsetMode(gdipGraphics, Gdip.PixelOffsetModeHalf);\n        return;\n    }\n    \n    \n    int nullBrush = OS.GetStockObject(OS.NULL_BRUSH);\n    int oldBrush = OS.SelectObject(handle, nullBrush);\n    OS.Ellipse(handle, x, y, x + width + 1, y + height + 1);\n    OS.SelectObject(handle, oldBrush);\n}",
			"comments":"/**\n* Draws the outline of an oval, using the foreground color,\n* within the specified rectangular area.\n* <p>\n* The result is a circle or ellipse that fits within the\n* rectangle specified by the <code>x</code>, <code>y</code>,\n* <code>width</code>, and <code>height</code> arguments.\n* </p><p>\n* The oval covers an area that is <code>width + 1</code>\n* pixels wide and <code>height + 1</code> pixels tall.\n* </p>\n*\n* @param x the x coordinate of the upper left corner of the oval to be drawn\n* @param y the y coordinate of the upper left corner of the oval to be drawn\n* @param width the width of the oval to be drawn\n* @param height the height of the oval to be drawn\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n// Check performance impact of always setting null brush. If the user has not\n// set the background color, we may not have to do this work?\n",
			"methodName":"public void drawOval(int x, int y, int width, int height)"
		},
		"public void drawFocus(int x, int y, int width, int height)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    RECT rect = new RECT();\n    OS.SetRect(rect, x, y, x + width, y + height);\n    OS.DrawFocusRect(handle, rect);\n}",
			"comments":"/**\n* Draws a rectangle, based on the specified arguments, which has\n* the appearance of the platform's <em>focus rectangle</em> if the\n* platform supports such a notion, and otherwise draws a simple\n* rectangle in the receiver's foreground color.\n*\n* @param x the x coordinate of the rectangle\n* @param y the y coordinate of the rectangle\n* @param width the width of the rectangle\n* @param height the height of the rectangle\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #drawRectangle(int, int, int, int)\n*/\n",
			"methodName":"public void drawFocus(int x, int y, int width, int height)"
		},
		"int createGdipFont()":{
			"methodBody":"{\n    return createGdipFont(handle, OS.GetCurrentObject(handle, OS.OBJ_FONT));\n}",
			"comments":"",
			"methodName":"int createGdipFont()"
		},
		"public void fillOval(int x, int y, int width, int height)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (data.gdipGraphics != 0) {\n        initGdip(false, true);\n        Gdip.Graphics_FillEllipse(data.gdipGraphics, data.gdipBrush, x, y, width, height);\n        return;\n    }\n    \n    int nullPen = OS.GetStockObject(OS.NULL_PEN);\n    int oldPen = OS.SelectObject(handle, nullPen);\n    OS.Ellipse(handle, x, y, x + width + 1, y + height + 1);\n    OS.SelectObject(handle, oldPen);\n}",
			"comments":"/**\n* Fills the interior of an oval, within the specified\n* rectangular area, with the receiver's background\n* color.\n*\n* @param x the x coordinate of the upper left corner of the oval to be filled\n* @param y the y coordinate of the upper left corner of the oval to be filled\n* @param width the width of the oval to be filled\n* @param height the height of the oval to be filled\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #drawOval\n*/\n/* Assumes that user sets the background color. */\n",
			"methodName":"public void fillOval(int x, int y, int width, int height)"
		},
		"public void setLineWidth(int lineWidth)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    setPen(-1, lineWidth, -1, -1, -1, data.dashes);\n}",
			"comments":"/**\n* Sets the width that will be used when drawing lines\n* for all of the figure drawing operations (that is,\n* <code>drawLine</code>, <code>drawRectangle</code>,\n* <code>drawPolyline</code>, and so forth.\n* <p>\n* Note that line width of zero is used as a hint to\n* indicate that the fastest possible line drawing\n* algorithms should be used. This means that the\n* output may be different from line width one.\n* </p>\n*\n* @param lineWidth the width of a line\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void setLineWidth(int lineWidth)"
		},
		"float measureSpace(int font, int format)":{
			"methodBody":"{\n    PointF pt = new PointF();\n    RectF bounds = new RectF();\n    Gdip.Graphics_MeasureString(data.gdipGraphics, new char[] { ' ' }, 1, font, pt, format, bounds);\n    return bounds.Width;\n}",
			"comments":"",
			"methodName":"float measureSpace(int font, int format)"
		},
		"public int getLineCap()":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    int style, size;\n    int hPen = OS.GetCurrentObject(handle, OS.OBJ_PEN);\n    if ((size = OS.GetObject(hPen, 0, (LOGPEN) null)) == LOGPEN.sizeof) {\n        LOGPEN logPen = new LOGPEN();\n        OS.GetObject(hPen, LOGPEN.sizeof, logPen);\n        style = logPen.lopnStyle | OS.PS_ENDCAP_FLAT;\n    } else {\n        EXTLOGPEN logPen = new EXTLOGPEN();\n        if (size <= EXTLOGPEN.sizeof) {\n            OS.GetObject(hPen, size, logPen);\n        } else {\n            int hHeap = OS.GetProcessHeap();\n            int ptr = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, size);\n            OS.GetObject(hPen, size, ptr);\n            OS.MoveMemory(logPen, ptr, EXTLOGPEN.sizeof);\n            OS.HeapFree(hHeap, 0, ptr);\n        }\n        style = logPen.elpPenStyle & OS.PS_ENDCAP_MASK;\n    }\n    int cap = SWT.CAP_ROUND;\n    switch(style) {\n        case OS.PS_ENDCAP_ROUND:\n            cap = SWT.CAP_ROUND;\n            break;\n        case OS.PS_ENDCAP_FLAT:\n            cap = SWT.CAP_FLAT;\n            break;\n        case OS.PS_ENDCAP_SQUARE:\n            cap = SWT.CAP_SQUARE;\n            break;\n    }\n    return cap;\n}",
			"comments":"/**\n* Returns the receiver's line cap style, which will be one\n* of the constants <code>SWT.CAP_FLAT</code>, <code>SWT.CAP_ROUND</code>,\n* or <code>SWT.CAP_SQUARE</code>.\n*\n* @return the cap style used for drawing lines\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public int getLineCap()"
		},
		"public void drawText(String string, int x, int y, boolean isTransparent)":{
			"methodBody":"{\n    int flags = SWT.DRAW_DELIMITER | SWT.DRAW_TAB;\n    if (isTransparent)\n        flags |= SWT.DRAW_TRANSPARENT;\n    drawText(string, x, y, flags);\n}",
			"comments":"/**\n* Draws the given string, using the receiver's current font and\n* foreground color. Tab expansion and carriage return processing\n* are performed. If <code>isTransparent</code> is <code>true</code>,\n* then the background of the rectangular area where the text is being\n* drawn will not be modified, otherwise it will be filled with the\n* receiver's background color.\n*\n* @param string the string to be drawn\n* @param x the x coordinate of the top left corner of the rectangular area where the text is to be drawn\n* @param y the y coordinate of the top left corner of the rectangular area where the text is to be drawn\n* @param isTransparent if <code>true</code> the background will be transparent, otherwise it will be opaque\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the string is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void drawText(String string, int x, int y, boolean isTransparent)"
		},
		"public void drawPath(Path path)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (path == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (path.handle == 0)\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    initGdip(true, false);\n    int gdipGraphics = data.gdipGraphics;\n    if (data.lineWidth == 0 || (data.lineWidth % 2) == 1)\n        Gdip.Graphics_SetPixelOffsetMode(gdipGraphics, Gdip.PixelOffsetModeNone);\n    Gdip.Graphics_DrawPath(gdipGraphics, data.gdipPen, path.handle);\n    if (data.lineWidth == 0 || (data.lineWidth % 2) == 1)\n        Gdip.Graphics_SetPixelOffsetMode(gdipGraphics, Gdip.PixelOffsetModeHalf);\n}",
			"comments":"/**\n* Draws the path described by the parameter.\n*\n* @param path the path to draw\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the parameter is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the parameter has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see Path\n*\n* @since 3.1\n*/\n",
			"methodName":"public void drawPath(Path path)"
		},
		"public boolean isClipped()":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    int region = OS.CreateRectRgn(0, 0, 0, 0);\n    int result = OS.GetClipRgn(handle, region);\n    OS.DeleteObject(region);\n    return result > 0;\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver has a clipping\n* region set into it, and <code>false</code> otherwise.\n* If this method returns false, the receiver will draw on all\n* available space in the destination. If it returns true,\n* it will draw only in the area that is covered by the region\n* that can be accessed with <code>getClipping(region)</code>.\n*\n* @return <code>true</code> if the GC has a clipping region, and <code>false</code> otherwise\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public boolean isClipped()"
		},
		"void drawImage(Image srcImage, int srcX, int srcY, int srcWidth, int srcHeight, int destX, int destY, int destWidth, int destHeight, boolean simple)":{
			"methodBody":"{\n    if (data.gdipGraphics != 0) {\n        \n        int[] gdipImage = srcImage.createGdipImage();\n        int img = gdipImage[0];\n        int imgWidth = Gdip.Image_GetWidth(img);\n        int imgHeight = Gdip.Image_GetHeight(img);\n        if (simple) {\n            srcWidth = destWidth = imgWidth;\n            srcHeight = destHeight = imgHeight;\n        } else {\n            if (srcX + srcWidth > imgWidth || srcY + srcHeight > imgHeight) {\n                SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n            }\n            simple = srcX == 0 && srcY == 0 && srcWidth == destWidth && destWidth == imgWidth && srcHeight == destHeight && destHeight == imgHeight;\n        }\n        if (simple) {\n            Gdip.Graphics_DrawImage(data.gdipGraphics, img, destX, destY);\n        } else {\n            Rect rect = new Rect();\n            rect.X = destX;\n            rect.Y = destY;\n            rect.Width = destWidth;\n            rect.Height = destHeight;\n            Gdip.Graphics_DrawImage(data.gdipGraphics, img, rect, srcX, srcY, srcWidth, srcHeight, Gdip.UnitPixel, 0, 0, 0);\n        }\n        Gdip.Bitmap_delete(img);\n        if (gdipImage[1] != 0) {\n            int hHeap = OS.GetProcessHeap();\n            OS.HeapFree(hHeap, 0, gdipImage[1]);\n        }\n        return;\n    }\n    switch(srcImage.type) {\n        case SWT.BITMAP:\n            drawBitmap(srcImage, srcX, srcY, srcWidth, srcHeight, destX, destY, destWidth, destHeight, simple);\n            break;\n        case SWT.ICON:\n            drawIcon(srcImage, srcX, srcY, srcWidth, srcHeight, destX, destY, destWidth, destHeight, simple);\n            break;\n        default:\n            SWT.error(SWT.ERROR_UNSUPPORTED_FORMAT);\n    }\n}",
			"comments":"//TODO - cache bitmap\n",
			"methodName":"void drawImage(Image srcImage, int srcX, int srcY, int srcWidth, int srcHeight, int destX, int destY, int destWidth, int destHeight, boolean simple)"
		},
		"public void drawPolygon(int[] pointArray)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (pointArray == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    int gdipGraphics = data.gdipGraphics;\n    if (gdipGraphics != 0) {\n        initGdip(true, false);\n        if (data.lineWidth == 0 || (data.lineWidth % 2) == 1)\n            Gdip.Graphics_SetPixelOffsetMode(gdipGraphics, Gdip.PixelOffsetModeNone);\n        Gdip.Graphics_DrawPolygon(gdipGraphics, data.gdipPen, pointArray, pointArray.length / 2);\n        if (data.lineWidth == 0 || (data.lineWidth % 2) == 1)\n            Gdip.Graphics_SetPixelOffsetMode(gdipGraphics, Gdip.PixelOffsetModeHalf);\n        return;\n    }\n    int nullBrush = OS.GetStockObject(OS.NULL_BRUSH);\n    int oldBrush = OS.SelectObject(handle, nullBrush);\n    OS.Polygon(handle, pointArray, pointArray.length / 2);\n    OS.SelectObject(handle, oldBrush);\n}",
			"comments":"/**\n* Draws the closed polygon which is defined by the specified array\n* of integer coordinates, using the receiver's foreground color. The array\n* contains alternating x and y values which are considered to represent\n* points which are the vertices of the polygon. Lines are drawn between\n* each consecutive pair, and between the first pair and last pair in the\n* array.\n*\n* @param pointArray an array of alternating x and y values which are the vertices of the polygon\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT if pointArray is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void drawPolygon(int[] pointArray)"
		},
		"public void drawRectangle(int x, int y, int width, int height)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    int gdipGraphics = data.gdipGraphics;\n    if (gdipGraphics != 0) {\n        initGdip(true, false);\n        if (data.lineWidth == 0 || (data.lineWidth % 2) == 1)\n            Gdip.Graphics_SetPixelOffsetMode(gdipGraphics, Gdip.PixelOffsetModeNone);\n        Gdip.Graphics_DrawRectangle(gdipGraphics, data.gdipPen, x, y, width, height);\n        if (data.lineWidth == 0 || (data.lineWidth % 2) == 1)\n            Gdip.Graphics_SetPixelOffsetMode(gdipGraphics, Gdip.PixelOffsetModeHalf);\n        return;\n    }\n    int hOld = OS.SelectObject(handle, OS.GetStockObject(OS.NULL_BRUSH));\n    OS.Rectangle(handle, x, y, x + width + 1, y + height + 1);\n    OS.SelectObject(handle, hOld);\n}",
			"comments":"/**\n* Draws the outline of the rectangle specified by the arguments,\n* using the receiver's foreground color. The left and right edges\n* of the rectangle are at <code>x</code> and <code>x + width</code>.\n* The top and bottom edges are at <code>y</code> and <code>y + height</code>.\n*\n* @param x the x coordinate of the rectangle to be drawn\n* @param y the y coordinate of the rectangle to be drawn\n* @param width the width of the rectangle to be drawn\n* @param height the height of the rectangle to be drawn\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void drawRectangle(int x, int y, int width, int height)"
		},
		"public void setXORMode(boolean xor)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    OS.SetROP2(handle, xor ? OS.R2_XORPEN : OS.R2_COPYPEN);\n}",
			"comments":"/**\n* If the argument is <code>true</code>, puts the receiver\n* in a drawing mode where the resulting color in the destination\n* is the <em>exclusive or</em> of the color values in the source\n* and the destination, and if the argument is <code>false</code>,\n* puts the receiver in a drawing mode where the destination color\n* is replaced with the source color value.\n* <p>\n* Note that this mode in fundamentally unsupportable on certain\n* platforms, notably Carbon (Mac OS X). Clients that want their\n* code to run on all platforms need to avoid this method.\n* </p>\n*\n* @param xor if <code>true</code>, then <em>xor</em> mode is used, otherwise <em>source copy</em> mode is used\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @deprecated this functionality is not supported on some platforms\n*/\n",
			"methodName":"public void setXORMode(boolean xor)"
		},
		"public Point textExtent(String string)":{
			"methodBody":"{\n    return textExtent(string, SWT.DRAW_DELIMITER | SWT.DRAW_TAB);\n}",
			"comments":"/**\n* Returns the extent of the given string. Tab expansion and\n* carriage return processing are performed.\n* <p>\n* The <em>extent</em> of a string is the width and height of\n* the rectangular area it would cover if drawn in a particular\n* font (in this case, the current font in the receiver).\n* </p>\n*\n* @param string the string to measure\n* @return a point containing the extent of the string\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the string is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public Point textExtent(String string)"
		},
		"public void setForeground(Color color)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (color == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (color.isDisposed())\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    if (data.foregroundPattern != null) {\n        if (data.gdipPen != 0) {\n            Gdip.Pen_delete(data.gdipPen);\n            data.gdipPen = 0;\n        }\n        data.foregroundPattern = null;\n    }\n    if (OS.GetTextColor(handle) == color.handle)\n        return;\n    data.foreground = color.handle;\n    OS.SetTextColor(handle, color.handle);\n    setPen(color.handle, -1, -1, -1, -1, data.dashes);\n}",
			"comments":"/**\n* Sets the foreground color. The foreground color is used\n* for drawing operations including when text is drawn.\n*\n* @param color the new foreground color for the receiver\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the color is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the color has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void setForeground(Color color)"
		},
		"public void drawText(String string, int x, int y)":{
			"methodBody":"{\n    drawText(string, x, y, SWT.DRAW_DELIMITER | SWT.DRAW_TAB);\n}",
			"comments":"/**\n* Draws the given string, using the receiver's current font and\n* foreground color. Tab expansion and carriage return processing\n* are performed. The background of the rectangular area where\n* the text is being drawn will be filled with the receiver's\n* background color.\n*\n* @param string the string to be drawn\n* @param x the x coordinate of the top left corner of the rectangular area where the text is to be drawn\n* @param y the y coordinate of the top left corner of the rectangular area where the text is to be drawn\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the string is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void drawText(String string, int x, int y)"
		},
		"public Font getFont()":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    int hFont = OS.GetCurrentObject(handle, OS.OBJ_FONT);\n    return Font.win32_new(data.device, hFont);\n}",
			"comments":"/**\n* Returns the font currently being used by the receiver\n* to draw and measure text.\n*\n* @return the receiver's font\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public Font getFont()"
		},
		"public void drawString(String string, int x, int y)":{
			"methodBody":"{\n    drawString(string, x, y, false);\n}",
			"comments":"/**\n* Draws the given string, using the receiver's current font and\n* foreground color. No tab expansion or carriage return processing\n* will be performed. The background of the rectangular area where\n* the string is being drawn will be filled with the receiver's\n* background color.\n*\n* @param string the string to be drawn\n* @param x the x coordinate of the top left corner of the rectangular area where the string is to be drawn\n* @param y the y coordinate of the top left corner of the rectangular area where the string is to be drawn\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the string is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void drawString(String string, int x, int y)"
		},
		"void drawIcon(Image srcImage, int srcX, int srcY, int srcWidth, int srcHeight, int destX, int destY, int destWidth, int destHeight, boolean simple)":{
			"methodBody":"{\n    int technology = OS.GetDeviceCaps(handle, OS.TECHNOLOGY);\n    boolean drawIcon = true;\n    int flags = OS.DI_NORMAL;\n    if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION(5, 1)) {\n        flags |= OS.DI_NOMIRROR;\n    } else {\n        if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION(4, 10)) {\n            drawIcon = (OS.GetLayout(handle) & OS.LAYOUT_RTL) == 0;\n        }\n    }\n    \n    if (simple && technology != OS.DT_RASPRINTER && drawIcon) {\n        OS.DrawIconEx(handle, destX, destY, srcImage.handle, 0, 0, 0, 0, flags);\n        return;\n    }\n    \n    ICONINFO srcIconInfo = new ICONINFO();\n    if (OS.IsWinCE) {\n        Image.GetIconInfo(srcImage, srcIconInfo);\n    } else {\n        OS.GetIconInfo(srcImage.handle, srcIconInfo);\n    }\n    \n    int hBitmap = srcIconInfo.hbmColor;\n    if (hBitmap == 0)\n        hBitmap = srcIconInfo.hbmMask;\n    BITMAP bm = new BITMAP();\n    OS.GetObject(hBitmap, BITMAP.sizeof, bm);\n    int iconWidth = bm.bmWidth, iconHeight = bm.bmHeight;\n    if (hBitmap == srcIconInfo.hbmMask)\n        iconHeight /= 2;\n    if (simple) {\n        srcWidth = destWidth = iconWidth;\n        srcHeight = destHeight = iconHeight;\n    }\n    \n    boolean failed = srcX + srcWidth > iconWidth || srcY + srcHeight > iconHeight;\n    if (!failed) {\n        simple = srcX == 0 && srcY == 0 && srcWidth == destWidth && srcHeight == destHeight && srcWidth == iconWidth && srcHeight == iconHeight;\n        if (!drawIcon) {\n            drawBitmapMask(srcImage, srcIconInfo.hbmColor, srcIconInfo.hbmMask, srcX, srcY, srcWidth, srcHeight, destX, destY, destWidth, destHeight, simple, iconWidth, iconHeight, false);\n        } else if (simple && technology != OS.DT_RASPRINTER) {\n            \n            OS.DrawIconEx(handle, destX, destY, srcImage.handle, 0, 0, 0, 0, flags);\n        } else {\n            \n            ICONINFO newIconInfo = new ICONINFO();\n            newIconInfo.fIcon = true;\n            int srcHdc = OS.CreateCompatibleDC(handle);\n            int dstHdc = OS.CreateCompatibleDC(handle);\n            \n            int srcColorY = srcY;\n            int srcColor = srcIconInfo.hbmColor;\n            if (srcColor == 0) {\n                srcColor = srcIconInfo.hbmMask;\n                srcColorY += iconHeight;\n            }\n            int oldSrcBitmap = OS.SelectObject(srcHdc, srcColor);\n            newIconInfo.hbmColor = OS.CreateCompatibleBitmap(srcHdc, destWidth, destHeight);\n            if (newIconInfo.hbmColor == 0)\n                SWT.error(SWT.ERROR_NO_HANDLES);\n            int oldDestBitmap = OS.SelectObject(dstHdc, newIconInfo.hbmColor);\n            boolean stretch = !simple && (srcWidth != destWidth || srcHeight != destHeight);\n            if (stretch) {\n                if (!OS.IsWinCE)\n                    OS.SetStretchBltMode(dstHdc, OS.COLORONCOLOR);\n                OS.StretchBlt(dstHdc, 0, 0, destWidth, destHeight, srcHdc, srcX, srcColorY, srcWidth, srcHeight, OS.SRCCOPY);\n            } else {\n                OS.BitBlt(dstHdc, 0, 0, destWidth, destHeight, srcHdc, srcX, srcColorY, OS.SRCCOPY);\n            }\n            \n            OS.SelectObject(srcHdc, srcIconInfo.hbmMask);\n            newIconInfo.hbmMask = OS.CreateBitmap(destWidth, destHeight, 1, 1, null);\n            if (newIconInfo.hbmMask == 0)\n                SWT.error(SWT.ERROR_NO_HANDLES);\n            OS.SelectObject(dstHdc, newIconInfo.hbmMask);\n            if (stretch) {\n                OS.StretchBlt(dstHdc, 0, 0, destWidth, destHeight, srcHdc, srcX, srcY, srcWidth, srcHeight, OS.SRCCOPY);\n            } else {\n                OS.BitBlt(dstHdc, 0, 0, destWidth, destHeight, srcHdc, srcX, srcY, OS.SRCCOPY);\n            }\n            if (technology == OS.DT_RASPRINTER) {\n                OS.SelectObject(srcHdc, newIconInfo.hbmColor);\n                OS.SelectObject(dstHdc, newIconInfo.hbmMask);\n                drawBitmapTransparentByClipping(srcHdc, dstHdc, 0, 0, destWidth, destHeight, destX, destY, destWidth, destHeight, true, destWidth, destHeight);\n                OS.SelectObject(srcHdc, oldSrcBitmap);\n                OS.SelectObject(dstHdc, oldDestBitmap);\n            } else {\n                OS.SelectObject(srcHdc, oldSrcBitmap);\n                OS.SelectObject(dstHdc, oldDestBitmap);\n                int hIcon = OS.CreateIconIndirect(newIconInfo);\n                if (hIcon == 0)\n                    SWT.error(SWT.ERROR_NO_HANDLES);\n                OS.DrawIconEx(handle, destX, destY, hIcon, destWidth, destHeight, 0, 0, flags);\n                OS.DestroyIcon(hIcon);\n            }\n            \n            OS.DeleteObject(newIconInfo.hbmMask);\n            OS.DeleteObject(newIconInfo.hbmColor);\n            OS.DeleteDC(dstHdc);\n            OS.DeleteDC(srcHdc);\n        }\n    }\n    \n    OS.DeleteObject(srcIconInfo.hbmMask);\n    if (srcIconInfo.hbmColor != 0) {\n        OS.DeleteObject(srcIconInfo.hbmColor);\n    }\n    if (failed)\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n}",
			"comments":"/* Simple case: no stretching, entire icon */\n/* Get the icon info */\n/* Get the icon width and height */\n/* Draw the icon */\n/* Simple case: no stretching, entire icon */\n/* Create the icon info and HDC's */\n/* Blt the color bitmap */\n/* Blt the mask bitmap */\n/* Destroy the new icon src and mask and hdc's*/\n/* Free icon info */\n",
			"methodName":"void drawIcon(Image srcImage, int srcX, int srcY, int srcWidth, int srcHeight, int destX, int destY, int destWidth, int destHeight, boolean simple)"
		},
		"public Pattern getForegroundPattern()":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    return data.foregroundPattern;\n}",
			"comments":"/**\n* Returns the foreground pattern. The default value is\n* <code>null</code>.\n*\n* @return the receiver's foreground pattern\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see Pattern\n*\n* @since 3.1\n*/\n",
			"methodName":"public Pattern getForegroundPattern()"
		},
		"public void fillRectangle(int x, int y, int width, int height)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (data.gdipGraphics != 0) {\n        initGdip(false, true);\n        Gdip.Graphics_FillRectangle(data.gdipGraphics, data.gdipBrush, x, y, width, height);\n        return;\n    }\n    int rop2 = 0;\n    if (OS.IsWinCE) {\n        rop2 = OS.SetROP2(handle, OS.R2_COPYPEN);\n        OS.SetROP2(handle, rop2);\n    } else {\n        rop2 = OS.GetROP2(handle);\n    }\n    int dwRop = rop2 == OS.R2_XORPEN ? OS.PATINVERT : OS.PATCOPY;\n    OS.PatBlt(handle, x, y, width, height, dwRop);\n}",
			"comments":"/**\n* Fills the interior of the rectangle specified by the arguments,\n* using the receiver's background color.\n*\n* @param x the x coordinate of the rectangle to be filled\n* @param y the y coordinate of the rectangle to be filled\n* @param width the width of the rectangle to be filled\n* @param height the height of the rectangle to be filled\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #drawRectangle(int, int, int, int)\n*/\n",
			"methodName":"public void fillRectangle(int x, int y, int width, int height)"
		},
		"public int[] getLineDash()":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (data.dashes == null)\n        return null;\n    int[] dashes = new int[data.dashes.length];\n    System.arraycopy(data.dashes, 0, dashes, 0, dashes.length);\n    return dashes;\n}",
			"comments":"/**\n* Returns the receiver's line dash style. The default value is\n* <code>null</code>.\n*\n* @return the lin dash style used for drawing lines\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public int[] getLineDash()"
		},
		"public void setInterpolation(int interpolation)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (data.gdipGraphics == 0 && interpolation == SWT.DEFAULT)\n        return;\n    int mode = 0;\n    switch(interpolation) {\n        case SWT.DEFAULT:\n            mode = Gdip.InterpolationModeDefault;\n            break;\n        case SWT.NONE:\n            mode = Gdip.InterpolationModeNearestNeighbor;\n            break;\n        case SWT.LOW:\n            mode = Gdip.InterpolationModeLowQuality;\n            break;\n        case SWT.HIGH:\n            mode = Gdip.InterpolationModeHighQuality;\n            break;\n        default:\n            SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    }\n    initGdip(false, false);\n    Gdip.Graphics_SetInterpolationMode(data.gdipGraphics, mode);\n}",
			"comments":"/**\n* Sets the receiver's interpolation setting to the parameter, which\n* must be one of <code>SWT.DEFAULT</code>, <code>SWT.NONE</code>,\n* <code>SWT.LOW</code> or <code>SWT.HIGH</code>.\n*\n* @param interpolation the new interpolation setting\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the rule is not one of <code>SWT.DEFAULT</code>,\n*                                 <code>SWT.NONE</code>, <code>SWT.LOW</code> or <code>SWT.HIGH</code>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public void setInterpolation(int interpolation)"
		},
		"public void setBackgroundPattern(Pattern pattern)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (pattern != null && pattern.isDisposed())\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    if (data.gdipGraphics == 0 && pattern == null)\n        return;\n    initGdip(false, false);\n    if (data.gdipBrush != 0)\n        destroyGdipBrush(data.gdipBrush);\n    if (pattern != null) {\n        data.gdipBrush = Gdip.Brush_Clone(pattern.handle);\n    } else {\n        data.gdipBrush = 0;\n    }\n    data.backgroundPattern = pattern;\n}",
			"comments":"/**\n* Sets the background pattern. The default value is <code>null</code>.\n*\n* @param pattern the new background pattern\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the parameter has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see Pattern\n*\n* @since 3.1\n*/\n",
			"methodName":"public void setBackgroundPattern(Pattern pattern)"
		},
		"public void setTextAntialias(int antialias)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (data.gdipGraphics == 0 && antialias == SWT.DEFAULT)\n        return;\n    int textMode = 0;\n    switch(antialias) {\n        case SWT.DEFAULT:\n            textMode = Gdip.TextRenderingHintSystemDefault;\n            break;\n        case SWT.OFF:\n            textMode = Gdip.TextRenderingHintSingleBitPerPixelGridFit;\n            break;\n        case SWT.ON:\n            int[] type = new int[1];\n            OS.SystemParametersInfo(OS.SPI_GETFONTSMOOTHINGTYPE, 0, type, 0);\n            if (type[0] == OS.FE_FONTSMOOTHINGCLEARTYPE) {\n                textMode = Gdip.TextRenderingHintClearTypeGridFit;\n            } else {\n                textMode = Gdip.TextRenderingHintAntiAliasGridFit;\n            }\n            break;\n        default:\n            SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    }\n    initGdip(false, false);\n    Gdip.Graphics_SetTextRenderingHint(data.gdipGraphics, textMode);\n}",
			"comments":"/**\n* Sets the receiver's text anti-aliasing value to the parameter,\n* which must be one of <code>SWT.DEFAULT</code>, <code>SWT.OFF</code>\n* or <code>SWT.ON</code>. Note that this controls anti-aliasing only\n* for all <em>text drawing</em> operations.\n*\n* @param antialias the anti-aliasing setting\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the parameter is not one of <code>SWT.DEFAULT</code>,\n*                                 <code>SWT.OFF</code> or <code>SWT.ON</code></li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #setAntialias\n*\n* @since 3.1\n*/\n",
			"methodName":"public void setTextAntialias(int antialias)"
		},
		"public void fillPolygon(int[] pointArray)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (pointArray == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (data.gdipGraphics != 0) {\n        initGdip(false, true);\n        int mode = OS.GetPolyFillMode(handle) == OS.WINDING ? Gdip.FillModeWinding : Gdip.FillModeAlternate;\n        Gdip.Graphics_FillPolygon(data.gdipGraphics, data.gdipBrush, pointArray, pointArray.length / 2, mode);\n        return;\n    }\n    int nullPen = OS.GetStockObject(OS.NULL_PEN);\n    int oldPen = OS.SelectObject(handle, nullPen);\n    OS.Polygon(handle, pointArray, pointArray.length / 2);\n    OS.SelectObject(handle, oldPen);\n}",
			"comments":"/**\n* Fills the interior of the closed polygon which is defined by the\n* specified array of integer coordinates, using the receiver's\n* background color. The array contains alternating x and y values\n* which are considered to represent points which are the vertices of\n* the polygon. Lines are drawn between each consecutive pair, and\n* between the first pair and last pair in the array.\n*\n* @param pointArray an array of alternating x and y values which are the vertices of the polygon\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT if pointArray is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #drawPolygon\n*/\n",
			"methodName":"public void fillPolygon(int[] pointArray)"
		},
		"public void copyArea(int srcX, int srcY, int width, int height, int destX, int destY, boolean paint)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    \n    int hwnd = data.hwnd;\n    if (hwnd == 0) {\n        OS.BitBlt(handle, destX, destY, width, height, handle, srcX, srcY, OS.SRCCOPY);\n    } else {\n        RECT lprcClip = null;\n        int hrgn = OS.CreateRectRgn(0, 0, 0, 0);\n        if (OS.GetClipRgn(handle, hrgn) == 1) {\n            lprcClip = new RECT();\n            OS.GetRgnBox(hrgn, lprcClip);\n        }\n        OS.DeleteObject(hrgn);\n        RECT lprcScroll = new RECT();\n        OS.SetRect(lprcScroll, srcX, srcY, srcX + width, srcY + height);\n        int flags = paint ? OS.SW_INVALIDATE | OS.SW_ERASE : 0;\n        int res = OS.ScrollWindowEx(hwnd, destX - srcX, destY - srcY, lprcScroll, lprcClip, 0, null, flags);\n        \n        if (res == 0 && OS.IsWinCE) {\n            OS.BitBlt(handle, destX, destY, width, height, handle, srcX, srcY, OS.SRCCOPY);\n            if (paint) {\n                int deltaX = destX - srcX, deltaY = destY - srcY;\n                boolean disjoint = (destX + width < srcX) || (srcX + width < destX) || (destY + height < srcY) || (srcY + height < destY);\n                if (disjoint) {\n                    OS.InvalidateRect(hwnd, lprcScroll, true);\n                } else {\n                    if (deltaX != 0) {\n                        int newX = destX - deltaX;\n                        if (deltaX < 0)\n                            newX = destX + width;\n                        OS.SetRect(lprcScroll, newX, srcY, newX + Math.abs(deltaX), srcY + height);\n                        OS.InvalidateRect(hwnd, lprcScroll, true);\n                    }\n                    if (deltaY != 0) {\n                        int newY = destY - deltaY;\n                        if (deltaY < 0)\n                            newY = destY + height;\n                        OS.SetRect(lprcScroll, srcX, newY, srcX + width, newY + Math.abs(deltaY));\n                        OS.InvalidateRect(hwnd, lprcScroll, true);\n                    }\n                }\n            }\n        }\n    }\n}",
			"comments":"/**\n* Copies a rectangular area of the receiver at the source\n* position onto the receiver at the destination position.\n*\n* @param srcX the x coordinate in the receiver of the area to be copied\n* @param srcY the y coordinate in the receiver of the area to be copied\n* @param width the width of the area to copy\n* @param height the height of the area to copy\n* @param destX the x coordinate in the receiver of the area to copy to\n* @param destY the y coordinate in the receiver of the area to copy to\n* @param paint if <code>true</code> paint events will be generated for old and obscured areas\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @since 3.1\n*/\n/*\n* Feature in WinCE.  The function WindowFromDC is not part of the\n* WinCE SDK.  The fix is to remember the HWND.\n*/\n/*\n* Feature in WinCE.  ScrollWindowEx does not accept combined\n* vertical and horizontal scrolling.  The fix is to do a\n* BitBlt and invalidate the appropriate source area.\n*/\n",
			"methodName":"public void copyArea(int srcX, int srcY, int width, int height, int destX, int destY, boolean paint)"
		},
		"public void drawArc(int x, int y, int width, int height, int startAngle, int arcAngle)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (width < 0) {\n        x = x + width;\n        width = -width;\n    }\n    if (height < 0) {\n        y = y + height;\n        height = -height;\n    }\n    if (width == 0 || height == 0 || arcAngle == 0)\n        return;\n    int gdipGraphics = data.gdipGraphics;\n    if (gdipGraphics != 0) {\n        initGdip(true, false);\n        if (data.lineWidth == 0 || (data.lineWidth % 2) == 1)\n            Gdip.Graphics_SetPixelOffsetMode(gdipGraphics, Gdip.PixelOffsetModeNone);\n        Gdip.Graphics_DrawArc(gdipGraphics, data.gdipPen, x, y, width, height, -startAngle, -arcAngle);\n        if (data.lineWidth == 0 || (data.lineWidth % 2) == 1)\n            Gdip.Graphics_SetPixelOffsetMode(gdipGraphics, Gdip.PixelOffsetModeHalf);\n        return;\n    }\n    \n    if (OS.IsWinCE) {\n        \n        if (arcAngle < 0) {\n            startAngle += arcAngle;\n            arcAngle = -arcAngle;\n        }\n        if (arcAngle > 360)\n            arcAngle = 360;\n        int[] points = new int[(arcAngle + 1) * 2];\n        int cteX = 2 * x + width;\n        int cteY = 2 * y + height;\n        int index = 0;\n        for (int i = 0; i <= arcAngle; i++) {\n            points[index++] = (Compatibility.cos(startAngle + i, width) + cteX) >> 1;\n            points[index++] = (cteY - Compatibility.sin(startAngle + i, height)) >> 1;\n        }\n        OS.Polyline(handle, points, points.length / 2);\n    } else {\n        int x1, y1, x2, y2, tmp;\n        boolean isNegative;\n        if (arcAngle >= 360 || arcAngle <= -360) {\n            x1 = x2 = x + width;\n            y1 = y2 = y + height / 2;\n        } else {\n            isNegative = arcAngle < 0;\n            arcAngle = arcAngle + startAngle;\n            if (isNegative) {\n                \n                tmp = startAngle;\n                startAngle = arcAngle;\n                arcAngle = tmp;\n            }\n            x1 = Compatibility.cos(startAngle, width) + x + width / 2;\n            y1 = -1 * Compatibility.sin(startAngle, height) + y + height / 2;\n            x2 = Compatibility.cos(arcAngle, width) + x + width / 2;\n            y2 = -1 * Compatibility.sin(arcAngle, height) + y + height / 2;\n        }\n        int nullBrush = OS.GetStockObject(OS.NULL_BRUSH);\n        int oldBrush = OS.SelectObject(handle, nullBrush);\n        OS.Arc(handle, x, y, x + width + 1, y + height + 1, x1, y1, x2, y2);\n        OS.SelectObject(handle, oldBrush);\n    }\n}",
			"comments":"/**\n* Draws the outline of a circular or elliptical arc\n* within the specified rectangular area.\n* <p>\n* The resulting arc begins at <code>startAngle</code> and extends\n* for <code>arcAngle</code> degrees, using the current color.\n* Angles are interpreted such that 0 degrees is at the 3 o'clock\n* position. A positive value indicates a counter-clockwise rotation\n* while a negative value indicates a clockwise rotation.\n* </p><p>\n* The center of the arc is the center of the rectangle whose origin\n* is (<code>x</code>, <code>y</code>) and whose size is specified by the\n* <code>width</code> and <code>height</code> arguments.\n* </p><p>\n* The resulting arc covers an area <code>width + 1</code> pixels wide\n* by <code>height + 1</code> pixels tall.\n* </p>\n*\n* @param x the x coordinate of the upper-left corner of the arc to be drawn\n* @param y the y coordinate of the upper-left corner of the arc to be drawn\n* @param width the width of the arc to be drawn\n* @param height the height of the arc to be drawn\n* @param startAngle the beginning angle\n* @param arcAngle the angular extent of the arc, relative to the start angle\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n/*\n* Feature in WinCE.  The function Arc is not present in the\n* WinCE SDK.  The fix is to emulate arc drawing by using\n* Polyline.\n*/\n/* compute arc with a simple linear interpolation */\n// swap angles\n",
			"methodName":"public void drawArc(int x, int y, int width, int height, int startAngle, int arcAngle)"
		},
		"public int getFillRule()":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (OS.IsWinCE)\n        return SWT.FILL_EVEN_ODD;\n    return OS.GetPolyFillMode(handle) == OS.WINDING ? SWT.FILL_WINDING : SWT.FILL_EVEN_ODD;\n}",
			"comments":"/**\n* Returns the receiver's fill rule, which will be one of\n* <code>SWT.FILL_EVEN_ODD</code> or <code>SWT.FILL_WINDING</code>.\n*\n* @return the receiver's fill rule\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public int getFillRule()"
		},
		"public void setLineJoin(int join)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    int joinStyle = 0;\n    switch(join) {\n        case SWT.JOIN_MITER:\n            joinStyle = OS.PS_JOIN_MITER;\n            break;\n        case SWT.JOIN_ROUND:\n            joinStyle = OS.PS_JOIN_ROUND;\n            break;\n        case SWT.JOIN_BEVEL:\n            joinStyle = OS.PS_JOIN_BEVEL;\n            break;\n        default:\n            SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    }\n    setPen(-1, -1, -1, -1, joinStyle, data.dashes);\n}",
			"comments":"/**\n* Sets the receiver's line join style to the argument, which must be one\n* of the constants <code>SWT.JOIN_MITER</code>, <code>SWT.JOIN_ROUND</code>,\n* or <code>SWT.JOIN_BEVEL</code>.\n*\n* @param join the join style to be used for drawing lines\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the style is not valid</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public void setLineJoin(int join)"
		},
		"int createGdipPen()":{
			"methodBody":"{\n    int style, colorRef, width, size, hPen = OS.GetCurrentObject(handle, OS.OBJ_PEN);\n    if ((size = OS.GetObject(hPen, 0, (LOGPEN) null)) == LOGPEN.sizeof) {\n        LOGPEN logPen = new LOGPEN();\n        OS.GetObject(hPen, LOGPEN.sizeof, logPen);\n        colorRef = logPen.lopnColor;\n        width = logPen.x;\n        style = logPen.lopnStyle;\n        \n        if (width <= 1) {\n            style |= OS.PS_ENDCAP_FLAT | OS.PS_JOIN_MITER;\n        }\n    } else {\n        EXTLOGPEN logPen = new EXTLOGPEN();\n        if (size <= EXTLOGPEN.sizeof) {\n            OS.GetObject(hPen, size, logPen);\n        } else {\n            int hHeap = OS.GetProcessHeap();\n            int ptr = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, size);\n            OS.GetObject(hPen, size, ptr);\n            OS.MoveMemory(logPen, ptr, EXTLOGPEN.sizeof);\n            OS.HeapFree(hHeap, 0, ptr);\n        }\n        colorRef = logPen.elpColor;\n        width = logPen.elpWidth;\n        style = logPen.elpPenStyle;\n    }\n    int rgb = ((colorRef >> 16) & 0xFF) | (colorRef & 0xFF00) | ((colorRef & 0xFF) << 16);\n    int color = Gdip.Color_new(data.alpha << 24 | rgb);\n    int pen = Gdip.Pen_new(color, Math.max(1, width));\n    Gdip.Color_delete(color);\n    if (data.foregroundPattern != null)\n        Gdip.Pen_SetBrush(pen, data.foregroundPattern.handle);\n    float[] dashes = null;\n    int dashStyle = Gdip.DashStyleSolid;\n    switch(style & OS.PS_STYLE_MASK) {\n        case OS.PS_SOLID:\n            break;\n        case OS.PS_DOT:\n            dashStyle = Gdip.DashStyleDot;\n            if (width == 0)\n                dashes = LINE_DOT_ZERO;\n            break;\n        case OS.PS_DASH:\n            dashStyle = Gdip.DashStyleDash;\n            if (width == 0)\n                dashes = LINE_DASH_ZERO;\n            break;\n        case OS.PS_DASHDOT:\n            dashStyle = Gdip.DashStyleDashDot;\n            if (width == 0)\n                dashes = LINE_DASHDOT_ZERO;\n            break;\n        case OS.PS_DASHDOTDOT:\n            dashStyle = Gdip.DashStyleDashDotDot;\n            if (width == 0)\n                dashes = LINE_DASHDOTDOT_ZERO;\n            break;\n        case OS.PS_USERSTYLE:\n            {\n                if (data.dashes != null) {\n                    dashes = new float[data.dashes.length * 2];\n                    for (int i = 0; i < data.dashes.length; i++) {\n                        float dash = (float) data.dashes[i] / Math.max(1, width);\n                        dashes[i] = dash;\n                        dashes[i + data.dashes.length] = dash;\n                    }\n                }\n            }\n    }\n    if (dashes != null) {\n        Gdip.Pen_SetDashPattern(pen, dashes, dashes.length);\n        Gdip.Pen_SetDashStyle(pen, Gdip.DashStyleCustom);\n    } else {\n        Gdip.Pen_SetDashStyle(pen, dashStyle);\n    }\n    int joinStyle = 0;\n    switch(style & OS.PS_JOIN_MASK) {\n        case OS.PS_JOIN_MITER:\n            joinStyle = Gdip.LineJoinMiter;\n            break;\n        case OS.PS_JOIN_BEVEL:\n            joinStyle = Gdip.LineJoinBevel;\n            break;\n        case OS.PS_JOIN_ROUND:\n            joinStyle = Gdip.LineJoinRound;\n            break;\n    }\n    Gdip.Pen_SetLineJoin(pen, joinStyle);\n    int dashCap = Gdip.DashCapFlat, capStyle = 0;\n    switch(style & OS.PS_ENDCAP_MASK) {\n        case OS.PS_ENDCAP_FLAT:\n            capStyle = Gdip.LineCapFlat;\n            break;\n        case OS.PS_ENDCAP_ROUND:\n            capStyle = Gdip.LineCapRound;\n            dashCap = Gdip.DashCapRound;\n            break;\n        case OS.PS_ENDCAP_SQUARE:\n            capStyle = Gdip.LineCapSquare;\n            break;\n    }\n    Gdip.Pen_SetLineCap(pen, capStyle, capStyle, dashCap);\n    return pen;\n}",
			"comments":"/*\n* Feature in Windows.  The default end caps is PS_ENDCAP_ROUND\n* and the default line join is PS_JOIN_ROUND which are different\n* from other platforms.  The fix is to change these values when\n* line width is widened.\n*/\n",
			"methodName":"int createGdipPen()"
		},
		"public void getClipping(Region region)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (region == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (region.isDisposed())\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    if (data.gdipGraphics != 0) {\n        int rgn = Gdip.Region_new();\n        Gdip.Graphics_GetClip(data.gdipGraphics, rgn);\n        int matrix = Gdip.Matrix_new(1, 0, 0, 1, 0, 0);\n        int identity = Gdip.Matrix_new(1, 0, 0, 1, 0, 0);\n        Gdip.Graphics_GetTransform(data.gdipGraphics, matrix);\n        Gdip.Graphics_SetTransform(data.gdipGraphics, identity);\n        int hRgn = Gdip.Region_GetHRGN(rgn, data.gdipGraphics);\n        Gdip.Graphics_SetTransform(data.gdipGraphics, matrix);\n        Gdip.Matrix_delete(identity);\n        Gdip.Matrix_delete(matrix);\n        OS.CombineRgn(region.handle, hRgn, 0, OS.RGN_COPY);\n        Gdip.Region_delete(rgn);\n        return;\n    }\n    POINT pt = new POINT();\n    OS.GetWindowOrgEx(handle, pt);\n    int result = OS.GetClipRgn(handle, region.handle);\n    if (result != 1) {\n        RECT rect = new RECT();\n        OS.GetClipBox(handle, rect);\n        OS.SetRectRgn(region.handle, rect.left, rect.top, rect.right, rect.bottom);\n    } else {\n        OS.OffsetRgn(region.handle, pt.x, pt.y);\n    }\n    if (!OS.IsWinCE) {\n        int metaRgn = OS.CreateRectRgn(0, 0, 0, 0);\n        if (OS.GetMetaRgn(handle, metaRgn) != 0) {\n            OS.OffsetRgn(metaRgn, pt.x, pt.y);\n            OS.CombineRgn(region.handle, metaRgn, region.handle, OS.RGN_AND);\n        }\n        OS.DeleteObject(metaRgn);\n        int flags = 0;\n        if (OS.WIN32_VERSION >= OS.VERSION(4, 10)) {\n            flags = OS.GetLayout(handle);\n        }\n        int hwnd = data.hwnd;\n        if (hwnd != 0 && data.ps != null && (flags & OS.LAYOUT_RTL) == 0) {\n            int sysRgn = OS.CreateRectRgn(0, 0, 0, 0);\n            if (OS.GetRandomRgn(handle, sysRgn, OS.SYSRGN) == 1) {\n                if (OS.IsWinNT) {\n                    OS.MapWindowPoints(0, hwnd, pt, 1);\n                    OS.OffsetRgn(sysRgn, pt.x, pt.y);\n                }\n                OS.CombineRgn(region.handle, sysRgn, region.handle, OS.RGN_AND);\n            }\n            OS.DeleteObject(sysRgn);\n        }\n    }\n}",
			"comments":"/**\n* Sets the region managed by the argument to the current\n* clipping region of the receiver.\n*\n* @param region the region to fill with the clipping region\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the region is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the region is disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void getClipping(Region region)"
		},
		"void flush()":{
			"methodBody":"{\n    if (data.gdipGraphics != 0) {\n        Gdip.Graphics_Flush(data.gdipGraphics, 0);\n        \n        int hdc = Gdip.Graphics_GetHDC(data.gdipGraphics);\n        Gdip.Graphics_ReleaseHDC(data.gdipGraphics, hdc);\n    }\n}",
			"comments":"/*\n* Note Flush() does not flush the output to the\n* underline HDC. This is done by calling GetHDC()\n* followed by ReleaseHDC().\n*/\n",
			"methodName":"void flush()"
		},
		"void setPen(int newColor, int newWidth, int lineStyle, int capStyle, int joinStyle, int[] dashes)":{
			"methodBody":"{\n    boolean extPen = false, changed = false;\n    int style, color, width, size, hPen = OS.GetCurrentObject(handle, OS.OBJ_PEN);\n    if ((size = OS.GetObject(hPen, 0, (LOGPEN) null)) == LOGPEN.sizeof) {\n        LOGPEN logPen = new LOGPEN();\n        OS.GetObject(hPen, LOGPEN.sizeof, logPen);\n        color = logPen.lopnColor;\n        width = logPen.x;\n        style = logPen.lopnStyle;\n        \n        if (width < 1 && (newWidth >= 1 || lineStyle == OS.PS_USERSTYLE)) {\n            if (capStyle == -1)\n                capStyle = OS.PS_ENDCAP_FLAT;\n            if (joinStyle == -1)\n                joinStyle = OS.PS_JOIN_MITER;\n        }\n    } else {\n        EXTLOGPEN logPen = new EXTLOGPEN();\n        if (size <= EXTLOGPEN.sizeof) {\n            OS.GetObject(hPen, size, logPen);\n        } else {\n            int hHeap = OS.GetProcessHeap();\n            int ptr = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, size);\n            OS.GetObject(hPen, size, ptr);\n            OS.MoveMemory(logPen, ptr, EXTLOGPEN.sizeof);\n            OS.HeapFree(hHeap, 0, ptr);\n        }\n        color = logPen.elpColor;\n        width = logPen.elpWidth;\n        style = logPen.elpPenStyle;\n        extPen = true;\n        if (newWidth == 0) {\n            if (dashes == null && (style & OS.PS_ENDCAP_MASK) == OS.PS_ENDCAP_FLAT && (style & OS.PS_JOIN_MASK) == OS.PS_JOIN_MITER) {\n                style &= ~(OS.PS_ENDCAP_MASK | OS.PS_JOIN_MASK | OS.PS_TYPE_MASK);\n                extPen = false;\n            }\n        }\n    }\n    if (newColor != -1) {\n        if (newColor != color) {\n            color = newColor;\n            changed = true;\n        }\n    }\n    if (newWidth != -1) {\n        if (newWidth != width) {\n            width = newWidth;\n            changed = true;\n        }\n    }\n    if (lineStyle != -1) {\n        if ((style & OS.PS_STYLE_MASK) != lineStyle || (style & OS.PS_STYLE_MASK) == OS.PS_USERSTYLE) {\n            style = (style & ~OS.PS_STYLE_MASK) | lineStyle;\n            changed = true;\n        }\n    }\n    if (capStyle != -1) {\n        if ((style & OS.PS_ENDCAP_MASK) != capStyle) {\n            style = (style & ~OS.PS_ENDCAP_MASK) | capStyle;\n            changed = true;\n        }\n    }\n    if (joinStyle != -1) {\n        if ((style & OS.PS_JOIN_MASK) != joinStyle) {\n            style = (style & ~OS.PS_JOIN_MASK) | joinStyle;\n            changed = true;\n        }\n    }\n    if (!changed)\n        return;\n    if ((style & OS.PS_STYLE_MASK) != OS.PS_USERSTYLE)\n        dashes = null;\n    \n    int newPen;\n    if (!OS.IsWinCE && (extPen || width >= 1 || (style & OS.PS_STYLE_MASK) == OS.PS_USERSTYLE)) {\n        LOGBRUSH logBrush = new LOGBRUSH();\n        logBrush.lbStyle = OS.BS_SOLID;\n        logBrush.lbColor = color;\n        \n        newPen = OS.ExtCreatePen(style | OS.PS_GEOMETRIC, Math.max(1, width), logBrush, dashes != null ? dashes.length : 0, dashes);\n    } else {\n        newPen = OS.CreatePen(style, width, color);\n    }\n    OS.SelectObject(handle, newPen);\n    if (data.hPen != 0)\n        OS.DeleteObject(data.hPen);\n    data.hPen = newPen;\n    data.lineWidth = width;\n    if (data.gdipPen != 0) {\n        Gdip.Pen_delete(data.gdipPen);\n        data.gdipPen = 0;\n    }\n}",
			"comments":"/*\n* Feature in Windows.  The default end caps is PS_ENDCAP_ROUND\n* and the default line join is PS_JOIN_ROUND which are different\n* from other platforms.  The fix is to change these values when\n* line width is widened.\n*/\n/*\n* Feature in Windows.  Windows does not honour line styles other then\n* PS_SOLID for pens wider than 1 pixel created with CreatePen().  The fix\n* is to use ExtCreatePen() instead.\n*/\n/* Feature in Windows. PS_GEOMETRIC pens cannot have zero width. */\n",
			"methodName":"void setPen(int newColor, int newWidth, int lineStyle, int capStyle, int joinStyle, int[] dashes)"
		},
		"public Point textExtent(String string, int flags)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (string == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (data.gdipGraphics != 0) {\n        int font = createGdipFont();\n        PointF pt = new PointF();\n        RectF bounds = new RectF();\n        char[] buffer;\n        int length = string.length();\n        if (length != 0) {\n            buffer = new char[length];\n            string.getChars(0, length, buffer, 0);\n        } else {\n            buffer = new char[] { ' ' };\n        }\n        int format = Gdip.StringFormat_Clone(Gdip.StringFormat_GenericTypographic());\n        Gdip.StringFormat_SetFormatFlags(format, Gdip.StringFormat_GetFormatFlags(format) | Gdip.StringFormatFlagsMeasureTrailingSpaces);\n        float[] tabs = (flags & SWT.DRAW_TAB) != 0 ? new float[] { measureSpace(font, format) * 8 } : new float[1];\n        Gdip.StringFormat_SetTabStops(format, 0, tabs.length, tabs);\n        Gdip.StringFormat_SetHotkeyPrefix(format, (flags & SWT.DRAW_MNEMONIC) != 0 ? Gdip.HotkeyPrefixShow : Gdip.HotkeyPrefixNone);\n        Gdip.Graphics_MeasureString(data.gdipGraphics, buffer, buffer.length, font, pt, format, bounds);\n        Gdip.StringFormat_delete(format);\n        Gdip.Font_delete(font);\n        return new Point(length == 0 ? 0 : Math.round(bounds.Width), Math.round(bounds.Height));\n    }\n    if (string.length() == 0) {\n        SIZE size = new SIZE();\n        \n        OS.GetTextExtentPoint32W(handle, new char[] { ' ' }, 1, size);\n        return new Point(0, size.cy);\n    }\n    RECT rect = new RECT();\n    TCHAR buffer = new TCHAR(getCodePage(), string, false);\n    int uFormat = OS.DT_LEFT | OS.DT_CALCRECT;\n    if ((flags & SWT.DRAW_DELIMITER) == 0)\n        uFormat |= OS.DT_SINGLELINE;\n    if ((flags & SWT.DRAW_TAB) != 0)\n        uFormat |= OS.DT_EXPANDTABS;\n    if ((flags & SWT.DRAW_MNEMONIC) == 0)\n        uFormat |= OS.DT_NOPREFIX;\n    OS.DrawText(handle, buffer, buffer.length(), rect, uFormat);\n    return new Point(rect.right, rect.bottom);\n}",
			"comments":"/**\n* Returns the extent of the given string. Tab expansion, line\n* delimiter and mnemonic processing are performed according to\n* the specified flags, which can be a combination of:\n* <dl>\n* <dt><b>DRAW_DELIMITER</b></dt>\n* <dd>draw multiple lines</dd>\n* <dt><b>DRAW_TAB</b></dt>\n* <dd>expand tabs</dd>\n* <dt><b>DRAW_MNEMONIC</b></dt>\n* <dd>underline the mnemonic character</dd>\n* <dt><b>DRAW_TRANSPARENT</b></dt>\n* <dd>transparent background</dd>\n* </dl>\n* <p>\n* The <em>extent</em> of a string is the width and height of\n* the rectangular area it would cover if drawn in a particular\n* font (in this case, the current font in the receiver).\n* </p>\n*\n* @param string the string to measure\n* @param flags the flags specifing how to process the text\n* @return a point containing the extent of the string\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the string is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n//\t\tOS.GetTextExtentPoint32(handle, SPACE, SPACE.length(), size);\n",
			"methodName":"public Point textExtent(String string, int flags)"
		},
		"public int getLineJoin()":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    int style, size;\n    int hPen = OS.GetCurrentObject(handle, OS.OBJ_PEN);\n    if ((size = OS.GetObject(hPen, 0, (LOGPEN) null)) == LOGPEN.sizeof) {\n        LOGPEN logPen = new LOGPEN();\n        OS.GetObject(hPen, LOGPEN.sizeof, logPen);\n        style = logPen.lopnStyle | OS.PS_JOIN_MITER;\n    } else {\n        EXTLOGPEN logPen = new EXTLOGPEN();\n        if (size <= EXTLOGPEN.sizeof) {\n            OS.GetObject(hPen, size, logPen);\n        } else {\n            int hHeap = OS.GetProcessHeap();\n            int ptr = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, size);\n            OS.GetObject(hPen, size, ptr);\n            OS.MoveMemory(logPen, ptr, EXTLOGPEN.sizeof);\n            OS.HeapFree(hHeap, 0, ptr);\n        }\n        style = logPen.elpPenStyle & OS.PS_JOIN_MASK;\n    }\n    int join = SWT.JOIN_ROUND;\n    switch(style) {\n        case OS.PS_JOIN_MITER:\n            join = SWT.JOIN_MITER;\n            break;\n        case OS.PS_JOIN_ROUND:\n            join = SWT.JOIN_ROUND;\n            break;\n        case OS.PS_JOIN_BEVEL:\n            join = SWT.JOIN_BEVEL;\n            break;\n    }\n    return join;\n}",
			"comments":"/**\n* Returns the receiver's line join style, which will be one\n* of the constants <code>SWT.JOIN_MITER</code>, <code>SWT.JOIN_ROUND</code>,\n* or <code>SWT.JOIN_BEVEL</code>.\n*\n* @return the join style used for drawing lines\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public int getLineJoin()"
		},
		"public Pattern getBackgroundPattern()":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    return data.backgroundPattern;\n}",
			"comments":"/**\n* Returns the background pattern. The default value is\n* <code>null</code>.\n*\n* @return the receiver's background pattern\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see Pattern\n*\n* @since 3.1\n*/\n",
			"methodName":"public Pattern getBackgroundPattern()"
		},
		"public void drawPoint(int x, int y)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    OS.SetPixel(handle, x, y, OS.GetTextColor(handle));\n}",
			"comments":"/**\n* Draws a pixel, using the foreground color, at the specified\n* point (<code>x</code>, <code>y</code>).\n* <p>\n* Note that the receiver's line attributes do not affect this\n* operation.\n* </p>\n*\n* @param x the point's x coordinate\n* @param y the point's y coordinate\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public void drawPoint(int x, int y)"
		},
		"public void setClipping(Rectangle rect)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (rect == null) {\n        setClipping(0);\n    } else {\n        setClipping(rect.x, rect.y, rect.width, rect.height);\n    }\n}",
			"comments":"/**\n* Sets the area of the receiver which can be changed\n* by drawing operations to the rectangular area specified\n* by the argument.  Specifying <code>null</code> for the\n* rectangle reverts the receiver's clipping area to its\n* original value.\n*\n* @param rect the clipping rectangle or <code>null</code>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void setClipping(Rectangle rect)"
		},
		"public boolean isDisposed()":{
			"methodBody":"{\n    return handle == 0;\n}",
			"comments":"/**\n* Returns <code>true</code> if the GC has been disposed,\n* and <code>false</code> otherwise.\n* <p>\n* This method gets the dispose state for the GC.\n* When a GC has been disposed, it is an error to\n* invoke any other method using the GC.\n*\n* @return <code>true</code> when the GC is disposed and <code>false</code> otherwise\n*/\n",
			"methodName":"public boolean isDisposed()"
		},
		"public int getTextAntialias()":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (data.gdipGraphics == 0)\n        return SWT.DEFAULT;\n    int mode = Gdip.Graphics_GetTextRenderingHint(data.gdipGraphics);\n    switch(mode) {\n        case Gdip.TextRenderingHintSystemDefault:\n            return SWT.DEFAULT;\n        case Gdip.TextRenderingHintSingleBitPerPixel:\n        case Gdip.TextRenderingHintSingleBitPerPixelGridFit:\n            return SWT.OFF;\n        case Gdip.TextRenderingHintAntiAlias:\n        case Gdip.TextRenderingHintAntiAliasGridFit:\n        case Gdip.TextRenderingHintClearTypeGridFit:\n            return SWT.ON;\n    }\n    return SWT.DEFAULT;\n}",
			"comments":"/**\n* Returns the receiver's text drawing anti-aliasing setting value,\n* which will be one of <code>SWT.DEFAULT</code>, <code>SWT.OFF</code> or\n* <code>SWT.ON</code>. Note that this controls anti-aliasing\n* <em>only</em> for text drawing operations.\n*\n* @return the anti-aliasing setting\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #getAntialias\n*\n* @since 3.1\n*/\n",
			"methodName":"public int getTextAntialias()"
		},
		"public int getAdvanceWidth(char ch)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (OS.IsWinCE) {\n        SIZE size = new SIZE();\n        OS.GetTextExtentPoint32W(handle, new char[] { ch }, 1, size);\n        return size.cx;\n    }\n    int tch = ch;\n    if (ch > 0x7F) {\n        TCHAR buffer = new TCHAR(getCodePage(), ch, false);\n        tch = buffer.tcharAt(0);\n    }\n    int[] width = new int[1];\n    OS.GetCharWidth(handle, tch, tch, width);\n    return width[0];\n}",
			"comments":"/**\n* Returns the <em>advance width</em> of the specified character in\n* the font which is currently selected into the receiver.\n* <p>\n* The advance width is defined as the horizontal distance the cursor\n* should move after printing the character in the selected font.\n* </p>\n*\n* @param ch the character to measure\n* @return the distance in the x direction to move past the character before painting the next\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public int getAdvanceWidth(char ch)"
		},
		"public void setTransform(Transform transform)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (transform != null && transform.isDisposed())\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    if (data.gdipGraphics == 0 && transform == null)\n        return;\n    initGdip(false, false);\n    if (transform != null) {\n        Gdip.Graphics_SetTransform(data.gdipGraphics, transform.handle);\n    } else {\n        int identity = Gdip.Matrix_new(1, 0, 0, 1, 0, 0);\n        Gdip.Graphics_SetTransform(data.gdipGraphics, identity);\n        Gdip.Matrix_delete(identity);\n    }\n}",
			"comments":"/**\n* Sets the transform that is currently being used by the receiver. If\n* the argument is <code>null</code>, the current transform is set to\n* the identity transform.\n*\n* @param transform the transform to set\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the parameter has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see Transform\n*\n* @since 3.1\n*/\n",
			"methodName":"public void setTransform(Transform transform)"
		},
		"public void drawString(String string, int x, int y, boolean isTransparent)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (string == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    \n    int length = string.length();\n    if (length == 0)\n        return;\n    char[] buffer = new char[length];\n    string.getChars(0, length, buffer, 0);\n    if (data.gdipGraphics != 0) {\n        initGdip(true, !isTransparent);\n        int font = createGdipFont();\n        PointF pt = new PointF();\n        pt.X = x;\n        pt.Y = y;\n        int brush = Gdip.Pen_GetBrush(data.gdipPen);\n        int format = Gdip.StringFormat_Clone(Gdip.StringFormat_GenericTypographic());\n        Gdip.StringFormat_SetFormatFlags(format, Gdip.StringFormat_GetFormatFlags(format) | Gdip.StringFormatFlagsMeasureTrailingSpaces);\n        if (!isTransparent) {\n            RectF bounds = new RectF();\n            Gdip.Graphics_MeasureString(data.gdipGraphics, buffer, length, font, pt, format, bounds);\n            Gdip.Graphics_FillRectangle(data.gdipGraphics, data.gdipBrush, (int) bounds.X, (int) bounds.Y, Math.round(bounds.Width), Math.round(bounds.Height));\n        }\n        Gdip.Graphics_DrawString(data.gdipGraphics, buffer, length, font, pt, format, brush);\n        Gdip.StringFormat_delete(format);\n        Gdip.Font_delete(font);\n        return;\n    }\n    int rop2 = 0;\n    if (OS.IsWinCE) {\n        rop2 = OS.SetROP2(handle, OS.R2_COPYPEN);\n        OS.SetROP2(handle, rop2);\n    } else {\n        rop2 = OS.GetROP2(handle);\n    }\n    int oldBkMode = OS.SetBkMode(handle, isTransparent ? OS.TRANSPARENT : OS.OPAQUE);\n    if (rop2 != OS.R2_XORPEN) {\n        OS.ExtTextOutW(handle, x, y, 0, null, buffer, length, null);\n    } else {\n        int foreground = OS.GetTextColor(handle);\n        if (isTransparent) {\n            SIZE size = new SIZE();\n            OS.GetTextExtentPoint32W(handle, buffer, length, size);\n            int width = size.cx, height = size.cy;\n            int hBitmap = OS.CreateCompatibleBitmap(handle, width, height);\n            if (hBitmap == 0)\n                SWT.error(SWT.ERROR_NO_HANDLES);\n            int memDC = OS.CreateCompatibleDC(handle);\n            int hOldBitmap = OS.SelectObject(memDC, hBitmap);\n            OS.PatBlt(memDC, 0, 0, width, height, OS.BLACKNESS);\n            OS.SetBkMode(memDC, OS.TRANSPARENT);\n            OS.SetTextColor(memDC, foreground);\n            OS.SelectObject(memDC, OS.GetCurrentObject(handle, OS.OBJ_FONT));\n            OS.ExtTextOutW(memDC, 0, 0, 0, null, buffer, length, null);\n            OS.BitBlt(handle, x, y, width, height, memDC, 0, 0, OS.SRCINVERT);\n            OS.SelectObject(memDC, hOldBitmap);\n            OS.DeleteDC(memDC);\n            OS.DeleteObject(hBitmap);\n        } else {\n            int background = OS.GetBkColor(handle);\n            OS.SetTextColor(handle, foreground ^ background);\n            OS.ExtTextOutW(handle, x, y, 0, null, buffer, length, null);\n            OS.SetTextColor(handle, foreground);\n        }\n    }\n    OS.SetBkMode(handle, oldBkMode);\n}",
			"comments":"/**\n* Draws the given string, using the receiver's current font and\n* foreground color. No tab expansion or carriage return processing\n* will be performed. If <code>isTransparent</code> is <code>true</code>,\n* then the background of the rectangular area where the string is being\n* drawn will not be modified, otherwise it will be filled with the\n* receiver's background color.\n*\n* @param string the string to be drawn\n* @param x the x coordinate of the top left corner of the rectangular area where the string is to be drawn\n* @param y the y coordinate of the top left corner of the rectangular area where the string is to be drawn\n* @param isTransparent if <code>true</code> the background will be transparent, otherwise it will be opaque\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the string is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n//\tTCHAR buffer = new TCHAR (getCodePage(), string, false);\n",
			"methodName":"public void drawString(String string, int x, int y, boolean isTransparent)"
		},
		"public void setAdvanced(boolean advanced)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (advanced && data.gdipGraphics != 0)\n        return;\n    if (advanced) {\n        try {\n            initGdip(false, false);\n        } catch (SWTException e) {\n        }\n    } else {\n        if (data.gdipGraphics != 0)\n            Gdip.Graphics_delete(data.gdipGraphics);\n        if (data.gdipPen != 0)\n            Gdip.Pen_delete(data.gdipPen);\n        if (data.gdipBrush != 0)\n            destroyGdipBrush(data.gdipBrush);\n        data.gdipGraphics = data.gdipBrush = data.gdipPen = 0;\n        data.alpha = 0xFF;\n        data.backgroundPattern = data.foregroundPattern = null;\n        setClipping(0);\n        if (data.hPen != 0)\n            OS.SelectObject(handle, data.hPen);\n        if (data.hBrush != 0)\n            OS.SelectObject(handle, data.hBrush);\n    }\n}",
			"comments":"/**\n* Sets the receiver to always use the operating system's advanced graphics\n* subsystem for all graphics operations if the argument is <code>true</code>.\n* If the argument is <code>false</code>, the advanced graphics subsystem is\n* no longer used, advanced graphics state is cleared and the normal graphics\n* subsystem is used from now on.\n* <p>\n* Normally, the advanced graphics subsystem is invoked automatically when\n* any one of the alpha, antialias, patterns, interpolation, paths, clipping\n* or transformation operations in the receiver is requested.  When the receiver\n* is switched into advanced mode, the advanced graphics subsystem performs both\n* advanced and normal graphics operations.  Because the two subsystems are\n* different, their output may differ.  Switching to advanced graphics before\n* any graphics operations are performed ensures that the output is consistent.\n* </p>\n* <p>\n* Advanced graphics may not be installed for the operating system.  In this\n* case, this operation does nothing.  Some operating system have only one\n* graphics subsystem, so switching from normal to advanced graphics does\n* nothing.  However, switching from advanced to normal graphics will always\n* clear the advanced graphics state, even for operating systems that have\n* only one graphics subsystem.\n* </p>\n*\n* @param advanced the new advanced graphics state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #setAlpha\n* @see #setAntialias\n* @see #setBackgroundPattern\n* @see #setClipping(Path)\n* @see #setForegroundPattern\n* @see #setInterpolation\n* @see #setTextAntialias\n* @see #setTransform\n* @see #getAdvanced\n*\n* @since 3.1\n*/\n",
			"methodName":"public void setAdvanced(boolean advanced)"
		},
		"void init(Drawable drawable, GCData data, int hDC)":{
			"methodBody":"{\n    int foreground = data.foreground;\n    if (foreground != -1 && OS.GetTextColor(hDC) != foreground) {\n        OS.SetTextColor(hDC, foreground);\n        int newPen = OS.CreatePen(OS.PS_SOLID, 0, foreground);\n        OS.SelectObject(hDC, newPen);\n        if (data.hPen != 0)\n            OS.DeleteObject(data.hPen);\n        data.hPen = newPen;\n    }\n    int background = data.background;\n    if (background != -1 && OS.GetBkColor(hDC) != background) {\n        OS.SetBkColor(hDC, background);\n        int newBrush = OS.CreateSolidBrush(background);\n        OS.SelectObject(hDC, newBrush);\n        if (data.hBrush != 0)\n            OS.DeleteObject(data.hBrush);\n        data.hBrush = newBrush;\n    }\n    int hFont = data.hFont;\n    if (hFont != 0)\n        OS.SelectObject(hDC, hFont);\n    int hPalette = data.device.hPalette;\n    if (hPalette != 0) {\n        OS.SelectPalette(hDC, hPalette, true);\n        OS.RealizePalette(hDC);\n    }\n    Image image = data.image;\n    if (image != null) {\n        data.hNullBitmap = OS.SelectObject(hDC, image.handle);\n        image.memGC = this;\n    }\n    int layout = data.layout;\n    if (layout != -1) {\n        if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION(4, 10)) {\n            int flags = OS.GetLayout(hDC);\n            if ((flags & OS.LAYOUT_RTL) != (layout & OS.LAYOUT_RTL)) {\n                flags &= ~OS.LAYOUT_RTL;\n                OS.SetLayout(hDC, flags | layout);\n            }\n            if ((data.style & SWT.RIGHT_TO_LEFT) != 0)\n                data.style |= SWT.MIRRORED;\n        }\n    }\n    this.drawable = drawable;\n    this.data = data;\n    handle = hDC;\n}",
			"comments":"",
			"methodName":"void init(Drawable drawable, GCData data, int hDC)"
		},
		"public void setBackground(Color color)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (color == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (color.isDisposed())\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    if (data.backgroundPattern != null) {\n        if (data.gdipBrush != 0) {\n            destroyGdipBrush(data.gdipBrush);\n            data.gdipBrush = 0;\n        }\n        data.backgroundPattern = null;\n    }\n    if (OS.GetBkColor(handle) == color.handle)\n        return;\n    data.background = color.handle;\n    OS.SetBkColor(handle, color.handle);\n    int newBrush = OS.CreateSolidBrush(color.handle);\n    OS.SelectObject(handle, newBrush);\n    if (data.hBrush != 0)\n        OS.DeleteObject(data.hBrush);\n    data.hBrush = newBrush;\n    if (data.gdipBrush != 0) {\n        destroyGdipBrush(data.gdipBrush);\n        data.gdipBrush = 0;\n    }\n}",
			"comments":"/**\n* Sets the background color. The background color is used\n* for fill operations and as the background color when text\n* is drawn.\n*\n* @param color the new background color for the receiver\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the color is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the color has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void setBackground(Color color)"
		},
		"public void dispose()":{
			"methodBody":"{\n    if (handle == 0)\n        return;\n    if (data.device.isDisposed())\n        return;\n    if (data.gdipGraphics != 0)\n        Gdip.Graphics_delete(data.gdipGraphics);\n    if (data.gdipPen != 0)\n        Gdip.Pen_delete(data.gdipPen);\n    if (data.gdipBrush != 0)\n        destroyGdipBrush(data.gdipBrush);\n    data.gdipBrush = data.gdipPen = data.gdipGraphics = 0;\n    \n    if (data.hPen != 0) {\n        int nullPen = OS.GetStockObject(OS.NULL_PEN);\n        OS.SelectObject(handle, nullPen);\n        OS.DeleteObject(data.hPen);\n        data.hPen = 0;\n    }\n    if (data.hBrush != 0) {\n        int nullBrush = OS.GetStockObject(OS.NULL_BRUSH);\n        OS.SelectObject(handle, nullBrush);\n        OS.DeleteObject(data.hBrush);\n        data.hBrush = 0;\n    }\n    \n    int hNullBitmap = data.hNullBitmap;\n    if (hNullBitmap != 0) {\n        OS.SelectObject(handle, hNullBitmap);\n        data.hNullBitmap = 0;\n    }\n    Image image = data.image;\n    if (image != null)\n        image.memGC = null;\n    \n    Device device = data.device;\n    if (drawable != null)\n        drawable.internal_dispose_GC(handle, data);\n    drawable = null;\n    handle = 0;\n    data.image = null;\n    data.ps = null;\n    if (device.tracking)\n        device.dispose_Object(this);\n    data.device = null;\n    data = null;\n}",
			"comments":"/**\n* Disposes of the operating system resources associated with\n* the graphics context. Applications must dispose of all GCs\n* which they allocate.\n*/\n/* Select stock pen and brush objects and free resources */\n/*\n* Put back the original bitmap into the device context.\n* This will ensure that we have not left a bitmap\n* selected in it when we delete the HDC.\n*/\n/*\n* Dispose the HDC.\n*/\n",
			"methodName":"public void dispose()"
		},
		"void drawBitmapAlpha(Image srcImage, int srcX, int srcY, int srcWidth, int srcHeight, int destX, int destY, int destWidth, int destHeight, boolean simple, BITMAP bm, int imgWidth, int imgHeight)":{
			"methodBody":"{\n    \n    if (srcImage.alpha == 0)\n        return;\n    if (srcImage.alpha == 255) {\n        drawBitmap(srcImage, srcX, srcY, srcWidth, srcHeight, destX, destY, destWidth, destHeight, simple, bm, imgWidth, imgHeight);\n        return;\n    }\n    if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION(4, 10)) {\n        \n        boolean fixAlpha = false;\n        int dstBitmap = OS.GetCurrentObject(handle, OS.OBJ_BITMAP);\n        if (dstBitmap != 0) {\n            BITMAP dstBM = new BITMAP();\n            OS.GetObject(dstBitmap, BITMAP.sizeof, dstBM);\n            fixAlpha = dstBM.bmPlanes * dstBM.bmBitsPixel == 32;\n        }\n        int dstDib = 0, oldDstBitmap = 0, dstHdc = handle, dstX = destX, dstY = destY;\n        if (fixAlpha) {\n            dstDib = Image.createDIB(destWidth, destHeight, 24);\n            if (dstDib == 0)\n                SWT.error(SWT.ERROR_NO_HANDLES);\n            dstHdc = OS.CreateCompatibleDC(handle);\n            oldDstBitmap = OS.SelectObject(dstHdc, dstDib);\n            OS.BitBlt(dstHdc, 0, 0, destWidth, destHeight, handle, destX, destY, OS.SRCCOPY);\n            dstX = dstY = 0;\n        }\n        BLENDFUNCTION blend = new BLENDFUNCTION();\n        blend.BlendOp = OS.AC_SRC_OVER;\n        int srcHdc = OS.CreateCompatibleDC(handle);\n        int oldSrcBitmap = OS.SelectObject(srcHdc, srcImage.handle);\n        if (srcImage.alpha != -1) {\n            blend.SourceConstantAlpha = (byte) srcImage.alpha;\n            OS.AlphaBlend(dstHdc, dstX, dstY, destWidth, destHeight, srcHdc, srcX, srcY, srcWidth, srcHeight, blend);\n        } else {\n            int memDib = Image.createDIB(srcWidth, srcHeight, 32);\n            if (memDib == 0)\n                SWT.error(SWT.ERROR_NO_HANDLES);\n            int memHdc = OS.CreateCompatibleDC(handle);\n            int oldMemBitmap = OS.SelectObject(memHdc, memDib);\n            BITMAP dibBM = new BITMAP();\n            OS.GetObject(memDib, BITMAP.sizeof, dibBM);\n            OS.BitBlt(memHdc, 0, 0, srcWidth, srcHeight, srcHdc, srcX, srcY, OS.SRCCOPY);\n            byte[] srcData = new byte[dibBM.bmWidthBytes * dibBM.bmHeight];\n            OS.MoveMemory(srcData, dibBM.bmBits, srcData.length);\n            final int apinc = imgWidth - srcWidth;\n            int ap = srcY * imgWidth + srcX, sp = 0;\n            byte[] alphaData = srcImage.alphaData;\n            for (int y = 0; y < srcHeight; ++y) {\n                for (int x = 0; x < srcWidth; ++x) {\n                    int alpha = alphaData[ap++] & 0xff;\n                    srcData[sp + 0] = (byte) ((srcData[sp + 0] & 0xff) * alpha / 255);\n                    srcData[sp + 1] = (byte) ((srcData[sp + 1] & 0xff) * alpha / 255);\n                    srcData[sp + 2] = (byte) ((srcData[sp + 2] & 0xff) * alpha / 255);\n                    srcData[sp + 3] = (byte) alpha;\n                    sp += 4;\n                }\n                ap += apinc;\n            }\n            OS.MoveMemory(dibBM.bmBits, srcData, srcData.length);\n            blend.SourceConstantAlpha = (byte) 0xff;\n            blend.AlphaFormat = OS.AC_SRC_ALPHA;\n            OS.AlphaBlend(dstHdc, dstX, dstY, destWidth, destHeight, memHdc, 0, 0, srcWidth, srcHeight, blend);\n            OS.SelectObject(memHdc, oldMemBitmap);\n            OS.DeleteDC(memHdc);\n            OS.DeleteObject(memDib);\n        }\n        if (fixAlpha) {\n            OS.BitBlt(handle, destX, destY, destWidth, destHeight, dstHdc, 0, 0, OS.SRCCOPY);\n            OS.SelectObject(dstHdc, oldDstBitmap);\n            OS.DeleteDC(dstHdc);\n            OS.DeleteObject(dstDib);\n        }\n        OS.SelectObject(srcHdc, oldSrcBitmap);\n        OS.DeleteDC(srcHdc);\n        return;\n    }\n    \n    Rectangle rect = getClipping();\n    rect = rect.intersection(new Rectangle(destX, destY, destWidth, destHeight));\n    if (rect.isEmpty())\n        return;\n    \n    int sx1 = srcX + (((rect.x - destX) * srcWidth) / destWidth);\n    int sx2 = srcX + ((((rect.x + rect.width) - destX) * srcWidth) / destWidth);\n    int sy1 = srcY + (((rect.y - destY) * srcHeight) / destHeight);\n    int sy2 = srcY + ((((rect.y + rect.height) - destY) * srcHeight) / destHeight);\n    destX = rect.x;\n    destY = rect.y;\n    destWidth = rect.width;\n    destHeight = rect.height;\n    srcX = sx1;\n    srcY = sy1;\n    srcWidth = Math.max(1, sx2 - sx1);\n    srcHeight = Math.max(1, sy2 - sy1);\n    \n    int srcHdc = OS.CreateCompatibleDC(handle);\n    int oldSrcBitmap = OS.SelectObject(srcHdc, srcImage.handle);\n    int memHdc = OS.CreateCompatibleDC(handle);\n    int memDib = Image.createDIB(Math.max(srcWidth, destWidth), Math.max(srcHeight, destHeight), 32);\n    if (memDib == 0)\n        SWT.error(SWT.ERROR_NO_HANDLES);\n    int oldMemBitmap = OS.SelectObject(memHdc, memDib);\n    BITMAP dibBM = new BITMAP();\n    OS.GetObject(memDib, BITMAP.sizeof, dibBM);\n    int sizeInBytes = dibBM.bmWidthBytes * dibBM.bmHeight;\n    \n    OS.BitBlt(memHdc, 0, 0, destWidth, destHeight, handle, destX, destY, OS.SRCCOPY);\n    byte[] destData = new byte[sizeInBytes];\n    OS.MoveMemory(destData, dibBM.bmBits, sizeInBytes);\n    \n    OS.BitBlt(memHdc, 0, 0, srcWidth, srcHeight, srcHdc, srcX, srcY, OS.SRCCOPY);\n    byte[] srcData = new byte[sizeInBytes];\n    OS.MoveMemory(srcData, dibBM.bmBits, sizeInBytes);\n    \n    int alpha = srcImage.alpha;\n    final boolean hasAlphaChannel = (srcImage.alpha == -1);\n    if (hasAlphaChannel) {\n        final int apinc = imgWidth - srcWidth;\n        final int spinc = dibBM.bmWidthBytes - srcWidth * 4;\n        int ap = srcY * imgWidth + srcX, sp = 3;\n        byte[] alphaData = srcImage.alphaData;\n        for (int y = 0; y < srcHeight; ++y) {\n            for (int x = 0; x < srcWidth; ++x) {\n                srcData[sp] = alphaData[ap++];\n                sp += 4;\n            }\n            ap += apinc;\n            sp += spinc;\n        }\n    }\n    \n    OS.MoveMemory(dibBM.bmBits, srcData, sizeInBytes);\n    \n    if ((OS.IsWinCE && (destWidth > srcWidth || destHeight > srcHeight)) || (!OS.IsWinNT && !OS.IsWinCE)) {\n        int tempHdc = OS.CreateCompatibleDC(handle);\n        int tempDib = Image.createDIB(destWidth, destHeight, 32);\n        if (tempDib == 0)\n            SWT.error(SWT.ERROR_NO_HANDLES);\n        int oldTempBitmap = OS.SelectObject(tempHdc, tempDib);\n        if (!simple && (srcWidth != destWidth || srcHeight != destHeight)) {\n            if (!OS.IsWinCE)\n                OS.SetStretchBltMode(memHdc, OS.COLORONCOLOR);\n            OS.StretchBlt(tempHdc, 0, 0, destWidth, destHeight, memHdc, 0, 0, srcWidth, srcHeight, OS.SRCCOPY);\n        } else {\n            OS.BitBlt(tempHdc, 0, 0, destWidth, destHeight, memHdc, 0, 0, OS.SRCCOPY);\n        }\n        OS.BitBlt(memHdc, 0, 0, destWidth, destHeight, tempHdc, 0, 0, OS.SRCCOPY);\n        OS.SelectObject(tempHdc, oldTempBitmap);\n        OS.DeleteObject(tempDib);\n        OS.DeleteDC(tempHdc);\n    } else {\n        if (!simple && (srcWidth != destWidth || srcHeight != destHeight)) {\n            if (!OS.IsWinCE)\n                OS.SetStretchBltMode(memHdc, OS.COLORONCOLOR);\n            OS.StretchBlt(memHdc, 0, 0, destWidth, destHeight, memHdc, 0, 0, srcWidth, srcHeight, OS.SRCCOPY);\n        } else {\n            OS.BitBlt(memHdc, 0, 0, destWidth, destHeight, memHdc, 0, 0, OS.SRCCOPY);\n        }\n    }\n    OS.MoveMemory(srcData, dibBM.bmBits, sizeInBytes);\n    \n    final int dpinc = dibBM.bmWidthBytes - destWidth * 4;\n    int dp = 0;\n    for (int y = 0; y < destHeight; ++y) {\n        for (int x = 0; x < destWidth; ++x) {\n            if (hasAlphaChannel)\n                alpha = srcData[dp + 3] & 0xff;\n            destData[dp] += ((srcData[dp] & 0xff) - (destData[dp] & 0xff)) * alpha / 255;\n            destData[dp + 1] += ((srcData[dp + 1] & 0xff) - (destData[dp + 1] & 0xff)) * alpha / 255;\n            destData[dp + 2] += ((srcData[dp + 2] & 0xff) - (destData[dp + 2] & 0xff)) * alpha / 255;\n            dp += 4;\n        }\n        dp += dpinc;\n    }\n    \n    OS.MoveMemory(dibBM.bmBits, destData, sizeInBytes);\n    OS.BitBlt(handle, destX, destY, destWidth, destHeight, memHdc, 0, 0, OS.SRCCOPY);\n    \n    OS.SelectObject(memHdc, oldMemBitmap);\n    OS.DeleteDC(memHdc);\n    OS.DeleteObject(memDib);\n    OS.SelectObject(srcHdc, oldSrcBitmap);\n    OS.DeleteDC(srcHdc);\n}",
			"comments":"/* Simple cases */\n/*\n* Feature in Windows.  AlphaBlend() alters the alpha\n* channel if the destination is a 32 bit depth bitmap.\n* The fix is to draw to a temporary 24 bit depth bitmap\n* first and then draw the temporary bitmap.\n*/\n/* Check clipping */\n/*\n* Optimization.  Recalculate src and dest rectangles so that\n* only the clipping area is drawn.\n*/\n/* Create resources */\n/* Get the background pixels */\n/* Get the foreground pixels */\n/* Merge the alpha channel in place */\n/* Scale the foreground pixels with alpha */\n/*\n* Bug in WinCE and Win98.  StretchBlt does not correctly stretch when\n* the source and destination HDCs are the same.  The workaround is to\n* stretch to a temporary HDC and blit back into the original HDC.\n* Note that on WinCE StretchBlt correctly compresses the image when the\n* source and destination HDCs are the same.\n*/\n/* Compose the pixels */\n/* Draw the composed pixels */\n/* Free resources */\n",
			"methodName":"void drawBitmapAlpha(Image srcImage, int srcX, int srcY, int srcWidth, int srcHeight, int destX, int destY, int destWidth, int destHeight, boolean simple, BITMAP bm, int imgWidth, int imgHeight)"
		},
		"public void setClipping(Region region)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (region != null && region.isDisposed())\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    setClipping(region != null ? region.handle : 0);\n}",
			"comments":"/**\n* Sets the area of the receiver which can be changed\n* by drawing operations to the region specified\n* by the argument.  Specifying <code>null</code> for the\n* region reverts the receiver's clipping area to its\n* original value.\n*\n* @param region the clipping region or <code>null</code>\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the region has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void setClipping(Region region)"
		},
		"public void drawImage(Image image, int srcX, int srcY, int srcWidth, int srcHeight, int destX, int destY, int destWidth, int destHeight)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (srcWidth == 0 || srcHeight == 0 || destWidth == 0 || destHeight == 0)\n        return;\n    if (srcX < 0 || srcY < 0 || srcWidth < 0 || srcHeight < 0 || destWidth < 0 || destHeight < 0) {\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    }\n    if (image == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (image.isDisposed())\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    drawImage(image, srcX, srcY, srcWidth, srcHeight, destX, destY, destWidth, destHeight, false);\n}",
			"comments":"/**\n* Copies a rectangular area from the source image into a (potentially\n* different sized) rectangular area in the receiver. If the source\n* and destination areas are of differing sizes, then the source\n* area will be stretched or shrunk to fit the destination area\n* as it is copied. The copy fails if any part of the source rectangle\n* lies outside the bounds of the source image, or if any of the width\n* or height arguments are negative.\n*\n* @param image the source image\n* @param srcX the x coordinate in the source image to copy from\n* @param srcY the y coordinate in the source image to copy from\n* @param srcWidth the width in pixels to copy from the source\n* @param srcHeight the height in pixels to copy from the source\n* @param destX the x coordinate in the destination to copy to\n* @param destY the y coordinate in the destination to copy to\n* @param destWidth the width in pixels of the destination rectangle\n* @param destHeight the height in pixels of the destination rectangle\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the image is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the image has been disposed</li>\n*    <li>ERROR_INVALID_ARGUMENT - if any of the width or height arguments are negative.\n*    <li>ERROR_INVALID_ARGUMENT - if the source rectangle is not contained within the bounds of the source image</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n* @exception SWTError <ul>\n*    <li>ERROR_NO_HANDLES - if no handles are available to perform the operation</li>\n* </ul>\n*/\n",
			"methodName":"public void drawImage(Image image, int srcX, int srcY, int srcWidth, int srcHeight, int destX, int destY, int destWidth, int destHeight)"
		},
		"public int getLineWidth()":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    int size;\n    int hPen = OS.GetCurrentObject(handle, OS.OBJ_PEN);\n    if ((size = OS.GetObject(hPen, 0, (LOGPEN) null)) == LOGPEN.sizeof) {\n        LOGPEN logPen = new LOGPEN();\n        OS.GetObject(hPen, LOGPEN.sizeof, logPen);\n        return logPen.x;\n    } else {\n        EXTLOGPEN logPen = new EXTLOGPEN();\n        if (size <= EXTLOGPEN.sizeof) {\n            OS.GetObject(hPen, size, logPen);\n        } else {\n            int hHeap = OS.GetProcessHeap();\n            int ptr = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, size);\n            OS.GetObject(hPen, size, ptr);\n            OS.MoveMemory(logPen, ptr, EXTLOGPEN.sizeof);\n            OS.HeapFree(hHeap, 0, ptr);\n        }\n        return logPen.elpWidth;\n    }\n}",
			"comments":"/**\n* Returns the width that will be used when drawing lines\n* for all of the figure drawing operations (that is,\n* <code>drawLine</code>, <code>drawRectangle</code>,\n* <code>drawPolyline</code>, and so forth.\n*\n* @return the receiver's line width\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public int getLineWidth()"
		},
		"public void drawLine(int x1, int y1, int x2, int y2)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    int gdipGraphics = data.gdipGraphics;\n    if (gdipGraphics != 0) {\n        initGdip(true, false);\n        if (data.lineWidth == 0 || (data.lineWidth % 2) == 1)\n            Gdip.Graphics_SetPixelOffsetMode(gdipGraphics, Gdip.PixelOffsetModeNone);\n        Gdip.Graphics_DrawLine(gdipGraphics, data.gdipPen, x1, y1, x2, y2);\n        if (data.lineWidth == 0 || (data.lineWidth % 2) == 1)\n            Gdip.Graphics_SetPixelOffsetMode(gdipGraphics, Gdip.PixelOffsetModeHalf);\n        return;\n    }\n    if (OS.IsWinCE) {\n        int[] points = new int[] { x1, y1, x2, y2 };\n        OS.Polyline(handle, points, points.length / 2);\n    } else {\n        OS.MoveToEx(handle, x1, y1, 0);\n        OS.LineTo(handle, x2, y2);\n    }\n    if (data.lineWidth <= 1) {\n        OS.SetPixel(handle, x2, y2, OS.GetTextColor(handle));\n    }\n}",
			"comments":"/**\n* Draws a line, using the foreground color, between the points\n* (<code>x1</code>, <code>y1</code>) and (<code>x2</code>, <code>y2</code>).\n*\n* @param x1 the first point's x coordinate\n* @param y1 the first point's y coordinate\n* @param x2 the second point's x coordinate\n* @param y2 the second point's y coordinate\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void drawLine(int x1, int y1, int x2, int y2)"
		},
		"public void fillArc(int x, int y, int width, int height, int startAngle, int arcAngle)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (width < 0) {\n        x = x + width;\n        width = -width;\n    }\n    if (height < 0) {\n        y = y + height;\n        height = -height;\n    }\n    if (width == 0 || height == 0 || arcAngle == 0)\n        return;\n    if (data.gdipGraphics != 0) {\n        initGdip(false, true);\n        Gdip.Graphics_FillPie(data.gdipGraphics, data.gdipBrush, x, y, width, height, -startAngle, -arcAngle);\n        return;\n    }\n    \n    if (OS.IsWinCE) {\n        \n        if (arcAngle < 0) {\n            startAngle += arcAngle;\n            arcAngle = -arcAngle;\n        }\n        boolean drawSegments = true;\n        if (arcAngle >= 360) {\n            arcAngle = 360;\n            drawSegments = false;\n        }\n        int[] points = new int[(arcAngle + 1) * 2 + (drawSegments ? 4 : 0)];\n        int cteX = 2 * x + width;\n        int cteY = 2 * y + height;\n        int index = (drawSegments ? 2 : 0);\n        for (int i = 0; i <= arcAngle; i++) {\n            points[index++] = (Compatibility.cos(startAngle + i, width) + cteX) >> 1;\n            points[index++] = (cteY - Compatibility.sin(startAngle + i, height)) >> 1;\n        }\n        if (drawSegments) {\n            points[0] = points[points.length - 2] = cteX >> 1;\n            points[1] = points[points.length - 1] = cteY >> 1;\n        }\n        int nullPen = OS.GetStockObject(OS.NULL_PEN);\n        int oldPen = OS.SelectObject(handle, nullPen);\n        OS.Polygon(handle, points, points.length / 2);\n        OS.SelectObject(handle, oldPen);\n    } else {\n        int x1, y1, x2, y2, tmp;\n        boolean isNegative;\n        if (arcAngle >= 360 || arcAngle <= -360) {\n            x1 = x2 = x + width;\n            y1 = y2 = y + height / 2;\n        } else {\n            isNegative = arcAngle < 0;\n            arcAngle = arcAngle + startAngle;\n            if (isNegative) {\n                \n                tmp = startAngle;\n                startAngle = arcAngle;\n                arcAngle = tmp;\n            }\n            x1 = Compatibility.cos(startAngle, width) + x + width / 2;\n            y1 = -1 * Compatibility.sin(startAngle, height) + y + height / 2;\n            x2 = Compatibility.cos(arcAngle, width) + x + width / 2;\n            y2 = -1 * Compatibility.sin(arcAngle, height) + y + height / 2;\n        }\n        int nullPen = OS.GetStockObject(OS.NULL_PEN);\n        int oldPen = OS.SelectObject(handle, nullPen);\n        OS.Pie(handle, x, y, x + width + 1, y + height + 1, x1, y1, x2, y2);\n        OS.SelectObject(handle, oldPen);\n    }\n}",
			"comments":"/**\n* Fills the interior of a circular or elliptical arc within\n* the specified rectangular area, with the receiver's background\n* color.\n* <p>\n* The resulting arc begins at <code>startAngle</code> and extends\n* for <code>arcAngle</code> degrees, using the current color.\n* Angles are interpreted such that 0 degrees is at the 3 o'clock\n* position. A positive value indicates a counter-clockwise rotation\n* while a negative value indicates a clockwise rotation.\n* </p><p>\n* The center of the arc is the center of the rectangle whose origin\n* is (<code>x</code>, <code>y</code>) and whose size is specified by the\n* <code>width</code> and <code>height</code> arguments.\n* </p><p>\n* The resulting arc covers an area <code>width + 1</code> pixels wide\n* by <code>height + 1</code> pixels tall.\n* </p>\n*\n* @param x the x coordinate of the upper-left corner of the arc to be filled\n* @param y the y coordinate of the upper-left corner of the arc to be filled\n* @param width the width of the arc to be filled\n* @param height the height of the arc to be filled\n* @param startAngle the beginning angle\n* @param arcAngle the angular extent of the arc, relative to the start angle\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #drawArc\n*/\n/*\n* Feature in WinCE.  The function Pie is not present in the\n* WinCE SDK.  The fix is to emulate it by using Polygon.\n*/\n/* compute arc with a simple linear interpolation */\n// swap angles\n",
			"methodName":"public void fillArc(int x, int y, int width, int height, int startAngle, int arcAngle)"
		},
		"static int createGdipFont(int hDC, int hFont)":{
			"methodBody":"{\n    int font = Gdip.Font_new(hDC, hFont);\n    if (font == 0)\n        SWT.error(SWT.ERROR_NO_HANDLES);\n    if (!Gdip.Font_IsAvailable(font)) {\n        Gdip.Font_delete(font);\n        LOGFONT logFont = OS.IsUnicode ? (LOGFONT) new LOGFONTW() : new LOGFONTA();\n        OS.GetObject(hFont, LOGFONT.sizeof, logFont);\n        int size = Math.abs(logFont.lfHeight);\n        int style = Gdip.FontStyleRegular;\n        if (logFont.lfWeight == 700)\n            style |= Gdip.FontStyleBold;\n        if (logFont.lfItalic != 0)\n            style |= Gdip.FontStyleItalic;\n        char[] chars;\n        if (OS.IsUnicode) {\n            chars = ((LOGFONTW) logFont).lfFaceName;\n        } else {\n            chars = new char[OS.LF_FACESIZE];\n            byte[] bytes = ((LOGFONTA) logFont).lfFaceName;\n            OS.MultiByteToWideChar(OS.CP_ACP, OS.MB_PRECOMPOSED, bytes, bytes.length, chars, chars.length);\n        }\n        int index = 0;\n        while (index < chars.length) {\n            if (chars[index] == 0)\n                break;\n            index++;\n        }\n        String name = new String(chars, 0, index);\n        if (Compatibility.equalsIgnoreCase(name, \"Courier\")) {\n            \n            \n            name = \"Courier New\";\n        }\n        char[] buffer = new char[name.length() + 1];\n        name.getChars(0, name.length(), buffer, 0);\n        font = Gdip.Font_new(buffer, size, style, Gdip.UnitPixel, 0);\n    }\n    if (font == 0)\n        SWT.error(SWT.ERROR_NO_HANDLES);\n    return font;\n}",
			"comments":"//$NON-NLS-1$\n//$NON-NLS-1$\n",
			"methodName":"static int createGdipFont(int hDC, int hFont)"
		},
		"public void drawPolyline(int[] pointArray)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (pointArray == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    int gdipGraphics = data.gdipGraphics;\n    if (gdipGraphics != 0) {\n        initGdip(true, false);\n        if (data.lineWidth == 0 || (data.lineWidth % 2) == 1)\n            Gdip.Graphics_SetPixelOffsetMode(gdipGraphics, Gdip.PixelOffsetModeNone);\n        Gdip.Graphics_DrawLines(gdipGraphics, data.gdipPen, pointArray, pointArray.length / 2);\n        if (data.lineWidth == 0 || (data.lineWidth % 2) == 1)\n            Gdip.Graphics_SetPixelOffsetMode(gdipGraphics, Gdip.PixelOffsetModeHalf);\n        return;\n    }\n    OS.Polyline(handle, pointArray, pointArray.length / 2);\n    int length = pointArray.length;\n    if (length >= 2) {\n        if (data.lineWidth <= 1) {\n            OS.SetPixel(handle, pointArray[length - 2], pointArray[length - 1], OS.GetTextColor(handle));\n        }\n    }\n}",
			"comments":"/**\n* Draws the polyline which is defined by the specified array\n* of integer coordinates, using the receiver's foreground color. The array\n* contains alternating x and y values which are considered to represent\n* points which are the corners of the polyline. Lines are drawn between\n* each consecutive pair, but not between the first pair and last pair in\n* the array.\n*\n* @param pointArray an array of alternating x and y values which are the corners of the polyline\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the point array is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void drawPolyline(int[] pointArray)"
		},
		"public void drawImage(Image image, int x, int y)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (image == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (image.isDisposed())\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    drawImage(image, 0, 0, -1, -1, x, y, -1, -1, true);\n}",
			"comments":"/**\n* Draws the given image in the receiver at the specified\n* coordinates.\n*\n* @param image the image to draw\n* @param x the x coordinate of where to draw\n* @param y the y coordinate of where to draw\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the image is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the image has been disposed</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the given coordinates are outside the bounds of the image</li>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n* @exception SWTError <ul>\n*    <li>ERROR_NO_HANDLES - if no handles are available to perform the operation</li>\n* </ul>\n*/\n",
			"methodName":"public void drawImage(Image image, int x, int y)"
		},
		"public void setLineCap(int cap)":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    int capStyle = 0;\n    switch(cap) {\n        case SWT.CAP_ROUND:\n            capStyle = OS.PS_ENDCAP_ROUND;\n            break;\n        case SWT.CAP_FLAT:\n            capStyle = OS.PS_ENDCAP_FLAT;\n            break;\n        case SWT.CAP_SQUARE:\n            capStyle = OS.PS_ENDCAP_SQUARE;\n            break;\n        default:\n            SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    }\n    setPen(-1, -1, -1, capStyle, -1, data.dashes);\n}",
			"comments":"/**\n* Sets the receiver's line cap style to the argument, which must be one\n* of the constants <code>SWT.CAP_FLAT</code>, <code>SWT.CAP_ROUND</code>,\n* or <code>SWT.CAP_SQUARE</code>.\n*\n* @param cap the cap style to be used for drawing lines\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the style is not valid</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public void setLineCap(int cap)"
		},
		"public Rectangle getClipping()":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (data.gdipGraphics != 0) {\n        Rect rect = new Rect();\n        Gdip.Graphics_GetClipBounds(data.gdipGraphics, rect);\n        return new Rectangle(rect.X, rect.Y, rect.Width, rect.Height);\n    }\n    RECT rect = new RECT();\n    OS.GetClipBox(handle, rect);\n    return new Rectangle(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);\n}",
			"comments":"/**\n* Returns the bounding rectangle of the receiver's clipping\n* region. If no clipping region is set, the return value\n* will be a rectangle which covers the entire bounds of the\n* object the receiver is drawing on.\n*\n* @return the bounding rectangle of the clipping region\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public Rectangle getClipping()"
		},
		"public int getAntialias()":{
			"methodBody":"{\n    if (handle == 0)\n        SWT.error(SWT.ERROR_GRAPHIC_DISPOSED);\n    if (data.gdipGraphics == 0)\n        return SWT.DEFAULT;\n    int mode = Gdip.Graphics_GetSmoothingMode(data.gdipGraphics);\n    switch(mode) {\n        case Gdip.SmoothingModeDefault:\n            return SWT.DEFAULT;\n        case Gdip.SmoothingModeHighSpeed:\n        case Gdip.SmoothingModeNone:\n            return SWT.OFF;\n        case Gdip.SmoothingModeAntiAlias:\n        case Gdip.SmoothingModeAntiAlias8x8:\n        case Gdip.SmoothingModeHighQuality:\n            return SWT.ON;\n    }\n    return SWT.DEFAULT;\n}",
			"comments":"/**\n* Returns the receiver's anti-aliasing setting value, which will be\n* one of <code>SWT.DEFAULT</code>, <code>SWT.OFF</code> or\n* <code>SWT.ON</code>. Note that this controls anti-aliasing for all\n* <em>non-text drawing</em> operations.\n*\n* @return the anti-aliasing setting\n*\n* @exception SWTException <ul>\n*    <li>ERROR_GRAPHIC_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #getTextAntialias\n*\n* @since 3.1\n*/\n",
			"methodName":"public int getAntialias()"
		}
	},
	"ClassORInterfaceName":[
		"GC"
	]
}
