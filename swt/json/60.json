{
	"variables":[
		"logicalContent",
		"content",
		"clientArea",
		"gc",
		"lineBackgrounds",
		"lineStyles",
		"bidiSegments",
		"lineLength",
		"logicalLineOffset",
		"segments",
		"logicalLineIndex",
		"logicalLineLength",
		"lineOffsetDelta",
		"newSegmentCount",
		"newSegments",
		"i",
		"i",
		"newIndex",
		"logicalLineIndex",
		"mask",
		"logicalLineOffset",
		"logicalLineOffset",
		"logicalLineEvent",
		"clone",
		"device",
		"regularFont",
		"logicalContent",
		"lineBackgrounds",
		"lineStyles",
		"bidiSegments",
		"clientArea",
		"gc",
		"tabLength",
		"content",
		"logicalContent",
		"content",
		"content",
		"lineText",
		"lineOffset",
		"bidiSegments",
		"logicalLineOffset",
		"segments",
		"segments",
		"lineLength",
		"logicalContent",
		"lineOffset",
		"logicalContent",
		"logicalLineIndex",
		"lineOffset",
		"logicalLineOffset",
		"lineLength",
		"logicalLineLength",
		"lineOffset",
		"logicalLineOffset",
		"segments",
		"i",
		"segments",
		"i",
		"newSegments",
		"i",
		"Math",
		"segments",
		"i",
		"lineOffsetDelta",
		"newSegments",
		"i",
		"lineLength",
		"newSegments",
		"i",
		"lineLength",
		"newSegmentCount",
		"i",
		"newSegments",
		"i",
		"newSegmentCount",
		"segments",
		"newSegmentCount",
		"i",
		"newSegments",
		"newIndex",
		"newSegmentCount",
		"i",
		"i",
		"newSegments",
		"i",
		"segments",
		"newIndex",
		"newSegments",
		"i",
		"segments",
		"clientArea",
		"content",
		"gc",
		"logicalContent",
		"visualLineOffset",
		"logicalContent",
		"logicalLineIndex",
		"SWT",
		"SWT",
		"gc",
		"mask",
		"lineOffset",
		"lineBackgrounds",
		"logicalLineOffset",
		"lineOffset",
		"lineStyles",
		"logicalLineOffset",
		"logicalLineEvent",
		"logicalLineEvent",
		"clone",
		"logicalLineEvent",
		"clone",
		"logicalLineEvent",
		"clone",
		"logicalLineEvent",
		"logicalLineEvent",
		"clone",
		"lineOffset",
		"line",
		"logicalLineEvent",
		"logicalContent",
		"lineBackgrounds",
		"lineStyles",
		"bidiSegments",
		"clientArea",
		"gc",
		"length",
		"length",
		"length",
		"RIGHT_TO_LEFT",
		"LEFT_TO_RIGHT",
		"data",
		"detail",
		"detail",
		"styles",
		"styles",
		"text",
		"text",
		"device",
		"regularFont",
		"gc",
		"logicalContent",
		"lineBackgrounds",
		"lineStyles",
		"bidiSegments",
		"tabLength",
		"clientArea",
		"gc",
		"line",
		"lineOffset",
		"paintX",
		"paintY",
		"gc",
		"lineOffset",
		"lineText",
		"visualLineOffset",
		"lineOffset",
		"line",
		"lineOffset",
		"line"
	],
	"extendORImplementFiles":[
		"StyledTextRenderer"
	],
	"package":[
		"org.eclipse.swt.custom"
	],
	"import":[
		"java.util.Hashtable",
		"org.eclipse.swt.SWT",
		"org.eclipse.swt.graphics"
	],
	"methods":[
		"dispose",
		"disposeGC",
		"drawLineBreakSelection",
		"getBidiSegments",
		"getClientArea",
		"getContent",
		"getGC",
		"getHorizontalPixel",
		"getLogicalLineOffset",
		"getOrientation",
		"getSelectionBackground",
		"getSelectionForeground",
		"getLineBackgroundData",
		"getLineStyleData",
		"getSelection",
		"getWordWrap",
		"isFullLineSelection",
		"calculateLineHeight",
		"setTabLength",
		"wrapLines",
		"dispose",
		"length",
		"getLogicalLineOffset",
		"get",
		"getLineAtOffset",
		"length",
		"getLine",
		"max",
		"getLineAtOffset",
		"getOffsetAtLine",
		"getStyle",
		"getLogicalLineOffset",
		"get",
		"getLogicalLineOffset",
		"get",
		"getLineStyleData",
		"WrappedContent",
		"Integer",
		"Integer",
		"Integer",
		"StyledTextEvent",
		"Point"
	],
	"methodsBody":{
		"private int getLogicalLineOffset(int visualLineOffset)":{
			"methodBody":"{\n    int logicalLineIndex = logicalContent.getLineAtOffset(visualLineOffset);\n    return logicalContent.getOffsetAtLine(logicalLineIndex);\n}",
			"comments":"/**\n* Returns the start offset of the line at the given offset.\n* </p>\n* @param visualLineOffset an offset that may be anywhere within a\n* \tline.\n* @return the start offset of the line at the given offset,\n* \trelative to the start of the document.\n*/\n",
			"methodName":"private int getLogicalLineOffset(int visualLineOffset)"
		},
		"protected StyledTextEvent getLineBackgroundData(int lineOffset, String line)":{
			"methodBody":"{\n    int logicalLineOffset = getLogicalLineOffset(lineOffset);\n    return (StyledTextEvent) lineBackgrounds.get(new Integer(logicalLineOffset));\n}",
			"comments":"/**\n* Return cached line background data.\n* @see StyledTextRenderer#getLineBackgroundData\n*/\n",
			"methodName":"protected StyledTextEvent getLineBackgroundData(int lineOffset, String line)"
		},
		"protected void disposeGC(GC gc)":{
			"methodBody":"{\n}",
			"comments":"/**\n* Do nothing. PrintRenderer does not create GCs.\n* @see StyledTextRenderer#disposeGC\n*/\n",
			"methodName":"protected void disposeGC(GC gc)"
		},
		"protected Rectangle getClientArea()":{
			"methodBody":"{\n    return clientArea;\n}",
			"comments":"/**\n* Returns the printer client area.\n* </p>\n* @return the visible client area that can be used for rendering.\n* @see StyledTextRenderer#getClientArea\n*/\n",
			"methodName":"protected Rectangle getClientArea()"
		},
		"protected GC getGC()":{
			"methodBody":"{\n    return gc;\n}",
			"comments":"/**\n* Returns the printer GC to use for rendering and measuring.\n* There can be only one GC for each printer device at any given\n* time.\n* </p>\n* @return the printer GC to use for rendering and measuring.\n*/\n",
			"methodName":"protected GC getGC()"
		},
		"protected StyledTextContent getContent()":{
			"methodBody":"{\n    return content;\n}",
			"comments":"/**\n* Returns the <class>StyledTextContent</class> to use for line offset\n* calculations.\n* This is the wrapped content, calculated in the constructor from the\n* logical printing content.\n* </p>\n* @return the <class>StyledTextContent</class> to use for line offset\n* calculations.\n*/\n",
			"methodName":"protected StyledTextContent getContent()"
		},
		"protected void drawLineBreakSelection(String line, int lineOffset, int paintX, int paintY, GC gc)":{
			"methodBody":"{\n}",
			"comments":"/**\n* Do not print the selection.\n* @see StyledTextRenderer#drawLineSelectionBackground\n*/\n",
			"methodName":"protected void drawLineBreakSelection(String line, int lineOffset, int paintX, int paintY, GC gc)"
		},
		"protected Color getSelectionForeground()":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"protected Color getSelectionForeground()"
		},
		"protected int[] getBidiSegments(int lineOffset, String lineText)":{
			"methodBody":"{\n    int lineLength = lineText.length();\n    int logicalLineOffset = getLogicalLineOffset(lineOffset);\n    int[] segments = (int[]) bidiSegments.get(new Integer(logicalLineOffset));\n    if (segments == null) {\n        segments = new int[] { 0, lineLength };\n    } else {\n        \n        \n        \n        \n        int logicalLineIndex = logicalContent.getLineAtOffset(lineOffset);\n        int logicalLineLength = logicalContent.getLine(logicalLineIndex).length();\n        if (lineOffset != logicalLineOffset || lineLength != logicalLineLength) {\n            int lineOffsetDelta = lineOffset - logicalLineOffset;\n            int newSegmentCount = 0;\n            int[] newSegments = new int[segments.length];\n            for (int i = 0; i < segments.length; i++) {\n                newSegments[i] = Math.max(0, segments[i] - lineOffsetDelta);\n                if (newSegments[i] > lineLength) {\n                    newSegments[i] = lineLength;\n                    newSegmentCount++;\n                    break;\n                }\n                if (i == 0 || newSegments[i] > 0) {\n                    newSegmentCount++;\n                }\n            }\n            segments = new int[newSegmentCount];\n            for (int i = 0, newIndex = 0; i < newSegments.length && newIndex < newSegmentCount; i++) {\n                if (i == 0 || newSegments[i] > 0) {\n                    segments[newIndex++] = newSegments[i];\n                }\n            }\n        }\n    }\n    return segments;\n}",
			"comments":"/**\n* Returns from cache the text segments that should be treated as\n* if they had a different direction than the surrounding text.\n* <p>\n* Use cached data.\n* </p>\n*\n* @param lineOffset offset of the first character in the line.\n* \t0 based from the beginning of the document.\n* @param line text of the line to specify bidi segments for\n* @return text segments that should be treated as if they had a\n* \tdifferent direction than the surrounding text. Only the start\n* \tindex of a segment is specified, relative to the start of the\n* \tline. Always starts with 0 and ends with the line length.\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the segment indices returned\n* \t\tby the listener do not start with 0, are not in ascending order,\n* \t\texceed the line length or have duplicates</li>\n* </ul>\n*/\n// cached bidi segments are for logical lines.\n// make sure that returned segments match requested line since\n// line wrapping may require either entire or part of logical\n// line bidi segments\n",
			"methodName":"protected int[] getBidiSegments(int lineOffset, String lineText)"
		},
		"protected Color getSelectionBackground()":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"protected Color getSelectionBackground()"
		},
		"protected boolean isFullLineSelection()":{
			"methodBody":"{\n    return false;\n}",
			"comments":"/**\n* Selection is not printed. Returns false.\n* <p>\n* @return false\n* @see StyledTextRenderer#isFullLineSelection\n*/\n",
			"methodName":"protected boolean isFullLineSelection()"
		},
		"protected boolean getWordWrap()":{
			"methodBody":"{\n    return true;\n}",
			"comments":"/**\n* Printed content is always wrapped.\n* </p>\n* @return true\n* @see StyledTextRenderer#getWordWrap\n*/\n",
			"methodName":"protected boolean getWordWrap()"
		},
		"protected void dispose()":{
			"methodBody":"{\n    content = null;\n    super.dispose();\n}",
			"comments":"/**\n* Disposes the resource created by the receiver.\n*/\n",
			"methodName":"protected void dispose()"
		},
		"protected Point getSelection()":{
			"methodBody":"{\n    return new Point(0, 0);\n}",
			"comments":"/**\n* Selection is not printed.\n* </p>\n* @return Point(0,0)\n* @see StyledTextRenderer#getSelection\n*/\n",
			"methodName":"protected Point getSelection()"
		},
		"protected int getHorizontalPixel()":{
			"methodBody":"{\n    return 0;\n}",
			"comments":"/**\n* Returns 0. Scrolling does not affect printing. Text is wrapped\n* for printing.\n* </p>\n* @return 0\n* @see StyledTextRenderer#getHorizontalPixel\n*/\n",
			"methodName":"protected int getHorizontalPixel()"
		},
		"protected int getOrientation()":{
			"methodBody":"{\n    int mask = SWT.RIGHT_TO_LEFT | SWT.LEFT_TO_RIGHT;\n    return gc.getStyle() & mask;\n}",
			"comments":"",
			"methodName":"protected int getOrientation()"
		},
		"protected StyledTextEvent getLineStyleData(int lineOffset, String line)":{
			"methodBody":"{\n    int logicalLineOffset = getLogicalLineOffset(lineOffset);\n    StyledTextEvent logicalLineEvent = (StyledTextEvent) lineStyles.get(new Integer(logicalLineOffset));\n    if (logicalLineEvent != null) {\n        StyledTextEvent clone = new StyledTextEvent((StyledTextContent) logicalLineEvent.data);\n        clone.detail = logicalLineEvent.detail;\n        clone.styles = logicalLineEvent.styles;\n        clone.text = logicalLineEvent.text;\n        logicalLineEvent = getLineStyleData(clone, lineOffset, line);\n    }\n    return logicalLineEvent;\n}",
			"comments":"/**\n* Return cached line style background data.\n* @see StyledTextRenderer#getLineStyleData\n*/\n",
			"methodName":"protected StyledTextEvent getLineStyleData(int lineOffset, String line)"
		}
	},
	"ClassORInterfaceName":[
		"PrintRenderer"
	]
}
