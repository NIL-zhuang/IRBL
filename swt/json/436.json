{
	"variables":[
		"items",
		"originalItems",
		"locked",
		"ignoreResize",
		"ReBarProc",
		"ReBarClass",
		"icex",
		"lpWndClass",
		"SEPARATOR_WIDTH",
		"MAX_WIDTH",
		"width",
		"height",
		"border",
		"newWidth",
		"newHeight",
		"count",
		"redraw",
		"oldRect",
		"oldWidth",
		"oldHeight",
		"flags",
		"rect",
		"rbBand",
		"rowWidth",
		"separator",
		"i",
		"hFont",
		"count",
		"id",
		"newItems",
		"hHeap",
		"lpText",
		"rbBand",
		"lastIndex",
		"fixLast",
		"length",
		"newOriginals",
		"index",
		"count",
		"lastIndex",
		"control",
		"wasVisible",
		"nextItem",
		"length",
		"newOriginals",
		"margin",
		"margins",
		"rect",
		"count",
		"rbBand",
		"count",
		"indices",
		"rbBand",
		"i",
		"item",
		"index",
		"count",
		"result",
		"rbBand",
		"i",
		"count",
		"sizes",
		"rbBand",
		"separator",
		"margins",
		"i",
		"rect",
		"count",
		"rbBand",
		"i",
		"count",
		"rbBand",
		"items",
		"indices",
		"count",
		"i",
		"result",
		"count",
		"rbBand",
		"rect",
		"rbBand",
		"i",
		"item",
		"i",
		"item",
		"flags",
		"count",
		"rbBand",
		"i",
		"itemCount",
		"set",
		"i",
		"index",
		"rbBand",
		"i",
		"id",
		"index",
		"lastItemSrcRow",
		"lastItemDstRow",
		"count",
		"rbBand",
		"i",
		"count",
		"rbBand",
		"i",
		"count",
		"i",
		"items",
		"i",
		"item",
		"i",
		"index",
		"item",
		"bits",
		"result",
		"result",
		"result",
		"result",
		"rect",
		"code",
		"code",
		"hdr",
		"lprbcs",
		"item",
		"control",
		"width",
		"height",
		"size",
		"border",
		"height",
		"lpnm",
		"item",
		"event",
		"nmcd",
		"OS",
		"icex",
		"INITCOMMONCONTROLSEX",
		"icex",
		"OS",
		"OS",
		"icex",
		"OS",
		"ReBarClass",
		"lpWndClass",
		"ReBarProc",
		"lpWndClass",
		"parent",
		"style",
		"handle",
		"OS",
		"ReBarProc",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"style",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"wHint",
		"SWT",
		"wHint",
		"border",
		"hHint",
		"SWT",
		"hHint",
		"border",
		"OS",
		"handle",
		"OS",
		"count",
		"ignoreResize",
		"OS",
		"handle",
		"OS",
		"redraw",
		"OS",
		"handle",
		"OS",
		"handle",
		"OS",
		"redraw",
		"drawCount",
		"redraw",
		"OS",
		"handle",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"oldRect",
		"oldRect",
		"oldRect",
		"oldRect",
		"oldRect",
		"OS",
		"OS",
		"OS",
		"OS",
		"handle",
		"newWidth",
		"newHeight",
		"flags",
		"OS",
		"handle",
		"OS",
		"count",
		"rect",
		"height",
		"Math",
		"height",
		"rect",
		"handle",
		"oldWidth",
		"oldHeight",
		"flags",
		"rbBand",
		"REBARBANDINFO",
		"rbBand",
		"OS",
		"OS",
		"style",
		"SWT",
		"SEPARATOR_WIDTH",
		"i",
		"count",
		"i",
		"OS",
		"handle",
		"OS",
		"i",
		"rbBand",
		"rbBand",
		"OS",
		"width",
		"Math",
		"width",
		"rowWidth",
		"separator",
		"rowWidth",
		"rowWidth",
		"rbBand",
		"i",
		"separator",
		"width",
		"Math",
		"width",
		"rowWidth",
		"separator",
		"redraw",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"ignoreResize",
		"width",
		"width",
		"DEFAULT_WIDTH",
		"height",
		"height",
		"DEFAULT_HEIGHT",
		"wHint",
		"SWT",
		"width",
		"wHint",
		"hHint",
		"SWT",
		"height",
		"hHint",
		"height",
		"border",
		"width",
		"border",
		"width",
		"height",
		"state",
		"CANVAS",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"hFont",
		"OS",
		"handle",
		"OS",
		"index",
		"index",
		"count",
		"SWT",
		"id",
		"items",
		"items",
		"id",
		"id",
		"id",
		"items",
		"items",
		"System",
		"items",
		"newItems",
		"items",
		"items",
		"newItems",
		"OS",
		"OS",
		"hHeap",
		"OS",
		"TCHAR",
		"rbBand",
		"REBARBANDINFO",
		"rbBand",
		"OS",
		"OS",
		"OS",
		"rbBand",
		"OS",
		"OS",
		"item",
		"SWT",
		"rbBand",
		"OS",
		"rbBand",
		"lpText",
		"rbBand",
		"id",
		"index",
		"index",
		"lastIndex",
		"fixLast",
		"rbBand",
		"OS",
		"rbBand",
		"MAX_WIDTH",
		"index",
		"count",
		"OS",
		"handle",
		"OS",
		"index",
		"rbBand",
		"SWT",
		"fixLast",
		"lastIndex",
		"OS",
		"hHeap",
		"lpText",
		"items",
		"item",
		"id",
		"item",
		"originalItems",
		"length",
		"System",
		"originalItems",
		"newOriginals",
		"index",
		"System",
		"originalItems",
		"index",
		"newOriginals",
		"index",
		"length",
		"index",
		"newOriginals",
		"index",
		"item",
		"originalItems",
		"newOriginals",
		"items",
		"originalItems",
		"OS",
		"handle",
		"OS",
		"item",
		"OS",
		"handle",
		"OS",
		"count",
		"index",
		"index",
		"lastIndex",
		"lastIndex",
		"item",
		"control",
		"control",
		"control",
		"item",
		"index",
		"count",
		"nextItem",
		"index",
		"ignoreResize",
		"nextItem",
		"OS",
		"handle",
		"OS",
		"index",
		"SWT",
		"items",
		"item",
		"item",
		"ignoreResize",
		"nextItem",
		"ignoreResize",
		"wasVisible",
		"control",
		"index",
		"index",
		"originalItems",
		"originalItems",
		"index",
		"item",
		"index",
		"originalItems",
		"length",
		"System",
		"originalItems",
		"newOriginals",
		"index",
		"System",
		"originalItems",
		"index",
		"newOriginals",
		"index",
		"length",
		"index",
		"originalItems",
		"newOriginals",
		"OS",
		"OS",
		"handle",
		"OS",
		"margins",
		"margin",
		"margins",
		"margins",
		"OS",
		"handle",
		"OS",
		"index",
		"rect",
		"style",
		"SWT",
		"margin",
		"rect",
		"margin",
		"rect",
		"rect",
		"margin",
		"OS",
		"handle",
		"OS",
		"index",
		"index",
		"count",
		"SWT",
		"rbBand",
		"REBARBANDINFO",
		"rbBand",
		"OS",
		"OS",
		"handle",
		"OS",
		"index",
		"rbBand",
		"items",
		"rbBand",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"count",
		"rbBand",
		"REBARBANDINFO",
		"rbBand",
		"OS",
		"i",
		"count",
		"i",
		"OS",
		"handle",
		"OS",
		"i",
		"rbBand",
		"items",
		"rbBand",
		"index",
		"originalItems",
		"originalItems",
		"index",
		"item",
		"index",
		"index",
		"originalItems",
		"SWT",
		"indices",
		"i",
		"index",
		"indices",
		"OS",
		"handle",
		"OS",
		"count",
		"rbBand",
		"REBARBANDINFO",
		"rbBand",
		"OS",
		"i",
		"count",
		"i",
		"OS",
		"handle",
		"OS",
		"i",
		"rbBand",
		"result",
		"i",
		"items",
		"rbBand",
		"result",
		"OS",
		"handle",
		"OS",
		"count",
		"rbBand",
		"REBARBANDINFO",
		"rbBand",
		"OS",
		"style",
		"SWT",
		"SEPARATOR_WIDTH",
		"i",
		"count",
		"i",
		"OS",
		"handle",
		"OS",
		"i",
		"rect",
		"OS",
		"handle",
		"OS",
		"i",
		"rbBand",
		"OS",
		"OS",
		"handle",
		"OS",
		"margins",
		"rect",
		"margins",
		"rect",
		"margins",
		"i",
		"rect",
		"separator",
		"sizes",
		"i",
		"rect",
		"rect",
		"rbBand",
		"sizes",
		"OS",
		"handle",
		"OS",
		"count",
		"rbBand",
		"REBARBANDINFO",
		"rbBand",
		"OS",
		"index",
		"i",
		"count",
		"i",
		"OS",
		"handle",
		"OS",
		"i",
		"rbBand",
		"rbBand",
		"OS",
		"i",
		"count",
		"OS",
		"handle",
		"OS",
		"index",
		"count",
		"rbBand",
		"REBARBANDINFO",
		"rbBand",
		"OS",
		"OS",
		"handle",
		"OS",
		"index",
		"rbBand",
		"rbBand",
		"OS",
		"locked",
		"items",
		"i",
		"items",
		"i",
		"items",
		"i",
		"indices",
		"count",
		"i",
		"count",
		"System",
		"indices",
		"result",
		"count",
		"result",
		"item",
		"SWT",
		"item",
		"SWT",
		"OS",
		"handle",
		"OS",
		"item",
		"OS",
		"handle",
		"OS",
		"index",
		"index",
		"count",
		"rbBand",
		"REBARBANDINFO",
		"rbBand",
		"OS",
		"OS",
		"handle",
		"OS",
		"index",
		"rbBand",
		"OS",
		"handle",
		"OS",
		"index",
		"rect",
		"rbBand",
		"rbBand",
		"rect",
		"style",
		"SWT",
		"rbBand",
		"rect",
		"rbBand",
		"OS",
		"OS",
		"handle",
		"OS",
		"index",
		"rbBand",
		"rbBand",
		"REBARBANDINFO",
		"rbBand",
		"OS",
		"rbBand",
		"MAX_WIDTH",
		"OS",
		"handle",
		"OS",
		"index",
		"rbBand",
		"i",
		"items",
		"i",
		"items",
		"i",
		"item",
		"item",
		"item",
		"items",
		"control",
		"i",
		"items",
		"i",
		"items",
		"i",
		"item",
		"item",
		"control",
		"item",
		"background",
		"pixel",
		"background",
		"pixel",
		"pixel",
		"pixel",
		"OS",
		"handle",
		"OS",
		"pixel",
		"OS",
		"handle",
		"OS",
		"pixel",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"handle",
		"flags",
		"foreground",
		"pixel",
		"foreground",
		"pixel",
		"pixel",
		"pixel",
		"OS",
		"handle",
		"OS",
		"pixel",
		"pixel",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"rbBand",
		"REBARBANDINFO",
		"rbBand",
		"OS",
		"rbBand",
		"foreColor",
		"rbBand",
		"backColor",
		"i",
		"count",
		"i",
		"OS",
		"handle",
		"OS",
		"i",
		"rbBand",
		"itemOrder",
		"wrapIndices",
		"sizes",
		"itemOrder",
		"SWT",
		"OS",
		"handle",
		"OS",
		"itemOrder",
		"itemCount",
		"SWT",
		"itemCount",
		"i",
		"itemOrder",
		"i",
		"itemOrder",
		"i",
		"index",
		"index",
		"itemCount",
		"SWT",
		"set",
		"index",
		"SWT",
		"set",
		"index",
		"rbBand",
		"REBARBANDINFO",
		"i",
		"itemOrder",
		"i",
		"originalItems",
		"itemOrder",
		"i",
		"OS",
		"handle",
		"OS",
		"id",
		"index",
		"i",
		"index",
		"i",
		"index",
		"lastItemSrcRow",
		"index",
		"i",
		"lastItemDstRow",
		"i",
		"OS",
		"handle",
		"OS",
		"index",
		"i",
		"index",
		"lastItemSrcRow",
		"index",
		"index",
		"i",
		"lastItemDstRow",
		"i",
		"sizes",
		"SWT",
		"OS",
		"handle",
		"OS",
		"sizes",
		"count",
		"SWT",
		"rbBand",
		"REBARBANDINFO",
		"rbBand",
		"OS",
		"i",
		"count",
		"i",
		"OS",
		"handle",
		"OS",
		"i",
		"rbBand",
		"items",
		"rbBand",
		"sizes",
		"i",
		"sizes",
		"i",
		"locked",
		"OS",
		"handle",
		"OS",
		"rbBand",
		"REBARBANDINFO",
		"rbBand",
		"OS",
		"i",
		"count",
		"i",
		"OS",
		"handle",
		"OS",
		"i",
		"rbBand",
		"locked",
		"rbBand",
		"OS",
		"rbBand",
		"OS",
		"OS",
		"handle",
		"OS",
		"i",
		"rbBand",
		"indices",
		"indices",
		"i",
		"indices",
		"i",
		"indices",
		"i",
		"indices",
		"i",
		"count",
		"SWT",
		"i",
		"items",
		"i",
		"items",
		"i",
		"item",
		"i",
		"item",
		"count",
		"i",
		"indices",
		"i",
		"indices",
		"i",
		"index",
		"index",
		"items",
		"items",
		"index",
		"item",
		"index",
		"OS",
		"OS",
		"bits",
		"OS",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"bits",
		"ReBarClass",
		"ReBarProc",
		"wParam",
		"lParam",
		"result",
		"result",
		"LRESULT",
		"wParam",
		"lParam",
		"result",
		"result",
		"OS",
		"wParam",
		"wParam",
		"lParam",
		"result",
		"result",
		"LRESULT",
		"wParam",
		"lParam",
		"result",
		"result",
		"OS",
		"LRESULT",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"OS",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"rect",
		"parent",
		"rect",
		"rect",
		"rect",
		"rect",
		"code",
		"ignoreResize",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"code",
		"LRESULT",
		"code",
		"wParam",
		"lParam",
		"OS",
		"hdr",
		"lParam",
		"NMHDR",
		"hdr",
		"OS",
		"OS",
		"lprbcs",
		"lParam",
		"NMREBARCHILDSIZE",
		"lprbcs",
		"items",
		"lprbcs",
		"item",
		"control",
		"lprbcs",
		"lprbcs",
		"lprbcs",
		"lprbcs",
		"control",
		"lprbcs",
		"lprbcs",
		"width",
		"height",
		"OS",
		"ignoreResize",
		"OS",
		"handle",
		"OS",
		"size",
		"height",
		"border",
		"OS",
		"OS",
		"lpnm",
		"lParam",
		"NMREBARCHEVRON",
		"items",
		"lpnm",
		"item",
		"event",
		"SWT",
		"event",
		"lpnm",
		"event",
		"lpnm",
		"item",
		"SWT",
		"event",
		"OS",
		"OS",
		"background",
		"style",
		"SWT",
		"OS",
		"nmcd",
		"lParam",
		"NMCUSTOMDRAW",
		"nmcd",
		"OS",
		"OS",
		"OS",
		"nmcd",
		"wParam",
		"lParam",
		"REBARCLASSNAME",
		"dwSize",
		"sizeof",
		"dwICC",
		"ICC_COOL_CLASSES",
		"lpfnWndProc",
		"NO_FOCUS",
		"H_SCROLL",
		"V_SCROLL",
		"ERROR_INVALID_SUBCLASS",
		"DEFAULT",
		"DEFAULT",
		"RB_GETBANDCOUNT",
		"COMCTL32_MAJOR",
		"WM_SETREDRAW",
		"WM_SETREDRAW",
		"right",
		"left",
		"bottom",
		"top",
		"SWP_NOACTIVATE",
		"SWP_NOMOVE",
		"SWP_NOREDRAW",
		"SWP_NOZORDER",
		"RB_GETRECT",
		"bottom",
		"cbSize",
		"sizeof",
		"fMask",
		"RBBIM_IDEALSIZE",
		"RBBIM_STYLE",
		"FLAT",
		"RB_GETBANDINFO",
		"fStyle",
		"RBBS_BREAK",
		"cxIdeal",
		"COMCTL32_MAJOR",
		"WM_SETREDRAW",
		"WM_SETREDRAW",
		"DEFAULT",
		"DEFAULT",
		"SYSTEM_FONT",
		"WM_SETFONT",
		"RB_GETBANDCOUNT",
		"ERROR_INVALID_RANGE",
		"length",
		"length",
		"length",
		"length",
		"HEAP_ZERO_MEMORY",
		"sizeof",
		"cbSize",
		"sizeof",
		"fMask",
		"RBBIM_TEXT",
		"RBBIM_STYLE",
		"RBBIM_ID",
		"fStyle",
		"RBBS_VARIABLEHEIGHT",
		"RBBS_GRIPPERALWAYS",
		"style",
		"DROP_DOWN",
		"fStyle",
		"RBBS_USECHEVRON",
		"lpText",
		"wID",
		"fMask",
		"RBBIM_SIZE",
		"cx",
		"RB_INSERTBAND",
		"ERROR_ITEM_NOT_ADDED",
		"id",
		"length",
		"RB_IDTOINDEX",
		"id",
		"RB_GETBANDCOUNT",
		"control",
		"RB_DELETEBAND",
		"ERROR_ITEM_NOT_REMOVED",
		"id",
		"id",
		"length",
		"length",
		"COMCTL32_MAJOR",
		"RB_GETBANDMARGINS",
		"cxLeftWidth",
		"cxRightWidth",
		"RB_GETBANDBORDERS",
		"FLAT",
		"left",
		"left",
		"right",
		"RB_GETBANDCOUNT",
		"ERROR_INVALID_RANGE",
		"cbSize",
		"sizeof",
		"fMask",
		"RBBIM_ID",
		"RB_GETBANDINFO",
		"wID",
		"RB_GETBANDCOUNT",
		"RB_GETBANDCOUNT",
		"cbSize",
		"sizeof",
		"fMask",
		"RBBIM_ID",
		"RB_GETBANDINFO",
		"wID",
		"length",
		"length",
		"ERROR_CANNOT_GET_ITEM",
		"RB_GETBANDCOUNT",
		"cbSize",
		"sizeof",
		"fMask",
		"RBBIM_ID",
		"RB_GETBANDINFO",
		"wID",
		"RB_GETBANDCOUNT",
		"cbSize",
		"sizeof",
		"fMask",
		"RBBIM_CHILDSIZE",
		"FLAT",
		"RB_GETRECT",
		"RB_GETBANDINFO",
		"COMCTL32_MAJOR",
		"RB_GETBANDMARGINS",
		"left",
		"cxLeftWidth",
		"right",
		"cxRightWidth",
		"right",
		"right",
		"left",
		"cyChild",
		"RB_GETBANDCOUNT",
		"cbSize",
		"sizeof",
		"fMask",
		"RBBIM_STYLE",
		"RB_GETBANDINFO",
		"fStyle",
		"RBBS_BREAK",
		"RB_GETBANDCOUNT",
		"cbSize",
		"sizeof",
		"fMask",
		"RBBIM_STYLE",
		"RB_GETBANDINFO",
		"fStyle",
		"RBBS_BREAK",
		"length",
		"length",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"RB_IDTOINDEX",
		"id",
		"RB_GETBANDCOUNT",
		"cbSize",
		"sizeof",
		"fMask",
		"RBBIM_IDEALSIZE",
		"RB_GETBANDINFO",
		"RB_GETBANDBORDERS",
		"cx",
		"cxIdeal",
		"left",
		"FLAT",
		"cx",
		"right",
		"fMask",
		"RBBIM_SIZE",
		"RB_SETBANDINFO",
		"cbSize",
		"sizeof",
		"fMask",
		"RBBIM_SIZE",
		"cx",
		"RB_SETBANDINFO",
		"length",
		"length",
		"control",
		"RB_SETBKCOLOR",
		"RB_GETTEXTCOLOR",
		"IsWinCE",
		"RDW_ERASE",
		"RDW_FRAME",
		"RDW_INVALIDATE",
		"RDW_ALLCHILDREN",
		"RB_SETTEXTCOLOR",
		"RB_GETBKCOLOR",
		"RB_GETBANDCOUNT",
		"cbSize",
		"sizeof",
		"fMask",
		"RBBIM_COLORS",
		"clrFore",
		"clrBack",
		"RB_SETBANDINFO",
		"ERROR_NULL_ARGUMENT",
		"RB_GETBANDCOUNT",
		"length",
		"ERROR_INVALID_ARGUMENT",
		"length",
		"ERROR_INVALID_RANGE",
		"ERROR_INVALID_ARGUMENT",
		"cbSize",
		"sizeof",
		"length",
		"id",
		"RB_IDTOINDEX",
		"RB_MOVEBAND",
		"ERROR_NULL_ARGUMENT",
		"RB_GETBANDCOUNT",
		"length",
		"ERROR_INVALID_ARGUMENT",
		"cbSize",
		"sizeof",
		"fMask",
		"RBBIM_ID",
		"RB_GETBANDINFO",
		"wID",
		"x",
		"y",
		"locked",
		"RB_GETBANDCOUNT",
		"cbSize",
		"sizeof",
		"fMask",
		"RBBIM_STYLE",
		"RB_GETBANDINFO",
		"fStyle",
		"RBBS_NOGRIPPER",
		"fStyle",
		"RBBS_NOGRIPPER",
		"RB_SETBANDINFO",
		"length",
		"ERROR_INVALID_RANGE",
		"length",
		"length",
		"length",
		"CCS_NODIVIDER",
		"CCS_NORESIZE",
		"RBS_VARHEIGHT",
		"RBS_DBLCLKTOGGLE",
		"FLAT",
		"RBS_BANDBORDERS",
		"ZERO",
		"COMCTL32_MAJOR",
		"ZERO",
		"COMCTL32_MAJOR",
		"ZERO",
		"WM_SETREDRAW",
		"WM_SETREDRAW",
		"x",
		"y",
		"width",
		"height",
		"WM_SIZE",
		"ZERO",
		"sizeof",
		"code",
		"RBN_CHILDSIZE",
		"sizeof",
		"uBand",
		"wID",
		"control",
		"rcChild_right",
		"rcChild_left",
		"rcChild_bottom",
		"rcChild_top",
		"rcChild_left",
		"rcChild_top",
		"RBN_HEIGHTCHANGE",
		"RB_GETBARHEIGHT",
		"x",
		"RBN_CHEVRONPUSHED",
		"sizeof",
		"wID",
		"detail",
		"ARROW",
		"x",
		"left",
		"y",
		"bottom",
		"Selection",
		"NM_CUSTOMDRAW",
		"COMCTL32_MAJOR",
		"FLAT",
		"sizeof",
		"dwDrawStage",
		"CDDS_PREERASE",
		"CDRF_NOTIFYPOSTERASE",
		"CDDS_POSTERASE",
		"hdc",
		"parent",
		"style",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"style",
		"wHint",
		"hHint",
		"changed",
		"item",
		"index",
		"item",
		"index",
		"index",
		"index",
		"index",
		"item",
		"index",
		"index",
		"control",
		"pixel",
		"pixel",
		"foreColor",
		"backColor",
		"itemOrder",
		"wrapIndices",
		"sizes",
		"itemOrder",
		"sizes",
		"locked",
		"indices",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam"
	],
	"extendORImplementFiles":[
		"Composite"
	],
	"package":[
		"org.eclipse.swt.widgets"
	],
	"import":[
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt",
		"org.eclipse.swt.graphics"
	],
	"methods":[
		"callWindowProc",
		"checkStyle",
		"checkSubclass",
		"computeSize",
		"createHandle",
		"createItem",
		"createWidget",
		"destroyItem",
		"getMargin",
		"findThemeControl",
		"getItem",
		"getItemCount",
		"getItemOrder",
		"getItems",
		"getItemSizes",
		"getLastIndexOfRow",
		"isLastItemOfRow",
		"getLocked",
		"getWrapIndices",
		"indexOf",
		"resizeToPreferredWidth",
		"resizeToMaximumWidth",
		"releaseWidget",
		"removeControl",
		"setBackgroundPixel",
		"setForegroundPixel",
		"setItemColors",
		"setItemLayout",
		"setItemOrder",
		"setItemSizes",
		"setLocked",
		"setWrapIndices",
		"widgetStyle",
		"windowClass",
		"windowProc",
		"WM_COMMAND",
		"WM_ERASEBKGND",
		"WM_NOTIFY",
		"WM_SETREDRAW",
		"WM_SIZE",
		"wmNotifyChild",
		"InitCommonControlsEx",
		"GetClassInfo",
		"checkStyle",
		"CallWindowProc",
		"isValidSubclass",
		"error",
		"checkWidget",
		"getBorderWidth",
		"SendMessage",
		"IsWindowVisible",
		"UpdateWindow",
		"DefWindowProc",
		"UpdateWindow",
		"SendMessage",
		"GetWindowRect",
		"SetWindowPos",
		"SendMessage",
		"max",
		"SetWindowPos",
		"SendMessage",
		"max",
		"getMargin",
		"max",
		"DefWindowProc",
		"SendMessage",
		"createHandle",
		"GetStockObject",
		"SendMessage",
		"SendMessage",
		"error",
		"arraycopy",
		"GetProcessHeap",
		"HeapAlloc",
		"getLastIndexOfRow",
		"setWrap",
		"getItem",
		"SendMessage",
		"error",
		"resizeToPreferredWidth",
		"HeapFree",
		"arraycopy",
		"arraycopy",
		"createWidget",
		"SendMessage",
		"SendMessage",
		"getLastIndexOfRow",
		"resizeToMaximumWidth",
		"isDisposed",
		"getVisible",
		"getWrap",
		"getItem",
		"getWrap",
		"SendMessage",
		"error",
		"setWrap",
		"setVisible",
		"arraycopy",
		"arraycopy",
		"SendMessage",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"error",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"error",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"isLastItemOfRow",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"checkWidget",
		"checkWidget",
		"getItems",
		"getWrap",
		"arraycopy",
		"checkWidget",
		"error",
		"isDisposed",
		"error",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"isDisposed",
		"releaseResources",
		"releaseWidget",
		"removeControl",
		"setControl",
		"defaultBackground",
		"SendMessage",
		"setItemColors",
		"SendMessage",
		"IsWindowVisible",
		"InvalidateRect",
		"RedrawWindow",
		"defaultForeground",
		"SendMessage",
		"setItemColors",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"checkWidget",
		"setRedraw",
		"setItemOrder",
		"setWrapIndices",
		"setItemSizes",
		"setRedraw",
		"error",
		"SendMessage",
		"error",
		"error",
		"error",
		"SendMessage",
		"getLastIndexOfRow",
		"getLastIndexOfRow",
		"resizeToPreferredWidth",
		"resizeToPreferredWidth",
		"SendMessage",
		"resizeToMaximumWidth",
		"resizeToMaximumWidth",
		"error",
		"SendMessage",
		"error",
		"SendMessage",
		"setSize",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"checkWidget",
		"getItemCount",
		"error",
		"setRedraw",
		"getItems",
		"getWrap",
		"resizeToPreferredWidth",
		"setWrap",
		"resizeToMaximumWidth",
		"setWrap",
		"resizeToMaximumWidth",
		"setRedraw",
		"widgetStyle",
		"WM_COMMAND",
		"WM_ERASEBKGND",
		"drawBackground",
		"WM_NOTIFY",
		"WM_SETREDRAW",
		"getBounds",
		"callWindowProc",
		"DefWindowProc",
		"equals",
		"getBounds",
		"redraw",
		"callWindowProc",
		"WM_SIZE",
		"MoveMemory",
		"MoveMemory",
		"setBounds",
		"getSize",
		"getBorderWidth",
		"SendMessage",
		"setSize",
		"MoveMemory",
		"postEvent",
		"MoveMemory",
		"drawBackground",
		"wmNotifyChild",
		"TCHAR",
		"INITCOMMONCONTROLSEX",
		"WNDCLASS",
		"RECT",
		"RECT",
		"REBARBANDINFO",
		"Point",
		"REBARBANDINFO",
		"MARGINS",
		"RECT",
		"REBARBANDINFO",
		"REBARBANDINFO",
		"REBARBANDINFO",
		"REBARBANDINFO",
		"MARGINS",
		"RECT",
		"Point",
		"REBARBANDINFO",
		"REBARBANDINFO",
		"REBARBANDINFO",
		"RECT",
		"REBARBANDINFO",
		"REBARBANDINFO",
		"REBARBANDINFO",
		"REBARBANDINFO",
		"REBARBANDINFO",
		"LRESULT",
		"LRESULT",
		"NMHDR",
		"NMREBARCHILDSIZE",
		"NMREBARCHEVRON",
		"Event",
		"NMCUSTOMDRAW",
		"LRESULT"
	],
	"methodsBody":{
		"public Point[] getItemSizes()":{
			"methodBody":"{\n    checkWidget();\n    int count = OS.SendMessage(handle, OS.RB_GETBANDCOUNT, 0, 0);\n    Point[] sizes = new Point[count];\n    REBARBANDINFO rbBand = new REBARBANDINFO();\n    rbBand.cbSize = REBARBANDINFO.sizeof;\n    rbBand.fMask = OS.RBBIM_CHILDSIZE;\n    int separator = (style & SWT.FLAT) == 0 ? SEPARATOR_WIDTH : 0;\n    MARGINS margins = new MARGINS();\n    for (int i = 0; i < count; i++) {\n        RECT rect = new RECT();\n        OS.SendMessage(handle, OS.RB_GETRECT, i, rect);\n        OS.SendMessage(handle, OS.RB_GETBANDINFO, i, rbBand);\n        if (OS.COMCTL32_MAJOR >= 6) {\n            OS.SendMessage(handle, OS.RB_GETBANDMARGINS, 0, margins);\n            rect.left -= margins.cxLeftWidth;\n            rect.right += margins.cxRightWidth;\n        }\n        if (!isLastItemOfRow(i))\n            rect.right += separator;\n        sizes[i] = new Point(rect.right - rect.left, rbBand.cyChild);\n    }\n    return sizes;\n}",
			"comments":"/**\n* Returns an array of points whose x and y coordinates describe\n* the widths and heights (respectively) of the items in the receiver\n* in the order in which they are currently being displayed.\n*\n* @return the receiver's item sizes in their current visual order\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Point[] getItemSizes()"
		},
		"LRESULT wmNotifyChild(int wParam, int lParam)":{
			"methodBody":"{\n    NMHDR hdr = new NMHDR();\n    OS.MoveMemory(hdr, lParam, NMHDR.sizeof);\n    switch(hdr.code) {\n        case OS.RBN_CHILDSIZE:\n            \n            NMREBARCHILDSIZE lprbcs = new NMREBARCHILDSIZE();\n            OS.MoveMemory(lprbcs, lParam, NMREBARCHILDSIZE.sizeof);\n            if (lprbcs.uBand != -1) {\n                CoolItem item = items[lprbcs.wID];\n                Control control = item.control;\n                if (control != null) {\n                    int width = lprbcs.rcChild_right - lprbcs.rcChild_left;\n                    int height = lprbcs.rcChild_bottom - lprbcs.rcChild_top;\n                    control.setBounds(lprbcs.rcChild_left, lprbcs.rcChild_top, width, height);\n                }\n            }\n            break;\n        case OS.RBN_HEIGHTCHANGE:\n            if (!ignoreResize) {\n                Point size = getSize();\n                int border = getBorderWidth();\n                int height = OS.SendMessage(handle, OS.RB_GETBARHEIGHT, 0, 0);\n                setSize(size.x, height + (border * 2));\n            }\n            break;\n        case OS.RBN_CHEVRONPUSHED:\n            NMREBARCHEVRON lpnm = new NMREBARCHEVRON();\n            OS.MoveMemory(lpnm, lParam, NMREBARCHEVRON.sizeof);\n            CoolItem item = items[lpnm.wID];\n            if (item != null) {\n                Event event = new Event();\n                event.detail = SWT.ARROW;\n                event.x = lpnm.left;\n                event.y = lpnm.bottom;\n                item.postEvent(SWT.Selection, event);\n            }\n            break;\n        case OS.NM_CUSTOMDRAW:\n            \n            if (OS.COMCTL32_MAJOR < 6)\n                break;\n            if (background != -1 || (style & SWT.FLAT) != 0) {\n                NMCUSTOMDRAW nmcd = new NMCUSTOMDRAW();\n                OS.MoveMemory(nmcd, lParam, NMCUSTOMDRAW.sizeof);\n                switch(nmcd.dwDrawStage) {\n                    case OS.CDDS_PREERASE:\n                        return new LRESULT(OS.CDRF_NOTIFYPOSTERASE);\n                    case OS.CDDS_POSTERASE:\n                        drawBackground(nmcd.hdc);\n                        break;\n                }\n            }\n            break;\n    }\n    return super.wmNotifyChild(wParam, lParam);\n}",
			"comments":"/*\n* Bug in Windows.  When Windows sets the size of the rebar band\n* child and the child is a combo box, the size of the drop down\n* portion of the combo box is resized to zero.  The fix is to set\n* the size of the control to the current size after the rebar has\n* already resized it.  If the control is not a combo, this does\n* nothing.  If the control is a combo, the drop down portion is\n* recalculated.\n*/\n/*\n* Bug in Windows.  On versions of Windows prior to XP,\n* drawing the background color in NM_CUSTOMDRAW erases\n* the separators.  The fix is to draw the background\n* in WM_ERASEBKGND.\n*/\n",
			"methodName":"LRESULT wmNotifyChild(int wParam, int lParam)"
		},
		"LRESULT WM_ERASEBKGND(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_ERASEBKGND(wParam, lParam);\n    if (result != null)\n        return result;\n    \n    if (OS.COMCTL32_MAJOR < 6)\n        drawBackground(wParam);\n    return null;\n}",
			"comments":"/*\n* Feature in Windows.  For some reason, Windows\n* does not fully erase the area that the cool bar\n* occupies when the size of the cool bar is larger\n* than the space occupied by the cool bar items.\n* The fix is to erase the cool bar background.\n*\n* NOTE: On versions of Windows prior to XP, for\n* some reason, the cool bar draws separators in\n* WM_ERASEBKGND.  Therefore it is essential to run\n* the cool bar window proc after the background has\n* been erased.\n*\n* On XP, this work around is unnecessary because\n* the background is drawn using NM_CUSTOMDRAW.\n*/\n",
			"methodName":"LRESULT WM_ERASEBKGND(int wParam, int lParam)"
		},
		"int getMargin(int index)":{
			"methodBody":"{\n    int margin = 0;\n    if (OS.COMCTL32_MAJOR >= 6) {\n        MARGINS margins = new MARGINS();\n        OS.SendMessage(handle, OS.RB_GETBANDMARGINS, 0, margins);\n        margin += margins.cxLeftWidth + margins.cxRightWidth;\n    }\n    RECT rect = new RECT();\n    OS.SendMessage(handle, OS.RB_GETBANDBORDERS, index, rect);\n    if ((style & SWT.FLAT) != 0) {\n        \n        margin += rect.left + 4;\n    } else {\n        margin += rect.left + rect.right;\n    }\n    return margin;\n}",
			"comments":"/*\n* Bug in Windows.  When the style bit  RBS_BANDBORDERS is not set\n* the rectangle returned by RBS_BANDBORDERS is four pixels too small.\n* The fix is to add four pixels to the result.\n*/\n",
			"methodName":"int getMargin(int index)"
		},
		"void setBackgroundPixel(int pixel)":{
			"methodBody":"{\n    if (background == pixel)\n        return;\n    background = pixel;\n    if (pixel == -1)\n        pixel = defaultBackground();\n    OS.SendMessage(handle, OS.RB_SETBKCOLOR, 0, pixel);\n    setItemColors(OS.SendMessage(handle, OS.RB_GETTEXTCOLOR, 0, 0), pixel);\n    \n    if (!OS.IsWindowVisible(handle))\n        return;\n    if (OS.IsWinCE) {\n        OS.InvalidateRect(handle, null, true);\n    } else {\n        int flags = OS.RDW_ERASE | OS.RDW_FRAME | OS.RDW_INVALIDATE | OS.RDW_ALLCHILDREN;\n        OS.RedrawWindow(handle, null, 0, flags);\n    }\n}",
			"comments":"/*\n* Feature in Windows.  For some reason, Windows\n* does not fully erase the coolbar area and coolbar\n* items when you set the background.  The fix is\n* to invalidate the coolbar area.\n*/\n",
			"methodName":"void setBackgroundPixel(int pixel)"
		},
		"void resizeToPreferredWidth(int index)":{
			"methodBody":"{\n    \n    int count = OS.SendMessage(handle, OS.RB_GETBANDCOUNT, 0, 0);\n    if (0 <= index && index < count) {\n        REBARBANDINFO rbBand = new REBARBANDINFO();\n        rbBand.cbSize = REBARBANDINFO.sizeof;\n        rbBand.fMask = OS.RBBIM_IDEALSIZE;\n        OS.SendMessage(handle, OS.RB_GETBANDINFO, index, rbBand);\n        RECT rect = new RECT();\n        OS.SendMessage(handle, OS.RB_GETBANDBORDERS, index, rect);\n        rbBand.cx = rbBand.cxIdeal + rect.left;\n        if ((style & SWT.FLAT) == 0)\n            rbBand.cx += rect.right;\n        rbBand.fMask = OS.RBBIM_SIZE;\n        OS.SendMessage(handle, OS.RB_SETBANDINFO, index, rbBand);\n    }\n}",
			"comments":"/*\n* Bug in Windows.  When RB_GETBANDBORDERS is sent\n* with an index out of range, Windows GP's.  The\n* fix is to ensure the index is in range.\n*/\n",
			"methodName":"void resizeToPreferredWidth(int index)"
		},
		"public boolean getLocked()":{
			"methodBody":"{\n    checkWidget();\n    return locked;\n}",
			"comments":"/**\n* Returns whether or not the receiver is 'locked'. When a coolbar\n* is locked, its items cannot be repositioned.\n*\n* @return true if the coolbar is locked, false otherwise\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 2.0\n*/\n",
			"methodName":"public boolean getLocked()"
		},
		"LRESULT WM_SETREDRAW(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_SETREDRAW(wParam, lParam);\n    if (result != null)\n        return result;\n    \n    if (OS.COMCTL32_MAJOR >= 6)\n        return LRESULT.ZERO;\n    Rectangle rect = getBounds();\n    int code = callWindowProc(handle, OS.WM_SETREDRAW, wParam, lParam);\n    OS.DefWindowProc(handle, OS.WM_SETREDRAW, wParam, lParam);\n    if (!rect.equals(getBounds())) {\n        parent.redraw(rect.x, rect.y, rect.width, rect.height, true);\n    }\n    return new LRESULT(code);\n}",
			"comments":"/*\n* Feature in Windows.  When redraw is turned off, the rebar\n* control does not call the default window proc.  This means\n* that the rebar will redraw and children of the rebar will\n* also redraw.  The fix is to call both the rebar window proc\n* and the default window proc.\n*\n* NOTE: The rebar control can resize itself in WM_SETREDRAW.\n* When redraw is turned off by the default window proc, this\n* can leave pixel corruption in the parent.  The fix is to\n* detect the size change and damage the previous area in the\n* parent.\n*\n* NOTE:  In version 6.00 of COMCTL32.DLL, when WM_SETREDRAW\n* is off, we cannot detect that the size has changed causing\n* pixel corruption.  The fix is to disallow WM_SETREDRAW by\n* not running the default window proc or the rebar window\n* proc.\n*/\n",
			"methodName":"LRESULT WM_SETREDRAW(int wParam, int lParam)"
		},
		"protected void checkSubclass()":{
			"methodBody":"{\n    if (!isValidSubclass())\n        error(SWT.ERROR_INVALID_SUBCLASS);\n}",
			"comments":"",
			"methodName":"protected void checkSubclass()"
		},
		"void destroyItem(CoolItem item)":{
			"methodBody":"{\n    int index = OS.SendMessage(handle, OS.RB_IDTOINDEX, item.id, 0);\n    int count = OS.SendMessage(handle, OS.RB_GETBANDCOUNT, 0, 0);\n    if (count != 0) {\n        int lastIndex = getLastIndexOfRow(index);\n        if (index == lastIndex) {\n            \n            resizeToMaximumWidth(lastIndex - 1);\n        }\n    }\n    \n    Control control = item.control;\n    boolean wasVisible = control != null && !control.isDisposed() && control.getVisible();\n    \n    CoolItem nextItem = null;\n    if (item.getWrap()) {\n        if (index + 1 < count) {\n            nextItem = getItem(index + 1);\n            ignoreResize = !nextItem.getWrap();\n        }\n    }\n    if (OS.SendMessage(handle, OS.RB_DELETEBAND, index, 0) == 0) {\n        error(SWT.ERROR_ITEM_NOT_REMOVED);\n    }\n    items[item.id] = null;\n    item.id = -1;\n    if (ignoreResize) {\n        nextItem.setWrap(true);\n        ignoreResize = false;\n    }\n    \n    if (wasVisible)\n        control.setVisible(true);\n    index = 0;\n    while (index < originalItems.length) {\n        if (originalItems[index] == item)\n            break;\n        index++;\n    }\n    int length = originalItems.length - 1;\n    CoolItem[] newOriginals = new CoolItem[length];\n    System.arraycopy(originalItems, 0, newOriginals, 0, index);\n    System.arraycopy(originalItems, index + 1, newOriginals, index, length - index);\n    originalItems = newOriginals;\n}",
			"comments":"/*\n* Feature in Windows.  If the last item in a row is\n* given its ideal size, it will be placed at the far\n* right hand edge of the coolbar.  It is preferred\n* that the last item appear next to the second last\n* item.  The fix is to size the last item of each row\n* so that it occupies all the available space to the\n* right in the row.\n*/\n/*\n* Feature in Windows.  When Windows removed a rebar\n* band, it makes the band child invisible.  The fix\n* is to show the child.\n*/\n/*\n* When a wrapped item is being deleted, make the next\n* item in the row wrapped in order to preserve the row.\n* In order to avoid an unnecessary layout, temporarily\n* ignore WM_SIZE.  If the next item is wrapped then a\n* row will be deleted and the WM_SIZE is necessary.\n*/\n/* Restore the visible state tof the control */\n",
			"methodName":"void destroyItem(CoolItem item)"
		},
		"public CoolItem[] getItems()":{
			"methodBody":"{\n    checkWidget();\n    int count = OS.SendMessage(handle, OS.RB_GETBANDCOUNT, 0, 0);\n    CoolItem[] result = new CoolItem[count];\n    REBARBANDINFO rbBand = new REBARBANDINFO();\n    rbBand.cbSize = REBARBANDINFO.sizeof;\n    rbBand.fMask = OS.RBBIM_ID;\n    for (int i = 0; i < count; i++) {\n        OS.SendMessage(handle, OS.RB_GETBANDINFO, i, rbBand);\n        result[i] = items[rbBand.wID];\n    }\n    return result;\n}",
			"comments":"/**\n* Returns an array of <code>CoolItem</code>s in the order\n* in which they are currently being displayed.\n* <p>\n* Note: This is not the actual structure used by the receiver\n* to maintain its list of items, so modifying the array will\n* not affect the receiver.\n* </p>\n*\n* @return the receiver's items in their current visual order\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public CoolItem[] getItems()"
		},
		"void setItemOrder(int[] itemOrder)":{
			"methodBody":"{\n    if (itemOrder == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    int itemCount = OS.SendMessage(handle, OS.RB_GETBANDCOUNT, 0, 0);\n    if (itemOrder.length != itemCount)\n        error(SWT.ERROR_INVALID_ARGUMENT);\n    \n    boolean[] set = new boolean[itemCount];\n    for (int i = 0; i < itemOrder.length; i++) {\n        int index = itemOrder[i];\n        if (index < 0 || index >= itemCount)\n            error(SWT.ERROR_INVALID_RANGE);\n        if (set[index])\n            error(SWT.ERROR_INVALID_ARGUMENT);\n        set[index] = true;\n    }\n    REBARBANDINFO rbBand = new REBARBANDINFO();\n    rbBand.cbSize = REBARBANDINFO.sizeof;\n    for (int i = 0; i < itemOrder.length; i++) {\n        int id = originalItems[itemOrder[i]].id;\n        int index = OS.SendMessage(handle, OS.RB_IDTOINDEX, id, 0);\n        if (index != i) {\n            int lastItemSrcRow = getLastIndexOfRow(index);\n            int lastItemDstRow = getLastIndexOfRow(i);\n            if (index == lastItemSrcRow) {\n                resizeToPreferredWidth(index);\n            }\n            if (i == lastItemDstRow) {\n                resizeToPreferredWidth(i);\n            }\n            \n            OS.SendMessage(handle, OS.RB_MOVEBAND, index, i);\n            if (index == lastItemSrcRow && index - 1 >= 0) {\n                resizeToMaximumWidth(index - 1);\n            }\n            if (i == lastItemDstRow) {\n                resizeToMaximumWidth(i);\n            }\n        }\n    }\n}",
			"comments":"/*\n* Sets the order that the items in the receiver should\n* be displayed in to the given argument which is described\n* in terms of the zero-relative ordering of when the items\n* were added.\n*\n* @param itemOrder the new order to display the items in\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the item order is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the item order is not the same length as the number of items</li>\n* </ul>\n*/\n/* Ensure that itemOrder does not contain any duplicates. */\n/* Move the item */\n",
			"methodName":"void setItemOrder(int[] itemOrder)"
		},
		"public void setWrapIndices(int[] indices)":{
			"methodBody":"{\n    checkWidget();\n    if (indices == null)\n        indices = new int[0];\n    int count = getItemCount();\n    for (int i = 0; i < indices.length; i++) {\n        if (indices[i] < 0 || indices[i] >= count) {\n            error(SWT.ERROR_INVALID_RANGE);\n        }\n    }\n    setRedraw(false);\n    CoolItem[] items = getItems();\n    for (int i = 0; i < items.length; i++) {\n        CoolItem item = items[i];\n        if (item.getWrap()) {\n            resizeToPreferredWidth(i - 1);\n            item.setWrap(false);\n        }\n    }\n    resizeToMaximumWidth(count - 1);\n    for (int i = 0; i < indices.length; i++) {\n        int index = indices[i];\n        if (0 <= index && index < items.length) {\n            CoolItem item = items[index];\n            item.setWrap(true);\n            resizeToMaximumWidth(index - 1);\n        }\n    }\n    setRedraw(true);\n}",
			"comments":"/**\n* Sets the indices of all item(s) in the receiver that will\n* begin on a new row. The indices are given in the order in\n* which they are currently being displayed. The 0th item\n* always begins the first row, therefore it does not count\n* as a wrap index. If indices is null or empty, the items\n* will be placed on one line.\n*\n* @param indices an array of wrap indices, or null\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setWrapIndices(int[] indices)"
		},
		"LRESULT WM_NOTIFY(int wParam, int lParam)":{
			"methodBody":"{\n    \n    LRESULT result = super.WM_NOTIFY(wParam, lParam);\n    if (result != null)\n        return result;\n    return LRESULT.ZERO;\n}",
			"comments":"/*\n* Feature in Windows.  When the cool bar window\n* proc processes WM_NOTIFY, it forwards this\n* message to its parent.  This is done so that\n* children of this control that send this message\n* type to their parent will notify not only\n* this control but also the parent of this control,\n* which is typically the application window and\n* the window that is looking for the message.\n* If the control did not forward the message,\n* applications would have to subclass the control\n* window to see the message. Because the control\n* window is subclassed by SWT, the message\n* is delivered twice, once by SWT and once when\n* the message is forwarded by the window proc.\n* The fix is to avoid calling the window proc\n* for this control.\n*/\n",
			"methodName":"LRESULT WM_NOTIFY(int wParam, int lParam)"
		},
		"void removeControl(Control control)":{
			"methodBody":"{\n    super.removeControl(control);\n    for (int i = 0; i < items.length; i++) {\n        CoolItem item = items[i];\n        if (item != null && item.control == control) {\n            item.setControl(null);\n        }\n    }\n}",
			"comments":"",
			"methodName":"void removeControl(Control control)"
		},
		"static int checkStyle(int style)":{
			"methodBody":"{\n    style |= SWT.NO_FOCUS;\n    \n    return style & ~(SWT.H_SCROLL | SWT.V_SCROLL);\n}",
			"comments":"/*\n* Even though it is legal to create this widget\n* with scroll bars, they serve no useful purpose\n* because they do not automatically scroll the\n* widget's client area.  The fix is to clear\n* the SWT style.\n*/\n",
			"methodName":"static int checkStyle(int style)"
		},
		"public void setLocked(boolean locked)":{
			"methodBody":"{\n    checkWidget();\n    this.locked = locked;\n    int count = OS.SendMessage(handle, OS.RB_GETBANDCOUNT, 0, 0);\n    REBARBANDINFO rbBand = new REBARBANDINFO();\n    rbBand.cbSize = REBARBANDINFO.sizeof;\n    rbBand.fMask = OS.RBBIM_STYLE;\n    for (int i = 0; i < count; i++) {\n        OS.SendMessage(handle, OS.RB_GETBANDINFO, i, rbBand);\n        if (locked) {\n            rbBand.fStyle |= OS.RBBS_NOGRIPPER;\n        } else {\n            rbBand.fStyle &= ~OS.RBBS_NOGRIPPER;\n        }\n        OS.SendMessage(handle, OS.RB_SETBANDINFO, i, rbBand);\n    }\n}",
			"comments":"/**\n* Sets whether or not the receiver is 'locked'. When a coolbar\n* is locked, its items cannot be repositioned.\n*\n* @param locked lock the coolbar if true, otherwise unlock the coolbar\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 2.0\n*/\n",
			"methodName":"public void setLocked(boolean locked)"
		},
		"LRESULT WM_COMMAND(int wParam, int lParam)":{
			"methodBody":"{\n    \n    LRESULT result = super.WM_COMMAND(wParam, lParam);\n    if (result != null)\n        return result;\n    return LRESULT.ZERO;\n}",
			"comments":"/*\n* Feature in Windows.  When the coolbar window\n* proc processes WM_COMMAND, it forwards this\n* message to its parent.  This is done so that\n* children of this control that send this message\n* type to their parent will notify not only\n* this control but also the parent of this control,\n* which is typically the application window and\n* the window that is looking for the message.\n* If the control did not forward the message,\n* applications would have to subclass the control\n* window to see the message. Because the control\n* window is subclassed by SWT, the message\n* is delivered twice, once by SWT and once when\n* the message is forwarded by the window proc.\n* The fix is to avoid calling the window proc\n* for this control.\n*/\n",
			"methodName":"LRESULT WM_COMMAND(int wParam, int lParam)"
		},
		"void createWidget()":{
			"methodBody":"{\n    super.createWidget();\n    items = new CoolItem[4];\n    originalItems = new CoolItem[0];\n}",
			"comments":"",
			"methodName":"void createWidget()"
		},
		"public Point computeSize(int wHint, int hHint, boolean changed)":{
			"methodBody":"{\n    checkWidget();\n    int width = 0, height = 0;\n    int border = getBorderWidth();\n    int newWidth = wHint == SWT.DEFAULT ? 0x3FFF : wHint + (border * 2);\n    int newHeight = hHint == SWT.DEFAULT ? 0x3FFF : hHint + (border * 2);\n    int count = OS.SendMessage(handle, OS.RB_GETBANDCOUNT, 0, 0);\n    if (count != 0) {\n        ignoreResize = true;\n        boolean redraw = false;\n        if (OS.IsWindowVisible(handle)) {\n            if (OS.COMCTL32_MAJOR >= 6) {\n                redraw = true;\n                OS.UpdateWindow(handle);\n                OS.DefWindowProc(handle, OS.WM_SETREDRAW, 0, 0);\n            } else {\n                redraw = drawCount == 0;\n                if (redraw) {\n                    OS.UpdateWindow(handle);\n                    OS.SendMessage(handle, OS.WM_SETREDRAW, 0, 0);\n                }\n            }\n        }\n        RECT oldRect = new RECT();\n        OS.GetWindowRect(handle, oldRect);\n        int oldWidth = oldRect.right - oldRect.left;\n        int oldHeight = oldRect.bottom - oldRect.top;\n        int flags = OS.SWP_NOACTIVATE | OS.SWP_NOMOVE | OS.SWP_NOREDRAW | OS.SWP_NOZORDER;\n        SetWindowPos(handle, 0, 0, 0, newWidth, newHeight, flags);\n        RECT rect = new RECT();\n        OS.SendMessage(handle, OS.RB_GETRECT, count - 1, rect);\n        height = Math.max(height, rect.bottom);\n        SetWindowPos(handle, 0, 0, 0, oldWidth, oldHeight, flags);\n        REBARBANDINFO rbBand = new REBARBANDINFO();\n        rbBand.cbSize = REBARBANDINFO.sizeof;\n        rbBand.fMask = OS.RBBIM_IDEALSIZE | OS.RBBIM_STYLE;\n        int rowWidth = 0;\n        int separator = (style & SWT.FLAT) == 0 ? SEPARATOR_WIDTH : 0;\n        for (int i = 0; i < count; i++) {\n            OS.SendMessage(handle, OS.RB_GETBANDINFO, i, rbBand);\n            if ((rbBand.fStyle & OS.RBBS_BREAK) != 0) {\n                width = Math.max(width, rowWidth - separator);\n                rowWidth = 0;\n            }\n            rowWidth += rbBand.cxIdeal + getMargin(i) + separator;\n        }\n        width = Math.max(width, rowWidth - separator);\n        if (redraw) {\n            if (OS.COMCTL32_MAJOR >= 6) {\n                OS.DefWindowProc(handle, OS.WM_SETREDRAW, 1, 0);\n            } else {\n                OS.SendMessage(handle, OS.WM_SETREDRAW, 1, 0);\n            }\n        }\n        ignoreResize = false;\n    }\n    if (width == 0)\n        width = DEFAULT_WIDTH;\n    if (height == 0)\n        height = DEFAULT_HEIGHT;\n    if (wHint != SWT.DEFAULT)\n        width = wHint;\n    if (hHint != SWT.DEFAULT)\n        height = hHint;\n    height += border * 2;\n    width += border * 2;\n    return new Point(width, height);\n}",
			"comments":"",
			"methodName":"public Point computeSize(int wHint, int hHint, boolean changed)"
		},
		"void resizeToMaximumWidth(int index)":{
			"methodBody":"{\n    REBARBANDINFO rbBand = new REBARBANDINFO();\n    rbBand.cbSize = REBARBANDINFO.sizeof;\n    rbBand.fMask = OS.RBBIM_SIZE;\n    rbBand.cx = MAX_WIDTH;\n    OS.SendMessage(handle, OS.RB_SETBANDINFO, index, rbBand);\n}",
			"comments":"",
			"methodName":"void resizeToMaximumWidth(int index)"
		},
		"Control findThemeControl()":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"Control findThemeControl()"
		},
		"public int[] getItemOrder()":{
			"methodBody":"{\n    checkWidget();\n    int count = OS.SendMessage(handle, OS.RB_GETBANDCOUNT, 0, 0);\n    int[] indices = new int[count];\n    REBARBANDINFO rbBand = new REBARBANDINFO();\n    rbBand.cbSize = REBARBANDINFO.sizeof;\n    rbBand.fMask = OS.RBBIM_ID;\n    for (int i = 0; i < count; i++) {\n        OS.SendMessage(handle, OS.RB_GETBANDINFO, i, rbBand);\n        CoolItem item = items[rbBand.wID];\n        int index = 0;\n        while (index < originalItems.length) {\n            if (originalItems[index] == item)\n                break;\n            index++;\n        }\n        if (index == originalItems.length)\n            error(SWT.ERROR_CANNOT_GET_ITEM);\n        indices[i] = index;\n    }\n    return indices;\n}",
			"comments":"/**\n* Returns an array of zero-relative ints that map\n* the creation order of the receiver's items to the\n* order in which they are currently being displayed.\n* <p>\n* Specifically, the indices of the returned array represent\n* the current visual order of the items, and the contents\n* of the array represent the creation order of the items.\n* </p><p>\n* Note: This is not the actual structure used by the receiver\n* to maintain its list of items, so modifying the array will\n* not affect the receiver.\n* </p>\n*\n* @return the current visual order of the receiver's items\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int[] getItemOrder()"
		},
		"public void setItemLayout(int[] itemOrder, int[] wrapIndices, Point[] sizes)":{
			"methodBody":"{\n    checkWidget();\n    setRedraw(false);\n    setItemOrder(itemOrder);\n    setWrapIndices(wrapIndices);\n    setItemSizes(sizes);\n    setRedraw(true);\n}",
			"comments":"/**\n* Sets the receiver's item order, wrap indices, and item sizes\n* all at once. This method is typically used to restore the\n* displayed state of the receiver to a previously stored state.\n* <p>\n* The item order is the order in which the items in the receiver\n* should be displayed, given in terms of the zero-relative ordering\n* of when the items were added.\n* </p><p>\n* The wrap indices are the indices of all item(s) in the receiver\n* that will begin on a new row. The indices are given in the order\n* specified by the item order. The 0th item always begins the first\n* row, therefore it does not count as a wrap index. If wrap indices\n* is null or empty, the items will be placed on one line.\n* </p><p>\n* The sizes are specified in an array of points whose x and y\n* coordinates describe the new widths and heights (respectively)\n* of the receiver's items in the order specified by the item order.\n* </p>\n*\n* @param itemOrder an array of indices that describe the new order to display the items in\n* @param wrapIndices an array of wrap indices, or null\n* @param sizes an array containing the new sizes for each of the receiver's items in visual order\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if item order or sizes is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if item order or sizes is not the same length as the number of items</li>\n* </ul>\n*/\n",
			"methodName":"public void setItemLayout(int[] itemOrder, int[] wrapIndices, Point[] sizes)"
		},
		"TCHAR windowClass()":{
			"methodBody":"{\n    return ReBarClass;\n}",
			"comments":"",
			"methodName":"TCHAR windowClass()"
		},
		"LRESULT WM_SIZE(int wParam, int lParam)":{
			"methodBody":"{\n    if (ignoreResize) {\n        int code = callWindowProc(handle, OS.WM_SIZE, wParam, lParam);\n        if (code == 0)\n            return LRESULT.ZERO;\n        return new LRESULT(code);\n    }\n    return super.WM_SIZE(wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_SIZE(int wParam, int lParam)"
		},
		"int getLastIndexOfRow(int index)":{
			"methodBody":"{\n    int count = OS.SendMessage(handle, OS.RB_GETBANDCOUNT, 0, 0);\n    if (count == 0)\n        return -1;\n    REBARBANDINFO rbBand = new REBARBANDINFO();\n    rbBand.cbSize = REBARBANDINFO.sizeof;\n    rbBand.fMask = OS.RBBIM_STYLE;\n    for (int i = index + 1; i < count; i++) {\n        OS.SendMessage(handle, OS.RB_GETBANDINFO, i, rbBand);\n        if ((rbBand.fStyle & OS.RBBS_BREAK) != 0) {\n            return i - 1;\n        }\n    }\n    return count - 1;\n}",
			"comments":"",
			"methodName":"int getLastIndexOfRow(int index)"
		},
		"boolean isLastItemOfRow(int index)":{
			"methodBody":"{\n    int count = OS.SendMessage(handle, OS.RB_GETBANDCOUNT, 0, 0);\n    if (index + 1 == count)\n        return true;\n    REBARBANDINFO rbBand = new REBARBANDINFO();\n    rbBand.cbSize = REBARBANDINFO.sizeof;\n    rbBand.fMask = OS.RBBIM_STYLE;\n    OS.SendMessage(handle, OS.RB_GETBANDINFO, index + 1, rbBand);\n    return (rbBand.fStyle & OS.RBBS_BREAK) != 0;\n}",
			"comments":"",
			"methodName":"boolean isLastItemOfRow(int index)"
		},
		"void createHandle()":{
			"methodBody":"{\n    super.createHandle();\n    state &= ~CANVAS;\n    \n    int hFont = OS.GetStockObject(OS.SYSTEM_FONT);\n    OS.SendMessage(handle, OS.WM_SETFONT, hFont, 0);\n}",
			"comments":"/*\n* Feature in Windows.  When the control is created,\n* it does not use the default system font.  A new HFONT\n* is created and destroyed when the control is destroyed.\n* This means that a program that queries the font from\n* this control, uses the font in another control and then\n* destroys this control will have the font unexpectedly\n* destroyed in the other control.  The fix is to assign\n* the font ourselves each time the control is created.\n* The control will not destroy a font that it did not\n* create.\n*/\n",
			"methodName":"void createHandle()"
		},
		"void releaseWidget()":{
			"methodBody":"{\n    for (int i = 0; i < items.length; i++) {\n        CoolItem item = items[i];\n        if (item != null && !item.isDisposed()) {\n            item.releaseResources();\n        }\n    }\n    items = null;\n    super.releaseWidget();\n}",
			"comments":"",
			"methodName":"void releaseWidget()"
		},
		"void createItem(CoolItem item, int index)":{
			"methodBody":"{\n    int count = OS.SendMessage(handle, OS.RB_GETBANDCOUNT, 0, 0);\n    if (!(0 <= index && index <= count))\n        error(SWT.ERROR_INVALID_RANGE);\n    int id = 0;\n    while (id < items.length && items[id] != null) id++;\n    if (id == items.length) {\n        CoolItem[] newItems = new CoolItem[items.length + 4];\n        System.arraycopy(items, 0, newItems, 0, items.length);\n        items = newItems;\n    }\n    int hHeap = OS.GetProcessHeap();\n    int lpText = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, TCHAR.sizeof);\n    REBARBANDINFO rbBand = new REBARBANDINFO();\n    rbBand.cbSize = REBARBANDINFO.sizeof;\n    rbBand.fMask = OS.RBBIM_TEXT | OS.RBBIM_STYLE | OS.RBBIM_ID;\n    rbBand.fStyle = OS.RBBS_VARIABLEHEIGHT | OS.RBBS_GRIPPERALWAYS;\n    if ((item.style & SWT.DROP_DOWN) != 0) {\n        rbBand.fStyle |= OS.RBBS_USECHEVRON;\n    }\n    rbBand.lpText = lpText;\n    rbBand.wID = id;\n    \n    int lastIndex = getLastIndexOfRow(index - 1);\n    boolean fixLast = index == lastIndex + 1;\n    if (fixLast) {\n        rbBand.fMask |= OS.RBBIM_SIZE;\n        rbBand.cx = MAX_WIDTH;\n    }\n    \n    if (index == 0 && count > 0) {\n        getItem(0).setWrap(false);\n    }\n    \n    if (OS.SendMessage(handle, OS.RB_INSERTBAND, index, rbBand) == 0) {\n        error(SWT.ERROR_ITEM_NOT_ADDED);\n    }\n    \n    if (fixLast) {\n        resizeToPreferredWidth(lastIndex);\n    }\n    OS.HeapFree(hHeap, 0, lpText);\n    items[item.id = id] = item;\n    int length = originalItems.length;\n    CoolItem[] newOriginals = new CoolItem[length + 1];\n    System.arraycopy(originalItems, 0, newOriginals, 0, index);\n    System.arraycopy(originalItems, index, newOriginals, index + 1, length - index);\n    newOriginals[index] = item;\n    originalItems = newOriginals;\n}",
			"comments":"/*\n* Feature in Windows.  When inserting an item at end of a row,\n* sometimes, Windows will begin to place the item on the right\n* side of the cool bar.  The fix is to resize the new items to\n* the maximum size and then resize the next to last item to the\n* ideal size.\n*/\n/*\n* Feature in Windows. Is possible that the item at index zero\n* has the RBBS_BREAK flag set. When a new item is inserted at\n* position zero, the previous item at position zero moves to\n* a new line.  The fix is to detect this case and clear the\n* RBBS_BREAK flag on the previous item before inserting the\n* new item.\n*/\n/* Insert the item */\n/* Resize the next to last item to the ideal size */\n",
			"methodName":"void createItem(CoolItem item, int index)"
		},
		"public int indexOf(CoolItem item)":{
			"methodBody":"{\n    checkWidget();\n    if (item == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (item.isDisposed())\n        error(SWT.ERROR_INVALID_ARGUMENT);\n    return OS.SendMessage(handle, OS.RB_IDTOINDEX, item.id, 0);\n}",
			"comments":"/**\n* Searches the receiver's items in the order they are currently\n* being displayed, starting at the first item (index 0), until\n* an item is found that is equal to the argument, and returns\n* the index of that item. If no item is found, returns -1.\n*\n* @param item the search item\n* @return the visual order index of the search item, or -1 if the item is not found\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the item is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the item is disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int indexOf(CoolItem item)"
		},
		"void setItemSizes(Point[] sizes)":{
			"methodBody":"{\n    if (sizes == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    int count = OS.SendMessage(handle, OS.RB_GETBANDCOUNT, 0, 0);\n    if (sizes.length != count)\n        error(SWT.ERROR_INVALID_ARGUMENT);\n    REBARBANDINFO rbBand = new REBARBANDINFO();\n    rbBand.cbSize = REBARBANDINFO.sizeof;\n    rbBand.fMask = OS.RBBIM_ID;\n    for (int i = 0; i < count; i++) {\n        OS.SendMessage(handle, OS.RB_GETBANDINFO, i, rbBand);\n        items[rbBand.wID].setSize(sizes[i].x, sizes[i].y);\n    }\n}",
			"comments":"/*\n* Sets the width and height of the receiver's items to the ones\n* specified by the argument, which is an array of points whose x\n* and y coordinates describe the widths and heights (respectively)\n* in the order in which the items are currently being displayed.\n*\n* @param sizes an array containing the new sizes for each of the receiver's items in visual order\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the array of sizes is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the array of sizes is not the same length as the number of items</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"void setItemSizes(Point[] sizes)"
		},
		"int windowProc()":{
			"methodBody":"{\n    return ReBarProc;\n}",
			"comments":"",
			"methodName":"int windowProc()"
		},
		"public CoolItem getItem(int index)":{
			"methodBody":"{\n    checkWidget();\n    int count = OS.SendMessage(handle, OS.RB_GETBANDCOUNT, 0, 0);\n    if (!(0 <= index && index < count))\n        error(SWT.ERROR_INVALID_RANGE);\n    REBARBANDINFO rbBand = new REBARBANDINFO();\n    rbBand.cbSize = REBARBANDINFO.sizeof;\n    rbBand.fMask = OS.RBBIM_ID;\n    OS.SendMessage(handle, OS.RB_GETBANDINFO, index, rbBand);\n    return items[rbBand.wID];\n}",
			"comments":"/**\n* Returns the item that is currently displayed at the given,\n* zero-relative index. Throws an exception if the index is\n* out of range.\n*\n* @param index the visual index of the item to return\n* @return the item at the given visual index\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_RANGE - if the index is not between 0 and the number of elements in the list minus 1 (inclusive)</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public CoolItem getItem(int index)"
		},
		"void setItemColors(int foreColor, int backColor)":{
			"methodBody":"{\n    int count = OS.SendMessage(handle, OS.RB_GETBANDCOUNT, 0, 0);\n    REBARBANDINFO rbBand = new REBARBANDINFO();\n    rbBand.cbSize = REBARBANDINFO.sizeof;\n    rbBand.fMask = OS.RBBIM_COLORS;\n    rbBand.clrFore = foreColor;\n    rbBand.clrBack = backColor;\n    for (int i = 0; i < count; i++) {\n        OS.SendMessage(handle, OS.RB_SETBANDINFO, i, rbBand);\n    }\n}",
			"comments":"",
			"methodName":"void setItemColors(int foreColor, int backColor)"
		},
		"public int[] getWrapIndices()":{
			"methodBody":"{\n    checkWidget();\n    CoolItem[] items = getItems();\n    int[] indices = new int[items.length];\n    int count = 0;\n    for (int i = 0; i < items.length; i++) {\n        if (items[i].getWrap())\n            indices[count++] = i;\n    }\n    int[] result = new int[count];\n    System.arraycopy(indices, 0, result, 0, count);\n    return result;\n}",
			"comments":"/**\n* Returns an array of ints that describe the zero-relative\n* indices of any item(s) in the receiver that will begin on\n* a new row. The 0th visible item always begins the first row,\n* therefore it does not count as a wrap index.\n*\n* @return an array containing the receiver's wrap indices, or an empty array if all items are in one row\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int[] getWrapIndices()"
		},
		"int callWindowProc(int hwnd, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    if (handle == 0)\n        return 0;\n    return OS.CallWindowProc(ReBarProc, hwnd, msg, wParam, lParam);\n}",
			"comments":"",
			"methodName":"int callWindowProc(int hwnd, int msg, int wParam, int lParam)"
		},
		"void setForegroundPixel(int pixel)":{
			"methodBody":"{\n    if (foreground == pixel)\n        return;\n    foreground = pixel;\n    if (pixel == -1)\n        pixel = defaultForeground();\n    OS.SendMessage(handle, OS.RB_SETTEXTCOLOR, 0, pixel);\n    setItemColors(pixel, OS.SendMessage(handle, OS.RB_GETBKCOLOR, 0, 0));\n}",
			"comments":"",
			"methodName":"void setForegroundPixel(int pixel)"
		},
		"int widgetStyle()":{
			"methodBody":"{\n    int bits = super.widgetStyle() | OS.CCS_NODIVIDER | OS.CCS_NORESIZE;\n    bits |= OS.RBS_VARHEIGHT | OS.RBS_DBLCLKTOGGLE;\n    if ((style & SWT.FLAT) == 0)\n        bits |= OS.RBS_BANDBORDERS;\n    return bits;\n}",
			"comments":"",
			"methodName":"int widgetStyle()"
		},
		"public int getItemCount()":{
			"methodBody":"{\n    checkWidget();\n    return OS.SendMessage(handle, OS.RB_GETBANDCOUNT, 0, 0);\n}",
			"comments":"/**\n* Returns the number of items contained in the receiver.\n*\n* @return the number of items\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getItemCount()"
		}
	},
	"ClassORInterfaceName":[
		"CoolBar"
	]
}
