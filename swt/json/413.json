{
	"variables":[
		"iUnknown",
		"iOleClientSite",
		"iAdviseSink",
		"iOleInPlaceSite",
		"iOleDocumentSite",
		"appClsid",
		"objClsid",
		"refCount",
		"frame",
		"objIUnknown",
		"objIOleObject",
		"objIViewObject2",
		"objIOleInPlaceObject",
		"objIOleCommandTarget",
		"objDocumentView",
		"tempStorage",
		"aspect",
		"type",
		"isStatic",
		"borderWidths",
		"indent",
		"inUpdate",
		"inInit",
		"inDispose",
		"WORDPROGID",
		"listener",
		"STATE_NONE",
		"STATE_RUNNING",
		"STATE_INPLACEACTIVE",
		"STATE_UIACTIVE",
		"STATE_ACTIVE",
		"state",
		"fileName",
		"result",
		"address",
		"address",
		"result",
		"fileName",
		"fileClsid",
		"address",
		"result",
		"storage",
		"address",
		"mode",
		"result",
		"address",
		"mode",
		"result",
		"streamName",
		"wordGUID",
		"stream",
		"fileInput",
		"increment",
		"buffer",
		"count",
		"pv",
		"result",
		"ppv",
		"iPersistStorage",
		"ppvObject",
		"objIPersist",
		"tempid",
		"result",
		"pdwConnection",
		"objIOleLink",
		"ppmk",
		"objIMoniker",
		"tempStorage",
		"grfMode",
		"result",
		"result",
		"address",
		"inAddress",
		"outAddress",
		"result",
		"ppvObject",
		"guid",
		"buffer",
		"count",
		"result",
		"sizel",
		"lplpszProgID",
		"hMem",
		"length",
		"ptr",
		"buffer",
		"result",
		"index",
		"ppvObject",
		"objOleDocument",
		"rect",
		"location",
		"area",
		"rect",
		"iOleInPlaceFrame",
		"rect",
		"frameInfo",
		"shell",
		"menubar",
		"hwnd",
		"cAccel",
		"hAccel",
		"address",
		"permStorage",
		"result",
		"focusHwnd",
		"phwnd",
		"phwnd",
		"ppvObject",
		"shell",
		"size",
		"size",
		"area",
		"rect",
		"pArea",
		"area",
		"phwnd",
		"shell",
		"menubar",
		"shellHandle",
		"guid",
		"address",
		"olecmd",
		"result",
		"success",
		"tempContents",
		"writer",
		"increment",
		"pv",
		"pcbWritten",
		"buffer",
		"success",
		"tempContents",
		"pv",
		"size",
		"rc",
		"buffer",
		"writer",
		"address",
		"permStorage",
		"path",
		"mode",
		"result",
		"storage",
		"address",
		"area",
		"currentExtent",
		"newExtent",
		"alreadyRunning",
		"rect",
		"ppvObject",
		"objISPP",
		"caGUID",
		"result",
		"chTitle",
		"ppv",
		"iPersistStorage",
		"result",
		"hDC",
		"xppi",
		"yppi",
		"cx",
		"cy",
		"size",
		"hDC",
		"xppi",
		"yppi",
		"cx",
		"cy",
		"size",
		"STATE_NONE",
		"parent",
		"style",
		"parent",
		"parent",
		"frame",
		"parent",
		"parent",
		"parent",
		"frame",
		"OLE",
		"SWT",
		"frame",
		"aspect",
		"COM",
		"type",
		"COM",
		"isStatic",
		"listener",
		"e",
		"SWT",
		"SWT",
		"e",
		"SWT",
		"e",
		"SWT",
		"e",
		"SWT",
		"e",
		"SWT",
		"e",
		"SWT",
		"e",
		"SWT",
		"OLE",
		"SWT",
		"frame",
		"SWT",
		"listener",
		"frame",
		"SWT",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"listener",
		"parent",
		"style",
		"file",
		"file",
		"file",
		"OLE",
		"OLE",
		"appClsid",
		"file",
		"COM",
		"fileName",
		"appClsid",
		"result",
		"COM",
		"OLE",
		"OLE",
		"result",
		"OLE",
		"OLE",
		"result",
		"tempStorage",
		"result",
		"COM",
		"appClsid",
		"fileName",
		"COM",
		"COM",
		"tempStorage",
		"address",
		"result",
		"COM",
		"OLE",
		"OLE",
		"result",
		"objIUnknown",
		"address",
		"COM",
		"objIUnknown",
		"OLE",
		"state",
		"STATE_RUNNING",
		"e",
		"parent",
		"style",
		"appClsid",
		"progId",
		"appClsid",
		"OLE",
		"OLE",
		"tempStorage",
		"COM",
		"appClsid",
		"COM",
		"COM",
		"tempStorage",
		"address",
		"result",
		"COM",
		"OLE",
		"OLE",
		"result",
		"objIUnknown",
		"address",
		"COM",
		"objIUnknown",
		"OLE",
		"state",
		"STATE_RUNNING",
		"e",
		"parent",
		"style",
		"file",
		"file",
		"file",
		"OLE",
		"OLE",
		"appClsid",
		"progId",
		"file",
		"COM",
		"fileName",
		"fileClsid",
		"COM",
		"appClsid",
		"fileClsid",
		"tempStorage",
		"COM",
		"appClsid",
		"fileName",
		"COM",
		"COM",
		"tempStorage",
		"address",
		"result",
		"COM",
		"OLE",
		"OLE",
		"result",
		"objIUnknown",
		"address",
		"COM",
		"fileName",
		"COM",
		"COM",
		"COM",
		"COM",
		"COM",
		"fileName",
		"mode",
		"address",
		"result",
		"COM",
		"OLE",
		"OLE",
		"result",
		"storage",
		"address",
		"COM",
		"COM",
		"COM",
		"COM",
		"COM",
		"mode",
		"COM",
		"address",
		"result",
		"COM",
		"OLE",
		"OLE",
		"result",
		"storage",
		"address",
		"WORDPROGID",
		"COM",
		"appClsid",
		"wordGUID",
		"streamName",
		"address",
		"result",
		"storage",
		"streamName",
		"mode",
		"address",
		"result",
		"COM",
		"storage",
		"OLE",
		"OLE",
		"result",
		"address",
		"file",
		"increment",
		"count",
		"fileInput",
		"buffer",
		"COM",
		"count",
		"OS",
		"pv",
		"buffer",
		"count",
		"result",
		"stream",
		"pv",
		"count",
		"COM",
		"pv",
		"result",
		"COM",
		"fileInput",
		"stream",
		"storage",
		"OLE",
		"OLE",
		"result",
		"fileInput",
		"stream",
		"COM",
		"stream",
		"stream",
		"storage",
		"OLE",
		"OLE",
		"tempStorage",
		"storage",
		"tempStorage",
		"storage",
		"result",
		"COM",
		"OLE",
		"OLE",
		"result",
		"result",
		"COM",
		"appClsid",
		"COM",
		"COM",
		"COM",
		"ppv",
		"result",
		"COM",
		"OLE",
		"OLE",
		"result",
		"objIUnknown",
		"ppv",
		"ppv",
		"result",
		"objIUnknown",
		"COM",
		"ppv",
		"result",
		"COM",
		"OLE",
		"OLE",
		"result",
		"ppv",
		"result",
		"iPersistStorage",
		"tempStorage",
		"iPersistStorage",
		"result",
		"COM",
		"OLE",
		"OLE",
		"result",
		"COM",
		"objIUnknown",
		"OLE",
		"state",
		"STATE_RUNNING",
		"e",
		"objIUnknown",
		"COM",
		"ppvObject",
		"COM",
		"ppvObject",
		"objIPersist",
		"tempid",
		"COM",
		"objClsid",
		"tempid",
		"objIPersist",
		"ppvObject",
		"objIUnknown",
		"COM",
		"ppvObject",
		"result",
		"COM",
		"OLE",
		"OLE",
		"result",
		"objIViewObject2",
		"ppvObject",
		"objIViewObject2",
		"aspect",
		"iAdviseSink",
		"ppvObject",
		"result",
		"objIUnknown",
		"COM",
		"ppvObject",
		"result",
		"COM",
		"OLE",
		"OLE",
		"result",
		"objIOleObject",
		"ppvObject",
		"objIOleObject",
		"iOleClientSite",
		"objIOleObject",
		"iAdviseSink",
		"pdwConnection",
		"objIOleObject",
		"COM",
		"objIUnknown",
		"ppvObject",
		"objIUnknown",
		"COM",
		"ppvObject",
		"COM",
		"ppvObject",
		"objIOleLink",
		"ppmk",
		"COM",
		"ppmk",
		"objIMoniker",
		"type",
		"COM",
		"objIOleLink",
		"isStatic",
		"objIOleLink",
		"refCount",
		"refCount",
		"aspect",
		"COM",
		"type",
		"COM",
		"COM",
		"COM",
		"COM",
		"iUnknown",
		"args",
		"args",
		"iOleClientSite",
		"args",
		"args",
		"args",
		"args",
		"iAdviseSink",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"iOleInPlaceSite",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"iOleDocumentSite",
		"args",
		"args",
		"args",
		"COM",
		"COM",
		"COM",
		"COM",
		"grfMode",
		"tempStorage",
		"result",
		"COM",
		"OLE",
		"OLE",
		"result",
		"tempStorage",
		"objIOleInPlaceObject",
		"objIOleInPlaceObject",
		"tempStorage",
		"tempStorage",
		"tempStorage",
		"iUnknown",
		"iUnknown",
		"iUnknown",
		"iOleClientSite",
		"iOleClientSite",
		"iOleClientSite",
		"iAdviseSink",
		"iAdviseSink",
		"iAdviseSink",
		"iOleInPlaceSite",
		"iOleInPlaceSite",
		"iOleInPlaceSite",
		"iOleDocumentSite",
		"iOleDocumentSite",
		"iOleDocumentSite",
		"state",
		"STATE_NONE",
		"COM",
		"objIUnknown",
		"OLE",
		"state",
		"STATE_RUNNING",
		"state",
		"STATE_NONE",
		"isStatic",
		"COM",
		"objIOleObject",
		"verb",
		"iOleClientSite",
		"handle",
		"state",
		"STATE_RUNNING",
		"inInit",
		"inInit",
		"result",
		"objIOleCommandTarget",
		"objIUnknown",
		"COM",
		"address",
		"COM",
		"OLE",
		"objIOleCommandTarget",
		"address",
		"in",
		"inAddress",
		"OS",
		"OS",
		"OS",
		"Variant",
		"in",
		"inAddress",
		"out",
		"outAddress",
		"OS",
		"OS",
		"OS",
		"Variant",
		"out",
		"outAddress",
		"objIOleCommandTarget",
		"cmdID",
		"options",
		"inAddress",
		"outAddress",
		"inAddress",
		"COM",
		"inAddress",
		"OS",
		"inAddress",
		"outAddress",
		"out",
		"outAddress",
		"COM",
		"outAddress",
		"OS",
		"outAddress",
		"result",
		"objIUnknown",
		"COM",
		"ppvObject",
		"COM",
		"ppvObject",
		"clientName",
		"clientName",
		"buffer",
		"count",
		"clientName",
		"count",
		"buffer",
		"COM",
		"buffer",
		"guid",
		"COM",
		"COM",
		"buffer",
		"guid",
		"result",
		"COM",
		"OLE",
		"OLE",
		"result",
		"guid",
		"ppContainer",
		"COM",
		"ppContainer",
		"COM",
		"objIOleObject",
		"objIViewObject2",
		"COM",
		"objIOleObject",
		"objIViewObject2",
		"aspect",
		"sizel",
		"objIOleObject",
		"aspect",
		"sizel",
		"sizel",
		"indent",
		"indent",
		"indent",
		"indent",
		"appClsid",
		"COM",
		"appClsid",
		"lplpszProgID",
		"COM",
		"lplpszProgID",
		"OS",
		"hMem",
		"OS",
		"hMem",
		"length",
		"COM",
		"buffer",
		"ptr",
		"length",
		"OS",
		"hMem",
		"OS",
		"hMem",
		"buffer",
		"result",
		"result",
		"index",
		"pViewToActivate",
		"objIUnknown",
		"COM",
		"ppvObject",
		"COM",
		"COM",
		"ppvObject",
		"objOleDocument",
		"iOleInPlaceSite",
		"ppvObject",
		"COM",
		"COM",
		"objOleDocument",
		"objDocumentView",
		"ppvObject",
		"objDocumentView",
		"pViewToActivate",
		"objDocumentView",
		"objDocumentView",
		"iOleInPlaceSite",
		"objDocumentView",
		"objDocumentView",
		"rect",
		"objDocumentView",
		"COM",
		"phwnd",
		"COM",
		"frame",
		"COM",
		"phwnd",
		"COM",
		"COM",
		"phwnd",
		"frame",
		"COM",
		"frame",
		"rect",
		"location",
		"rect",
		"location",
		"rect",
		"location",
		"area",
		"borderWidths",
		"borderWidths",
		"rect",
		"location",
		"area",
		"borderWidths",
		"borderWidths",
		"rect",
		"frame",
		"ppFrame",
		"COM",
		"frame",
		"COM",
		"ppFrame",
		"iOleInPlaceFrame",
		"frame",
		"ppDoc",
		"COM",
		"ppDoc",
		"lprcPosRect",
		"OS",
		"lprcPosRect",
		"rect",
		"RECT",
		"lprcClipRect",
		"OS",
		"lprcClipRect",
		"rect",
		"RECT",
		"frameInfo",
		"OLEINPLACEFRAMEINFO",
		"frameInfo",
		"frameInfo",
		"frame",
		"shell",
		"menubar",
		"menubar",
		"shell",
		"OS",
		"hwnd",
		"OS",
		"cAccel",
		"OS",
		"hwnd",
		"OS",
		"hAccel",
		"frameInfo",
		"cAccel",
		"frameInfo",
		"hAccel",
		"COM",
		"lpFrameInfo",
		"frameInfo",
		"OLEINPLACEFRAMEINFO",
		"COM",
		"objIOleObject",
		"COM",
		"address",
		"COM",
		"address",
		"permStorage",
		"permStorage",
		"result",
		"COM",
		"OS",
		"objIOleInPlaceObject",
		"handle",
		"focusHwnd",
		"objIOleInPlaceObject",
		"phwnd",
		"focusHwnd",
		"phwnd",
		"focusHwnd",
		"focusHwnd",
		"OS",
		"focusHwnd",
		"COM",
		"COM",
		"inDispose",
		"state",
		"STATE_NONE",
		"OLE",
		"SWT",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"listener",
		"frame",
		"SWT",
		"listener",
		"frame",
		"SWT",
		"listener",
		"frame",
		"frame",
		"inDispose",
		"state",
		"STATE_UIACTIVE",
		"OLE",
		"objIOleInPlaceObject",
		"objIOleInPlaceObject",
		"phwnd",
		"phwnd",
		"OS",
		"phwnd",
		"state",
		"STATE_INPLACEACTIVE",
		"frame",
		"objIOleObject",
		"COM",
		"objIOleObject",
		"COM",
		"ppvObject",
		"COM",
		"objIOleInPlaceObject",
		"ppvObject",
		"COM",
		"objIOleInPlaceObject",
		"objIOleInPlaceObject",
		"objIOleInPlaceObject",
		"state",
		"STATE_RUNNING",
		"frame",
		"shell",
		"SWT",
		"COM",
		"size",
		"size",
		"COM",
		"state",
		"STATE_RUNNING",
		"state",
		"STATE_INPLACEACTIVE",
		"rect",
		"area",
		"rect",
		"area",
		"area",
		"size",
		"size",
		"rect",
		"area",
		"rect",
		"area",
		"area",
		"rect",
		"area",
		"rect",
		"area",
		"size",
		"rect",
		"area",
		"rect",
		"area",
		"size",
		"OS",
		"COM",
		"COM",
		"RECT",
		"OS",
		"pArea",
		"rect",
		"RECT",
		"COM",
		"objIUnknown",
		"aspect",
		"e",
		"pArea",
		"OS",
		"pArea",
		"frame",
		"borderWidths",
		"borderWidths",
		"area",
		"borderWidths",
		"borderWidths",
		"area",
		"borderWidths",
		"borderWidths",
		"COM",
		"objIOleInPlaceObject",
		"COM",
		"state",
		"STATE_UIACTIVE",
		"objIOleInPlaceObject",
		"phwnd",
		"COM",
		"OS",
		"phwnd",
		"OS",
		"OS",
		"OS",
		"COM",
		"frame",
		"frame",
		"COM",
		"state",
		"STATE_INPLACEACTIVE",
		"frame",
		"frame",
		"shell",
		"SWT",
		"shell",
		"menubar",
		"menubar",
		"COM",
		"shell",
		"OS",
		"shellHandle",
		"menubar",
		"COM",
		"shellHandle",
		"event",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"event",
		"COM",
		"riid",
		"ppvObject",
		"COM",
		"COM",
		"guid",
		"riid",
		"GUID",
		"COM",
		"guid",
		"COM",
		"COM",
		"ppvObject",
		"iUnknown",
		"COM",
		"COM",
		"guid",
		"COM",
		"COM",
		"ppvObject",
		"iAdviseSink",
		"COM",
		"COM",
		"guid",
		"COM",
		"COM",
		"ppvObject",
		"iOleClientSite",
		"COM",
		"COM",
		"guid",
		"COM",
		"COM",
		"ppvObject",
		"iOleInPlaceSite",
		"COM",
		"COM",
		"ppvObject",
		"COM",
		"objIOleCommandTarget",
		"objIUnknown",
		"COM",
		"address",
		"COM",
		"objIOleCommandTarget",
		"address",
		"olecmd",
		"cmd",
		"objIOleCommandTarget",
		"olecmd",
		"result",
		"COM",
		"olecmd",
		"refCount",
		"refCount",
		"refCount",
		"objIOleInPlaceObject",
		"objIOleInPlaceObject",
		"objIOleInPlaceObject",
		"objIOleObject",
		"objIOleObject",
		"COM",
		"objIOleObject",
		"objIOleObject",
		"objDocumentView",
		"objDocumentView",
		"objDocumentView",
		"objIViewObject2",
		"objIViewObject2",
		"aspect",
		"objIViewObject2",
		"objIViewObject2",
		"objIOleCommandTarget",
		"objIOleCommandTarget",
		"objIOleCommandTarget",
		"objIUnknown",
		"objIUnknown",
		"objIUnknown",
		"COM",
		"includeOleInfo",
		"file",
		"file",
		"address",
		"tempContents",
		"file",
		"COM",
		"increment",
		"tempContents",
		"pv",
		"increment",
		"pcbWritten",
		"COM",
		"pcbWritten",
		"pcbWritten",
		"OS",
		"buffer",
		"pv",
		"pcbWritten",
		"writer",
		"buffer",
		"success",
		"COM",
		"pv",
		"writer",
		"tempContents",
		"success",
		"address",
		"tempContents",
		"COM",
		"tempContents",
		"pv",
		"OS",
		"size",
		"pv",
		"COM",
		"pv",
		"rc",
		"COM",
		"size",
		"size",
		"pv",
		"COM",
		"size",
		"rc",
		"tempContents",
		"pv",
		"size",
		"OS",
		"buffer",
		"pv",
		"size",
		"COM",
		"pv",
		"file",
		"writer",
		"buffer",
		"writer",
		"success",
		"tempContents",
		"success",
		"COM",
		"file",
		"file",
		"objIOleObject",
		"COM",
		"address",
		"COM",
		"address",
		"address",
		"file",
		"COM",
		"COM",
		"COM",
		"COM",
		"COM",
		"path",
		"mode",
		"address",
		"result",
		"COM",
		"address",
		"COM",
		"permStorage",
		"storage",
		"COM",
		"storage",
		"COM",
		"COM",
		"storage",
		"permStorage",
		"file",
		"file",
		"tempStorage",
		"COM",
		"COM",
		"COM",
		"address",
		"COM",
		"address",
		"file",
		"tempStorage",
		"COM",
		"COM",
		"COM",
		"address",
		"COM",
		"address",
		"file",
		"COM",
		"borderWidths",
		"newBorderwidth",
		"frame",
		"borderWidths",
		"borderWidths",
		"area",
		"borderWidths",
		"borderWidths",
		"area",
		"borderWidths",
		"borderWidths",
		"objIOleObject",
		"isStatic",
		"inUpdate",
		"width",
		"currentExtent",
		"height",
		"currentExtent",
		"newExtent",
		"width",
		"newExtent",
		"height",
		"newExtent",
		"newExtent",
		"COM",
		"objIOleObject",
		"alreadyRunning",
		"COM",
		"objIOleObject",
		"objIOleObject",
		"aspect",
		"newExtent",
		"COM",
		"inUpdate",
		"objIOleObject",
		"inUpdate",
		"alreadyRunning",
		"objIOleObject",
		"COM",
		"indent",
		"indent",
		"newIndent",
		"indent",
		"newIndent",
		"indent",
		"newIndent",
		"indent",
		"newIndent",
		"objIOleInPlaceObject",
		"objIOleInPlaceObject",
		"rect",
		"rect",
		"COM",
		"objIUnknown",
		"COM",
		"ppvObject",
		"COM",
		"ppvObject",
		"objISPP",
		"caGUID",
		"objISPP",
		"result",
		"COM",
		"title",
		"chTitle",
		"title",
		"title",
		"title",
		"chTitle",
		"result",
		"COM",
		"frame",
		"chTitle",
		"objIUnknown",
		"caGUID",
		"caGUID",
		"COM",
		"COM",
		"caGUID",
		"tempStorage",
		"objIUnknown",
		"COM",
		"ppv",
		"COM",
		"ppv",
		"COM",
		"iPersistStorage",
		"tempStorage",
		"result",
		"COM",
		"COM",
		"tempStorage",
		"objClsid",
		"result",
		"iPersistStorage",
		"tempStorage",
		"tempStorage",
		"COM",
		"result",
		"iPersistStorage",
		"iPersistStorage",
		"OS",
		"OS",
		"hDC",
		"OS",
		"hDC",
		"OS",
		"hDC",
		"Compatibility",
		"aSize",
		"xppi",
		"Compatibility",
		"aSize",
		"yppi",
		"size",
		"cx",
		"size",
		"cy",
		"size",
		"OS",
		"OS",
		"hDC",
		"OS",
		"hDC",
		"OS",
		"hDC",
		"Compatibility",
		"aSize",
		"xppi",
		"Compatibility",
		"aSize",
		"yppi",
		"size",
		"cx",
		"size",
		"cy",
		"size",
		"ERROR_INVALID_ARGUMENT",
		"DVASPECT_CONTENT",
		"OLEEMBEDDED",
		"type",
		"Resize",
		"Move",
		"Dispose",
		"FocusIn",
		"FocusOut",
		"Paint",
		"Traverse",
		"KeyDown",
		"ERROR_NOT_IMPLEMENTED",
		"Resize",
		"Move",
		"Dispose",
		"FocusIn",
		"FocusOut",
		"Paint",
		"Traverse",
		"KeyDown",
		"ERROR_INVALID_ARGUMENT",
		"S_OK",
		"ERROR_INVALID_CLASSID",
		"ERROR_INVALID_CLASSID",
		"IIDIUnknown",
		"OLERENDER_DRAW",
		"S_OK",
		"ERROR_CANNOT_CREATE_OBJECT",
		"S_OK",
		"ERROR_INVALID_CLASSID",
		"IIDIUnknown",
		"OLERENDER_DRAW",
		"S_OK",
		"ERROR_CANNOT_CREATE_OBJECT",
		"S_OK",
		"ERROR_INVALID_ARGUMENT",
		"IIDIUnknown",
		"OLERENDER_DRAW",
		"S_OK",
		"ERROR_CANNOT_CREATE_OBJECT",
		"S_OK",
		"STGM_READ",
		"STGM_TRANSACTED",
		"STGM_SHARE_EXCLUSIVE",
		"S_OK",
		"ERROR_CANNOT_OPEN_FILE",
		"STGM_READWRITE",
		"STGM_DIRECT",
		"STGM_SHARE_EXCLUSIVE",
		"STGM_CREATE",
		"STGM_DELETEONRELEASE",
		"S_OK",
		"ERROR_CANNOT_OPEN_FILE",
		"S_OK",
		"ERROR_CANNOT_OPEN_FILE",
		"S_OK",
		"ERROR_CANNOT_OPEN_FILE",
		"STGC_DEFAULT",
		"ERROR_CANNOT_OPEN_FILE",
		"S_OK",
		"ERROR_CANNOT_OPEN_FILE",
		"CLSCTX_INPROC_HANDLER",
		"CLSCTX_INPROC_SERVER",
		"IIDIUnknown",
		"S_OK",
		"ERROR_CANNOT_CREATE_OBJECT",
		"IIDIPersistStorage",
		"S_OK",
		"ERROR_CANNOT_CREATE_OBJECT",
		"S_OK",
		"ERROR_CANNOT_CREATE_OBJECT",
		"S_OK",
		"IIDIPersist",
		"S_OK",
		"S_OK",
		"IIDIViewObject2",
		"S_OK",
		"ERROR_INTERFACE_NOT_FOUND",
		"IIDIOleObject",
		"S_OK",
		"ERROR_INTERFACE_NOT_FOUND",
		"IIDIOleLink",
		"S_OK",
		"S_OK",
		"OLELINKED",
		"DVASPECT_CONTENT",
		"OLEEMBEDDED",
		"S_OK",
		"S_FALSE",
		"S_OK",
		"STGM_READWRITE",
		"STGM_SHARE_EXCLUSIVE",
		"STGM_DELETEONRELEASE",
		"S_OK",
		"ERROR_CANNOT_CREATE_FILE",
		"S_OK",
		"E_FAIL",
		"IIDIOleCommandTarget",
		"S_OK",
		"ERROR_INTERFACE_NOT_FOUND",
		"GMEM_FIXED",
		"GMEM_ZEROINIT",
		"sizeof",
		"GMEM_FIXED",
		"GMEM_ZEROINIT",
		"sizeof",
		"IIDIDispatch",
		"S_OK",
		"S_OK",
		"S_OK",
		"ERROR_INVALID_CLASSID",
		"E_NOINTERFACE",
		"left",
		"right",
		"top",
		"bottom",
		"S_OK",
		"IIDIOleDocument",
		"S_OK",
		"E_FAIL",
		"S_OK",
		"E_FAIL",
		"S_OK",
		"E_INVALIDARG",
		"E_NOTIMPL",
		"handle",
		"S_OK",
		"left",
		"x",
		"top",
		"y",
		"right",
		"x",
		"width",
		"left",
		"right",
		"bottom",
		"y",
		"height",
		"top",
		"bottom",
		"E_NOTIMPL",
		"sizeof",
		"sizeof",
		"cb",
		"sizeof",
		"fMDIApp",
		"hwndFrame",
		"handle",
		"handle",
		"WM_APP",
		"WM_APP",
		"cAccelEntries",
		"haccel",
		"sizeof",
		"S_OK",
		"IIDIPersistFile",
		"S_OK",
		"S_FALSE",
		"S_OK",
		"S_OK",
		"OLEIVERB_DISCARDUNDOSTATE",
		"Dispose",
		"FocusIn",
		"Paint",
		"Traverse",
		"KeyDown",
		"Resize",
		"Move",
		"OLEIVERB_SHOW",
		"S_OK",
		"IIDIOleInPlaceObject",
		"S_OK",
		"S_OK",
		"TRAVERSE_TAB_NEXT",
		"S_OK",
		"x",
		"y",
		"S_OK",
		"left",
		"x",
		"right",
		"x",
		"height",
		"cx",
		"cy",
		"top",
		"y",
		"bottom",
		"y",
		"height",
		"left",
		"x",
		"right",
		"x",
		"cx",
		"top",
		"y",
		"bottom",
		"y",
		"cy",
		"GMEM_FIXED",
		"GMEM_ZEROINIT",
		"sizeof",
		"sizeof",
		"handle",
		"gc",
		"left",
		"top",
		"width",
		"left",
		"right",
		"height",
		"top",
		"bottom",
		"S_OK",
		"E_FAIL",
		"S_OK",
		"HWND_TOP",
		"SWP_NOSIZE",
		"SWP_NOMOVE",
		"S_OK",
		"S_OK",
		"TRAVERSE_TAB_NEXT",
		"S_OK",
		"handle",
		"handle",
		"detail",
		"TRAVERSE_ESCAPE",
		"TRAVERSE_RETURN",
		"TRAVERSE_TAB_NEXT",
		"TRAVERSE_TAB_PREVIOUS",
		"TRAVERSE_PAGE_NEXT",
		"TRAVERSE_PAGE_PREVIOUS",
		"TRAVERSE_MNEMONIC",
		"doit",
		"S_OK",
		"E_NOINTERFACE",
		"sizeof",
		"IIDIUnknown",
		"S_OK",
		"IIDIAdviseSink",
		"S_OK",
		"IIDIOleClientSite",
		"S_OK",
		"IIDIOleInPlaceSite",
		"S_OK",
		"E_NOINTERFACE",
		"IIDIOleCommandTarget",
		"S_OK",
		"cmdID",
		"S_OK",
		"cmdf",
		"OLECLOSE_NOSAVE",
		"S_OK",
		"S_OK",
		"S_OK",
		"IIDIPersistStorage",
		"S_OK",
		"STGM_TRANSACTED",
		"STGM_READWRITE",
		"STGM_SHARE_EXCLUSIVE",
		"STGM_CREATE",
		"S_OK",
		"S_OK",
		"STGC_DEFAULT",
		"S_OK",
		"STGM_DIRECT",
		"STGM_READ",
		"STGM_SHARE_EXCLUSIVE",
		"S_OK",
		"STGM_DIRECT",
		"STGM_READ",
		"STGM_SHARE_EXCLUSIVE",
		"S_OK",
		"S_OK",
		"left",
		"top",
		"width",
		"left",
		"right",
		"height",
		"top",
		"bottom",
		"cx",
		"cy",
		"cx",
		"cy",
		"S_OK",
		"OLECLOSE_SAVEIFDIRTY",
		"left",
		"x",
		"right",
		"width",
		"top",
		"y",
		"bottom",
		"height",
		"S_OK",
		"IIDISpecifyPropertyPages",
		"S_OK",
		"S_OK",
		"handle",
		"cElems",
		"pElems",
		"LOCALE_USER_DEFAULT",
		"pElems",
		"IIDIPersistStorage",
		"S_OK",
		"S_OK",
		"STGC_DEFAULT",
		"cx",
		"cy",
		"cx",
		"cy",
		"cx",
		"cy",
		"cx",
		"cy",
		"parent",
		"style",
		"e",
		"parent",
		"style",
		"file",
		"e",
		"parent",
		"style",
		"progId",
		"e",
		"parent",
		"style",
		"progId",
		"file",
		"err",
		"e",
		"fEnterMode",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"verb",
		"cmdID",
		"options",
		"in",
		"out",
		"clientName",
		"ppContainer",
		"pViewToActivate",
		"phwnd",
		"ppFrame",
		"ppDoc",
		"lprcPosRect",
		"lprcClipRect",
		"lpFrameInfo",
		"pFormatetc",
		"pStgmed",
		"e",
		"e",
		"e",
		"lprcPosRect",
		"e",
		"e",
		"fShow",
		"fUndoable",
		"event",
		"dwAspect",
		"lindex",
		"riid",
		"ppvObject",
		"cmd",
		"file",
		"includeOleInfo",
		"address",
		"file",
		"err",
		"address",
		"file",
		"err",
		"file",
		"file",
		"scrollExtant",
		"newBorderwidth",
		"width",
		"height",
		"newIndent",
		"title",
		"aSize",
		"aSize"
	],
	"extendORImplementFiles":[
		"Composite"
	],
	"package":[
		"org.eclipse.swt.ole.win32"
	],
	"import":[
		"java.io.File",
		"java.io.FileOutputStream",
		"java.io.FileInputStream",
		"java.io.IOException",
		"org.eclipse.swt",
		"org.eclipse.swt.internal.Compatibility",
		"org.eclipse.swt.internal.ole.win32",
		"org.eclipse.swt.graphics",
		"org.eclipse.swt.widgets",
		"org.eclipse.swt.internal.win32"
	],
	"methods":[
		"handleEvent",
		"addObjectReferences",
		"AddRef",
		"CanInPlaceActivate",
		"ContextSensitiveHelp",
		"createCOMInterfaces",
		"method0",
		"method1",
		"method2",
		"method0",
		"method1",
		"method2",
		"method3",
		"method5",
		"method6",
		"method7",
		"method0",
		"method1",
		"method2",
		"method3",
		"method4",
		"method6",
		"method7",
		"method0",
		"method1",
		"method2",
		"method3",
		"method4",
		"method5",
		"method6",
		"method7",
		"method8",
		"method9",
		"method10",
		"method11",
		"method14",
		"method0",
		"method1",
		"method2",
		"method3",
		"createTempStorage",
		"deactivateInPlaceClient",
		"deleteTempStorage",
		"disposeCOMInterfaces",
		"doVerb",
		"exec",
		"getAutomationObject",
		"getClassID",
		"GetContainer",
		"getExtent",
		"getIndent",
		"getProgramID",
		"ActivateMe",
		"GetWindow",
		"getRect",
		"GetWindowContext",
		"isDirty",
		"isFocusControl",
		"OnClose",
		"OnDataChange",
		"onDispose",
		"onFocusIn",
		"onFocusOut",
		"OnInPlaceActivate",
		"OnInPlaceDeactivate",
		"OnPosRectChange",
		"onPaint",
		"onResize",
		"OnSave",
		"OnShowWindow",
		"OnUIActivate",
		"OnUIDeactivate",
		"onTraverse",
		"OnViewChange",
		"QueryInterface",
		"queryStatus",
		"Release",
		"releaseObjectInterfaces",
		"save",
		"saveFromContents",
		"saveFromOle10Native",
		"SaveObject",
		"saveToStorageFile",
		"saveToTraditionalFile",
		"Scroll",
		"setBorderSpace",
		"setExtent",
		"setIndent",
		"setObjectRects",
		"ShowObject",
		"showProperties",
		"updateStorage",
		"xFormHimetricToPixels",
		"xFormPixelsToHimetric",
		"createCOMInterfaces",
		"getParent",
		"error",
		"AddRef",
		"onResize",
		"onDispose",
		"onFocusIn",
		"onFocusOut",
		"onPaint",
		"onTraverse",
		"error",
		"addListener",
		"addListener",
		"addListener",
		"addListener",
		"addListener",
		"addListener",
		"addListener",
		"addListener",
		"isDirectory",
		"exists",
		"error",
		"toCharArray",
		"getAbsolutePath",
		"GetClassFile",
		"error",
		"getProgramID",
		"error",
		"createTempStorage",
		"OleCreateFromFile",
		"getAddress",
		"error",
		"addObjectReferences",
		"OleRun",
		"getAddress",
		"dispose",
		"disposeCOMInterfaces",
		"getClassID",
		"error",
		"createTempStorage",
		"OleCreate",
		"getAddress",
		"error",
		"addObjectReferences",
		"OleRun",
		"getAddress",
		"dispose",
		"disposeCOMInterfaces",
		"isDirectory",
		"exists",
		"error",
		"getClassID",
		"toCharArray",
		"getAbsolutePath",
		"GetClassFile",
		"IsEqualGUID",
		"createTempStorage",
		"OleCreateFromFile",
		"getAddress",
		"error",
		"StgIsStorageFile",
		"StgOpenStorage",
		"error",
		"StgCreateDocfile",
		"error",
		"getClassID",
		"IsEqualGUID",
		"CreateStream",
		"Release",
		"error",
		"read",
		"CoTaskMemAlloc",
		"MoveMemory",
		"Write",
		"CoTaskMemFree",
		"close",
		"Release",
		"Release",
		"error",
		"close",
		"Commit",
		"Release",
		"Release",
		"Release",
		"error",
		"createTempStorage",
		"CopyTo",
		"getAddress",
		"Release",
		"error",
		"CoCreateInstance",
		"error",
		"QueryInterface",
		"error",
		"Load",
		"getAddress",
		"Release",
		"error",
		"addObjectReferences",
		"OleRun",
		"getAddress",
		"dispose",
		"disposeCOMInterfaces",
		"QueryInterface",
		"GetClassID",
		"Release",
		"QueryInterface",
		"error",
		"SetAdvise",
		"getAddress",
		"QueryInterface",
		"error",
		"SetClientSite",
		"getAddress",
		"Advise",
		"getAddress",
		"SetHostNames",
		"OleSetContainedObject",
		"getAddress",
		"QueryInterface",
		"GetSourceMoniker",
		"Release",
		"BindIfRunning",
		"Release",
		"QueryInterface",
		"AddRef",
		"Release",
		"QueryInterface",
		"AddRef",
		"Release",
		"SaveObject",
		"GetContainer",
		"ShowObject",
		"OnShowWindow",
		"QueryInterface",
		"AddRef",
		"Release",
		"OnDataChange",
		"OnViewChange",
		"OnSave",
		"OnClose",
		"QueryInterface",
		"AddRef",
		"Release",
		"GetWindow",
		"ContextSensitiveHelp",
		"CanInPlaceActivate",
		"OnInPlaceActivate",
		"OnUIActivate",
		"GetWindowContext",
		"Scroll",
		"OnUIDeactivate",
		"OnInPlaceDeactivate",
		"OnPosRectChange",
		"QueryInterface",
		"AddRef",
		"Release",
		"ActivateMe",
		"StgCreateDocfile",
		"error",
		"InPlaceDeactivate",
		"Release",
		"dispose",
		"dispose",
		"dispose",
		"dispose",
		"dispose",
		"OleRun",
		"getAddress",
		"DoVerb",
		"getAddress",
		"updateStorage",
		"QueryInterface",
		"GlobalAlloc",
		"getData",
		"GlobalAlloc",
		"getData",
		"Exec",
		"VariantClear",
		"GlobalFree",
		"setData",
		"VariantClear",
		"GlobalFree",
		"QueryInterface",
		"length",
		"getChars",
		"CLSIDFromProgID",
		"CLSIDFromString",
		"error",
		"MoveMemory",
		"OleIsRunning",
		"getAddress",
		"GetExtent",
		"GetExtent",
		"xFormHimetricToPixels",
		"ProgIDFromCLSID",
		"GlobalSize",
		"GlobalLock",
		"MoveMemory",
		"GlobalUnlock",
		"GlobalFree",
		"indexOf",
		"substring",
		"QueryInterface",
		"CreateView",
		"getAddress",
		"Release",
		"AddRef",
		"SetInPlaceSite",
		"getAddress",
		"UIActivate",
		"getRect",
		"SetRect",
		"Show",
		"MoveMemory",
		"MoveMemory",
		"getLocation",
		"getClientArea",
		"getIOleInPlaceFrame",
		"MoveMemory",
		"AddRef",
		"MoveMemory",
		"getRect",
		"MoveMemory",
		"MoveMemory",
		"getShell",
		"getMenuBar",
		"isDisposed",
		"SendMessage",
		"SendMessage",
		"MoveMemory",
		"QueryInterface",
		"IsDirty",
		"Release",
		"checkWidget",
		"GetFocus",
		"GetWindow",
		"GetParent",
		"doVerb",
		"deactivateInPlaceClient",
		"releaseObjectInterfaces",
		"deleteTempStorage",
		"removeListener",
		"removeListener",
		"removeListener",
		"removeListener",
		"removeListener",
		"removeListener",
		"removeListener",
		"Release",
		"doVerb",
		"isFocusControl",
		"GetWindow",
		"SetFocus",
		"setCurrentDocument",
		"QueryInterface",
		"Release",
		"redraw",
		"getShell",
		"isFocusControl",
		"isFocusControl",
		"traverse",
		"getSize",
		"setExtent",
		"getExtent",
		"getClientArea",
		"startsWith",
		"getProgramID",
		"GlobalAlloc",
		"MoveMemory",
		"OleDraw",
		"getAddress",
		"GlobalFree",
		"getClientArea",
		"setBounds",
		"setObjectRects",
		"GetWindow",
		"SetWindowPos",
		"isDisposed",
		"SetActiveObject",
		"redraw",
		"getShell",
		"isFocusControl",
		"isFocusControl",
		"traverse",
		"getMenuBar",
		"isDisposed",
		"SetMenu",
		"OleSetMenuDescriptor",
		"MoveMemory",
		"IsEqualGUID",
		"MoveMemory",
		"getAddress",
		"AddRef",
		"IsEqualGUID",
		"MoveMemory",
		"getAddress",
		"AddRef",
		"IsEqualGUID",
		"MoveMemory",
		"getAddress",
		"AddRef",
		"IsEqualGUID",
		"MoveMemory",
		"getAddress",
		"AddRef",
		"MoveMemory",
		"QueryInterface",
		"QueryStatus",
		"disposeCOMInterfaces",
		"Release",
		"Close",
		"Release",
		"Release",
		"SetAdvise",
		"Release",
		"Release",
		"Release",
		"CoFreeUnusedLibraries",
		"saveToStorageFile",
		"saveToTraditionalFile",
		"AddRef",
		"CoTaskMemAlloc",
		"Read",
		"MoveMemory",
		"write",
		"CoTaskMemFree",
		"close",
		"Release",
		"AddRef",
		"CoTaskMemAlloc",
		"Read",
		"MoveMemory",
		"CoTaskMemFree",
		"CoTaskMemAlloc",
		"Read",
		"MoveMemory",
		"CoTaskMemFree",
		"write",
		"close",
		"Release",
		"updateStorage",
		"isDirectory",
		"updateStorage",
		"QueryInterface",
		"toCharArray",
		"getAbsolutePath",
		"StgCreateDocfile",
		"OleSave",
		"getAddress",
		"getAddress",
		"Commit",
		"Release",
		"Release",
		"isDirectory",
		"updateStorage",
		"OpenStream",
		"saveFromContents",
		"OpenStream",
		"saveFromOle10Native",
		"getClientArea",
		"setBounds",
		"setObjectRects",
		"getExtent",
		"xFormPixelsToHimetric",
		"OleIsRunning",
		"getAddress",
		"OleRun",
		"getAddress",
		"SetExtent",
		"Update",
		"Close",
		"getRect",
		"SetObjectRects",
		"QueryInterface",
		"GetPages",
		"Release",
		"length",
		"getChars",
		"length",
		"OleCreatePropertyFrame",
		"getAddress",
		"CoTaskMemFree",
		"QueryInterface",
		"OleSave",
		"getAddress",
		"getAddress",
		"WriteClassStg",
		"getAddress",
		"Save",
		"getAddress",
		"Commit",
		"SaveCompleted",
		"Release",
		"GetDC",
		"GetDeviceCaps",
		"GetDeviceCaps",
		"ReleaseDC",
		"round",
		"round",
		"GetDC",
		"GetDeviceCaps",
		"GetDeviceCaps",
		"ReleaseDC",
		"round",
		"round",
		"RECT",
		"RECT",
		"Listener",
		"GUID",
		"IUnknown",
		"IUnknown",
		"GUID",
		"IUnknown",
		"IStorage",
		"IStorage",
		"IStream",
		"FileInputStream",
		"IUnknown",
		"IPersistStorage",
		"IPersist",
		"GUID",
		"IViewObject2",
		"IOleObject",
		"IOleLink",
		"IMoniker",
		"COMObject",
		"COMObject",
		"COMObject",
		"COMObject",
		"COMObject",
		"IStorage",
		"IOleCommandTarget",
		"IDispatch",
		"GUID",
		"SIZE",
		"Rectangle",
		"String",
		"IOleDocument",
		"IOleDocumentView",
		"IOleDocumentView",
		"RECT",
		"OLEINPLACEFRAMEINFO",
		"IPersistStorage",
		"IOleInPlaceObject",
		"RECT",
		"GUID",
		"IOleCommandTarget",
		"OLECMD",
		"IStream",
		"FileOutputStream",
		"IStream",
		"FileOutputStream",
		"IPersistStorage",
		"IStorage",
		"SIZE",
		"RECT",
		"ISpecifyPropertyPages",
		"CAUUID",
		"IPersistStorage",
		"SIZE",
		"SIZE"
	],
	"methodsBody":{
		"private boolean saveFromOle10Native(int address, File file)":{
			"methodBody":"{\n    boolean success = false;\n    IStream tempContents = new IStream(address);\n    tempContents.AddRef();\n    \n    \n    int pv = COM.CoTaskMemAlloc(4);\n    int[] size = new int[1];\n    int rc = tempContents.Read(pv, 4, null);\n    OS.MoveMemory(size, pv, 4);\n    COM.CoTaskMemFree(pv);\n    if (rc == COM.S_OK && size[0] > 0) {\n        \n        byte[] buffer = new byte[size[0]];\n        pv = COM.CoTaskMemAlloc(size[0]);\n        rc = tempContents.Read(pv, size[0], null);\n        OS.MoveMemory(buffer, pv, size[0]);\n        COM.CoTaskMemFree(pv);\n        \n        try {\n            FileOutputStream writer = new FileOutputStream(file);\n            \n            writer.write(buffer);\n            writer.close();\n            success = true;\n        } catch (IOException err) {\n        }\n    }\n    tempContents.Release();\n    return success;\n}",
			"comments":"// The \"\\1Ole10Native\" stream contains a DWORD header whose value is the length\n// of the native data that follows.\n// Read the data\n// open the file and write data into it\n// Note: if file does not exist, this will create the file\n",
			"methodName":"private boolean saveFromOle10Native(int address, File file)"
		},
		"private void setObjectRects()":{
			"methodBody":"{\n    if (objIOleInPlaceObject == null)\n        return;\n    \n    \n    RECT rect = getRect();\n    objIOleInPlaceObject.SetObjectRects(rect, rect);\n}",
			"comments":"// size the object to fill the available space\n// leave a border\n",
			"methodName":"private void setObjectRects()"
		},
		"public void deactivateInPlaceClient()":{
			"methodBody":"{\n    if (objIOleInPlaceObject != null) {\n        objIOleInPlaceObject.InPlaceDeactivate();\n    }\n}",
			"comments":"/**\n* Deactivates an active in-place object and discards the object's undo state.\n*/\n",
			"methodName":"public void deactivateInPlaceClient()"
		},
		"private int OnUIActivate()":{
			"methodBody":"{\n    if (objIOleInPlaceObject == null)\n        return COM.E_FAIL;\n    state = STATE_UIACTIVE;\n    int[] phwnd = new int[1];\n    if (objIOleInPlaceObject.GetWindow(phwnd) == COM.S_OK) {\n        OS.SetWindowPos(phwnd[0], OS.HWND_TOP, 0, 0, 0, 0, OS.SWP_NOSIZE | OS.SWP_NOMOVE);\n    }\n    return COM.S_OK;\n}",
			"comments":"",
			"methodName":"private int OnUIActivate()"
		},
		"private int OnShowWindow(int fShow)":{
			"methodBody":"{\n    return COM.S_OK;\n}",
			"comments":"",
			"methodName":"private int OnShowWindow(int fShow)"
		},
		"private boolean saveFromContents(int address, File file)":{
			"methodBody":"{\n    boolean success = false;\n    IStream tempContents = new IStream(address);\n    tempContents.AddRef();\n    try {\n        FileOutputStream writer = new FileOutputStream(file);\n        int increment = 1024 * 4;\n        int pv = COM.CoTaskMemAlloc(increment);\n        int[] pcbWritten = new int[1];\n        while (tempContents.Read(pv, increment, pcbWritten) == COM.S_OK && pcbWritten[0] > 0) {\n            byte[] buffer = new byte[pcbWritten[0]];\n            OS.MoveMemory(buffer, pv, pcbWritten[0]);\n            \n            writer.write(buffer);\n            \n            success = true;\n        }\n        COM.CoTaskMemFree(pv);\n        writer.close();\n    } catch (IOException err) {\n    }\n    tempContents.Release();\n    return success;\n}",
			"comments":"// Note: if file does not exist, this will create the file the\n// first time it is called\n",
			"methodName":"private boolean saveFromContents(int address, File file)"
		},
		"protected void createCOMInterfaces()":{
			"methodBody":"{\n    iUnknown = new COMObject(new int[] { 2, 0, 0 }) {\n\n        public int method0(int[] args) {\n            return QueryInterface(args[0], args[1]);\n        }\n\n        public int method1(int[] args) {\n            return AddRef();\n        }\n\n        public int method2(int[] args) {\n            return Release();\n        }\n    };\n    iOleClientSite = new COMObject(new int[] { 2, 0, 0, 0, 3, 1, 0, 1, 0 }) {\n\n        public int method0(int[] args) {\n            return QueryInterface(args[0], args[1]);\n        }\n\n        public int method1(int[] args) {\n            return AddRef();\n        }\n\n        public int method2(int[] args) {\n            return Release();\n        }\n\n        public int method3(int[] args) {\n            return SaveObject();\n        }\n\n        \n        public int method5(int[] args) {\n            return GetContainer(args[0]);\n        }\n\n        public int method6(int[] args) {\n            return ShowObject();\n        }\n\n        public int method7(int[] args) {\n            return OnShowWindow(args[0]);\n        }\n    };\n    iAdviseSink = new COMObject(new int[] { 2, 0, 0, 2, 2, 1, 0, 0 }) {\n\n        public int method0(int[] args) {\n            return QueryInterface(args[0], args[1]);\n        }\n\n        public int method1(int[] args) {\n            return AddRef();\n        }\n\n        public int method2(int[] args) {\n            return Release();\n        }\n\n        public int method3(int[] args) {\n            return OnDataChange(args[0], args[1]);\n        }\n\n        public int method4(int[] args) {\n            return OnViewChange(args[0], args[1]);\n        }\n\n        \n        public int method6(int[] args) {\n            OnSave();\n            return 0;\n        }\n\n        public int method7(int[] args) {\n            return OnClose();\n        }\n    };\n    iOleInPlaceSite = new COMObject(new int[] { 2, 0, 0, 1, 1, 0, 0, 0, 5, 1, 1, 0, 0, 0, 1 }) {\n\n        public int method0(int[] args) {\n            return QueryInterface(args[0], args[1]);\n        }\n\n        public int method1(int[] args) {\n            return AddRef();\n        }\n\n        public int method2(int[] args) {\n            return Release();\n        }\n\n        public int method3(int[] args) {\n            return GetWindow(args[0]);\n        }\n\n        public int method4(int[] args) {\n            return ContextSensitiveHelp(args[0]);\n        }\n\n        public int method5(int[] args) {\n            return CanInPlaceActivate();\n        }\n\n        public int method6(int[] args) {\n            return OnInPlaceActivate();\n        }\n\n        public int method7(int[] args) {\n            return OnUIActivate();\n        }\n\n        public int method8(int[] args) {\n            return GetWindowContext(args[0], args[1], args[2], args[3], args[4]);\n        }\n\n        public int method9(int[] args) {\n            return Scroll(args[0]);\n        }\n\n        public int method10(int[] args) {\n            return OnUIDeactivate(args[0]);\n        }\n\n        public int method11(int[] args) {\n            return OnInPlaceDeactivate();\n        }\n\n        \n        \n        public int method14(int[] args) {\n            return OnPosRectChange(args[0]);\n        }\n    };\n    iOleDocumentSite = new COMObject(new int[] { 2, 0, 0, 1 }) {\n\n        public int method0(int[] args) {\n            return QueryInterface(args[0], args[1]);\n        }\n\n        public int method1(int[] args) {\n            return AddRef();\n        }\n\n        public int method2(int[] args) {\n            return Release();\n        }\n\n        public int method3(int[] args) {\n            return ActivateMe(args[0]);\n        }\n    };\n}",
			"comments":"// method4 GetMoniker - not implemented\n// method8 RequestNewObjectLayout - not implemented\n//method5 OnRename - not implemented\n// method12 DiscardUndoState - not implemented\n// method13 DeactivateAndUndoChange - not implemented\n",
			"methodName":"protected void createCOMInterfaces()"
		},
		"private int SaveObject()":{
			"methodBody":"{\n    updateStorage();\n    return COM.S_OK;\n}",
			"comments":"",
			"methodName":"private int SaveObject()"
		},
		"public void setIndent(Rectangle newIndent)":{
			"methodBody":"{\n    indent = new RECT();\n    indent.left = newIndent.x;\n    indent.right = newIndent.width;\n    indent.top = newIndent.y;\n    indent.bottom = newIndent.height;\n}",
			"comments":"",
			"methodName":"public void setIndent(Rectangle newIndent)"
		},
		"private void onDispose(Event e)":{
			"methodBody":"{\n    inDispose = true;\n    if (state != STATE_NONE)\n        doVerb(OLE.OLEIVERB_DISCARDUNDOSTATE);\n    deactivateInPlaceClient();\n    \n    releaseObjectInterfaces();\n    deleteTempStorage();\n    \n    removeListener(SWT.Dispose, listener);\n    removeListener(SWT.FocusIn, listener);\n    removeListener(SWT.Paint, listener);\n    removeListener(SWT.Traverse, listener);\n    removeListener(SWT.KeyDown, listener);\n    frame.removeListener(SWT.Resize, listener);\n    frame.removeListener(SWT.Move, listener);\n    frame.Release();\n    frame = null;\n}",
			"comments":"// Note, must release object interfaces before releasing frame\n// remove listeners\n",
			"methodName":"private void onDispose(Event e)"
		},
		"public int queryStatus(int cmd)":{
			"methodBody":"{\n    if (objIOleCommandTarget == null) {\n        int[] address = new int[1];\n        if (objIUnknown.QueryInterface(COM.IIDIOleCommandTarget, address) != COM.S_OK)\n            return 0;\n        objIOleCommandTarget = new IOleCommandTarget(address[0]);\n    }\n    OLECMD olecmd = new OLECMD();\n    olecmd.cmdID = cmd;\n    int result = objIOleCommandTarget.QueryStatus(null, 1, olecmd, null);\n    if (result != COM.S_OK)\n        return 0;\n    return olecmd.cmdf;\n}",
			"comments":"/**\n* Returns the status of the specified command.  The status is any bitwise OR'd combination of\n* SWTOLE.OLECMDF_SUPPORTED, SWTOLE.OLECMDF_ENABLED, SWTOLE.OLECMDF_LATCHED, SWTOLE.OLECMDF_NINCHED.\n* You can query the status of a command before invoking it with OleClientSite.exec.  The\n* OLE Document or ActiveX Control must support the IOleCommandTarget to make use of this method.\n*\n* @param cmd the ID of a command; these are the OLE.OLECMDID_ values - a small set of common\n*            commands\n*\n* @return the status of the specified command or 0 if unable to query the OLE Object; these are the\n*\t\t\t  OLE.OLECMDF_ values\n*/\n",
			"methodName":"public int queryStatus(int cmd)"
		},
		"private int ShowObject()":{
			"methodBody":"{\n    \n    return COM.S_OK;\n}",
			"comments":"/* Tells the container to position the object so it is visible to\n* the user. This method ensures that the container itself is\n* visible and not minimized.\n*/\n",
			"methodName":"private int ShowObject()"
		},
		"private boolean saveToTraditionalFile(File file)":{
			"methodBody":"{\n    \n    if (file == null || file.isDirectory())\n        return false;\n    if (!updateStorage())\n        return false;\n    int[] address = new int[1];\n    \n    if (\n    tempStorage.OpenStream(\"CONTENTS\", 0, COM.STGM_DIRECT | COM.STGM_READ | COM.STGM_SHARE_EXCLUSIVE, 0, address) == COM.S_OK)\n        return saveFromContents(address[0], file);\n    \n    if (\n    tempStorage.OpenStream(\"\\1Ole10Native\", 0, COM.STGM_DIRECT | COM.STGM_READ | COM.STGM_SHARE_EXCLUSIVE, 0, address) == COM.S_OK)\n        return saveFromOle10Native(address[0], file);\n    return false;\n}",
			"comments":"/**\n* Saves the document to the specified file.  This method must be used for\n* files that do not have an OLE Storage format.  For example, a bitmap file edited with MSPaint\n* should be saved using this method because bitmap is a standard format that does not include any\n* OLE specific data.\n*\n* @param file the file to which the changes are to be saved\n*\n* @return true if the save was successful\n*/\n// Note: if the file already exists, some applications will not overwrite the file\n// In these cases, you should delete the file first (probably save the contents of the file in case the\n// save fails)\n// Look for a CONTENTS stream\n//$NON-NLS-1$\n// Look for Ole 1.0 object stream\n//$NON-NLS-1$\n",
			"methodName":"private boolean saveToTraditionalFile(File file)"
		},
		"private int OnInPlaceActivate()":{
			"methodBody":"{\n    state = STATE_INPLACEACTIVE;\n    frame.setCurrentDocument(this);\n    if (objIOleObject == null)\n        return COM.S_OK;\n    int[] ppvObject = new int[1];\n    if (objIOleObject.QueryInterface(COM.IIDIOleInPlaceObject, ppvObject) == COM.S_OK) {\n        objIOleInPlaceObject = new IOleInPlaceObject(ppvObject[0]);\n    }\n    return COM.S_OK;\n}",
			"comments":"",
			"methodName":"private int OnInPlaceActivate()"
		},
		"public Rectangle getIndent()":{
			"methodBody":"{\n    return new Rectangle(indent.left, indent.right, indent.top, indent.bottom);\n}",
			"comments":"",
			"methodName":"public Rectangle getIndent()"
		},
		"public int method14(int[] args)":{
			"methodBody":"{\n    return OnPosRectChange(args[0]);\n}",
			"comments":"// method12 DiscardUndoState - not implemented\n// method13 DeactivateAndUndoChange - not implemented\n",
			"methodName":"public int method14(int[] args)"
		},
		"private boolean saveToStorageFile(File file)":{
			"methodBody":"{\n    \n    if (file == null || file.isDirectory())\n        return false;\n    if (!updateStorage())\n        return false;\n    \n    int[] address = new int[1];\n    if (objIOleObject.QueryInterface(COM.IIDIPersistStorage, address) != COM.S_OK)\n        return false;\n    IPersistStorage permStorage = new IPersistStorage(address[0]);\n    try {\n        address = new int[1];\n        char[] path = (file.getAbsolutePath() + \"\\0\").toCharArray();\n        int mode = COM.STGM_TRANSACTED | COM.STGM_READWRITE | COM.STGM_SHARE_EXCLUSIVE | COM.STGM_CREATE;\n        \n        int result = COM.StgCreateDocfile(path, mode, 0, address);\n        if (result != COM.S_OK)\n            return false;\n        IStorage storage = new IStorage(address[0]);\n        try {\n            if (COM.OleSave(permStorage.getAddress(), storage.getAddress(), false) == COM.S_OK) {\n                if (storage.Commit(COM.STGC_DEFAULT) == COM.S_OK) {\n                    return true;\n                }\n            }\n        } finally {\n            storage.Release();\n        }\n    } finally {\n        permStorage.Release();\n    }\n    return false;\n}",
			"comments":"/**\n* Saves the document to the specified file and includes OLE spcific inforrmation.  This method\n* must <b>only</b> be used for files that have an OLE Storage format.  For example, a word file\n* edited with Word.Document should be saved using this method because there is formating information\n* that should be stored in the OLE specific Storage format.\n*\n* @param file the file to which the changes are to be saved\n*\n* @return true if the save was successful\n*/\n// The file will be saved using the formating of the current application - this\n// may not be the format of the application that was originally used to create the file\n// e.g. if an Excel file is opened in Word, the Word application will save the file in the\n// Word format\n// Note: if the file already exists, some applications will not overwrite the file\n// In these cases, you should delete the file first (probably save the contents of the file in case the\n// save fails)\n// get access to the persistant storage mechanism\n//Does an AddRef if successful\n",
			"methodName":"private boolean saveToStorageFile(File file)"
		},
		"protected GUID getClassID(String clientName)":{
			"methodBody":"{\n    \n    GUID guid = new GUID();\n    \n    char[] buffer = null;\n    if (clientName != null) {\n        int count = clientName.length();\n        buffer = new char[count + 1];\n        clientName.getChars(0, count, buffer, 0);\n    }\n    if (COM.CLSIDFromProgID(buffer, guid) != COM.S_OK) {\n        int result = COM.CLSIDFromString(buffer, guid);\n        if (result != COM.S_OK)\n            OLE.error(OLE.ERROR_INVALID_CLASSID, result);\n    }\n    return guid;\n}",
			"comments":"// create a GUID struct to hold the result\n// create a null terminated array of char\n",
			"methodName":"protected GUID getClassID(String clientName)"
		},
		"private void OnSave()":{
			"methodBody":"{\n}",
			"comments":"",
			"methodName":"private void OnSave()"
		},
		"protected int QueryInterface(int riid, int ppvObject)":{
			"methodBody":"{\n    if (riid == 0 || ppvObject == 0)\n        return COM.E_NOINTERFACE;\n    GUID guid = new GUID();\n    COM.MoveMemory(guid, riid, GUID.sizeof);\n    if (COM.IsEqualGUID(guid, COM.IIDIUnknown)) {\n        COM.MoveMemory(ppvObject, new int[] { iUnknown.getAddress() }, 4);\n        AddRef();\n        return COM.S_OK;\n    }\n    if (COM.IsEqualGUID(guid, COM.IIDIAdviseSink)) {\n        COM.MoveMemory(ppvObject, new int[] { iAdviseSink.getAddress() }, 4);\n        AddRef();\n        return COM.S_OK;\n    }\n    if (COM.IsEqualGUID(guid, COM.IIDIOleClientSite)) {\n        COM.MoveMemory(ppvObject, new int[] { iOleClientSite.getAddress() }, 4);\n        AddRef();\n        return COM.S_OK;\n    }\n    if (COM.IsEqualGUID(guid, COM.IIDIOleInPlaceSite)) {\n        COM.MoveMemory(ppvObject, new int[] { iOleInPlaceSite.getAddress() }, 4);\n        AddRef();\n        return COM.S_OK;\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    COM.MoveMemory(ppvObject, new int[] { 0 }, 4);\n    return COM.E_NOINTERFACE;\n}",
			"comments":"// INTENTIONALLY COMMENTED - see bug 35493\n//\tif (COM.IsEqualGUID(guid, COM.IIDIOleDocumentSite )) {\n//\t\tString progID = getProgramID();\n//\t\tif (!progID.startsWith(\"PowerPoint\")) { //$NON-NLS-1$\n//\t\t\tCOM.MoveMemory(ppvObject, new int[] {iOleDocumentSite.getAddress()}, 4);\n//\t\t\tAddRef();\n//\t\t\treturn COM.S_OK;\n//\t\t}\n//\t}\n",
			"methodName":"protected int QueryInterface(int riid, int ppvObject)"
		},
		"private SIZE xFormPixelsToHimetric(SIZE aSize)":{
			"methodBody":"{\n    \n    \n    int hDC = OS.GetDC(0);\n    \n    int xppi = OS.GetDeviceCaps(hDC, 88);\n    \n    int yppi = OS.GetDeviceCaps(hDC, 90);\n    OS.ReleaseDC(0, hDC);\n    \n    int cx = Compatibility.round(aSize.cx * 2540, xppi);\n    int cy = Compatibility.round(aSize.cy * 2540, yppi);\n    SIZE size = new SIZE();\n    size.cx = cx;\n    size.cy = cy;\n    return size;\n}",
			"comments":"// Return a new size which is the HIMETRIC transformation of a\n// size in pixel units.\n// logical pixels/inch in x\n// logical pixels/inch in y\n// 2540 HIMETRIC units per inch\n",
			"methodName":"private SIZE xFormPixelsToHimetric(SIZE aSize)"
		},
		"private int OnInPlaceDeactivate()":{
			"methodBody":"{\n    if (objIOleInPlaceObject != null)\n        objIOleInPlaceObject.Release();\n    objIOleInPlaceObject = null;\n    state = STATE_RUNNING;\n    redraw();\n    Shell shell = getShell();\n    if (isFocusControl() || frame.isFocusControl()) {\n        shell.traverse(SWT.TRAVERSE_TAB_NEXT);\n    }\n    return COM.S_OK;\n}",
			"comments":"",
			"methodName":"private int OnInPlaceDeactivate()"
		},
		"public int method11(int[] args)":{
			"methodBody":"{\n    return OnInPlaceDeactivate();\n}",
			"comments":"",
			"methodName":"public int method11(int[] args)"
		},
		"protected void disposeCOMInterfaces()":{
			"methodBody":"{\n    if (iUnknown != null)\n        iUnknown.dispose();\n    iUnknown = null;\n    if (iOleClientSite != null)\n        iOleClientSite.dispose();\n    iOleClientSite = null;\n    if (iAdviseSink != null)\n        iAdviseSink.dispose();\n    iAdviseSink = null;\n    if (iOleInPlaceSite != null)\n        iOleInPlaceSite.dispose();\n    iOleInPlaceSite = null;\n    if (iOleDocumentSite != null)\n        iOleDocumentSite.dispose();\n    iOleDocumentSite = null;\n}",
			"comments":"",
			"methodName":"protected void disposeCOMInterfaces()"
		},
		"void onFocusOut(Event e)":{
			"methodBody":"{\n}",
			"comments":"",
			"methodName":"void onFocusOut(Event e)"
		},
		"public int method10(int[] args)":{
			"methodBody":"{\n    return OnUIDeactivate(args[0]);\n}",
			"comments":"",
			"methodName":"public int method10(int[] args)"
		},
		"public int method3(int[] args)":{
			"methodBody":"{\n    return ActivateMe(args[0]);\n}",
			"comments":"",
			"methodName":"public int method3(int[] args)"
		},
		"private int ContextSensitiveHelp(int fEnterMode)":{
			"methodBody":"{\n    return COM.S_OK;\n}",
			"comments":"",
			"methodName":"private int ContextSensitiveHelp(int fEnterMode)"
		},
		"void onFocusIn(Event e)":{
			"methodBody":"{\n    if (inDispose)\n        return;\n    if (state != STATE_UIACTIVE)\n        doVerb(OLE.OLEIVERB_SHOW);\n    if (objIOleInPlaceObject == null)\n        return;\n    if (isFocusControl())\n        return;\n    int[] phwnd = new int[1];\n    objIOleInPlaceObject.GetWindow(phwnd);\n    if (phwnd[0] == 0)\n        return;\n    OS.SetFocus(phwnd[0]);\n}",
			"comments":"",
			"methodName":"void onFocusIn(Event e)"
		},
		"public int method2(int[] args)":{
			"methodBody":"{\n    return Release();\n}",
			"comments":"",
			"methodName":"public int method2(int[] args)"
		},
		"public int method1(int[] args)":{
			"methodBody":"{\n    return AddRef();\n}",
			"comments":"",
			"methodName":"public int method1(int[] args)"
		},
		"protected IStorage createTempStorage()":{
			"methodBody":"{\n    int[] tempStorage = new int[1];\n    int grfMode = COM.STGM_READWRITE | COM.STGM_SHARE_EXCLUSIVE | COM.STGM_DELETEONRELEASE;\n    int result = COM.StgCreateDocfile(null, grfMode, 0, tempStorage);\n    if (result != COM.S_OK)\n        OLE.error(OLE.ERROR_CANNOT_CREATE_FILE, result);\n    return new IStorage(tempStorage[0]);\n}",
			"comments":"",
			"methodName":"protected IStorage createTempStorage()"
		},
		"private void onTraverse(Event event)":{
			"methodBody":"{\n    switch(event.detail) {\n        case SWT.TRAVERSE_ESCAPE:\n        case SWT.TRAVERSE_RETURN:\n        case SWT.TRAVERSE_TAB_NEXT:\n        case SWT.TRAVERSE_TAB_PREVIOUS:\n        case SWT.TRAVERSE_PAGE_NEXT:\n        case SWT.TRAVERSE_PAGE_PREVIOUS:\n        case SWT.TRAVERSE_MNEMONIC:\n            event.doit = true;\n            break;\n    }\n}",
			"comments":"",
			"methodName":"private void onTraverse(Event event)"
		},
		"public int exec(int cmdID, int options, Variant in, Variant out)":{
			"methodBody":"{\n    if (objIOleCommandTarget == null) {\n        int[] address = new int[1];\n        if (objIUnknown.QueryInterface(COM.IIDIOleCommandTarget, address) != COM.S_OK)\n            return OLE.ERROR_INTERFACE_NOT_FOUND;\n        objIOleCommandTarget = new IOleCommandTarget(address[0]);\n    }\n    int inAddress = 0;\n    if (in != null) {\n        inAddress = OS.GlobalAlloc(OS.GMEM_FIXED | OS.GMEM_ZEROINIT, Variant.sizeof);\n        in.getData(inAddress);\n    }\n    int outAddress = 0;\n    if (out != null) {\n        outAddress = OS.GlobalAlloc(OS.GMEM_FIXED | OS.GMEM_ZEROINIT, Variant.sizeof);\n        out.getData(outAddress);\n    }\n    int result = objIOleCommandTarget.Exec(null, cmdID, options, inAddress, outAddress);\n    if (inAddress != 0) {\n        COM.VariantClear(inAddress);\n        OS.GlobalFree(inAddress);\n    }\n    if (outAddress != 0) {\n        out.setData(outAddress);\n        COM.VariantClear(outAddress);\n        OS.GlobalFree(outAddress);\n    }\n    return result;\n}",
			"comments":"/**\n* Asks the OLE Document or ActiveX Control to execute a command from a standard\n* list of commands. The OLE Document or ActiveX Control must support the IOleCommandTarget\n* interface.  The OLE Document or ActiveX Control does not have to support all the commands\n* in the standard list.  To check if a command is supported, you can call queryStatus with\n* the cmdID.\n*\n* @param cmdID the ID of a command; these are the OLE.OLECMDID_ values - a small set of common\n*              commands\n* @param options the optional flags; these are the OLE.OLECMDEXECOPT_ values\n* @param in the argument for the command\n* @param out the return value of the command\n*\n* @return an HRESULT value; OLE.S_OK is returned if successful\n*\n*/\n",
			"methodName":"public int exec(int cmdID, int options, Variant in, Variant out)"
		},
		"public int method0(int[] args)":{
			"methodBody":"{\n    return QueryInterface(args[0], args[1]);\n}",
			"comments":"",
			"methodName":"public int method0(int[] args)"
		},
		"private int CanInPlaceActivate()":{
			"methodBody":"{\n    if (aspect == COM.DVASPECT_CONTENT && type == COM.OLEEMBEDDED)\n        return COM.S_OK;\n    return COM.S_FALSE;\n}",
			"comments":"",
			"methodName":"private int CanInPlaceActivate()"
		},
		"private void onResize(Event e)":{
			"methodBody":"{\n    Rectangle area = frame.getClientArea();\n    setBounds(borderWidths.left, borderWidths.top, area.width - borderWidths.left - borderWidths.right, area.height - borderWidths.top - borderWidths.bottom);\n    setObjectRects();\n}",
			"comments":"",
			"methodName":"private void onResize(Event e)"
		},
		"private int Scroll(int scrollExtant)":{
			"methodBody":"{\n    return COM.S_OK;\n}",
			"comments":"",
			"methodName":"private int Scroll(int scrollExtant)"
		},
		"protected int AddRef()":{
			"methodBody":"{\n    refCount++;\n    return refCount;\n}",
			"comments":"",
			"methodName":"protected int AddRef()"
		},
		"IDispatch getAutomationObject()":{
			"methodBody":"{\n    int[] ppvObject = new int[1];\n    if (objIUnknown.QueryInterface(COM.IIDIDispatch, ppvObject) != COM.S_OK)\n        return null;\n    return new IDispatch(ppvObject[0]);\n}",
			"comments":"",
			"methodName":"IDispatch getAutomationObject()"
		},
		"private boolean updateStorage()":{
			"methodBody":"{\n    if (tempStorage == null)\n        return false;\n    int[] ppv = new int[1];\n    if (objIUnknown.QueryInterface(COM.IIDIPersistStorage, ppv) != COM.S_OK)\n        return false;\n    IPersistStorage iPersistStorage = new IPersistStorage(ppv[0]);\n    int result = COM.OleSave(iPersistStorage.getAddress(), tempStorage.getAddress(), true);\n    if (result != COM.S_OK) {\n        \n        COM.WriteClassStg(tempStorage.getAddress(), objClsid);\n        result = iPersistStorage.Save(tempStorage.getAddress(), true);\n    }\n    tempStorage.Commit(COM.STGC_DEFAULT);\n    result = iPersistStorage.SaveCompleted(0);\n    iPersistStorage.Release();\n    return true;\n}",
			"comments":"// OleSave will fail for static objects, so do what OleSave does.\n",
			"methodName":"private boolean updateStorage()"
		},
		"private void onPaint(Event e)":{
			"methodBody":"{\n    if (state == STATE_RUNNING || state == STATE_INPLACEACTIVE) {\n        SIZE size = getExtent();\n        Rectangle area = getClientArea();\n        RECT rect = new RECT();\n        if (getProgramID().startsWith(\"Excel.Sheet\")) {\n            \n            rect.left = area.x;\n            rect.right = area.x + (area.height * size.cx / size.cy);\n            rect.top = area.y;\n            rect.bottom = area.y + area.height;\n        } else {\n            rect.left = area.x;\n            rect.right = area.x + size.cx;\n            rect.top = area.y;\n            rect.bottom = area.y + size.cy;\n        }\n        int pArea = OS.GlobalAlloc(COM.GMEM_FIXED | COM.GMEM_ZEROINIT, RECT.sizeof);\n        OS.MoveMemory(pArea, rect, RECT.sizeof);\n        COM.OleDraw(objIUnknown.getAddress(), aspect, e.gc.handle, pArea);\n        OS.GlobalFree(pArea);\n    }\n}",
			"comments":"//$NON-NLS-1$\n",
			"methodName":"private void onPaint(Event e)"
		},
		"private int OnPosRectChange(int lprcPosRect)":{
			"methodBody":"{\n    Point size = getSize();\n    setExtent(size.x, size.y);\n    return COM.S_OK;\n}",
			"comments":"",
			"methodName":"private int OnPosRectChange(int lprcPosRect)"
		},
		"private SIZE xFormHimetricToPixels(SIZE aSize)":{
			"methodBody":"{\n    \n    \n    int hDC = OS.GetDC(0);\n    \n    int xppi = OS.GetDeviceCaps(hDC, 88);\n    \n    int yppi = OS.GetDeviceCaps(hDC, 90);\n    OS.ReleaseDC(0, hDC);\n    \n    int cx = Compatibility.round(aSize.cx * xppi, 2540);\n    int cy = Compatibility.round(aSize.cy * yppi, 2540);\n    SIZE size = new SIZE();\n    size.cx = cx;\n    size.cy = cy;\n    return size;\n}",
			"comments":"// Return a new Size which is the pixel transformation of a\n// size in HIMETRIC units.\n// logical pixels/inch in x\n// logical pixels/inch in y\n// 2540 HIMETRIC units per inch\n",
			"methodName":"private SIZE xFormHimetricToPixels(SIZE aSize)"
		},
		"public int method4(int[] args)":{
			"methodBody":"{\n    return ContextSensitiveHelp(args[0]);\n}",
			"comments":"",
			"methodName":"public int method4(int[] args)"
		},
		"public int method5(int[] args)":{
			"methodBody":"{\n    return CanInPlaceActivate();\n}",
			"comments":"",
			"methodName":"public int method5(int[] args)"
		},
		"private int OnClose()":{
			"methodBody":"{\n    return COM.S_OK;\n}",
			"comments":"",
			"methodName":"private int OnClose()"
		},
		"public int method7(int[] args)":{
			"methodBody":"{\n    return OnUIActivate();\n}",
			"comments":"",
			"methodName":"public int method7(int[] args)"
		},
		"public int method6(int[] args)":{
			"methodBody":"{\n    return OnInPlaceActivate();\n}",
			"comments":"",
			"methodName":"public int method6(int[] args)"
		},
		"private int GetContainer(int ppContainer)":{
			"methodBody":"{\n    \n    if (ppContainer != 0)\n        COM.MoveMemory(ppContainer, new int[] { 0 }, 4);\n    return COM.E_NOINTERFACE;\n}",
			"comments":"/* Simple containers that do not support links to their embedded\n* objects probably do not need to implement this method. Instead,\n* they can return E_NOINTERFACE and set ppContainer to NULL.\n*/\n",
			"methodName":"private int GetContainer(int ppContainer)"
		},
		"public boolean isDirty()":{
			"methodBody":"{\n    \n    \n    int[] address = new int[1];\n    if (objIOleObject.QueryInterface(COM.IIDIPersistFile, address) != COM.S_OK)\n        return true;\n    IPersistStorage permStorage = new IPersistStorage(address[0]);\n    \n    int result = permStorage.IsDirty();\n    permStorage.Release();\n    if (result == COM.S_FALSE)\n        return false;\n    return true;\n}",
			"comments":"/*\n*  Note: this method must return true unless it is absolutely clear that the\n* contents of the Ole Document do not differ from the contents in the file\n* on the file system.\n*/\n// Get access to the persistant storage mechanism\n// Are the contents of the permanent storage different from the file?\n",
			"methodName":"public boolean isDirty()"
		},
		"public int method9(int[] args)":{
			"methodBody":"{\n    return Scroll(args[0]);\n}",
			"comments":"",
			"methodName":"public int method9(int[] args)"
		},
		"protected void releaseObjectInterfaces()":{
			"methodBody":"{\n    if (objIOleInPlaceObject != null)\n        objIOleInPlaceObject.Release();\n    objIOleInPlaceObject = null;\n    if (objIOleObject != null) {\n        objIOleObject.Close(COM.OLECLOSE_NOSAVE);\n        objIOleObject.Release();\n    }\n    objIOleObject = null;\n    if (objDocumentView != null) {\n        objDocumentView.Release();\n    }\n    objDocumentView = null;\n    if (objIViewObject2 != null) {\n        objIViewObject2.SetAdvise(aspect, 0, 0);\n        objIViewObject2.Release();\n    }\n    objIViewObject2 = null;\n    if (objIOleCommandTarget != null)\n        objIOleCommandTarget.Release();\n    objIOleCommandTarget = null;\n    if (objIUnknown != null) {\n        objIUnknown.Release();\n    }\n    objIUnknown = null;\n    COM.CoFreeUnusedLibraries();\n}",
			"comments":"",
			"methodName":"protected void releaseObjectInterfaces()"
		},
		"void setBorderSpace(RECT newBorderwidth)":{
			"methodBody":"{\n    borderWidths = newBorderwidth;\n    \n    Rectangle area = frame.getClientArea();\n    setBounds(borderWidths.left, borderWidths.top, area.width - borderWidths.left - borderWidths.right, area.height - borderWidths.top - borderWidths.bottom);\n    setObjectRects();\n}",
			"comments":"// readjust size and location of client site\n",
			"methodName":"void setBorderSpace(RECT newBorderwidth)"
		},
		"public int method8(int[] args)":{
			"methodBody":"{\n    return GetWindowContext(args[0], args[1], args[2], args[3], args[4]);\n}",
			"comments":"",
			"methodName":"public int method8(int[] args)"
		},
		"private int GetWindowContext(int ppFrame, int ppDoc, int lprcPosRect, int lprcClipRect, int lpFrameInfo)":{
			"methodBody":"{\n    if (frame == null || ppFrame == 0)\n        return COM.E_NOTIMPL;\n    \n    int iOleInPlaceFrame = frame.getIOleInPlaceFrame();\n    COM.MoveMemory(ppFrame, new int[] { iOleInPlaceFrame }, 4);\n    frame.AddRef();\n    \n    if (ppDoc != 0)\n        COM.MoveMemory(ppDoc, new int[] { 0 }, 4);\n    \n    RECT rect = getRect();\n    if (lprcPosRect != 0)\n        OS.MoveMemory(lprcPosRect, rect, RECT.sizeof);\n    if (lprcClipRect != 0)\n        OS.MoveMemory(lprcClipRect, rect, RECT.sizeof);\n    \n    OLEINPLACEFRAMEINFO frameInfo = new OLEINPLACEFRAMEINFO();\n    frameInfo.cb = OLEINPLACEFRAMEINFO.sizeof;\n    frameInfo.fMDIApp = 0;\n    frameInfo.hwndFrame = frame.handle;\n    Shell shell = getShell();\n    Menu menubar = shell.getMenuBar();\n    if (menubar != null && !menubar.isDisposed()) {\n        int hwnd = shell.handle;\n        int cAccel = OS.SendMessage(hwnd, OS.WM_APP, 0, 0);\n        if (cAccel != 0) {\n            int hAccel = OS.SendMessage(hwnd, OS.WM_APP + 1, 0, 0);\n            if (hAccel != 0) {\n                frameInfo.cAccelEntries = cAccel;\n                frameInfo.haccel = hAccel;\n            }\n        }\n    }\n    COM.MoveMemory(lpFrameInfo, frameInfo, OLEINPLACEFRAMEINFO.sizeof);\n    return COM.S_OK;\n}",
			"comments":"// fill in frame handle\n// null out document handle\n// fill in position and clipping info\n// get frame info\n",
			"methodName":"private int GetWindowContext(int ppFrame, int ppDoc, int lprcPosRect, int lprcClipRect, int lpFrameInfo)"
		},
		"private SIZE getExtent()":{
			"methodBody":"{\n    SIZE sizel = new SIZE();\n    \n    if (objIOleObject != null) {\n        if (objIViewObject2 != null && !COM.OleIsRunning(objIOleObject.getAddress())) {\n            objIViewObject2.GetExtent(aspect, -1, null, sizel);\n        } else {\n            objIOleObject.GetExtent(aspect, sizel);\n        }\n    }\n    return xFormHimetricToPixels(sizel);\n}",
			"comments":"// get the current size of the embedded OLENatives object\n",
			"methodName":"private SIZE getExtent()"
		},
		"public void handleEvent(Event e)":{
			"methodBody":"{\n    switch(e.type) {\n        case SWT.Resize:\n        case SWT.Move:\n            onResize(e);\n            break;\n        case SWT.Dispose:\n            onDispose(e);\n            break;\n        case SWT.FocusIn:\n            onFocusIn(e);\n            break;\n        case SWT.FocusOut:\n            onFocusOut(e);\n            break;\n        case SWT.Paint:\n            onPaint(e);\n            break;\n        case SWT.Traverse:\n            onTraverse(e);\n            break;\n        case SWT.KeyDown:\n            \n            break;\n        default:\n            OLE.error(SWT.ERROR_NOT_IMPLEMENTED);\n    }\n}",
			"comments":"/* required for traversal */\n",
			"methodName":"public void handleEvent(Event e)"
		},
		"int ActivateMe(int pViewToActivate)":{
			"methodBody":"{\n    if (pViewToActivate == 0) {\n        int[] ppvObject = new int[1];\n        if (objIUnknown.QueryInterface(COM.IIDIOleDocument, ppvObject) != COM.S_OK)\n            return COM.E_FAIL;\n        IOleDocument objOleDocument = new IOleDocument(ppvObject[0]);\n        if (objOleDocument.CreateView(iOleInPlaceSite.getAddress(), 0, 0, ppvObject) != COM.S_OK)\n            return COM.E_FAIL;\n        objOleDocument.Release();\n        objDocumentView = new IOleDocumentView(ppvObject[0]);\n    } else {\n        objDocumentView = new IOleDocumentView(pViewToActivate);\n        objDocumentView.AddRef();\n        objDocumentView.SetInPlaceSite(iOleInPlaceSite.getAddress());\n    }\n    \n    objDocumentView.UIActivate(1);\n    RECT rect = getRect();\n    objDocumentView.SetRect(rect);\n    \n    objDocumentView.Show(1);\n    return COM.S_OK;\n}",
			"comments":"//TRUE\n//TRUE\n",
			"methodName":"int ActivateMe(int pViewToActivate)"
		},
		"public boolean save(File file, boolean includeOleInfo)":{
			"methodBody":"{\n    if (includeOleInfo)\n        return saveToStorageFile(file);\n    return saveToTraditionalFile(file);\n}",
			"comments":"",
			"methodName":"public boolean save(File file, boolean includeOleInfo)"
		},
		"public String getProgramID()":{
			"methodBody":"{\n    if (appClsid != null) {\n        int[] lplpszProgID = new int[1];\n        if (COM.ProgIDFromCLSID(appClsid, lplpszProgID) == COM.S_OK) {\n            int hMem = lplpszProgID[0];\n            int length = OS.GlobalSize(hMem);\n            int ptr = OS.GlobalLock(hMem);\n            char[] buffer = new char[length];\n            COM.MoveMemory(buffer, ptr, length);\n            OS.GlobalUnlock(hMem);\n            OS.GlobalFree(hMem);\n            String result = new String(buffer);\n            \n            int index = result.indexOf(\"\\0\");\n            return result.substring(0, index);\n        }\n    }\n    return null;\n}",
			"comments":"/**\n* Returns the program ID of the OLE Document or ActiveX Control.\n*\n* @return the program ID of the OLE Document or ActiveX Control\n*/\n// remove null terminator\n",
			"methodName":"public String getProgramID()"
		},
		"protected int GetWindow(int phwnd)":{
			"methodBody":"{\n    if (phwnd == 0)\n        return COM.E_INVALIDARG;\n    if (frame == null) {\n        COM.MoveMemory(phwnd, new int[] { 0 }, 4);\n        return COM.E_NOTIMPL;\n    }\n    \n    COM.MoveMemory(phwnd, new int[] { frame.handle }, 4);\n    return COM.S_OK;\n}",
			"comments":"// Copy the Window's handle into the memory passed in\n",
			"methodName":"protected int GetWindow(int phwnd)"
		},
		"private void setExtent(int width, int height)":{
			"methodBody":"{\n    if (objIOleObject == null || isStatic || inUpdate)\n        return;\n    SIZE currentExtent = getExtent();\n    if (width == currentExtent.cx && height == currentExtent.cy)\n        return;\n    SIZE newExtent = new SIZE();\n    newExtent.cx = width;\n    newExtent.cy = height;\n    newExtent = xFormPixelsToHimetric(newExtent);\n    \n    boolean alreadyRunning = COM.OleIsRunning(objIOleObject.getAddress());\n    if (!alreadyRunning)\n        COM.OleRun(objIOleObject.getAddress());\n    if (objIOleObject.SetExtent(aspect, newExtent) == COM.S_OK) {\n        inUpdate = true;\n        objIOleObject.Update();\n        inUpdate = false;\n        if (!alreadyRunning)\n            \n            objIOleObject.Close(COM.OLECLOSE_SAVEIFDIRTY);\n    }\n}",
			"comments":"// Resize the width and height of the embedded/linked OLENatives object\n// to the specified values.\n// Get the server running first, then do a SetExtent, then show it\n// Close server if it wasn't already running upon entering this method.\n",
			"methodName":"private void setExtent(int width, int height)"
		},
		"protected int Release()":{
			"methodBody":"{\n    refCount--;\n    if (refCount == 0) {\n        disposeCOMInterfaces();\n    }\n    return refCount;\n}",
			"comments":"",
			"methodName":"protected int Release()"
		},
		"protected void addObjectReferences()":{
			"methodBody":"{\n    \n    int[] ppvObject = new int[1];\n    if (objIUnknown.QueryInterface(COM.IIDIPersist, ppvObject) == COM.S_OK) {\n        IPersist objIPersist = new IPersist(ppvObject[0]);\n        GUID tempid = new GUID();\n        if (objIPersist.GetClassID(tempid) == COM.S_OK)\n            objClsid = tempid;\n        objIPersist.Release();\n    }\n    \n    ppvObject = new int[1];\n    int result = objIUnknown.QueryInterface(COM.IIDIViewObject2, ppvObject);\n    if (result != COM.S_OK)\n        OLE.error(OLE.ERROR_INTERFACE_NOT_FOUND, result);\n    objIViewObject2 = new IViewObject2(ppvObject[0]);\n    objIViewObject2.SetAdvise(aspect, 0, iAdviseSink.getAddress());\n    \n    ppvObject = new int[1];\n    result = objIUnknown.QueryInterface(COM.IIDIOleObject, ppvObject);\n    if (result != COM.S_OK)\n        OLE.error(OLE.ERROR_INTERFACE_NOT_FOUND, result);\n    objIOleObject = new IOleObject(ppvObject[0]);\n    objIOleObject.SetClientSite(iOleClientSite.getAddress());\n    int[] pdwConnection = new int[1];\n    objIOleObject.Advise(iAdviseSink.getAddress(), pdwConnection);\n    \n    objIOleObject.SetHostNames(\"main\", \"main\");\n    \n    COM.OleSetContainedObject(objIUnknown.getAddress(), true);\n    \n    ppvObject = new int[1];\n    if (objIUnknown.QueryInterface(COM.IIDIOleLink, ppvObject) == COM.S_OK) {\n        IOleLink objIOleLink = new IOleLink(ppvObject[0]);\n        int[] ppmk = new int[1];\n        if (objIOleLink.GetSourceMoniker(ppmk) == COM.S_OK) {\n            IMoniker objIMoniker = new IMoniker(ppmk[0]);\n            objIMoniker.Release();\n            type = COM.OLELINKED;\n            objIOleLink.BindIfRunning();\n        } else {\n            isStatic = true;\n        }\n        objIOleLink.Release();\n    }\n}",
			"comments":"//\n//\n//\n//$NON-NLS-1$ //$NON-NLS-2$\n// Notify the control object that it is embedded in an OLE container\n// Is OLE object linked or embedded?\n",
			"methodName":"protected void addObjectReferences()"
		},
		"private void deleteTempStorage()":{
			"methodBody":"{\n    \n    if (tempStorage != null) {\n        tempStorage.Release();\n    }\n    tempStorage = null;\n}",
			"comments":"//Destroy this item's contents in the temp root IStorage.\n",
			"methodName":"private void deleteTempStorage()"
		},
		"public int doVerb(int verb)":{
			"methodBody":"{\n    \n    if (state == STATE_NONE) {\n        if (COM.OleRun(objIUnknown.getAddress()) == OLE.S_OK)\n            state = STATE_RUNNING;\n    }\n    if (state == STATE_NONE || isStatic)\n        return COM.E_FAIL;\n    \n    int result = objIOleObject.DoVerb(verb, null, iOleClientSite.getAddress(), 0, handle, null);\n    if (state != STATE_RUNNING && inInit) {\n        updateStorage();\n        inInit = false;\n    }\n    return result;\n}",
			"comments":"/**\n* Requests that the OLE Document or ActiveX Control perform an action; actions are almost always\n* changes to the activation state.\n*\n* @param verb the operation that is requested.  This is one of the OLE.OLEIVERB_ values\n*\n* @return an HRESULT value indicating the success of the operation request; OLE.S_OK indicates\n*         success\n*/\n// Not all OLE clients (for example PowerPoint) can be set into the running state in the constructor.\n// The fix is to ensure that the client is in the running state before invoking any verb on it.\n// See PR: 1FV9RZW\n",
			"methodName":"public int doVerb(int verb)"
		},
		"RECT getRect()":{
			"methodBody":"{\n    Point location = this.getLocation();\n    Rectangle area = frame.getClientArea();\n    RECT rect = new RECT();\n    rect.left = location.x;\n    rect.top = location.y;\n    rect.right = location.x + area.width - borderWidths.left - borderWidths.right;\n    rect.bottom = location.y + area.height - borderWidths.top - borderWidths.bottom;\n    return rect;\n}",
			"comments":"",
			"methodName":"RECT getRect()"
		},
		"private int OnViewChange(int dwAspect, int lindex)":{
			"methodBody":"{\n    return COM.S_OK;\n}",
			"comments":"",
			"methodName":"private int OnViewChange(int dwAspect, int lindex)"
		},
		"private int OnDataChange(int pFormatetc, int pStgmed)":{
			"methodBody":"{\n    return COM.S_OK;\n}",
			"comments":"",
			"methodName":"private int OnDataChange(int pFormatetc, int pStgmed)"
		},
		"private int OnUIDeactivate(int fUndoable)":{
			"methodBody":"{\n    \n    if (frame == null || frame.isDisposed())\n        return COM.S_OK;\n    state = STATE_INPLACEACTIVE;\n    frame.SetActiveObject(0, 0);\n    redraw();\n    Shell shell = getShell();\n    if (isFocusControl() || frame.isFocusControl()) {\n        shell.traverse(SWT.TRAVERSE_TAB_NEXT);\n    }\n    Menu menubar = shell.getMenuBar();\n    if (menubar == null || menubar.isDisposed())\n        return COM.S_OK;\n    int shellHandle = shell.handle;\n    OS.SetMenu(shellHandle, menubar.handle);\n    return COM.OleSetMenuDescriptor(0, shellHandle, 0, 0, 0);\n}",
			"comments":"// currently, we are ignoring the fUndoable flag\n",
			"methodName":"private int OnUIDeactivate(int fUndoable)"
		},
		"public boolean isFocusControl()":{
			"methodBody":"{\n    checkWidget();\n    int focusHwnd = OS.GetFocus();\n    if (objIOleInPlaceObject == null)\n        return (handle == focusHwnd);\n    int[] phwnd = new int[1];\n    objIOleInPlaceObject.GetWindow(phwnd);\n    while (focusHwnd != 0) {\n        if (phwnd[0] == focusHwnd)\n            return true;\n        focusHwnd = OS.GetParent(focusHwnd);\n    }\n    return false;\n}",
			"comments":"",
			"methodName":"public boolean isFocusControl()"
		},
		"public void showProperties(String title)":{
			"methodBody":"{\n    \n    int[] ppvObject = new int[1];\n    if (objIUnknown.QueryInterface(COM.IIDISpecifyPropertyPages, ppvObject) != COM.S_OK)\n        return;\n    ISpecifyPropertyPages objISPP = new ISpecifyPropertyPages(ppvObject[0]);\n    CAUUID caGUID = new CAUUID();\n    int result = objISPP.GetPages(caGUID);\n    objISPP.Release();\n    if (result != COM.S_OK)\n        return;\n    \n    char[] chTitle = null;\n    if (title != null) {\n        chTitle = new char[title.length()];\n        title.getChars(0, title.length(), chTitle, 0);\n    }\n    result = COM.OleCreatePropertyFrame(frame.handle, 10, 10, chTitle, 1, new int[] { objIUnknown.getAddress() }, caGUID.cElems, caGUID.pElems, COM.LOCALE_USER_DEFAULT, 0, 0);\n    \n    COM.CoTaskMemFree(caGUID.pElems);\n}",
			"comments":"/**\n* Displays a dialog with the property information for this OLE Object.  The OLE Document or\n* ActiveX Control must support the ISpecifyPropertyPages interface.\n*\n* @param title the name that will appear in the titlebar of the dialog\n*/\n// Get the Property Page information from the OLE Object\n// create a frame in which to display the pages\n// free the property page information\n",
			"methodName":"public void showProperties(String title)"
		}
	},
	"ClassORInterfaceName":[
		"OleClientSite"
	]
}
