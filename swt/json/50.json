{
	"variables":[
		"LineDelimiter",
		"textListeners",
		"textStore",
		"gapStart",
		"gapEnd",
		"gapLine",
		"highWatermark",
		"lowWatermark",
		"lines",
		"lineCount",
		"expandExp",
		"replaceExpandExp",
		"size",
		"newLines",
		"range",
		"size",
		"newLines",
		"range",
		"typedListener",
		"size",
		"size",
		"start",
		"textLength",
		"i",
		"ch",
		"before",
		"after",
		"startChar",
		"before",
		"endChar",
		"after",
		"indexedLines",
		"start",
		"lineCnt",
		"i",
		"location",
		"ch",
		"newLines",
		"range",
		"startLine",
		"change",
		"endInsert",
		"startLineOffset",
		"startLineLength",
		"i",
		"newLines",
		"numNewLines",
		"i",
		"i",
		"content",
		"oldSize",
		"newSize",
		"i",
		"newGapStart",
		"newGapEnd",
		"delta",
		"delta",
		"gapLength",
		"i",
		"lineCnt",
		"count",
		"i",
		"ch",
		"lineCount",
		"length",
		"i",
		"ch",
		"length",
		"start",
		"length",
		"end",
		"buf",
		"gapLength",
		"start",
		"length",
		"end",
		"buf",
		"gapLength",
		"start",
		"length",
		"position",
		"lastLine",
		"high",
		"low",
		"index",
		"lineStart",
		"lineEnd",
		"high",
		"low",
		"index",
		"lineStart",
		"lineEnd",
		"start",
		"size",
		"newLines",
		"end",
		"gapLength",
		"buf",
		"i",
		"typedListener",
		"event",
		"i",
		"event",
		"startLine",
		"startLineOffset",
		"endLine",
		"endText",
		"splittingDelimiter",
		"oldLines",
		"j",
		"eol",
		"ch",
		"numOldLines",
		"i",
		"System",
		"lines",
		"lineCount",
		"size",
		"size",
		"Compatibility",
		"expandExp",
		"System",
		"lines",
		"newLines",
		"size",
		"lines",
		"newLines",
		"expandExp",
		"start",
		"length",
		"lines",
		"lineCount",
		"range",
		"lineCount",
		"linesArray",
		"linesArray",
		"count",
		"size",
		"newLines",
		"size",
		"Compatibility",
		"replaceExpandExp",
		"replaceExpandExp",
		"System",
		"linesArray",
		"newLines",
		"size",
		"start",
		"length",
		"newLines",
		"count",
		"range",
		"newLines",
		"listener",
		"SWT",
		"listener",
		"textListeners",
		"typedListener",
		"position",
		"gapStart",
		"gapEnd",
		"gapStart",
		"sizeHint",
		"lowWatermark",
		"size",
		"size",
		"highWatermark",
		"position",
		"sizeHint",
		"gapStart",
		"sizeHint",
		"gapEnd",
		"gapStart",
		"sizeHint",
		"lowWatermark",
		"size",
		"size",
		"highWatermark",
		"position",
		"sizeHint",
		"line",
		"lineCount",
		"textStore",
		"i",
		"start",
		"i",
		"textLength",
		"i",
		"textStore",
		"i",
		"ch",
		"SWT",
		"i",
		"textLength",
		"ch",
		"textStore",
		"i",
		"ch",
		"SWT",
		"i",
		"start",
		"i",
		"start",
		"start",
		"i",
		"ch",
		"SWT",
		"start",
		"i",
		"start",
		"start",
		"i",
		"start",
		"i",
		"start",
		"ch",
		"SWT",
		"ch",
		"SWT",
		"replaceLength",
		"start",
		"start",
		"start",
		"before",
		"start",
		"after",
		"start",
		"startChar",
		"start",
		"start",
		"before",
		"start",
		"replaceLength",
		"endChar",
		"start",
		"replaceLength",
		"start",
		"replaceLength",
		"after",
		"numLines",
		"replaceExpandExp",
		"i",
		"start",
		"i",
		"length",
		"i",
		"i",
		"offset",
		"location",
		"gapStart",
		"location",
		"gapEnd",
		"textStore",
		"location",
		"ch",
		"SWT",
		"location",
		"textStore",
		"ch",
		"textStore",
		"location",
		"ch",
		"SWT",
		"i",
		"indexedLines",
		"start",
		"i",
		"start",
		"indexedLines",
		"lineCnt",
		"lineCnt",
		"start",
		"i",
		"ch",
		"SWT",
		"indexedLines",
		"start",
		"i",
		"start",
		"indexedLines",
		"lineCnt",
		"lineCnt",
		"start",
		"i",
		"lineCnt",
		"System",
		"indexedLines",
		"newLines",
		"lineCnt",
		"start",
		"i",
		"start",
		"newLines",
		"lineCnt",
		"range",
		"newLines",
		"text",
		"position",
		"text",
		"position",
		"position",
		"change",
		"startLine",
		"startLine",
		"startLine",
		"change",
		"gapStart",
		"change",
		"i",
		"text",
		"i",
		"textStore",
		"position",
		"i",
		"text",
		"i",
		"startLineOffset",
		"startLineLength",
		"newLines",
		"newLines",
		"numNewLines",
		"endInsert",
		"numNewLines",
		"numNewLines",
		"numNewLines",
		"lineCount",
		"i",
		"startLine",
		"i",
		"lines",
		"i",
		"numNewLines",
		"lines",
		"i",
		"i",
		"numNewLines",
		"i",
		"newLines",
		"i",
		"startLineOffset",
		"lines",
		"startLine",
		"i",
		"newLines",
		"i",
		"numNewLines",
		"newLines",
		"newLines",
		"numNewLines",
		"startLineOffset",
		"lines",
		"startLine",
		"numNewLines",
		"newLines",
		"numNewLines",
		"lineCount",
		"numNewLines",
		"gapLine",
		"gapStart",
		"gapEnd",
		"gapStart",
		"size",
		"newSize",
		"highWatermark",
		"size",
		"newSize",
		"lowWatermark",
		"size",
		"lines",
		"gapLine",
		"lines",
		"gapLine",
		"oldSize",
		"gapLine",
		"i",
		"lineCount",
		"i",
		"lines",
		"i",
		"lines",
		"i",
		"oldSize",
		"newSize",
		"oldSize",
		"content",
		"textStore",
		"oldSize",
		"System",
		"textStore",
		"content",
		"gapStart",
		"System",
		"textStore",
		"gapEnd",
		"content",
		"gapStart",
		"content",
		"gapStart",
		"textStore",
		"content",
		"gapStart",
		"gapEnd",
		"position",
		"content",
		"textStore",
		"newSize",
		"oldSize",
		"position",
		"newGapStart",
		"newSize",
		"oldSize",
		"System",
		"textStore",
		"content",
		"newGapStart",
		"System",
		"textStore",
		"newGapStart",
		"content",
		"newGapEnd",
		"content",
		"newGapEnd",
		"newGapStart",
		"gapStart",
		"gapStart",
		"newGapStart",
		"System",
		"textStore",
		"content",
		"newGapStart",
		"System",
		"textStore",
		"newGapStart",
		"content",
		"newGapEnd",
		"delta",
		"System",
		"textStore",
		"gapEnd",
		"content",
		"newGapEnd",
		"delta",
		"textStore",
		"gapEnd",
		"newGapStart",
		"gapStart",
		"System",
		"textStore",
		"content",
		"gapStart",
		"System",
		"textStore",
		"gapEnd",
		"content",
		"gapStart",
		"delta",
		"System",
		"textStore",
		"gapEnd",
		"delta",
		"content",
		"newGapEnd",
		"content",
		"newGapEnd",
		"textStore",
		"content",
		"gapStart",
		"newGapStart",
		"gapEnd",
		"newGapEnd",
		"gapLine",
		"newGapLine",
		"gapEnd",
		"gapStart",
		"lines",
		"gapLine",
		"lines",
		"gapLine",
		"gapLength",
		"gapLine",
		"i",
		"lineCount",
		"i",
		"lines",
		"i",
		"lines",
		"i",
		"gapLength",
		"length",
		"startOffset",
		"i",
		"gapStart",
		"i",
		"gapEnd",
		"gapStart",
		"count",
		"length",
		"i",
		"gapStart",
		"i",
		"gapEnd",
		"textStore",
		"i",
		"ch",
		"SWT",
		"i",
		"textStore",
		"ch",
		"textStore",
		"i",
		"ch",
		"SWT",
		"i",
		"count",
		"lineCnt",
		"ch",
		"SWT",
		"lineCnt",
		"count",
		"i",
		"lineCnt",
		"text",
		"i",
		"length",
		"i",
		"text",
		"i",
		"ch",
		"SWT",
		"i",
		"length",
		"text",
		"i",
		"SWT",
		"i",
		"lineCount",
		"ch",
		"SWT",
		"lineCount",
		"lineCount",
		"gapEnd",
		"gapStart",
		"textStore",
		"length",
		"index",
		"lineCount",
		"index",
		"SWT",
		"lines",
		"index",
		"lines",
		"index",
		"start",
		"length",
		"end",
		"gapStart",
		"start",
		"gapEnd",
		"length",
		"textStore",
		"start",
		"length",
		"length",
		"textStore",
		"start",
		"length",
		"gapEnd",
		"gapStart",
		"buf",
		"textStore",
		"start",
		"gapStart",
		"start",
		"buf",
		"textStore",
		"gapEnd",
		"length",
		"gapLength",
		"gapStart",
		"start",
		"length",
		"buf",
		"length",
		"buf",
		"length",
		"length",
		"buf",
		"length",
		"LineDelimiter",
		"lines",
		"index",
		"lines",
		"index",
		"start",
		"length",
		"end",
		"gapStart",
		"start",
		"gapEnd",
		"textStore",
		"start",
		"length",
		"gapEnd",
		"gapStart",
		"buf",
		"textStore",
		"start",
		"gapStart",
		"start",
		"buf",
		"textStore",
		"gapEnd",
		"length",
		"gapLength",
		"gapStart",
		"start",
		"buf",
		"lines",
		"index",
		"lines",
		"index",
		"start",
		"length",
		"lineCount",
		"charPosition",
		"charPosition",
		"SWT",
		"charPosition",
		"gapStart",
		"position",
		"charPosition",
		"position",
		"charPosition",
		"gapEnd",
		"gapStart",
		"lineCount",
		"lineCount",
		"position",
		"lines",
		"lastLine",
		"lines",
		"lastLine",
		"lastLine",
		"lineCount",
		"lineCount",
		"high",
		"low",
		"index",
		"high",
		"low",
		"lines",
		"index",
		"lineStart",
		"lines",
		"index",
		"position",
		"lineStart",
		"high",
		"index",
		"position",
		"lineEnd",
		"high",
		"index",
		"low",
		"index",
		"high",
		"lineCount",
		"lineCount",
		"high",
		"low",
		"index",
		"high",
		"low",
		"lines",
		"index",
		"lineStart",
		"lines",
		"index",
		"position",
		"lineStart",
		"high",
		"index",
		"position",
		"lineEnd",
		"high",
		"index",
		"low",
		"index",
		"high",
		"lineIndex",
		"lineIndex",
		"lineCount",
		"lineIndex",
		"SWT",
		"lines",
		"lineIndex",
		"start",
		"gapEnd",
		"start",
		"gapEnd",
		"gapStart",
		"start",
		"lines",
		"size",
		"lineCount",
		"numLines",
		"size",
		"Math",
		"numLines",
		"System",
		"lines",
		"newLines",
		"size",
		"lines",
		"newLines",
		"SWT",
		"code",
		"gapStart",
		"gapEnd",
		"textStore",
		"start",
		"length",
		"textStore",
		"length",
		"start",
		"length",
		"end",
		"gapStart",
		"textStore",
		"start",
		"length",
		"gapStart",
		"start",
		"gapEnd",
		"gapStart",
		"textStore",
		"start",
		"gapLength",
		"length",
		"buf",
		"textStore",
		"start",
		"gapStart",
		"start",
		"buf",
		"textStore",
		"gapEnd",
		"end",
		"gapStart",
		"buf",
		"listener",
		"SWT",
		"i",
		"textListeners",
		"i",
		"textListeners",
		"i",
		"typedListener",
		"listener",
		"textListeners",
		"i",
		"start",
		"replaceLength",
		"newText",
		"SWT",
		"SWT",
		"event",
		"StyledText",
		"event",
		"start",
		"event",
		"start",
		"replaceLength",
		"event",
		"newText",
		"event",
		"newText",
		"event",
		"replaceLength",
		"event",
		"newText",
		"event",
		"start",
		"replaceLength",
		"event",
		"start",
		"newText",
		"event",
		"event",
		"StyledText",
		"event",
		"i",
		"textListeners",
		"i",
		"textListeners",
		"i",
		"event",
		"textStore",
		"text",
		"gapStart",
		"gapEnd",
		"expandExp",
		"event",
		"StyledText",
		"event",
		"event",
		"length",
		"position",
		"startLine",
		"position",
		"length",
		"position",
		"length",
		"endText",
		"position",
		"length",
		"endText",
		"SWT",
		"endText",
		"SWT",
		"splittingDelimiter",
		"position",
		"length",
		"length",
		"startLine",
		"position",
		"length",
		"gapEnd",
		"gapStart",
		"numLines",
		"position",
		"length",
		"gapStart",
		"gapStart",
		"length",
		"gapEnd",
		"length",
		"position",
		"j",
		"textStore",
		"eol",
		"j",
		"gapStart",
		"j",
		"gapEnd",
		"textStore",
		"j",
		"ch",
		"j",
		"textStore",
		"ch",
		"SWT",
		"textStore",
		"j",
		"SWT",
		"j",
		"eol",
		"j",
		"lines",
		"startLine",
		"position",
		"startLineOffset",
		"j",
		"position",
		"oldLines",
		"splittingDelimiter",
		"numOldLines",
		"endLine",
		"i",
		"lineCount",
		"i",
		"lines",
		"i",
		"numOldLines",
		"lines",
		"i",
		"lineCount",
		"numOldLines",
		"gapLine",
		"gapStart",
		"length",
		"length",
		"ERROR_NULL_ARGUMENT",
		"length",
		"CR",
		"LF",
		"LF",
		"CR",
		"LF",
		"CR",
		"length",
		"LF",
		"LF",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"CR",
		"length",
		"LF",
		"LF",
		"CR",
		"LF",
		"LF",
		"length",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"length",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"type",
		"TextChanging",
		"start",
		"replaceLineCount",
		"text",
		"newLineCount",
		"replaceCharCount",
		"newCharCount",
		"replaceLineCount",
		"type",
		"TextChanged",
		"type",
		"TextSet",
		"text",
		"CR",
		"LF",
		"length",
		"length",
		"CR",
		"LF",
		"length",
		"start",
		"length",
		"start",
		"length",
		"linesArray",
		"count",
		"listener",
		"position",
		"sizeHint",
		"line",
		"ch",
		"start",
		"replaceLength",
		"newText",
		"offset",
		"length",
		"numLines",
		"position",
		"text",
		"position",
		"size",
		"newGapLine",
		"startOffset",
		"length",
		"text",
		"index",
		"index",
		"index",
		"charPosition",
		"position",
		"lineIndex",
		"numLines",
		"code",
		"start",
		"length",
		"start",
		"length",
		"listener",
		"start",
		"replaceLength",
		"newText",
		"event",
		"text",
		"position",
		"length",
		"numLines"
	],
	"extendORImplementFiles":[
		"StyledTextContent"
	],
	"package":[
		"org.eclipse.swt.custom"
	],
	"import":[
		"org.eclipse.swt",
		"org.eclipse.swt.internal.Compatibility",
		"org.eclipse.swt.widgets",
		"java.util.Vector"
	],
	"methods":[
		"addLineIndex",
		"addLineIndex",
		"addTextChangeListener",
		"adjustGap",
		"indexLines",
		"isDelimiter",
		"isValidReplace",
		"indexLines",
		"insert",
		"moveAndResizeGap",
		"lineCount",
		"lineCount",
		"getCharCount",
		"getLine",
		"getLineDelimiter",
		"getFullLine",
		"getPhysicalLine",
		"getLineCount",
		"getLineAtOffset",
		"getLineAtPhysicalOffset",
		"getOffsetAtLine",
		"expandLinesBy",
		"error",
		"gapExists",
		"getPhysicalText",
		"getTextRange",
		"removeTextChangeListener",
		"replaceTextRange",
		"sendTextEvent",
		"setText",
		"delete",
		"getProperty",
		"setText",
		"pow2",
		"arraycopy",
		"pow2",
		"arraycopy",
		"error",
		"addElement",
		"moveAndResizeGap",
		"addLineIndex",
		"addLineIndex",
		"addLineIndex",
		"getCharCount",
		"charAt",
		"getTextRange",
		"charAt",
		"getTextRange",
		"charAt",
		"getTextRange",
		"charAt",
		"getTextRange",
		"charAt",
		"getTextRange",
		"getCharCount",
		"charAt",
		"getTextRange",
		"addLineIndex",
		"addLineIndex",
		"arraycopy",
		"length",
		"getLineAtOffset",
		"length",
		"getCharCount",
		"adjustGap",
		"getOffsetAtLine",
		"length",
		"getPhysicalLine",
		"length",
		"charAt",
		"indexLines",
		"expandLinesBy",
		"getLineAtPhysicalOffset",
		"gapExists",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"gapExists",
		"length",
		"charAt",
		"charAt",
		"error",
		"gapExists",
		"isDelimiter",
		"append",
		"append",
		"length",
		"isDelimiter",
		"charAt",
		"substring",
		"toString",
		"gapExists",
		"append",
		"append",
		"toString",
		"getPhysicalText",
		"getCharCount",
		"error",
		"error",
		"max",
		"arraycopy",
		"error",
		"gapExists",
		"append",
		"append",
		"toString",
		"error",
		"size",
		"elementAt",
		"getEventListener",
		"removeElementAt",
		"isValidReplace",
		"error",
		"lineCount",
		"lineCount",
		"length",
		"sendTextEvent",
		"delete",
		"insert",
		"sendTextEvent",
		"size",
		"handleEvent",
		"elementAt",
		"toCharArray",
		"indexLines",
		"sendTextEvent",
		"getLineAtOffset",
		"getOffsetAtLine",
		"getLineAtOffset",
		"getCharCount",
		"getTextRange",
		"charAt",
		"charAt",
		"adjustGap",
		"indexLines",
		"isDelimiter",
		"getLineAtPhysicalOffset",
		"Vector",
		"StyledTextListener",
		"String",
		"StringBuffer",
		"String",
		"StringBuffer",
		"String",
		"String",
		"String",
		"StringBuffer",
		"StyledTextEvent",
		"StyledTextEvent",
		"StyledTextEvent"
	],
	"methodsBody":{
		"int lineCount(int startOffset, int length)":{
			"methodBody":"{\n    if (length == 0) {\n        return 0;\n    }\n    int lineCnt = 0;\n    int count = 0;\n    int i = startOffset;\n    if (i >= gapStart) {\n        i += gapEnd - gapStart;\n    }\n    while (count < length) {\n        if ((i >= gapStart) && (i < gapEnd)) {\n        \n        } else {\n            char ch = textStore[i];\n            if (ch == SWT.CR) {\n                \n                if (i + 1 < textStore.length) {\n                    ch = textStore[i + 1];\n                    if (ch == SWT.LF) {\n                        i++;\n                        count++;\n                    }\n                }\n                lineCnt++;\n            } else if (ch == SWT.LF) {\n                lineCnt++;\n            }\n            count++;\n        }\n        i++;\n    }\n    return lineCnt;\n}",
			"comments":"/**\n* Returns the number of lines that are in the specified text.\n* <p>\n*\n* @param startOffset the start of the text to lineate\n* @param length the length of the text to lineate\n* @return number of lines\n*/\n// ignore the gap\n// see if the next character is a LF\n",
			"methodName":"int lineCount(int startOffset, int length)"
		},
		"int getLineAtPhysicalOffset(int position)":{
			"methodBody":"{\n    int high = lineCount;\n    int low = -1;\n    int index = lineCount;\n    while (high - low > 1) {\n        index = (high + low) / 2;\n        int lineStart = lines[index][0];\n        int lineEnd = lineStart + lines[index][1] - 1;\n        if (position <= lineStart) {\n            high = index;\n        } else if (position <= lineEnd) {\n            high = index;\n            break;\n        } else {\n            low = index;\n        }\n    }\n    return high;\n}",
			"comments":"/**\n* Returns the line index at the given physical offset.\n* <p>\n*\n* @param position physical character offset (i.e., includes gap)\n* @return the line index\n*/\n",
			"methodName":"int getLineAtPhysicalOffset(int position)"
		},
		"public void addTextChangeListener(TextChangeListener listener)":{
			"methodBody":"{\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    StyledTextListener typedListener = new StyledTextListener(listener);\n    textListeners.addElement(typedListener);\n}",
			"comments":"/**\n* Adds a <code>TextChangeListener</code> listening for\n* <code>TextChangingEvent</code> and <code>TextChangedEvent</code>. A\n* <code>TextChangingEvent</code> is sent before changes to the text occur.\n* A <code>TextChangedEvent</code> is sent after changes to the text\n* occured.\n* <p>\n*\n* @param listener the listener\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT when listener is null</li>\n* </ul>\n*/\n",
			"methodName":"public void addTextChangeListener(TextChangeListener listener)"
		},
		"void insert(int position, String text)":{
			"methodBody":"{\n    if (text.length() == 0)\n        return;\n    int startLine = getLineAtOffset(position);\n    int change = text.length();\n    boolean endInsert = position == getCharCount();\n    adjustGap(position, change, startLine);\n    \n    \n    \n    int startLineOffset = getOffsetAtLine(startLine);\n    \n    \n    int startLineLength = getPhysicalLine(startLine).length();\n    if (change > 0) {\n        \n        gapStart += (change);\n        for (int i = 0; i < text.length(); i++) textStore[position + i] = text.charAt(i);\n    }\n    \n    int[][] newLines = indexLines(startLineOffset, startLineLength, 10);\n    \n    int numNewLines = newLines.length - 1;\n    if (newLines[numNewLines][1] == 0) {\n        \n        if (endInsert) {\n            \n            \n            \n            numNewLines += 1;\n        } else {\n            numNewLines -= 1;\n        }\n    }\n    \n    expandLinesBy(numNewLines);\n    \n    for (int i = lineCount - 1; i > startLine; i--) {\n        lines[i + numNewLines] = lines[i];\n    }\n    \n    for (int i = 0; i < numNewLines; i++) {\n        newLines[i][0] += startLineOffset;\n        lines[startLine + i] = newLines[i];\n    }\n    \n    if (numNewLines < newLines.length) {\n        newLines[numNewLines][0] += startLineOffset;\n        lines[startLine + numNewLines] = newLines[numNewLines];\n    }\n    lineCount += numNewLines;\n    gapLine = getLineAtPhysicalOffset(gapStart);\n}",
			"comments":"/**\n* Inserts text.\n* <p>\n*\n* @param position the position at which to insert the text\n* @param text the text to insert\n*/\n// during an insert the gap will be adjusted to start at\n// position and it will be associated with startline, the\n// inserted text will be placed in the gap\n// at this point, startLineLength will include the start line\n// and all of the newly inserted text\n// shrink gap\n// figure out the number of new lines that have been inserted\n// only insert an empty line if it is the last line in the text\n// last inserted line is a new line\n// insert happening at end of the text, leave numNewLines as\n// is since the last new line will not be concatenated with another\n// line\n// make room for the new lines\n// shift down the lines after the replace line\n// insert the new lines\n// update the last inserted line\n",
			"methodName":"void insert(int position, String text)"
		},
		"void addLineIndex(int start, int length)":{
			"methodBody":"{\n    int size = lines.length;\n    if (lineCount == size) {\n        \n        int[][] newLines = new int[size + Compatibility.pow2(expandExp)][2];\n        System.arraycopy(lines, 0, newLines, 0, size);\n        lines = newLines;\n        expandExp++;\n    }\n    int[] range = new int[] { start, length };\n    lines[lineCount] = range;\n    lineCount++;\n}",
			"comments":"/**\n* Adds a line to the end of the line indexes array.  Increases the size of the array if necessary.\n* <code>lineCount</code> is updated to reflect the new entry.\n* <p>\n*\n* @param start the start of the line\n* @param length the length of the line\n*/\n// expand the lines by powers of 2\n",
			"methodName":"void addLineIndex(int start, int length)"
		},
		"int lineCount(String text)":{
			"methodBody":"{\n    int lineCount = 0;\n    int length = text.length();\n    for (int i = 0; i < length; i++) {\n        char ch = text.charAt(i);\n        if (ch == SWT.CR) {\n            if (i + 1 < length && text.charAt(i + 1) == SWT.LF) {\n                i++;\n            }\n            lineCount++;\n        } else if (ch == SWT.LF) {\n            lineCount++;\n        }\n    }\n    return lineCount;\n}",
			"comments":"/**\n* Returns the number of lines that are in the specified text.\n* <p>\n*\n* @param text the text to lineate\n* @return number of lines in the text\n*/\n",
			"methodName":"int lineCount(String text)"
		},
		"String getPhysicalLine(int index)":{
			"methodBody":"{\n    int start = lines[index][0];\n    int length = lines[index][1];\n    return getPhysicalText(start, length);\n}",
			"comments":"/**\n* Returns the physical line at the given index (i.e., with delimiters and the gap).\n* <p>\n*\n* @param index the line index\n* @return the physical line\n*/\n",
			"methodName":"String getPhysicalLine(int index)"
		},
		"public void replaceTextRange(int start, int replaceLength, String newText)":{
			"methodBody":"{\n    \n    if (!isValidReplace(start, replaceLength, newText))\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    \n    StyledTextEvent event = new StyledTextEvent(this);\n    event.type = StyledText.TextChanging;\n    event.start = start;\n    event.replaceLineCount = lineCount(start, replaceLength);\n    event.text = newText;\n    event.newLineCount = lineCount(newText);\n    event.replaceCharCount = replaceLength;\n    event.newCharCount = newText.length();\n    sendTextEvent(event);\n    \n    delete(start, replaceLength, event.replaceLineCount + 1);\n    \n    insert(start, newText);\n    \n    event = new StyledTextEvent(this);\n    event.type = StyledText.TextChanged;\n    sendTextEvent(event);\n\n}",
			"comments":"/**\n* Replaces the text with <code>newText</code> starting at position <code>start</code>\n* for a length of <code>replaceLength</code>.  Notifies the appropriate listeners.\n* <p>\n*\n* When sending the TextChangingEvent, <code>newLineCount</code> is the number of\n* lines that are going to be inserted and <code>replaceLineCount</code> is\n* the number of lines that are going to be deleted, based on the change\n* that occurs visually.  For example:\n* <ul>\n* <li>(replaceText,newText) ==> (replaceLineCount,newLineCount)\n* <li>(\"\",\"\\n\") ==> (0,1)\n* <li>(\"\\n\\n\",\"a\") ==> (2,0)\n* </ul>\n* </p>\n*\n* @param start\tstart offset of text to replace\n* @param replaceLength start offset of text to replace\n* @param newText start offset of text to replace\n*\n* @exception SWTException <ul>\n*   <li>ERROR_INVALID_ARGUMENT when the text change results in a multi byte\n*      line delimiter being split or partially deleted.  Splitting a line\n*      delimiter by inserting text between the CR and LF characters of the\n*      \\r\\n delimiter or deleting part of this line delimiter is not supported</li>\n* </ul>\n*/\n// check for invalid replace operations\n// inform listeners\n// first delete the text to be replaced\n// then insert the new text\n// inform listeners\n// printLines();\n",
			"methodName":"public void replaceTextRange(int start, int replaceLength, String newText)"
		},
		"public String getLineDelimiter()":{
			"methodBody":"{\n    return LineDelimiter;\n}",
			"comments":"/**\n* Returns the line delimiter that should be used by the StyledText\n* widget when inserting new lines.  This delimiter may be different than the\n* delimiter that is used by the <code>StyledTextContent</code> interface.\n* <p>\n*\n* @return the platform line delimiter as specified in the line.separator\n* \tsystem property.\n*/\n",
			"methodName":"public String getLineDelimiter()"
		},
		"public int getCharCount()":{
			"methodBody":"{\n    int length = gapEnd - gapStart;\n    return (textStore.length - length);\n}",
			"comments":"/**\n* @return the logical length of the text store\n*/\n",
			"methodName":"public int getCharCount()"
		},
		"public int getLineCount()":{
			"methodBody":"{\n    return lineCount;\n}",
			"comments":"/**\n* @return the number of lines in the text store\n*/\n",
			"methodName":"public int getLineCount()"
		},
		"public int getLineAtOffset(int charPosition)":{
			"methodBody":"{\n    int position;\n    if ((charPosition > getCharCount()) || (charPosition < 0))\n        error(SWT.ERROR_INVALID_ARGUMENT);\n    if (charPosition < gapStart) {\n        \n        position = charPosition;\n    } else {\n        \n        position = charPosition + (gapEnd - gapStart);\n    }\n    \n    if (lineCount > 0) {\n        int lastLine = lineCount - 1;\n        if (position == lines[lastLine][0] + lines[lastLine][1])\n            return lastLine;\n    }\n    int high = lineCount;\n    int low = -1;\n    int index = lineCount;\n    while (high - low > 1) {\n        index = (high + low) / 2;\n        int lineStart = lines[index][0];\n        int lineEnd = lineStart + lines[index][1] - 1;\n        if (position <= lineStart) {\n            high = index;\n        } else if (position <= lineEnd) {\n            high = index;\n            break;\n        } else {\n            low = index;\n        }\n    }\n    return high;\n}",
			"comments":"/**\n* Returns the line at the given offset.\n* <p>\n*\n* @param charPosition logical character offset (i.e., does not include gap)\n* @return the line index\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT when charPosition is out of range</li>\n* </ul>\n*/\n// position is before the gap\n// position includes the gap\n// if last line and the line is not empty you can ask for\n// a position that doesn't exist (the one to the right of the\n// last character) - for inserting\n",
			"methodName":"public int getLineAtOffset(int charPosition)"
		},
		"boolean isDelimiter(char ch)":{
			"methodBody":"{\n    if (ch == SWT.CR)\n        return true;\n    if (ch == SWT.LF)\n        return true;\n    return false;\n}",
			"comments":"/**\n* Returns whether or not the given character is a line delimiter.  Both CR and LF\n* are valid line delimiters.\n* <p>\n*\n* @param ch the character to test\n* @return true if ch is a delimiter, false otherwise\n*/\n",
			"methodName":"boolean isDelimiter(char ch)"
		},
		"void moveAndResizeGap(int position, int size, int newGapLine)":{
			"methodBody":"{\n    char[] content = null;\n    int oldSize = gapEnd - gapStart;\n    int newSize;\n    if (size > 0) {\n        newSize = highWatermark + size;\n    } else {\n        newSize = lowWatermark - size;\n    }\n    \n    if (gapExists()) {\n        \n        lines[gapLine][1] = lines[gapLine][1] - oldSize;\n        \n        for (int i = gapLine + 1; i < lineCount; i++) {\n            lines[i][0] = lines[i][0] - oldSize;\n        }\n    }\n    if (newSize < 0) {\n        if (oldSize > 0) {\n            \n            content = new char[textStore.length - oldSize];\n            System.arraycopy(textStore, 0, content, 0, gapStart);\n            System.arraycopy(textStore, gapEnd, content, gapStart, content.length - gapStart);\n            textStore = content;\n        }\n        gapStart = gapEnd = position;\n        return;\n    }\n    content = new char[textStore.length + (newSize - oldSize)];\n    int newGapStart = position;\n    int newGapEnd = newGapStart + newSize;\n    if (oldSize == 0) {\n        System.arraycopy(textStore, 0, content, 0, newGapStart);\n        System.arraycopy(textStore, newGapStart, content, newGapEnd, content.length - newGapEnd);\n    } else if (newGapStart < gapStart) {\n        int delta = gapStart - newGapStart;\n        System.arraycopy(textStore, 0, content, 0, newGapStart);\n        System.arraycopy(textStore, newGapStart, content, newGapEnd, delta);\n        System.arraycopy(textStore, gapEnd, content, newGapEnd + delta, textStore.length - gapEnd);\n    } else {\n        int delta = newGapStart - gapStart;\n        System.arraycopy(textStore, 0, content, 0, gapStart);\n        System.arraycopy(textStore, gapEnd, content, gapStart, delta);\n        System.arraycopy(textStore, gapEnd + delta, content, newGapEnd, content.length - newGapEnd);\n    }\n    textStore = content;\n    gapStart = newGapStart;\n    gapEnd = newGapEnd;\n    \n    if (gapExists()) {\n        gapLine = newGapLine;\n        \n        int gapLength = gapEnd - gapStart;\n        lines[gapLine][1] = lines[gapLine][1] + (gapLength);\n        \n        for (int i = gapLine + 1; i < lineCount; i++) {\n            lines[i][0] = lines[i][0] + gapLength;\n        }\n    }\n}",
			"comments":"/**\n* Moves the gap and adjusts its size in anticipation of a text change.\n* The gap is resized to actual size + the specified size and moved to the given\n* position.\n* <p>\n*\n* @param position the position at which a change is occurring\n* @param size the size of the change\n* @param newGapLine the line where the gap should be put\n*/\n// remove the old gap from the lines information\n// adjust the line length\n// adjust the offsets of the lines after the gapLine\n// removing the gap\n// add the new gap to the lines information\n// adjust the line length\n// adjust the offsets of the lines after the gapLine\n",
			"methodName":"void moveAndResizeGap(int position, int size, int newGapLine)"
		},
		"String getPhysicalText(int start, int length)":{
			"methodBody":"{\n    return new String(textStore, start, length);\n}",
			"comments":"/**\n* Returns a string representing the continous content of\n* the text store.\n* <p>\n*\n* @param start\tthe physical start offset of the text to return\n* @param length the physical length of the text to return\n* @return the text\n*/\n",
			"methodName":"String getPhysicalText(int start, int length)"
		},
		"public String getTextRange(int start, int length)":{
			"methodBody":"{\n    if (textStore == null)\n        return \"\";\n    if (length == 0)\n        return \"\";\n    int end = start + length;\n    if (!gapExists() || (end < gapStart))\n        return new String(textStore, start, length);\n    if (gapStart < start) {\n        int gapLength = gapEnd - gapStart;\n        return new String(textStore, start + gapLength, length);\n    }\n    StringBuffer buf = new StringBuffer();\n    buf.append(textStore, start, gapStart - start);\n    buf.append(textStore, gapEnd, end - gapStart);\n    return buf.toString();\n}",
			"comments":"/**\n* Returns a string representing the logical content of\n* the text store (i.e., gap stripped out).\n* <p>\n*\n* @param start the logical start offset of the text to return\n* @param length the logical length of the text to return\n* @return the text\n*/\n",
			"methodName":"public String getTextRange(int start, int length)"
		},
		"void expandLinesBy(int numLines)":{
			"methodBody":"{\n    int size = lines.length;\n    if (size - lineCount >= numLines) {\n        return;\n    }\n    int[][] newLines = new int[size + Math.max(10, numLines)][2];\n    System.arraycopy(lines, 0, newLines, 0, size);\n    lines = newLines;\n}",
			"comments":"/**\n* Increases the line indexes array to accomodate more lines.\n* <p>\n*\n* @param numLines the number to increase the array by\n*/\n",
			"methodName":"void expandLinesBy(int numLines)"
		},
		"int[][] addLineIndex(int start, int length, int[][] linesArray, int count)":{
			"methodBody":"{\n    int size = linesArray.length;\n    int[][] newLines = linesArray;\n    if (count == size) {\n        newLines = new int[size + Compatibility.pow2(replaceExpandExp)][2];\n        replaceExpandExp++;\n        System.arraycopy(linesArray, 0, newLines, 0, size);\n    }\n    int[] range = new int[] { start, length };\n    newLines[count] = range;\n    return newLines;\n}",
			"comments":"/**\n* Adds a line index to the end of <code>linesArray</code>.  Increases the\n* size of the array if necessary and returns a new array.\n* <p>\n*\n* @param start the start of the line\n* @param length the length of the line\n* @param linesArray the array to which to add the line index\n* @param count the position at which to add the line\n* @return a new array of line indexes\n*/\n",
			"methodName":"int[][] addLineIndex(int start, int length, int[][] linesArray, int count)"
		},
		"protected boolean isValidReplace(int start, int replaceLength, String newText)":{
			"methodBody":"{\n    if (replaceLength == 0) {\n        \n        if (start == 0)\n            return true;\n        if (start == getCharCount())\n            return true;\n        char before = getTextRange(start - 1, 1).charAt(0);\n        if (before == '\\r') {\n            char after = getTextRange(start, 1).charAt(0);\n            if (after == '\\n')\n                return false;\n        }\n    } else {\n        \n        char startChar = getTextRange(start, 1).charAt(0);\n        if (startChar == '\\n') {\n            \n            if (start != 0) {\n                char before = getTextRange(start - 1, 1).charAt(0);\n                if (before == '\\r')\n                    return false;\n            }\n        }\n        char endChar = getTextRange(start + replaceLength - 1, 1).charAt(0);\n        if (endChar == '\\r') {\n            \n            if (start + replaceLength != getCharCount()) {\n                char after = getTextRange(start + replaceLength, 1).charAt(0);\n                if (after == '\\n')\n                    return false;\n            }\n        }\n    }\n    return true;\n}",
			"comments":"/**\n* Determine whether or not the replace operation is valid.  DefaultContent will not allow\n* the /r/n line delimiter to be split or partially deleted.\n* <p>\n*\n* @param start\tstart offset of text to replace\n* @param replaceLength start offset of text to replace\n* @param newText start offset of text to replace\n* @return a boolean specifying whether or not the replace operation is valid\n*/\n// inserting text, see if the \\r\\n line delimiter is being split\n// deleting text, see if part of a \\r\\n line delimiter is being deleted\n// see if char before delete position is \\r\n// see if char after delete position is \\n\n",
			"methodName":"protected boolean isValidReplace(int start, int replaceLength, String newText)"
		},
		"void indexLines()":{
			"methodBody":"{\n    int start = 0;\n    lineCount = 0;\n    int textLength = textStore.length;\n    int i;\n    for (i = start; i < textLength; i++) {\n        char ch = textStore[i];\n        if (ch == SWT.CR) {\n            \n            if (i + 1 < textLength) {\n                ch = textStore[i + 1];\n                if (ch == SWT.LF) {\n                    i++;\n                }\n            }\n            addLineIndex(start, i - start + 1);\n            start = i + 1;\n        } else if (ch == SWT.LF) {\n            addLineIndex(start, i - start + 1);\n            start = i + 1;\n        }\n    }\n    addLineIndex(start, i - start);\n}",
			"comments":"/**\n* Calculates the indexes of each line in the text store.  Assumes no gap exists.\n* Optimized to do less checking.\n*/\n// see if the next character is a LF\n",
			"methodName":"void indexLines()"
		},
		"int[][] indexLines(int offset, int length, int numLines)":{
			"methodBody":"{\n    int[][] indexedLines = new int[numLines][2];\n    int start = 0;\n    int lineCnt = 0;\n    int i;\n    replaceExpandExp = 1;\n    for (i = start; i < length; i++) {\n        int location = i + offset;\n        if ((location >= gapStart) && (location < gapEnd)) {\n        \n        } else {\n            char ch = textStore[location];\n            if (ch == SWT.CR) {\n                \n                if (location + 1 < textStore.length) {\n                    ch = textStore[location + 1];\n                    if (ch == SWT.LF) {\n                        i++;\n                    }\n                }\n                indexedLines = addLineIndex(start, i - start + 1, indexedLines, lineCnt);\n                lineCnt++;\n                start = i + 1;\n            } else if (ch == SWT.LF) {\n                indexedLines = addLineIndex(start, i - start + 1, indexedLines, lineCnt);\n                lineCnt++;\n                start = i + 1;\n            }\n        }\n    }\n    int[][] newLines = new int[lineCnt + 1][2];\n    System.arraycopy(indexedLines, 0, newLines, 0, lineCnt);\n    int[] range = new int[] { start, i - start };\n    newLines[lineCnt] = range;\n    return newLines;\n}",
			"comments":"/**\n* Calculates the indexes of each line of text in the given range.\n* <p>\n*\n* @param offset the logical start offset of the text lineate\n* @param length the length of the text to lineate, includes gap\n* @param numLines the number of lines to initially allocate for the line index array,\n*\tpassed in for efficiency (the exact number of lines may be known)\n* @return a line indexes array where each line is identified by a start offset and\n* \ta length\n*/\n// ignore the gap\n// see if the next character is a LF\n",
			"methodName":"int[][] indexLines(int offset, int length, int numLines)"
		},
		"void error(int code)":{
			"methodBody":"{\n    SWT.error(code);\n}",
			"comments":"/**\n* Reports an SWT error.\n* <p>\n*\n* @param code the error code\n*/\n",
			"methodName":"void error(int code)"
		},
		"void delete(int position, int length, int numLines)":{
			"methodBody":"{\n    if (length == 0)\n        return;\n    int startLine = getLineAtOffset(position);\n    int startLineOffset = getOffsetAtLine(startLine);\n    int endLine = getLineAtOffset(position + length);\n    String endText = \"\";\n    boolean splittingDelimiter = false;\n    if (position + length < getCharCount()) {\n        endText = getTextRange(position + length - 1, 2);\n        if ((endText.charAt(0) == SWT.CR) && (endText.charAt(1) == SWT.LF)) {\n            splittingDelimiter = true;\n        }\n    }\n    adjustGap(position + length, -length, startLine);\n    int[][] oldLines = indexLines(position, length + (gapEnd - gapStart), numLines);\n    \n    if (position + length == gapStart) {\n        gapStart -= length;\n    } else {\n        gapEnd += length;\n    }\n    \n    \n    int j = position;\n    boolean eol = false;\n    while (j < textStore.length && !eol) {\n        if (j < gapStart || j >= gapEnd) {\n            char ch = textStore[j];\n            if (isDelimiter(ch)) {\n                if (j + 1 < textStore.length)\n                    if (ch == SWT.CR && (textStore[j + 1] == SWT.LF))\n                        j++;\n                eol = true;\n            }\n        }\n        j++;\n    }\n    \n    lines[startLine][1] = (position - startLineOffset) + (j - position);\n    \n    int numOldLines = oldLines.length - 1;\n    if (splittingDelimiter)\n        numOldLines -= 1;\n    \n    for (int i = endLine + 1; i < lineCount; i++) {\n        lines[i - numOldLines] = lines[i];\n    }\n    lineCount -= numOldLines;\n    gapLine = getLineAtPhysicalOffset(gapStart);\n}",
			"comments":"/**\n* Deletes text.\n* <p>\n* @param position the position at which the text to delete starts\n* @param length the length of the text to delete\n* @param numLines the number of lines that are being deleted\n*/\n// enlarge the gap - the gap can be enlarged either to the\n// right or left\n// figure out the length of the new concatenated line, do so by\n// finding the first line delmiter after position\n// update the line where the deletion started\n// figure out the number of lines that have been deleted\n// shift up the lines after the last deleted line, no need to update\n// the offset or length of the lines\n",
			"methodName":"void delete(int position, int length, int numLines)"
		},
		"public int getOffsetAtLine(int lineIndex)":{
			"methodBody":"{\n    if (lineIndex == 0)\n        return 0;\n    if ((lineIndex >= lineCount) || (lineIndex < 0))\n        error(SWT.ERROR_INVALID_ARGUMENT);\n    int start = lines[lineIndex][0];\n    if (start > gapEnd) {\n        return start - (gapEnd - gapStart);\n    } else {\n        return start;\n    }\n}",
			"comments":"/**\n* Returns the logical offset of the given line.\n* <p>\n*\n* @param lineIndex index of line\n* @return the logical starting offset of the line.  When there are not any lines,\n* \tgetOffsetAtLine(0) is a valid call that should answer 0.\n* @exception IllegalArgumentException <ul>\n*   <li>ERROR_INVALID_ARGUMENT when lineIndex is out of range</li>\n* </ul>\n*/\n",
			"methodName":"public int getOffsetAtLine(int lineIndex)"
		},
		"void adjustGap(int position, int sizeHint, int line)":{
			"methodBody":"{\n    if (position == gapStart) {\n        \n        int size = (gapEnd - gapStart) - sizeHint;\n        if (lowWatermark <= size && size <= highWatermark)\n            return;\n    } else if ((position + sizeHint == gapStart) && (sizeHint < 0)) {\n        \n        int size = (gapEnd - gapStart) - sizeHint;\n        if (lowWatermark <= size && size <= highWatermark)\n            return;\n    }\n    moveAndResizeGap(position, sizeHint, line);\n}",
			"comments":"/**\n* Adjusts the gap to accomodate a text change that is occurring.\n* <p>\n*\n* @param position the position at which a change is occurring\n* @param sizeHint the size of the change\n* @param line the line where the gap will go\n*/\n// text is being inserted at the gap position\n// text is being deleted at the gap position\n",
			"methodName":"void adjustGap(int position, int sizeHint, int line)"
		},
		"public void setText(String text)":{
			"methodBody":"{\n    textStore = text.toCharArray();\n    gapStart = -1;\n    gapEnd = -1;\n    expandExp = 1;\n    indexLines();\n    StyledTextEvent event = new StyledTextEvent(this);\n    event.type = StyledText.TextSet;\n    event.text = \"\";\n    sendTextEvent(event);\n}",
			"comments":"/**\n* Sets the content to text and removes the gap since there are no sensible predictions\n* about where the next change will occur.\n* <p>\n*\n* @param text the text\n*/\n",
			"methodName":"public void setText(String text)"
		},
		"public String getLine(int index)":{
			"methodBody":"{\n    if ((index >= lineCount) || (index < 0))\n        error(SWT.ERROR_INVALID_ARGUMENT);\n    int start = lines[index][0];\n    int length = lines[index][1];\n    int end = start + length - 1;\n    if (!gapExists() || (end < gapStart) || (start >= gapEnd)) {\n        \n        while ((length - 1 >= 0) && isDelimiter(textStore[start + length - 1])) {\n            length--;\n        }\n        return new String(textStore, start, length);\n    } else {\n        \n        StringBuffer buf = new StringBuffer();\n        int gapLength = gapEnd - gapStart;\n        buf.append(textStore, start, gapStart - start);\n        buf.append(textStore, gapEnd, length - gapLength - (gapStart - start));\n        length = buf.length();\n        while ((length - 1 >= 0) && isDelimiter(buf.charAt(length - 1))) {\n            length--;\n        }\n        return buf.toString().substring(0, length);\n    }\n}",
			"comments":"/**\n* Returns the line at <code>index</code> without delimiters.\n* <p>\n*\n* @param index\tthe index of the line to return\n* @return the logical line text (i.e., without the gap)\n* @exception IllegalArgumentException <ul>\n*   <li>ERROR_INVALID_ARGUMENT when index is out of range</li>\n* </ul>\n*/\n// line is before or after the gap\n// gap is in the specified range, strip out the gap\n",
			"methodName":"public String getLine(int index)"
		},
		"void sendTextEvent(StyledTextEvent event)":{
			"methodBody":"{\n    for (int i = 0; i < textListeners.size(); i++) {\n        ((StyledTextListener) textListeners.elementAt(i)).handleEvent(event);\n    }\n}",
			"comments":"/**\n* Sends the text listeners the TextChanged event.\n*/\n",
			"methodName":"void sendTextEvent(StyledTextEvent event)"
		},
		"String getFullLine(int index)":{
			"methodBody":"{\n    int start = lines[index][0];\n    int length = lines[index][1];\n    int end = start + length - 1;\n    if (!gapExists() || (end < gapStart) || (start >= gapEnd)) {\n        \n        return new String(textStore, start, length);\n    } else {\n        \n        StringBuffer buf = new StringBuffer();\n        int gapLength = gapEnd - gapStart;\n        buf.append(textStore, start, gapStart - start);\n        buf.append(textStore, gapEnd, length - gapLength - (gapStart - start));\n        return buf.toString();\n    }\n}",
			"comments":"/**\n* Returns the line at the given index with delimiters.\n* <p>\n* @param index\tthe index of the line to return\n* @return the logical line text (i.e., without the gap) with delimiters\n*/\n// line is before or after the gap\n// gap is in the specified range, strip out the gap\n",
			"methodName":"String getFullLine(int index)"
		},
		"boolean gapExists()":{
			"methodBody":"{\n    return gapStart != gapEnd;\n}",
			"comments":"/**\n* Returns whether or not a gap exists in the text store.\n* <p>\n*\n* @return true if gap exists, false otherwise\n*/\n",
			"methodName":"boolean gapExists()"
		},
		"public void removeTextChangeListener(TextChangeListener listener)":{
			"methodBody":"{\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    for (int i = 0; i < textListeners.size(); i++) {\n        TypedListener typedListener = (TypedListener) textListeners.elementAt(i);\n        if (typedListener.getEventListener() == listener) {\n            textListeners.removeElementAt(i);\n            break;\n        }\n    }\n}",
			"comments":"/**\n* Removes the specified <code>TextChangeListener</code>.\n* <p>\n*\n* @param listener the listener\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT when listener is null</li>\n* </ul>\n*/\n",
			"methodName":"public void removeTextChangeListener(TextChangeListener listener)"
		}
	},
	"ClassORInterfaceName":[
		"DefaultContent"
	]
}
