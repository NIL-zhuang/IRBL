{
	"variables":[
		"content",
		"styles",
		"styleCount",
		"lineExpandExp",
		"lineCount",
		"lineBackgrounds",
		"size",
		"insertCount",
		"spaceNeeded",
		"newStyles",
		"previous",
		"previousEnd",
		"styleEnd",
		"next",
		"styleEnd",
		"nextEnd",
		"pt",
		"clearStyleEnd",
		"count",
		"deleteStyle",
		"deleteCount",
		"i",
		"overlap",
		"overlapEnd",
		"endStyle",
		"size",
		"newLines",
		"i",
		"newStyles",
		"lineIndex",
		"lineStart",
		"lineEnd",
		"high",
		"style",
		"lineStyles",
		"index",
		"styleEnd",
		"high",
		"low",
		"index",
		"style",
		"styleEnd",
		"i",
		"pt",
		"newStyleEnd",
		"added",
		"count",
		"i",
		"overlap",
		"overlapEnd",
		"endStyle",
		"high",
		"low",
		"index",
		"style",
		"startLine",
		"startLineOffset",
		"inserting",
		"i",
		"i",
		"i",
		"style",
		"end",
		"deleteStart",
		"deleteCount",
		"inserting",
		"high",
		"index",
		"beforeStyle",
		"styleEnd",
		"i",
		"style",
		"end",
		"high",
		"count",
		"index",
		"styleEnd",
		"pt",
		"newStyle",
		"pt",
		"ranges",
		"i",
		"newStyle",
		"content",
		"lineCount",
		"content",
		"lineBackgrounds",
		"lineCount",
		"style",
		"index",
		"styles",
		"insertStyles",
		"styleCount",
		"insertCount",
		"size",
		"spaceNeeded",
		"size",
		"spaceNeeded",
		"System",
		"styles",
		"newStyles",
		"size",
		"styles",
		"newStyles",
		"System",
		"styles",
		"index",
		"styles",
		"index",
		"insertCount",
		"styleCount",
		"index",
		"System",
		"insertStyles",
		"styles",
		"index",
		"insertCount",
		"styleCount",
		"styleCount",
		"insertCount",
		"style",
		"index",
		"style",
		"index",
		"style",
		"index",
		"index",
		"styles",
		"index",
		"style",
		"previous",
		"previous",
		"previous",
		"style",
		"previousEnd",
		"style",
		"previous",
		"style",
		"style",
		"index",
		"styleCount",
		"styleEnd",
		"styles",
		"index",
		"previous",
		"style",
		"style",
		"previous",
		"index",
		"styleCount",
		"styles",
		"index",
		"style",
		"next",
		"style",
		"style",
		"next",
		"next",
		"styleEnd",
		"nextEnd",
		"styleEnd",
		"next",
		"index",
		"style",
		"styles",
		"index",
		"styles",
		"index",
		"next",
		"next",
		"next",
		"style",
		"next",
		"style",
		"clearStyle",
		"clearStyle",
		"clearStyle",
		"clearStyle",
		"pt",
		"pt",
		"pt",
		"count",
		"pt",
		"i",
		"styles",
		"i",
		"overlap",
		"overlap",
		"overlap",
		"clearStyle",
		"overlapEnd",
		"clearStyleEnd",
		"overlap",
		"clearStyle",
		"overlap",
		"overlap",
		"endStyle",
		"clearStyleEnd",
		"endStyle",
		"overlapEnd",
		"clearStyleEnd",
		"overlap",
		"clearStyle",
		"overlap",
		"endStyle",
		"i",
		"overlapEnd",
		"clearStyleEnd",
		"deleteStyle",
		"deleteStyle",
		"i",
		"deleteCount",
		"overlap",
		"clearStyleEnd",
		"overlap",
		"overlapEnd",
		"overlap",
		"count",
		"deleteStyle",
		"deleteCount",
		"lineBackgrounds",
		"size",
		"lineCount",
		"numLines",
		"size",
		"Math",
		"Compatibility",
		"lineExpandExp",
		"numLines",
		"System",
		"lineBackgrounds",
		"newLines",
		"size",
		"lineBackgrounds",
		"newLines",
		"lineExpandExp",
		"index",
		"count",
		"index",
		"System",
		"styles",
		"index",
		"count",
		"styles",
		"index",
		"styleCount",
		"index",
		"count",
		"i",
		"count",
		"i",
		"styles",
		"styleCount",
		"i",
		"styleCount",
		"styleCount",
		"count",
		"styleCount",
		"System",
		"styles",
		"newStyles",
		"styleCount",
		"newStyles",
		"content",
		"event",
		"event",
		"lineBackgrounds",
		"lineIndex",
		"event",
		"lineStart",
		"event",
		"lineStart",
		"lineEnd",
		"high",
		"index",
		"styleCount",
		"index",
		"style",
		"styles",
		"index",
		"style",
		"lineEnd",
		"style",
		"style",
		"styleEnd",
		"lineStart",
		"lineStyles",
		"style",
		"event",
		"lineStyles",
		"lineStyles",
		"event",
		"styleCount",
		"high",
		"high",
		"low",
		"index",
		"high",
		"low",
		"styles",
		"index",
		"style",
		"style",
		"start",
		"style",
		"end",
		"styleEnd",
		"start",
		"style",
		"styleEnd",
		"start",
		"styleEnd",
		"end",
		"high",
		"index",
		"low",
		"index",
		"high",
		"startLine",
		"i",
		"startLine",
		"count",
		"i",
		"lineBackgrounds",
		"i",
		"background",
		"newStyle",
		"styles",
		"styleCount",
		"newStyle",
		"newStyle",
		"newStyle",
		"newStyle",
		"newStyle",
		"newStyle",
		"newStyle",
		"pt",
		"newStyle",
		"pt",
		"newStyle",
		"pt",
		"pt",
		"count",
		"pt",
		"i",
		"styles",
		"i",
		"overlap",
		"overlap",
		"overlap",
		"newStyle",
		"overlapEnd",
		"newStyleEnd",
		"newStyle",
		"overlap",
		"overlap",
		"newStyle",
		"newStyle",
		"overlap",
		"overlap",
		"newStyle",
		"overlap",
		"newStyle",
		"i",
		"newStyle",
		"i",
		"i",
		"added",
		"newStyle",
		"overlap",
		"overlap",
		"endStyle",
		"newStyleEnd",
		"endStyle",
		"overlapEnd",
		"newStyleEnd",
		"overlap",
		"newStyle",
		"overlap",
		"newStyle",
		"i",
		"i",
		"endStyle",
		"i",
		"overlapEnd",
		"newStyleEnd",
		"added",
		"styles",
		"i",
		"newStyle",
		"added",
		"i",
		"i",
		"overlap",
		"newStyleEnd",
		"overlap",
		"overlapEnd",
		"overlap",
		"added",
		"newStyle",
		"i",
		"count",
		"start",
		"length",
		"styleCount",
		"high",
		"high",
		"low",
		"index",
		"high",
		"low",
		"styles",
		"index",
		"start",
		"style",
		"high",
		"index",
		"low",
		"index",
		"ranges",
		"high",
		"styles",
		"System",
		"styles",
		"styles",
		"styleCount",
		"styles",
		"content",
		"event",
		"content",
		"startLine",
		"event",
		"event",
		"event",
		"event",
		"event",
		"content",
		"lineCount",
		"content",
		"event",
		"event",
		"event",
		"startLineOffset",
		"startLine",
		"startLine",
		"startLine",
		"event",
		"startLine",
		"event",
		"delta",
		"delta",
		"inserting",
		"delta",
		"lineCount",
		"i",
		"start",
		"i",
		"lineBackgrounds",
		"i",
		"delta",
		"lineBackgrounds",
		"i",
		"start",
		"i",
		"start",
		"delta",
		"i",
		"lineBackgrounds",
		"i",
		"start",
		"delta",
		"i",
		"lineCount",
		"i",
		"lineBackgrounds",
		"i",
		"delta",
		"lineBackgrounds",
		"i",
		"lineCount",
		"delta",
		"delta",
		"delta",
		"inserting",
		"end",
		"start",
		"delta",
		"end",
		"start",
		"delta",
		"start",
		"end",
		"index",
		"high",
		"index",
		"styleCount",
		"index",
		"style",
		"styles",
		"index",
		"inserting",
		"style",
		"start",
		"style",
		"beforeStyle",
		"start",
		"style",
		"style",
		"start",
		"style",
		"style",
		"beforeStyle",
		"beforeStyle",
		"beforeStyle",
		"index",
		"index",
		"style",
		"style",
		"style",
		"end",
		"style",
		"start",
		"styleEnd",
		"end",
		"style",
		"start",
		"style",
		"style",
		"style",
		"delta",
		"index",
		"styleEnd",
		"end",
		"deleteStart",
		"deleteStart",
		"index",
		"deleteCount",
		"style",
		"start",
		"style",
		"styleEnd",
		"end",
		"index",
		"deleteStart",
		"deleteCount",
		"index",
		"deleteCount",
		"i",
		"styleCount",
		"i",
		"style",
		"styles",
		"i",
		"style",
		"style",
		"delta",
		"styleCount",
		"start",
		"length",
		"start",
		"end",
		"high",
		"index",
		"styleCount",
		"index",
		"style",
		"styles",
		"index",
		"style",
		"style",
		"style",
		"end",
		"styleEnd",
		"start",
		"count",
		"high",
		"count",
		"lineBackgrounds",
		"index",
		"styleCount",
		"offset",
		"pt",
		"pt",
		"styles",
		"pt",
		"newStyle",
		"offset",
		"newStyle",
		"newStyle",
		"styleCount",
		"offset",
		"length",
		"pt",
		"pt",
		"pt",
		"i",
		"pt",
		"i",
		"styles",
		"pt",
		"i",
		"ranges",
		"i",
		"newStyle",
		"ranges",
		"styles",
		"content",
		"length",
		"length",
		"start",
		"length",
		"start",
		"start",
		"start",
		"start",
		"length",
		"start",
		"length",
		"start",
		"length",
		"start",
		"start",
		"length",
		"start",
		"length",
		"start",
		"start",
		"start",
		"length",
		"length",
		"start",
		"length",
		"start",
		"start",
		"start",
		"start",
		"length",
		"start",
		"length",
		"y",
		"x",
		"y",
		"start",
		"length",
		"start",
		"start",
		"length",
		"start",
		"start",
		"start",
		"length",
		"length",
		"start",
		"start",
		"start",
		"length",
		"start",
		"length",
		"lineOffset",
		"lineBackground",
		"lineOffset",
		"lineText",
		"start",
		"start",
		"length",
		"styles",
		"styles",
		"start",
		"length",
		"start",
		"start",
		"length",
		"start",
		"length",
		"start",
		"length",
		"y",
		"x",
		"x",
		"y",
		"start",
		"length",
		"start",
		"start",
		"length",
		"start",
		"length",
		"start",
		"length",
		"start",
		"start",
		"start",
		"length",
		"length",
		"start",
		"start",
		"start",
		"length",
		"start",
		"start",
		"styles",
		"length",
		"styles",
		"length",
		"length",
		"start",
		"start",
		"replaceCharCount",
		"start",
		"newCharCount",
		"replaceCharCount",
		"replaceLineCount",
		"newLineCount",
		"start",
		"replaceLineCount",
		"newLineCount",
		"start",
		"length",
		"start",
		"start",
		"length",
		"length",
		"length",
		"length",
		"start",
		"length",
		"start",
		"start",
		"length",
		"start",
		"length",
		"length",
		"start",
		"length",
		"start",
		"start",
		"start",
		"length",
		"start",
		"y",
		"x",
		"start",
		"length",
		"y",
		"y",
		"y",
		"x",
		"content",
		"style",
		"index",
		"insertStyles",
		"index",
		"style",
		"index",
		"style",
		"index",
		"style",
		"index",
		"clearStyle",
		"numLines",
		"index",
		"index",
		"count",
		"event",
		"event",
		"start",
		"end",
		"startLine",
		"count",
		"background",
		"newStyle",
		"start",
		"length",
		"ranges",
		"styles",
		"event",
		"start",
		"delta",
		"start",
		"delta",
		"start",
		"length",
		"index",
		"offset",
		"offset",
		"length"
	],
	"extendORImplementFiles":[
		"LineStyleListener",
		"LineBackgroundListener"
	],
	"package":[
		"org.eclipse.swt.custom"
	],
	"import":[
		"org.eclipse.swt.graphics",
		"org.eclipse.swt.internal.Compatibility",
		"java.util.Vector"
	],
	"methods":[
		"insertStyle",
		"insertStyles",
		"insertMergeStyle",
		"mergeStyleBefore",
		"mergeStyleAfter",
		"clearStyle",
		"expandLinesBy",
		"deleteStyle",
		"deleteStyles",
		"getStyleRanges",
		"lineGetBackground",
		"lineGetStyle",
		"searchForStyle",
		"setLineBackground",
		"setStyleRange",
		"replaceStyleRanges",
		"setStyleRanges",
		"textChanging",
		"linesChanging",
		"textChanging",
		"getOverlappingStyles",
		"getLineBackground",
		"getStyleRangeAtOffset",
		"getStyleRangesFor",
		"release",
		"getLineCount",
		"insertStyles",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"mergeStyleBefore",
		"mergeStyleAfter",
		"insertStyle",
		"similarTo",
		"similarTo",
		"getOverlappingStyles",
		"clone",
		"insertStyle",
		"deleteStyles",
		"max",
		"pow2",
		"arraycopy",
		"deleteStyles",
		"arraycopy",
		"arraycopy",
		"getLineAtOffset",
		"length",
		"searchForStyle",
		"addElement",
		"size",
		"copyInto",
		"isUnstyled",
		"clearStyle",
		"getOverlappingStyles",
		"insertStyle",
		"insertMergeStyle",
		"similarTo",
		"mergeStyleAfter",
		"insertStyle",
		"similarTo",
		"clone",
		"insertStyle",
		"insertStyle",
		"deleteStyle",
		"insertMergeStyle",
		"clearStyle",
		"insertStyles",
		"arraycopy",
		"getLineAtOffset",
		"getOffsetAtLine",
		"textChanging",
		"textChanging",
		"getCharCount",
		"linesChanging",
		"linesChanging",
		"getLineCount",
		"linesChanging",
		"linesChanging",
		"expandLinesBy",
		"searchForStyle",
		"clone",
		"insertStyle",
		"deleteStyles",
		"searchForStyle",
		"getOverlappingStyles",
		"clone",
		"getOverlappingStyles",
		"Vector",
		"StyleRange",
		"Point"
	],
	"methodsBody":{
		"void deleteStyle(int index)":{
			"methodBody":"{\n    deleteStyles(index, 1);\n}",
			"comments":"/**\n* Deletes the style at <code>index</code>.\n* <p>\n*\n* @param index\tthe index of the style to be deleted\n*/\n",
			"methodName":"void deleteStyle(int index)"
		},
		"public void lineGetBackground(LineBackgroundEvent event)":{
			"methodBody":"{\n    int lineIndex = content.getLineAtOffset(event.lineOffset);\n    event.lineBackground = lineBackgrounds[lineIndex];\n}",
			"comments":"/**\n* Handles the get line background color callback.\n* <p>\n*\n* @param event the lineOffset line number (input), lineText line text (input),\n* and background line background color (output)\n*/\n",
			"methodName":"public void lineGetBackground(LineBackgroundEvent event)"
		},
		"StyleRange getStyleRangeAtOffset(int offset)":{
			"methodBody":"{\n    if (styleCount == 0)\n        return null;\n    Point pt = getOverlappingStyles(offset, 1);\n    if (pt == null || pt.y == 0)\n        return null;\n    StyleRange newStyle = (StyleRange) styles[pt.x].clone();\n    newStyle.start = offset;\n    newStyle.length = 1;\n    return newStyle;\n}",
			"comments":"/**\n* Returns the style for the character at <code>offset</code>.  Called by StyledText.\n* Returns a new style.  Does not return the existing style.\n* <p>\n*\n* @param offset the character position in the text\n* @return a cloned StyleRange with start == offset and length == 1 if a style is\n* \tspecified or null if no style is specified\n*/\n",
			"methodName":"StyleRange getStyleRangeAtOffset(int offset)"
		},
		"boolean mergeStyleBefore(StyleRange style, int index)":{
			"methodBody":"{\n    \n    if (index > 0) {\n        StyleRange previous = styles[index - 1];\n        if (style.similarTo(previous)) {\n            \n            \n            int previousEnd = previous.start + previous.length;\n            if ((style.start <= previousEnd) && (style.start >= previous.start)) {\n                int styleEnd = style.start + style.length;\n                if ((index == styleCount) || (styleEnd <= styles[index].start)) {\n                    previous.length = style.start + style.length - previous.start;\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}",
			"comments":"/**\n* Merges the style with the style before it if possible.\n* <p>\n*\n* @param style\tthe new style\n* @param index\tthe index at which to attempt the merge.\n* @return true if the style was merged, false otherwise\n*/\n// see if the style is similar to the style before it and merge the\n// styles if possible\n// the start of style needs to be in the range of the previous style\n// and the end of style needs to be < the start of the next style\n",
			"methodName":"boolean mergeStyleBefore(StyleRange style, int index)"
		},
		"void insertStyle(StyleRange style, int index)":{
			"methodBody":"{\n    insertStyles(new StyleRange[] { style }, index);\n}",
			"comments":"/**\n* Inserts a style at the given location.\n* <p>\n*\n* @param style\tthe new style\n* @param index\tthe index at which to insert the style (the new style\n* \twill reside at this index)\n*\n*/\n",
			"methodName":"void insertStyle(StyleRange style, int index)"
		},
		"void replaceStyleRanges(int start, int length, StyleRange[] ranges)":{
			"methodBody":"{\n    clearStyle(new StyleRange(start, length, null, null));\n    \n    int high = styleCount;\n    int low = -1;\n    int index = high;\n    while (high - low > 1) {\n        index = (high + low) / 2;\n        StyleRange style = styles[index];\n        if (start <= style.start) {\n            high = index;\n        } else {\n            low = index;\n        }\n    }\n    insertStyles(ranges, high);\n}",
			"comments":"/**\n* Replace the styles for the given range.\n*\n* @param start the initial style range to replace\n* @param length the number of ranges to replace\n* @param ranges the new styles, must be in order and non-overlapping\n*/\n// find insert point\n",
			"methodName":"void replaceStyleRanges(int start, int length, StyleRange[] ranges)"
		},
		"void setLineBackground(int startLine, int count, Color background)":{
			"methodBody":"{\n    for (int i = startLine; i < startLine + count; i++) {\n        lineBackgrounds[i] = background;\n    }\n}",
			"comments":"/**\n* Updates the line background colors to reflect a new color.  Called by StyledText.\n* <p>\n*\n* @param startLine index of the first line to color\n* @param count number of lines to color starting at startLine\n* @param background the background color for the lines\n*/\n",
			"methodName":"void setLineBackground(int startLine, int count, Color background)"
		},
		"void setStyleRanges(StyleRange[] styles)":{
			"methodBody":"{\n    this.styles = new StyleRange[styles.length];\n    System.arraycopy(styles, 0, this.styles, 0, styles.length);\n    styleCount = styles.length;\n}",
			"comments":"/**\n* Sets the array of styles and discards old styles.  Called by StyledText.\n* <p>\n*\n* @param styles the new styles, must be in order and non-overlapping\n*/\n",
			"methodName":"void setStyleRanges(StyleRange[] styles)"
		},
		"boolean mergeStyleAfter(StyleRange style, int index)":{
			"methodBody":"{\n    \n    if (index < styleCount) {\n        StyleRange next = styles[index];\n        if (style.similarTo(next)) {\n            \n            \n            int styleEnd = style.start + style.length;\n            int nextEnd = next.start + next.length;\n            if ((styleEnd <= nextEnd) && (styleEnd >= next.start)) {\n                if ((index == 0) || (style.start >= styles[index - 1].start + styles[index - 1].length)) {\n                    next.length = next.start + next.length - style.start;\n                    next.start = style.start;\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}",
			"comments":"/**\n* Merges the style with the style after it if possible.\n* <p>\n*\n* @param style\tthe new style\n* @param index\tthe index at which to attempt the merge.\n* @return true if the style was merged, false otherwise\n*/\n// see if the style is similar to the style that will be after it and\n// merge the styles if possible\n// the end of style needs to be in the range of the next style and\n// the start of style needs to be > the end of the previous style\n",
			"methodName":"boolean mergeStyleAfter(StyleRange style, int index)"
		},
		"public void lineGetStyle(LineStyleEvent event)":{
			"methodBody":"{\n    int lineStart = event.lineOffset;\n    int lineEnd = lineStart + event.lineText.length();\n    int high = searchForStyle(lineStart, lineEnd);\n    StyleRange style = null;\n    Vector lineStyles = new Vector();\n    \n    for (int index = high; index < styleCount; index++) {\n        style = styles[index];\n        if (style.start > lineEnd)\n            \n            break;\n        int styleEnd = style.start + style.length - 1;\n        if (styleEnd >= lineStart)\n            lineStyles.addElement(style);\n    }\n    event.styles = new StyleRange[lineStyles.size()];\n    lineStyles.copyInto(event.styles);\n}",
			"comments":"/**\n* Handles the get line style information callback.\n* <p>\n*\n* @param event the lineOffset line number (input), lineText line text (input),\n* and styles array of StyleRanges, need to be in order (output)\n*/\n// index will represent a style that\n// -- starts after the line (end processing)\n// -- ends before the line (continue processing)\n// -- starts before the line, ends in the line (add range)\n// -- starts in the line, ends in the line (add range)\n// -- starts in the line, ends after the line (add range)\n// -- starts before the line, ends after the line (add range)\n// style starts after the line, end looping\n",
			"methodName":"public void lineGetStyle(LineStyleEvent event)"
		},
		"Point getOverlappingStyles(int start, int length)":{
			"methodBody":"{\n    StyleRange style;\n    if (styleCount == 0)\n        return null;\n    \n    \n    int end = start + length - 1;\n    int high = searchForStyle(start, end);\n    int count = 0;\n    for (int index = high; index < styleCount; index++) {\n        style = styles[index];\n        int styleEnd = style.start + style.length - 1;\n        if (style.start > end)\n            break;\n        if (styleEnd >= start)\n            count++;\n    }\n    return new Point(high, count);\n}",
			"comments":"/**\n* Returns the indexes of the styles that overlap the given range.  Styles that partially\n* or fully overlap the range will be returned.\n* <p>\n*\n* @return Point where x is the index of the starting overlap style, y is the number of\n* \tstyles that overlap the range\n*/\n// find the index of the first style for the given offset, use a binary search\n// to find the index\n",
			"methodName":"Point getOverlappingStyles(int start, int length)"
		},
		"boolean insertMergeStyle(StyleRange style, int index)":{
			"methodBody":"{\n    if (mergeStyleBefore(style, index))\n        return false;\n    if (mergeStyleAfter(style, index))\n        return false;\n    insertStyle(style, index);\n    return true;\n}",
			"comments":"/**\n* Inserts a style, merging it with adjacent styles if possible.\n* <p>\n*\n* @param style\tthe new style\n* @param index\tthe index at which to insert the style (the new style\n* \twill reside at this index)\n* @return true if the style was inserted, false if the style was merged with an adjacent\n* \tstyle\n*/\n",
			"methodName":"boolean insertMergeStyle(StyleRange style, int index)"
		},
		"void setStyleRange(StyleRange newStyle)":{
			"methodBody":"{\n    if (newStyle == null) {\n        styles = new StyleRange[0];\n        styleCount = 0;\n        return;\n    }\n    if (newStyle.length == 0)\n        return;\n    if (newStyle.isUnstyled()) {\n        clearStyle(newStyle);\n        return;\n    }\n    Point pt = getOverlappingStyles(newStyle.start, newStyle.length);\n    int newStyleEnd = newStyle.start + newStyle.length - 1;\n    \n    if (pt == null) {\n        insertStyle(newStyle, 0);\n        return;\n    }\n    \n    if (pt.y == 0) {\n        insertMergeStyle(newStyle, pt.x);\n        return;\n    }\n    \n    \n    boolean added = false;\n    int count = 0;\n    \n    for (int i = pt.x; count < pt.y; i++) {\n        StyleRange overlap = styles[i];\n        int overlapEnd = overlap.start + overlap.length - 1;\n        if (overlap.start < newStyle.start) {\n            if (overlapEnd <= newStyleEnd) {\n                \n                if (newStyle.similarTo(overlap)) {\n                    \n                    overlap.length = newStyle.start + newStyle.length - overlap.start;\n                } else {\n                    overlap.length = newStyle.start - overlap.start;\n                    \n                    if (mergeStyleAfter(newStyle, i + 1))\n                        break;\n                    \n                    \n                    insertStyle(newStyle, i + 1);\n                    i++;\n                }\n                added = true;\n            } else {\n                \n                if (newStyle.similarTo(overlap))\n                    break;\n                StyleRange endStyle = (StyleRange) overlap.clone();\n                endStyle.start = newStyleEnd + 1;\n                endStyle.length = overlapEnd - newStyleEnd;\n                overlap.length = newStyle.start - overlap.start;\n                insertStyle(newStyle, i + 1);\n                i++;\n                insertStyle(endStyle, i + 1);\n                \n                break;\n            }\n        } else {\n            if (overlapEnd <= newStyleEnd) {\n                \n                if (!added) {\n                    styles[i] = newStyle;\n                    added = true;\n                } else {\n                    deleteStyle(i);\n                    i--;\n                }\n            } else {\n                \n                overlap.start = newStyleEnd + 1;\n                overlap.length = overlapEnd - overlap.start + 1;\n                if (!added) {\n                    insertMergeStyle(newStyle, i);\n                }\n                \n                break;\n            }\n        }\n        count++;\n    }\n}",
			"comments":"/**\n* Update the styles to reflect the new style.  <code>newStyle</code> will\n* replace any old style for the range.  When this method is called, the\n* DefaultLineStyler may merge the new style with an existing style (if possible).\n* Called by StyledText when a style is added.  Called by StyledText.\n* <p>\n*\n* @param newStyle the new style information.\n*/\n// no styles exist\n// newStyle does not overlap any other styles\n// the newStyle overlaps one or more of the existing styles\n// indicates whether or not the new style has been added\n// pt.x is the index of the first overlapped style, pt.y is the number of overlapped\n// styles\n// the end of overlap needs to be replaced by newStyle\n// update overlap to accomodate the new style\n// see if newStyle can be merged with the style after overlap, if so,\n// processing is done\n// otherwise, insert the newStyle, newStyle may still overlap other\n// styles after it so continue processing\n// middle of overlap needs to be replaced by newStyle, this will\n// cause overlap to be broken into two\n// when newStyle overlaps the middle of a style, this implies that\n// processing is done (no more overlapped styles)\n// overlap will be replaced by the newStyle, make sure newStyle\n// hasn't already been added, if it has just delete overlap\n// beginning of overlap needs to be replaced by newStyle\n// when newStyle overlaps only the beginning of a style, this implies\n// that processing is done (no more overlapped styles)\n",
			"methodName":"void setStyleRange(StyleRange newStyle)"
		},
		"void deleteStyles(int index, int count)":{
			"methodBody":"{\n    if ((count == 0) || (index < 0))\n        return;\n    \n    System.arraycopy(styles, index + count, styles, index, styleCount - (index + count));\n    for (int i = 0; i < count; i++) {\n        styles[styleCount - i - 1] = null;\n    }\n    styleCount = styleCount - count;\n}",
			"comments":"/**\n* Delete count styles starting at <code>index</code>.\n* <p>\n*\n* @param index\tthe index of the style to be deleted\n* @param count\tthe number of styles to be deleted\n*/\n// shift the styles up\n",
			"methodName":"void deleteStyles(int index, int count)"
		},
		"StyleRange[] getStyleRanges()":{
			"methodBody":"{\n    StyleRange[] newStyles = new StyleRange[styleCount];\n    System.arraycopy(styles, 0, newStyles, 0, styleCount);\n    return newStyles;\n}",
			"comments":"/**\n* Returns the styles that are defined.\n* <p>\n*\n* @return the copied array of styles\n*/\n",
			"methodName":"StyleRange[] getStyleRanges()"
		},
		"StyleRange[] getStyleRangesFor(int offset, int length)":{
			"methodBody":"{\n    if (styleCount == 0)\n        return null;\n    Point pt = getOverlappingStyles(offset, length);\n    if (pt == null || pt.y == 0)\n        return null;\n    StyleRange[] ranges = new StyleRange[pt.y];\n    for (int i = 0; i < pt.y; i++) {\n        StyleRange newStyle = styles[pt.x + i];\n        ranges[i] = newStyle;\n    }\n    return ranges;\n}",
			"comments":"/**\n* Returns the styles for the given range. Returns the existing styles,\n* so be careful not to modify the return value.  Styles are not cloned\n* in order to make this method as efficient as possible.\n* <p>\n*\n* @param offset the start position of the text range\n* @param length the length of the text range\n* @return a StyleRange array or null if no styles are specified for the text\n* \trange\n*/\n",
			"methodName":"StyleRange[] getStyleRangesFor(int offset, int length)"
		},
		"void insertStyles(StyleRange[] insertStyles, int index)":{
			"methodBody":"{\n    int size = styles.length;\n    int insertCount = insertStyles.length;\n    int spaceNeeded = styleCount + insertCount - size;\n    if (spaceNeeded > 0) {\n        StyleRange[] newStyles = new StyleRange[size + spaceNeeded];\n        System.arraycopy(styles, 0, newStyles, 0, size);\n        styles = newStyles;\n    }\n    \n    System.arraycopy(styles, index, styles, index + insertCount, styleCount - index);\n    \n    System.arraycopy(insertStyles, 0, styles, index, insertCount);\n    styleCount = styleCount + insertCount;\n}",
			"comments":"/**\n* Insert the styles at the given location.\n* <p>\n*\n* @param insertStyles\tthe new styles\n* @param index\tthe index at which to insert the styles (the first new style\n* \twill reside at this index)\n*\n*/\n// shift the styles down to make room for the new styles\n// add the new styles\n",
			"methodName":"void insertStyles(StyleRange[] insertStyles, int index)"
		},
		"void expandLinesBy(int numLines)":{
			"methodBody":"{\n    int size = lineBackgrounds.length;\n    if (size - lineCount >= numLines) {\n        return;\n    }\n    Color[] newLines = new Color[size + Math.max(Compatibility.pow2(lineExpandExp), numLines)];\n    System.arraycopy(lineBackgrounds, 0, newLines, 0, size);\n    lineBackgrounds = newLines;\n    lineExpandExp++;\n}",
			"comments":"/**\n* Increases the <code>linebackgrounds</code> array to accomodate new line background\n* information.\n* <p>\n*\n* @param numLines the number to increase the array by\n*/\n",
			"methodName":"void expandLinesBy(int numLines)"
		},
		"Color getLineBackground(int index)":{
			"methodBody":"{\n    return lineBackgrounds[index];\n}",
			"comments":"/**\n* Returns the background color of a line.  Called by StyledText.  It is safe to return\n* the existing Color object since the colors are set and managed by the client.\n* <p>\n*\n* @param index\tthe line index\n* @return the background color of the line at the given index\n*/\n",
			"methodName":"Color getLineBackground(int index)"
		},
		"public void textChanging(TextChangingEvent event)":{
			"methodBody":"{\n    int startLine = content.getLineAtOffset(event.start);\n    int startLineOffset = content.getOffsetAtLine(startLine);\n    textChanging(event.start, -event.replaceCharCount);\n    textChanging(event.start, event.newCharCount);\n    if (event.replaceCharCount == content.getCharCount()) {\n        \n        linesChanging(0, -lineCount);\n        linesChanging(0, content.getLineCount() - event.replaceLineCount + event.newLineCount);\n        return;\n    }\n    if (event.start != startLineOffset) {\n        startLine = startLine + 1;\n    }\n    linesChanging(startLine, -event.replaceLineCount);\n    linesChanging(startLine, event.newLineCount);\n}",
			"comments":"/**\n* Updates the style ranges and line backgrounds to reflect a pending text\n* change.\n* Called by StyledText when a TextChangingEvent is received.\n* <p>\n*\n* @param event\tthe event with the text change information\n*/\n// all text is going to be replaced, clear line backgrounds\n",
			"methodName":"public void textChanging(TextChangingEvent event)"
		},
		"int searchForStyle(int start, int end)":{
			"methodBody":"{\n    int high = styleCount;\n    int low = -1;\n    int index = high;\n    \n    while (high - low > 1) {\n        index = (high + low) / 2;\n        StyleRange style = styles[index];\n        int styleEnd = style.start + style.length - 1;\n        if (start <= style.start || end <= styleEnd || (start > style.start && styleEnd >= start && styleEnd < end)) {\n            high = index;\n        } else {\n            low = index;\n        }\n    }\n    return high;\n}",
			"comments":"/**\n* Searches for the first style in the <code>start</code> - <code>end</code> range.\n* <p>\n*\n* @return the index of the first style that overlaps the input range\n*/\n// find the index of the first style for the given range, use a binary search\n",
			"methodName":"int searchForStyle(int start, int end)"
		},
		"void linesChanging(int start, int delta)":{
			"methodBody":"{\n    if (delta == 0)\n        return;\n    boolean inserting = delta > 0;\n    if (inserting) {\n        \n        expandLinesBy(delta);\n        for (int i = lineCount - 1; i >= start; i--) {\n            lineBackgrounds[i + delta] = lineBackgrounds[i];\n        }\n        for (int i = start; i < start + delta; i++) {\n            lineBackgrounds[i] = null;\n        }\n    } else {\n        \n        for (int i = start - delta; i < lineCount; i++) {\n            lineBackgrounds[i + delta] = lineBackgrounds[i];\n        }\n    }\n    lineCount += delta;\n}",
			"comments":"/*\n* Updates the line backgrounds to reflect a pending text change.\n* <p>\n*\n* @param start\tthe starting line of the change that is about to take place\n* @param delta\tthe number of lines in the change, > 0 indicates lines inserted,\n* \t< 0 indicates lines deleted\n*/\n// shift the lines down to make room for new lines\n// shift up the lines\n",
			"methodName":"void linesChanging(int start, int delta)"
		},
		"void textChanging(int start, int delta)":{
			"methodBody":"{\n    if (delta == 0)\n        return;\n    StyleRange style;\n    \n    \n    int end;\n    int deleteStart = -1;\n    int deleteCount = 0;\n    boolean inserting = delta > 0;\n    if (inserting) {\n        end = (start + delta) - 1;\n    } else {\n        end = (start - delta) - 1;\n    }\n    int high = searchForStyle(start, end);\n    int index;\n    \n    for (index = high; index < styleCount; index++) {\n        style = styles[index];\n        if (inserting) {\n            if (style.start >= start)\n                break;\n            \n            \n            StyleRange beforeStyle = (StyleRange) style.clone();\n            beforeStyle.length = start - style.start;\n            style.start = start;\n            style.length = style.length - beforeStyle.length;\n            if (beforeStyle.length != 0)\n                insertStyle(beforeStyle, index);\n            index++;\n            break;\n        } else {\n            int styleEnd = style.start + style.length - 1;\n            if (style.start > end)\n                break;\n            \n            if (style.start < start) {\n                if (styleEnd <= end) {\n                    \n                    style.length = start - style.start;\n                } else {\n                    \n                    style.length = style.length + delta;\n                    index++;\n                    break;\n                }\n            } else {\n                if (styleEnd <= end) {\n                    \n                    if (deleteStart == -1) {\n                        deleteStart = index;\n                    }\n                    deleteCount++;\n                } else {\n                    \n                    style.start = start;\n                    style.length = styleEnd - end;\n                    index++;\n                    break;\n                }\n            }\n        }\n    }\n    deleteStyles(deleteStart, deleteCount);\n    \n    for (int i = index - deleteCount; i < styleCount; i++) {\n        style = styles[i];\n        style.start = style.start + delta;\n    }\n}",
			"comments":"/*\n* Updates the style ranges to reflect a text change.\n* <p>\n*\n* @param start\tthe starting offset of the change that is about to\n*\ttake place\n* @param delta\tthe length of the change, > 0 indicates text inserted,\n* \t< 0 indicates text deleted\n*/\n// find the index of the first style for the given offset, use a binary search\n// to find the index\n// update the styles that are in the affected range\n// in the insert case only one style range will be directly affected,\n// it will need to be split into two and then the newStyle inserted\n// in the delete case, any style that overlaps the change range will be\n// affected\n// style starts before change range, ends in change range\n// style starts before change range, ends after change range\n// style starts in change range, ends in change range\n// style starts in change range, ends after change range\n// change the offsets of the styles after the affected styles\n",
			"methodName":"void textChanging(int start, int delta)"
		},
		"void clearStyle(StyleRange clearStyle)":{
			"methodBody":"{\n    Point pt = getOverlappingStyles(clearStyle.start, clearStyle.length);\n    int clearStyleEnd = clearStyle.start + clearStyle.length - 1;\n    \n    if ((pt == null) || (pt.y == 0))\n        return;\n    \n    \n    \n    int count = 0;\n    int deleteStyle = -1;\n    int deleteCount = 0;\n    for (int i = pt.x; count < pt.y; i++) {\n        StyleRange overlap = styles[i];\n        int overlapEnd = overlap.start + overlap.length - 1;\n        if (overlap.start < clearStyle.start) {\n            if (overlapEnd <= clearStyleEnd) {\n                \n                overlap.length = clearStyle.start - overlap.start;\n            } else {\n                \n                \n                StyleRange endStyle = (StyleRange) overlap.clone();\n                endStyle.start = clearStyleEnd + 1;\n                endStyle.length = overlapEnd - clearStyleEnd;\n                overlap.length = clearStyle.start - overlap.start;\n                insertStyle(endStyle, i + 1);\n                break;\n            }\n        } else {\n            if (overlapEnd <= clearStyleEnd) {\n                \n                if (deleteStyle == -1) {\n                    deleteStyle = i;\n                }\n                deleteCount++;\n            } else {\n                \n                overlap.start = clearStyleEnd + 1;\n                overlap.length = overlapEnd - overlap.start + 1;\n                break;\n            }\n        }\n        count++;\n    }\n    deleteStyles(deleteStyle, deleteCount);\n}",
			"comments":"/**\n* Removes style information that is defined for the range of text in <code>clearStyle</code>.\n* <p>\n*\n* @param clearStyle the style information to use for clearing\n*/\n// no overlapped styles exist\n// the newStyle overlaps one or more of the existing styles\n// pt.x is the index of the first overlapped style, pt.y is the number of overlapped\n// styles\n// the end of overlap needs to be cleared\n// middle of overlap needs to be cleared, this will\n// cause overlap to be broken into two\n// entire overlap needs to be cleared\n// beginning of overlap needs to be cleared\n",
			"methodName":"void clearStyle(StyleRange clearStyle)"
		},
		"void release()":{
			"methodBody":"{\n    styles = null;\n}",
			"comments":"",
			"methodName":"void release()"
		}
	},
	"ClassORInterfaceName":[
		"DefaultLineStyler"
	]
}
