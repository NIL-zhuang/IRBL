{
	"variables":[
		"file",
		"isLittleEndian",
		"loader",
		"depth",
		"imageWidth",
		"imageLength",
		"bitsPerSample",
		"compression",
		"photometricInterpretation",
		"stripOffsets",
		"samplesPerPixel",
		"rowsPerStrip",
		"stripByteCounts",
		"t4Options",
		"colorMapOffset",
		"image",
		"out",
		"NO_VALUE",
		"TAG_ImageWidth",
		"TAG_ImageLength",
		"TAG_BitsPerSample",
		"TAG_Compression",
		"TAG_PhotometricInterpretation",
		"TAG_StripOffsets",
		"TAG_SamplesPerPixel",
		"TAG_RowsPerStrip",
		"TAG_StripByteCounts",
		"TAG_XResolution",
		"TAG_YResolution",
		"TAG_T4Options",
		"TAG_ResolutionUnit",
		"TAG_ColorMap",
		"TYPE_BYTE",
		"TYPE_ASCII",
		"TYPE_SHORT",
		"TYPE_LONG",
		"TYPE_RATIONAL",
		"COMPRESSION_NONE",
		"COMPRESSION_CCITT_3_1",
		"COMPRESSION_PACKBITS",
		"IFD_ENTRY_SIZE",
		"destIndex",
		"srcIndex",
		"n",
		"value",
		"j",
		"start",
		"size",
		"offset",
		"i",
		"imageData",
		"destIndex",
		"length",
		"i",
		"data",
		"codec",
		"nRows",
		"n",
		"numColors",
		"numBytes",
		"buffer",
		"colors",
		"offset",
		"startG",
		"startB",
		"i",
		"r",
		"g",
		"b",
		"numColors",
		"rgbs",
		"i",
		"value",
		"blueMask",
		"i",
		"greenMask",
		"i",
		"redMask",
		"i",
		"n",
		"nbrRowsPerStrip",
		"nbr",
		"stripByteSize",
		"offsets",
		"counts",
		"postIFDData",
		"startOffset",
		"offset",
		"i",
		"mod",
		"colorMap",
		"offsetGreen",
		"offsetBlue",
		"i",
		"offset",
		"tag",
		"type",
		"count",
		"buffer",
		"numberEntries",
		"palette",
		"image",
		"isRGB",
		"isColorMap",
		"isBiLevel",
		"imageWidth",
		"imageLength",
		"rowByteSize",
		"numberEntries",
		"lengthDirectory",
		"nextOffset",
		"extraBytes",
		"colorMap",
		"palette",
		"rgbs",
		"data",
		"strips",
		"nbrRowsPerStrip",
		"stripOffsets",
		"stripByteCounts",
		"bitsPerSampleOffset",
		"stripOffsetsOffset",
		"stripByteCountsOffset",
		"xResolutionOffset",
		"yResolutionOffset",
		"colorMapOffset",
		"cnt",
		"i",
		"i",
		"i",
		"i",
		"i",
		"photometricInterpretation",
		"palette",
		"rgbs",
		"rgb0",
		"rgb1",
		"file",
		"isLittleEndian",
		"loader",
		"image",
		"offsetDest",
		"srcIndex",
		"src",
		"src",
		"srcIndex",
		"n",
		"n",
		"System",
		"src",
		"srcIndex",
		"dest",
		"destIndex",
		"n",
		"srcIndex",
		"n",
		"destIndex",
		"n",
		"n",
		"n",
		"src",
		"srcIndex",
		"j",
		"n",
		"j",
		"dest",
		"destIndex",
		"value",
		"srcIndex",
		"srcIndex",
		"destIndex",
		"offsetDest",
		"buffer",
		"index",
		"type",
		"index",
		"buffer",
		"start",
		"TYPE_LONG",
		"type",
		"TYPE_SHORT",
		"size",
		"TYPE_LONG",
		"size",
		"TYPE_RATIONAL",
		"size",
		"TYPE_ASCII",
		"TYPE_BYTE",
		"size",
		"SWT",
		"SWT",
		"values",
		"size",
		"buffer",
		"values",
		"size",
		"file",
		"offset",
		"file",
		"buffer",
		"start",
		"i",
		"values",
		"i",
		"values",
		"i",
		"buffer",
		"start",
		"i",
		"size",
		"type",
		"imageWidth",
		"depth",
		"imageLength",
		"image",
		"imageData",
		"stripOffsets",
		"i",
		"length",
		"i",
		"stripByteCounts",
		"i",
		"file",
		"stripOffsets",
		"i",
		"file",
		"data",
		"compression",
		"COMPRESSION_NONE",
		"System",
		"data",
		"imageData",
		"destIndex",
		"data",
		"destIndex",
		"data",
		"compression",
		"COMPRESSION_PACKBITS",
		"destIndex",
		"data",
		"imageData",
		"destIndex",
		"compression",
		"COMPRESSION_CCITT_3_1",
		"compression",
		"rowsPerStrip",
		"i",
		"length",
		"imageLength",
		"rowsPerStrip",
		"n",
		"nRows",
		"n",
		"destIndex",
		"codec",
		"data",
		"imageData",
		"destIndex",
		"imageWidth",
		"nRows",
		"loader",
		"loader",
		"loader",
		"image",
		"i",
		"i",
		"length",
		"bitsPerSample",
		"numColors",
		"numBytes",
		"file",
		"colorMapOffset",
		"file",
		"buffer",
		"numColors",
		"isLittleEndian",
		"numColors",
		"startG",
		"numColors",
		"i",
		"numColors",
		"i",
		"buffer",
		"offset",
		"buffer",
		"startG",
		"offset",
		"buffer",
		"startB",
		"offset",
		"colors",
		"i",
		"r",
		"g",
		"b",
		"offset",
		"colors",
		"bitsPerSample",
		"numColors",
		"i",
		"numColors",
		"i",
		"i",
		"numColors",
		"photometricInterpretation",
		"value",
		"value",
		"rgbs",
		"i",
		"value",
		"value",
		"value",
		"rgbs",
		"i",
		"bitsB",
		"i",
		"blueMask",
		"i",
		"bitsB",
		"i",
		"bitsB",
		"bitsG",
		"i",
		"greenMask",
		"i",
		"bitsB",
		"bitsG",
		"i",
		"bitsB",
		"bitsG",
		"bitsR",
		"i",
		"redMask",
		"i",
		"redMask",
		"greenMask",
		"blueMask",
		"rowByteSize",
		"maxStripByteSize",
		"n",
		"data",
		"rowByteSize",
		"nbrRowsPerStrip",
		"data",
		"maxStripByteSize",
		"maxStripByteSize",
		"nbrRowsPerStrip",
		"nbrRows",
		"nbr",
		"n",
		"nbrRows",
		"nbrRowsPerStrip",
		"nbrRowsPerStrip",
		"rowByteSize",
		"nbrRowsPerStrip",
		"n",
		"n",
		"n",
		"n",
		"offsetPostIFD",
		"extraBytes",
		"postIFDData",
		"startOffset",
		"i",
		"n",
		"i",
		"offsets",
		"i",
		"offset",
		"counts",
		"i",
		"stripByteSize",
		"offset",
		"stripByteSize",
		"data",
		"stripByteSize",
		"mod",
		"counts",
		"counts",
		"mod",
		"strips",
		"offsets",
		"strips",
		"counts",
		"nbrRowsPerStrip",
		"rgbs",
		"rgbs",
		"rgbs",
		"i",
		"rgbs",
		"i",
		"colorMap",
		"i",
		"rgbs",
		"i",
		"rgbs",
		"i",
		"colorMap",
		"i",
		"offsetGreen",
		"rgbs",
		"i",
		"rgbs",
		"i",
		"colorMap",
		"i",
		"offsetBlue",
		"rgbs",
		"i",
		"rgbs",
		"i",
		"colorMap",
		"offset",
		"buffer",
		"offset",
		"IFD_ENTRY_SIZE",
		"buffer",
		"offset",
		"TYPE_SHORT",
		"buffer",
		"offset",
		"TYPE_SHORT",
		"buffer",
		"offset",
		"TYPE_LONG",
		"tag",
		"TAG_ImageWidth",
		"imageWidth",
		"type",
		"buffer",
		"offset",
		"TAG_ImageLength",
		"imageLength",
		"type",
		"buffer",
		"offset",
		"TAG_BitsPerSample",
		"type",
		"TYPE_SHORT",
		"SWT",
		"SWT",
		"bitsPerSample",
		"count",
		"type",
		"buffer",
		"offset",
		"bitsPerSample",
		"TAG_Compression",
		"compression",
		"type",
		"buffer",
		"offset",
		"TAG_PhotometricInterpretation",
		"photometricInterpretation",
		"type",
		"buffer",
		"offset",
		"TAG_StripOffsets",
		"type",
		"TYPE_LONG",
		"type",
		"TYPE_SHORT",
		"SWT",
		"SWT",
		"stripOffsets",
		"count",
		"type",
		"buffer",
		"offset",
		"stripOffsets",
		"TAG_SamplesPerPixel",
		"type",
		"TYPE_SHORT",
		"SWT",
		"SWT",
		"samplesPerPixel",
		"type",
		"buffer",
		"offset",
		"samplesPerPixel",
		"samplesPerPixel",
		"SWT",
		"SWT",
		"TAG_RowsPerStrip",
		"rowsPerStrip",
		"type",
		"buffer",
		"offset",
		"TAG_StripByteCounts",
		"stripByteCounts",
		"count",
		"type",
		"buffer",
		"offset",
		"stripByteCounts",
		"TAG_XResolution",
		"TAG_YResolution",
		"TAG_T4Options",
		"type",
		"TYPE_LONG",
		"SWT",
		"SWT",
		"t4Options",
		"type",
		"buffer",
		"offset",
		"t4Options",
		"SWT",
		"SWT",
		"TAG_ResolutionUnit",
		"TAG_ColorMap",
		"type",
		"TYPE_SHORT",
		"SWT",
		"SWT",
		"colorMapOffset",
		"TYPE_LONG",
		"buffer",
		"offset",
		"bitsPerSample",
		"colorMapOffset",
		"NO_VALUE",
		"compression",
		"imageLength",
		"NO_VALUE",
		"imageWidth",
		"NO_VALUE",
		"photometricInterpretation",
		"NO_VALUE",
		"rowsPerStrip",
		"Integer",
		"samplesPerPixel",
		"stripByteCounts",
		"stripOffsets",
		"file",
		"buffer",
		"buffer",
		"TYPE_SHORT",
		"buffer",
		"IFD_ENTRY_SIZE",
		"numberEntries",
		"file",
		"buffer",
		"buffer",
		"depth",
		"photometricInterpretation",
		"palette",
		"depth",
		"bitsPerSample",
		"colorMapOffset",
		"NO_VALUE",
		"SWT",
		"SWT",
		"palette",
		"bitsPerSample",
		"bitsPerSample",
		"bitsPerSample",
		"depth",
		"bitsPerSample",
		"bitsPerSample",
		"bitsPerSample",
		"colorMapOffset",
		"NO_VALUE",
		"SWT",
		"SWT",
		"palette",
		"depth",
		"bitsPerSample",
		"SWT",
		"SWT",
		"ImageData",
		"imageWidth",
		"imageLength",
		"depth",
		"palette",
		"SWT",
		"image",
		"image",
		"type",
		"TYPE_LONG",
		"isLittleEndian",
		"buffer",
		"i",
		"buffer",
		"i",
		"buffer",
		"i",
		"buffer",
		"i",
		"buffer",
		"i",
		"buffer",
		"i",
		"buffer",
		"i",
		"buffer",
		"i",
		"type",
		"TYPE_SHORT",
		"isLittleEndian",
		"buffer",
		"i",
		"buffer",
		"i",
		"buffer",
		"i",
		"buffer",
		"i",
		"SWT",
		"SWT",
		"photometricInterpretation",
		"photometricInterpretation",
		"photometricInterpretation",
		"photometricInterpretation",
		"image",
		"image",
		"image",
		"isBiLevel",
		"numberEntries",
		"lengthDirectory",
		"isColorMap",
		"image",
		"palette",
		"colorMap",
		"rgbs",
		"colorMap",
		"image",
		"SWT",
		"SWT",
		"extraBytes",
		"colorMap",
		"isRGB",
		"extraBytes",
		"image",
		"rowByteSize",
		"imageLength",
		"data",
		"nextOffset",
		"extraBytes",
		"strips",
		"strips",
		"strips",
		"NO_VALUE",
		"isRGB",
		"bitsPerSampleOffset",
		"nextOffset",
		"nextOffset",
		"NO_VALUE",
		"NO_VALUE",
		"NO_VALUE",
		"stripOffsets",
		"cnt",
		"stripOffsetsOffset",
		"nextOffset",
		"nextOffset",
		"cnt",
		"stripByteCountsOffset",
		"nextOffset",
		"nextOffset",
		"cnt",
		"xResolutionOffset",
		"nextOffset",
		"nextOffset",
		"yResolutionOffset",
		"nextOffset",
		"nextOffset",
		"isColorMap",
		"colorMapOffset",
		"nextOffset",
		"nextOffset",
		"colorMap",
		"out",
		"numberEntries",
		"TAG_ImageWidth",
		"TYPE_LONG",
		"imageWidth",
		"TAG_ImageLength",
		"TYPE_LONG",
		"imageLength",
		"isColorMap",
		"TAG_BitsPerSample",
		"TYPE_SHORT",
		"image",
		"isRGB",
		"TAG_BitsPerSample",
		"TYPE_SHORT",
		"bitsPerSampleOffset",
		"TAG_Compression",
		"TYPE_SHORT",
		"COMPRESSION_NONE",
		"TAG_PhotometricInterpretation",
		"TYPE_SHORT",
		"photometricInterpretation",
		"TAG_StripOffsets",
		"TYPE_LONG",
		"cnt",
		"cnt",
		"stripOffsetsOffset",
		"stripOffsets",
		"isRGB",
		"TAG_SamplesPerPixel",
		"TYPE_SHORT",
		"TAG_RowsPerStrip",
		"TYPE_LONG",
		"nbrRowsPerStrip",
		"TAG_StripByteCounts",
		"TYPE_LONG",
		"cnt",
		"cnt",
		"stripByteCountsOffset",
		"stripByteCounts",
		"TAG_XResolution",
		"TYPE_RATIONAL",
		"xResolutionOffset",
		"TAG_YResolution",
		"TYPE_RATIONAL",
		"yResolutionOffset",
		"isColorMap",
		"TAG_ColorMap",
		"TYPE_SHORT",
		"colorMap",
		"colorMapOffset",
		"out",
		"isRGB",
		"i",
		"i",
		"out",
		"cnt",
		"i",
		"cnt",
		"i",
		"out",
		"stripOffsets",
		"i",
		"i",
		"cnt",
		"i",
		"out",
		"stripByteCounts",
		"i",
		"i",
		"i",
		"out",
		"out",
		"isColorMap",
		"i",
		"colorMap",
		"i",
		"out",
		"colorMap",
		"i",
		"out",
		"data",
		"out",
		"tag",
		"out",
		"type",
		"out",
		"count",
		"out",
		"value",
		"out",
		"out",
		"out",
		"out",
		"out",
		"byteStream",
		"image",
		"SWT",
		"SWT",
		"image",
		"image",
		"palette",
		"palette",
		"rgbs",
		"rgbs",
		"SWT",
		"SWT",
		"rgbs",
		"rgbs",
		"rgb0",
		"rgb0",
		"rgb0",
		"rgb0",
		"rgb1",
		"rgb1",
		"rgb1",
		"rgb1",
		"rgb0",
		"rgb1",
		"rgb0",
		"rgb1",
		"SWT",
		"SWT",
		"photometricInterpretation",
		"image",
		"photometricInterpretation",
		"photometricInterpretation",
		"SWT",
		"SWT",
		"photometricInterpretation",
		"file",
		"isLittleEndian",
		"loader",
		"image",
		"length",
		"ERROR_UNSUPPORTED_FORMAT",
		"length",
		"length",
		"length",
		"data",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"red",
		"red",
		"green",
		"green",
		"blue",
		"blue",
		"length",
		"ERROR_INVALID_IMAGE",
		"ERROR_INVALID_IMAGE",
		"ERROR_INVALID_IMAGE",
		"ERROR_UNSUPPORTED_DEPTH",
		"ERROR_INVALID_IMAGE",
		"ERROR_UNSUPPORTED_FORMAT",
		"ERROR_INVALID_IMAGE",
		"MAX_VALUE",
		"ERROR_INVALID_IMAGE",
		"ERROR_INVALID_IMAGE",
		"ERROR_INVALID_IMAGE",
		"IMAGE_TIFF",
		"ERROR_INVALID_IMAGE",
		"width",
		"height",
		"bytesPerLine",
		"palette",
		"length",
		"depth",
		"ERROR_UNSUPPORTED_FORMAT",
		"length",
		"data",
		"length",
		"length",
		"depth",
		"length",
		"length",
		"scanlinePad",
		"ERROR_UNSUPPORTED_FORMAT",
		"depth",
		"palette",
		"colors",
		"isDirect",
		"length",
		"ERROR_UNSUPPORTED_FORMAT",
		"red",
		"green",
		"green",
		"blue",
		"red",
		"green",
		"green",
		"blue",
		"red",
		"red",
		"red",
		"red",
		"ERROR_UNSUPPORTED_FORMAT",
		"red",
		"colors",
		"palette",
		"ERROR_UNSUPPORTED_FORMAT",
		"file",
		"isLittleEndian",
		"loader",
		"image",
		"src",
		"dest",
		"offsetDest",
		"type",
		"buffer",
		"index",
		"type",
		"buffer",
		"index",
		"values",
		"image",
		"bitsR",
		"bitsG",
		"bitsB",
		"rowByteSize",
		"nbrRows",
		"data",
		"maxStripByteSize",
		"offsetPostIFD",
		"extraBytes",
		"strips",
		"rgbs",
		"buffer",
		"buffer",
		"i",
		"type",
		"photometricInterpretation",
		"tag",
		"type",
		"count",
		"value",
		"byteStream"
	],
	"extendORImplementFiles":[],
	"package":[
		"org.eclipse.swt.internal.image"
	],
	"import":[
		"org.eclipse.swt",
		"org.eclipse.swt.graphics",
		"java.io"
	],
	"methods":[
		"decodePackBits",
		"getEntryValue",
		"getEntryValue",
		"decodePixels",
		"getColorMap",
		"getGrayPalette",
		"getRGBPalette",
		"formatStrips",
		"formatColorMap",
		"parseEntries",
		"read",
		"toInt",
		"write",
		"writeEntry",
		"writeHeader",
		"writeToStream",
		"arraycopy",
		"toInt",
		"toInt",
		"error",
		"seek",
		"read",
		"toInt",
		"seek",
		"read",
		"arraycopy",
		"decodePackBits",
		"decode",
		"hasListeners",
		"notifyListeners",
		"seek",
		"read",
		"toInt",
		"toInt",
		"toInt",
		"getEntryValue",
		"getEntryValue",
		"error",
		"getEntryValue",
		"getEntryValue",
		"getEntryValue",
		"error",
		"getEntryValue",
		"error",
		"getEntryValue",
		"error",
		"getEntryValue",
		"getEntryValue",
		"error",
		"getEntryValue",
		"error",
		"error",
		"getEntryValue",
		"read",
		"toInt",
		"read",
		"parseEntries",
		"getGrayPalette",
		"error",
		"getRGBPalette",
		"error",
		"getColorMap",
		"error",
		"internal_new",
		"decodePixels",
		"error",
		"getRGBs",
		"formatColorMap",
		"error",
		"formatStrips",
		"writeHeader",
		"writeShort",
		"writeEntry",
		"writeEntry",
		"writeEntry",
		"writeEntry",
		"writeEntry",
		"writeEntry",
		"writeEntry",
		"writeEntry",
		"writeEntry",
		"writeEntry",
		"writeEntry",
		"writeEntry",
		"writeEntry",
		"writeInt",
		"writeShort",
		"writeInt",
		"writeInt",
		"writeInt",
		"writeInt",
		"writeShort",
		"write",
		"writeShort",
		"writeShort",
		"writeInt",
		"writeInt",
		"writeByte",
		"writeByte",
		"writeShort",
		"writeInt",
		"error",
		"error",
		"error",
		"error",
		"write",
		"TIFFModifiedHuffmanCodec",
		"ImageLoaderEvent",
		"RGB",
		"PaletteData",
		"RGB",
		"PaletteData",
		"PaletteData"
	],
	"methodsBody":{
		"void getEntryValue(int type, byte[] buffer, int index, int[] values) throws IOException":{
			"methodBody":"{\n    int start = index + 8;\n    int size;\n    int offset = toInt(buffer, start, TYPE_LONG);\n    switch(type) {\n        case TYPE_SHORT:\n            size = 2;\n            break;\n        case TYPE_LONG:\n            size = 4;\n            break;\n        case TYPE_RATIONAL:\n            size = 8;\n            break;\n        case TYPE_ASCII:\n        case TYPE_BYTE:\n            size = 1;\n            break;\n        default:\n            SWT.error(SWT.ERROR_UNSUPPORTED_FORMAT);\n            return;\n    }\n    if (values.length * size > 4) {\n        buffer = new byte[values.length * size];\n        file.seek(offset);\n        file.read(buffer);\n        start = 0;\n    }\n    for (int i = 0; i < values.length; i++) {\n        values[i] = toInt(buffer, start + i * size, type);\n    }\n}",
			"comments":"",
			"methodName":"void getEntryValue(int type, byte[] buffer, int index, int[] values) throws IOException"
		},
		"PaletteData getColorMap() throws IOException":{
			"methodBody":"{\n    int numColors = 1 << bitsPerSample[0];\n    \n    int numBytes = 3 * 2 * numColors;\n    byte[] buffer = new byte[numBytes];\n    file.seek(colorMapOffset);\n    file.read(buffer);\n    RGB[] colors = new RGB[numColors];\n    \n    int offset = isLittleEndian ? 1 : 0;\n    int startG = 2 * numColors;\n    int startB = startG + 2 * numColors;\n    for (int i = 0; i < numColors; i++) {\n        int r = buffer[offset] & 0xFF;\n        int g = buffer[startG + offset] & 0xFF;\n        int b = buffer[startB + offset] & 0xFF;\n        colors[i] = new RGB(r, g, b);\n        offset += 2;\n    }\n    return new PaletteData(colors);\n}",
			"comments":"/* R, G, B entries are 16 bit wide (2 bytes) */\n/**\n* SWT does not support 16-bit depth color formats.\n* Convert the 16-bit data to 8-bit data.\n* The correct way to do this is to multiply each\n* 16 bit value by the value:\n* (2^8 - 1) / (2^16 - 1).\n* The fast way to do this is just to drop the low\n* byte of the 16-bit value.\n*/\n",
			"methodName":"PaletteData getColorMap() throws IOException"
		},
		"void writeHeader() throws IOException":{
			"methodBody":"{\n    \n    out.writeByte((byte) 0x49);\n    out.writeByte((byte) 0x49);\n    \n    out.writeShort(42);\n    \n    out.writeInt(8);\n}",
			"comments":"/* little endian */\n/* TIFF identifier */\n/*\n* Offset of the first IFD is chosen to be 8.\n* It is word aligned and immediately after this header.\n*/\n",
			"methodName":"void writeHeader() throws IOException"
		},
		"PaletteData getGrayPalette()":{
			"methodBody":"{\n    int numColors = 1 << bitsPerSample[0];\n    RGB[] rgbs = new RGB[numColors];\n    for (int i = 0; i < numColors; i++) {\n        int value = i * 0xFF / (numColors - 1);\n        if (photometricInterpretation == 0)\n            value = 0xFF - value;\n        rgbs[i] = new RGB(value, value, value);\n    }\n    return new PaletteData(rgbs);\n}",
			"comments":"",
			"methodName":"PaletteData getGrayPalette()"
		},
		"int toInt(byte[] buffer, int i, int type)":{
			"methodBody":"{\n    if (type == TYPE_LONG) {\n        return isLittleEndian ? (buffer[i] & 0xFF) | ((buffer[i + 1] & 0xFF) << 8) | ((buffer[i + 2] & 0xFF) << 16) | ((buffer[i + 3] & 0xFF) << 24) : (buffer[i + 3] & 0xFF) | ((buffer[i + 2] & 0xFF) << 8) | ((buffer[i + 1] & 0xFF) << 16) | ((buffer[i] & 0xFF) << 24);\n    }\n    if (type == TYPE_SHORT) {\n        return isLittleEndian ? (buffer[i] & 0xFF) | ((buffer[i + 1] & 0xFF) << 8) : (buffer[i + 1] & 0xFF) | ((buffer[i] & 0xFF) << 8);\n    }\n    \n    SWT.error(SWT.ERROR_INVALID_IMAGE);\n    return -1;\n}",
			"comments":"/* Invalid type */\n",
			"methodName":"int toInt(byte[] buffer, int i, int type)"
		},
		"int formatStrips(int rowByteSize, int nbrRows, byte[] data, int maxStripByteSize, int offsetPostIFD, int extraBytes, int[][] strips)":{
			"methodBody":"{\n    \n    int n, nbrRowsPerStrip;\n    if (rowByteSize > maxStripByteSize) {\n        \n        n = data.length / rowByteSize;\n        nbrRowsPerStrip = 1;\n    } else {\n        int nbr = (data.length + maxStripByteSize - 1) / maxStripByteSize;\n        nbrRowsPerStrip = nbrRows / nbr;\n        n = (nbrRows + nbrRowsPerStrip - 1) / nbrRowsPerStrip;\n    }\n    int stripByteSize = rowByteSize * nbrRowsPerStrip;\n    int[] offsets = new int[n];\n    int[] counts = new int[n];\n    \n    int postIFDData = n == 1 ? 0 : n * 2 * 4;\n    int startOffset = offsetPostIFD + extraBytes + postIFDData;\n    \n    int offset = startOffset;\n    for (int i = 0; i < n; i++) {\n        \n        offsets[i] = offset;\n        counts[i] = stripByteSize;\n        offset += stripByteSize;\n    }\n    \n    int mod = data.length % stripByteSize;\n    if (mod != 0)\n        counts[counts.length - 1] = mod;\n    strips[0] = offsets;\n    strips[1] = counts;\n    return nbrRowsPerStrip;\n}",
			"comments":"/*\n* Calculate the nbr of required strips given the following requirements:\n* - each strip should, if possible, not be greater than maxStripByteSize\n* - each strip should contain 1 or more entire rows\n*\n* Format the strip fields arrays so that the image data is stored in one\n* contiguous block. This block is stored after the IFD and after any tag\n* info described in the IFD.\n*/\n/* Each strip contains 1 row */\n/*\n* Nbr of bytes between the end of the IFD directory and the start of\n* the image data. Keep space for at least the offsets and counts\n* data, each field being TYPE_LONG (4 bytes). If other tags require\n* space between the IFD and the image block, use the extraBytes\n* parameter.\n* If there is only one strip, the offsets and counts data is stored\n* directly in the IFD and we need not reserve space for it.\n*/\n/* offset of image data */\n/*\n* Store all strips sequentially to allow us\n* to copy all pixels in one contiguous area.\n*/\n/* The last strip may contain fewer rows */\n",
			"methodName":"int formatStrips(int rowByteSize, int nbrRows, byte[] data, int maxStripByteSize, int offsetPostIFD, int extraBytes, int[][] strips)"
		},
		"PaletteData getRGBPalette(int bitsR, int bitsG, int bitsB)":{
			"methodBody":"{\n    int blueMask = 0;\n    for (int i = 0; i < bitsB; i++) {\n        blueMask |= 1 << i;\n    }\n    int greenMask = 0;\n    for (int i = bitsB; i < bitsB + bitsG; i++) {\n        greenMask |= 1 << i;\n    }\n    int redMask = 0;\n    for (int i = bitsB + bitsG; i < bitsB + bitsG + bitsR; i++) {\n        redMask |= 1 << i;\n    }\n    return new PaletteData(redMask, greenMask, blueMask);\n}",
			"comments":"",
			"methodName":"PaletteData getRGBPalette(int bitsR, int bitsG, int bitsB)"
		},
		"void decodePixels(ImageData image) throws IOException":{
			"methodBody":"{\n    \n    byte[] imageData = new byte[(imageWidth * depth + 7) / 8 * imageLength];\n    image.data = imageData;\n    int destIndex = 0;\n    int length = stripOffsets.length;\n    for (int i = 0; i < length; i++) {\n        \n        byte[] data = new byte[stripByteCounts[i]];\n        file.seek(stripOffsets[i]);\n        file.read(data);\n        if (compression == COMPRESSION_NONE) {\n            System.arraycopy(data, 0, imageData, destIndex, data.length);\n            destIndex += data.length;\n        } else if (compression == COMPRESSION_PACKBITS) {\n            destIndex += decodePackBits(data, imageData, destIndex);\n        } else if (compression == COMPRESSION_CCITT_3_1 || compression == 3) {\n            TIFFModifiedHuffmanCodec codec = new TIFFModifiedHuffmanCodec();\n            int nRows = rowsPerStrip;\n            if (i == length - 1) {\n                int n = imageLength % rowsPerStrip;\n                if (n != 0)\n                    nRows = n;\n            }\n            destIndex += codec.decode(data, imageData, destIndex, imageWidth, nRows);\n        }\n        if (loader.hasListeners()) {\n            loader.notifyListeners(new ImageLoaderEvent(loader, image, i, i == length - 1));\n        }\n    }\n}",
			"comments":"/* Each row is byte aligned */\n/* Read a strip */\n",
			"methodName":"void decodePixels(ImageData image) throws IOException"
		},
		"public ImageData read() throws IOException":{
			"methodBody":"{\n    \n    bitsPerSample = new int[] { 1 };\n    colorMapOffset = NO_VALUE;\n    compression = 1;\n    imageLength = NO_VALUE;\n    imageWidth = NO_VALUE;\n    photometricInterpretation = NO_VALUE;\n    rowsPerStrip = Integer.MAX_VALUE;\n    samplesPerPixel = 1;\n    stripByteCounts = null;\n    stripOffsets = null;\n    byte[] buffer = new byte[2];\n    file.read(buffer);\n    int numberEntries = toInt(buffer, 0, TYPE_SHORT);\n    buffer = new byte[IFD_ENTRY_SIZE * numberEntries];\n    file.read(buffer);\n    parseEntries(buffer);\n    PaletteData palette = null;\n    depth = 0;\n    switch(photometricInterpretation) {\n        case 0:\n        case 1:\n            {\n                \n                palette = getGrayPalette();\n                depth = bitsPerSample[0];\n                break;\n            }\n        case 2:\n            {\n                \n                if (colorMapOffset != NO_VALUE)\n                    SWT.error(SWT.ERROR_INVALID_IMAGE);\n                \n                palette = getRGBPalette(bitsPerSample[0], bitsPerSample[1], bitsPerSample[2]);\n                depth = bitsPerSample[0] + bitsPerSample[1] + bitsPerSample[2];\n                break;\n            }\n        case 3:\n            {\n                \n                if (colorMapOffset == NO_VALUE)\n                    SWT.error(SWT.ERROR_INVALID_IMAGE);\n                palette = getColorMap();\n                depth = bitsPerSample[0];\n                break;\n            }\n        default:\n            {\n                SWT.error(SWT.ERROR_INVALID_IMAGE);\n            }\n    }\n    ImageData image = ImageData.internal_new(imageWidth, imageLength, depth, palette, 1, null, 0, null, null, -1, -1, SWT.IMAGE_TIFF, 0, 0, 0, 0);\n    decodePixels(image);\n    return image;\n}",
			"comments":"/* Set TIFF default values */\n/* Bilevel or Grayscale image */\n/* RGB image */\n/* SamplesPerPixel 3 is the only value supported */\n/* Palette Color image */\n",
			"methodName":"public ImageData read() throws IOException"
		},
		"int[] formatColorMap(RGB[] rgbs)":{
			"methodBody":"{\n    \n    int[] colorMap = new int[rgbs.length * 3];\n    int offsetGreen = rgbs.length;\n    int offsetBlue = rgbs.length * 2;\n    for (int i = 0; i < rgbs.length; i++) {\n        colorMap[i] = rgbs[i].red << 8 | rgbs[i].red;\n        colorMap[i + offsetGreen] = rgbs[i].green << 8 | rgbs[i].green;\n        colorMap[i + offsetBlue] = rgbs[i].blue << 8 | rgbs[i].blue;\n    }\n    return colorMap;\n}",
			"comments":"/*\n* In a TIFF ColorMap, all red come first, followed by\n* green and blue. All values must be converted from\n* 8 bit to 16 bit.\n*/\n",
			"methodName":"int[] formatColorMap(RGB[] rgbs)"
		},
		"void parseEntries(byte[] buffer) throws IOException":{
			"methodBody":"{\n    for (int offset = 0; offset < buffer.length; offset += IFD_ENTRY_SIZE) {\n        int tag = toInt(buffer, offset, TYPE_SHORT);\n        int type = toInt(buffer, offset + 2, TYPE_SHORT);\n        int count = toInt(buffer, offset + 4, TYPE_LONG);\n        switch(tag) {\n            case TAG_ImageWidth:\n                {\n                    imageWidth = getEntryValue(type, buffer, offset);\n                    break;\n                }\n            case TAG_ImageLength:\n                {\n                    imageLength = getEntryValue(type, buffer, offset);\n                    break;\n                }\n            case TAG_BitsPerSample:\n                {\n                    if (type != TYPE_SHORT)\n                        SWT.error(SWT.ERROR_INVALID_IMAGE);\n                    bitsPerSample = new int[count];\n                    getEntryValue(type, buffer, offset, bitsPerSample);\n                    break;\n                }\n            case TAG_Compression:\n                {\n                    compression = getEntryValue(type, buffer, offset);\n                    break;\n                }\n            case TAG_PhotometricInterpretation:\n                {\n                    photometricInterpretation = getEntryValue(type, buffer, offset);\n                    break;\n                }\n            case TAG_StripOffsets:\n                {\n                    if (type != TYPE_LONG && type != TYPE_SHORT)\n                        SWT.error(SWT.ERROR_INVALID_IMAGE);\n                    stripOffsets = new int[count];\n                    getEntryValue(type, buffer, offset, stripOffsets);\n                    break;\n                }\n            case TAG_SamplesPerPixel:\n                {\n                    if (type != TYPE_SHORT)\n                        SWT.error(SWT.ERROR_INVALID_IMAGE);\n                    samplesPerPixel = getEntryValue(type, buffer, offset);\n                    \n                    if (samplesPerPixel != 1 && samplesPerPixel != 3)\n                        SWT.error(SWT.ERROR_UNSUPPORTED_DEPTH);\n                    break;\n                }\n            case TAG_RowsPerStrip:\n                {\n                    rowsPerStrip = getEntryValue(type, buffer, offset);\n                    break;\n                }\n            case TAG_StripByteCounts:\n                {\n                    stripByteCounts = new int[count];\n                    getEntryValue(type, buffer, offset, stripByteCounts);\n                    break;\n                }\n            case TAG_XResolution:\n                {\n                    \n                    break;\n                }\n            case TAG_YResolution:\n                {\n                    \n                    break;\n                }\n            case TAG_T4Options:\n                {\n                    if (type != TYPE_LONG)\n                        SWT.error(SWT.ERROR_INVALID_IMAGE);\n                    t4Options = getEntryValue(type, buffer, offset);\n                    if ((t4Options & 0x1) == 1) {\n                        \n                        SWT.error(SWT.ERROR_UNSUPPORTED_FORMAT);\n                    }\n                    break;\n                }\n            case TAG_ResolutionUnit:\n                {\n                    \n                    break;\n                }\n            case TAG_ColorMap:\n                {\n                    if (type != TYPE_SHORT)\n                        SWT.error(SWT.ERROR_INVALID_IMAGE);\n                    \n                    colorMapOffset = getEntryValue(TYPE_LONG, buffer, offset);\n                    break;\n                }\n        }\n    }\n}",
			"comments":"/* Only the basic 1 and 3 values are supported */\n/* Ignored */\n/* Ignored */\n/* 2-dimensional coding is not supported */\n/* Ignored */\n/* Get the offset of the colorMap (use TYPE_LONG) */\n",
			"methodName":"void parseEntries(byte[] buffer) throws IOException"
		},
		"void write(int photometricInterpretation) throws IOException":{
			"methodBody":"{\n    boolean isRGB = photometricInterpretation == 2;\n    boolean isColorMap = photometricInterpretation == 3;\n    boolean isBiLevel = photometricInterpretation == 0 || photometricInterpretation == 1;\n    int imageWidth = image.width;\n    int imageLength = image.height;\n    int rowByteSize = image.bytesPerLine;\n    int numberEntries = isBiLevel ? 9 : 11;\n    int lengthDirectory = 2 + 12 * numberEntries + 4;\n    \n    int nextOffset = 8 + lengthDirectory;\n    \n    int extraBytes = 16;\n    int[] colorMap = null;\n    if (isColorMap) {\n        PaletteData palette = image.palette;\n        RGB[] rgbs = palette.getRGBs();\n        colorMap = formatColorMap(rgbs);\n        \n        if (colorMap.length != 3 * 1 << image.depth)\n            SWT.error(SWT.ERROR_UNSUPPORTED_FORMAT);\n        \n        extraBytes += colorMap.length * 2;\n    }\n    if (isRGB) {\n        \n        extraBytes += 6;\n    }\n    \n    byte[] data = image.data;\n    int[][] strips = new int[2][];\n    int nbrRowsPerStrip = formatStrips(rowByteSize, imageLength, data, 8192, nextOffset, extraBytes, strips);\n    int[] stripOffsets = strips[0];\n    int[] stripByteCounts = strips[1];\n    int bitsPerSampleOffset = NO_VALUE;\n    if (isRGB) {\n        bitsPerSampleOffset = nextOffset;\n        nextOffset += 6;\n    }\n    int stripOffsetsOffset = NO_VALUE, stripByteCountsOffset = NO_VALUE;\n    int xResolutionOffset, yResolutionOffset, colorMapOffset = NO_VALUE;\n    int cnt = stripOffsets.length;\n    if (cnt > 1) {\n        stripOffsetsOffset = nextOffset;\n        nextOffset += 4 * cnt;\n        stripByteCountsOffset = nextOffset;\n        nextOffset += 4 * cnt;\n    }\n    xResolutionOffset = nextOffset;\n    nextOffset += 8;\n    yResolutionOffset = nextOffset;\n    nextOffset += 8;\n    if (isColorMap) {\n        colorMapOffset = nextOffset;\n        nextOffset += colorMap.length * 2;\n    }\n    \n    writeHeader();\n    \n    out.writeShort(numberEntries);\n    writeEntry(TAG_ImageWidth, TYPE_LONG, 1, imageWidth);\n    writeEntry(TAG_ImageLength, TYPE_LONG, 1, imageLength);\n    if (isColorMap)\n        writeEntry(TAG_BitsPerSample, TYPE_SHORT, 1, image.depth);\n    if (isRGB)\n        writeEntry(TAG_BitsPerSample, TYPE_SHORT, 3, bitsPerSampleOffset);\n    writeEntry(TAG_Compression, TYPE_SHORT, 1, COMPRESSION_NONE);\n    writeEntry(TAG_PhotometricInterpretation, TYPE_SHORT, 1, photometricInterpretation);\n    writeEntry(TAG_StripOffsets, TYPE_LONG, cnt, cnt > 1 ? stripOffsetsOffset : stripOffsets[0]);\n    if (isRGB)\n        writeEntry(TAG_SamplesPerPixel, TYPE_SHORT, 1, 3);\n    writeEntry(TAG_RowsPerStrip, TYPE_LONG, 1, nbrRowsPerStrip);\n    writeEntry(TAG_StripByteCounts, TYPE_LONG, cnt, cnt > 1 ? stripByteCountsOffset : stripByteCounts[0]);\n    writeEntry(TAG_XResolution, TYPE_RATIONAL, 1, xResolutionOffset);\n    writeEntry(TAG_YResolution, TYPE_RATIONAL, 1, yResolutionOffset);\n    if (isColorMap)\n        writeEntry(TAG_ColorMap, TYPE_SHORT, colorMap.length, colorMapOffset);\n    \n    out.writeInt(0);\n    \n    if (isRGB)\n        for (int i = 0; i < 3; i++) out.writeShort(8);\n    if (cnt > 1) {\n        for (int i = 0; i < cnt; i++) out.writeInt(stripOffsets[i]);\n        for (int i = 0; i < cnt; i++) out.writeInt(stripByteCounts[i]);\n    }\n    \n    for (int i = 0; i < 2; i++) {\n        out.writeInt(300);\n        out.writeInt(1);\n    }\n    \n    if (isColorMap)\n        for (int i = 0; i < colorMap.length; i++) out.writeShort(colorMap[i]);\n    \n    out.write(data);\n}",
			"comments":"/* Offset following the header and the directory */\n/* Extra space used by XResolution and YResolution values */\n/* The number of entries of the Color Map must match the bitsPerSample field */\n/* Extra space used by ColorMap values */\n/* Extra space used by BitsPerSample values */\n/* TIFF recommends storing the data in strips of no more than 8 Ko */\n/* TIFF header */\n/* Image File Directory */\n/* Offset of next IFD (0 for last IFD) */\n/* Values longer than 4 bytes Section */\n/* BitsPerSample 8,8,8 */\n/* XResolution and YResolution set to 300 dpi */\n/* ColorMap */\n/* Image Data */\n",
			"methodName":"void write(int photometricInterpretation) throws IOException"
		},
		"int decodePackBits(byte[] src, byte[] dest, int offsetDest)":{
			"methodBody":"{\n    int destIndex = offsetDest;\n    int srcIndex = 0;\n    while (srcIndex < src.length) {\n        byte n = src[srcIndex];\n        if (0 <= n && n <= 127) {\n            \n            System.arraycopy(src, ++srcIndex, dest, destIndex, n + 1);\n            srcIndex += n + 1;\n            destIndex += n + 1;\n        } else if (-127 <= n && n <= -1) {\n            \n            byte value = src[++srcIndex];\n            for (int j = 0; j < -n + 1; j++) {\n                dest[destIndex++] = value;\n            }\n            srcIndex++;\n        } else {\n            \n            srcIndex++;\n        }\n    }\n    \n    return destIndex - offsetDest;\n}",
			"comments":"/* PackBits decoder */\n/* Copy next n+1 bytes literally */\n/* Copy next byte -n+1 times */\n/* Noop when n == -128 */\n/* Number of bytes copied */\n",
			"methodName":"int decodePackBits(byte[] src, byte[] dest, int offsetDest)"
		},
		"int getEntryValue(int type, byte[] buffer, int index)":{
			"methodBody":"{\n    return toInt(buffer, index + 8, type);\n}",
			"comments":"",
			"methodName":"int getEntryValue(int type, byte[] buffer, int index)"
		},
		"void writeToStream(LEDataOutputStream byteStream) throws IOException":{
			"methodBody":"{\n    out = byteStream;\n    int photometricInterpretation = -1;\n    \n    if (image.scanlinePad != 1)\n        SWT.error(SWT.ERROR_UNSUPPORTED_FORMAT);\n    switch(image.depth) {\n        case 1:\n            {\n                \n                PaletteData palette = image.palette;\n                RGB[] rgbs = palette.colors;\n                if (palette.isDirect || rgbs == null || rgbs.length != 2)\n                    SWT.error(SWT.ERROR_UNSUPPORTED_FORMAT);\n                RGB rgb0 = rgbs[0];\n                RGB rgb1 = rgbs[1];\n                if (!(rgb0.red == rgb0.green && rgb0.green == rgb0.blue && rgb1.red == rgb1.green && rgb1.green == rgb1.blue && ((rgb0.red == 0x0 && rgb1.red == 0xFF) || (rgb0.red == 0xFF && rgb1.red == 0x0)))) {\n                    SWT.error(SWT.ERROR_UNSUPPORTED_FORMAT);\n                }\n                \n                photometricInterpretation = image.palette.colors[0].red == 0xFF ? 0 : 1;\n                break;\n            }\n        case 4:\n        case 8:\n            {\n                photometricInterpretation = 3;\n                break;\n            }\n        case 24:\n            {\n                photometricInterpretation = 2;\n                break;\n            }\n        default:\n            {\n                SWT.error(SWT.ERROR_UNSUPPORTED_FORMAT);\n            }\n    }\n    write(photometricInterpretation);\n}",
			"comments":"/* Scanline pad must be 1 */\n/* Palette must be black and white or white and black */\n/* 0 means a color index of 0 is imaged as white */\n",
			"methodName":"void writeToStream(LEDataOutputStream byteStream) throws IOException"
		},
		"void writeEntry(short tag, int type, int count, int value) throws IOException":{
			"methodBody":"{\n    out.writeShort(tag);\n    out.writeShort(type);\n    out.writeInt(count);\n    out.writeInt(value);\n}",
			"comments":"",
			"methodName":"void writeEntry(short tag, int type, int count, int value) throws IOException"
		}
	},
	"ClassORInterfaceName":[
		"TIFFDirectory"
	]
}
