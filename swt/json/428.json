{
	"variables":[
		"name",
		"command",
		"iconName",
		"key",
		"phkResult",
		"lpcbData",
		"lpData",
		"result",
		"extensions",
		"lpName",
		"lpcName",
		"ft",
		"dwIndex",
		"count",
		"extension",
		"newExtensions",
		"newExtension",
		"key",
		"phkResult",
		"result",
		"lpcbData",
		"length",
		"lpData",
		"lpDst",
		"name",
		"DEFAULT_COMMAND",
		"defaultCommand",
		"COMMAND",
		"command",
		"DEFAULT_ICON",
		"iconName",
		"program",
		"programs",
		"lpName",
		"lpcName",
		"ft",
		"dwIndex",
		"count",
		"path",
		"program",
		"newPrograms",
		"newPrograms",
		"hHeap",
		"buffer",
		"byteCount",
		"lpFile",
		"info",
		"result",
		"quote",
		"prefix",
		"suffix",
		"index",
		"count",
		"i",
		"length",
		"nIconIndex",
		"fileName",
		"index",
		"iconIndex",
		"lpszFile",
		"phiconSmall",
		"phiconLarge",
		"image",
		"imageData",
		"program",
		"extension",
		"SWT",
		"SWT",
		"extension",
		"extension",
		"extension",
		"extension",
		"extension",
		"OS",
		"OS",
		"key",
		"OS",
		"phkResult",
		"lpcbData",
		"OS",
		"phkResult",
		"lpData",
		"lpcbData",
		"OS",
		"phkResult",
		"result",
		"lpData",
		"lpData",
		"lpName",
		"OS",
		"OS",
		"dwIndex",
		"lpName",
		"lpcName",
		"ft",
		"OS",
		"lpName",
		"lpcName",
		"lpcName",
		"lpName",
		"extension",
		"extension",
		"count",
		"extensions",
		"extensions",
		"System",
		"extensions",
		"newExtensions",
		"extensions",
		"extensions",
		"newExtensions",
		"extensions",
		"count",
		"extension",
		"dwIndex",
		"count",
		"extensions",
		"count",
		"System",
		"extensions",
		"newExtension",
		"count",
		"extensions",
		"newExtension",
		"extensions",
		"string",
		"OS",
		"OS",
		"key",
		"OS",
		"phkResult",
		"OS",
		"phkResult",
		"lpcbData",
		"result",
		"lpcbData",
		"TCHAR",
		"length",
		"length",
		"OS",
		"phkResult",
		"lpData",
		"lpcbData",
		"OS",
		"expand",
		"length",
		"OS",
		"lpData",
		"length",
		"length",
		"OS",
		"lpData",
		"lpDst",
		"length",
		"result",
		"lpDst",
		"Math",
		"length",
		"length",
		"Math",
		"lpData",
		"result",
		"lpData",
		"length",
		"phkResult",
		"OS",
		"phkResult",
		"result",
		"key",
		"name",
		"name",
		"name",
		"key",
		"key",
		"DEFAULT_COMMAND",
		"defaultCommand",
		"defaultCommand",
		"defaultCommand",
		"defaultCommand",
		"key",
		"COMMAND",
		"command",
		"command",
		"key",
		"DEFAULT_ICON",
		"iconName",
		"iconName",
		"program",
		"name",
		"program",
		"command",
		"program",
		"iconName",
		"program",
		"lpName",
		"OS",
		"OS",
		"dwIndex",
		"lpName",
		"lpcName",
		"ft",
		"OS",
		"lpName",
		"lpcName",
		"lpcName",
		"lpName",
		"path",
		"program",
		"count",
		"programs",
		"programs",
		"System",
		"programs",
		"newPrograms",
		"programs",
		"programs",
		"newPrograms",
		"programs",
		"count",
		"program",
		"dwIndex",
		"count",
		"programs",
		"count",
		"System",
		"programs",
		"newPrograms",
		"count",
		"programs",
		"newPrograms",
		"programs",
		"fileName",
		"SWT",
		"SWT",
		"OS",
		"fileName",
		"buffer",
		"TCHAR",
		"OS",
		"hHeap",
		"OS",
		"byteCount",
		"OS",
		"lpFile",
		"buffer",
		"byteCount",
		"info",
		"SHELLEXECUTEINFO",
		"info",
		"lpFile",
		"info",
		"OS",
		"OS",
		"info",
		"lpFile",
		"OS",
		"hHeap",
		"lpFile",
		"result",
		"fileName",
		"SWT",
		"SWT",
		"command",
		"command",
		"index",
		"index",
		"command",
		"i",
		"length",
		"command",
		"i",
		"count",
		"i",
		"quote",
		"count",
		"prefix",
		"command",
		"index",
		"suffix",
		"command",
		"index",
		"length",
		"quote",
		"fileName",
		"fileName",
		"Compatibility",
		"prefix",
		"fileName",
		"suffix",
		"iconName",
		"iconName",
		"index",
		"fileName",
		"iconName",
		"index",
		"iconName",
		"index",
		"iconName",
		"nIconIndex",
		"Integer",
		"iconIndex",
		"fileName",
		"OS",
		"lpszFile",
		"nIconIndex",
		"phiconLarge",
		"phiconSmall",
		"phiconSmall",
		"Image",
		"SWT",
		"phiconSmall",
		"image",
		"image",
		"imageData",
		"name",
		"other",
		"other",
		"other",
		"name",
		"program",
		"command",
		"program",
		"iconName",
		"program",
		"name",
		"command",
		"iconName",
		"name",
		"ERROR_NULL_ARGUMENT",
		"HKEY_CLASSES_ROOT",
		"KEY_READ",
		"HKEY_CLASSES_ROOT",
		"ERROR_NO_MORE_ITEMS",
		"length",
		"length",
		"length",
		"length",
		"HKEY_CLASSES_ROOT",
		"KEY_READ",
		"sizeof",
		"IsWinCE",
		"name",
		"command",
		"iconName",
		"HKEY_CLASSES_ROOT",
		"ERROR_NO_MORE_ITEMS",
		"length",
		"length",
		"length",
		"length",
		"ERROR_NULL_ARGUMENT",
		"sizeof",
		"HEAP_ZERO_MEMORY",
		"cbSize",
		"sizeof",
		"lpFile",
		"nShow",
		"SW_SHOW",
		"ERROR_NULL_ARGUMENT",
		"ICON",
		"name",
		"command",
		"iconName",
		"extension",
		"string",
		"expand",
		"key",
		"fileName",
		"fileName",
		"e",
		"e",
		"other"
	],
	"extendORImplementFiles":[],
	"package":[
		"org.eclipse.swt.program"
	],
	"import":[
		"org.eclipse.swt.internal",
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt",
		"org.eclipse.swt.graphics",
		"java.io.IOException"
	],
	"methods":[
		"findProgram",
		"getExtensions",
		"getKeyValue",
		"getProgram",
		"getPrograms",
		"launch",
		"execute",
		"getImageData",
		"getName",
		"equals",
		"hashCode",
		"toString",
		"error",
		"length",
		"charAt",
		"RegOpenKeyEx",
		"RegQueryValueEx",
		"RegCloseKey",
		"getProgram",
		"toString",
		"strlen",
		"length",
		"RegEnumKeyEx",
		"toString",
		"length",
		"length",
		"charAt",
		"arraycopy",
		"arraycopy",
		"RegOpenKeyEx",
		"RegQueryValueEx",
		"RegQueryValueEx",
		"ExpandEnvironmentStrings",
		"ExpandEnvironmentStrings",
		"toString",
		"max",
		"max",
		"length",
		"toString",
		"RegCloseKey",
		"getKeyValue",
		"length",
		"getKeyValue",
		"length",
		"getKeyValue",
		"length",
		"getKeyValue",
		"length",
		"length",
		"RegEnumKeyEx",
		"toString",
		"length",
		"getProgram",
		"arraycopy",
		"arraycopy",
		"error",
		"GetProcessHeap",
		"length",
		"HeapAlloc",
		"MoveMemory",
		"ShellExecuteEx",
		"HeapFree",
		"error",
		"indexOf",
		"length",
		"charAt",
		"substring",
		"substring",
		"exec",
		"indexOf",
		"substring",
		"trim",
		"substring",
		"length",
		"parseInt",
		"ExtractIconEx",
		"win32_new",
		"getImageData",
		"dispose",
		"equals",
		"equals",
		"equals",
		"hashCode",
		"hashCode",
		"hashCode",
		"TCHAR",
		"TCHAR",
		"TCHAR",
		"FILETIME",
		"TCHAR",
		"TCHAR",
		"TCHAR",
		"Program",
		"TCHAR",
		"FILETIME",
		"TCHAR",
		"SHELLEXECUTEINFO",
		"TCHAR"
	],
	"methodsBody":{
		"public String toString()":{
			"methodBody":"{\n    \n    return \"Program {\" + name + \"}\";\n}",
			"comments":"/**\n* Returns a string containing a concise, human-readable\n* description of the receiver.\n*\n* @return a string representation of the event\n*/\n//$NON-NLS-1$ //$NON-NLS-2$\n",
			"methodName":"public String toString()"
		},
		"public int hashCode()":{
			"methodBody":"{\n    return name.hashCode() ^ command.hashCode() ^ iconName.hashCode();\n}",
			"comments":"/**\n* Returns an integer hash code for the receiver. Any two\n* objects that return <code>true</code> when passed to\n* <code>equals</code> must return the same value for this\n* method.\n*\n* @return the receiver's hash\n*\n* @see #equals(Object)\n*/\n",
			"methodName":"public int hashCode()"
		},
		"public boolean execute(String fileName)":{
			"methodBody":"{\n    if (fileName == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    boolean quote = true;\n    \n    String prefix = command, suffix = \"\";\n    \n    int index = command.indexOf(\"%1\");\n    if (index != -1) {\n        int count = 0;\n        int i = index + 2, length = command.length();\n        while (i < length) {\n            if (command.charAt(i) == '\"')\n                count++;\n            i++;\n        }\n        quote = count % 2 == 0;\n        prefix = command.substring(0, index);\n        suffix = command.substring(index + 2, length);\n    }\n    \n    if (quote)\n        fileName = \" \\\"\" + fileName + \"\\\"\";\n    try {\n        Compatibility.exec(prefix + fileName + suffix);\n    } catch (IOException e) {\n        return false;\n    }\n    return true;\n}",
			"comments":"/**\n* Executes the program with the file as the single argument\n* in the operating system.  It is the responsibility of the\n* programmer to ensure that the file contains valid data for\n* this program.\n*\n* @param fileName the file or program name\n* @return <code>true</code> if the file is launched, otherwise <code>false</code>\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT when fileName is null</li>\n* </ul>\n*/\n//$NON-NLS-1$\n//$NON-NLS-1$\n//$NON-NLS-1$ //$NON-NLS-2$\n",
			"methodName":"public boolean execute(String fileName)"
		},
		"public boolean equals(Object other)":{
			"methodBody":"{\n    if (this == other)\n        return true;\n    if (other instanceof Program) {\n        final Program program = (Program) other;\n        return name.equals(program.name) && command.equals(program.command) && iconName.equals(program.iconName);\n    }\n    return false;\n}",
			"comments":"/**\n* Compares the argument to the receiver, and returns true\n* if they represent the <em>same</em> object using a class\n* specific comparison.\n*\n* @param other the object to compare with this object\n* @return <code>true</code> if the object is the same as this object and <code>false</code> otherwise\n*\n* @see #hashCode()\n*/\n",
			"methodName":"public boolean equals(Object other)"
		},
		"public static Program[] getPrograms()":{
			"methodBody":"{\n    Program[] programs = new Program[1024];\n    \n    TCHAR lpName = new TCHAR(0, 1024);\n    int[] lpcName = new int[] { lpName.length() };\n    FILETIME ft = new FILETIME();\n    int dwIndex = 0, count = 0;\n    while (OS.RegEnumKeyEx(OS.HKEY_CLASSES_ROOT, dwIndex, lpName, lpcName, null, null, null, ft) != OS.ERROR_NO_MORE_ITEMS) {\n        String path = lpName.toString(0, lpcName[0]);\n        lpcName[0] = lpName.length();\n        Program program = getProgram(path);\n        if (program != null) {\n            if (count == programs.length) {\n                Program[] newPrograms = new Program[programs.length + 1024];\n                System.arraycopy(programs, 0, newPrograms, 0, programs.length);\n                programs = newPrograms;\n            }\n            programs[count++] = program;\n        }\n        dwIndex++;\n    }\n    if (count != programs.length) {\n        Program[] newPrograms = new Program[count];\n        System.arraycopy(programs, 0, newPrograms, 0, count);\n        programs = newPrograms;\n    }\n    return programs;\n}",
			"comments":"/**\n* Answers all available programs in the operating system.  Note\n* that a <code>Display</code> must already exist to guarantee\n* that this method returns an appropriate result.\n*\n* @return an array of programs\n*/\n/* Use the character encoding for the default locale */\n",
			"methodName":"public static Program[] getPrograms()"
		},
		"public static Program findProgram(String extension)":{
			"methodBody":"{\n    if (extension == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (extension.length() == 0)\n        return null;\n    \n    if (extension.charAt(0) != '.')\n        extension = \".\" + extension;\n    \n    TCHAR key = new TCHAR(0, extension, true);\n    int[] phkResult = new int[1];\n    if (OS.RegOpenKeyEx(OS.HKEY_CLASSES_ROOT, key, 0, OS.KEY_READ, phkResult) != 0) {\n        return null;\n    }\n    int[] lpcbData = new int[] { 256 };\n    TCHAR lpData = new TCHAR(0, lpcbData[0]);\n    int result = OS.RegQueryValueEx(phkResult[0], null, 0, null, lpData, lpcbData);\n    OS.RegCloseKey(phkResult[0]);\n    if (result != 0)\n        return null;\n    return getProgram(lpData.toString(0, lpData.strlen()));\n}",
			"comments":"/**\n* Finds the program that is associated with an extension.\n* The extension may or may not begin with a '.'.  Note that\n* a <code>Display</code> must already exist to guarantee that\n* this method returns an appropriate result.\n*\n* @param extension the program extension\n* @return the program or <code>null</code>\n*\n* @exception IllegalArgumentException <ul>\n*\t\t<li>ERROR_NULL_ARGUMENT when extension is null</li>\n*\t</ul>\n*/\n//$NON-NLS-1$\n/* Use the character encoding for the default locale */\n",
			"methodName":"public static Program findProgram(String extension)"
		},
		"public ImageData getImageData()":{
			"methodBody":"{\n    int nIconIndex = 0;\n    String fileName = iconName;\n    int index = iconName.indexOf(',');\n    if (index != -1) {\n        fileName = iconName.substring(0, index);\n        String iconIndex = iconName.substring(index + 1, iconName.length()).trim();\n        try {\n            nIconIndex = Integer.parseInt(iconIndex);\n        } catch (NumberFormatException e) {\n        }\n    }\n    \n    TCHAR lpszFile = new TCHAR(0, fileName, true);\n    int[] phiconSmall = new int[1], phiconLarge = null;\n    OS.ExtractIconEx(lpszFile, nIconIndex, phiconLarge, phiconSmall, 1);\n    if (phiconSmall[0] == 0)\n        return null;\n    Image image = Image.win32_new(null, SWT.ICON, phiconSmall[0]);\n    ImageData imageData = image.getImageData();\n    image.dispose();\n    return imageData;\n}",
			"comments":"/**\n* Returns the receiver's image data.  This is the icon\n* that is associated with the reciever in the operating\n* system.\n*\n* @return the image data for the program, may be null\n*/\n/* Use the character encoding for the default locale */\n",
			"methodName":"public ImageData getImageData()"
		},
		"public String getName()":{
			"methodBody":"{\n    return name;\n}",
			"comments":"/**\n* Returns the receiver's name.  This is as short and\n* descriptive a name as possible for the program.  If\n* the program has no descriptive name, this string may\n* be the executable name, path or empty.\n*\n* @return the name of the program\n*/\n",
			"methodName":"public String getName()"
		},
		"public static String[] getExtensions()":{
			"methodBody":"{\n    String[] extensions = new String[1024];\n    \n    TCHAR lpName = new TCHAR(0, 1024);\n    int[] lpcName = new int[] { lpName.length() };\n    FILETIME ft = new FILETIME();\n    int dwIndex = 0, count = 0;\n    while (OS.RegEnumKeyEx(OS.HKEY_CLASSES_ROOT, dwIndex, lpName, lpcName, null, null, null, ft) != OS.ERROR_NO_MORE_ITEMS) {\n        String extension = lpName.toString(0, lpcName[0]);\n        lpcName[0] = lpName.length();\n        if (extension.length() > 0 && extension.charAt(0) == '.') {\n            if (count == extensions.length) {\n                String[] newExtensions = new String[extensions.length + 1024];\n                System.arraycopy(extensions, 0, newExtensions, 0, extensions.length);\n                extensions = newExtensions;\n            }\n            extensions[count++] = extension;\n        }\n        dwIndex++;\n    }\n    if (count != extensions.length) {\n        String[] newExtension = new String[count];\n        System.arraycopy(extensions, 0, newExtension, 0, count);\n        extensions = newExtension;\n    }\n    return extensions;\n}",
			"comments":"/**\n* Answer all program extensions in the operating system.  Note\n* that a <code>Display</code> must already exist to guarantee\n* that this method returns an appropriate result.\n*\n* @return an array of extensions\n*/\n/* Use the character encoding for the default locale */\n",
			"methodName":"public static String[] getExtensions()"
		},
		"static String getKeyValue(String string, boolean expand)":{
			"methodBody":"{\n    \n    TCHAR key = new TCHAR(0, string, true);\n    int[] phkResult = new int[1];\n    if (OS.RegOpenKeyEx(OS.HKEY_CLASSES_ROOT, key, 0, OS.KEY_READ, phkResult) != 0) {\n        return null;\n    }\n    String result = null;\n    int[] lpcbData = new int[1];\n    if (OS.RegQueryValueEx(phkResult[0], (TCHAR) null, 0, null, (TCHAR) null, lpcbData) == 0) {\n        result = \"\";\n        int length = lpcbData[0] / TCHAR.sizeof;\n        if (length != 0) {\n            \n            TCHAR lpData = new TCHAR(0, length);\n            if (OS.RegQueryValueEx(phkResult[0], null, 0, null, lpData, lpcbData) == 0) {\n                if (!OS.IsWinCE && expand) {\n                    length = OS.ExpandEnvironmentStrings(lpData, null, 0);\n                    if (length != 0) {\n                        TCHAR lpDst = new TCHAR(0, length);\n                        OS.ExpandEnvironmentStrings(lpData, lpDst, length);\n                        result = lpDst.toString(0, Math.max(0, length - 1));\n                    }\n                } else {\n                    length = Math.max(0, lpData.length() - 1);\n                    result = lpData.toString(0, length);\n                }\n            }\n        }\n    }\n    if (phkResult[0] != 0)\n        OS.RegCloseKey(phkResult[0]);\n    return result;\n}",
			"comments":"/* Use the character encoding for the default locale */\n/* Use the character encoding for the default locale */\n",
			"methodName":"static String getKeyValue(String string, boolean expand)"
		},
		"static Program getProgram(String key)":{
			"methodBody":"{\n    \n    String name = getKeyValue(key, false);\n    if (name == null || name.length() == 0) {\n        name = key;\n    }\n    \n    \n    String DEFAULT_COMMAND = \"\\\\shell\";\n    String defaultCommand = getKeyValue(key + DEFAULT_COMMAND, true);\n    \n    if (defaultCommand == null || defaultCommand.length() == 0)\n        defaultCommand = \"open\";\n    \n    String COMMAND = \"\\\\shell\\\\\" + defaultCommand + \"\\\\command\";\n    String command = getKeyValue(key + COMMAND, true);\n    if (command == null || command.length() == 0)\n        return null;\n    \n    \n    String DEFAULT_ICON = \"\\\\DefaultIcon\";\n    String iconName = getKeyValue(key + DEFAULT_ICON, true);\n    if (iconName == null || iconName.length() == 0)\n        return null;\n    Program program = new Program();\n    program.name = name;\n    program.command = command;\n    program.iconName = iconName;\n    return program;\n}",
			"comments":"/* Name */\n/* Command */\n//$NON-NLS-1$\n//$NON-NLS-1$\n//$NON-NLS-1$\n/* Icon */\n//$NON-NLS-1$\n",
			"methodName":"static Program getProgram(String key)"
		},
		"public static boolean launch(String fileName)":{
			"methodBody":"{\n    if (fileName == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    \n    int hHeap = OS.GetProcessHeap();\n    TCHAR buffer = new TCHAR(0, fileName, true);\n    int byteCount = buffer.length() * TCHAR.sizeof;\n    int lpFile = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, byteCount);\n    OS.MoveMemory(lpFile, buffer, byteCount);\n    SHELLEXECUTEINFO info = new SHELLEXECUTEINFO();\n    info.cbSize = SHELLEXECUTEINFO.sizeof;\n    info.lpFile = lpFile;\n    info.nShow = OS.SW_SHOW;\n    boolean result = OS.ShellExecuteEx(info);\n    if (lpFile != 0)\n        OS.HeapFree(hHeap, 0, lpFile);\n    return result;\n}",
			"comments":"/**\n* Launches the executable associated with the file in\n* the operating system.  If the file is an executable,\n* then the executable is launched.  Note that a <code>Display</code>\n* must already exist to guarantee that this method returns\n* an appropriate result.\n*\n* @param fileName the file or program name\n* @return <code>true</code> if the file is launched, otherwise <code>false</code>\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT when fileName is null</li>\n* </ul>\n*/\n/* Use the character encoding for the default locale */\n",
			"methodName":"public static boolean launch(String fileName)"
		}
	},
	"ClassORInterfaceName":[
		"Program"
	]
}
