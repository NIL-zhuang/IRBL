{
	"variables":[
		"horizontalBar",
		"verticalBar",
		"scrolledHandle",
		"rect",
		"bits1",
		"bits2",
		"nWidth",
		"nHeight",
		"bar",
		"rect",
		"scrolledHandle",
		"bits",
		"result",
		"result",
		"vertical",
		"horizontal",
		"msg",
		"value",
		"delta",
		"code",
		"count",
		"i",
		"vPosition",
		"hPosition",
		"code",
		"position",
		"event",
		"position",
		"event",
		"code",
		"result",
		"result",
		"type",
		"info",
		"code",
		"increment",
		"pageIncrement",
		"code",
		"parent",
		"style",
		"handle",
		"OS",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"OS",
		"rect",
		"x",
		"y",
		"x",
		"width",
		"y",
		"height",
		"OS",
		"scrolledHandle",
		"OS",
		"OS",
		"scrolledHandle",
		"OS",
		"OS",
		"rect",
		"bits1",
		"bits2",
		"horizontalBar",
		"rect",
		"OS",
		"OS",
		"verticalBar",
		"rect",
		"OS",
		"OS",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"nWidth",
		"nHeight",
		"type",
		"state",
		"CANVAS",
		"bar",
		"bar",
		"bar",
		"style",
		"SWT",
		"horizontalBar",
		"SWT",
		"style",
		"SWT",
		"verticalBar",
		"SWT",
		"OS",
		"scrolledHandle",
		"rect",
		"rect",
		"rect",
		"horizontalBar",
		"verticalBar",
		"horizontalBar",
		"horizontalBar",
		"verticalBar",
		"verticalBar",
		"horizontalBar",
		"verticalBar",
		"handle",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"bits",
		"display",
		"display",
		"wParam",
		"lParam",
		"result",
		"result",
		"horizontalBar",
		"lParam",
		"lParam",
		"handle",
		"horizontalBar",
		"state",
		"CANVAS",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"result",
		"wParam",
		"lParam",
		"result",
		"result",
		"state",
		"CANVAS",
		"wParam",
		"OS",
		"OS",
		"result",
		"verticalBar",
		"verticalBar",
		"horizontalBar",
		"horizontalBar",
		"vertical",
		"OS",
		"horizontal",
		"OS",
		"msg",
		"result",
		"OS",
		"OS",
		"value",
		"wParam",
		"value",
		"OS",
		"code",
		"delta",
		"OS",
		"OS",
		"count",
		"Math",
		"delta",
		"OS",
		"code",
		"delta",
		"OS",
		"OS",
		"delta",
		"Math",
		"delta",
		"delta",
		"OS",
		"result",
		"msg",
		"OS",
		"count",
		"value",
		"delta",
		"OS",
		"count",
		"delta",
		"OS",
		"i",
		"count",
		"i",
		"OS",
		"handle",
		"msg",
		"code",
		"LRESULT",
		"verticalBar",
		"verticalBar",
		"horizontalBar",
		"horizontalBar",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"verticalBar",
		"verticalBar",
		"position",
		"vPosition",
		"event",
		"position",
		"vPosition",
		"SWT",
		"SWT",
		"verticalBar",
		"SWT",
		"event",
		"horizontalBar",
		"horizontalBar",
		"position",
		"hPosition",
		"event",
		"position",
		"hPosition",
		"SWT",
		"SWT",
		"horizontalBar",
		"SWT",
		"event",
		"code",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"code",
		"LRESULT",
		"code",
		"wParam",
		"lParam",
		"result",
		"result",
		"verticalBar",
		"lParam",
		"lParam",
		"handle",
		"verticalBar",
		"state",
		"CANVAS",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"result",
		"update",
		"msg",
		"OS",
		"OS",
		"OS",
		"info",
		"SCROLLINFO",
		"info",
		"OS",
		"OS",
		"OS",
		"OS",
		"hwnd",
		"type",
		"info",
		"info",
		"OS",
		"wParam",
		"code",
		"OS",
		"OS",
		"OS",
		"info",
		"info",
		"OS",
		"info",
		"info",
		"OS",
		"info",
		"info",
		"OS",
		"info",
		"bar",
		"OS",
		"bar",
		"info",
		"Math",
		"info",
		"info",
		"increment",
		"OS",
		"info",
		"bar",
		"OS",
		"bar",
		"info",
		"Math",
		"info",
		"info",
		"pageIncrement",
		"OS",
		"hwnd",
		"type",
		"info",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"result",
		"code",
		"LRESULT",
		"code",
		"bar",
		"wParam",
		"lParam",
		"result",
		"GWL_STYLE",
		"GWL_EXSTYLE",
		"bottom",
		"SM_CYHSCROLL",
		"right",
		"SM_CXVSCROLL",
		"right",
		"left",
		"bottom",
		"top",
		"left",
		"top",
		"H_SCROLL",
		"H_SCROLL",
		"V_SCROLL",
		"V_SCROLL",
		"right",
		"bottom",
		"WS_TABSTOP",
		"H_SCROLL",
		"WS_HSCROLL",
		"V_SCROLL",
		"WS_VSCROLL",
		"windowClass",
		"windowProc",
		"WM_HSCROLL",
		"MK_SHIFT",
		"MK_CONTROL",
		"WM_VSCROLL",
		"WM_HSCROLL",
		"SPI_GETWHEELSCROLLLINES",
		"WHEEL_PAGESCROLL",
		"SB_PAGEDOWN",
		"SB_PAGEUP",
		"WHEEL_DELTA",
		"SB_LINEDOWN",
		"SB_LINEUP",
		"WHEEL_DELTA",
		"WM_VSCROLL",
		"WHEEL_DELTA",
		"WHEEL_DELTA",
		"ZERO",
		"WM_MOUSEWHEEL",
		"detail",
		"PAGE_UP",
		"PAGE_DOWN",
		"Selection",
		"detail",
		"PAGE_UP",
		"PAGE_DOWN",
		"Selection",
		"WM_SIZE",
		"ZERO",
		"WM_VSCROLL",
		"WM_HSCROLL",
		"SB_HORZ",
		"SB_VERT",
		"cbSize",
		"sizeof",
		"fMask",
		"SIF_TRACKPOS",
		"SIF_POS",
		"SIF_RANGE",
		"fMask",
		"SIF_POS",
		"SB_ENDSCROLL",
		"SB_THUMBPOSITION",
		"SB_THUMBTRACK",
		"nPos",
		"nTrackPos",
		"SB_TOP",
		"nPos",
		"nMin",
		"SB_BOTTOM",
		"nPos",
		"nMax",
		"SB_LINEDOWN",
		"nPos",
		"SB_LINEUP",
		"nPos",
		"nMin",
		"nPos",
		"SB_PAGEDOWN",
		"nPos",
		"SB_PAGEUP",
		"nPos",
		"nMin",
		"nPos",
		"ZERO",
		"parent",
		"style",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"x",
		"y",
		"width",
		"height",
		"type",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"bar",
		"update",
		"hwnd",
		"msg",
		"wParam",
		"lParam"
	],
	"extendORImplementFiles":[
		"Control"
	],
	"package":[
		"org.eclipse.swt.widgets"
	],
	"import":[
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt",
		"org.eclipse.swt.graphics"
	],
	"methods":[
		"callWindowProc",
		"computeTrim",
		"createScrollBar",
		"createWidget",
		"getClientArea",
		"getHorizontalBar",
		"getVerticalBar",
		"releaseWidget",
		"scrolledHandle",
		"widgetExtStyle",
		"widgetStyle",
		"windowClass",
		"windowProc",
		"WM_HSCROLL",
		"WM_MOUSEWHEEL",
		"WM_SIZE",
		"WM_VSCROLL",
		"wmScroll",
		"DefWindowProc",
		"checkWidget",
		"scrolledHandle",
		"SetRect",
		"GetWindowLong",
		"GetWindowLong",
		"AdjustWindowRectEx",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"setMaximum",
		"setThumb",
		"createWidget",
		"createScrollBar",
		"createScrollBar",
		"checkWidget",
		"forceResize",
		"scrolledHandle",
		"GetClientRect",
		"checkWidget",
		"checkWidget",
		"releaseResources",
		"releaseResources",
		"releaseWidget",
		"widgetExtStyle",
		"widgetStyle",
		"WM_HSCROLL",
		"wmScroll",
		"WM_MOUSEWHEEL",
		"getEnabled",
		"getEnabled",
		"SystemParametersInfo",
		"abs",
		"abs",
		"SendMessage",
		"getSelection",
		"getSelection",
		"callWindowProc",
		"getSelection",
		"sendEvent",
		"getSelection",
		"sendEvent",
		"callWindowProc",
		"WM_SIZE",
		"WM_VSCROLL",
		"wmScroll",
		"GetScrollInfo",
		"getIncrement",
		"getIncrement",
		"max",
		"getPageIncrement",
		"getPageIncrement",
		"max",
		"SetScrollInfo",
		"callWindowProc",
		"wmScrollChild",
		"RECT",
		"Rectangle",
		"ScrollBar",
		"RECT",
		"Rectangle",
		"Event",
		"Event",
		"LRESULT",
		"LRESULT",
		"SCROLLINFO",
		"LRESULT"
	],
	"methodsBody":{
		"int widgetExtStyle()":{
			"methodBody":"{\n    return super.widgetExtStyle();\n\n\n\n\n}",
			"comments":"/*\n* This code is intentionally commented.  In future,\n* we may wish to support different standard Windows\n* edge styles.  The issue here is that not all of\n* these styles are available on the other platforms\n* this would need to be a hint.\n*/\n//\tif ((style & SWT.BORDER) != 0) return OS.WS_EX_CLIENTEDGE;\n//\tif ((style & SWT.SHADOW_IN) != 0) return OS.WS_EX_STATICEDGE;\n//\treturn super.widgetExtStyle ();\n",
			"methodName":"int widgetExtStyle()"
		},
		"LRESULT wmScroll(ScrollBar bar, boolean update, int hwnd, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = null;\n    if (update) {\n        int type = msg == OS.WM_HSCROLL ? OS.SB_HORZ : OS.SB_VERT;\n        SCROLLINFO info = new SCROLLINFO();\n        info.cbSize = SCROLLINFO.sizeof;\n        info.fMask = OS.SIF_TRACKPOS | OS.SIF_POS | OS.SIF_RANGE;\n        OS.GetScrollInfo(hwnd, type, info);\n        info.fMask = OS.SIF_POS;\n        int code = wParam & 0xFFFF;\n        switch(code) {\n            case OS.SB_ENDSCROLL:\n                return null;\n            case OS.SB_THUMBPOSITION:\n            case OS.SB_THUMBTRACK:\n                \n                info.nPos = info.nTrackPos;\n                break;\n            case OS.SB_TOP:\n                info.nPos = info.nMin;\n                break;\n            case OS.SB_BOTTOM:\n                info.nPos = info.nMax;\n                break;\n            case OS.SB_LINEDOWN:\n                info.nPos += bar.getIncrement();\n                break;\n            case OS.SB_LINEUP:\n                int increment = bar.getIncrement();\n                info.nPos = Math.max(info.nMin, info.nPos - increment);\n                break;\n            case OS.SB_PAGEDOWN:\n                info.nPos += bar.getPageIncrement();\n                break;\n            case OS.SB_PAGEUP:\n                int pageIncrement = bar.getPageIncrement();\n                info.nPos = Math.max(info.nMin, info.nPos - pageIncrement);\n                break;\n        }\n        OS.SetScrollInfo(hwnd, type, info, true);\n    } else {\n        int code = callWindowProc(hwnd, msg, wParam, lParam);\n        result = code == 0 ? LRESULT.ZERO : new LRESULT(code);\n    }\n    bar.wmScrollChild(wParam, lParam);\n    return result;\n}",
			"comments":"/*\n* Note: On WinCE, the value in SB_THUMBPOSITION is relative to nMin.\n* Same for SB_THUMBPOSITION 'except' for the very first thumb track\n* message which has the actual value of nMin. This is a problem when\n* nMin is not zero.\n*/\n",
			"methodName":"LRESULT wmScroll(ScrollBar bar, boolean update, int hwnd, int msg, int wParam, int lParam)"
		},
		"TCHAR windowClass()":{
			"methodBody":"{\n    return display.windowClass;\n}",
			"comments":"",
			"methodName":"TCHAR windowClass()"
		},
		"LRESULT WM_SIZE(int wParam, int lParam)":{
			"methodBody":"{\n    int code = callWindowProc(handle, OS.WM_SIZE, wParam, lParam);\n    super.WM_SIZE(wParam, lParam);\n    \n    if (code == 0)\n        return LRESULT.ZERO;\n    return new LRESULT(code);\n}",
			"comments":"// widget may be disposed at this point\n",
			"methodName":"LRESULT WM_SIZE(int wParam, int lParam)"
		},
		"ScrollBar createScrollBar(int type)":{
			"methodBody":"{\n    ScrollBar bar = new ScrollBar(this, type);\n    if ((state & CANVAS) != 0) {\n        bar.setMaximum(100);\n        bar.setThumb(10);\n    }\n    return bar;\n}",
			"comments":"",
			"methodName":"ScrollBar createScrollBar(int type)"
		},
		"public ScrollBar getVerticalBar()":{
			"methodBody":"{\n    checkWidget();\n    return verticalBar;\n}",
			"comments":"/**\n* Returns the receiver's vertical scroll bar if it has\n* one, and null if it does not.\n*\n* @return the vertical scroll bar (or null)\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public ScrollBar getVerticalBar()"
		},
		"public ScrollBar getHorizontalBar()":{
			"methodBody":"{\n    checkWidget();\n    return horizontalBar;\n}",
			"comments":"/**\n* Returns the receiver's horizontal scroll bar if it has\n* one, and null if it does not.\n*\n* @return the horizontal scroll bar (or null)\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public ScrollBar getHorizontalBar()"
		},
		"LRESULT WM_VSCROLL(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_VSCROLL(wParam, lParam);\n    if (result != null)\n        return result;\n    \n    if (verticalBar != null && (lParam == 0 || lParam == handle)) {\n        return wmScroll(verticalBar, (state & CANVAS) != 0, handle, OS.WM_VSCROLL, wParam, lParam);\n    }\n    return result;\n}",
			"comments":"/*\n* Bug on WinCE.  lParam should be NULL when the message is not sent\n* by a scroll bar control, but it contains the handle to the window.\n* When the message is sent by a scroll bar control, it correctly\n* contains the handle to the scroll bar.  The fix is to check for\n* both.\n*/\n",
			"methodName":"LRESULT WM_VSCROLL(int wParam, int lParam)"
		},
		"public Rectangle getClientArea()":{
			"methodBody":"{\n    checkWidget();\n    forceResize();\n    RECT rect = new RECT();\n    int scrolledHandle = scrolledHandle();\n    OS.GetClientRect(scrolledHandle, rect);\n    return new Rectangle(0, 0, rect.right, rect.bottom);\n}",
			"comments":"/**\n* Returns a rectangle which describes the area of the\n* receiver which is capable of displaying data (that is,\n* not covered by the \"trimmings\").\n*\n* @return the client area\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #computeTrim\n*/\n",
			"methodName":"public Rectangle getClientArea()"
		},
		"public Rectangle computeTrim(int x, int y, int width, int height)":{
			"methodBody":"{\n    checkWidget();\n    int scrolledHandle = scrolledHandle();\n    RECT rect = new RECT();\n    OS.SetRect(rect, x, y, x + width, y + height);\n    int bits1 = OS.GetWindowLong(scrolledHandle, OS.GWL_STYLE);\n    int bits2 = OS.GetWindowLong(scrolledHandle, OS.GWL_EXSTYLE);\n    OS.AdjustWindowRectEx(rect, bits1, false, bits2);\n    if (horizontalBar != null)\n        rect.bottom += OS.GetSystemMetrics(OS.SM_CYHSCROLL);\n    if (verticalBar != null)\n        rect.right += OS.GetSystemMetrics(OS.SM_CXVSCROLL);\n    int nWidth = rect.right - rect.left, nHeight = rect.bottom - rect.top;\n    return new Rectangle(rect.left, rect.top, nWidth, nHeight);\n}",
			"comments":"/**\n* Given a desired <em>client area</em> for the receiver\n* (as described by the arguments), returns the bounding\n* rectangle which would be required to produce that client\n* area.\n* <p>\n* In other words, it returns a rectangle such that, if the\n* receiver's bounds were set to that rectangle, the area\n* of the receiver which is capable of displaying data\n* (that is, not covered by the \"trimmings\") would be the\n* rectangle described by the arguments (relative to the\n* receiver's parent).\n* </p>\n*\n* @param x the desired x coordinate of the client area\n* @param y the desired y coordinate of the client area\n* @param width the desired width of the client area\n* @param height the desired height of the client area\n* @return the required bounds to produce the given client area\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #getClientArea\n*/\n",
			"methodName":"public Rectangle computeTrim(int x, int y, int width, int height)"
		},
		"void releaseWidget()":{
			"methodBody":"{\n    if (horizontalBar != null)\n        horizontalBar.releaseResources();\n    if (verticalBar != null)\n        verticalBar.releaseResources();\n    horizontalBar = verticalBar = null;\n    super.releaseWidget();\n}",
			"comments":"",
			"methodName":"void releaseWidget()"
		},
		"int windowProc()":{
			"methodBody":"{\n    return display.windowProc;\n}",
			"comments":"",
			"methodName":"int windowProc()"
		},
		"LRESULT WM_MOUSEWHEEL(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_MOUSEWHEEL(wParam, lParam);\n    if (result != null)\n        return result;\n    \n    if ((state & CANVAS) != 0) {\n        if ((wParam & (OS.MK_SHIFT | OS.MK_CONTROL)) != 0)\n            return result;\n        boolean vertical = verticalBar != null && verticalBar.getEnabled();\n        boolean horizontal = horizontalBar != null && horizontalBar.getEnabled();\n        int msg = (vertical) ? OS.WM_VSCROLL : (horizontal) ? OS.WM_HSCROLL : 0;\n        if (msg == 0)\n            return result;\n        int[] value = new int[1];\n        OS.SystemParametersInfo(OS.SPI_GETWHEELSCROLLLINES, 0, value, 0);\n        int delta = (short) (wParam >> 16);\n        int code = 0, count = 0;\n        if (value[0] == OS.WHEEL_PAGESCROLL) {\n            code = delta < 0 ? OS.SB_PAGEDOWN : OS.SB_PAGEUP;\n            count = Math.abs(delta / OS.WHEEL_DELTA);\n        } else {\n            code = delta < 0 ? OS.SB_LINEDOWN : OS.SB_LINEUP;\n            delta = Math.abs(delta);\n            if (delta < OS.WHEEL_DELTA)\n                return result;\n            if (msg == OS.WM_VSCROLL) {\n                count = value[0] * delta / OS.WHEEL_DELTA;\n            } else {\n                count = delta / OS.WHEEL_DELTA;\n            }\n        }\n        for (int i = 0; i < count; i++) {\n            OS.SendMessage(handle, msg, code, 0);\n        }\n        return LRESULT.ZERO;\n    }\n    \n    int vPosition = verticalBar == null ? 0 : verticalBar.getSelection();\n    int hPosition = horizontalBar == null ? 0 : horizontalBar.getSelection();\n    int code = callWindowProc(handle, OS.WM_MOUSEWHEEL, wParam, lParam);\n    if (verticalBar != null) {\n        int position = verticalBar.getSelection();\n        if (position != vPosition) {\n            Event event = new Event();\n            event.detail = position < vPosition ? SWT.PAGE_UP : SWT.PAGE_DOWN;\n            verticalBar.sendEvent(SWT.Selection, event);\n        }\n    }\n    if (horizontalBar != null) {\n        int position = horizontalBar.getSelection();\n        if (position != hPosition) {\n            Event event = new Event();\n            event.detail = position < hPosition ? SWT.PAGE_UP : SWT.PAGE_DOWN;\n            horizontalBar.sendEvent(SWT.Selection, event);\n        }\n    }\n    return new LRESULT(code);\n}",
			"comments":"/*\n* Translate WM_MOUSEWHEEL to WM_VSCROLL or WM_HSCROLL.\n*/\n/*\n* When the native widget scrolls inside WM_MOUSEWHEEL, it\n* may or may not send a WM_VSCROLL or WM_HSCROLL to do the\n* actual scrolling.  This depends on the implementation of\n* each native widget.  In order to ensure that application\n* code is notified when the scroll bar moves, compare the\n* scroll bar position before and after the WM_MOUSEWHEEL.\n* If the native control sends a WM_VSCROLL or WM_HSCROLL,\n* then the application has already been notified.  If not\n* explicity send the event.\n*/\n",
			"methodName":"LRESULT WM_MOUSEWHEEL(int wParam, int lParam)"
		},
		"void createWidget()":{
			"methodBody":"{\n    super.createWidget();\n    if ((style & SWT.H_SCROLL) != 0)\n        horizontalBar = createScrollBar(SWT.H_SCROLL);\n    if ((style & SWT.V_SCROLL) != 0)\n        verticalBar = createScrollBar(SWT.V_SCROLL);\n}",
			"comments":"",
			"methodName":"void createWidget()"
		},
		"LRESULT WM_HSCROLL(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_HSCROLL(wParam, lParam);\n    if (result != null)\n        return result;\n    \n    if (horizontalBar != null && (lParam == 0 || lParam == handle)) {\n        return wmScroll(horizontalBar, (state & CANVAS) != 0, handle, OS.WM_HSCROLL, wParam, lParam);\n    }\n    return result;\n}",
			"comments":"/*\n* Bug on WinCE.  lParam should be NULL when the message is not sent\n* by a scroll bar control, but it contains the handle to the window.\n* When the message is sent by a scroll bar control, it correctly\n* contains the handle to the scroll bar.  The fix is to check for\n* both.\n*/\n",
			"methodName":"LRESULT WM_HSCROLL(int wParam, int lParam)"
		},
		"int callWindowProc(int hwnd, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    if (handle == 0)\n        return 0;\n    return OS.DefWindowProc(hwnd, msg, wParam, lParam);\n}",
			"comments":"",
			"methodName":"int callWindowProc(int hwnd, int msg, int wParam, int lParam)"
		},
		"int scrolledHandle()":{
			"methodBody":"{\n    return handle;\n}",
			"comments":"",
			"methodName":"int scrolledHandle()"
		},
		"int widgetStyle()":{
			"methodBody":"{\n    int bits = super.widgetStyle() | OS.WS_TABSTOP;\n    if ((style & SWT.H_SCROLL) != 0)\n        bits |= OS.WS_HSCROLL;\n    if ((style & SWT.V_SCROLL) != 0)\n        bits |= OS.WS_VSCROLL;\n    return bits;\n}",
			"comments":"",
			"methodName":"int widgetStyle()"
		}
	},
	"ClassORInterfaceName":[
		"Scrollable"
	]
}
