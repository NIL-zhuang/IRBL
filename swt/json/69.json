{
	"variables":[
		"TAB",
		"PlatformLineDelimiter",
		"BIDI_CARET_WIDTH",
		"DEFAULT_WIDTH",
		"DEFAULT_HEIGHT",
		"ExtendedModify",
		"LineGetBackground",
		"LineGetStyle",
		"TextChanging",
		"TextSet",
		"VerifyKey",
		"TextChanged",
		"LineGetSegments",
		"selectionBackground",
		"selectionForeground",
		"logicalContent",
		"content",
		"renderer",
		"listener",
		"textChangeListener",
		"defaultLineStyler",
		"lineCache",
		"userLineStyle",
		"userLineBackground",
		"verticalScrollOffset",
		"horizontalScrollOffset",
		"topIndex",
		"lastPaintTopIndex",
		"topOffset",
		"clientAreaHeight",
		"clientAreaWidth",
		"lineHeight",
		"tabLength",
		"leftMargin",
		"topMargin",
		"rightMargin",
		"bottomMargin",
		"ibeamCursor",
		"columnX",
		"caretOffset",
		"selection",
		"clipboardSelection",
		"selectionAnchor",
		"doubleClickSelection",
		"editable",
		"wordWrap",
		"doubleClickEnabled",
		"overwrite",
		"textLimit",
		"keyActionMap",
		"background",
		"foreground",
		"clipboard",
		"mouseDown",
		"mouseDoubleClick",
		"autoScrollDirection",
		"autoScrollDistance",
		"lastTextChangeStart",
		"lastTextChangeNewLineCount",
		"lastTextChangeNewCharCount",
		"lastTextChangeReplaceLineCount",
		"lastTextChangeReplaceCharCount",
		"isMirrored",
		"bidiColoring",
		"leftCaretBitmap",
		"rightCaretBitmap",
		"caretDirection",
		"advancing",
		"defaultCaret",
		"updateCaretDirection",
		"IS_CARBON",
		"IS_GTK",
		"IS_MOTIF",
		"DOUBLE_BUFFER",
		"platform",
		"LEFT",
		"CENTER",
		"RIGHT",
		"parent",
		"printer",
		"renderer",
		"printOptions",
		"printerContent",
		"clientArea",
		"printerFont",
		"displayFontData",
		"printerColors",
		"lineBackgrounds",
		"lineStyles",
		"bidiSegments",
		"gc",
		"pageWidth",
		"startPage",
		"endPage",
		"pageSize",
		"startLine",
		"endLine",
		"singleLine",
		"selection",
		"mirrored",
		"data",
		"temp",
		"segments",
		"event",
		"i",
		"lineOffset",
		"line",
		"event",
		"styles",
		"i",
		"styleCopy",
		"insertOffset",
		"i",
		"insertEndOffset",
		"values",
		"event",
		"event",
		"i",
		"style",
		"printerBackground",
		"printerForeground",
		"colors",
		"color",
		"trim",
		"dpi",
		"style",
		"lineHeight",
		"content",
		"data",
		"printerColor",
		"content",
		"background",
		"foreground",
		"lineHeight",
		"paintY",
		"page",
		"i",
		"line",
		"lastSegmentIndex",
		"SegmentCount",
		"text",
		"i",
		"segmentIndex",
		"segment",
		"pageIndex",
		"PageTagLength",
		"buffer",
		"segmentWidth",
		"drawX",
		"drawY",
		"layout",
		"jobName",
		"DEFAULT_FOREGROUND",
		"DEFAULT_BACKGROUND",
		"colorTable",
		"WriteUnicode",
		"index",
		"Win95",
		"Win98",
		"WinME",
		"WinNT",
		"osName",
		"osVersion",
		"majorVersion",
		"majorIndex",
		"index",
		"ch",
		"header",
		"fontData",
		"cpg",
		"i",
		"color",
		"styles",
		"lineBackground",
		"event",
		"lineLength",
		"lineIndex",
		"copyEnd",
		"startOffset",
		"endOffset",
		"lineEndOffset",
		"writeOffset",
		"i",
		"style",
		"start",
		"end",
		"colorIndex",
		"buffer",
		"startOffset",
		"endOffset",
		"isClosed",
		"lineLength",
		"lineIndex",
		"copyEnd",
		"writeOffset",
		"parent",
		"lineWidth",
		"content",
		"lineCount",
		"maxWidth",
		"maxWidthLineIndex",
		"caretWidth",
		"endLine",
		"i",
		"line",
		"lineOffset",
		"topIndex",
		"bottomLine",
		"layout",
		"rect",
		"size",
		"newLines",
		"inserting",
		"i",
		"i",
		"i",
		"endLine",
		"i",
		"i",
		"startLine",
		"removedMaxLine",
		"i",
		"parent",
		"visualContent",
		"itemCount",
		"oldLineOffsets",
		"i",
		"i",
		"startLine",
		"lineCount",
		"display",
		"runnable",
		"direction",
		"lineIndex",
		"line",
		"lineOffset",
		"offsetInLine",
		"newCaretX",
		"typedListener",
		"keyValue",
		"modifierValue",
		"keyChar",
		"ch",
		"newKey",
		"typedListener",
		"typedListener",
		"typedListener",
		"typedListener",
		"typedListener",
		"typedListener",
		"typedListener",
		"lastChar",
		"horizontalBar",
		"verticalBar",
		"oldTopIndex",
		"verticalIncrement",
		"clientAreaHeight",
		"bottomPixel",
		"fullLineTopPixel",
		"fullLineVisibleHeight",
		"newVerticalOffset",
		"newHorizontalOffset",
		"selectionStart",
		"selectionEnd",
		"length",
		"redrawStart",
		"redrawEnd",
		"count",
		"width",
		"height",
		"singleLine",
		"computeLineCache",
		"visibleCount",
		"wrappedContent",
		"rect",
		"length",
		"convertedText",
		"delimiter",
		"length",
		"crIndex",
		"lfIndex",
		"i",
		"caretWidth",
		"display",
		"gc",
		"length",
		"area",
		"timer",
		"TIMER_INTERVAL",
		"display",
		"lines",
		"lines",
		"event",
		"line",
		"lineOffset",
		"lineText",
		"layout",
		"start",
		"event",
		"lineIndex",
		"lineOffset",
		"line",
		"length",
		"caretLine",
		"caretLine",
		"event",
		"line",
		"lineOffset",
		"lineLength",
		"event",
		"event",
		"caretLine",
		"caretLine",
		"lineOffset",
		"lineLength",
		"lineEndOffset",
		"caretLine",
		"lineOffset",
		"caretLine",
		"line",
		"lineCount",
		"newCaretOffset",
		"newCaretLine",
		"oldAdvancing",
		"wordOffset",
		"lineCount",
		"oldColumnX",
		"oldHScrollOffset",
		"caretLine",
		"verticalMaximum",
		"pageSize",
		"scrollLines",
		"scrollOffset",
		"hScrollChange",
		"line",
		"bottomCaretOffset",
		"topCaretOffset",
		"oldColumnX",
		"oldHScrollOffset",
		"caretLine",
		"scrollLines",
		"scrollOffset",
		"hScrollChange",
		"redrawStart",
		"redrawEnd",
		"caretLine",
		"lineOffset",
		"offsetInLine",
		"caretLine",
		"lineOffset",
		"offsetInLine",
		"oldColumnX",
		"caretLine",
		"lineStartOffset",
		"oldColumnX",
		"caretLine",
		"lineStartOffset",
		"oldColumnX",
		"caretLine",
		"lineStartOffset",
		"oldColumnX",
		"caretLine",
		"lineStartOffset",
		"newCaretOffset",
		"caretLine",
		"caretLine",
		"caretLine",
		"startLine",
		"endY",
		"paintYFromTopLine",
		"topLineOffset",
		"paintY",
		"lineCount",
		"background",
		"foreground",
		"gc",
		"i",
		"line",
		"lineCount",
		"partialTopLineHeight",
		"x",
		"layout",
		"trailing",
		"offsetInLine",
		"lineLength",
		"level",
		"offset",
		"trailingLevel",
		"caret",
		"plainTextTransfer",
		"line",
		"lineOffset",
		"layout",
		"line",
		"lineOffset",
		"layout",
		"gc",
		"increment",
		"action",
		"intAction",
		"lineBackground",
		"lineCount",
		"event",
		"lineIndex",
		"lineCache",
		"line",
		"lineOffset",
		"lineContent",
		"x",
		"y",
		"layout",
		"line",
		"lineOffset",
		"offsetInLine",
		"lineText",
		"x",
		"rect",
		"trailing",
		"lineText",
		"lineOffset",
		"partialLineCount",
		"end",
		"startLine",
		"endLine",
		"endLineText",
		"endLineOffset",
		"i",
		"style",
		"event",
		"lineLength",
		"segments",
		"segmentCount",
		"i",
		"event",
		"styles",
		"lineLength",
		"k",
		"count",
		"offsets",
		"i",
		"style",
		"styleLineStart",
		"styleLineEnd",
		"result",
		"styles",
		"contentLength",
		"end",
		"styles",
		"style",
		"newStyle",
		"newStyle",
		"style",
		"newStyle",
		"newStyle",
		"contentLength",
		"contentLength",
		"lineStart",
		"lineEnd",
		"rect",
		"y",
		"height",
		"left",
		"right",
		"i",
		"lineOffset",
		"line",
		"layout",
		"contentLength",
		"end",
		"logicalTopIndex",
		"visualLineOffset",
		"caretLine",
		"lineOffset",
		"line",
		"offset",
		"lineLength",
		"layout",
		"level",
		"caretLine",
		"leftColumnX",
		"line",
		"lineOffset",
		"lineText",
		"lineLength",
		"layout",
		"line",
		"lineOffset",
		"lineText",
		"lineLength",
		"ch",
		"letterOrDigit",
		"line",
		"lineOffset",
		"lineText",
		"layout",
		"x",
		"lineLength",
		"endLineOffset",
		"lineOffset",
		"layout",
		"sel",
		"typedListener",
		"verticalBar",
		"horizontalBar",
		"end",
		"firstLine",
		"lastLine",
		"offsetInFirstLine",
		"partialBottomIndex",
		"partialTopIndex",
		"clientArea",
		"redrawStopY",
		"redrawY",
		"rtfWriter",
		"scrollPixel",
		"action",
		"c",
		"ignore",
		"verifyEvent",
		"text",
		"x",
		"y",
		"e",
		"select",
		"startLine",
		"paintYFromTopLine",
		"topLineOffset",
		"startY",
		"renderHeight",
		"oldHeight",
		"oldWidth",
		"clientArea",
		"x",
		"y",
		"lineCount",
		"oldBottomIndex",
		"newItemCount",
		"startLine",
		"startY",
		"gc",
		"caret",
		"caretVisible",
		"firstLine",
		"textChangeY",
		"isMultiLineChange",
		"newEndOfText",
		"accessible",
		"selection",
		"state",
		"oldColumnX",
		"oldHScrollOffset",
		"hScrollChange",
		"caretLine",
		"line",
		"lineOffset",
		"offsetInLine",
		"partialBottomIndex",
		"partialTopIndex",
		"notVisible",
		"styledTextEvent",
		"replacedLength",
		"lineIndex",
		"lineOffset",
		"lineText",
		"layout",
		"levelStart",
		"lineIndexEnd",
		"levelEnd",
		"text",
		"event",
		"clientArea",
		"background",
		"foreground",
		"lineCount",
		"gcStyle",
		"paintY",
		"paintHeight",
		"lineBuffer",
		"lineGC",
		"doubleBuffer",
		"i",
		"line",
		"printer",
		"options",
		"options",
		"itemCount",
		"lineCount",
		"startLine",
		"endLine",
		"itemCount",
		"redrawX",
		"lineText",
		"redrawY",
		"line",
		"lineCount",
		"redrawY",
		"redrawWidth",
		"lineOffset",
		"fullLineRedraw",
		"clientArea",
		"layout",
		"rect",
		"offsetInLastLine",
		"clientArea",
		"lineCount",
		"sourceY",
		"destinationY",
		"redrawStartY",
		"redrawHeight",
		"end",
		"contentLength",
		"firstLine",
		"lastLine",
		"typedListener",
		"typedListener",
		"end",
		"firstLine",
		"lastLine",
		"redrawY",
		"redrawStopY",
		"contentLength",
		"end",
		"event",
		"verticalBar",
		"horizontalBar",
		"clientArea",
		"sourceX",
		"scrollWidth",
		"scrollHeight",
		"destinationX",
		"scrollWidth",
		"scrollHeight",
		"oldColumnX",
		"horizontalBar",
		"accessible",
		"event",
		"horizontalBar",
		"caret",
		"updateImage",
		"imageDirection",
		"newCaretY",
		"lineIndex",
		"line",
		"lineOffset",
		"offsetInLine",
		"newCaretX",
		"length",
		"plainTextTransfer",
		"plainTextWriter",
		"plainText",
		"data",
		"types",
		"rtfTransfer",
		"rtfWriter",
		"rtfText",
		"oldLineHeight",
		"clientAreaWidth",
		"width",
		"clientAreaWidth",
		"width",
		"horizontalBar",
		"INACTIVE",
		"clientArea",
		"partialBottomIndex",
		"verticalBar",
		"clientArea",
		"INACTIVE",
		"maximum",
		"contentLength",
		"end",
		"end",
		"temp",
		"firstLine",
		"lastLine",
		"redrawY",
		"redrawStopY",
		"last",
		"lastEnd",
		"firstLine",
		"lastLine",
		"event",
		"styledTextEvent",
		"lineCount",
		"pageSize",
		"logicalLineOffset",
		"lineCount",
		"height",
		"maxTopPixel",
		"clientArea",
		"verticalBar",
		"oldColumnX",
		"clientAreaWidth",
		"verticalIncrement",
		"horizontalIncrement",
		"scrolled",
		"caretLine",
		"lineOffset",
		"line",
		"offsetInLine",
		"newCaretX",
		"scrolled",
		"setWrapCaretLocation",
		"caret",
		"caretY",
		"line",
		"lineOffset",
		"offsetInLine",
		"lineText",
		"xAtOffset",
		"selectionFits",
		"startOffset",
		"startLine",
		"startX",
		"endOffset",
		"endLine",
		"endX",
		"offsetInLine",
		"rightToLeft",
		"w",
		"netNewLength",
		"redrawStart",
		"wrappedContent",
		"newTopIndex",
		"verticalBar",
		"System",
		"SWT",
		"SWT",
		"SWT",
		"IS_CARBON",
		"platform",
		"IS_GTK",
		"platform",
		"IS_MOTIF",
		"platform",
		"DOUBLE_BUFFER",
		"IS_CARBON",
		"printer",
		"parent",
		"printer",
		"printOptions",
		"parent",
		"SWT",
		"singleLine",
		"parent",
		"startPage",
		"endPage",
		"Integer",
		"data",
		"PrinterData",
		"startPage",
		"data",
		"endPage",
		"data",
		"endPage",
		"startPage",
		"endPage",
		"endPage",
		"startPage",
		"startPage",
		"temp",
		"data",
		"PrinterData",
		"selection",
		"parent",
		"displayFontData",
		"parent",
		"parent",
		"printerContent",
		"parent",
		"lineOffset",
		"line",
		"segments",
		"bidiSegments",
		"lineOffset",
		"segments",
		"parent",
		"lineOffset",
		"line",
		"event",
		"lineBackgrounds",
		"lineOffset",
		"event",
		"i",
		"printerContent",
		"i",
		"printerContent",
		"i",
		"printerContent",
		"i",
		"printOptions",
		"lineOffset",
		"line",
		"printOptions",
		"printOptions",
		"printOptions",
		"lineOffset",
		"line",
		"parent",
		"lineOffset",
		"line",
		"parent",
		"lineOffset",
		"line",
		"event",
		"event",
		"i",
		"styles",
		"i",
		"printOptions",
		"styles",
		"i",
		"styleCopy",
		"styles",
		"i",
		"styleCopy",
		"printOptions",
		"styles",
		"i",
		"styleCopy",
		"styleCopy",
		"styles",
		"i",
		"styleCopy",
		"printOptions",
		"styles",
		"i",
		"SWT",
		"styleCopy",
		"styleCopy",
		"styles",
		"i",
		"styleCopy",
		"SWT",
		"styleCopy",
		"styles",
		"i",
		"styleCopy",
		"lineStyles",
		"lineOffset",
		"event",
		"printerContent",
		"i",
		"original",
		"i",
		"i",
		"original",
		"insertEndOffset",
		"original",
		"i",
		"insertEndOffset",
		"original",
		"printerContent",
		"insertOffset",
		"original",
		"insertOffset",
		"insertEndOffset",
		"insertOffset",
		"insertOffset",
		"insertEndOffset",
		"lineBackgrounds",
		"printerColors",
		"values",
		"values",
		"event",
		"event",
		"values",
		"lineStyles",
		"values",
		"values",
		"i",
		"event",
		"i",
		"event",
		"i",
		"style",
		"style",
		"printerBackground",
		"style",
		"printerForeground",
		"style",
		"style",
		"style",
		"style",
		"printerBackground",
		"style",
		"printerForeground",
		"event",
		"i",
		"style",
		"printerColors",
		"printerColors",
		"colors",
		"colors",
		"color",
		"printerColors",
		"gc",
		"gc",
		"gc",
		"printerFont",
		"printerFont",
		"printerFont",
		"renderer",
		"renderer",
		"renderer",
		"page",
		"printer",
		"printer",
		"printer",
		"printerFont",
		"printer",
		"displayFontData",
		"displayFontData",
		"SWT",
		"clientArea",
		"printer",
		"pageWidth",
		"clientArea",
		"clientArea",
		"dpi",
		"trim",
		"clientArea",
		"dpi",
		"trim",
		"clientArea",
		"clientArea",
		"trim",
		"clientArea",
		"clientArea",
		"trim",
		"mirrored",
		"SWT",
		"SWT",
		"gc",
		"printer",
		"style",
		"gc",
		"printerFont",
		"renderer",
		"printer",
		"printerFont",
		"gc",
		"printerContent",
		"lineBackgrounds",
		"lineStyles",
		"bidiSegments",
		"parent",
		"clientArea",
		"printOptions",
		"renderer",
		"clientArea",
		"lineHeight",
		"clientArea",
		"lineHeight",
		"printOptions",
		"clientArea",
		"renderer",
		"pageSize",
		"clientArea",
		"renderer",
		"renderer",
		"startLine",
		"singleLine",
		"endLine",
		"endLine",
		"content",
		"printer",
		"data",
		"PrinterData",
		"startLine",
		"startPage",
		"pageSize",
		"data",
		"PrinterData",
		"startLine",
		"content",
		"selection",
		"selection",
		"endLine",
		"content",
		"selection",
		"selection",
		"endLine",
		"startLine",
		"color",
		"printerColor",
		"printerColors",
		"color",
		"printerColor",
		"printerColor",
		"printer",
		"color",
		"printerColors",
		"color",
		"printerColor",
		"printerColor",
		"renderer",
		"gc",
		"gc",
		"renderer",
		"clientArea",
		"startPage",
		"startLine",
		"i",
		"endLine",
		"page",
		"endPage",
		"i",
		"paintY",
		"lineHeight",
		"content",
		"i",
		"paintY",
		"clientArea",
		"page",
		"renderer",
		"line",
		"i",
		"paintY",
		"gc",
		"background",
		"foreground",
		"paintY",
		"lineHeight",
		"clientArea",
		"clientArea",
		"page",
		"paintY",
		"clientArea",
		"lineHeight",
		"page",
		"paintY",
		"clientArea",
		"page",
		"header",
		"text",
		"printOptions",
		"text",
		"printOptions",
		"text",
		"i",
		"SegmentCount",
		"i",
		"text",
		"StyledTextPrintOptions",
		"lastSegmentIndex",
		"segmentIndex",
		"segment",
		"text",
		"lastSegmentIndex",
		"segment",
		"i",
		"page",
		"header",
		"segment",
		"text",
		"lastSegmentIndex",
		"segmentIndex",
		"segment",
		"i",
		"page",
		"header",
		"lastSegmentIndex",
		"segmentIndex",
		"StyledTextPrintOptions",
		"segment",
		"StyledTextPrintOptions",
		"pageIndex",
		"StyledTextPrintOptions",
		"segment",
		"pageIndex",
		"buffer",
		"page",
		"buffer",
		"segment",
		"pageIndex",
		"PageTagLength",
		"segment",
		"buffer",
		"segment",
		"printer",
		"layout",
		"segment",
		"layout",
		"printerFont",
		"segmentWidth",
		"layout",
		"header",
		"drawY",
		"clientArea",
		"renderer",
		"drawY",
		"clientArea",
		"clientArea",
		"renderer",
		"alignment",
		"LEFT",
		"drawX",
		"clientArea",
		"alignment",
		"CENTER",
		"drawX",
		"pageWidth",
		"segmentWidth",
		"alignment",
		"RIGHT",
		"drawX",
		"clientArea",
		"clientArea",
		"segmentWidth",
		"layout",
		"gc",
		"drawX",
		"drawY",
		"layout",
		"printOptions",
		"jobName",
		"jobName",
		"printer",
		"jobName",
		"printer",
		"printer",
		"page",
		"start",
		"length",
		"colorTable",
		"colorTable",
		"color",
		"index",
		"defaultIndex",
		"index",
		"colorTable",
		"color",
		"index",
		"index",
		"colorTable",
		"colorTable",
		"color",
		"index",
		"System",
		"System",
		"osName",
		"WinNT",
		"osVersion",
		"osVersion",
		"majorIndex",
		"osVersion",
		"osVersion",
		"majorIndex",
		"majorVersion",
		"Integer",
		"osVersion",
		"osName",
		"Win95",
		"osName",
		"Win98",
		"osName",
		"WinME",
		"osName",
		"WinNT",
		"majorVersion",
		"WriteUnicode",
		"WriteUnicode",
		"start",
		"index",
		"end",
		"index",
		"string",
		"index",
		"ch",
		"WriteUnicode",
		"index",
		"start",
		"string",
		"start",
		"index",
		"Integer",
		"ch",
		"start",
		"index",
		"ch",
		"ch",
		"ch",
		"index",
		"start",
		"string",
		"start",
		"index",
		"ch",
		"start",
		"index",
		"start",
		"end",
		"string",
		"start",
		"end",
		"header",
		"System",
		"cpg",
		"cpg",
		"cpg",
		"cpg",
		"cpg",
		"header",
		"header",
		"cpg",
		"header",
		"header",
		"fontData",
		"header",
		"i",
		"colorTable",
		"i",
		"colorTable",
		"i",
		"header",
		"header",
		"color",
		"header",
		"header",
		"color",
		"header",
		"header",
		"color",
		"header",
		"header",
		"header",
		"fontData",
		"header",
		"header",
		"SWT",
		"SWT",
		"event",
		"renderer",
		"lineOffset",
		"line",
		"event",
		"styles",
		"event",
		"event",
		"renderer",
		"lineOffset",
		"line",
		"event",
		"lineBackground",
		"event",
		"lineBackground",
		"lineBackground",
		"line",
		"lineOffset",
		"styles",
		"lineBackground",
		"SWT",
		"SWT",
		"lineDelimiter",
		"lineDelimiter",
		"line",
		"startOffset",
		"Math",
		"lineLength",
		"endOffset",
		"lineOffset",
		"startOffset",
		"lineOffset",
		"writeOffset",
		"line",
		"writeOffset",
		"lineIndex",
		"writeOffset",
		"lineIndex",
		"lineBackground",
		"lineBackground",
		"DEFAULT_BACKGROUND",
		"i",
		"styles",
		"i",
		"styles",
		"i",
		"style",
		"lineOffset",
		"start",
		"style",
		"end",
		"writeOffset",
		"start",
		"lineEndOffset",
		"lineIndex",
		"start",
		"line",
		"lineIndex",
		"start",
		"lineIndex",
		"start",
		"colorIndex",
		"style",
		"DEFAULT_BACKGROUND",
		"style",
		"DEFAULT_FOREGROUND",
		"colorIndex",
		"DEFAULT_BACKGROUND",
		"colorIndex",
		"style",
		"SWT",
		"style",
		"SWT",
		"style",
		"style",
		"copyEnd",
		"Math",
		"end",
		"lineEndOffset",
		"copyEnd",
		"Math",
		"copyEnd",
		"lineIndex",
		"line",
		"lineIndex",
		"copyEnd",
		"style",
		"SWT",
		"style",
		"SWT",
		"style",
		"style",
		"lineIndex",
		"copyEnd",
		"lineIndex",
		"lineEndOffset",
		"line",
		"lineIndex",
		"lineEndOffset",
		"lineBackground",
		"buffer",
		"length",
		"startOffset",
		"start",
		"endOffset",
		"start",
		"length",
		"isClosed",
		"isClosed",
		"endOffset",
		"startOffset",
		"startOffset",
		"isClosed",
		"buffer",
		"buffer",
		"string",
		"offset",
		"offset",
		"buffer",
		"buffer",
		"offset",
		"string",
		"buffer",
		"i",
		"buffer",
		"i",
		"line",
		"startOffset",
		"lineOffset",
		"isClosed",
		"SWT",
		"SWT",
		"writeOffset",
		"lineLength",
		"writeOffset",
		"lineIndex",
		"writeOffset",
		"lineIndex",
		"copyEnd",
		"Math",
		"lineLength",
		"endOffset",
		"lineOffset",
		"lineIndex",
		"copyEnd",
		"line",
		"lineIndex",
		"copyEnd",
		"isClosed",
		"SWT",
		"SWT",
		"lineDelimiter",
		"parent",
		"content",
		"content",
		"lineWidth",
		"lineCount",
		"lineCount",
		"startLine",
		"lineCount",
		"startLine",
		"endLine",
		"lineWidth",
		"caretWidth",
		"startLine",
		"i",
		"endLine",
		"i",
		"lineWidth",
		"i",
		"content",
		"i",
		"content",
		"i",
		"lineWidth",
		"i",
		"line",
		"lineOffset",
		"caretWidth",
		"lineWidth",
		"i",
		"maxWidth",
		"maxWidth",
		"lineWidth",
		"i",
		"maxWidthLineIndex",
		"i",
		"parent",
		"Math",
		"startLine",
		"newLineCount",
		"startLine",
		"Math",
		"startLine",
		"topIndex",
		"startLine",
		"bottomLine",
		"startLine",
		"renderer",
		"line",
		"lineOffset",
		"layout",
		"renderer",
		"layout",
		"rect",
		"rect",
		"leftMargin",
		"rightMargin",
		"lineWidth",
		"size",
		"lineCount",
		"numLines",
		"Math",
		"size",
		"size",
		"numLines",
		"System",
		"lineWidth",
		"newLines",
		"size",
		"lineWidth",
		"newLines",
		"size",
		"lineWidth",
		"size",
		"maxWidth",
		"delta",
		"delta",
		"inserting",
		"delta",
		"lineCount",
		"i",
		"startLine",
		"i",
		"lineWidth",
		"i",
		"delta",
		"lineWidth",
		"i",
		"startLine",
		"i",
		"startLine",
		"delta",
		"i",
		"lineWidth",
		"i",
		"lineWidth",
		"i",
		"maxWidthLineIndex",
		"startLine",
		"maxWidthLineIndex",
		"delta",
		"startLine",
		"delta",
		"i",
		"lineCount",
		"i",
		"lineWidth",
		"i",
		"delta",
		"lineWidth",
		"i",
		"maxWidthLineIndex",
		"startLine",
		"maxWidthLineIndex",
		"startLine",
		"delta",
		"maxWidth",
		"maxWidthLineIndex",
		"maxWidthLineIndex",
		"startLine",
		"delta",
		"maxWidthLineIndex",
		"delta",
		"lineCount",
		"delta",
		"startLine",
		"lineCount",
		"calculateMaxWidth",
		"startLine",
		"lineCount",
		"startLine",
		"endLine",
		"lineWidth",
		"startLine",
		"i",
		"endLine",
		"i",
		"lineWidth",
		"i",
		"maxWidthLineIndex",
		"startLine",
		"maxWidthLineIndex",
		"endLine",
		"maxWidth",
		"maxWidthLineIndex",
		"calculateMaxWidth",
		"i",
		"lineCount",
		"i",
		"lineWidth",
		"i",
		"maxWidth",
		"maxWidth",
		"lineWidth",
		"i",
		"maxWidthLineIndex",
		"i",
		"parent",
		"startOffset",
		"maxWidthLineIndex",
		"startLine",
		"maxWidthLineIndex",
		"startLine",
		"replaceLineCount",
		"startLine",
		"replaceLineCount",
		"lineCount",
		"lineCount",
		"newLineCount",
		"lineWidth",
		"lineCount",
		"lineCount",
		"maxWidth",
		"startLine",
		"replaceLineCount",
		"startLine",
		"newLineCount",
		"lineWidth",
		"startLine",
		"startLine",
		"newLineCount",
		"removedMaxLine",
		"maxWidthLineIndex",
		"lineWidth",
		"maxWidthLineIndex",
		"maxWidth",
		"maxWidth",
		"i",
		"lineCount",
		"i",
		"lineWidth",
		"i",
		"maxWidth",
		"maxWidth",
		"lineWidth",
		"i",
		"maxWidthLineIndex",
		"i",
		"parent",
		"visualContent",
		"content",
		"visualContent",
		"parent",
		"lineCount",
		"visualContent",
		"visualContent",
		"visualContent",
		"startLine",
		"lineCount",
		"topIndex",
		"itemCount",
		"i",
		"itemCount",
		"i",
		"oldLineOffsets",
		"i",
		"visualContent",
		"i",
		"topIndex",
		"startLine",
		"lineCount",
		"calculateMaxWidth",
		"topIndex",
		"itemCount",
		"parent",
		"i",
		"itemCount",
		"i",
		"visualContent",
		"i",
		"topIndex",
		"oldLineOffsets",
		"i",
		"parent",
		"visualContent",
		"startOffset",
		"visualContent",
		"startOffset",
		"newLineCount",
		"replaceLineCount",
		"newCharCount",
		"replaceCharCount",
		"wordWrap",
		"content",
		"startLine",
		"lineCount",
		"startLine",
		"lineCount",
		"startLine",
		"parent",
		"parent",
		"style",
		"SWT",
		"SWT",
		"isMirrored",
		"SWT",
		"style",
		"SWT",
		"leftMargin",
		"rightMargin",
		"BIDI_CARET_WIDTH",
		"style",
		"SWT",
		"style",
		"SWT",
		"leftMargin",
		"topMargin",
		"rightMargin",
		"bottomMargin",
		"clipboard",
		"display",
		"style",
		"SWT",
		"lineCache",
		"content",
		"defaultCaret",
		"SWT",
		"BidiUtil",
		"BidiUtil",
		"SWT",
		"SWT",
		"direction",
		"caretDirection",
		"defaultCaret",
		"content",
		"lineIndex",
		"content",
		"lineIndex",
		"caretOffset",
		"lineOffset",
		"line",
		"lineIndex",
		"offsetInLine",
		"newCaretX",
		"direction",
		"BidiUtil",
		"handle",
		"runnable",
		"defaultCaret",
		"ibeamCursor",
		"display",
		"SWT",
		"ibeamCursor",
		"extendedModifyListener",
		"SWT",
		"SWT",
		"extendedModifyListener",
		"ExtendedModify",
		"typedListener",
		"key",
		"SWT",
		"key",
		"SWT",
		"keyValue",
		"Compatibility",
		"keyChar",
		"Character",
		"keyChar",
		"ch",
		"modifierValue",
		"action",
		"SWT",
		"keyActionMap",
		"newKey",
		"keyActionMap",
		"newKey",
		"action",
		"ch",
		"Character",
		"keyChar",
		"newKey",
		"ch",
		"modifierValue",
		"action",
		"SWT",
		"keyActionMap",
		"newKey",
		"keyActionMap",
		"newKey",
		"action",
		"action",
		"SWT",
		"keyActionMap",
		"key",
		"keyActionMap",
		"key",
		"action",
		"listener",
		"SWT",
		"SWT",
		"listener",
		"LineGetSegments",
		"typedListener",
		"listener",
		"SWT",
		"SWT",
		"userLineBackground",
		"defaultLineStyler",
		"defaultLineStyler",
		"logicalContent",
		"userLineBackground",
		"listener",
		"LineGetBackground",
		"typedListener",
		"listener",
		"SWT",
		"SWT",
		"userLineStyle",
		"defaultLineStyler",
		"defaultLineStyler",
		"userLineStyle",
		"listener",
		"LineGetStyle",
		"typedListener",
		"modifyListener",
		"SWT",
		"SWT",
		"modifyListener",
		"SWT",
		"typedListener",
		"listener",
		"SWT",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"listener",
		"SWT",
		"SWT",
		"listener",
		"VerifyKey",
		"typedListener",
		"verifyListener",
		"SWT",
		"SWT",
		"verifyListener",
		"SWT",
		"typedListener",
		"string",
		"SWT",
		"SWT",
		"Math",
		"lastChar",
		"string",
		"lineCache",
		"content",
		"lineCache",
		"topIndex",
		"topIndex",
		"verticalBar",
		"verticalBar",
		"horizontalBar",
		"horizontalBar",
		"topIndex",
		"verticalIncrement",
		"topIndex",
		"Compatibility",
		"verticalScrollOffset",
		"verticalIncrement",
		"topIndex",
		"clientAreaHeight",
		"verticalScrollOffset",
		"clientAreaHeight",
		"topIndex",
		"verticalIncrement",
		"bottomPixel",
		"fullLineTopPixel",
		"fullLineVisibleHeight",
		"verticalIncrement",
		"topIndex",
		"topIndex",
		"content",
		"topIndex",
		"content",
		"topIndex",
		"oldTopIndex",
		"topOffset",
		"content",
		"topIndex",
		"lineCache",
		"topIndex",
		"topIndex",
		"style",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"style",
		"SWT",
		"style",
		"SWT",
		"style",
		"Math",
		"content",
		"lineHeight",
		"newVerticalOffset",
		"verticalScrollOffset",
		"newVerticalOffset",
		"Math",
		"lineCache",
		"leftMargin",
		"rightMargin",
		"newHorizontalOffset",
		"horizontalScrollOffset",
		"newHorizontalOffset",
		"horizontalScrollOffset",
		"gc",
		"background",
		"topMargin",
		"gc",
		"y",
		"clientArea",
		"topMargin",
		"bottomMargin",
		"gc",
		"clientArea",
		"bottomMargin",
		"y",
		"clientArea",
		"bottomMargin",
		"leftMargin",
		"gc",
		"y",
		"leftMargin",
		"clientArea",
		"rightMargin",
		"gc",
		"clientArea",
		"rightMargin",
		"y",
		"rightMargin",
		"clientArea",
		"selection",
		"selection",
		"content",
		"selectionEnd",
		"selectionStart",
		"Math",
		"selectionStart",
		"length",
		"Math",
		"selectionEnd",
		"length",
		"redrawEnd",
		"redrawStart",
		"redrawStart",
		"redrawEnd",
		"redrawStart",
		"sendEvent",
		"SWT",
		"singleLine",
		"count",
		"count",
		"content",
		"wHint",
		"SWT",
		"width",
		"wHint",
		"width",
		"DEFAULT_WIDTH",
		"wHint",
		"SWT",
		"lineCache",
		"wordWrap",
		"computeLineCache",
		"logicalContent",
		"singleLine",
		"count",
		"logicalContent",
		"Math",
		"count",
		"lineHeight",
		"computeLineCache",
		"visibleCount",
		"width",
		"computeLineCache",
		"leftMargin",
		"rightMargin",
		"wordWrap",
		"singleLine",
		"renderer",
		"logicalContent",
		"wrappedContent",
		"width",
		"count",
		"wrappedContent",
		"hHint",
		"SWT",
		"height",
		"hHint",
		"height",
		"count",
		"lineHeight",
		"topMargin",
		"bottomMargin",
		"width",
		"width",
		"DEFAULT_WIDTH",
		"height",
		"singleLine",
		"height",
		"lineHeight",
		"height",
		"DEFAULT_HEIGHT",
		"width",
		"height",
		"rect",
		"rect",
		"DND",
		"clipboardType",
		"DND",
		"clipboardType",
		"DND",
		"selection",
		"selection",
		"length",
		"selection",
		"length",
		"clipboardType",
		"error",
		"DND",
		"error",
		"text",
		"length",
		"text",
		"convertedText",
		"length",
		"i",
		"length",
		"crIndex",
		"crIndex",
		"text",
		"SWT",
		"i",
		"lfIndex",
		"lfIndex",
		"text",
		"SWT",
		"i",
		"lfIndex",
		"crIndex",
		"crIndex",
		"lfIndex",
		"crIndex",
		"lfIndex",
		"convertedText",
		"text",
		"i",
		"crIndex",
		"lfIndex",
		"crIndex",
		"i",
		"lfIndex",
		"i",
		"crIndex",
		"convertedText",
		"text",
		"i",
		"lfIndex",
		"i",
		"lfIndex",
		"convertedText",
		"delimiter",
		"i",
		"length",
		"convertedText",
		"convertedText",
		"text",
		"i",
		"convertedText",
		"SWT",
		"ST",
		"SWT",
		"ST",
		"SWT",
		"ST",
		"SWT",
		"ST",
		"SWT",
		"ST",
		"SWT",
		"ST",
		"SWT",
		"SWT",
		"ST",
		"SWT",
		"SWT",
		"ST",
		"SWT",
		"SWT",
		"ST",
		"SWT",
		"SWT",
		"ST",
		"SWT",
		"ST",
		"SWT",
		"ST",
		"SWT",
		"SWT",
		"ST",
		"SWT",
		"SWT",
		"ST",
		"SWT",
		"ST",
		"SWT",
		"ST",
		"SWT",
		"SWT",
		"ST",
		"SWT",
		"SWT",
		"ST",
		"SWT",
		"SWT",
		"ST",
		"SWT",
		"SWT",
		"ST",
		"SWT",
		"SWT",
		"ST",
		"SWT",
		"SWT",
		"ST",
		"SWT",
		"SWT",
		"ST",
		"SWT",
		"SWT",
		"ST",
		"SWT",
		"SWT",
		"SWT",
		"ST",
		"SWT",
		"SWT",
		"SWT",
		"ST",
		"SWT",
		"SWT",
		"SWT",
		"ST",
		"SWT",
		"SWT",
		"SWT",
		"ST",
		"SWT",
		"SWT",
		"ST",
		"SWT",
		"SWT",
		"ST",
		"SWT",
		"SWT",
		"SWT",
		"ST",
		"SWT",
		"SWT",
		"SWT",
		"ST",
		"SWT",
		"SWT",
		"ST",
		"SWT",
		"SWT",
		"ST",
		"SWT",
		"SWT",
		"SWT",
		"ST",
		"SWT",
		"SWT",
		"SWT",
		"ST",
		"SWT",
		"ST",
		"SWT",
		"ST",
		"SWT",
		"ST",
		"SWT",
		"SWT",
		"ST",
		"SWT",
		"SWT",
		"ST",
		"SWT",
		"SWT",
		"ST",
		"SWT",
		"SWT",
		"ST",
		"SWT",
		"ST",
		"SWT",
		"ST",
		"SWT",
		"SWT",
		"ST",
		"SWT",
		"SWT",
		"ST",
		"SWT",
		"ST",
		"BIDI_CARET_WIDTH",
		"leftCaretBitmap",
		"defaultCaret",
		"leftCaretBitmap",
		"defaultCaret",
		"defaultCaret",
		"leftCaretBitmap",
		"leftCaretBitmap",
		"display",
		"caretWidth",
		"lineHeight",
		"leftCaretBitmap",
		"gc",
		"display",
		"SWT",
		"gc",
		"caretWidth",
		"lineHeight",
		"gc",
		"display",
		"SWT",
		"gc",
		"lineHeight",
		"gc",
		"caretWidth",
		"gc",
		"gc",
		"rightCaretBitmap",
		"defaultCaret",
		"rightCaretBitmap",
		"defaultCaret",
		"defaultCaret",
		"rightCaretBitmap",
		"rightCaretBitmap",
		"display",
		"caretWidth",
		"lineHeight",
		"gc",
		"rightCaretBitmap",
		"gc",
		"display",
		"SWT",
		"gc",
		"caretWidth",
		"lineHeight",
		"gc",
		"display",
		"SWT",
		"gc",
		"caretWidth",
		"caretWidth",
		"lineHeight",
		"gc",
		"caretWidth",
		"gc",
		"caretWidth",
		"gc",
		"selection",
		"selection",
		"length",
		"selection",
		"length",
		"DND",
		"error",
		"DND",
		"error",
		"event",
		"area",
		"SWT",
		"event",
		"area",
		"event",
		"SWT",
		"event",
		"event",
		"leftMargin",
		"wordWrap",
		"ST",
		"leftMargin",
		"event",
		"event",
		"area",
		"leftMargin",
		"rightMargin",
		"wordWrap",
		"ST",
		"event",
		"area",
		"leftMargin",
		"rightMargin",
		"autoScrollDistance",
		"distance",
		"autoScrollDirection",
		"direction",
		"direction",
		"SWT",
		"timer",
		"autoScrollDirection",
		"SWT",
		"autoScrollDistance",
		"lines",
		"display",
		"TIMER_INTERVAL",
		"direction",
		"SWT",
		"timer",
		"autoScrollDirection",
		"SWT",
		"autoScrollDistance",
		"lines",
		"display",
		"TIMER_INTERVAL",
		"direction",
		"ST",
		"timer",
		"autoScrollDirection",
		"ST",
		"display",
		"TIMER_INTERVAL",
		"direction",
		"ST",
		"timer",
		"autoScrollDirection",
		"ST",
		"display",
		"TIMER_INTERVAL",
		"timer",
		"autoScrollDirection",
		"direction",
		"display",
		"TIMER_INTERVAL",
		"timer",
		"event",
		"selection",
		"selection",
		"event",
		"selection",
		"event",
		"selection",
		"event",
		"caretOffset",
		"content",
		"caretOffset",
		"content",
		"line",
		"caretOffset",
		"lineOffset",
		"lineOffset",
		"content",
		"line",
		"event",
		"lineOffset",
		"content",
		"line",
		"event",
		"caretOffset",
		"content",
		"line",
		"renderer",
		"lineText",
		"lineOffset",
		"layout",
		"caretOffset",
		"lineOffset",
		"SWT",
		"renderer",
		"layout",
		"event",
		"start",
		"lineOffset",
		"event",
		"caretOffset",
		"event",
		"textLimit",
		"content",
		"selection",
		"selection",
		"textLimit",
		"event",
		"event",
		"selection",
		"event",
		"selection",
		"key",
		"SWT",
		"key",
		"SWT",
		"event",
		"selection",
		"selection",
		"overwrite",
		"key",
		"TAB",
		"content",
		"event",
		"content",
		"lineIndex",
		"content",
		"lineIndex",
		"event",
		"lineOffset",
		"line",
		"event",
		"event",
		"key",
		"event",
		"key",
		"event",
		"event",
		"content",
		"caretOffset",
		"length",
		"caretOffset",
		"length",
		"caretOffset",
		"caretOffset",
		"advancing",
		"selection",
		"selection",
		"caretOffset",
		"selection",
		"caretLine",
		"caretLine",
		"advancing",
		"selection",
		"selection",
		"caretOffset",
		"selection",
		"caretLine",
		"caretLine",
		"event",
		"selection",
		"selection",
		"event",
		"selection",
		"event",
		"selection",
		"event",
		"caretOffset",
		"content",
		"content",
		"caretOffset",
		"content",
		"line",
		"content",
		"line",
		"caretOffset",
		"lineOffset",
		"lineLength",
		"event",
		"caretOffset",
		"event",
		"content",
		"line",
		"event",
		"caretOffset",
		"event",
		"caretOffset",
		"line",
		"event",
		"selection",
		"selection",
		"event",
		"event",
		"caretOffset",
		"event",
		"caretOffset",
		"event",
		"selection",
		"selection",
		"event",
		"event",
		"caretOffset",
		"event",
		"caretOffset",
		"event",
		"caretLine",
		"content",
		"caretLine",
		"caretOffset",
		"columnX",
		"caretLine",
		"caretLine",
		"content",
		"caretLine",
		"content",
		"caretLine",
		"lineOffset",
		"lineLength",
		"caretOffset",
		"lineEndOffset",
		"caretOffset",
		"lineEndOffset",
		"content",
		"caretLine",
		"caretOffset",
		"lineOffset",
		"caretOffset",
		"lineOffset",
		"caretLine",
		"caretLine",
		"caretLine",
		"caretOffset",
		"columnX",
		"caretLine",
		"caretLine",
		"y",
		"verticalScrollOffset",
		"lineHeight",
		"content",
		"advancing",
		"updateCaretDirection",
		"line",
		"lineCount",
		"line",
		"lineCount",
		"line",
		"line",
		"newCaretOffset",
		"x",
		"line",
		"mouseDoubleClick",
		"newCaretOffset",
		"x",
		"newCaretOffset",
		"line",
		"newCaretLine",
		"content",
		"newCaretOffset",
		"y",
		"y",
		"x",
		"x",
		"wordWrap",
		"newCaretLine",
		"content",
		"caretOffset",
		"newCaretOffset",
		"caretOffset",
		"advancing",
		"oldAdvancing",
		"caretOffset",
		"newCaretOffset",
		"select",
		"select",
		"caretOffset",
		"newCaretOffset",
		"caretOffset",
		"selection",
		"caretOffset",
		"selection",
		"caretOffset",
		"selection",
		"selectionAnchor",
		"selection",
		"ST",
		"ST",
		"newCaretOffset",
		"selectionAnchor",
		"selectionAnchor",
		"selection",
		"selectionAnchor",
		"doubleClickSelection",
		"newCaretOffset",
		"selectionAnchor",
		"selectionAnchor",
		"selection",
		"selectionAnchor",
		"doubleClickSelection",
		"x",
		"x",
		"caretOffset",
		"selection",
		"wordOffset",
		"newCaretOffset",
		"wordOffset",
		"newCaretOffset",
		"content",
		"wordOffset",
		"line",
		"newCaretOffset",
		"wordOffset",
		"newCaretOffset",
		"content",
		"columnX",
		"horizontalScrollOffset",
		"caretLine",
		"caretLine",
		"lineCount",
		"lineCount",
		"Math",
		"lineCount",
		"caretLine",
		"lines",
		"scrollLines",
		"Math",
		"scrollLines",
		"caretLine",
		"scrollLines",
		"caretOffset",
		"columnX",
		"caretLine",
		"select",
		"ST",
		"scrollOffset",
		"verticalScrollOffset",
		"scrollLines",
		"scrollOffset",
		"pageSize",
		"verticalMaximum",
		"scrollOffset",
		"verticalMaximum",
		"pageSize",
		"scrollOffset",
		"verticalScrollOffset",
		"scrollOffset",
		"caretLine",
		"oldHScrollOffset",
		"horizontalScrollOffset",
		"columnX",
		"oldColumnX",
		"hScrollChange",
		"content",
		"line",
		"content",
		"line",
		"caretOffset",
		"bottomCaretOffset",
		"caretOffset",
		"bottomCaretOffset",
		"content",
		"topIndex",
		"caretOffset",
		"topCaretOffset",
		"caretOffset",
		"topCaretOffset",
		"topIndex",
		"columnX",
		"horizontalScrollOffset",
		"caretLine",
		"Math",
		"Math",
		"caretLine",
		"lines",
		"caretLine",
		"scrollLines",
		"caretOffset",
		"columnX",
		"caretLine",
		"select",
		"ST",
		"scrollOffset",
		"Math",
		"verticalScrollOffset",
		"scrollLines",
		"scrollOffset",
		"verticalScrollOffset",
		"scrollOffset",
		"caretLine",
		"oldHScrollOffset",
		"horizontalScrollOffset",
		"columnX",
		"oldColumnX",
		"hScrollChange",
		"selectionAnchor",
		"selectionAnchor",
		"selection",
		"direction",
		"ST",
		"caretOffset",
		"selection",
		"redrawEnd",
		"selection",
		"redrawStart",
		"selection",
		"caretOffset",
		"selection",
		"selectionAnchor",
		"redrawEnd",
		"selection",
		"selection",
		"selectionAnchor",
		"selectionAnchor",
		"selection",
		"caretOffset",
		"selection",
		"redrawEnd",
		"selection",
		"redrawStart",
		"selection",
		"caretOffset",
		"caretOffset",
		"selection",
		"redrawStart",
		"selection",
		"redrawEnd",
		"selection",
		"caretOffset",
		"selection",
		"selectionAnchor",
		"redrawStart",
		"selection",
		"selection",
		"selectionAnchor",
		"selectionAnchor",
		"selection",
		"caretOffset",
		"selection",
		"redrawStart",
		"selection",
		"redrawEnd",
		"selection",
		"caretOffset",
		"redrawStart",
		"redrawEnd",
		"redrawStart",
		"redrawEnd",
		"redrawStart",
		"content",
		"caretLine",
		"caretOffset",
		"lineOffset",
		"advancing",
		"offsetInLine",
		"content",
		"caretLine",
		"caretOffset",
		"caretOffset",
		"caretLine",
		"caretLine",
		"content",
		"caretLine",
		"caretOffset",
		"content",
		"caretLine",
		"caretLine",
		"content",
		"caretLine",
		"caretOffset",
		"lineOffset",
		"advancing",
		"offsetInLine",
		"caretOffset",
		"caretOffset",
		"caretLine",
		"caretLine",
		"caretLine",
		"caretLine",
		"lineOffset",
		"content",
		"caretLine",
		"caretOffset",
		"lineOffset",
		"content",
		"caretLine",
		"caretLine",
		"lineStartOffset",
		"content",
		"caretLine",
		"oldColumnX",
		"columnX",
		"content",
		"caretLine",
		"caretLine",
		"caretOffset",
		"lineStartOffset",
		"caretLine",
		"content",
		"caretOffset",
		"content",
		"caretLine",
		"ST",
		"caretLine",
		"columnX",
		"oldColumnX",
		"content",
		"caretLine",
		"oldColumnX",
		"columnX",
		"content",
		"caretLine",
		"caretLine",
		"caretOffset",
		"lineStartOffset",
		"caretLine",
		"caretOffset",
		"caretLine",
		"caretLine",
		"ST",
		"columnX",
		"oldColumnX",
		"content",
		"caretLine",
		"oldColumnX",
		"columnX",
		"content",
		"caretLine",
		"caretLine",
		"caretOffset",
		"lineStartOffset",
		"lines",
		"columnX",
		"oldColumnX",
		"content",
		"caretLine",
		"oldColumnX",
		"columnX",
		"content",
		"caretLine",
		"caretLine",
		"caretOffset",
		"lineStartOffset",
		"lines",
		"columnX",
		"oldColumnX",
		"caretOffset",
		"advancing",
		"content",
		"caretOffset",
		"content",
		"newCaretOffset",
		"caretOffset",
		"newCaretOffset",
		"advancing",
		"caretOffset",
		"caretOffset",
		"caretLine",
		"content",
		"caretOffset",
		"wordWrap",
		"caretLine",
		"content",
		"caretOffset",
		"content",
		"caretLine",
		"caretLine",
		"caretLine",
		"caretOffset",
		"caretOffset",
		"caretOffset",
		"caretOffset",
		"selection",
		"selection",
		"caretOffset",
		"selection",
		"caretLine",
		"caretLine",
		"selection",
		"selection",
		"caretOffset",
		"selection",
		"caretLine",
		"caretLine",
		"clearBackground",
		"x",
		"leftMargin",
		"y",
		"topMargin",
		"width",
		"height",
		"y",
		"verticalScrollOffset",
		"lineHeight",
		"y",
		"height",
		"startLine",
		"topIndex",
		"lineHeight",
		"topIndex",
		"lineHeight",
		"verticalScrollOffset",
		"paintYFromTopLine",
		"topLineOffset",
		"topMargin",
		"content",
		"lineCount",
		"startLine",
		"paintY",
		"endY",
		"i",
		"lineCount",
		"i",
		"paintY",
		"lineHeight",
		"content",
		"i",
		"renderer",
		"line",
		"i",
		"paintY",
		"gc",
		"background",
		"foreground",
		"clearBackground",
		"gc",
		"autoScrollDirection",
		"SWT",
		"background",
		"SWT",
		"background",
		"renderer",
		"bidiColoring",
		"lineHeight",
		"topIndex",
		"lineHeight",
		"verticalScrollOffset",
		"lineCount",
		"partialTopLineHeight",
		"lineHeight",
		"Math",
		"content",
		"topIndex",
		"Math",
		"lineCount",
		"caretOffset",
		"lineXOffset",
		"leftMargin",
		"horizontalScrollOffset",
		"renderer",
		"line",
		"lineOffset",
		"layout",
		"x",
		"trailing",
		"advancing",
		"trailing",
		"line",
		"offsetInLine",
		"trailing",
		"lineLength",
		"offsetInLine",
		"lineLength",
		"advancing",
		"offsetInLine",
		"offset",
		"Character",
		"line",
		"offset",
		"offset",
		"offset",
		"Character",
		"line",
		"offset",
		"level",
		"level",
		"layout",
		"offset",
		"offsetInLine",
		"trailing",
		"layout",
		"offsetInLine",
		"advancing",
		"level",
		"trailingLevel",
		"renderer",
		"layout",
		"offsetInLine",
		"caret",
		"caret",
		"TextTransfer",
		"clipboard",
		"plainTextTransfer",
		"clipboardType",
		"content",
		"lineIndex",
		"content",
		"lineIndex",
		"renderer",
		"line",
		"lineOffset",
		"offset",
		"lineOffset",
		"offset",
		"layout",
		"offset",
		"SWT",
		"offset",
		"lineOffset",
		"renderer",
		"layout",
		"offset",
		"content",
		"lineIndex",
		"content",
		"lineIndex",
		"renderer",
		"line",
		"lineOffset",
		"offset",
		"lineOffset",
		"offset",
		"layout",
		"offset",
		"SWT",
		"offset",
		"lineOffset",
		"renderer",
		"layout",
		"offset",
		"logicalContent",
		"doubleClickEnabled",
		"editable",
		"foreground",
		"SWT",
		"foreground",
		"gc",
		"gc",
		"increment",
		"horizontalScrollOffset",
		"horizontalScrollOffset",
		"keyActionMap",
		"key",
		"action",
		"intAction",
		"SWT",
		"intAction",
		"action",
		"intAction",
		"content",
		"index",
		"index",
		"logicalContent",
		"SWT",
		"SWT",
		"userLineBackground",
		"lineBackground",
		"defaultLineStyler",
		"index",
		"lineBackground",
		"LineGetBackground",
		"lineOffset",
		"line",
		"lineHeight",
		"lineCount",
		"lineHeight",
		"lineCount",
		"lineCount",
		"offset",
		"offset",
		"SWT",
		"SWT",
		"logicalContent",
		"offset",
		"content",
		"eventType",
		"event",
		"logicalContent",
		"wordWrap",
		"logicalContent",
		"lineOffset",
		"event",
		"logicalContent",
		"lineIndex",
		"event",
		"logicalContent",
		"lineIndex",
		"event",
		"lineOffset",
		"event",
		"line",
		"eventType",
		"event",
		"event",
		"lineHeight",
		"wordWrap",
		"lineCache",
		"content",
		"lineCache",
		"content",
		"lineCache",
		"LineGetStyle",
		"lineOffset",
		"line",
		"offset",
		"offset",
		"SWT",
		"SWT",
		"content",
		"offset",
		"content",
		"line",
		"content",
		"line",
		"lineContent",
		"line",
		"offset",
		"lineOffset",
		"line",
		"lineHeight",
		"verticalScrollOffset",
		"x",
		"y",
		"lineIndex",
		"lineIndex",
		"lineIndex",
		"logicalContent",
		"SWT",
		"SWT",
		"logicalContent",
		"lineIndex",
		"point",
		"SWT",
		"SWT",
		"point",
		"verticalScrollOffset",
		"point",
		"horizontalScrollOffset",
		"SWT",
		"SWT",
		"line",
		"point",
		"lineHeight",
		"line",
		"content",
		"SWT",
		"SWT",
		"lineText",
		"content",
		"line",
		"lineOffset",
		"content",
		"line",
		"point",
		"leftMargin",
		"horizontalScrollOffset",
		"layout",
		"renderer",
		"lineText",
		"lineOffset",
		"layout",
		"x",
		"rect",
		"rect",
		"renderer",
		"layout",
		"SWT",
		"SWT",
		"offsetInLine",
		"layout",
		"x",
		"trailing",
		"offsetInLine",
		"lineText",
		"offsetInLine",
		"Math",
		"lineText",
		"offsetInLine",
		"trailing",
		"renderer",
		"layout",
		"lineOffset",
		"offsetInLine",
		"content",
		"line",
		"content",
		"line",
		"lineText",
		"lineOffset",
		"x",
		"lineOffset",
		"SWT",
		"SWT",
		"Compatibility",
		"lineHeight",
		"Math",
		"content",
		"topIndex",
		"partialLineCount",
		"writer",
		"writer",
		"logicalContent",
		"writer",
		"logicalContent",
		"end",
		"logicalContent",
		"endLine",
		"logicalContent",
		"endLine",
		"startLine",
		"i",
		"endLine",
		"i",
		"writer",
		"logicalContent",
		"i",
		"logicalContent",
		"i",
		"i",
		"endLine",
		"writer",
		"PlatformLineDelimiter",
		"end",
		"endLineOffset",
		"endLineText",
		"writer",
		"PlatformLineDelimiter",
		"writer",
		"writer",
		"selection",
		"selection",
		"selection",
		"selection",
		"selection",
		"selectionBackground",
		"SWT",
		"selectionBackground",
		"selectionForeground",
		"SWT",
		"selectionForeground",
		"content",
		"selection",
		"selection",
		"selection",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"style",
		"LineGetSegments",
		"line",
		"lineOffset",
		"LineGetSegments",
		"lineOffset",
		"line",
		"line",
		"event",
		"event",
		"event",
		"segments",
		"lineLength",
		"event",
		"event",
		"SWT",
		"SWT",
		"i",
		"segmentCount",
		"i",
		"event",
		"i",
		"event",
		"i",
		"event",
		"i",
		"lineLength",
		"SWT",
		"SWT",
		"event",
		"segmentCount",
		"lineLength",
		"segments",
		"segmentCount",
		"System",
		"event",
		"segments",
		"segmentCount",
		"segments",
		"segmentCount",
		"lineLength",
		"segments",
		"event",
		"segments",
		"line",
		"bidiColoring",
		"lineLength",
		"event",
		"renderer",
		"lineOffset",
		"line",
		"event",
		"styles",
		"event",
		"styles",
		"lineLength",
		"k",
		"styles",
		"styles",
		"k",
		"styles",
		"k",
		"lineLength",
		"k",
		"styles",
		"k",
		"k",
		"i",
		"styles",
		"i",
		"styles",
		"i",
		"Math",
		"style",
		"lineOffset",
		"Math",
		"style",
		"style",
		"lineOffset",
		"styleLineStart",
		"styleLineEnd",
		"Math",
		"styleLineEnd",
		"line",
		"i",
		"count",
		"styleLineStart",
		"offsets",
		"count",
		"styleLineStart",
		"offsets",
		"count",
		"styleLineEnd",
		"offsets",
		"count",
		"styleLineEnd",
		"offsets",
		"count",
		"style",
		"styles",
		"i",
		"offsets",
		"count",
		"Math",
		"offsets",
		"count",
		"styleLineStart",
		"offsets",
		"count",
		"Math",
		"offsets",
		"count",
		"styleLineEnd",
		"styleLineStart",
		"offsets",
		"count",
		"offsets",
		"count",
		"styleLineStart",
		"count",
		"offsets",
		"count",
		"styleLineEnd",
		"count",
		"lineLength",
		"offsets",
		"count",
		"offsets",
		"count",
		"lineLength",
		"count",
		"count",
		"offsets",
		"offsets",
		"count",
		"System",
		"offsets",
		"result",
		"count",
		"result",
		"offset",
		"offset",
		"SWT",
		"SWT",
		"userLineStyle",
		"defaultLineStyler",
		"offset",
		"userLineStyle",
		"styles",
		"defaultLineStyler",
		"styles",
		"styles",
		"start",
		"length",
		"start",
		"end",
		"start",
		"end",
		"contentLength",
		"SWT",
		"SWT",
		"userLineStyle",
		"styles",
		"defaultLineStyler",
		"start",
		"length",
		"styles",
		"styles",
		"styles",
		"style",
		"start",
		"styles",
		"newStyle",
		"newStyle",
		"start",
		"newStyle",
		"newStyle",
		"start",
		"styles",
		"newStyle",
		"style",
		"style",
		"start",
		"length",
		"styles",
		"newStyle",
		"start",
		"length",
		"newStyle",
		"styles",
		"newStyle",
		"styles",
		"styles",
		"style",
		"start",
		"styles",
		"newStyle",
		"newStyle",
		"start",
		"newStyle",
		"newStyle",
		"start",
		"styles",
		"newStyle",
		"style",
		"styles",
		"styles",
		"style",
		"style",
		"start",
		"length",
		"styles",
		"styles",
		"newStyle",
		"start",
		"length",
		"newStyle",
		"styles",
		"styles",
		"newStyle",
		"styles",
		"styles",
		"tabLength",
		"content",
		"start",
		"start",
		"contentLength",
		"end",
		"end",
		"contentLength",
		"start",
		"end",
		"SWT",
		"SWT",
		"content",
		"start",
		"end",
		"start",
		"start",
		"start",
		"contentLength",
		"end",
		"end",
		"contentLength",
		"start",
		"end",
		"SWT",
		"SWT",
		"content",
		"start",
		"content",
		"end",
		"lineStart",
		"lineHeight",
		"lineEnd",
		"lineHeight",
		"y",
		"lineStart",
		"i",
		"lineEnd",
		"i",
		"content",
		"i",
		"content",
		"i",
		"renderer",
		"line",
		"lineOffset",
		"i",
		"lineStart",
		"i",
		"lineEnd",
		"rect",
		"layout",
		"start",
		"lineOffset",
		"end",
		"lineOffset",
		"i",
		"lineStart",
		"rect",
		"layout",
		"start",
		"lineOffset",
		"line",
		"i",
		"lineEnd",
		"rect",
		"layout",
		"end",
		"lineOffset",
		"rect",
		"layout",
		"left",
		"Math",
		"left",
		"rect",
		"right",
		"Math",
		"right",
		"rect",
		"rect",
		"renderer",
		"layout",
		"rect",
		"left",
		"y",
		"right",
		"left",
		"height",
		"rect",
		"leftMargin",
		"horizontalScrollOffset",
		"rect",
		"verticalScrollOffset",
		"rect",
		"start",
		"length",
		"start",
		"end",
		"start",
		"end",
		"contentLength",
		"SWT",
		"SWT",
		"content",
		"start",
		"length",
		"textLimit",
		"topIndex",
		"wordWrap",
		"content",
		"topIndex",
		"logicalTopIndex",
		"logicalContent",
		"visualLineOffset",
		"logicalTopIndex",
		"verticalScrollOffset",
		"lineHeight",
		"SWT",
		"updateCaretDirection",
		"caretDirection",
		"SWT",
		"caretDirection",
		"updateCaretDirection",
		"content",
		"caretLine",
		"content",
		"caretLine",
		"caretOffset",
		"lineOffset",
		"line",
		"lineLength",
		"SWT",
		"SWT",
		"advancing",
		"offset",
		"offset",
		"offset",
		"lineLength",
		"offset",
		"offset",
		"offset",
		"Character",
		"line",
		"offset",
		"offset",
		"offset",
		"Character",
		"line",
		"offset",
		"SWT",
		"SWT",
		"renderer",
		"line",
		"lineOffset",
		"layout",
		"offset",
		"renderer",
		"layout",
		"level",
		"SWT",
		"SWT",
		"content",
		"caretOffset",
		"leftMargin",
		"wordWrap",
		"columnX",
		"leftColumnX",
		"caretLine",
		"content",
		"caretOffset",
		"content",
		"caretLine",
		"caretLine",
		"caretLine",
		"logicalContent",
		"offset",
		"logicalContent",
		"line",
		"logicalContent",
		"line",
		"lineText",
		"offset",
		"offset",
		"offset",
		"lineOffset",
		"lineLength",
		"line",
		"offset",
		"logicalContent",
		"line",
		"renderer",
		"lineText",
		"lineOffset",
		"offset",
		"lineOffset",
		"offset",
		"layout",
		"offset",
		"SWT",
		"offset",
		"lineOffset",
		"renderer",
		"layout",
		"offset",
		"logicalContent",
		"offset",
		"logicalContent",
		"line",
		"logicalContent",
		"line",
		"lineText",
		"offset",
		"offset",
		"offset",
		"lineOffset",
		"lineLength",
		"line",
		"offset",
		"logicalContent",
		"line",
		"offset",
		"lineOffset",
		"lineText",
		"offset",
		"Compatibility",
		"ch",
		"offset",
		"lineLength",
		"Compatibility",
		"ch",
		"letterOrDigit",
		"Compatibility",
		"ch",
		"offset",
		"ch",
		"lineText",
		"offset",
		"offset",
		"lineLength",
		"Compatibility",
		"ch",
		"letterOrDigit",
		"Compatibility",
		"ch",
		"offset",
		"offset",
		"lineOffset",
		"offset",
		"logicalContent",
		"offset",
		"logicalContent",
		"line",
		"logicalContent",
		"line",
		"offset",
		"offset",
		"offset",
		"lineOffset",
		"line",
		"lineText",
		"logicalContent",
		"line",
		"offset",
		"logicalContent",
		"line",
		"lineText",
		"renderer",
		"lineText",
		"lineOffset",
		"offset",
		"lineOffset",
		"offset",
		"layout",
		"offset",
		"SWT",
		"offset",
		"lineOffset",
		"renderer",
		"layout",
		"offset",
		"wordWrap",
		"line",
		"lineIndex",
		"content",
		"content",
		"lineIndex",
		"lineLength",
		"offsetInLine",
		"offsetInLine",
		"endLineOffset",
		"offsetInLine",
		"lineLength",
		"lineLength",
		"offsetInLine",
		"lineLength",
		"content",
		"lineIndex",
		"renderer",
		"line",
		"lineOffset",
		"advancing",
		"offsetInLine",
		"x",
		"layout",
		"offsetInLine",
		"x",
		"layout",
		"offsetInLine",
		"renderer",
		"layout",
		"x",
		"leftMargin",
		"horizontalScrollOffset",
		"string",
		"SWT",
		"SWT",
		"sel",
		"sel",
		"string",
		"textChangeListener",
		"event",
		"event",
		"event",
		"logicalContent",
		"content",
		"content",
		"textChangeListener",
		"defaultLineStyler",
		"logicalContent",
		"defaultLineStyler",
		"userLineStyle",
		"LineGetStyle",
		"typedListener",
		"userLineBackground",
		"LineGetBackground",
		"typedListener",
		"listener",
		"event",
		"SWT",
		"event",
		"SWT",
		"event",
		"SWT",
		"event",
		"SWT",
		"event",
		"SWT",
		"event",
		"SWT",
		"event",
		"SWT",
		"event",
		"SWT",
		"event",
		"SWT",
		"event",
		"SWT",
		"event",
		"SWT",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"listener",
		"verticalBar",
		"verticalBar",
		"SWT",
		"event",
		"horizontalBar",
		"horizontalBar",
		"SWT",
		"event",
		"content",
		"horizontalScrollOffset",
		"lineCache",
		"selection",
		"wordWrap",
		"start",
		"length",
		"content",
		"start",
		"content",
		"end",
		"verticalScrollOffset",
		"lineHeight",
		"firstLine",
		"partialBottomIndex",
		"lastLine",
		"partialTopIndex",
		"partialTopIndex",
		"firstLine",
		"firstLine",
		"partialTopIndex",
		"offsetInFirstLine",
		"offsetInFirstLine",
		"start",
		"content",
		"firstLine",
		"partialBottomIndex",
		"lastLine",
		"lastLine",
		"partialBottomIndex",
		"end",
		"content",
		"lastLine",
		"firstLine",
		"offsetInFirstLine",
		"lastLine",
		"end",
		"clearBackground",
		"lastLine",
		"firstLine",
		"lastLine",
		"lineHeight",
		"verticalScrollOffset",
		"firstLine",
		"lineHeight",
		"verticalScrollOffset",
		"redrawY",
		"clientArea",
		"redrawStopY",
		"redrawY",
		"clearBackground",
		"rtfWriter",
		"SWT",
		"listener",
		"SWT",
		"event",
		"event",
		"SWT",
		"clipboard",
		"ibeamCursor",
		"renderer",
		"renderer",
		"renderer",
		"content",
		"content",
		"textChangeListener",
		"content",
		"defaultCaret",
		"defaultCaret",
		"defaultCaret",
		"leftCaretBitmap",
		"leftCaretBitmap",
		"leftCaretBitmap",
		"rightCaretBitmap",
		"rightCaretBitmap",
		"rightCaretBitmap",
		"defaultLineStyler",
		"defaultLineStyler",
		"defaultLineStyler",
		"BidiUtil",
		"handle",
		"selectionBackground",
		"selectionForeground",
		"logicalContent",
		"textChangeListener",
		"lineCache",
		"ibeamCursor",
		"selection",
		"doubleClickSelection",
		"keyActionMap",
		"background",
		"foreground",
		"clipboard",
		"horizontalScrollOffset",
		"scrollPixel",
		"advancing",
		"event",
		"action",
		"event",
		"event",
		"action",
		"event",
		"event",
		"action",
		"SWT",
		"event",
		"SWT",
		"event",
		"event",
		"event",
		"action",
		"c",
		"event",
		"action",
		"SWT",
		"IS_CARBON",
		"ignore",
		"event",
		"SWT",
		"event",
		"SWT",
		"SWT",
		"IS_MOTIF",
		"ignore",
		"event",
		"SWT",
		"event",
		"SWT",
		"SWT",
		"ignore",
		"event",
		"SWT",
		"event",
		"SWT",
		"event",
		"SWT",
		"SWT",
		"event",
		"SWT",
		"SWT",
		"ignore",
		"event",
		"event",
		"SWT",
		"event",
		"SWT",
		"event",
		"SWT",
		"event",
		"TAB",
		"event",
		"action",
		"clipboardSelection",
		"clipboardSelection",
		"selection",
		"selection",
		"verifyEvent",
		"event",
		"verifyEvent",
		"event",
		"verifyEvent",
		"event",
		"verifyEvent",
		"VerifyKey",
		"verifyEvent",
		"verifyEvent",
		"event",
		"clipboardSelection",
		"clipboardSelection",
		"selection",
		"clipboardSelection",
		"selection",
		"selection",
		"selection",
		"selection",
		"selection",
		"selection",
		"DND",
		"error",
		"DND",
		"error",
		"clipboardSelection",
		"event",
		"doubleClickEnabled",
		"event",
		"topMargin",
		"mouseDoubleClick",
		"caretOffset",
		"caretOffset",
		"caretOffset",
		"caretOffset",
		"doubleClickSelection",
		"selection",
		"selection",
		"mouseDown",
		"mouseDoubleClick",
		"event",
		"DND",
		"text",
		"text",
		"event",
		"event",
		"topMargin",
		"x",
		"y",
		"e",
		"selection",
		"e",
		"selection",
		"e",
		"text",
		"e",
		"event",
		"IS_CARBON",
		"event",
		"SWT",
		"event",
		"SWT",
		"event",
		"topMargin",
		"event",
		"event",
		"select",
		"mouseDown",
		"event",
		"SWT",
		"event",
		"topMargin",
		"event",
		"event",
		"event",
		"mouseDown",
		"mouseDoubleClick",
		"event",
		"topMargin",
		"event",
		"selection",
		"selection",
		"selection",
		"selection",
		"selection",
		"DND",
		"error",
		"DND",
		"error",
		"Math",
		"event",
		"topMargin",
		"verticalScrollOffset",
		"lineHeight",
		"startLine",
		"topIndex",
		"lineHeight",
		"topIndex",
		"lineHeight",
		"verticalScrollOffset",
		"paintYFromTopLine",
		"topLineOffset",
		"topMargin",
		"event",
		"event",
		"startY",
		"event",
		"event",
		"startLine",
		"startY",
		"renderHeight",
		"clientAreaHeight",
		"clientAreaWidth",
		"clientAreaHeight",
		"clientArea",
		"clientAreaWidth",
		"clientArea",
		"oldWidth",
		"clientAreaWidth",
		"rightMargin",
		"oldWidth",
		"clientAreaWidth",
		"oldWidth",
		"clientAreaWidth",
		"rightMargin",
		"x",
		"rightMargin",
		"oldHeight",
		"oldHeight",
		"clientAreaHeight",
		"bottomMargin",
		"oldHeight",
		"clientAreaHeight",
		"oldHeight",
		"clientAreaHeight",
		"bottomMargin",
		"y",
		"oldWidth",
		"bottomMargin",
		"wordWrap",
		"oldWidth",
		"clientAreaWidth",
		"oldWidth",
		"clientAreaHeight",
		"oldHeight",
		"content",
		"topIndex",
		"oldHeight",
		"lineHeight",
		"Compatibility",
		"clientAreaHeight",
		"oldHeight",
		"lineHeight",
		"oldBottomIndex",
		"Math",
		"oldBottomIndex",
		"lineCount",
		"newItemCount",
		"Math",
		"newItemCount",
		"lineCount",
		"oldBottomIndex",
		"lineCache",
		"oldBottomIndex",
		"newItemCount",
		"oldHeight",
		"clientAreaHeight",
		"lineCache",
		"lastTextChangeStart",
		"lastTextChangeNewLineCount",
		"lastTextChangeReplaceLineCount",
		"lastTextChangeNewCharCount",
		"lastTextChangeReplaceCharCount",
		"lastTextChangeStart",
		"lastTextChangeReplaceCharCount",
		"lastTextChangeNewCharCount",
		"lastTextChangeReplaceLineCount",
		"lastTextChangeReplaceCharCount",
		"lastTextChangeNewLineCount",
		"lastTextChangeReplaceLineCount",
		"content",
		"lastTextChangeStart",
		"startLine",
		"lineHeight",
		"verticalScrollOffset",
		"topMargin",
		"DOUBLE_BUFFER",
		"caret",
		"caretVisible",
		"caret",
		"caret",
		"gc",
		"startLine",
		"startY",
		"lineHeight",
		"caret",
		"caret",
		"caretVisible",
		"gc",
		"startY",
		"lineHeight",
		"event",
		"event",
		"event",
		"event",
		"event",
		"event",
		"lastTextChangeStart",
		"event",
		"lastTextChangeNewLineCount",
		"event",
		"lastTextChangeNewCharCount",
		"event",
		"lastTextChangeReplaceLineCount",
		"event",
		"lastTextChangeReplaceCharCount",
		"event",
		"firstLine",
		"content",
		"event",
		"textChangeY",
		"firstLine",
		"lineHeight",
		"verticalScrollOffset",
		"topMargin",
		"isMultiLineChange",
		"textChangeY",
		"event",
		"event",
		"defaultLineStyler",
		"defaultLineStyler",
		"event",
		"content",
		"event",
		"event",
		"caretOffset",
		"newEndOfText",
		"caretOffset",
		"newEndOfText",
		"event",
		"SWT",
		"SWT",
		"SWT",
		"event",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"event",
		"editable",
		"event",
		"SWT",
		"event",
		"accessible",
		"e",
		"accessible",
		"e",
		"StyledText",
		"StyledText",
		"e",
		"selection",
		"e",
		"selection",
		"accessible",
		"e",
		"ACC",
		"state",
		"ACC",
		"state",
		"ACC",
		"state",
		"ACC",
		"state",
		"ACC",
		"e",
		"state",
		"e",
		"StyledText",
		"SWT",
		"accessible",
		"ACC",
		"renderer",
		"renderer",
		"renderer",
		"tabLength",
		"lineHeight",
		"renderer",
		"wordWrap",
		"content",
		"renderer",
		"logicalContent",
		"updateCaretDirection",
		"action",
		"ST",
		"caretLine",
		"oldColumnX",
		"columnX",
		"oldHScrollOffset",
		"horizontalScrollOffset",
		"caretLine",
		"hScrollChange",
		"oldHScrollOffset",
		"horizontalScrollOffset",
		"columnX",
		"oldColumnX",
		"hScrollChange",
		"ST",
		"caretLine",
		"oldColumnX",
		"columnX",
		"oldHScrollOffset",
		"horizontalScrollOffset",
		"caretLine",
		"hScrollChange",
		"oldHScrollOffset",
		"horizontalScrollOffset",
		"columnX",
		"oldColumnX",
		"hScrollChange",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"ST",
		"overwrite",
		"overwrite",
		"IS_GTK",
		"BidiUtil",
		"isMirrored",
		"content",
		"offset",
		"content",
		"line",
		"offset",
		"lineOffset",
		"offsetInLine",
		"content",
		"line",
		"isMirrored",
		"verticalScrollOffset",
		"lineHeight",
		"firstLine",
		"partialBottomIndex",
		"lastLine",
		"partialTopIndex",
		"notVisible",
		"SWT",
		"event",
		"SWT",
		"event",
		"event",
		"event",
		"event",
		"ExtendedModify",
		"styledTextEvent",
		"logicalContent",
		"styledTextEvent",
		"event",
		"styledTextEvent",
		"event",
		"event",
		"styledTextEvent",
		"content",
		"event",
		"replacedLength",
		"updateCaret",
		"event",
		"content",
		"event",
		"content",
		"lineIndex",
		"content",
		"lineIndex",
		"renderer",
		"lineText",
		"lineOffset",
		"layout",
		"event",
		"lineOffset",
		"content",
		"event",
		"lineIndex",
		"lineIndexEnd",
		"renderer",
		"layout",
		"lineOffset",
		"content",
		"lineIndexEnd",
		"lineText",
		"content",
		"lineIndexEnd",
		"layout",
		"renderer",
		"lineText",
		"lineOffset",
		"layout",
		"event",
		"lineOffset",
		"renderer",
		"layout",
		"advancing",
		"levelStart",
		"levelEnd",
		"content",
		"event",
		"replacedLength",
		"event",
		"updateCaret",
		"event",
		"event",
		"event",
		"ExtendedModify",
		"ExtendedModify",
		"styledTextEvent",
		"text",
		"DND",
		"text",
		"text",
		"event",
		"selection",
		"event",
		"selection",
		"event",
		"text",
		"event",
		"clientArea",
		"renderHeight",
		"content",
		"SWT",
		"SWT",
		"lineCount",
		"DOUBLE_BUFFER",
		"lastPaintTopIndex",
		"topIndex",
		"lastPaintTopIndex",
		"topIndex",
		"doubleBuffer",
		"paintY",
		"paintHeight",
		"renderHeight",
		"lineBuffer",
		"clientArea",
		"renderHeight",
		"lineGC",
		"lineBuffer",
		"gcStyle",
		"lineGC",
		"lineGC",
		"foreground",
		"lineGC",
		"background",
		"paintY",
		"startY",
		"paintHeight",
		"startY",
		"renderHeight",
		"lineBuffer",
		"lineGC",
		"gc",
		"startLine",
		"paintY",
		"paintHeight",
		"i",
		"lineCount",
		"i",
		"paintY",
		"lineHeight",
		"content",
		"i",
		"renderer",
		"line",
		"i",
		"paintY",
		"lineGC",
		"background",
		"foreground",
		"paintY",
		"paintHeight",
		"lineGC",
		"background",
		"lineGC",
		"paintY",
		"clientArea",
		"paintHeight",
		"paintY",
		"doubleBuffer",
		"lineGC",
		"background",
		"clientArea",
		"startY",
		"gc",
		"lineBuffer",
		"startY",
		"lineGC",
		"lineBuffer",
		"gc",
		"background",
		"clientArea",
		"options",
		"options",
		"options",
		"options",
		"printer",
		"options",
		"printer",
		"options",
		"options",
		"options",
		"options",
		"printer",
		"SWT",
		"SWT",
		"printer",
		"options",
		"printer",
		"options",
		"SWT",
		"SWT",
		"printer",
		"options",
		"itemCount",
		"topIndex",
		"lineCache",
		"topIndex",
		"itemCount",
		"lineCache",
		"topIndex",
		"itemCount",
		"x",
		"y",
		"width",
		"height",
		"all",
		"height",
		"content",
		"y",
		"lineHeight",
		"startLine",
		"Compatibility",
		"height",
		"lineHeight",
		"startLine",
		"Math",
		"startLine",
		"lineCount",
		"itemCount",
		"Math",
		"endLine",
		"lineCount",
		"startLine",
		"lineCache",
		"startLine",
		"itemCount",
		"itemCount",
		"topIndex",
		"lineCache",
		"topIndex",
		"itemCount",
		"offset",
		"content",
		"line",
		"redrawX",
		"lineText",
		"line",
		"offset",
		"line",
		"lineHeight",
		"verticalScrollOffset",
		"redrawX",
		"leftMargin",
		"redrawY",
		"topMargin",
		"leftMargin",
		"rightMargin",
		"lineHeight",
		"content",
		"firstLine",
		"lastLine",
		"firstLine",
		"content",
		"firstLine",
		"fullLineRedraw",
		"SWT",
		"lastLine",
		"firstLine",
		"clearBackground",
		"endOffset",
		"lineOffset",
		"line",
		"fullLineRedraw",
		"renderer",
		"line",
		"lineOffset",
		"layout",
		"offsetInFirstLine",
		"Math",
		"endOffset",
		"line",
		"renderer",
		"layout",
		"rect",
		"horizontalScrollOffset",
		"rect",
		"clientArea",
		"redrawY",
		"firstLine",
		"lineHeight",
		"verticalScrollOffset",
		"redrawWidth",
		"fullLineRedraw",
		"clientArea",
		"leftMargin",
		"rightMargin",
		"rect",
		"rect",
		"redrawY",
		"redrawWidth",
		"lineHeight",
		"clearBackground",
		"lineCount",
		"lineOffset",
		"content",
		"lastLine",
		"endOffset",
		"lineOffset",
		"offsetInLastLine",
		"line",
		"content",
		"lastLine",
		"clearBackground",
		"offsetInLastLine",
		"line",
		"fullLineRedraw",
		"line",
		"content",
		"lastLine",
		"layout",
		"renderer",
		"line",
		"lineOffset",
		"rect",
		"layout",
		"offsetInLastLine",
		"renderer",
		"layout",
		"rect",
		"horizontalScrollOffset",
		"rect",
		"clientArea",
		"redrawY",
		"lastLine",
		"lineHeight",
		"verticalScrollOffset",
		"redrawWidth",
		"fullLineRedraw",
		"clientArea",
		"leftMargin",
		"rightMargin",
		"rect",
		"rect",
		"redrawY",
		"redrawWidth",
		"lineHeight",
		"clearBackground",
		"newLineCount",
		"replacedLineCount",
		"lineCount",
		"sourceY",
		"Math",
		"y",
		"lineHeight",
		"destinationY",
		"sourceY",
		"lineCount",
		"lineHeight",
		"destinationY",
		"Math",
		"y",
		"lineHeight",
		"sourceY",
		"destinationY",
		"lineCount",
		"lineHeight",
		"destinationY",
		"sourceY",
		"clientArea",
		"clientArea",
		"y",
		"lineHeight",
		"y",
		"clientArea",
		"y",
		"clientArea",
		"lineHeight",
		"newLineCount",
		"y",
		"lineHeight",
		"newLineCount",
		"lineHeight",
		"redrawStartY",
		"redrawHeight",
		"redrawStartY",
		"clientArea",
		"redrawStartY",
		"clientArea",
		"redrawHeight",
		"start",
		"length",
		"content",
		"start",
		"end",
		"start",
		"end",
		"contentLength",
		"SWT",
		"SWT",
		"firstLine",
		"content",
		"start",
		"lastLine",
		"content",
		"end",
		"lineCache",
		"firstLine",
		"lastLine",
		"firstLine",
		"start",
		"length",
		"clearBackground",
		"listener",
		"SWT",
		"SWT",
		"LineGetSegments",
		"listener",
		"extendedModifyListener",
		"SWT",
		"SWT",
		"ExtendedModify",
		"extendedModifyListener",
		"listener",
		"SWT",
		"SWT",
		"LineGetBackground",
		"listener",
		"LineGetBackground",
		"userLineBackground",
		"defaultLineStyler",
		"LineGetBackground",
		"typedListener",
		"userLineBackground",
		"listener",
		"SWT",
		"SWT",
		"LineGetStyle",
		"listener",
		"LineGetStyle",
		"userLineStyle",
		"defaultLineStyler",
		"LineGetStyle",
		"typedListener",
		"userLineStyle",
		"modifyListener",
		"SWT",
		"SWT",
		"SWT",
		"modifyListener",
		"listener",
		"SWT",
		"SWT",
		"SWT",
		"listener",
		"verifyListener",
		"SWT",
		"SWT",
		"SWT",
		"verifyListener",
		"listener",
		"SWT",
		"SWT",
		"VerifyKey",
		"listener",
		"userLineStyle",
		"ranges",
		"SWT",
		"SWT",
		"ranges",
		"start",
		"length",
		"start",
		"length",
		"start",
		"end",
		"start",
		"end",
		"SWT",
		"SWT",
		"content",
		"start",
		"content",
		"end",
		"defaultLineStyler",
		"start",
		"length",
		"ranges",
		"lineCache",
		"firstLine",
		"lastLine",
		"firstLine",
		"firstLine",
		"lastLine",
		"firstLine",
		"lineHeight",
		"verticalScrollOffset",
		"lastLine",
		"lineHeight",
		"verticalScrollOffset",
		"redrawY",
		"redrawStopY",
		"redrawY",
		"start",
		"length",
		"start",
		"end",
		"start",
		"end",
		"contentLength",
		"SWT",
		"SWT",
		"text",
		"SWT",
		"SWT",
		"event",
		"start",
		"event",
		"end",
		"event",
		"text",
		"event",
		"caretOffset",
		"topIndex",
		"topOffset",
		"verticalScrollOffset",
		"horizontalScrollOffset",
		"defaultLineStyler",
		"defaultLineStyler",
		"defaultLineStyler",
		"verticalBar",
		"verticalBar",
		"horizontalBar",
		"horizontalBar",
		"selection",
		"selection",
		"caretOffset",
		"selectionAnchor",
		"pixels",
		"clientArea",
		"pixels",
		"leftMargin",
		"pixels",
		"clientArea",
		"sourceX",
		"rightMargin",
		"clientArea",
		"topMargin",
		"bottomMargin",
		"leftMargin",
		"topMargin",
		"sourceX",
		"topMargin",
		"scrollWidth",
		"scrollHeight",
		"sourceX",
		"scrollWidth",
		"leftMargin",
		"scrollWidth",
		"topMargin",
		"pixels",
		"scrollWidth",
		"scrollHeight",
		"leftMargin",
		"pixels",
		"clientArea",
		"destinationX",
		"rightMargin",
		"clientArea",
		"topMargin",
		"bottomMargin",
		"destinationX",
		"topMargin",
		"leftMargin",
		"topMargin",
		"scrollWidth",
		"scrollHeight",
		"destinationX",
		"scrollWidth",
		"leftMargin",
		"scrollWidth",
		"topMargin",
		"pixels",
		"scrollWidth",
		"scrollHeight",
		"horizontalScrollOffset",
		"pixels",
		"columnX",
		"pixels",
		"columnX",
		"oldColumnX",
		"pixels",
		"horizontalBar",
		"horizontalBar",
		"horizontalScrollOffset",
		"pixels",
		"pixels",
		"Math",
		"editable",
		"event",
		"event",
		"accessible",
		"ACC",
		"event",
		"event",
		"event",
		"event",
		"event",
		"accessible",
		"ACC",
		"event",
		"event",
		"accessible",
		"ACC",
		"event",
		"event",
		"event",
		"accessible",
		"ACC",
		"event",
		"event",
		"SWT",
		"event",
		"event",
		"selection",
		"event",
		"selection",
		"SWT",
		"event",
		"SWT",
		"wrap",
		"wordWrap",
		"wordWrap",
		"wrap",
		"wordWrap",
		"logicalContent",
		"content",
		"content",
		"renderer",
		"logicalContent",
		"content",
		"logicalContent",
		"horizontalScrollOffset",
		"horizontalBar",
		"horizontalBar",
		"wordWrap",
		"caret",
		"caretDirection",
		"SWT",
		"caret",
		"background",
		"color",
		"bidiColoring",
		"mode",
		"caret",
		"caret",
		"defaultCaret",
		"direction",
		"imageDirection",
		"SWT",
		"imageDirection",
		"SWT",
		"imageDirection",
		"SWT",
		"imageDirection",
		"SWT",
		"updateImage",
		"imageDirection",
		"SWT",
		"newCaretX",
		"caret",
		"line",
		"lineHeight",
		"verticalScrollOffset",
		"topMargin",
		"caret",
		"newCaretX",
		"newCaretY",
		"direction",
		"caretDirection",
		"caretDirection",
		"direction",
		"updateImage",
		"imageDirection",
		"SWT",
		"defaultCaret",
		"imageDirection",
		"SWT",
		"defaultCaret",
		"leftCaretBitmap",
		"imageDirection",
		"SWT",
		"defaultCaret",
		"rightCaretBitmap",
		"caret",
		"caret",
		"lineHeight",
		"caretDirection",
		"SWT",
		"BidiUtil",
		"BidiUtil",
		"caretDirection",
		"SWT",
		"BidiUtil",
		"BidiUtil",
		"columnX",
		"newCaretX",
		"content",
		"lineIndex",
		"content",
		"lineIndex",
		"caretOffset",
		"lineOffset",
		"line",
		"lineIndex",
		"offsetInLine",
		"newCaretX",
		"lineIndex",
		"length",
		"offset",
		"caretOffset",
		"offset",
		"caretOffset",
		"offset",
		"length",
		"caretOffset",
		"length",
		"offset",
		"SWT",
		"SWT",
		"caretOffset",
		"offset",
		"clipboardType",
		"DND",
		"IS_MOTIF",
		"IS_GTK",
		"TextTransfer",
		"start",
		"length",
		"plainTextWriter",
		"clipboardType",
		"DND",
		"data",
		"plainText",
		"types",
		"plainTextTransfer",
		"RTFTransfer",
		"start",
		"length",
		"rtfWriter",
		"data",
		"rtfText",
		"plainText",
		"types",
		"rtfTransfer",
		"plainTextTransfer",
		"clipboard",
		"data",
		"types",
		"clipboardType",
		"newContent",
		"SWT",
		"SWT",
		"content",
		"content",
		"textChangeListener",
		"logicalContent",
		"newContent",
		"wordWrap",
		"content",
		"renderer",
		"logicalContent",
		"content",
		"logicalContent",
		"content",
		"textChangeListener",
		"cursor",
		"ibeamCursor",
		"cursor",
		"doubleClickEnabled",
		"enable",
		"editable",
		"lineHeight",
		"font",
		"lineHeight",
		"oldLineHeight",
		"verticalScrollOffset",
		"lineHeight",
		"oldLineHeight",
		"caretDirection",
		"SWT",
		"foreground",
		"color",
		"offset",
		"offset",
		"offset",
		"clientAreaWidth",
		"lineCache",
		"offset",
		"width",
		"clientAreaWidth",
		"offset",
		"Math",
		"width",
		"clientAreaWidth",
		"offset",
		"horizontalScrollOffset",
		"pixel",
		"pixel",
		"clientAreaWidth",
		"lineCache",
		"pixel",
		"width",
		"clientAreaWidth",
		"pixel",
		"Math",
		"width",
		"clientAreaWidth",
		"pixel",
		"horizontalScrollOffset",
		"horizontalBar",
		"horizontalBar",
		"clientArea",
		"lineCache",
		"horizontalBar",
		"horizontalBar",
		"horizontalBar",
		"lineCache",
		"clientArea",
		"leftMargin",
		"rightMargin",
		"horizontalBar",
		"clientArea",
		"leftMargin",
		"rightMargin",
		"horizontalBar",
		"INACTIVE",
		"horizontalBar",
		"INACTIVE",
		"horizontalBar",
		"horizontalBar",
		"horizontalBar",
		"INACTIVE",
		"INACTIVE",
		"horizontalBar",
		"INACTIVE",
		"userLineBackground",
		"startLine",
		"startLine",
		"lineCount",
		"logicalContent",
		"SWT",
		"SWT",
		"defaultLineStyler",
		"startLine",
		"lineCount",
		"background",
		"startLine",
		"partialBottomIndex",
		"startLine",
		"lineCount",
		"topIndex",
		"startLine",
		"topIndex",
		"lineCount",
		"topIndex",
		"startLine",
		"startLine",
		"topIndex",
		"startLine",
		"lineCount",
		"partialBottomIndex",
		"lineCount",
		"partialBottomIndex",
		"startLine",
		"startLine",
		"topIndex",
		"leftMargin",
		"startLine",
		"lineHeight",
		"topMargin",
		"leftMargin",
		"rightMargin",
		"lineCount",
		"lineHeight",
		"mouseDoubleClick",
		"caretOffset",
		"doubleClickSelection",
		"selectionAnchor",
		"doubleClickSelection",
		"caretOffset",
		"doubleClickSelection",
		"selectionAnchor",
		"doubleClickSelection",
		"orientation",
		"SWT",
		"SWT",
		"orientation",
		"SWT",
		"orientation",
		"SWT",
		"orientation",
		"SWT",
		"orientation",
		"SWT",
		"BidiUtil",
		"handle",
		"orientation",
		"isMirrored",
		"orientation",
		"SWT",
		"caretDirection",
		"SWT",
		"keyActionMap",
		"verticalBar",
		"content",
		"clientArea",
		"maximum",
		"verticalBar",
		"verticalBar",
		"verticalBar",
		"maximum",
		"clientArea",
		"verticalBar",
		"clientArea",
		"verticalBar",
		"INACTIVE",
		"verticalBar",
		"INACTIVE",
		"verticalBar",
		"verticalBar",
		"verticalBar",
		"INACTIVE",
		"INACTIVE",
		"verticalBar",
		"INACTIVE",
		"start",
		"start",
		"point",
		"SWT",
		"SWT",
		"point",
		"point",
		"color",
		"color",
		"SWT",
		"SWT",
		"selectionBackground",
		"color",
		"color",
		"color",
		"SWT",
		"SWT",
		"selectionForeground",
		"color",
		"start",
		"end",
		"start",
		"start",
		"Math",
		"Math",
		"start",
		"contentLength",
		"start",
		"length",
		"end",
		"length",
		"start",
		"end",
		"contentLength",
		"length",
		"contentLength",
		"start",
		"start",
		"start",
		"length",
		"SWT",
		"SWT",
		"start",
		"length",
		"start",
		"length",
		"start",
		"end",
		"end",
		"end",
		"start",
		"start",
		"temp",
		"selection",
		"start",
		"selection",
		"end",
		"length",
		"selectionAnchor",
		"selection",
		"length",
		"selectionAnchor",
		"selection",
		"sendEvent",
		"length",
		"selectionAnchor",
		"selection",
		"end",
		"caretOffset",
		"selection",
		"start",
		"selectionAnchor",
		"selection",
		"start",
		"caretOffset",
		"selection",
		"end",
		"selection",
		"selection",
		"selection",
		"userLineStyle",
		"range",
		"range",
		"range",
		"content",
		"SWT",
		"SWT",
		"defaultLineStyler",
		"range",
		"range",
		"content",
		"range",
		"content",
		"range",
		"range",
		"lineCache",
		"firstLine",
		"lastLine",
		"firstLine",
		"firstLine",
		"lastLine",
		"firstLine",
		"lineHeight",
		"verticalScrollOffset",
		"lastLine",
		"lineHeight",
		"verticalScrollOffset",
		"redrawY",
		"redrawStopY",
		"redrawY",
		"lineCache",
		"content",
		"userLineStyle",
		"ranges",
		"SWT",
		"SWT",
		"ranges",
		"ranges",
		"ranges",
		"last",
		"last",
		"content",
		"ranges",
		"lastEnd",
		"content",
		"SWT",
		"SWT",
		"lastLine",
		"content",
		"lastEnd",
		"lineCache",
		"firstLine",
		"lastLine",
		"firstLine",
		"lineCache",
		"content",
		"defaultLineStyler",
		"ranges",
		"tabLength",
		"tabs",
		"renderer",
		"tabLength",
		"caretOffset",
		"caretOffset",
		"lineCache",
		"content",
		"text",
		"SWT",
		"SWT",
		"event",
		"event",
		"event",
		"text",
		"event",
		"SWT",
		"event",
		"event",
		"ExtendedModify",
		"styledTextEvent",
		"logicalContent",
		"styledTextEvent",
		"event",
		"styledTextEvent",
		"event",
		"event",
		"styledTextEvent",
		"content",
		"event",
		"event",
		"event",
		"content",
		"event",
		"event",
		"styledTextEvent",
		"ExtendedModify",
		"styledTextEvent",
		"limit",
		"SWT",
		"SWT",
		"textLimit",
		"limit",
		"logicalContent",
		"Math",
		"Math",
		"lineCount",
		"topIndex",
		"topIndex",
		"topIndex",
		"lineCount",
		"pageSize",
		"topIndex",
		"lineCount",
		"pageSize",
		"wordWrap",
		"logicalContent",
		"topIndex",
		"topIndex",
		"content",
		"logicalLineOffset",
		"topIndex",
		"content",
		"Math",
		"lineCount",
		"height",
		"pixel",
		"pixel",
		"pixel",
		"maxTopPixel",
		"pixel",
		"maxTopPixel",
		"pixel",
		"pixelOffset",
		"verticalScrollOffset",
		"verticalBar",
		"adjustScrollBar",
		"verticalBar",
		"pixelOffset",
		"clientArea",
		"pixelOffset",
		"verticalScrollOffset",
		"clientArea",
		"clientArea",
		"verticalScrollOffset",
		"pixelOffset",
		"columnX",
		"columnX",
		"oldColumnX",
		"leftMargin",
		"clientAreaWidth",
		"x",
		"leftMargin",
		"x",
		"Math",
		"horizontalScrollOffset",
		"x",
		"horizontalIncrement",
		"scrolled",
		"x",
		"x",
		"clientAreaWidth",
		"x",
		"Math",
		"lineCache",
		"horizontalScrollOffset",
		"x",
		"horizontalIncrement",
		"scrolled",
		"x",
		"clientAreaWidth",
		"line",
		"topIndex",
		"scrolled",
		"line",
		"verticalIncrement",
		"line",
		"scrolled",
		"line",
		"verticalIncrement",
		"scrolled",
		"content",
		"caretOffset",
		"caretLine",
		"content",
		"caretLine",
		"content",
		"caretLine",
		"caretOffset",
		"lineOffset",
		"line",
		"caretLine",
		"offsetInLine",
		"newCaretX",
		"caretLine",
		"wordWrap",
		"caret",
		"caret",
		"caretY",
		"verticalScrollOffset",
		"caretLine",
		"setWrapCaretLocation",
		"scrolled",
		"setWrapCaretLocation",
		"newCaretX",
		"caretLine",
		"content",
		"offset",
		"content",
		"line",
		"offset",
		"lineOffset",
		"content",
		"line",
		"lineText",
		"line",
		"offsetInLine",
		"xAtOffset",
		"line",
		"caretOffset",
		"selection",
		"rightToLeft",
		"startOffset",
		"selection",
		"endOffset",
		"selection",
		"startOffset",
		"selection",
		"endOffset",
		"selection",
		"startLine",
		"content",
		"startOffset",
		"offsetInLine",
		"startOffset",
		"content",
		"startLine",
		"startX",
		"content",
		"startLine",
		"startLine",
		"offsetInLine",
		"endLine",
		"content",
		"endOffset",
		"offsetInLine",
		"endOffset",
		"content",
		"endLine",
		"endX",
		"content",
		"endLine",
		"endLine",
		"offsetInLine",
		"rightToLeft",
		"selectionFits",
		"startX",
		"endX",
		"w",
		"selectionFits",
		"endX",
		"startX",
		"w",
		"selectionFits",
		"startX",
		"startLine",
		"endX",
		"content",
		"endLine",
		"endLine",
		"offsetInLine",
		"endX",
		"endLine",
		"endX",
		"endLine",
		"BidiUtil",
		"selection",
		"startOffset",
		"selection",
		"startOffset",
		"selection",
		"startOffset",
		"selection",
		"selection",
		"startOffset",
		"replacedLength",
		"selection",
		"startOffset",
		"replacedLength",
		"newLength",
		"replacedLength",
		"startOffset",
		"newLength",
		"redrawStart",
		"selection",
		"netNewLength",
		"redrawStart",
		"selection",
		"startOffset",
		"selection",
		"startOffset",
		"replacedLength",
		"startOffset",
		"newLength",
		"selection",
		"newLength",
		"replacedLength",
		"selection",
		"selection",
		"content",
		"oldClientAreaWidth",
		"clientAreaWidth",
		"oldClientAreaWidth",
		"wrappedContent",
		"logicalContent",
		"wrappedContent",
		"newTopIndex",
		"content",
		"topOffset",
		"newTopIndex",
		"content",
		"topOffset",
		"content",
		"newTopIndex",
		"newTopIndex",
		"newTopIndex",
		"topIndex",
		"verticalScrollOffset",
		"newTopIndex",
		"topIndex",
		"verticalScrollOffset",
		"verticalScrollOffset",
		"topIndex",
		"newTopIndex",
		"topOffset",
		"content",
		"topIndex",
		"verticalBar",
		"verticalBar",
		"verticalScrollOffset",
		"NULL",
		"NULL",
		"parent",
		"printer",
		"printOptions",
		"mirrored",
		"MIRRORED",
		"MAX_VALUE",
		"scope",
		"PAGE_RANGE",
		"startPage",
		"endPage",
		"scope",
		"SELECTION",
		"printLineBackground",
		"printTextBackground",
		"printTextForeground",
		"printTextFontStyle",
		"styles",
		"length",
		"printTextBackground",
		"background",
		"background",
		"printTextForeground",
		"foreground",
		"foreground",
		"printTextFontStyle",
		"fontStyle",
		"NORMAL",
		"fontStyle",
		"NORMAL",
		"lineBackground",
		"lineBackground",
		"length",
		"styles",
		"styles",
		"background",
		"foreground",
		"background",
		"foreground",
		"background",
		"foreground",
		"styles",
		"NORMAL",
		"width",
		"x",
		"x",
		"x",
		"y",
		"y",
		"y",
		"width",
		"x",
		"width",
		"height",
		"y",
		"height",
		"RIGHT_TO_LEFT",
		"LEFT_TO_RIGHT",
		"tabLength",
		"header",
		"y",
		"height",
		"footer",
		"height",
		"height",
		"scope",
		"PAGE_RANGE",
		"scope",
		"SELECTION",
		"x",
		"y",
		"x",
		"y",
		"y",
		"y",
		"y",
		"height",
		"y",
		"y",
		"header",
		"footer",
		"SEPARATOR",
		"SEPARATOR",
		"PAGE_TAG",
		"PAGE_TAG",
		"width",
		"y",
		"y",
		"height",
		"x",
		"x",
		"width",
		"jobName",
		"ERROR_IO",
		"styles",
		"lineBackground",
		"ERROR_IO",
		"length",
		"start",
		"length",
		"background",
		"foreground",
		"fontStyle",
		"BOLD",
		"fontStyle",
		"ITALIC",
		"underline",
		"strikeout",
		"fontStyle",
		"BOLD",
		"fontStyle",
		"ITALIC",
		"underline",
		"strikeout",
		"ERROR_IO",
		"ERROR_IO",
		"parent",
		"content",
		"lineCount",
		"length",
		"x",
		"width",
		"length",
		"length",
		"length",
		"length",
		"parent",
		"width",
		"NO_REDRAW_RESIZE",
		"NO_BACKGROUND",
		"MIRRORED",
		"READ_ONLY",
		"SINGLE",
		"BORDER",
		"WRAP",
		"NULL",
		"KEYBOARD_BIDI",
		"RIGHT",
		"LEFT",
		"CURSOR_IBEAM",
		"ERROR_NULL_ARGUMENT",
		"KEY_MASK",
		"MODIFIER_MASK",
		"NULL",
		"NULL",
		"NULL",
		"ERROR_NULL_ARGUMENT",
		"ERROR_NULL_ARGUMENT",
		"ERROR_NULL_ARGUMENT",
		"ERROR_NULL_ARGUMENT",
		"Modify",
		"ERROR_NULL_ARGUMENT",
		"Selection",
		"ERROR_NULL_ARGUMENT",
		"ERROR_NULL_ARGUMENT",
		"Verify",
		"ERROR_NULL_ARGUMENT",
		"height",
		"SINGLE",
		"H_SCROLL",
		"V_SCROLL",
		"WRAP",
		"MULTI",
		"MULTI",
		"WRAP",
		"H_SCROLL",
		"height",
		"width",
		"width",
		"height",
		"width",
		"height",
		"width",
		"height",
		"x",
		"y",
		"SINGLE",
		"DEFAULT",
		"DEFAULT",
		"height",
		"DEFAULT",
		"width",
		"height",
		"CLIPBOARD",
		"CLIPBOARD",
		"SELECTION_CLIPBOARD",
		"y",
		"x",
		"x",
		"code",
		"ERROR_CANNOT_SET_CLIPBOARD",
		"CR",
		"LF",
		"ARROW_UP",
		"LINE_UP",
		"ARROW_DOWN",
		"LINE_DOWN",
		"HOME",
		"LINE_START",
		"END",
		"LINE_END",
		"PAGE_UP",
		"PAGE_UP",
		"PAGE_DOWN",
		"PAGE_DOWN",
		"HOME",
		"MOD1",
		"TEXT_START",
		"END",
		"MOD1",
		"TEXT_END",
		"PAGE_UP",
		"MOD1",
		"WINDOW_START",
		"PAGE_DOWN",
		"MOD1",
		"WINDOW_END",
		"ARROW_LEFT",
		"COLUMN_NEXT",
		"ARROW_RIGHT",
		"COLUMN_PREVIOUS",
		"ARROW_LEFT",
		"MOD1",
		"WORD_NEXT",
		"ARROW_RIGHT",
		"MOD1",
		"WORD_PREVIOUS",
		"ARROW_LEFT",
		"COLUMN_PREVIOUS",
		"ARROW_RIGHT",
		"COLUMN_NEXT",
		"ARROW_LEFT",
		"MOD1",
		"WORD_PREVIOUS",
		"ARROW_RIGHT",
		"MOD1",
		"WORD_NEXT",
		"ARROW_UP",
		"MOD2",
		"SELECT_LINE_UP",
		"ARROW_DOWN",
		"MOD2",
		"SELECT_LINE_DOWN",
		"HOME",
		"MOD2",
		"SELECT_LINE_START",
		"END",
		"MOD2",
		"SELECT_LINE_END",
		"PAGE_UP",
		"MOD2",
		"SELECT_PAGE_UP",
		"PAGE_DOWN",
		"MOD2",
		"SELECT_PAGE_DOWN",
		"HOME",
		"MOD1",
		"MOD2",
		"SELECT_TEXT_START",
		"END",
		"MOD1",
		"MOD2",
		"SELECT_TEXT_END",
		"PAGE_UP",
		"MOD1",
		"MOD2",
		"SELECT_WINDOW_START",
		"PAGE_DOWN",
		"MOD1",
		"MOD2",
		"SELECT_WINDOW_END",
		"ARROW_LEFT",
		"MOD2",
		"SELECT_COLUMN_NEXT",
		"ARROW_RIGHT",
		"MOD2",
		"SELECT_COLUMN_PREVIOUS",
		"ARROW_LEFT",
		"MOD1",
		"MOD2",
		"SELECT_WORD_NEXT",
		"ARROW_RIGHT",
		"MOD1",
		"MOD2",
		"SELECT_WORD_PREVIOUS",
		"ARROW_LEFT",
		"MOD2",
		"SELECT_COLUMN_PREVIOUS",
		"ARROW_RIGHT",
		"MOD2",
		"SELECT_COLUMN_NEXT",
		"ARROW_LEFT",
		"MOD1",
		"MOD2",
		"SELECT_WORD_PREVIOUS",
		"ARROW_RIGHT",
		"MOD1",
		"MOD2",
		"SELECT_WORD_NEXT",
		"MOD1",
		"CUT",
		"MOD1",
		"COPY",
		"MOD1",
		"PASTE",
		"DEL",
		"MOD2",
		"CUT",
		"INSERT",
		"MOD1",
		"COPY",
		"INSERT",
		"MOD2",
		"PASTE",
		"BS",
		"MOD2",
		"DELETE_PREVIOUS",
		"BS",
		"DELETE_PREVIOUS",
		"DEL",
		"DELETE_NEXT",
		"BS",
		"MOD1",
		"DELETE_WORD_PREVIOUS",
		"DEL",
		"MOD1",
		"DELETE_WORD_NEXT",
		"INSERT",
		"TOGGLE_OVERWRITE",
		"COLOR_BLACK",
		"COLOR_WHITE",
		"COLOR_BLACK",
		"COLOR_WHITE",
		"y",
		"x",
		"x",
		"CLIPBOARD",
		"code",
		"ERROR_CANNOT_SET_CLIPBOARD",
		"y",
		"height",
		"DOWN",
		"y",
		"height",
		"y",
		"UP",
		"y",
		"x",
		"COLUMN_PREVIOUS",
		"x",
		"x",
		"width",
		"COLUMN_NEXT",
		"x",
		"width",
		"UP",
		"UP",
		"DOWN",
		"DOWN",
		"COLUMN_NEXT",
		"COLUMN_NEXT",
		"COLUMN_PREVIOUS",
		"COLUMN_PREVIOUS",
		"text",
		"x",
		"y",
		"start",
		"x",
		"end",
		"y",
		"start",
		"end",
		"MOVEMENT_CHAR",
		"start",
		"end",
		"y",
		"x",
		"start",
		"x",
		"end",
		"y",
		"CR",
		"LF",
		"text",
		"x",
		"y",
		"end",
		"end",
		"end",
		"text",
		"text",
		"text",
		"y",
		"x",
		"x",
		"y",
		"x",
		"y",
		"text",
		"x",
		"y",
		"start",
		"x",
		"end",
		"y",
		"start",
		"end",
		"start",
		"end",
		"x",
		"y",
		"text",
		"start",
		"end",
		"x",
		"y",
		"text",
		"start",
		"end",
		"height",
		"width",
		"x",
		"x",
		"y",
		"x",
		"COLUMN_PREVIOUS",
		"COLUMN_NEXT",
		"x",
		"y",
		"y",
		"x",
		"width",
		"x",
		"height",
		"COLUMN_NEXT",
		"COLUMN_PREVIOUS",
		"x",
		"COLUMN_PREVIOUS",
		"x",
		"x",
		"x",
		"y",
		"y",
		"y",
		"x",
		"y",
		"y",
		"y",
		"y",
		"y",
		"y",
		"x",
		"x",
		"x",
		"y",
		"x",
		"x",
		"x",
		"COLUMN_NEXT",
		"COLUMN_PREVIOUS",
		"y",
		"x",
		"y",
		"y",
		"x",
		"x",
		"NULL",
		"COLOR_LIST_BACKGROUND",
		"height",
		"x",
		"MOVEMENT_CLUSTER",
		"MOVEMENT_CLUSTER",
		"COLOR_LIST_FOREGROUND",
		"NULL",
		"ERROR_INVALID_ARGUMENT",
		"height",
		"ERROR_INVALID_RANGE",
		"detail",
		"text",
		"detail",
		"text",
		"ERROR_INVALID_RANGE",
		"ERROR_INVALID_RANGE",
		"ERROR_NULL_ARGUMENT",
		"y",
		"x",
		"ERROR_INVALID_ARGUMENT",
		"y",
		"ERROR_INVALID_ARGUMENT",
		"x",
		"x",
		"width",
		"ERROR_INVALID_ARGUMENT",
		"RIGHT_TO_LEFT",
		"LEFT_TO_RIGHT",
		"height",
		"x",
		"y",
		"x",
		"y",
		"x",
		"COLOR_LIST_SELECTION",
		"y",
		"COLOR_LIST_SELECTION_TEXT",
		"x",
		"y",
		"x",
		"LEFT_TO_RIGHT",
		"RIGHT_TO_LEFT",
		"MIRRORED",
		"RIGHT_TO_LEFT",
		"MIRRORED",
		"LEFT_TO_RIGHT",
		"segments",
		"length",
		"segments",
		"length",
		"segments",
		"segments",
		"ERROR_INVALID_ARGUMENT",
		"segments",
		"segments",
		"segments",
		"ERROR_INVALID_ARGUMENT",
		"segments",
		"segments",
		"segments",
		"styles",
		"length",
		"length",
		"start",
		"length",
		"length",
		"length",
		"start",
		"start",
		"length",
		"length",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_INVALID_RANGE",
		"length",
		"start",
		"length",
		"length",
		"start",
		"start",
		"start",
		"length",
		"length",
		"start",
		"length",
		"start",
		"length",
		"length",
		"start",
		"start",
		"length",
		"start",
		"length",
		"length",
		"length",
		"start",
		"length",
		"ERROR_INVALID_RANGE",
		"ERROR_INVALID_RANGE",
		"x",
		"x",
		"width",
		"x",
		"y",
		"ERROR_INVALID_RANGE",
		"DEFAULT",
		"NULL",
		"RIGHT",
		"LEFT",
		"RIGHT",
		"LEFT",
		"RIGHT",
		"LEFT",
		"MOVEMENT_WORD",
		"MOVEMENT_WORD",
		"x",
		"x",
		"ERROR_NULL_ARGUMENT",
		"x",
		"y",
		"type",
		"Dispose",
		"KeyDown",
		"KeyUp",
		"MouseDown",
		"MouseUp",
		"MouseDoubleClick",
		"MouseMove",
		"Paint",
		"Resize",
		"Traverse",
		"Dispose",
		"KeyDown",
		"KeyUp",
		"MouseDown",
		"MouseUp",
		"MouseDoubleClick",
		"MouseMove",
		"Paint",
		"Resize",
		"Traverse",
		"Selection",
		"Selection",
		"width",
		"Dispose",
		"Dispose",
		"type",
		"None",
		"keyCode",
		"keyCode",
		"stateMask",
		"character",
		"stateMask",
		"NULL",
		"stateMask",
		"CTRL",
		"character",
		"character",
		"character",
		"stateMask",
		"NULL",
		"stateMask",
		"COMMAND",
		"stateMask",
		"COMMAND",
		"SHIFT",
		"stateMask",
		"CTRL",
		"stateMask",
		"CTRL",
		"SHIFT",
		"stateMask",
		"ALT",
		"stateMask",
		"CTRL",
		"stateMask",
		"ALT",
		"SHIFT",
		"stateMask",
		"CTRL",
		"SHIFT",
		"character",
		"character",
		"DEL",
		"character",
		"CR",
		"character",
		"LF",
		"character",
		"character",
		"x",
		"y",
		"character",
		"character",
		"keyCode",
		"keyCode",
		"stateMask",
		"stateMask",
		"doit",
		"doit",
		"x",
		"x",
		"y",
		"y",
		"y",
		"x",
		"x",
		"y",
		"x",
		"SELECTION_CLIPBOARD",
		"code",
		"ERROR_CANNOT_SET_CLIPBOARD",
		"button",
		"y",
		"x",
		"y",
		"button",
		"SELECTION_CLIPBOARD",
		"x",
		"y",
		"start",
		"x",
		"end",
		"y",
		"text",
		"button",
		"stateMask",
		"MOD4",
		"stateMask",
		"MOD2",
		"y",
		"x",
		"y",
		"stateMask",
		"BUTTON1",
		"y",
		"x",
		"y",
		"y",
		"button",
		"y",
		"x",
		"x",
		"y",
		"x",
		"SELECTION_CLIPBOARD",
		"code",
		"ERROR_CANNOT_SET_CLIPBOARD",
		"y",
		"y",
		"height",
		"height",
		"gc",
		"height",
		"width",
		"width",
		"replaceLineCount",
		"newLineCount",
		"replaceCharCount",
		"start",
		"replaceCharCount",
		"replaceCharCount",
		"start",
		"newLineCount",
		"newCharCount",
		"replaceLineCount",
		"replaceCharCount",
		"start",
		"newLineCount",
		"replaceLineCount",
		"replaceCharCount",
		"newCharCount",
		"detail",
		"TRAVERSE_ESCAPE",
		"TRAVERSE_PAGE_NEXT",
		"TRAVERSE_PAGE_PREVIOUS",
		"doit",
		"TRAVERSE_RETURN",
		"TRAVERSE_TAB_NEXT",
		"TRAVERSE_TAB_PREVIOUS",
		"SINGLE",
		"doit",
		"stateMask",
		"MODIFIER_MASK",
		"doit",
		"result",
		"offset",
		"offset",
		"x",
		"length",
		"y",
		"detail",
		"ROLE_TEXT",
		"STATE_FOCUSABLE",
		"STATE_FOCUSED",
		"STATE_INVISIBLE",
		"STATE_READONLY",
		"detail",
		"result",
		"FocusIn",
		"CHILDID_SELF",
		"LINE_UP",
		"LINE_DOWN",
		"LINE_START",
		"LINE_END",
		"COLUMN_PREVIOUS",
		"COLUMN_NEXT",
		"PAGE_UP",
		"PAGE_DOWN",
		"WORD_PREVIOUS",
		"WORD_NEXT",
		"TEXT_START",
		"TEXT_END",
		"WINDOW_START",
		"WINDOW_END",
		"SELECT_LINE_UP",
		"SELECT_ALL",
		"SELECT_LINE_DOWN",
		"SELECT_LINE_START",
		"COLUMN_PREVIOUS",
		"SELECT_LINE_END",
		"COLUMN_NEXT",
		"SELECT_COLUMN_PREVIOUS",
		"COLUMN_PREVIOUS",
		"SELECT_COLUMN_NEXT",
		"COLUMN_NEXT",
		"SELECT_PAGE_UP",
		"SELECT_PAGE_DOWN",
		"SELECT_WORD_PREVIOUS",
		"COLUMN_PREVIOUS",
		"SELECT_WORD_NEXT",
		"COLUMN_NEXT",
		"SELECT_TEXT_START",
		"COLUMN_PREVIOUS",
		"SELECT_TEXT_END",
		"COLUMN_NEXT",
		"SELECT_WINDOW_START",
		"COLUMN_PREVIOUS",
		"SELECT_WINDOW_END",
		"COLUMN_NEXT",
		"CUT",
		"COPY",
		"PASTE",
		"DELETE_PREVIOUS",
		"DELETE_NEXT",
		"DELETE_WORD_PREVIOUS",
		"DELETE_WORD_NEXT",
		"TOGGLE_OVERWRITE",
		"SINGLE",
		"doit",
		"Verify",
		"doit",
		"end",
		"start",
		"start",
		"start",
		"end",
		"start",
		"text",
		"text",
		"start",
		"text",
		"start",
		"start",
		"end",
		"end",
		"start",
		"text",
		"start",
		"text",
		"CLIPBOARD",
		"start",
		"x",
		"end",
		"y",
		"text",
		"width",
		"RIGHT_TO_LEFT",
		"LEFT_TO_RIGHT",
		"width",
		"width",
		"printTextForeground",
		"printTextBackground",
		"printTextFontStyle",
		"printLineBackground",
		"printTextForeground",
		"printTextBackground",
		"printTextFontStyle",
		"printLineBackground",
		"ERROR_NULL_ARGUMENT",
		"ERROR_NULL_ARGUMENT",
		"width",
		"FULL_SELECTION",
		"x",
		"width",
		"width",
		"x",
		"x",
		"width",
		"width",
		"x",
		"width",
		"height",
		"height",
		"width",
		"height",
		"width",
		"ERROR_INVALID_RANGE",
		"ERROR_NULL_ARGUMENT",
		"ERROR_NULL_ARGUMENT",
		"ERROR_NULL_ARGUMENT",
		"ERROR_NULL_ARGUMENT",
		"ERROR_NULL_ARGUMENT",
		"Modify",
		"ERROR_NULL_ARGUMENT",
		"Selection",
		"ERROR_NULL_ARGUMENT",
		"Verify",
		"ERROR_NULL_ARGUMENT",
		"ERROR_NULL_ARGUMENT",
		"length",
		"ERROR_INVALID_RANGE",
		"width",
		"ERROR_INVALID_RANGE",
		"ERROR_NULL_ARGUMENT",
		"start",
		"end",
		"text",
		"x",
		"y",
		"width",
		"height",
		"width",
		"height",
		"text",
		"TEXT_DELETE",
		"start",
		"end",
		"start",
		"start",
		"end",
		"TEXT_INSERT",
		"start",
		"text",
		"TEXT_DELETE",
		"start",
		"end",
		"start",
		"TEXT_INSERT",
		"start",
		"text",
		"Modify",
		"x",
		"x",
		"y",
		"y",
		"Selection",
		"SINGLE",
		"NULL",
		"LEFT",
		"RIGHT",
		"RIGHT",
		"LEFT",
		"RIGHT",
		"x",
		"DEFAULT",
		"LEFT",
		"RIGHT",
		"x",
		"LEFT",
		"KEYBOARD_NON_BIDI",
		"RIGHT",
		"KEYBOARD_BIDI",
		"ERROR_INVALID_ARGUMENT",
		"SELECTION_CLIPBOARD",
		"SELECTION_CLIPBOARD",
		"ERROR_NULL_ARGUMENT",
		"editable",
		"NULL",
		"width",
		"width",
		"width",
		"width",
		"width",
		"ERROR_INVALID_ARGUMENT",
		"width",
		"x",
		"y",
		"y",
		"x",
		"RIGHT_TO_LEFT",
		"LEFT_TO_RIGHT",
		"RIGHT_TO_LEFT",
		"LEFT_TO_RIGHT",
		"RIGHT_TO_LEFT",
		"LEFT_TO_RIGHT",
		"RIGHT_TO_LEFT",
		"NULL",
		"height",
		"height",
		"height",
		"ERROR_NULL_ARGUMENT",
		"x",
		"y",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"x",
		"y",
		"x",
		"y",
		"y",
		"x",
		"x",
		"y",
		"x",
		"y",
		"x",
		"start",
		"length",
		"ERROR_INVALID_RANGE",
		"start",
		"start",
		"length",
		"width",
		"ERROR_NULL_ARGUMENT",
		"length",
		"length",
		"start",
		"length",
		"start",
		"ERROR_INVALID_RANGE",
		"ERROR_NULL_ARGUMENT",
		"start",
		"end",
		"text",
		"doit",
		"Verify",
		"doit",
		"start",
		"start",
		"end",
		"start",
		"text",
		"text",
		"start",
		"end",
		"start",
		"text",
		"ERROR_CANNOT_BE_ZERO",
		"height",
		"width",
		"height",
		"width",
		"height",
		"y",
		"x",
		"y",
		"x",
		"x",
		"y",
		"width",
		"y",
		"x",
		"x",
		"x",
		"y",
		"x",
		"y",
		"y",
		"x",
		"x",
		"y",
		"x",
		"parent",
		"printer",
		"printOptions",
		"lineOffset",
		"line",
		"lineOffset",
		"line",
		"printerContent",
		"lineOffset",
		"line",
		"original",
		"page",
		"color",
		"page",
		"header",
		"segment",
		"alignment",
		"page",
		"header",
		"page",
		"start",
		"length",
		"color",
		"defaultIndex",
		"exception",
		"string",
		"start",
		"end",
		"line",
		"lineOffset",
		"lineDelimiter",
		"line",
		"lineOffset",
		"styles",
		"lineBackground",
		"start",
		"length",
		"string",
		"string",
		"offset",
		"i",
		"i",
		"line",
		"lineOffset",
		"lineDelimiter",
		"startLine",
		"lineCount",
		"startLine",
		"lineCount",
		"calculateMaxWidth",
		"startLine",
		"lineCount",
		"calculateMaxWidth",
		"startOffset",
		"newLineCount",
		"replaceLineCount",
		"newCharCount",
		"replaceCharCount",
		"parent",
		"content",
		"startLine",
		"lineCount",
		"startLine",
		"newLineCount",
		"line",
		"lineOffset",
		"numLines",
		"startLine",
		"delta",
		"startLine",
		"lineCount",
		"calculateMaxWidth",
		"startLine",
		"lineCount",
		"calculateMaxWidth",
		"startOffset",
		"newLineCount",
		"replaceLineCount",
		"newCharCount",
		"replaceCharCount",
		"parent",
		"content",
		"startLine",
		"lineCount",
		"startLine",
		"lineCount",
		"calculateMaxWidth",
		"startLine",
		"lineCount",
		"calculateMaxWidth",
		"startOffset",
		"newLineCount",
		"replaceLineCount",
		"newCharCount",
		"replaceCharCount",
		"parent",
		"style",
		"extendedModifyListener",
		"key",
		"action",
		"listener",
		"listener",
		"listener",
		"modifyListener",
		"listener",
		"listener",
		"verifyListener",
		"string",
		"style",
		"gc",
		"background",
		"clientArea",
		"y",
		"sendEvent",
		"wHint",
		"hHint",
		"changed",
		"clipboardType",
		"error",
		"text",
		"error",
		"event",
		"direction",
		"distance",
		"key",
		"x",
		"y",
		"select",
		"x",
		"newCaretOffset",
		"line",
		"select",
		"lines",
		"select",
		"lines",
		"direction",
		"lines",
		"lines",
		"x",
		"y",
		"width",
		"height",
		"clearBackground",
		"line",
		"lineOffset",
		"lineXOffset",
		"clipboardType",
		"offset",
		"lineIndex",
		"offset",
		"lineIndex",
		"key",
		"index",
		"lineOffset",
		"line",
		"offset",
		"eventType",
		"lineOffset",
		"line",
		"content",
		"lineOffset",
		"line",
		"offset",
		"lineIndex",
		"point",
		"x",
		"line",
		"writer",
		"lineOffset",
		"line",
		"line",
		"lineOffset",
		"offset",
		"start",
		"length",
		"start",
		"end",
		"start",
		"end",
		"start",
		"length",
		"offset",
		"offset",
		"offset",
		"line",
		"lineIndex",
		"offsetInLine",
		"string",
		"event",
		"event",
		"event",
		"event",
		"event",
		"event",
		"start",
		"length",
		"clearBackground",
		"event",
		"event",
		"event",
		"event",
		"event",
		"error",
		"event",
		"event",
		"event",
		"event",
		"error",
		"event",
		"event",
		"event",
		"event",
		"event",
		"event",
		"event",
		"e",
		"e",
		"e",
		"e",
		"e",
		"e",
		"event",
		"action",
		"offset",
		"firstLine",
		"lastLine",
		"event",
		"updateCaret",
		"gc",
		"startLine",
		"startY",
		"renderHeight",
		"printer",
		"printer",
		"options",
		"x",
		"y",
		"width",
		"height",
		"all",
		"line",
		"offset",
		"firstLine",
		"offsetInFirstLine",
		"lastLine",
		"endOffset",
		"clearBackground",
		"y",
		"newLineCount",
		"replacedLineCount",
		"start",
		"length",
		"clearBackground",
		"listener",
		"extendedModifyListener",
		"listener",
		"listener",
		"modifyListener",
		"listener",
		"verifyListener",
		"listener",
		"start",
		"length",
		"ranges",
		"start",
		"length",
		"text",
		"pixels",
		"pixels",
		"event",
		"event",
		"wrap",
		"caret",
		"color",
		"mode",
		"newCaretX",
		"line",
		"direction",
		"offset",
		"start",
		"length",
		"clipboardType",
		"newContent",
		"cursor",
		"enable",
		"editable",
		"font",
		"color",
		"offset",
		"pixel",
		"startLine",
		"lineCount",
		"background",
		"orientation",
		"start",
		"point",
		"color",
		"color",
		"start",
		"end",
		"start",
		"length",
		"start",
		"length",
		"sendEvent",
		"range",
		"ranges",
		"tabs",
		"text",
		"limit",
		"topIndex",
		"pixel",
		"pixelOffset",
		"adjustScrollBar",
		"x",
		"line",
		"caretLine",
		"offset",
		"startOffset",
		"replacedLength",
		"newLength",
		"oldClientAreaWidth"
	],
	"extendORImplementFiles":[
		"Canvas",
		"Runnable",
		"TextWriter",
		"LineCache",
		"LineCache"
	],
	"package":[
		"org.eclipse.swt.custom"
	],
	"import":[
		"java.util",
		"org.eclipse.swt",
		"org.eclipse.swt.accessibility",
		"org.eclipse.swt.dnd",
		"org.eclipse.swt.events",
		"org.eclipse.swt.graphics",
		"org.eclipse.swt.internal",
		"org.eclipse.swt.printing",
		"org.eclipse.swt.widgets"
	],
	"methods":[
		"cacheBidiSegments",
		"cacheLineBackground",
		"cacheLineData",
		"cacheLineStyle",
		"copyContent",
		"createPrinterColors",
		"dispose",
		"endPage",
		"initializeRenderer",
		"getPrinterColor",
		"print",
		"printDecoration",
		"printDecorationSegment",
		"run",
		"startPage",
		"close",
		"getColorIndex",
		"setUnicode",
		"write",
		"writeHeader",
		"writeLine",
		"writeLineDelimiter",
		"writeStyledLine",
		"close",
		"getCharCount",
		"getStart",
		"isClosed",
		"toString",
		"write",
		"write",
		"write",
		"write",
		"writeLine",
		"writeLineDelimiter",
		"calculate",
		"getWidth",
		"redrawReset",
		"reset",
		"textChanged",
		"calculate",
		"calculateVisible",
		"contentWidth",
		"expandLines",
		"getWidth",
		"linesChanged",
		"redrawReset",
		"reset",
		"textChanged",
		"calculate",
		"getWidth",
		"redrawReset",
		"reset",
		"textChanged",
		"run",
		"addExtendedModifyListener",
		"setKeyBinding",
		"addBidiSegmentListener",
		"addLineBackgroundListener",
		"addLineStyleListener",
		"addModifyListener",
		"addSelectionListener",
		"addVerifyKeyListener",
		"addVerifyListener",
		"append",
		"calculateContentWidth",
		"calculateScrollBars",
		"calculateTopIndex",
		"checkStyle",
		"claimBottomFreeSpace",
		"claimRightFreeSpace",
		"clearMargin",
		"clearSelection",
		"computeSize",
		"copy",
		"copy",
		"getModelDelimitedText",
		"createKeyBindings",
		"createCaretBitmaps",
		"cut",
		"doAutoScroll",
		"doAutoScroll",
		"run",
		"run",
		"run",
		"run",
		"doBackspace",
		"doContent",
		"doContentEnd",
		"doContentStart",
		"doCursorPrevious",
		"doCursorNext",
		"doDelete",
		"doDeleteWordNext",
		"doDeleteWordPrevious",
		"doLineDown",
		"doLineEnd",
		"doLineStart",
		"doLineUp",
		"doMouseLocationChange",
		"doMouseSelection",
		"doMouseWordSelect",
		"doPageDown",
		"doPageEnd",
		"doPageStart",
		"doPageUp",
		"doSelection",
		"doSelectionCursorNext",
		"doSelectionCursorPrevious",
		"doSelectionLineDown",
		"doSelectionLineUp",
		"doSelectionPageDown",
		"doSelectionPageUp",
		"doSelectionWordNext",
		"doSelectionWordPrevious",
		"doVisualPrevious",
		"doVisualNext",
		"doWordNext",
		"doWordPrevious",
		"draw",
		"endAutoScroll",
		"getBackground",
		"getBaseline",
		"getBidiColoring",
		"getBottomIndex",
		"getCaretOffset",
		"getOffsetAtX",
		"getCaretWidth",
		"getClipboardContent",
		"getClusterNext",
		"getClusterPrevious",
		"getContent",
		"getDoubleClickEnabled",
		"getEditable",
		"getForeground",
		"getGC",
		"getHorizontalIncrement",
		"getHorizontalIndex",
		"getHorizontalPixel",
		"getKeyBinding",
		"getCharCount",
		"getLineBackground",
		"getLineBackgroundData",
		"getLineCount",
		"getLineCountWhole",
		"getLineAtOffset",
		"getLineDelimiter",
		"sendLineEvent",
		"getLineHeight",
		"getLineCache",
		"getLineStyleData",
		"getLocationAtOffset",
		"getOffsetAtLine",
		"getOffsetAtLocation",
		"getOffsetAtMouseLocation",
		"getOrientation",
		"getPartialBottomIndex",
		"getPlatformDelimitedText",
		"getSelection",
		"getSelectionRange",
		"getSelectionBackground",
		"getSelectionCount",
		"getSelectionForeground",
		"getSelectionText",
		"getStyle",
		"getBidiSegments",
		"getBidiSegmentsCompatibility",
		"getStyleRangeAtOffset",
		"getStyleRanges",
		"getStyleRanges",
		"getTabs",
		"getText",
		"getText",
		"getTextBounds",
		"getTextRange",
		"getTextLimit",
		"getTopIndex",
		"getTopPixel",
		"getVerticalIncrement",
		"getCaretDirection",
		"getCaretLine",
		"getWordEnd",
		"getWordEndNoSpaces",
		"getWordStart",
		"getWordWrap",
		"getXAtOffset",
		"insert",
		"installDefaultContent",
		"textChanging",
		"textChanged",
		"textSet",
		"installDefaultLineStyler",
		"installListeners",
		"handleEvent",
		"handleEvent",
		"handleEvent",
		"internalGetContent",
		"internalGetHorizontalPixel",
		"internalGetLineCache",
		"internalGetSelection",
		"internalGetWordWrap",
		"internalRedraw",
		"internalRedrawRange",
		"getRtf",
		"handleDispose",
		"handleHorizontalScroll",
		"handleKey",
		"handleKeyDown",
		"handleKeyUp",
		"handleMouseDoubleClick",
		"handleMouseDown",
		"handleMouseMove",
		"handleMouseUp",
		"handlePaint",
		"handleResize",
		"handleTextChanged",
		"handleTextChanging",
		"handleTextSet",
		"handleTraverse",
		"handleVerticalScroll",
		"initializeAccessible",
		"getHelp",
		"getCaretOffset",
		"getSelectionRange",
		"getRole",
		"getState",
		"getValue",
		"handleEvent",
		"initializeRenderer",
		"invokeAction",
		"isBidi",
		"isLineDelimiter",
		"isMirrored",
		"isAreaVisible",
		"isSingleLine",
		"modifyContent",
		"paste",
		"performPaint",
		"print",
		"print",
		"print",
		"redraw",
		"redraw",
		"redrawLine",
		"redrawLines",
		"redrawMultiLineChange",
		"redrawRange",
		"removeBidiSegmentListener",
		"removeExtendedModifyListener",
		"removeLineBackgroundListener",
		"removeLineStyleListener",
		"removeModifyListener",
		"removeSelectionListener",
		"removeVerifyListener",
		"removeVerifyKeyListener",
		"replaceStyleRanges",
		"replaceTextRange",
		"reset",
		"resetSelection",
		"scrollHorizontal",
		"scrollHorizontalBar",
		"selectAll",
		"sendKeyEvent",
		"sendModifyEvent",
		"sendSelectionEvent",
		"setWordWrap",
		"setCaret",
		"setBackground",
		"setBidiColoring",
		"setCaretLocation",
		"setCaretLocation",
		"setCaretOffset",
		"setClipboardContent",
		"setContent",
		"setCursor",
		"setDoubleClickEnabled",
		"setEditable",
		"setFont",
		"setForeground",
		"setHorizontalIndex",
		"setHorizontalPixel",
		"setHorizontalScrollBar",
		"setLineBackground",
		"setMouseWordSelectionAnchor",
		"setOrientation",
		"setScrollBars",
		"setSelection",
		"setSelection",
		"setSelectionBackground",
		"setSelectionForeground",
		"setSelection",
		"setSelectionRange",
		"internalSetSelection",
		"setStyleRange",
		"setStyleRanges",
		"setTabs",
		"setText",
		"setTextLimit",
		"setTopIndex",
		"setTopPixel",
		"setVerticalScrollOffset",
		"showLocation",
		"showCaret",
		"showCaret",
		"showOffset",
		"showSelection",
		"isBidiCaret",
		"updateSelection",
		"wordWrapResize",
		"getProperty",
		"getPlatform",
		"equals",
		"equals",
		"equals",
		"getPrinterData",
		"getStyle",
		"isSingleLine",
		"getSelectionRange",
		"getFontData",
		"getFont",
		"copyContent",
		"getContent",
		"cacheLineData",
		"getBidiSegments",
		"put",
		"getLineBackgroundData",
		"put",
		"getLineCount",
		"getOffsetAtLine",
		"getLine",
		"cacheLineBackground",
		"cacheLineStyle",
		"isBidi",
		"cacheBidiSegments",
		"getLineStyleData",
		"clone",
		"clone",
		"clone",
		"put",
		"getLineCount",
		"getLineCount",
		"getOffsetAtLine",
		"getCharCount",
		"replaceTextRange",
		"getTextRange",
		"elements",
		"hasMoreElements",
		"nextElement",
		"getPrinterColor",
		"elements",
		"hasMoreElements",
		"nextElement",
		"getPrinterColor",
		"getPrinterColor",
		"clone",
		"elements",
		"hasMoreElements",
		"nextElement",
		"dispose",
		"dispose",
		"dispose",
		"dispose",
		"printDecoration",
		"endPage",
		"computeTrim",
		"getDPI",
		"getName",
		"getHeight",
		"getClientArea",
		"setFont",
		"getLineHeight",
		"getLineHeight",
		"getLineHeight",
		"getContent",
		"getLineCount",
		"getPrinterData",
		"getLineAtOffset",
		"getLineAtOffset",
		"get",
		"getRGB",
		"put",
		"getContent",
		"getBackground",
		"getForeground",
		"getLineHeight",
		"getLine",
		"startPage",
		"drawLine",
		"endPage",
		"endPage",
		"indexOf",
		"substring",
		"printDecorationSegment",
		"substring",
		"printDecorationSegment",
		"length",
		"indexOf",
		"length",
		"substring",
		"append",
		"append",
		"substring",
		"toString",
		"length",
		"setText",
		"setFont",
		"getLineBounds",
		"getLineHeight",
		"getLineHeight",
		"draw",
		"dispose",
		"startJob",
		"createPrinterColors",
		"initializeRenderer",
		"print",
		"dispose",
		"endJob",
		"startPage",
		"printDecoration",
		"addElement",
		"getForeground",
		"addElement",
		"getBackground",
		"setUnicode",
		"isClosed",
		"writeHeader",
		"write",
		"close",
		"indexOf",
		"size",
		"addElement",
		"toLowerCase",
		"getProperty",
		"getProperty",
		"startsWith",
		"indexOf",
		"substring",
		"parseInt",
		"startsWith",
		"startsWith",
		"startsWith",
		"startsWith",
		"charAt",
		"write",
		"substring",
		"write",
		"write",
		"toString",
		"write",
		"write",
		"substring",
		"write",
		"write",
		"write",
		"substring",
		"getFontData",
		"getFont",
		"append",
		"toLowerCase",
		"getProperty",
		"startsWith",
		"startsWith",
		"substring",
		"length",
		"append",
		"append",
		"append",
		"append",
		"getName",
		"append",
		"size",
		"elementAt",
		"append",
		"append",
		"getRed",
		"append",
		"append",
		"getGreen",
		"append",
		"append",
		"getBlue",
		"append",
		"append",
		"append",
		"getHeight",
		"append",
		"write",
		"toString",
		"isClosed",
		"error",
		"getLineStyleData",
		"getLineBackgroundData",
		"getBackground",
		"writeStyledLine",
		"isClosed",
		"error",
		"write",
		"length",
		"write",
		"length",
		"getStart",
		"getCharCount",
		"min",
		"length",
		"write",
		"write",
		"getColorIndex",
		"write",
		"write",
		"getColorIndex",
		"write",
		"write",
		"getColorIndex",
		"write",
		"write",
		"write",
		"write",
		"write",
		"write",
		"write",
		"min",
		"max",
		"write",
		"write",
		"write",
		"write",
		"write",
		"write",
		"write",
		"write",
		"toString",
		"append",
		"length",
		"insert",
		"append",
		"append",
		"length",
		"error",
		"min",
		"write",
		"substring",
		"error",
		"write",
		"getLineCount",
		"reset",
		"getCaretWidth",
		"getLine",
		"getOffsetAtLine",
		"contentWidth",
		"getTopIndex",
		"min",
		"getPartialBottomIndex",
		"max",
		"calculate",
		"getTextLayout",
		"getLineBounds",
		"disposeTextLayout",
		"max",
		"arraycopy",
		"reset",
		"expandLines",
		"reset",
		"getLineAtOffset",
		"reset",
		"linesChanged",
		"linesChanged",
		"calculateVisible",
		"wrapLines",
		"getClientArea",
		"getLineCount",
		"wrapLines",
		"reset",
		"getPartialBottomIndex",
		"getOffsetAtLine",
		"redrawReset",
		"getPartialBottomIndex",
		"internalRedraw",
		"getOffsetAtLine",
		"internalRedraw",
		"getLineAtOffset",
		"textChanged",
		"getLineCount",
		"getPartialBottomIndex",
		"internalRedraw",
		"checkStyle",
		"setForeground",
		"getForeground",
		"setBackground",
		"getBackground",
		"getDisplay",
		"getStyle",
		"setEditable",
		"isBidiCaret",
		"installDefaultContent",
		"initializeRenderer",
		"setWordWrap",
		"isBidiCaret",
		"createCaretBitmaps",
		"getKeyboardLanguage",
		"getCaret",
		"getCaretLine",
		"getLine",
		"getOffsetAtLine",
		"getXAtOffset",
		"setCaretLocation",
		"getCaretLine",
		"addLanguageListener",
		"setCaret",
		"calculateScrollBars",
		"createKeyBindings",
		"setCursor",
		"installListeners",
		"installDefaultLineStyler",
		"initializeAccessible",
		"checkWidget",
		"error",
		"addListener",
		"checkWidget",
		"isLetter",
		"toUpperCase",
		"remove",
		"put",
		"toLowerCase",
		"remove",
		"put",
		"remove",
		"put",
		"checkWidget",
		"error",
		"addListener",
		"checkWidget",
		"error",
		"removeLineBackgroundListener",
		"setLineBackground",
		"getLineCount",
		"addListener",
		"checkWidget",
		"error",
		"removeLineStyleListener",
		"setStyleRange",
		"addListener",
		"checkWidget",
		"error",
		"addListener",
		"checkWidget",
		"error",
		"addListener",
		"checkWidget",
		"error",
		"addListener",
		"checkWidget",
		"error",
		"addListener",
		"checkWidget",
		"error",
		"max",
		"getCharCount",
		"replaceTextRange",
		"getLineCache",
		"calculate",
		"getPartialBottomIndex",
		"getHorizontalBar",
		"getVerticalBar",
		"setScrollBars",
		"setIncrement",
		"getVerticalIncrement",
		"setIncrement",
		"getHorizontalIncrement",
		"getVerticalIncrement",
		"getClientArea",
		"ceil",
		"getLineCount",
		"getLineCount",
		"getOffsetAtLine",
		"calculate",
		"getPartialBottomIndex",
		"setHorizontalScrollBar",
		"max",
		"getLineCount",
		"getClientArea",
		"setVerticalScrollOffset",
		"max",
		"getWidth",
		"getClientArea",
		"scrollHorizontalBar",
		"setBackground",
		"fillRectangle",
		"fillRectangle",
		"fillRectangle",
		"fillRectangle",
		"getCharCount",
		"resetSelection",
		"min",
		"min",
		"internalRedrawRange",
		"sendSelectionEvent",
		"checkWidget",
		"getStyle",
		"getLineCount",
		"getLineCount",
		"min",
		"getBounds",
		"getDisplay",
		"calculate",
		"getWidth",
		"wrapLines",
		"getLineCount",
		"computeTrim",
		"checkWidget",
		"copy",
		"checkWidget",
		"setClipboardContent",
		"getLineDelimiter",
		"length",
		"indexOf",
		"indexOf",
		"append",
		"substring",
		"append",
		"substring",
		"isSingleLine",
		"append",
		"isSingleLine",
		"length",
		"append",
		"substring",
		"toString",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"isMirrored",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"isMirrored",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"setKeyBinding",
		"getDisplay",
		"equals",
		"getImage",
		"setImage",
		"dispose",
		"setBackground",
		"getSystemColor",
		"fillRectangle",
		"setForeground",
		"getSystemColor",
		"drawLine",
		"drawLine",
		"drawLine",
		"dispose",
		"equals",
		"getImage",
		"setImage",
		"dispose",
		"setBackground",
		"getSystemColor",
		"fillRectangle",
		"setForeground",
		"getSystemColor",
		"drawLine",
		"drawLine",
		"drawLine",
		"dispose",
		"checkWidget",
		"setClipboardContent",
		"doDelete",
		"getClientArea",
		"doAutoScroll",
		"doAutoScroll",
		"doAutoScroll",
		"doAutoScroll",
		"endAutoScroll",
		"getDisplay",
		"getLineHeight",
		"doSelectionPageUp",
		"timerExec",
		"getLineHeight",
		"doSelectionPageDown",
		"timerExec",
		"doVisualNext",
		"setMouseWordSelectionAnchor",
		"doMouseSelection",
		"timerExec",
		"doVisualPrevious",
		"setMouseWordSelectionAnchor",
		"doMouseSelection",
		"timerExec",
		"timerExec",
		"sendKeyEvent",
		"getLineAtOffset",
		"getOffsetAtLine",
		"getOffsetAtLine",
		"length",
		"getLine",
		"getLine",
		"getTextLayout",
		"getPreviousOffset",
		"disposeTextLayout",
		"sendKeyEvent",
		"getCharCount",
		"isSingleLine",
		"getLineDelimiter",
		"getLineAtOffset",
		"getOffsetAtLine",
		"getLine",
		"length",
		"sendKeyEvent",
		"isSingleLine",
		"doLineEnd",
		"getCharCount",
		"showCaret",
		"showCaret",
		"getCaretLine",
		"showCaret",
		"doSelectionCursorPrevious",
		"getCaretLine",
		"showCaret",
		"doSelectionCursorNext",
		"sendKeyEvent",
		"getCharCount",
		"getLineAtOffset",
		"getOffsetAtLine",
		"length",
		"getLine",
		"getOffsetAtLine",
		"getClusterNext",
		"sendKeyEvent",
		"doDelete",
		"getWordEnd",
		"sendKeyEvent",
		"doBackspace",
		"getWordStart",
		"sendKeyEvent",
		"isSingleLine",
		"getCaretLine",
		"getLineCount",
		"getOffsetAtMouseLocation",
		"getCaretLine",
		"getOffsetAtLine",
		"length",
		"getLine",
		"showCaret",
		"getCaretLine",
		"getOffsetAtLine",
		"showCaret",
		"getCaretLine",
		"getOffsetAtMouseLocation",
		"getLineCount",
		"isSingleLine",
		"getOffsetAtMouseLocation",
		"doMouseWordSelect",
		"getLineAtOffset",
		"getClientArea",
		"getClientArea",
		"getLineAtOffset",
		"doMouseSelection",
		"showCaret",
		"clearSelection",
		"doSelection",
		"doSelection",
		"getClientArea",
		"getWordStart",
		"getWordEndNoSpaces",
		"getLineAtOffset",
		"getLineCount",
		"isSingleLine",
		"getCaretLine",
		"getVerticalIncrement",
		"getClientArea",
		"min",
		"max",
		"getOffsetAtMouseLocation",
		"doSelection",
		"getVerticalIncrement",
		"setVerticalScrollOffset",
		"showCaret",
		"isSingleLine",
		"doLineEnd",
		"getBottomIndex",
		"getOffsetAtLine",
		"length",
		"getLine",
		"showCaret",
		"getOffsetAtLine",
		"showCaret",
		"getCaretLine",
		"max",
		"min",
		"getOffsetAtMouseLocation",
		"doSelection",
		"max",
		"getVerticalIncrement",
		"setVerticalScrollOffset",
		"showCaret",
		"internalRedrawRange",
		"sendSelectionEvent",
		"getCaretLine",
		"getOffsetAtLine",
		"length",
		"getLine",
		"getClusterNext",
		"showCaret",
		"getLineCount",
		"isSingleLine",
		"getOffsetAtLine",
		"showCaret",
		"getCaretLine",
		"getOffsetAtLine",
		"getClusterPrevious",
		"showCaret",
		"getOffsetAtLine",
		"length",
		"getLine",
		"showCaret",
		"isSingleLine",
		"getCaretLine",
		"getOffsetAtLine",
		"getXAtOffset",
		"getLine",
		"getLineCount",
		"getCharCount",
		"doLineDown",
		"setMouseWordSelectionAnchor",
		"doSelection",
		"showCaret",
		"getCaretLine",
		"getOffsetAtLine",
		"getXAtOffset",
		"getLine",
		"doLineUp",
		"setMouseWordSelectionAnchor",
		"showCaret",
		"doSelection",
		"getCaretLine",
		"getOffsetAtLine",
		"getXAtOffset",
		"getLine",
		"doPageDown",
		"getCaretLine",
		"getOffsetAtLine",
		"getXAtOffset",
		"getLine",
		"doPageUp",
		"getWordEnd",
		"isSingleLine",
		"getLineAtOffset",
		"getLineAtOffset",
		"showCaret",
		"getWordStart",
		"getLineAtOffset",
		"getLineCount",
		"getOffsetAtLine",
		"showCaret",
		"getClusterPrevious",
		"getCaretLine",
		"showCaret",
		"getClusterNext",
		"getCaretLine",
		"showCaret",
		"getCaretLine",
		"showCaret",
		"doSelectionWordNext",
		"getCaretLine",
		"showCaret",
		"doSelectionWordPrevious",
		"redraw",
		"getLineCount",
		"getBackground",
		"getForeground",
		"getGC",
		"isSingleLine",
		"getLine",
		"drawLine",
		"dispose",
		"checkWidget",
		"getSystemColor",
		"getDisplay",
		"checkWidget",
		"getBaseline",
		"checkWidget",
		"getClientArea",
		"min",
		"getLineCount",
		"max",
		"checkWidget",
		"getTextLayout",
		"getOffset",
		"length",
		"isDigit",
		"charAt",
		"isDigit",
		"charAt",
		"isMirrored",
		"getLevel",
		"getLevel",
		"disposeTextLayout",
		"getCaret",
		"getSize",
		"getInstance",
		"getContents",
		"getLine",
		"getOffsetAtLine",
		"getTextLayout",
		"getNextOffset",
		"disposeTextLayout",
		"getLine",
		"getOffsetAtLine",
		"getTextLayout",
		"getPreviousOffset",
		"disposeTextLayout",
		"checkWidget",
		"checkWidget",
		"checkWidget",
		"checkWidget",
		"getSystemColor",
		"getDisplay",
		"getGC",
		"getAverageCharWidth",
		"getFontMetrics",
		"dispose",
		"checkWidget",
		"getHorizontalIncrement",
		"checkWidget",
		"checkWidget",
		"get",
		"intValue",
		"checkWidget",
		"getCharCount",
		"checkWidget",
		"getLineCount",
		"error",
		"getLineBackground",
		"sendLineEvent",
		"checkWidget",
		"getLineAtOffset",
		"getCharCount",
		"getClientArea",
		"checkWidget",
		"getCharCount",
		"error",
		"getLineAtOffset",
		"checkWidget",
		"getLineDelimiter",
		"isListening",
		"getLineAtOffset",
		"getOffsetAtLine",
		"getLine",
		"notifyListeners",
		"checkWidget",
		"sendLineEvent",
		"checkWidget",
		"getCharCount",
		"error",
		"getLineAtOffset",
		"getOffsetAtLine",
		"getLine",
		"getXAtOffset",
		"checkWidget",
		"getLineCount",
		"error",
		"getOffsetAtLine",
		"checkWidget",
		"error",
		"error",
		"getTopPixel",
		"getLineCount",
		"error",
		"getLine",
		"getOffsetAtLine",
		"getTextLayout",
		"getLineBounds",
		"disposeTextLayout",
		"error",
		"getOffset",
		"length",
		"min",
		"length",
		"disposeTextLayout",
		"getLine",
		"getOffsetAtLine",
		"getOffsetAtX",
		"checkWidget",
		"isMirrored",
		"ceil",
		"getClientArea",
		"min",
		"getLineCount",
		"getStart",
		"getCharCount",
		"getLineAtOffset",
		"getStart",
		"getLineAtOffset",
		"getLine",
		"getOffsetAtLine",
		"writeLine",
		"getLine",
		"getOffsetAtLine",
		"writeLineDelimiter",
		"length",
		"writeLineDelimiter",
		"close",
		"toString",
		"checkWidget",
		"checkWidget",
		"checkWidget",
		"getSystemColor",
		"getDisplay",
		"checkWidget",
		"getSelectionRange",
		"checkWidget",
		"getSystemColor",
		"getDisplay",
		"checkWidget",
		"getTextRange",
		"getStyle",
		"isMirrored",
		"isListening",
		"getBidiSegmentsCompatibility",
		"sendLineEvent",
		"length",
		"error",
		"error",
		"arraycopy",
		"length",
		"getLineStyleData",
		"max",
		"max",
		"min",
		"length",
		"similarTo",
		"min",
		"max",
		"arraycopy",
		"checkWidget",
		"getCharCount",
		"error",
		"getStyleRangeAtOffset",
		"checkWidget",
		"getStyleRanges",
		"checkWidget",
		"getCharCount",
		"error",
		"getStyleRangesFor",
		"clone",
		"clone",
		"clone",
		"clone",
		"checkWidget",
		"checkWidget",
		"getTextRange",
		"getCharCount",
		"checkWidget",
		"getCharCount",
		"error",
		"getTextRange",
		"checkWidget",
		"getCharCount",
		"error",
		"getLineAtOffset",
		"getLineAtOffset",
		"getOffsetAtLine",
		"getLine",
		"getTextLayout",
		"getBounds",
		"getBounds",
		"length",
		"getBounds",
		"getLineBounds",
		"min",
		"max",
		"disposeTextLayout",
		"checkWidget",
		"getCharCount",
		"error",
		"getTextRange",
		"checkWidget",
		"checkWidget",
		"getOffsetAtLine",
		"getLineAtOffset",
		"checkWidget",
		"isBidiCaret",
		"getCaretLine",
		"getOffsetAtLine",
		"getLine",
		"length",
		"isMirrored",
		"isDigit",
		"charAt",
		"isDigit",
		"charAt",
		"isMirrored",
		"getTextLayout",
		"getLevel",
		"disposeTextLayout",
		"getLineAtOffset",
		"getLineCount",
		"getOffsetAtLine",
		"getLineAtOffset",
		"getOffsetAtLine",
		"getLine",
		"length",
		"getCharCount",
		"getOffsetAtLine",
		"getTextLayout",
		"getNextOffset",
		"disposeTextLayout",
		"getLineAtOffset",
		"getOffsetAtLine",
		"getLine",
		"length",
		"getCharCount",
		"getOffsetAtLine",
		"charAt",
		"isLetterOrDigit",
		"isLetterOrDigit",
		"isSpaceChar",
		"charAt",
		"isLetterOrDigit",
		"isSpaceChar",
		"getLineAtOffset",
		"getOffsetAtLine",
		"getLine",
		"getLine",
		"getOffsetAtLine",
		"length",
		"getTextLayout",
		"getPreviousOffset",
		"disposeTextLayout",
		"checkWidget",
		"length",
		"getLineCount",
		"getOffsetAtLine",
		"getOffsetAtLine",
		"getTextLayout",
		"getLocation",
		"getLocation",
		"disposeTextLayout",
		"checkWidget",
		"error",
		"getSelectionRange",
		"replaceTextRange",
		"handleTextChanging",
		"handleTextChanged",
		"handleTextSet",
		"addTextChangeListener",
		"addListener",
		"addListener",
		"getVerticalBar",
		"getHorizontalBar",
		"handleDispose",
		"handleKeyDown",
		"handleKeyUp",
		"handleMouseDown",
		"handleMouseUp",
		"handleMouseDoubleClick",
		"handleMouseMove",
		"handlePaint",
		"handleResize",
		"handleTraverse",
		"addListener",
		"addListener",
		"addListener",
		"addListener",
		"addListener",
		"addListener",
		"addListener",
		"addListener",
		"addListener",
		"addListener",
		"addListener",
		"handleVerticalScroll",
		"addListener",
		"handleHorizontalScroll",
		"redraw",
		"getLineAtOffset",
		"getLineAtOffset",
		"getPartialBottomIndex",
		"getOffsetAtLine",
		"getOffsetAtLine",
		"redrawLines",
		"getClientArea",
		"draw",
		"checkWidget",
		"getCharCount",
		"getPlatformDelimitedText",
		"removeListener",
		"notifyListeners",
		"dispose",
		"dispose",
		"dispose",
		"removeTextChangeListener",
		"dispose",
		"dispose",
		"dispose",
		"release",
		"isBidiCaret",
		"removeLanguageListener",
		"getSelection",
		"getHorizontalBar",
		"scrollHorizontal",
		"getKeyBinding",
		"getKeyBinding",
		"getKeyBinding",
		"doContent",
		"invokeAction",
		"notifyListeners",
		"handleKey",
		"setClipboardContent",
		"getWordStart",
		"resetSelection",
		"getWordEndNoSpaces",
		"showCaret",
		"doMouseSelection",
		"getClipboardContent",
		"length",
		"doMouseLocationChange",
		"getModelDelimitedText",
		"sendKeyEvent",
		"doMouseLocationChange",
		"doMouseLocationChange",
		"update",
		"doAutoScroll",
		"endAutoScroll",
		"setClipboardContent",
		"max",
		"performPaint",
		"getClientArea",
		"redraw",
		"redraw",
		"wordWrapResize",
		"getLineCount",
		"ceil",
		"min",
		"min",
		"calculate",
		"setScrollBars",
		"claimBottomFreeSpace",
		"claimRightFreeSpace",
		"calculateTopIndex",
		"textChanged",
		"setScrollBars",
		"updateSelection",
		"claimBottomFreeSpace",
		"claimRightFreeSpace",
		"getLineAtOffset",
		"getGC",
		"getCaret",
		"getVisible",
		"setVisible",
		"performPaint",
		"setVisible",
		"dispose",
		"redraw",
		"getClientArea",
		"update",
		"getLineAtOffset",
		"redrawMultiLineChange",
		"textChanging",
		"getCharCount",
		"reset",
		"getStyle",
		"setVerticalScrollOffset",
		"getSelection",
		"getVerticalBar",
		"getAccessible",
		"addAccessibleListener",
		"getToolTipText",
		"addAccessibleTextListener",
		"getCaretOffset",
		"getSelectionRange",
		"addAccessibleControlListener",
		"isEnabled",
		"isFocusControl",
		"isVisible",
		"getEditable",
		"getText",
		"addListener",
		"setFocus",
		"dispose",
		"getDisplay",
		"getFont",
		"getLineHeight",
		"checkWidget",
		"doLineUp",
		"showCaret",
		"clearSelection",
		"doLineDown",
		"showCaret",
		"clearSelection",
		"doLineStart",
		"clearSelection",
		"doLineEnd",
		"clearSelection",
		"doCursorPrevious",
		"clearSelection",
		"doCursorNext",
		"clearSelection",
		"doPageUp",
		"getLineCountWhole",
		"clearSelection",
		"doPageDown",
		"getLineCountWhole",
		"clearSelection",
		"doWordPrevious",
		"clearSelection",
		"doWordNext",
		"clearSelection",
		"doContentStart",
		"clearSelection",
		"doContentEnd",
		"clearSelection",
		"doPageStart",
		"clearSelection",
		"doPageEnd",
		"clearSelection",
		"doSelectionLineUp",
		"selectAll",
		"doSelectionLineDown",
		"doLineStart",
		"doSelection",
		"doLineEnd",
		"doSelection",
		"doSelectionCursorPrevious",
		"doSelection",
		"doSelectionCursorNext",
		"doSelection",
		"doSelectionPageUp",
		"getLineCountWhole",
		"doSelectionPageDown",
		"getLineCountWhole",
		"doSelectionWordPrevious",
		"doSelection",
		"doSelectionWordNext",
		"doSelection",
		"doContentStart",
		"doSelection",
		"doContentEnd",
		"doSelection",
		"doPageStart",
		"doSelection",
		"doPageEnd",
		"doSelection",
		"cut",
		"copy",
		"paste",
		"doBackspace",
		"doDelete",
		"doDeleteWordPrevious",
		"doDeleteWordNext",
		"isBidiPlatform",
		"getLineAtOffset",
		"getOffsetAtLine",
		"length",
		"getLine",
		"getPartialBottomIndex",
		"getStyle",
		"notifyListeners",
		"isListening",
		"length",
		"getTextRange",
		"length",
		"getLineAtOffset",
		"getOffsetAtLine",
		"getLine",
		"getTextLayout",
		"getLevel",
		"getLineAtOffset",
		"disposeTextLayout",
		"getOffsetAtLine",
		"getLine",
		"getTextLayout",
		"getLevel",
		"disposeTextLayout",
		"replaceTextRange",
		"internalSetSelection",
		"length",
		"showCaret",
		"sendModifyEvent",
		"isListening",
		"notifyListeners",
		"checkWidget",
		"getClipboardContent",
		"length",
		"getModelDelimitedText",
		"sendKeyEvent",
		"getClientArea",
		"getBackground",
		"getForeground",
		"getLineCount",
		"isMirrored",
		"isSingleLine",
		"getDisplay",
		"setFont",
		"getFont",
		"setForeground",
		"setBackground",
		"getLine",
		"drawLine",
		"setBackground",
		"fillRectangle",
		"clearMargin",
		"drawImage",
		"dispose",
		"dispose",
		"clearMargin",
		"checkWidget",
		"run",
		"dispose",
		"checkWidget",
		"error",
		"print",
		"checkWidget",
		"error",
		"redraw",
		"getPartialBottomIndex",
		"redrawReset",
		"calculate",
		"setHorizontalScrollBar",
		"redraw",
		"getLineCount",
		"getTopPixel",
		"ceil",
		"min",
		"min",
		"reset",
		"getPartialBottomIndex",
		"calculate",
		"setHorizontalScrollBar",
		"getLine",
		"getXAtOffset",
		"redraw",
		"getClientArea",
		"getLine",
		"getOffsetAtLine",
		"getClientArea",
		"getStyle",
		"length",
		"getTextLayout",
		"getBounds",
		"min",
		"length",
		"disposeTextLayout",
		"intersect",
		"draw",
		"getOffsetAtLine",
		"getLine",
		"length",
		"getLine",
		"getTextLayout",
		"getBounds",
		"disposeTextLayout",
		"intersect",
		"draw",
		"getClientArea",
		"max",
		"max",
		"scroll",
		"redraw",
		"redraw",
		"checkWidget",
		"getCharCount",
		"error",
		"getLineAtOffset",
		"getLineAtOffset",
		"reset",
		"internalRedrawRange",
		"checkWidget",
		"error",
		"removeListener",
		"checkWidget",
		"error",
		"removeListener",
		"checkWidget",
		"error",
		"removeListener",
		"isListening",
		"addListener",
		"checkWidget",
		"error",
		"removeListener",
		"isListening",
		"addListener",
		"checkWidget",
		"error",
		"removeListener",
		"checkWidget",
		"error",
		"removeListener",
		"checkWidget",
		"error",
		"removeListener",
		"error",
		"removeListener",
		"checkWidget",
		"error",
		"setStyleRange",
		"getCharCount",
		"error",
		"getLineAtOffset",
		"getLineAtOffset",
		"replaceStyleRanges",
		"reset",
		"isAreaVisible",
		"draw",
		"getClientArea",
		"setCaretLocation",
		"checkWidget",
		"getCharCount",
		"error",
		"error",
		"modifyContent",
		"getVerticalBar",
		"getHorizontalBar",
		"resetSelection",
		"removeLineBackgroundListener",
		"removeLineStyleListener",
		"installDefaultLineStyler",
		"calculateContentWidth",
		"setSelection",
		"setSelection",
		"setScrollBars",
		"setCaretLocation",
		"redraw",
		"getClientArea",
		"scroll",
		"redraw",
		"scroll",
		"redraw",
		"setCaretLocation",
		"getHorizontalBar",
		"setSelection",
		"scrollHorizontal",
		"checkWidget",
		"setSelection",
		"max",
		"getCharCount",
		"modifyContent",
		"getAccessible",
		"length",
		"textChanged",
		"textChanged",
		"length",
		"textChanged",
		"textChanged",
		"length",
		"notifyListeners",
		"textSelectionChanged",
		"getAccessible",
		"notifyListeners",
		"checkWidget",
		"getStyle",
		"getHorizontalBar",
		"calculateContentWidth",
		"setVisible",
		"setScrollBars",
		"setCaretLocation",
		"redraw",
		"checkWidget",
		"setCaret",
		"setCaretLocation",
		"checkWidget",
		"setBackground",
		"getBackground",
		"redraw",
		"checkWidget",
		"getCaret",
		"isMirrored",
		"getSize",
		"setLocation",
		"textCaretMoved",
		"getAccessible",
		"getCaretOffset",
		"setImage",
		"setImage",
		"setImage",
		"setSize",
		"getSize",
		"setKeyboardLanguage",
		"setKeyboardLanguage",
		"getCaretLine",
		"getLine",
		"getOffsetAtLine",
		"getXAtOffset",
		"setCaretLocation",
		"getCaretDirection",
		"checkWidget",
		"getCharCount",
		"isLineDelimiter",
		"error",
		"clearSelection",
		"setCaretLocation",
		"getInstance",
		"getPlatformDelimitedText",
		"getInstance",
		"getPlatformDelimitedText",
		"setContents",
		"checkWidget",
		"error",
		"removeTextChangeListener",
		"addTextChangeListener",
		"reset",
		"setCursor",
		"setCursor",
		"checkWidget",
		"checkWidget",
		"checkWidget",
		"setFont",
		"initializeRenderer",
		"setVerticalScrollOffset",
		"claimBottomFreeSpace",
		"calculateContentWidth",
		"calculateScrollBars",
		"isBidiCaret",
		"createCaretBitmaps",
		"setCaretLocation",
		"redraw",
		"checkWidget",
		"setForeground",
		"getForeground",
		"redraw",
		"checkWidget",
		"getClientArea",
		"getCharCount",
		"getHorizontalIncrement",
		"getWidth",
		"max",
		"scrollHorizontalBar",
		"checkWidget",
		"getClientArea",
		"getCharCount",
		"getWidth",
		"max",
		"scrollHorizontalBar",
		"getHorizontalBar",
		"getVisible",
		"getClientArea",
		"getWidth",
		"setValues",
		"getSelection",
		"getMinimum",
		"getWidth",
		"getIncrement",
		"getThumb",
		"getMaximum",
		"setValues",
		"getSelection",
		"getMinimum",
		"getIncrement",
		"checkWidget",
		"getPartialBottomIndex",
		"getLineCount",
		"error",
		"setLineBackground",
		"redraw",
		"getClientArea",
		"isMirrored",
		"isMirrored",
		"setOrientation",
		"initializeRenderer",
		"setCaretLocation",
		"clear",
		"createKeyBindings",
		"redraw",
		"getVerticalBar",
		"getClientArea",
		"getLineCount",
		"getVerticalIncrement",
		"setValues",
		"getSelection",
		"getMinimum",
		"getIncrement",
		"getThumb",
		"getMaximum",
		"setValues",
		"getSelection",
		"getMinimum",
		"getIncrement",
		"setHorizontalScrollBar",
		"setSelection",
		"checkWidget",
		"error",
		"setSelection",
		"checkWidget",
		"isDisposed",
		"error",
		"redraw",
		"checkWidget",
		"isDisposed",
		"error",
		"redraw",
		"setSelectionRange",
		"showSelection",
		"checkWidget",
		"getCharCount",
		"max",
		"min",
		"isLineDelimiter",
		"isLineDelimiter",
		"error",
		"internalSetSelection",
		"setCaretLocation",
		"clearSelection",
		"internalRedrawRange",
		"checkWidget",
		"getCharCount",
		"error",
		"setStyleRange",
		"getLineAtOffset",
		"getLineAtOffset",
		"reset",
		"isAreaVisible",
		"draw",
		"getClientArea",
		"reset",
		"getLineCount",
		"redraw",
		"setCaretLocation",
		"checkWidget",
		"error",
		"getLineAtOffset",
		"getCharCount",
		"error",
		"getLineAtOffset",
		"reset",
		"reset",
		"getLineCount",
		"setStyleRanges",
		"redraw",
		"setCaretLocation",
		"checkWidget",
		"setTabLength",
		"showCaret",
		"clearSelection",
		"reset",
		"getLineCount",
		"redraw",
		"checkWidget",
		"error",
		"getCharCount",
		"notifyListeners",
		"isListening",
		"length",
		"getTextRange",
		"setText",
		"sendModifyEvent",
		"notifyListeners",
		"checkWidget",
		"error",
		"checkWidget",
		"getLineCount",
		"max",
		"min",
		"getLineCountWhole",
		"getCharCount",
		"getOffsetAtLine",
		"getLineAtOffset",
		"setVerticalScrollOffset",
		"getVerticalIncrement",
		"checkWidget",
		"getLineCount",
		"getClientArea",
		"max",
		"getVerticalIncrement",
		"getCharCount",
		"setVerticalScrollOffset",
		"getVerticalBar",
		"setSelection",
		"getClientArea",
		"scroll",
		"calculateTopIndex",
		"setCaretLocation",
		"getClientArea",
		"getVerticalIncrement",
		"max",
		"scrollHorizontalBar",
		"min",
		"getWidth",
		"scrollHorizontalBar",
		"setVerticalScrollOffset",
		"getBottomIndex",
		"setVerticalScrollOffset",
		"getClientArea",
		"getLineAtOffset",
		"showCaret",
		"getOffsetAtLine",
		"getLine",
		"getXAtOffset",
		"showLocation",
		"getCaret",
		"getLocation",
		"getVerticalIncrement",
		"setCaretLocation",
		"getCaretDirection",
		"getLineAtOffset",
		"getOffsetAtLine",
		"getLine",
		"getXAtOffset",
		"showLocation",
		"checkWidget",
		"getLineAtOffset",
		"getOffsetAtLine",
		"getXAtOffset",
		"getLine",
		"getLineAtOffset",
		"getOffsetAtLine",
		"getXAtOffset",
		"getLine",
		"getClientArea",
		"showLocation",
		"getXAtOffset",
		"getLine",
		"showLocation",
		"showLocation",
		"isBidiPlatform",
		"internalRedrawRange",
		"internalRedrawRange",
		"internalSetSelection",
		"setCaretLocation",
		"internalSetSelection",
		"setCaretLocation",
		"getLineCount",
		"getLineCount",
		"wrapLines",
		"getLineAtOffset",
		"getLineCount",
		"getOffsetAtLine",
		"getVerticalBar",
		"getVerticalIncrement",
		"getOffsetAtLine",
		"setSelection",
		"setCaretLocation",
		"redraw",
		"Point",
		"Hashtable",
		"Hashtable",
		"Hashtable",
		"Hashtable",
		"Integer",
		"Integer",
		"Integer",
		"DefaultContent",
		"Hashtable",
		"Font",
		"GC",
		"PrintRenderer",
		"Color",
		"StringBuffer",
		"TextLayout",
		"Vector",
		"StringBuffer",
		"StringBuffer",
		"Clipboard",
		"ContentWidthCache",
		"Caret",
		"Runnable",
		"Cursor",
		"StyledTextListener",
		"Integer",
		"Integer",
		"Integer",
		"Integer",
		"Integer",
		"Integer",
		"Integer",
		"Integer",
		"Integer",
		"StyledTextListener",
		"StyledTextListener",
		"StyledTextListener",
		"TypedListener",
		"TypedListener",
		"StyledTextListener",
		"TypedListener",
		"ContentWidthCache",
		"WrappedContent",
		"Point",
		"StringBuffer",
		"Image",
		"GC",
		"Image",
		"GC",
		"Runnable",
		"Runnable",
		"Runnable",
		"Runnable",
		"Event",
		"Event",
		"String",
		"String",
		"Event",
		"Event",
		"Event",
		"GC",
		"Integer",
		"StyledTextEvent",
		"WordWrapCache",
		"ContentWidthCache",
		"Point",
		"Point",
		"Point",
		"Rectangle",
		"TextChangeListener",
		"DefaultContent",
		"DefaultLineStyler",
		"StyledTextListener",
		"Listener",
		"Listener",
		"Listener",
		"RTFWriter",
		"Point",
		"Event",
		"Point",
		"Event",
		"AccessibleAdapter",
		"AccessibleTextAdapter",
		"AccessibleControlAdapter",
		"Listener",
		"DisplayRenderer",
		"WrappedContent",
		"StyledTextEvent",
		"Event",
		"Image",
		"GC",
		"Printer",
		"StyledTextPrintOptions",
		"Printing",
		"StyledTextPrintOptions",
		"Printing",
		"StyledTextListener",
		"StyledTextListener",
		"StyleRange",
		"Event",
		"Event",
		"WrappedContent",
		"TextWriter",
		"RTFWriter",
		"WrappedContent",
		"Event",
		"StyledTextEvent"
	],
	"methodsBody":{
		"void doWordNext()":{
			"methodBody":"{\n    if (selection.y - selection.x > 0) {\n        int caretLine;\n        caretOffset = selection.y;\n        caretLine = getCaretLine();\n        showCaret(caretLine);\n    } else {\n        doSelectionWordNext();\n    }\n}",
			"comments":"/**\n* Moves the caret to the end of the next word.\n* If a selection exists, move the caret to the end of the selection\n* and remove the selection.\n*/\n",
			"methodName":"void doWordNext()"
		},
		"public void setCaretOffset(int offset)":{
			"methodBody":"{\n    checkWidget();\n    int length = getCharCount();\n    if (length > 0 && offset != caretOffset) {\n        if (offset < 0) {\n            caretOffset = 0;\n        } else if (offset > length) {\n            caretOffset = length;\n        } else {\n            if (isLineDelimiter(offset)) {\n                \n                \n                SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n            }\n            caretOffset = offset;\n        }\n        \n        \n        clearSelection(false);\n    }\n    \n    setCaretLocation();\n}",
			"comments":"/**\n* Sets the caret offset.\n*\n* @param offset caret offset, relative to the first character in the text.\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*   <li>ERROR_INVALID_ARGUMENT when either the start or the end of the selection range is inside a\n* multi byte line delimiter (and thus neither clearly in front of or after the line delimiter)\n* </ul>\n*/\n// offset is inside a multi byte line delimiter. This is an\n// illegal operation and an exception is thrown. Fixes 1GDKK3R\n// clear the selection if the caret is moved.\n// don't notify listeners about the selection change.\n// always update the caret location. fixes 1G8FODP\n",
			"methodName":"public void setCaretOffset(int offset)"
		},
		"GC getGC()":{
			"methodBody":"{\n    return new GC(this);\n}",
			"comments":"/**\n* Return a GC to use for rendering and update the cached font style to\n* represent the current style.\n* <p>\n*\n* @return GC.\n*/\n",
			"methodName":"GC getGC()"
		},
		"public void redraw(int x, int y, int width, int height, boolean all)":{
			"methodBody":"{\n    super.redraw(x, y, width, height, all);\n    if (height > 0) {\n        int lineCount = content.getLineCount();\n        int startLine = (getTopPixel() + y) / lineHeight;\n        int endLine = startLine + Compatibility.ceil(height, lineHeight);\n        int itemCount;\n        \n        startLine = Math.min(startLine, lineCount);\n        itemCount = Math.min(endLine, lineCount) - startLine;\n        lineCache.reset(startLine, itemCount, true);\n        \n        itemCount = getPartialBottomIndex() - topIndex + 1;\n        lineCache.calculate(topIndex, itemCount);\n        setHorizontalScrollBar();\n    }\n}",
			"comments":"/**\n* Causes the rectangular area of the receiver specified by\n* the arguments to be marked as needing to be redrawn.\n* The next time a paint request is processed, that area of\n* the receiver will be painted. If the <code>all</code> flag\n* is <code>true</code>, any children of the receiver which\n* intersect with the specified area will also paint their\n* intersecting areas. If the <code>all</code> flag is\n* <code>false</code>, the children will not be painted.\n* <p>\n* Marks the content width of all lines in the specified rectangle\n* as unknown. Recalculates the content width of all visible lines.\n* When a <code>LineStyleListener</code> is used a redraw call\n* is the only notification to the widget that styles have changed\n* and that the content width may have changed.\n* </p>\n*\n* @param x the x coordinate of the area to draw\n* @param y the y coordinate of the area to draw\n* @param width the width of the area to draw\n* @param height the height of the area to draw\n* @param all <code>true</code> if children should redraw, and <code>false</code> otherwise\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see Control#update\n*/\n// reset all lines in the redraw rectangle\n// only calculate the visible lines\n",
			"methodName":"public void redraw(int x, int y, int width, int height, boolean all)"
		},
		"public void setBidiColoring(boolean mode)":{
			"methodBody":"{\n    checkWidget();\n    bidiColoring = mode;\n}",
			"comments":"/**\n* Sets the BIDI coloring mode.  When true the BIDI text display\n* algorithm is applied to segments of text that are the same\n* color.\n*\n* @param mode the new coloring mode\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* <p>\n* @deprecated use BidiSegmentListener instead.\n* </p>\n*/\n",
			"methodName":"public void setBidiColoring(boolean mode)"
		},
		"public void copy()":{
			"methodBody":"{\n    checkWidget();\n    copy(DND.CLIPBOARD);\n}",
			"comments":"/**\n* Copies the selected text to the <code>DND.CLIPBOARD</code> clipboard.\n* The text will be put on the clipboard in plain text format and RTF format.\n* The <code>DND.CLIPBOARD</code> clipboard is used for data that is\n*  transferred by keyboard accelerator (such as Ctrl+C/Ctrl+V) or\n*  by menu action.\n*\n* <p>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void copy()"
		},
		"void doMouseLocationChange(int x, int y, boolean select)":{
			"methodBody":"{\n    int line = (y + verticalScrollOffset) / lineHeight;\n    int lineCount = content.getLineCount();\n    int newCaretOffset;\n    int newCaretLine;\n    boolean oldAdvancing = advancing;\n    updateCaretDirection = true;\n    if (line > lineCount - 1) {\n        line = lineCount - 1;\n    }\n    \n    if (line < 0 || (isSingleLine() && line > 0)) {\n        return;\n    }\n    newCaretOffset = getOffsetAtMouseLocation(x, line);\n    if (mouseDoubleClick) {\n        \n        newCaretOffset = doMouseWordSelect(x, newCaretOffset, line);\n    }\n    newCaretLine = content.getLineAtOffset(newCaretOffset);\n    \n    if (y >= 0 && y < getClientArea().height && (x >= 0 && x < getClientArea().width || wordWrap || newCaretLine != content.getLineAtOffset(caretOffset))) {\n        if (newCaretOffset != caretOffset || advancing != oldAdvancing) {\n            caretOffset = newCaretOffset;\n            if (select) {\n                doMouseSelection();\n            }\n            showCaret();\n        }\n    }\n    if (select == false) {\n        caretOffset = newCaretOffset;\n        clearSelection(true);\n    }\n}",
			"comments":"/**\n* Moves the caret to the specified location.\n* <p>\n*\n* @param x x location of the new caret position\n* @param y y location of the new caret position\n* @param select the location change is a selection operation.\n* \tinclude the line delimiter in the selection\n*/\n// allow caret to be placed below first line only if receiver is\n// not in single line mode. fixes 4820.\n// double click word select the previous/next word. fixes bug 15610\n// Is the mouse within the left client area border or on\n// a different line? If not the autoscroll selection\n// could be incorrectly reset. Fixes 1GKM3XS\n",
			"methodName":"void doMouseLocationChange(int x, int y, boolean select)"
		},
		"public void textSet(TextChangedEvent event)":{
			"methodBody":"{\n    handleTextSet(event);\n}",
			"comments":"",
			"methodName":"public void textSet(TextChangedEvent event)"
		},
		"void doAutoScroll(int direction, int distance)":{
			"methodBody":"{\n    Runnable timer = null;\n    final int TIMER_INTERVAL = 50;\n    autoScrollDistance = distance;\n    \n    if (autoScrollDirection == direction) {\n        return;\n    }\n    final Display display = getDisplay();\n    \n    if (direction == SWT.UP) {\n        timer = new Runnable() {\n\n            public void run() {\n                if (autoScrollDirection == SWT.UP) {\n                    int lines = (autoScrollDistance / getLineHeight()) + 1;\n                    doSelectionPageUp(lines);\n                    display.timerExec(TIMER_INTERVAL, this);\n                }\n            }\n        };\n    } else if (direction == SWT.DOWN) {\n        timer = new Runnable() {\n\n            public void run() {\n                if (autoScrollDirection == SWT.DOWN) {\n                    int lines = (autoScrollDistance / getLineHeight()) + 1;\n                    doSelectionPageDown(lines);\n                    display.timerExec(TIMER_INTERVAL, this);\n                }\n            }\n        };\n    } else if (direction == ST.COLUMN_NEXT) {\n        timer = new Runnable() {\n\n            public void run() {\n                if (autoScrollDirection == ST.COLUMN_NEXT) {\n                    doVisualNext();\n                    setMouseWordSelectionAnchor();\n                    doMouseSelection();\n                    display.timerExec(TIMER_INTERVAL, this);\n                }\n            }\n        };\n    } else if (direction == ST.COLUMN_PREVIOUS) {\n        timer = new Runnable() {\n\n            public void run() {\n                if (autoScrollDirection == ST.COLUMN_PREVIOUS) {\n                    doVisualPrevious();\n                    setMouseWordSelectionAnchor();\n                    doMouseSelection();\n                    display.timerExec(TIMER_INTERVAL, this);\n                }\n            }\n        };\n    }\n    if (timer != null) {\n        autoScrollDirection = direction;\n        display.timerExec(TIMER_INTERVAL, timer);\n    }\n}",
			"comments":"/**\n* Initiates autoscrolling.\n* <p>\n*\n* @param direction SWT.UP, SWT.DOWN, SWT.COLUMN_NEXT, SWT.COLUMN_PREVIOUS\n*/\n// If we're already autoscrolling in the given direction do nothing\n// Set a timer that will simulate the user pressing and holding\n// down a cursor key (i.e., arrowUp, arrowDown).\n",
			"methodName":"void doAutoScroll(int direction, int distance)"
		},
		"void internalRedraw()":{
			"methodBody":"{\n    super.redraw();\n}",
			"comments":"/**\n* Used by WordWrapCache to bypass StyledText.redraw which does\n* an unwanted cache reset.\n*/\n",
			"methodName":"void internalRedraw()"
		},
		"void handleResize(Event event)":{
			"methodBody":"{\n    int oldHeight = clientAreaHeight;\n    int oldWidth = clientAreaWidth;\n    Rectangle clientArea = getClientArea();\n    clientAreaHeight = clientArea.height;\n    clientAreaWidth = clientArea.width;\n    \n    if (oldWidth != clientAreaWidth) {\n        if (rightMargin > 0) {\n            int x = (oldWidth < clientAreaWidth ? oldWidth : clientAreaWidth) - rightMargin;\n            redraw(x, 0, rightMargin, oldHeight, false);\n        }\n    }\n    if (oldHeight != clientAreaHeight) {\n        if (bottomMargin > 0) {\n            int y = (oldHeight < clientAreaHeight ? oldHeight : clientAreaHeight) - bottomMargin;\n            redraw(0, y, oldWidth, bottomMargin, false);\n        }\n    }\n    if (wordWrap) {\n        if (oldWidth != clientAreaWidth) {\n            wordWrapResize(oldWidth);\n        }\n    } else if (clientAreaHeight > oldHeight) {\n        int lineCount = content.getLineCount();\n        int oldBottomIndex = topIndex + oldHeight / lineHeight;\n        int newItemCount = Compatibility.ceil(clientAreaHeight - oldHeight, lineHeight);\n        oldBottomIndex = Math.min(oldBottomIndex, lineCount);\n        newItemCount = Math.min(newItemCount, lineCount - oldBottomIndex);\n        lineCache.calculate(oldBottomIndex, newItemCount);\n    }\n    setScrollBars();\n    claimBottomFreeSpace();\n    claimRightFreeSpace();\n    if (oldHeight != clientAreaHeight) {\n        calculateTopIndex();\n    }\n}",
			"comments":"/**\n* Recalculates the scroll bars. Rewraps all lines when in word\n* wrap mode.\n* <p>\n*\n* @param event resize event\n*/\n/* Redraw the old or new right/bottom margin if needed */\n",
			"methodName":"void handleResize(Event event)"
		},
		"public void removeSelectionListener(SelectionListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null) {\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    }\n    removeListener(SWT.Selection, listener);\n}",
			"comments":"/**\n* Removes the specified selection listener.\n* <p>\n*\n* @param listener the listener\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT when listener is null</li>\n* </ul>\n*/\n",
			"methodName":"public void removeSelectionListener(SelectionListener listener)"
		},
		"public void getSelectionRange(AccessibleTextEvent e)":{
			"methodBody":"{\n    Point selection = StyledText.this.getSelectionRange();\n    e.offset = selection.x;\n    e.length = selection.y;\n}",
			"comments":"",
			"methodName":"public void getSelectionRange(AccessibleTextEvent e)"
		},
		"public int getTopIndex()":{
			"methodBody":"{\n    checkWidget();\n    int logicalTopIndex = topIndex;\n    if (wordWrap) {\n        int visualLineOffset = content.getOffsetAtLine(topIndex);\n        logicalTopIndex = logicalContent.getLineAtOffset(visualLineOffset);\n    }\n    return logicalTopIndex;\n}",
			"comments":"/**\n* Gets the top index.  The top index is the index of the fully visible line that\n* is currently at the top of the widget or the topmost partially visible line if\n* no line is fully visible.\n* The top index changes when the widget is scrolled. Indexing is zero based.\n* <p>\n*\n* @return the index of the top line\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getTopIndex()"
		},
		"void endPage(int page)":{
			"methodBody":"{\n    printDecoration(page, false);\n    printer.endPage();\n}",
			"comments":"/**\n* Finish printing the indicated page.\n*\n* @param page page that was printed\n*/\n",
			"methodName":"void endPage(int page)"
		},
		"void write(String string)":{
			"methodBody":"{\n    buffer.append(string);\n}",
			"comments":"/**\n* Appends the given string to the data.\n*/\n",
			"methodName":"void write(String string)"
		},
		"public void setHorizontalIndex(int offset)":{
			"methodBody":"{\n    checkWidget();\n    int clientAreaWidth = getClientArea().width;\n    if (getCharCount() == 0) {\n        return;\n    }\n    if (offset < 0) {\n        offset = 0;\n    }\n    offset *= getHorizontalIncrement();\n    \n    if (clientAreaWidth > 0) {\n        int width = lineCache.getWidth();\n        \n        if (offset > width - clientAreaWidth) {\n            offset = Math.max(0, width - clientAreaWidth);\n        }\n    }\n    scrollHorizontalBar(offset - horizontalScrollOffset);\n}",
			"comments":"/**\n* Sets the horizontal scroll offset relative to the start of the line.\n* Do nothing if there is no text set.\n* <p>\n* <b>NOTE:</b> The horizontal index is reset to 0 when new text is set in the\n* widget.\n* </p>\n*\n* @param offset horizontal scroll offset relative to the start\n* \tof the line, measured in character increments starting at 0, if\n* \tequal to 0 the content is not scrolled, if > 0 = the content is scrolled.\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n// allow any value if client area width is unknown or 0.\n// offset will be checked in resize handler.\n// don't use isVisible since width is known even if widget\n// is temporarily invisible\n// prevent scrolling if the content fits in the client area.\n// align end of longest line with right border of client area\n// if offset is out of range.\n",
			"methodName":"public void setHorizontalIndex(int offset)"
		},
		"public void handleEvent(Event event)":{
			"methodBody":"{\n    accessible.setFocus(ACC.CHILDID_SELF);\n}",
			"comments":"",
			"methodName":"public void handleEvent(Event event)"
		},
		"public void writeLineDelimiter(String lineDelimiter)":{
			"methodBody":"{\n    if (isClosed) {\n        SWT.error(SWT.ERROR_IO);\n    }\n    write(lineDelimiter);\n}",
			"comments":"/**\n* Appends the specified line delmimiter to the data.\n* <p>\n*\n* @param lineDelimiter line delimiter to write\n* @exception SWTException <ul>\n*   <li>ERROR_IO when the writer is closed.</li>\n* </ul>\n*/\n",
			"methodName":"public void writeLineDelimiter(String lineDelimiter)"
		},
		"public boolean getEditable()":{
			"methodBody":"{\n    checkWidget();\n    return editable;\n}",
			"comments":"/**\n* Returns whether the widget content can be edited.\n* <p>\n*\n* @return true if content can be edited, false otherwise\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public boolean getEditable()"
		},
		"int getOffsetAtMouseLocation(int x, int line)":{
			"methodBody":"{\n    String lineText = content.getLine(line);\n    int lineOffset = content.getOffsetAtLine(line);\n    return getOffsetAtX(lineText, lineOffset, x) + lineOffset;\n}",
			"comments":"/**\n* Returns the offset at the specified x location in the specified line.\n* <p>\n*\n* @param x\tx location of the mouse location\n* @param line\tline the mouse location is in\n* @return the offset at the specified x location in the specified line,\n* \trelative to the beginning of the document\n*/\n",
			"methodName":"int getOffsetAtMouseLocation(int x, int line)"
		},
		"public void calculate(int startLine, int lineCount)":{
			"methodBody":"{\n}",
			"comments":"/**\n* Do nothing. Lines are wrapped immediately after reset.\n* <p>\n*\n* @param startLine first line to calculate\n* @param lineCount number of lines to calculate\n*/\n",
			"methodName":"public void calculate(int startLine, int lineCount)"
		},
		"void endAutoScroll()":{
			"methodBody":"{\n    autoScrollDirection = SWT.NULL;\n}",
			"comments":"/**\n* Ends the autoscroll process.\n*/\n",
			"methodName":"void endAutoScroll()"
		},
		"public void run()":{
			"methodBody":"{\n    if (autoScrollDirection == ST.COLUMN_PREVIOUS) {\n        doVisualPrevious();\n        setMouseWordSelectionAnchor();\n        doMouseSelection();\n        display.timerExec(TIMER_INTERVAL, this);\n    }\n}",
			"comments":"",
			"methodName":"public void run()"
		},
		"public void setSelectionBackground(Color color)":{
			"methodBody":"{\n    checkWidget();\n    if (color != null) {\n        if (color.isDisposed())\n            SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    }\n    selectionBackground = color;\n    redraw();\n}",
			"comments":"/**\n* Sets the receiver's selection background color to the color specified\n* by the argument, or to the default system color for the control\n* if the argument is null.\n*\n* @param color the new color (or null)\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @since 2.1\n*/\n",
			"methodName":"public void setSelectionBackground(Color color)"
		},
		"public int getCaretOffset()":{
			"methodBody":"{\n    checkWidget();\n    return caretOffset;\n}",
			"comments":"/**\n* Returns the caret position relative to the start of the text.\n* <p>\n*\n* @return the caret position relative to the start of the text.\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getCaretOffset()"
		},
		"boolean internalGetWordWrap()":{
			"methodBody":"{\n    return wordWrap;\n}",
			"comments":"",
			"methodName":"boolean internalGetWordWrap()"
		},
		"public void setFont(Font font)":{
			"methodBody":"{\n    checkWidget();\n    int oldLineHeight = lineHeight;\n    super.setFont(font);\n    initializeRenderer();\n    \n    if (lineHeight != oldLineHeight) {\n        setVerticalScrollOffset(verticalScrollOffset * lineHeight / oldLineHeight, true);\n        claimBottomFreeSpace();\n    }\n    calculateContentWidth();\n    calculateScrollBars();\n    if (isBidiCaret())\n        createCaretBitmaps();\n    caretDirection = SWT.NULL;\n    \n    setCaretLocation();\n    super.redraw();\n}",
			"comments":"/**\n* Sets a new font to render text with.\n* <p>\n* <b>NOTE:</b> Italic fonts are not supported unless they have no overhang\n* and the same baseline as regular fonts.\n* </p>\n*\n* @param font new font\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n// keep the same top line visible. fixes 5815\n// always set the caret location. Fixes 6685\n",
			"methodName":"public void setFont(Font font)"
		},
		"void doSelectionLineDown()":{
			"methodBody":"{\n    int oldColumnX;\n    int caretLine;\n    int lineStartOffset;\n    if (isSingleLine()) {\n        return;\n    }\n    caretLine = getCaretLine();\n    lineStartOffset = content.getOffsetAtLine(caretLine);\n    \n    oldColumnX = columnX = getXAtOffset(content.getLine(caretLine), caretLine, caretOffset - lineStartOffset);\n    if (caretLine == content.getLineCount() - 1) {\n        caretOffset = content.getCharCount();\n    } else {\n        caretLine = doLineDown();\n    }\n    setMouseWordSelectionAnchor();\n    \n    \n    doSelection(ST.COLUMN_NEXT);\n    \n    \n    showCaret(caretLine);\n    \n    columnX = oldColumnX;\n}",
			"comments":"/**\n* Moves the caret one line down and to the same character offset relative\n* to the beginning of the line. Moves the caret to the end of the new line\n* if the new line is shorter than the character offset.\n* Moves the caret to the end of the text if the caret already is on the\n* last line.\n* Adjusts the selection according to the caret change. This can either add\n* to or subtract from the old selection, depending on the previous selection\n* direction.\n*/\n// reset columnX on selection\n// select first and then scroll to reduce flash when key\n// repeat scrolls lots of lines\n// explicitly go to the calculated caret line. may be different\n// from content.getLineAtOffset(caretOffset) when in word wrap mode\n// save the original horizontal caret position\n",
			"methodName":"void doSelectionLineDown()"
		},
		"public void removeVerifyKeyListener(VerifyKeyListener listener)":{
			"methodBody":"{\n    if (listener == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    removeListener(VerifyKey, listener);\n}",
			"comments":"/**\n* Removes the specified key verify listener.\n* <p>\n*\n* @param listener the listener\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT when listener is null</li>\n* </ul>\n*/\n",
			"methodName":"public void removeVerifyKeyListener(VerifyKeyListener listener)"
		},
		"public int getTopPixel()":{
			"methodBody":"{\n    checkWidget();\n    return verticalScrollOffset;\n}",
			"comments":"/**\n* Gets the top pixel.  The top pixel is the pixel position of the line that is\n* currently at the top of the widget.The text widget can be scrolled by pixels\n* by dragging the scroll thumb so that a partial line may be displayed at the top\n* the widget.  The top pixel changes when the widget is scrolled.  The top pixel\n* does not include the widget trimming.\n* <p>\n*\n* @return pixel position of the top line\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getTopPixel()"
		},
		"public int getOrientation()":{
			"methodBody":"{\n    checkWidget();\n    return isMirrored() ? SWT.RIGHT_TO_LEFT : SWT.LEFT_TO_RIGHT;\n}",
			"comments":"/**\n* Return the orientation of the receiver.\n*\n* @return the orientation style\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 2.1.2\n*/\n",
			"methodName":"public int getOrientation()"
		},
		"int getWordEndNoSpaces(int offset)":{
			"methodBody":"{\n    int line = logicalContent.getLineAtOffset(offset);\n    int lineOffset = logicalContent.getOffsetAtLine(line);\n    String lineText = logicalContent.getLine(line);\n    int lineLength = lineText.length();\n    if (offset >= getCharCount()) {\n        return offset;\n    }\n    if (offset == lineOffset + lineLength) {\n        line++;\n        offset = logicalContent.getOffsetAtLine(line);\n    } else {\n        offset -= lineOffset;\n        char ch = lineText.charAt(offset);\n        boolean letterOrDigit = Compatibility.isLetterOrDigit(ch);\n        while (offset < lineLength - 1 && Compatibility.isLetterOrDigit(ch) == letterOrDigit && Compatibility.isSpaceChar(ch) == false) {\n            offset++;\n            ch = lineText.charAt(offset);\n        }\n        if (offset == lineLength - 1 && Compatibility.isLetterOrDigit(ch) == letterOrDigit && Compatibility.isSpaceChar(ch) == false) {\n            offset++;\n        }\n        offset += lineOffset;\n    }\n    return offset;\n}",
			"comments":"/**\n* Returns the offset of the character after the word at the specified\n* offset.\n* <p>\n* There are two classes of words formed by a sequence of characters:\n* <ul>\n* <li>from 0-9 and A-z (ASCII 48-57 and 65-122)\n* <li>every other character except line breaks\n* </ul>\n* </p>\n* <p>\n* Spaces are ignored and do not represent a word.  Line breaks are treated\n* as one word.\n* </p>\n*/\n",
			"methodName":"int getWordEndNoSpaces(int offset)"
		},
		"public void addLineStyleListener(LineStyleListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null) {\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    }\n    if (userLineStyle == false) {\n        removeLineStyleListener(defaultLineStyler);\n        defaultLineStyler.setStyleRange(null);\n        userLineStyle = true;\n    }\n    StyledTextListener typedListener = new StyledTextListener(listener);\n    addListener(LineGetStyle, typedListener);\n}",
			"comments":"/**\n* Adds a line style listener. A LineGetStyle event is sent by the widget to\n* determine the styles for a line.\n* <p>\n*\n* @param listener the listener\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT when listener is null</li>\n* </ul>\n*/\n",
			"methodName":"public void addLineStyleListener(LineStyleListener listener)"
		},
		"void initializeAccessible()":{
			"methodBody":"{\n    final Accessible accessible = getAccessible();\n    accessible.addAccessibleListener(new AccessibleAdapter() {\n\n        public void getHelp(AccessibleEvent e) {\n            e.result = getToolTipText();\n        }\n    });\n    accessible.addAccessibleTextListener(new AccessibleTextAdapter() {\n\n        public void getCaretOffset(AccessibleTextEvent e) {\n            e.offset = StyledText.this.getCaretOffset();\n        }\n\n        public void getSelectionRange(AccessibleTextEvent e) {\n            Point selection = StyledText.this.getSelectionRange();\n            e.offset = selection.x;\n            e.length = selection.y;\n        }\n    });\n    accessible.addAccessibleControlListener(new AccessibleControlAdapter() {\n\n        public void getRole(AccessibleControlEvent e) {\n            e.detail = ACC.ROLE_TEXT;\n        }\n\n        public void getState(AccessibleControlEvent e) {\n            int state = 0;\n            if (isEnabled())\n                state |= ACC.STATE_FOCUSABLE;\n            if (isFocusControl())\n                state |= ACC.STATE_FOCUSED;\n            if (isVisible() == false)\n                state |= ACC.STATE_INVISIBLE;\n            if (getEditable() == false)\n                state |= ACC.STATE_READONLY;\n            e.detail = state;\n        }\n\n        public void getValue(AccessibleControlEvent e) {\n            e.result = StyledText.this.getText();\n        }\n    });\n    addListener(SWT.FocusIn, new Listener() {\n\n        public void handleEvent(Event event) {\n            accessible.setFocus(ACC.CHILDID_SELF);\n        }\n    });\n}",
			"comments":"/**\n* Add accessibility support for the widget.\n*/\n",
			"methodName":"void initializeAccessible()"
		},
		"public void setSelection(Point point)":{
			"methodBody":"{\n    checkWidget();\n    if (point == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    setSelection(point.x, point.y);\n}",
			"comments":"/**\n* Sets the selection and scrolls it into view.\n* <p>\n* Indexing is zero based.  Text selections are specified in terms of\n* caret positions.  In a text widget that contains N characters, there are\n* N+1 caret positions, ranging from 0..N\n* </p>\n*\n* @param point x=selection start offset, y=selection end offset\n* \tThe caret will be placed at the selection start when x > y.\n* @see #setSelection(int,int)\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*   <li>ERROR_NULL_ARGUMENT when point is null</li>\n*   <li>ERROR_INVALID_ARGUMENT when either the start or the end of the selection range is inside a\n* multi byte line delimiter (and thus neither clearly in front of or after the line delimiter)\n* </ul>\n*/\n",
			"methodName":"public void setSelection(Point point)"
		},
		"public void addSelectionListener(SelectionListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null) {\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    }\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.Selection, typedListener);\n}",
			"comments":"/**\n* Adds a selection listener. A Selection event is sent by the widget when the\n* selection has changed.\n* <p>\n* When <code>widgetSelected</code> is called, the event x amd y fields contain\n* the start and end caret indices of the selection.\n* <code>widgetDefaultSelected</code> is not called for StyledTexts.\n* </p>\n*\n* @param listener the listener\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT when listener is null</li>\n* </ul>\n*/\n",
			"methodName":"public void addSelectionListener(SelectionListener listener)"
		},
		"public int getLineAtOffset(int offset)":{
			"methodBody":"{\n    checkWidget();\n    if (offset < 0 || offset > getCharCount()) {\n        SWT.error(SWT.ERROR_INVALID_RANGE);\n    }\n    return logicalContent.getLineAtOffset(offset);\n}",
			"comments":"/**\n* Returns the line at the specified offset in the text\n* where 0 &lt= offset &lt= getCharCount() so that getLineAtOffset(getCharCount())\n* returns the line of the insert location.\n*\n* @param offset offset relative to the start of the content.\n* \t0 <= offset <= getCharCount()\n* @return line at the specified offset in the text\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*   <li>ERROR_INVALID_RANGE when the offset is outside the valid range (< 0 or > getCharCount())</li>\n* </ul>\n*/\n",
			"methodName":"public int getLineAtOffset(int offset)"
		},
		"public void addLineBackgroundListener(LineBackgroundListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (userLineBackground == false) {\n        removeLineBackgroundListener(defaultLineStyler);\n        defaultLineStyler.setLineBackground(0, logicalContent.getLineCount(), null);\n        userLineBackground = true;\n    }\n    StyledTextListener typedListener = new StyledTextListener(listener);\n    addListener(LineGetBackground, typedListener);\n}",
			"comments":"/**\n* Adds a line background listener. A LineGetBackground event is sent by the\n* widget to determine the background color for a line.\n* <p>\n*\n* @param listener the listener\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT when listener is null</li>\n* </ul>\n*/\n",
			"methodName":"public void addLineBackgroundListener(LineBackgroundListener listener)"
		},
		"public Color getSelectionForeground()":{
			"methodBody":"{\n    checkWidget();\n    if (selectionForeground == null) {\n        return getDisplay().getSystemColor(SWT.COLOR_LIST_SELECTION_TEXT);\n    }\n    return selectionForeground;\n}",
			"comments":"/**\n* Returns the receiver's selection foreground color.\n*\n* @return the selection foreground color\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @since 2.1\n*/\n",
			"methodName":"public Color getSelectionForeground()"
		},
		"public Color getForeground()":{
			"methodBody":"{\n    checkWidget();\n    if (foreground == null) {\n        return getDisplay().getSystemColor(SWT.COLOR_LIST_FOREGROUND);\n    }\n    return foreground;\n}",
			"comments":"",
			"methodName":"public Color getForeground()"
		},
		"void handleTextSet(TextChangedEvent event)":{
			"methodBody":"{\n    reset();\n}",
			"comments":"/**\n* Called when the widget content is set programatically, overwriting\n* the old content. Resets the caret position, selection and scroll offsets.\n* Recalculates the content width and scroll bars. Redraws the widget.\n* <p>\n*\n* @param event text change event.\n*/\n",
			"methodName":"void handleTextSet(TextChangedEvent event)"
		},
		"public Point getLocationAtOffset(int offset)":{
			"methodBody":"{\n    checkWidget();\n    if (offset < 0 || offset > getCharCount()) {\n        SWT.error(SWT.ERROR_INVALID_RANGE);\n    }\n    int line = content.getLineAtOffset(offset);\n    int lineOffset = content.getOffsetAtLine(line);\n    String lineContent = content.getLine(line);\n    int x = getXAtOffset(lineContent, line, offset - lineOffset);\n    int y = line * lineHeight - verticalScrollOffset;\n    return new Point(x, y);\n}",
			"comments":"/**\n* Returns the x, y location of the upper left corner of the character\n* bounding box at the specified offset in the text. The point is\n* relative to the upper left corner of the widget client area.\n* <p>\n*\n* @param offset offset relative to the start of the content.\n* \t0 <= offset <= getCharCount()\n* @return x, y location of the upper left corner of the character\n* \tbounding box at the specified offset in the text.\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*   <li>ERROR_INVALID_RANGE when the offset is outside the valid range (< 0 or > getCharCount())</li>\n* </ul>\n*/\n",
			"methodName":"public Point getLocationAtOffset(int offset)"
		},
		"public int getWidth()":{
			"methodBody":"{\n    return parent.getClientArea().width;\n}",
			"comments":"/**\n* Returns the client area width. Lines are wrapped so there\n* is no horizontal scroll bar.\n* <p>\n*\n* @return the line width\n*/\n",
			"methodName":"public int getWidth()"
		},
		"void handleHorizontalScroll(Event event)":{
			"methodBody":"{\n    int scrollPixel = getHorizontalBar().getSelection() - horizontalScrollOffset;\n    scrollHorizontal(scrollPixel);\n}",
			"comments":"/**\n* Scrolls the widget horizontally.\n*/\n",
			"methodName":"void handleHorizontalScroll(Event event)"
		},
		"int getClusterPrevious(int offset, int lineIndex)":{
			"methodBody":"{\n    String line = content.getLine(lineIndex);\n    int lineOffset = content.getOffsetAtLine(lineIndex);\n    TextLayout layout = renderer.getTextLayout(line, lineOffset);\n    offset -= lineOffset;\n    offset = layout.getPreviousOffset(offset, SWT.MOVEMENT_CLUSTER);\n    offset += lineOffset;\n    renderer.disposeTextLayout(layout);\n    return offset;\n}",
			"comments":"",
			"methodName":"int getClusterPrevious(int offset, int lineIndex)"
		},
		"void cacheLineBackground(int lineOffset, String line)":{
			"methodBody":"{\n    StyledTextEvent event = parent.getLineBackgroundData(lineOffset, line);\n    if (event != null) {\n        lineBackgrounds.put(new Integer(lineOffset), event);\n    }\n}",
			"comments":"/**\n* Caches the line background color of the given line.\n* </p>\n* @param lineOffset offset of the line to cache the background\n* \tcolor for. Relative to the start of the document.\n* @param line line to cache the background color for\n*/\n",
			"methodName":"void cacheLineBackground(int lineOffset, String line)"
		},
		"void setHorizontalScrollBar()":{
			"methodBody":"{\n    ScrollBar horizontalBar = getHorizontalBar();\n    if (horizontalBar != null && horizontalBar.getVisible()) {\n        final int INACTIVE = 1;\n        Rectangle clientArea = getClientArea();\n        \n        if (clientArea.width < lineCache.getWidth()) {\n            horizontalBar.setValues(horizontalBar.getSelection(), horizontalBar.getMinimum(), \n            lineCache.getWidth(), \n            clientArea.width - leftMargin - rightMargin, horizontalBar.getIncrement(), \n            clientArea.width - leftMargin - rightMargin);\n        } else if (horizontalBar.getThumb() != INACTIVE || horizontalBar.getMaximum() != INACTIVE) {\n            horizontalBar.setValues(horizontalBar.getSelection(), horizontalBar.getMinimum(), INACTIVE, INACTIVE, horizontalBar.getIncrement(), INACTIVE);\n        }\n    }\n}",
			"comments":"/**\n* Adjusts the maximum and the page size of the horizontal scroll bar\n* to reflect content width changes.\n*/\n// only set the real values if the scroll bar can be used\n// (ie. because the thumb size is less than the scroll maximum)\n// avoids flashing on Motif, fixes 1G7RE1J and 1G5SE92\n// maximum\n// thumb size\n// page size\n",
			"methodName":"void setHorizontalScrollBar()"
		},
		"public String toString()":{
			"methodBody":"{\n    return buffer.toString();\n}",
			"comments":"/**\n* Returns the string.  <code>close()</code> must be called before <code>toString()</code>\n* is guaranteed to return a valid string.\n*\n* @return the string\n*/\n",
			"methodName":"public String toString()"
		},
		"public void removeLineStyleListener(LineStyleListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null) {\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    }\n    removeListener(LineGetStyle, listener);\n    \n    if (isListening(LineGetStyle) == false && userLineStyle) {\n        StyledTextListener typedListener = new StyledTextListener(defaultLineStyler);\n        addListener(LineGetStyle, typedListener);\n        userLineStyle = false;\n    }\n}",
			"comments":"/**\n* Removes the specified line style listener.\n* <p>\n*\n* @param listener the listener\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT when listener is null</li>\n* </ul>\n*/\n// use default line styler if last user line styler was removed. Fixes 1G7B1X2\n",
			"methodName":"public void removeLineStyleListener(LineStyleListener listener)"
		},
		"boolean showLocation(int x, int line)":{
			"methodBody":"{\n    int clientAreaWidth = getClientArea().width - leftMargin;\n    int verticalIncrement = getVerticalIncrement();\n    int horizontalIncrement = clientAreaWidth / 4;\n    boolean scrolled = false;\n    if (x < leftMargin) {\n        \n        x = Math.max(horizontalScrollOffset * -1, x - horizontalIncrement);\n        scrolled = scrollHorizontalBar(x);\n    } else if (x >= clientAreaWidth) {\n        \n        x = Math.min(lineCache.getWidth() - horizontalScrollOffset, x + horizontalIncrement);\n        scrolled = scrollHorizontalBar(x - clientAreaWidth);\n    }\n    if (line < topIndex) {\n        scrolled = setVerticalScrollOffset(line * verticalIncrement, true);\n    } else if (line > getBottomIndex()) {\n        scrolled = setVerticalScrollOffset((line + 1) * verticalIncrement - getClientArea().height, true);\n    }\n    return scrolled;\n}",
			"comments":"/**\n* Scrolls the specified location into view.\n* <p>\n*\n* @param x the x coordinate that should be made visible.\n* @param line the line that should be made visible. Relative to the\n*\tfirst line in the document.\n* @return\n*\ttrue=the widget was scrolled to make the specified location visible.\n*\tfalse=the specified location is already visible, the widget was\n*\tnot scrolled.\n*/\n// always make 1/4 of a page visible\n// always make 1/4 of a page visible\n",
			"methodName":"boolean showLocation(int x, int line)"
		},
		"public void setLineBackground(int startLine, int lineCount, Color background)":{
			"methodBody":"{\n    checkWidget();\n    int partialBottomIndex = getPartialBottomIndex();\n    \n    if (userLineBackground) {\n        return;\n    }\n    if (startLine < 0 || startLine + lineCount > logicalContent.getLineCount()) {\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    }\n    defaultLineStyler.setLineBackground(startLine, lineCount, background);\n    \n    if (startLine > partialBottomIndex || startLine + lineCount - 1 < topIndex) {\n        return;\n    }\n    \n    if (startLine < topIndex) {\n        lineCount -= topIndex - startLine;\n        startLine = topIndex;\n    }\n    if (startLine + lineCount - 1 > partialBottomIndex) {\n        lineCount = partialBottomIndex - startLine + 1;\n    }\n    startLine -= topIndex;\n    super.redraw(leftMargin, startLine * lineHeight + topMargin, getClientArea().width - leftMargin - rightMargin, lineCount * lineHeight, true);\n}",
			"comments":"/**\n* Sets the background color of the specified lines.\n* The background color is drawn for the width of the widget. All\n* line background colors are discarded when setText is called.\n* The text background color if defined in a StyleRange overlays the\n* line background color. Should not be called if a LineBackgroundListener\n* has been set since the listener maintains the line backgrounds.\n* <p>\n* Line background colors are maintained relative to the line text, not the\n* line index that is specified in this method call.\n* During text changes, when entire lines are inserted or removed, the line\n* background colors that are associated with the lines after the change\n* will \"move\" with their respective text. An entire line is defined as\n* extending from the first character on a line to the last and including the\n* line delimiter.\n* </p>\n* <p>\n* When two lines are joined by deleting a line delimiter, the top line\n* background takes precedence and the color of the bottom line is deleted.\n* For all other text changes line background colors will remain unchanged.\n* </p>\n*\n* @param startLine first line the color is applied to, 0 based\n* @param lineCount number of lines the color applies to.\n* @param background line background color\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*   <li>ERROR_INVALID_ARGUMENT when the specified line range is invalid</li>\n* </ul>\n*/\n// this API can not be used if the client is providing the line background\n// do nothing if redraw range is completely invisible\n// only redraw visible lines\n",
			"methodName":"public void setLineBackground(int startLine, int lineCount, Color background)"
		},
		"void copyContent(StyledTextContent original)":{
			"methodBody":"{\n    int insertOffset = 0;\n    printerContent = new DefaultContent();\n    for (int i = 0; i < original.getLineCount(); i++) {\n        int insertEndOffset;\n        if (i < original.getLineCount() - 1) {\n            insertEndOffset = original.getOffsetAtLine(i + 1);\n        } else {\n            insertEndOffset = original.getCharCount();\n        }\n        printerContent.replaceTextRange(insertOffset, 0, original.getTextRange(insertOffset, insertEndOffset - insertOffset));\n        insertOffset = insertEndOffset;\n    }\n}",
			"comments":"/**\n* Copies the text of the specified <class>StyledTextContent</class>.\n* </p>\n* @param original the <class>StyledTextContent</class> to copy.\n*/\n",
			"methodName":"void copyContent(StyledTextContent original)"
		},
		"public void getState(AccessibleControlEvent e)":{
			"methodBody":"{\n    int state = 0;\n    if (isEnabled())\n        state |= ACC.STATE_FOCUSABLE;\n    if (isFocusControl())\n        state |= ACC.STATE_FOCUSED;\n    if (isVisible() == false)\n        state |= ACC.STATE_INVISIBLE;\n    if (getEditable() == false)\n        state |= ACC.STATE_READONLY;\n    e.detail = state;\n}",
			"comments":"",
			"methodName":"public void getState(AccessibleControlEvent e)"
		},
		"public void paste()":{
			"methodBody":"{\n    checkWidget();\n    String text;\n    text = (String) getClipboardContent(DND.CLIPBOARD);\n    if (text != null && text.length() > 0) {\n        Event event = new Event();\n        event.start = selection.x;\n        event.end = selection.y;\n        event.text = getModelDelimitedText(text);\n        sendKeyEvent(event);\n    }\n}",
			"comments":"/**\n* Replaces the selection with the text on the <code>DND.CLIPBOARD</code>\n* clipboard  or, if there is no selection,  inserts the text at the current\n* caret offset.   If the widget has the SWT.SINGLE style and the\n* clipboard text contains more than one line, only the first line without\n* line delimiters is  inserted in the widget.\n* <p>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void paste()"
		},
		"public void setEditable(boolean editable)":{
			"methodBody":"{\n    checkWidget();\n    this.editable = editable;\n}",
			"comments":"/**\n* Sets whether the widget content can be edited.\n* </p>\n*\n* @param editable if true content can be edited, if false content can not be\n* \tedited\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setEditable(boolean editable)"
		},
		"LineCache internalGetLineCache()":{
			"methodBody":"{\n    return lineCache;\n}",
			"comments":"",
			"methodName":"LineCache internalGetLineCache()"
		},
		"void doPageEnd()":{
			"methodBody":"{\n    \n    if (isSingleLine()) {\n        doLineEnd();\n    } else {\n        int line = getBottomIndex();\n        int bottomCaretOffset = content.getOffsetAtLine(line) + content.getLine(line).length();\n        if (caretOffset < bottomCaretOffset) {\n            caretOffset = bottomCaretOffset;\n            showCaret();\n        }\n    }\n}",
			"comments":"/**\n* Moves the cursor to the end of the last fully visible line.\n*/\n// go to end of line if in single line mode. fixes 5673\n",
			"methodName":"void doPageEnd()"
		},
		"public StyleRange[] getStyleRanges(int start, int length)":{
			"methodBody":"{\n    checkWidget();\n    int contentLength = getCharCount();\n    int end = start + length;\n    if (start > end || start < 0 || end > contentLength) {\n        SWT.error(SWT.ERROR_INVALID_RANGE);\n    }\n    StyleRange[] styles;\n    if (userLineStyle == false) {\n        styles = defaultLineStyler.getStyleRangesFor(start, length);\n        if (styles == null)\n            return new StyleRange[0];\n        \n        if (styles.length == 1) {\n            StyleRange style = styles[0];\n            if (style.start < start) {\n                StyleRange newStyle = (StyleRange) styles[0].clone();\n                newStyle.length = newStyle.length - (start - newStyle.start);\n                newStyle.start = start;\n                styles[0] = newStyle;\n            }\n            if (style.start + style.length > (start + length)) {\n                StyleRange newStyle = (StyleRange) styles[0].clone();\n                newStyle.length = start + length - newStyle.start;\n                styles[0] = newStyle;\n            }\n        } else if (styles.length > 1) {\n            StyleRange style = styles[0];\n            if (style.start < start) {\n                StyleRange newStyle = (StyleRange) styles[0].clone();\n                newStyle.length = newStyle.length - (start - newStyle.start);\n                newStyle.start = start;\n                styles[0] = newStyle;\n            }\n            style = styles[styles.length - 1];\n            if (style.start + style.length > (start + length)) {\n                StyleRange newStyle = (StyleRange) styles[styles.length - 1].clone();\n                newStyle.length = start + length - newStyle.start;\n                styles[styles.length - 1] = newStyle;\n            }\n        }\n    } else {\n        styles = new StyleRange[0];\n    }\n    return styles;\n}",
			"comments":"/**\n* Returns the styles for the given text range.\n* Returns an empty array if a LineStyleListener has been set.\n* Should not be called if a LineStyleListener has been set since the\n* listener maintains the styles.\n*\n* @param start the start offset of the style ranges to return\n* @param length the number of style ranges to return\n*\n* @return the styles or an empty array if a LineStyleListener has\n*  been set.  The returned styles will reflect the given range.  The first\n*  returned <code>StyleRange</code> will have a starting offset >= start\n*  and the last returned <code>StyleRange</code> will have an ending\n*  offset <= start + length - 1\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*   <li>ERROR_INVALID_RANGE when start and/or end are outside the widget content</li>\n* </ul>\n*\n* @since 3.0\n*/\n// adjust the first and last style to reflect the specified\n// range, clone these styles since the returned styles are the\n// styles cached by the widget\n",
			"methodName":"public StyleRange[] getStyleRanges(int start, int length)"
		},
		"void writeStyledLine(String line, int lineOffset, StyleRange[] styles, Color lineBackground)":{
			"methodBody":"{\n    int lineLength = line.length();\n    int lineIndex;\n    int copyEnd;\n    int startOffset = getStart();\n    int endOffset = startOffset + super.getCharCount();\n    int lineEndOffset = Math.min(lineLength, endOffset - lineOffset);\n    int writeOffset = startOffset - lineOffset;\n    if (writeOffset >= line.length()) {\n        \n        return;\n    } else if (writeOffset > 0) {\n        \n        lineIndex = writeOffset;\n    } else {\n        lineIndex = 0;\n    }\n    if (lineBackground != null) {\n        write(\"{\\\\highlight\");\n        write(getColorIndex(lineBackground, DEFAULT_BACKGROUND));\n        write(\" \");\n    }\n    for (int i = 0; i < styles.length; i++) {\n        StyleRange style = styles[i];\n        int start = style.start - lineOffset;\n        int end = start + style.length;\n        int colorIndex;\n        \n        if (end < writeOffset) {\n            continue;\n        }\n        \n        if (start >= lineEndOffset) {\n            break;\n        }\n        \n        if (lineIndex < start) {\n            \n            \n            \n            write(line, lineIndex, start);\n            lineIndex = start;\n        }\n        \n        colorIndex = getColorIndex(style.background, DEFAULT_BACKGROUND);\n        write(\"{\\\\cf\");\n        write(getColorIndex(style.foreground, DEFAULT_FOREGROUND));\n        if (colorIndex != DEFAULT_BACKGROUND) {\n            write(\"\\\\highlight\");\n            write(colorIndex);\n        }\n        if ((style.fontStyle & SWT.BOLD) != 0) {\n            write(\"\\\\b\");\n        }\n        if ((style.fontStyle & SWT.ITALIC) != 0) {\n            write(\"\\\\i\");\n        }\n        if (style.underline) {\n            write(\"\\\\ul\");\n        }\n        if (style.strikeout) {\n            write(\"\\\\strike\");\n        }\n        write(\" \");\n        \n        copyEnd = Math.min(end, lineEndOffset);\n        \n        copyEnd = Math.max(copyEnd, lineIndex);\n        write(line, lineIndex, copyEnd);\n        if ((style.fontStyle & SWT.BOLD) != 0) {\n            write(\"\\\\b0\");\n        }\n        if ((style.fontStyle & SWT.ITALIC) != 0) {\n            write(\"\\\\i0\");\n        }\n        if (style.underline) {\n            write(\"\\\\ul0\");\n        }\n        if (style.strikeout) {\n            write(\"\\\\strike0\");\n        }\n        write(\"}\");\n        lineIndex = copyEnd;\n    }\n    \n    if (lineIndex < lineEndOffset) {\n        write(line, lineIndex, lineEndOffset);\n    }\n    if (lineBackground != null) {\n        write(\"}\");\n    }\n}",
			"comments":"/**\n* Appends the specified line text to the RTF data.\n* Use the colors and font styles specified in \"styles\" and \"lineBackground\".\n* Formatting is written to reflect the text rendering by the text widget.\n* Style background colors take precedence over the line background color.\n* Background colors are written using the \\highlight tag (vs. the \\cb tag).\n* <p>\n*\n* @param line line text to write as RTF. Must not contain line breaks\n* \tLine breaks should be written using writeLineDelimiter()\n* @param lineOffset offset of the line. 0 based from the start of the\n* \twidget document. Any text occurring before the start offset or after the\n* \tend offset specified during object creation is ignored.\n* @param styles styles to use for formatting. Must not be null.\n* @param lineBackground line background color to use for formatting.\n* \tMay be null.\n*/\n// whole line is outside write range\n// line starts before RTF write start\n// skip over partial first line\n// style starts beyond line end or RTF write end\n// write any unstyled text\n// copy to start of style\n// style starting betond end of write range or end of line\n// is guarded against above.\n// write styled text\n// copy to end of style or end of write range or end of line\n// guard against invalid styles and let style processing continue\n// write unstyled text at the end of the line\n",
			"methodName":"void writeStyledLine(String line, int lineOffset, StyleRange[] styles, Color lineBackground)"
		},
		"void doBackspace()":{
			"methodBody":"{\n    Event event = new Event();\n    event.text = \"\";\n    if (selection.x != selection.y) {\n        event.start = selection.x;\n        event.end = selection.y;\n        sendKeyEvent(event);\n    } else if (caretOffset > 0) {\n        int line = content.getLineAtOffset(caretOffset);\n        int lineOffset = content.getOffsetAtLine(line);\n        if (caretOffset == lineOffset) {\n            lineOffset = content.getOffsetAtLine(line - 1);\n            event.start = lineOffset + content.getLine(line - 1).length();\n            event.end = caretOffset;\n        } else {\n            String lineText = content.getLine(line);\n            TextLayout layout = renderer.getTextLayout(lineText, lineOffset);\n            int start = layout.getPreviousOffset(caretOffset - lineOffset, SWT.MOVEMENT_CHAR);\n            renderer.disposeTextLayout(layout);\n            event.start = start + lineOffset;\n            event.end = caretOffset;\n        }\n        sendKeyEvent(event);\n    }\n}",
			"comments":"/**\n* Deletes the previous character. Delete the selected text if any.\n* Move the caret in front of the deleted text.\n*/\n",
			"methodName":"void doBackspace()"
		},
		"public void getCaretOffset(AccessibleTextEvent e)":{
			"methodBody":"{\n    e.offset = StyledText.this.getCaretOffset();\n}",
			"comments":"",
			"methodName":"public void getCaretOffset(AccessibleTextEvent e)"
		},
		"public void setKeyBinding(int key, int action)":{
			"methodBody":"{\n    checkWidget();\n    int keyValue = key & SWT.KEY_MASK;\n    int modifierValue = key & SWT.MODIFIER_MASK;\n    char keyChar = (char) keyValue;\n    if (Compatibility.isLetter(keyChar)) {\n        \n        \n        char ch = Character.toUpperCase(keyChar);\n        int newKey = ch | modifierValue;\n        if (action == SWT.NULL) {\n            keyActionMap.remove(new Integer(newKey));\n        } else {\n            keyActionMap.put(new Integer(newKey), new Integer(action));\n        }\n        ch = Character.toLowerCase(keyChar);\n        newKey = ch | modifierValue;\n        if (action == SWT.NULL) {\n            keyActionMap.remove(new Integer(newKey));\n        } else {\n            keyActionMap.put(new Integer(newKey), new Integer(action));\n        }\n    } else {\n        if (action == SWT.NULL) {\n            keyActionMap.remove(new Integer(key));\n        } else {\n            keyActionMap.put(new Integer(key), new Integer(action));\n        }\n    }\n}",
			"comments":"/**\n* Maps a key to an action.\n* One action can be associated with N keys. However, each key can only\n* have one action (key:action is N:1 relation).\n* <p>\n*\n* @param key a key code defined in SWT.java or a character.\n* \tOptionally ORd with a state mask.  Preferred state masks are one or more of\n*  SWT.MOD1, SWT.MOD2, SWT.MOD3, since these masks account for modifier platform\n*  differences.  However, there may be cases where using the specific state masks\n*  (i.e., SWT.CTRL, SWT.SHIFT, SWT.ALT, SWT.COMMAND) makes sense.\n* @param action one of the predefined actions defined in ST.java.\n* \tUse SWT.NULL to remove a key binding.\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n// make the keybinding case insensitive by adding it\n// in its upper and lower case form\n",
			"methodName":"public void setKeyBinding(int key, int action)"
		},
		"void doLineEnd()":{
			"methodBody":"{\n    int caretLine = getCaretLine();\n    int lineOffset = content.getOffsetAtLine(caretLine);\n    int lineLength = content.getLine(caretLine).length();\n    int lineEndOffset = lineOffset + lineLength;\n    if (caretOffset < lineEndOffset) {\n        caretOffset = lineEndOffset;\n        showCaret();\n    }\n}",
			"comments":"/**\n* Moves the caret to the end of the line.\n*/\n",
			"methodName":"void doLineEnd()"
		},
		"boolean isBidi()":{
			"methodBody":"{\n    return IS_GTK || BidiUtil.isBidiPlatform() || isMirrored;\n}",
			"comments":"/**\n* Temporary until SWT provides this\n*/\n",
			"methodName":"boolean isBidi()"
		},
		"boolean isMirrored()":{
			"methodBody":"{\n    return isMirrored;\n}",
			"comments":"/**\n* Returns whether the widget is mirrored (right oriented/right to left\n* writing order).\n*\n* @return isMirrored true=the widget is right oriented, false=the widget\n* \tis left oriented\n*/\n",
			"methodName":"boolean isMirrored()"
		},
		"void write(char i)":{
			"methodBody":"{\n    buffer.append(i);\n}",
			"comments":"/**\n* Appends the given character to the data.\n*/\n",
			"methodName":"void write(char i)"
		},
		"void calculateContentWidth()":{
			"methodBody":"{\n    lineCache = getLineCache(content);\n    lineCache.calculate(topIndex, getPartialBottomIndex() - topIndex + 1);\n}",
			"comments":"/**\n* Calculates the width of the widest visible line.\n*/\n",
			"methodName":"void calculateContentWidth()"
		},
		"int getClusterNext(int offset, int lineIndex)":{
			"methodBody":"{\n    String line = content.getLine(lineIndex);\n    int lineOffset = content.getOffsetAtLine(lineIndex);\n    TextLayout layout = renderer.getTextLayout(line, lineOffset);\n    offset -= lineOffset;\n    offset = layout.getNextOffset(offset, SWT.MOVEMENT_CLUSTER);\n    offset += lineOffset;\n    renderer.disposeTextLayout(layout);\n    return offset;\n}",
			"comments":"",
			"methodName":"int getClusterNext(int offset, int lineIndex)"
		},
		"void doSelection(int direction)":{
			"methodBody":"{\n    int redrawStart = -1;\n    int redrawEnd = -1;\n    if (selectionAnchor == -1) {\n        selectionAnchor = selection.x;\n    }\n    if (direction == ST.COLUMN_PREVIOUS) {\n        if (caretOffset < selection.x) {\n            \n            redrawEnd = selection.x;\n            redrawStart = selection.x = caretOffset;\n            \n            if (selection.y != selectionAnchor) {\n                redrawEnd = selection.y;\n                selection.y = selectionAnchor;\n            }\n        } else \n        if (selectionAnchor == selection.x && caretOffset < selection.y) {\n            \n            \n            redrawEnd = selection.y;\n            redrawStart = selection.y = caretOffset;\n        }\n    } else {\n        if (caretOffset > selection.y) {\n            \n            redrawStart = selection.y;\n            redrawEnd = selection.y = caretOffset;\n            \n            if (selection.x != selectionAnchor) {\n                redrawStart = selection.x;\n                selection.x = selectionAnchor;\n            }\n        } else \n        if (selectionAnchor == selection.y && caretOffset > selection.x) {\n            \n            \n            redrawStart = selection.x;\n            redrawEnd = selection.x = caretOffset;\n        }\n    }\n    if (redrawStart != -1 && redrawEnd != -1) {\n        internalRedrawRange(redrawStart, redrawEnd - redrawStart, true);\n        sendSelectionEvent();\n    }\n}",
			"comments":"/**\n* Updates the selection to extend to the current caret position.\n*/\n// grow selection\n// check if selection has reversed direction\n// test whether selection actually changed. Fixes 1G71EO1\n// caret moved towards selection anchor (left side of selection).\n// shrink selection\n// grow selection\n// check if selection has reversed direction\n// test whether selection actually changed. Fixes 1G71EO1\n// caret moved towards selection anchor (right side of selection).\n// shrink selection\n",
			"methodName":"void doSelection(int direction)"
		},
		"void createPrinterColors()":{
			"methodBody":"{\n    Enumeration values = lineBackgrounds.elements();\n    printerColors = new Hashtable();\n    while (values.hasMoreElements()) {\n        StyledTextEvent event = (StyledTextEvent) values.nextElement();\n        event.lineBackground = getPrinterColor(event.lineBackground);\n    }\n    values = lineStyles.elements();\n    while (values.hasMoreElements()) {\n        StyledTextEvent event = (StyledTextEvent) values.nextElement();\n        for (int i = 0; i < event.styles.length; i++) {\n            StyleRange style = event.styles[i];\n            Color printerBackground = getPrinterColor(style.background);\n            Color printerForeground = getPrinterColor(style.foreground);\n            if (printerBackground != style.background || printerForeground != style.foreground) {\n                style = (StyleRange) style.clone();\n                style.background = printerBackground;\n                style.foreground = printerForeground;\n                event.styles[i] = style;\n            }\n        }\n    }\n}",
			"comments":"/**\n* Replaces all display colors in the cached line backgrounds and\n* line styles with printer colors.\n*/\n",
			"methodName":"void createPrinterColors()"
		},
		"void redrawMultiLineChange(int y, int newLineCount, int replacedLineCount)":{
			"methodBody":"{\n    Rectangle clientArea = getClientArea();\n    int lineCount = newLineCount - replacedLineCount;\n    int sourceY;\n    int destinationY;\n    if (lineCount > 0) {\n        sourceY = Math.max(0, y + lineHeight);\n        destinationY = sourceY + lineCount * lineHeight;\n    } else {\n        destinationY = Math.max(0, y + lineHeight);\n        sourceY = destinationY - lineCount * lineHeight;\n    }\n    scroll(\n    0, \n    destinationY, \n    0, \n    sourceY, clientArea.width, clientArea.height, true);\n    \n    if (y + lineHeight > 0 && y <= clientArea.height) {\n        \n        super.redraw(0, y, clientArea.width, lineHeight, true);\n    }\n    if (newLineCount > 0) {\n        int redrawStartY = y + lineHeight;\n        int redrawHeight = newLineCount * lineHeight;\n        if (redrawStartY + redrawHeight > 0 && redrawStartY <= clientArea.height) {\n            \n            super.redraw(0, redrawStartY, clientArea.width, redrawHeight, true);\n        }\n    }\n}",
			"comments":"/**\n* Fixes the widget to display a text change.\n* Bit blitting and redrawing is done as necessary.\n* <p>\n*\n* @param y y location of the text change\n* @param newLineCount number of new lines.\n* @param replacedLineCount number of replaced lines.\n*/\n// destination x, y\n// source x, y\n// Always redrawing causes the bottom line to flash when a line is\n// deleted. This is because SWT merges the paint area of the scroll\n// with the paint area of the redraw call below.\n// To prevent this we could call update after the scroll. However,\n// adding update can cause even more flash if the client does other\n// redraw/update calls (ie. for syntax highlighting).\n// We could also redraw only when a line has been added or when\n// contents has been added to a line. This would require getting\n// line index info from the content and is not worth the trouble\n// (the flash is only on the bottom line and minor).\n// Specifying the NO_MERGE_PAINTS style bit prevents the merged\n// redraw but could cause flash/slowness elsewhere.\n// redraw first changed line in case a line was split/joined\n// display new text\n",
			"methodName":"void redrawMultiLineChange(int y, int newLineCount, int replacedLineCount)"
		},
		"public int getHorizontalPixel()":{
			"methodBody":"{\n    checkWidget();\n    return horizontalScrollOffset;\n}",
			"comments":"/**\n* Returns the horizontal scroll offset relative to the start of the line.\n* <p>\n*\n* @return the horizontal scroll offset relative to the start of the line,\n* measured in pixel starting at 0, if > 0 the content is scrolled.\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getHorizontalPixel()"
		},
		"int getCaretWidth()":{
			"methodBody":"{\n    Caret caret = getCaret();\n    if (caret == null)\n        return 0;\n    return caret.getSize().x;\n}",
			"comments":"/**\n* Returns the caret width.\n* <p>\n*\n* @return the caret width, 0 if caret is null.\n*/\n",
			"methodName":"int getCaretWidth()"
		},
		"public void replaceTextRange(int start, int length, String text)":{
			"methodBody":"{\n    checkWidget();\n    int contentLength = getCharCount();\n    int end = start + length;\n    Event event = new Event();\n    if (start > end || start < 0 || end > contentLength) {\n        SWT.error(SWT.ERROR_INVALID_RANGE);\n    }\n    if (text == null) {\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    }\n    event.start = start;\n    event.end = end;\n    event.text = text;\n    modifyContent(event, false);\n}",
			"comments":"/**\n* Replaces the given text range with new text.\n* If the widget has the SWT.SINGLE style and \"text\" contains more than\n* one line, only the first line is rendered but the text is stored\n* unchanged. A subsequent call to getText will return the same text\n* that was set. Note that only a single line of text should be set when\n* the SWT.SINGLE style is used.\n* <p>\n* <b>NOTE:</b> During the replace operation the current selection is\n* changed as follows:\n* <ul>\n* <li>selection before replaced text: selection unchanged\n* <li>selection after replaced text: adjust the selection so that same text\n* remains selected\n* <li>selection intersects replaced text: selection is cleared and caret\n* is placed after inserted text\n* </ul>\n* </p>\n*\n* @param start offset of first character to replace\n* @param length number of characters to replace. Use 0 to insert text\n* @param text new text. May be empty to delete text.\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*   <li>ERROR_INVALID_RANGE when either start or end is outside the valid range (0 <= offset <= getCharCount())</li>\n*   <li>ERROR_INVALID_ARGUMENT when either start or end is inside a multi byte line delimiter.\n* \t\tSplitting a line delimiter for example by inserting text in between the CR and LF and deleting part of a line delimiter is not supported</li>\n*   <li>ERROR_NULL_ARGUMENT when string is null</li>\n* </ul>\n*/\n",
			"methodName":"public void replaceTextRange(int start, int length, String text)"
		},
		"public void insert(String string)":{
			"methodBody":"{\n    checkWidget();\n    if (string == null) {\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    }\n    Point sel = getSelectionRange();\n    replaceTextRange(sel.x, sel.y, string);\n}",
			"comments":"/**\n* Inserts a string.  The old selection is replaced with the new text.\n* <p>\n*\n* @param string the string\n* @see #replaceTextRange(int,int,String)\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT when string is null</li>\n* </ul>\n*/\n",
			"methodName":"public void insert(String string)"
		},
		"void doMouseSelection()":{
			"methodBody":"{\n    if (caretOffset <= selection.x || (caretOffset > selection.x && caretOffset < selection.y && selectionAnchor == selection.x)) {\n        doSelection(ST.COLUMN_PREVIOUS);\n    } else {\n        doSelection(ST.COLUMN_NEXT);\n    }\n}",
			"comments":"/**\n* Updates the selection based on the caret position\n*/\n",
			"methodName":"void doMouseSelection()"
		},
		"void handleMouseUp(Event event)":{
			"methodBody":"{\n    mouseDown = false;\n    mouseDoubleClick = false;\n    event.y -= topMargin;\n    endAutoScroll();\n    if (event.button == 1) {\n        try {\n            if (selection.y - selection.x > 0) {\n                setClipboardContent(selection.x, selection.y - selection.x, DND.SELECTION_CLIPBOARD);\n            }\n        } catch (SWTError error) {\n            \n            if (error.code != DND.ERROR_CANNOT_SET_CLIPBOARD) {\n                throw error;\n            }\n        }\n    }\n}",
			"comments":"/**\n* Autoscrolling ends when the mouse button is released.\n*/\n// Copy to clipboard failed. This happens when another application\n// is accessing the clipboard while we copy. Ignore the error.\n// Fixes 1GDQAVN\n// Rethrow all other errors. Fixes bug 17578.\n",
			"methodName":"void handleMouseUp(Event event)"
		},
		"Color getPrinterColor(Color color)":{
			"methodBody":"{\n    Color printerColor = null;\n    if (color != null) {\n        printerColor = (Color) printerColors.get(color);\n        if (printerColor == null) {\n            printerColor = new Color(printer, color.getRGB());\n            printerColors.put(color, printerColor);\n        }\n    }\n    return printerColor;\n}",
			"comments":"/**\n* Returns the printer color for the given display color.\n* </p>\n* @param color display color\n* @return color create on the printer with the same RGB values\n* \tas the display color.\n*/\n",
			"methodName":"Color getPrinterColor(Color color)"
		},
		"void wordWrapResize(int oldClientAreaWidth)":{
			"methodBody":"{\n    WrappedContent wrappedContent = (WrappedContent) content;\n    int newTopIndex;\n    \n    if (oldClientAreaWidth != 0 && clientAreaWidth > oldClientAreaWidth && wrappedContent.getLineCount() == logicalContent.getLineCount()) {\n        return;\n    }\n    wrappedContent.wrapLines();\n    \n    newTopIndex = content.getLineAtOffset(topOffset);\n    \n    if (newTopIndex < content.getLineCount() - 1 && topOffset == content.getOffsetAtLine(newTopIndex + 1)) {\n        newTopIndex++;\n    }\n    if (newTopIndex != topIndex) {\n        ScrollBar verticalBar = getVerticalBar();\n        \n        \n        \n        verticalScrollOffset += (newTopIndex - topIndex) * getVerticalIncrement();\n        \n        if (verticalScrollOffset < 0) {\n            verticalScrollOffset = 0;\n        }\n        topIndex = newTopIndex;\n        topOffset = content.getOffsetAtLine(topIndex);\n        if (verticalBar != null) {\n            verticalBar.setSelection(verticalScrollOffset);\n        }\n    }\n    \n    \n    setCaretLocation();\n    \n    super.redraw();\n}",
			"comments":"/**\n* Rewraps all lines\n* <p>\n*\n* @param oldClientAreaWidth client area width before resize\n* \toccurred\n*/\n// all lines are wrapped and no rewrap required if widget has already\n// been visible, client area is now wider and visual (wrapped) line\n// count equals logical line count.\n// adjust the top index so that top line remains the same\n// topOffset is the beginning of the top line. therefore it\n// needs to be adjusted because in a wrapped line this is also\n// the end of the preceeding line.\n// adjust index and pixel offset manually instead of calling\n// setVerticalScrollOffset because the widget does not actually need\n// to be scrolled. causes flash otherwise.\n// verticalScrollOffset may become negative if first line was\n// partially visible and second line was top line. prevent this from\n// happening to fix 8503.\n// caret may be on a different line after a rewrap.\n// call setCaretLocation after fixing vertical scroll offset.\n// word wrap may have changed on one of the visible lines\n",
			"methodName":"void wordWrapResize(int oldClientAreaWidth)"
		},
		"boolean isAreaVisible(int firstLine, int lastLine)":{
			"methodBody":"{\n    int partialBottomIndex = getPartialBottomIndex();\n    int partialTopIndex = verticalScrollOffset / lineHeight;\n    boolean notVisible = firstLine > partialBottomIndex || lastLine < partialTopIndex;\n    return !notVisible;\n}",
			"comments":"/**\n* Returns whether or not the given lines are visible.\n* <p>\n*\n* @return true if any of the lines is visible\n* false if none of the lines is visible\n*/\n",
			"methodName":"boolean isAreaVisible(int firstLine, int lastLine)"
		},
		"void handleMouseDown(Event event)":{
			"methodBody":"{\n    mouseDown = true;\n    mouseDoubleClick = false;\n    if (event.button == 2) {\n        String text = (String) getClipboardContent(DND.SELECTION_CLIPBOARD);\n        if (text != null && text.length() > 0) {\n            \n            int x = event.x;\n            int y = event.y - topMargin;\n            doMouseLocationChange(x, y, false);\n            \n            Event e = new Event();\n            e.start = selection.x;\n            e.end = selection.y;\n            e.text = getModelDelimitedText(text);\n            sendKeyEvent(e);\n        }\n    }\n    if ((event.button != 1) || (IS_CARBON && (event.stateMask & SWT.MOD4) != 0)) {\n        return;\n    }\n    boolean select = (event.stateMask & SWT.MOD2) != 0;\n    event.y -= topMargin;\n    doMouseLocationChange(event.x, event.y, select);\n}",
			"comments":"/**\n* Updates the caret location and selection if mouse button 1 has been\n* pressed.\n*/\n// position cursor\n// insert text\n",
			"methodName":"void handleMouseDown(Event event)"
		},
		"Point internalGetSelection()":{
			"methodBody":"{\n    return selection;\n}",
			"comments":"",
			"methodName":"Point internalGetSelection()"
		},
		"public void setDoubleClickEnabled(boolean enable)":{
			"methodBody":"{\n    checkWidget();\n    doubleClickEnabled = enable;\n}",
			"comments":"/**\n* Sets whether the widget implements double click mouse behavior.\n* </p>\n*\n* @param enable if true double clicking a word selects the word, if false\n* \tdouble clicks have the same effect as regular mouse clicks.\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setDoubleClickEnabled(boolean enable)"
		},
		"public int getTabs()":{
			"methodBody":"{\n    checkWidget();\n    return tabLength;\n}",
			"comments":"/**\n* Returns the tab width measured in characters.\n*\n* @return tab width measured in characters\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getTabs()"
		},
		"public boolean getDoubleClickEnabled()":{
			"methodBody":"{\n    checkWidget();\n    return doubleClickEnabled;\n}",
			"comments":"/**\n* Returns whether the widget implements double click mouse behavior.\n* <p>\n*\n* @return true if double clicking a word selects the word, false if double clicks\n* have the same effect as regular mouse clicks\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public boolean getDoubleClickEnabled()"
		},
		"void setMouseWordSelectionAnchor()":{
			"methodBody":"{\n    if (mouseDoubleClick == false) {\n        return;\n    }\n    if (caretOffset < doubleClickSelection.x) {\n        selectionAnchor = doubleClickSelection.y;\n    } else if (caretOffset > doubleClickSelection.y) {\n        selectionAnchor = doubleClickSelection.x;\n    }\n}",
			"comments":"/**\n* Flips selection anchor based on word selection direction.\n*/\n",
			"methodName":"void setMouseWordSelectionAnchor()"
		},
		"void showOffset(int offset)":{
			"methodBody":"{\n    int line = content.getLineAtOffset(offset);\n    int lineOffset = content.getOffsetAtLine(line);\n    int offsetInLine = offset - lineOffset;\n    String lineText = content.getLine(line);\n    int xAtOffset = getXAtOffset(lineText, line, offsetInLine);\n    showLocation(xAtOffset, line);\n}",
			"comments":"/**\n* Scrolls the specified offset into view.\n* <p>\n*\n* @param offset offset that should be scolled into view\n*/\n",
			"methodName":"void showOffset(int offset)"
		},
		"public void getHelp(AccessibleEvent e)":{
			"methodBody":"{\n    e.result = getToolTipText();\n}",
			"comments":"",
			"methodName":"public void getHelp(AccessibleEvent e)"
		},
		"void handleTextChanging(TextChangingEvent event)":{
			"methodBody":"{\n    int firstLine;\n    int textChangeY;\n    boolean isMultiLineChange = event.replaceLineCount > 0 || event.newLineCount > 0;\n    if (event.replaceCharCount < 0) {\n        event.start += event.replaceCharCount;\n        event.replaceCharCount *= -1;\n    }\n    lastTextChangeStart = event.start;\n    lastTextChangeNewLineCount = event.newLineCount;\n    lastTextChangeNewCharCount = event.newCharCount;\n    lastTextChangeReplaceLineCount = event.replaceLineCount;\n    lastTextChangeReplaceCharCount = event.replaceCharCount;\n    firstLine = content.getLineAtOffset(event.start);\n    textChangeY = firstLine * lineHeight - verticalScrollOffset + topMargin;\n    if (isMultiLineChange) {\n        redrawMultiLineChange(textChangeY, event.newLineCount, event.replaceLineCount);\n    }\n    \n    if (defaultLineStyler != null) {\n        defaultLineStyler.textChanging(event);\n    }\n    \n    \n    \n    \n    int newEndOfText = content.getCharCount() - event.replaceCharCount + event.newCharCount;\n    if (caretOffset > newEndOfText)\n        caretOffset = newEndOfText;\n}",
			"comments":"/**\n* Updates the screen to reflect a pending content change.\n* <p>\n*\n* @param event.start the start offset of the change\n* @param event.newText text that is going to be inserted or empty String\n*\tif no text will be inserted\n* @param event.replaceCharCount length of text that is going to be replaced\n* @param event.newCharCount length of text that is going to be inserted\n* @param event.replaceLineCount number of lines that are going to be replaced\n* @param event.newLineCount number of new lines that are going to be inserted\n*/\n// notify default line styler about text change\n// Update the caret offset if it is greater than the length of the content.\n// This is necessary since style range API may be called between the\n// handleTextChanging and handleTextChanged events and this API sets the\n// caretOffset.\n",
			"methodName":"void handleTextChanging(TextChangingEvent event)"
		},
		"String getModelDelimitedText(String text)":{
			"methodBody":"{\n    StringBuffer convertedText;\n    String delimiter = getLineDelimiter();\n    int length = text.length();\n    int crIndex = 0;\n    int lfIndex = 0;\n    int i = 0;\n    if (length == 0) {\n        return text;\n    }\n    convertedText = new StringBuffer(length);\n    while (i < length) {\n        if (crIndex != -1) {\n            crIndex = text.indexOf(SWT.CR, i);\n        }\n        if (lfIndex != -1) {\n            lfIndex = text.indexOf(SWT.LF, i);\n        }\n        if (lfIndex == -1 && crIndex == -1) {\n            \n            break;\n        } else \n        if ((crIndex < lfIndex && crIndex != -1) || lfIndex == -1) {\n            convertedText.append(text.substring(i, crIndex));\n            if (lfIndex == crIndex + 1) {\n                \n                i = lfIndex + 1;\n            } else {\n                i = crIndex + 1;\n            }\n        } else {\n            \n            convertedText.append(text.substring(i, lfIndex));\n            i = lfIndex + 1;\n        }\n        if (isSingleLine()) {\n            break;\n        }\n        convertedText.append(delimiter);\n    }\n    \n    if (i < length && (isSingleLine() == false || convertedText.length() == 0)) {\n        convertedText.append(text.substring(i));\n    }\n    return convertedText.toString();\n}",
			"comments":"/**\n* Returns a string that uses only the line delimiter specified by the\n* StyledTextContent implementation.\n* Returns only the first line if the widget has the SWT.SINGLE style.\n* <p>\n*\n* @param text the text that may have line delimiters that don't\n* \tmatch the model line delimiter. Possible line delimiters\n* \tare CR ('\\r'), LF ('\\n'), CR/LF (\"\\r\\n\")\n* @return the converted text that only uses the line delimiter\n* \tspecified by the model. Returns only the first line if the widget\n* \thas the SWT.SINGLE style.\n*/\n// no more line breaks?\n// CR occurs before LF or no LF present?\n// CR/LF combination?\n// LF occurs before CR!\n// copy remaining text if any and if not in single line mode or no\n// text copied thus far (because there only is one line)\n",
			"methodName":"String getModelDelimitedText(String text)"
		},
		"public void setForeground(Color color)":{
			"methodBody":"{\n    checkWidget();\n    foreground = color;\n    super.setForeground(getForeground());\n    redraw();\n}",
			"comments":"/**\n* @see org.eclipse.swt.widgets.Control#setForeground\n*/\n",
			"methodName":"public void setForeground(Color color)"
		},
		"public void setCaret(Caret caret)":{
			"methodBody":"{\n    checkWidget();\n    super.setCaret(caret);\n    caretDirection = SWT.NULL;\n    if (caret != null) {\n        setCaretLocation();\n    }\n}",
			"comments":"/**\n* Sets the receiver's caret.  Set the caret's height and location.\n*\n* </p>\n* @param caret the new caret for the receiver\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setCaret(Caret caret)"
		},
		"public void getRole(AccessibleControlEvent e)":{
			"methodBody":"{\n    e.detail = ACC.ROLE_TEXT;\n}",
			"comments":"",
			"methodName":"public void getRole(AccessibleControlEvent e)"
		},
		"void doVisualPrevious()":{
			"methodBody":"{\n    caretOffset = getClusterPrevious(caretOffset, getCaretLine());\n    showCaret();\n}",
			"comments":"/**\n* Moves the caret one character to the left.  Do not go to the previous line.\n* When in a bidi locale and at a R2L character the caret is moved to the\n* beginning of the R2L segment (visually right) and then one character to the\n* left (visually left because it's now in a L2R segment).\n*/\n",
			"methodName":"void doVisualPrevious()"
		},
		"void setClipboardContent(int start, int length, int clipboardType) throws SWTError":{
			"methodBody":"{\n    if (clipboardType == DND.SELECTION_CLIPBOARD && !(IS_MOTIF || IS_GTK))\n        return;\n    TextTransfer plainTextTransfer = TextTransfer.getInstance();\n    TextWriter plainTextWriter = new TextWriter(start, length);\n    String plainText = getPlatformDelimitedText(plainTextWriter);\n    Object[] data;\n    Transfer[] types;\n    if (clipboardType == DND.SELECTION_CLIPBOARD) {\n        data = new Object[] { plainText };\n        types = new Transfer[] { plainTextTransfer };\n    } else {\n        RTFTransfer rtfTransfer = RTFTransfer.getInstance();\n        RTFWriter rtfWriter = new RTFWriter(start, length);\n        String rtfText = getPlatformDelimitedText(rtfWriter);\n        data = new Object[] { rtfText, plainText };\n        types = new Transfer[] { rtfTransfer, plainTextTransfer };\n    }\n    clipboard.setContents(data, types, clipboardType);\n}",
			"comments":"/**\n* Copies the specified text range to the clipboard.  The text will be placed\n* in the clipboard in plain text format and RTF format.\n* <p>\n*\n* @param start start index of the text\n* @param length length of text to place in clipboard\n*\n* @exception SWTError, see Clipboard.setContents\n* @see org.eclipse.swt.dnd.Clipboard#setContents\n*/\n",
			"methodName":"void setClipboardContent(int start, int length, int clipboardType) throws SWTError"
		},
		"int getLineCountWhole()":{
			"methodBody":"{\n    int lineCount;\n    if (lineHeight != 0) {\n        lineCount = getClientArea().height / lineHeight;\n    } else {\n        lineCount = 1;\n    }\n    return lineCount;\n}",
			"comments":"/**\n* Returns the number of lines that can be completely displayed in the\n* widget client area.\n* <p>\n*\n* @return number of lines that can be completely displayed in the widget\n* \tclient area.\n*/\n",
			"methodName":"int getLineCountWhole()"
		},
		"void expandLines(int numLines)":{
			"methodBody":"{\n    int size = lineWidth.length;\n    if (size - lineCount >= numLines) {\n        return;\n    }\n    int[] newLines = new int[Math.max(size * 2, size + numLines)];\n    System.arraycopy(lineWidth, 0, newLines, 0, size);\n    lineWidth = newLines;\n    reset(size, lineWidth.length - size, false);\n}",
			"comments":"/**\n* Grows the <code>lineWidth</code> array to accomodate new line width\n* information.\n* <p>\n*\n* @param numLines the number of elements to increase the array by\n*/\n",
			"methodName":"void expandLines(int numLines)"
		},
		"void print()":{
			"methodBody":"{\n    StyledTextContent content = renderer.getContent();\n    Color background = gc.getBackground();\n    Color foreground = gc.getForeground();\n    int lineHeight = renderer.getLineHeight();\n    int paintY = clientArea.y;\n    int page = startPage;\n    for (int i = startLine; i <= endLine && page <= endPage; i++, paintY += lineHeight) {\n        String line = content.getLine(i);\n        if (paintY == clientArea.y) {\n            startPage(page);\n        }\n        renderer.drawLine(line, i, paintY, gc, background, foreground, true);\n        if (paintY + lineHeight * 2 > clientArea.y + clientArea.height) {\n            \n            endPage(page);\n            paintY = clientArea.y - lineHeight;\n            page++;\n        }\n    }\n    if (paintY > clientArea.y) {\n        \n        endPage(page);\n    }\n}",
			"comments":"/**\n* Prints the lines in the specified page range.\n*/\n// close full page\n// close partial page\n",
			"methodName":"void print()"
		},
		"void doPageDown(boolean select, int lines)":{
			"methodBody":"{\n    int lineCount = content.getLineCount();\n    int oldColumnX = columnX;\n    int oldHScrollOffset = horizontalScrollOffset;\n    int caretLine;\n    \n    if (isSingleLine()) {\n        return;\n    }\n    caretLine = getCaretLine();\n    if (caretLine < lineCount - 1) {\n        int verticalMaximum = lineCount * getVerticalIncrement();\n        int pageSize = getClientArea().height;\n        int scrollLines = Math.min(lineCount - caretLine - 1, lines);\n        int scrollOffset;\n        \n        \n        scrollLines = Math.max(1, scrollLines);\n        caretLine += scrollLines;\n        caretOffset = getOffsetAtMouseLocation(columnX, caretLine);\n        if (select) {\n            doSelection(ST.COLUMN_NEXT);\n        }\n        \n        scrollOffset = verticalScrollOffset + scrollLines * getVerticalIncrement();\n        if (scrollOffset + pageSize > verticalMaximum) {\n            scrollOffset = verticalMaximum - pageSize;\n        }\n        if (scrollOffset > verticalScrollOffset) {\n            setVerticalScrollOffset(scrollOffset, true);\n        }\n    }\n    \n    \n    showCaret(caretLine);\n    \n    int hScrollChange = oldHScrollOffset - horizontalScrollOffset;\n    columnX = oldColumnX + hScrollChange;\n}",
			"comments":"/**\n* Scrolls one page down so that the last line (truncated or whole)\n* of the current page becomes the fully visible top line.\n* The caret is scrolled the same number of lines so that its location\n* relative to the top line remains the same. The exception is the end\n* of the text where a full page scroll is not possible. In this case\n* the caret is moved after the last character.\n* <p>\n*\n* @param select whether or not to select the page\n*/\n// do nothing if in single line mode. fixes 5673\n// ensure that scrollLines never gets negative and at leat one\n// line is scrolled. fixes bug 5602.\n// scroll one page down or to the bottom\n// explicitly go to the calculated caret line. may be different\n// from content.getLineAtOffset(caretOffset) when in word wrap mode\n// restore the original horizontal caret position\n",
			"methodName":"void doPageDown(boolean select, int lines)"
		},
		"void handleMouseMove(Event event)":{
			"methodBody":"{\n    if (!mouseDown)\n        return;\n    if ((event.stateMask & SWT.BUTTON1) == 0) {\n        return;\n    }\n    event.y -= topMargin;\n    doMouseLocationChange(event.x, event.y, true);\n    update();\n    doAutoScroll(event);\n}",
			"comments":"/**\n* Updates the caret location and selection if mouse button 1 is pressed\n* during the mouse move.\n*/\n",
			"methodName":"void handleMouseMove(Event event)"
		},
		"public void textChanging(TextChangingEvent event)":{
			"methodBody":"{\n    handleTextChanging(event);\n}",
			"comments":"",
			"methodName":"public void textChanging(TextChangingEvent event)"
		},
		"void doCursorNext()":{
			"methodBody":"{\n    advancing = true;\n    if (selection.y - selection.x > 0) {\n        int caretLine;\n        caretOffset = selection.y;\n        caretLine = getCaretLine();\n        showCaret(caretLine);\n    } else {\n        doSelectionCursorNext();\n    }\n}",
			"comments":"/**\n* Moves the caret to the end of the selection if a selection exists.\n* Otherwise, if no selection exists move the cursor according to the\n* cursor selection rules.\n* <p>\n*\n* @see #doSelectionCursorNext\n*/\n",
			"methodName":"void doCursorNext()"
		},
		"int getCaretLine()":{
			"methodBody":"{\n    int caretLine = content.getLineAtOffset(caretOffset);\n    int leftColumnX = leftMargin;\n    if (wordWrap && columnX <= leftColumnX && caretLine < content.getLineCount() - 1 && caretOffset == content.getOffsetAtLine(caretLine + 1)) {\n        caretLine++;\n    }\n    return caretLine;\n}",
			"comments":"/**\n* Returns the index of the line the caret is on.\n* When in word wrap mode and at the end of one wrapped line/\n* beginning of the continuing wrapped line the caret offset\n* is not sufficient to determine the caret line.\n*\n* @return the index of the line the caret is on.\n*/\n",
			"methodName":"int getCaretLine()"
		},
		"StyledTextEvent sendLineEvent(int eventType, int lineOffset, String line)":{
			"methodBody":"{\n    StyledTextEvent event = null;\n    if (isListening(eventType)) {\n        event = new StyledTextEvent(logicalContent);\n        if (wordWrap) {\n            \n            int lineIndex = logicalContent.getLineAtOffset(lineOffset);\n            event.detail = logicalContent.getOffsetAtLine(lineIndex);\n            event.text = logicalContent.getLine(lineIndex);\n        } else {\n            event.detail = lineOffset;\n            event.text = line;\n        }\n        notifyListeners(eventType, event);\n    }\n    return event;\n}",
			"comments":"/**\n* Returns a StyledTextEvent that can be used to request data such\n* as styles and background color for a line.\n* The specified line may be a visual (wrapped) line if in word\n* wrap mode. The returned object will always be for a logical\n* (unwrapped) line.\n* <p>\n*\n* @param lineOffset offset of the line. This may be the offset of\n* \ta visual line if the widget is in word wrap mode.\n* @param line line text. This may be the text of a visualline if\n* \tthe widget is in word wrap mode.\n* @return StyledTextEvent that can be used to request line data\n* \tfor the given line.\n*/\n// if word wrap is on, the line offset and text may be visual (wrapped)\n",
			"methodName":"StyledTextEvent sendLineEvent(int eventType, int lineOffset, String line)"
		},
		"void doDelete()":{
			"methodBody":"{\n    Event event = new Event();\n    event.text = \"\";\n    if (selection.x != selection.y) {\n        event.start = selection.x;\n        event.end = selection.y;\n        sendKeyEvent(event);\n    } else if (caretOffset < content.getCharCount()) {\n        int line = content.getLineAtOffset(caretOffset);\n        int lineOffset = content.getOffsetAtLine(line);\n        int lineLength = content.getLine(line).length();\n        if (caretOffset == lineOffset + lineLength) {\n            event.start = caretOffset;\n            event.end = content.getOffsetAtLine(line + 1);\n        } else {\n            event.start = caretOffset;\n            event.end = getClusterNext(caretOffset, line);\n        }\n        sendKeyEvent(event);\n    }\n}",
			"comments":"/**\n* Deletes the next character. Delete the selected text if any.\n*/\n",
			"methodName":"void doDelete()"
		},
		"int doMouseWordSelect(int x, int newCaretOffset, int line)":{
			"methodBody":"{\n    int wordOffset;\n    \n    if (newCaretOffset < selectionAnchor && selectionAnchor == selection.x) {\n        selectionAnchor = doubleClickSelection.y;\n    } else if (newCaretOffset > selectionAnchor && selectionAnchor == selection.y) {\n        selectionAnchor = doubleClickSelection.x;\n    }\n    if (x >= 0 && x < getClientArea().width) {\n        \n        if (caretOffset == selection.x) {\n            wordOffset = getWordStart(newCaretOffset);\n        } else {\n            wordOffset = getWordEndNoSpaces(newCaretOffset);\n        }\n        \n        if (content.getLineAtOffset(wordOffset) == line) {\n            newCaretOffset = wordOffset;\n        }\n    }\n    return newCaretOffset;\n}",
			"comments":"/**\n* Returns the offset of the word at the specified offset.\n* If the current selection extends from high index to low index\n* (i.e., right to left, or caret is at left border of selecton on\n* non-bidi platforms) the start offset of the word preceeding the\n* selection is returned. If the current selection extends from\n* low index to high index the end offset of the word following\n* the selection is returned.\n*\n* @param x mouse x location\n* @param newCaretOffset caret offset of the mouse cursor location\n* @param line line index of the mouse cursor location\n*/\n// flip selection anchor based on word selection direction from\n// base double click. Always do this here (and don't rely on doAutoScroll)\n// because auto scroll only does not cover all possible mouse selections\n// (e.g., mouse x < 0 && mouse y > caret line y)\n// find the previous/next word\n// mouse word select only on same line mouse cursor is on\n",
			"methodName":"int doMouseWordSelect(int x, int newCaretOffset, int line)"
		},
		"void doSelectionLineUp()":{
			"methodBody":"{\n    int oldColumnX;\n    int caretLine = getCaretLine();\n    int lineStartOffset = content.getOffsetAtLine(caretLine);\n    \n    oldColumnX = columnX = getXAtOffset(content.getLine(caretLine), caretLine, caretOffset - lineStartOffset);\n    if (caretLine == 0) {\n        caretOffset = 0;\n    } else {\n        caretLine = doLineUp();\n    }\n    setMouseWordSelectionAnchor();\n    \n    \n    showCaret(caretLine);\n    doSelection(ST.COLUMN_PREVIOUS);\n    \n    columnX = oldColumnX;\n}",
			"comments":"/**\n* Moves the caret one line up and to the same character offset relative\n* to the beginning of the line. Moves the caret to the end of the new line\n* if the new line is shorter than the character offset.\n* Moves the caret to the beginning of the document if it is already on the\n* first line.\n* Adjusts the selection according to the caret change. This can either add\n* to or subtract from the old selection, depending on the previous selection\n* direction.\n*/\n// reset columnX on selection\n// explicitly go to the calculated caret line. may be different\n// from content.getLineAtOffset(caretOffset) when in word wrap mode\n// save the original horizontal caret position\n",
			"methodName":"void doSelectionLineUp()"
		},
		"public void invokeAction(int action)":{
			"methodBody":"{\n    int oldColumnX, oldHScrollOffset, hScrollChange;\n    int caretLine;\n    checkWidget();\n    updateCaretDirection = true;\n    switch(action) {\n        \n        case ST.LINE_UP:\n            caretLine = doLineUp();\n            oldColumnX = columnX;\n            oldHScrollOffset = horizontalScrollOffset;\n            \n            \n            showCaret(caretLine);\n            \n            hScrollChange = oldHScrollOffset - horizontalScrollOffset;\n            columnX = oldColumnX + hScrollChange;\n            clearSelection(true);\n            break;\n        case ST.LINE_DOWN:\n            caretLine = doLineDown();\n            oldColumnX = columnX;\n            oldHScrollOffset = horizontalScrollOffset;\n            \n            \n            showCaret(caretLine);\n            \n            hScrollChange = oldHScrollOffset - horizontalScrollOffset;\n            columnX = oldColumnX + hScrollChange;\n            clearSelection(true);\n            break;\n        case ST.LINE_START:\n            doLineStart();\n            clearSelection(true);\n            break;\n        case ST.LINE_END:\n            doLineEnd();\n            clearSelection(true);\n            break;\n        case ST.COLUMN_PREVIOUS:\n            doCursorPrevious();\n            clearSelection(true);\n            break;\n        case ST.COLUMN_NEXT:\n            doCursorNext();\n            clearSelection(true);\n            break;\n        case ST.PAGE_UP:\n            doPageUp(false, getLineCountWhole());\n            clearSelection(true);\n            break;\n        case ST.PAGE_DOWN:\n            doPageDown(false, getLineCountWhole());\n            clearSelection(true);\n            break;\n        case ST.WORD_PREVIOUS:\n            doWordPrevious();\n            clearSelection(true);\n            break;\n        case ST.WORD_NEXT:\n            doWordNext();\n            clearSelection(true);\n            break;\n        case ST.TEXT_START:\n            doContentStart();\n            clearSelection(true);\n            break;\n        case ST.TEXT_END:\n            doContentEnd();\n            clearSelection(true);\n            break;\n        case ST.WINDOW_START:\n            doPageStart();\n            clearSelection(true);\n            break;\n        case ST.WINDOW_END:\n            doPageEnd();\n            clearSelection(true);\n            break;\n        \n        case ST.SELECT_LINE_UP:\n            doSelectionLineUp();\n            break;\n        case ST.SELECT_ALL:\n            selectAll();\n            break;\n        case ST.SELECT_LINE_DOWN:\n            doSelectionLineDown();\n            break;\n        case ST.SELECT_LINE_START:\n            doLineStart();\n            doSelection(ST.COLUMN_PREVIOUS);\n            break;\n        case ST.SELECT_LINE_END:\n            doLineEnd();\n            doSelection(ST.COLUMN_NEXT);\n            break;\n        case ST.SELECT_COLUMN_PREVIOUS:\n            doSelectionCursorPrevious();\n            doSelection(ST.COLUMN_PREVIOUS);\n            break;\n        case ST.SELECT_COLUMN_NEXT:\n            doSelectionCursorNext();\n            doSelection(ST.COLUMN_NEXT);\n            break;\n        case ST.SELECT_PAGE_UP:\n            doSelectionPageUp(getLineCountWhole());\n            break;\n        case ST.SELECT_PAGE_DOWN:\n            doSelectionPageDown(getLineCountWhole());\n            break;\n        case ST.SELECT_WORD_PREVIOUS:\n            doSelectionWordPrevious();\n            doSelection(ST.COLUMN_PREVIOUS);\n            break;\n        case ST.SELECT_WORD_NEXT:\n            doSelectionWordNext();\n            doSelection(ST.COLUMN_NEXT);\n            break;\n        case ST.SELECT_TEXT_START:\n            doContentStart();\n            doSelection(ST.COLUMN_PREVIOUS);\n            break;\n        case ST.SELECT_TEXT_END:\n            doContentEnd();\n            doSelection(ST.COLUMN_NEXT);\n            break;\n        case ST.SELECT_WINDOW_START:\n            doPageStart();\n            doSelection(ST.COLUMN_PREVIOUS);\n            break;\n        case ST.SELECT_WINDOW_END:\n            doPageEnd();\n            doSelection(ST.COLUMN_NEXT);\n            break;\n        \n        case ST.CUT:\n            cut();\n            break;\n        case ST.COPY:\n            copy();\n            break;\n        case ST.PASTE:\n            paste();\n            break;\n        case ST.DELETE_PREVIOUS:\n            doBackspace();\n            break;\n        case ST.DELETE_NEXT:\n            doDelete();\n            break;\n        case ST.DELETE_WORD_PREVIOUS:\n            doDeleteWordPrevious();\n            break;\n        case ST.DELETE_WORD_NEXT:\n            doDeleteWordNext();\n            break;\n        \n        case ST.TOGGLE_OVERWRITE:\n            \n            overwrite = !overwrite;\n            break;\n    }\n}",
			"comments":"/**\n* Executes the action.\n* <p>\n*\n* @param action one of the actions defined in ST.java\n*/\n// Navigation\n// explicitly go to the calculated caret line. may be different\n// from content.getLineAtOffset(caretOffset) when in word wrap mode\n// restore the original horizontal caret position\n// explicitly go to the calculated caret line. may be different\n// from content.getLineAtOffset(caretOffset) when in word wrap mode\n// restore the original horizontal caret position\n// Selection\n// Modification\n// Miscellaneous\n// toggle insert/overwrite mode\n",
			"methodName":"public void invokeAction(int action)"
		},
		"public void setTopIndex(int topIndex)":{
			"methodBody":"{\n    checkWidget();\n    int lineCount = logicalContent.getLineCount();\n    int pageSize = Math.max(1, Math.min(lineCount, getLineCountWhole()));\n    if (getCharCount() == 0) {\n        return;\n    }\n    if (topIndex < 0) {\n        topIndex = 0;\n    } else if (topIndex > lineCount - pageSize) {\n        topIndex = lineCount - pageSize;\n    }\n    if (wordWrap) {\n        int logicalLineOffset = logicalContent.getOffsetAtLine(topIndex);\n        topIndex = content.getLineAtOffset(logicalLineOffset);\n    }\n    setVerticalScrollOffset(topIndex * getVerticalIncrement(), true);\n}",
			"comments":"/**\n* Sets the top index. Do nothing if there is no text set.\n* <p>\n* The top index is the index of the line that is currently at the top\n* of the widget. The top index changes when the widget is scrolled.\n* Indexing starts from zero.\n* Note: The top index is reset to 0 when new text is set in the widget.\n* </p>\n*\n* @param topIndex new top index. Must be between 0 and\n* \tgetLineCount() - fully visible lines per page. If no lines are fully\n* \tvisible the maximum value is getLineCount() - 1. An out of range\n* \tindex will be adjusted accordingly.\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setTopIndex(int topIndex)"
		},
		"void handleKeyUp(Event event)":{
			"methodBody":"{\n    if (clipboardSelection != null) {\n        if (clipboardSelection.x != selection.x || clipboardSelection.y != selection.y) {\n            try {\n                if (selection.y - selection.x > 0) {\n                    setClipboardContent(selection.x, selection.y - selection.x, DND.SELECTION_CLIPBOARD);\n                }\n            } catch (SWTError error) {\n                \n                if (error.code != DND.ERROR_CANNOT_SET_CLIPBOARD) {\n                    throw error;\n                }\n            }\n        }\n    }\n    clipboardSelection = null;\n}",
			"comments":"/**\n* Update the Selection Clipboard.\n* <p>\n*\n* @param event keyboard event\n*/\n// Copy to clipboard failed. This happens when another application\n// is accessing the clipboard while we copy. Ignore the error.\n// Fixes 1GDQAVN\n// Rethrow all other errors. Fixes bug 17578.\n",
			"methodName":"void handleKeyUp(Event event)"
		},
		"public String getLineDelimiter()":{
			"methodBody":"{\n    checkWidget();\n    return content.getLineDelimiter();\n}",
			"comments":"/**\n* Returns the line delimiter used for entering new lines by key down\n* or paste operation.\n* <p>\n*\n* @return line delimiter used for entering new lines by key down\n* or paste operation.\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public String getLineDelimiter()"
		},
		"public void redrawReset(int startLine, int lineCount, boolean calculateMaxWidth)":{
			"methodBody":"{\n    if (lineCount == visualContent.getLineCount()) {\n        \n        visualContent.wrapLines();\n    } else {\n        visualContent.reset(startLine, lineCount);\n    }\n}",
			"comments":"/**\n* Wraps the lines in the specified range.\n* This method is called in <code>StyledText.redraw()</code>.\n* A redraw is therefore not necessary.\n* <p>\n*\n* @param startLine the first line to reset\n* @param lineCount the number of lines to reset\n* @param calculateMaxWidth true=implementors should retain a\n* \tvalid width even if it is affected by the reset operation.\n* \tfalse=the width may be set to 0\n*/\n// do a full rewrap if all lines are reset\n",
			"methodName":"public void redrawReset(int startLine, int lineCount, boolean calculateMaxWidth)"
		},
		"int getCaretDirection()":{
			"methodBody":"{\n    if (!isBidiCaret())\n        return SWT.DEFAULT;\n    if (!updateCaretDirection && caretDirection != SWT.NULL)\n        return caretDirection;\n    updateCaretDirection = false;\n    int caretLine = getCaretLine();\n    int lineOffset = content.getOffsetAtLine(caretLine);\n    String line = content.getLine(caretLine);\n    int offset = caretOffset - lineOffset;\n    int lineLength = line.length();\n    if (lineLength == 0)\n        return isMirrored() ? SWT.RIGHT : SWT.LEFT;\n    if (advancing && offset > 0)\n        offset--;\n    if (offset == lineLength && offset > 0)\n        offset--;\n    while (offset > 0 && Character.isDigit(line.charAt(offset))) offset--;\n    if (offset == 0 && Character.isDigit(line.charAt(offset))) {\n        return isMirrored() ? SWT.RIGHT : SWT.LEFT;\n    }\n    TextLayout layout = renderer.getTextLayout(line, lineOffset);\n    int level = layout.getLevel(offset);\n    renderer.disposeTextLayout(layout);\n    return ((level & 1) != 0) ? SWT.RIGHT : SWT.LEFT;\n}",
			"comments":"",
			"methodName":"int getCaretDirection()"
		},
		"public int getLineCount()":{
			"methodBody":"{\n    checkWidget();\n    return getLineAtOffset(getCharCount()) + 1;\n}",
			"comments":"/**\n* Gets the number of text lines.\n* <p>\n*\n* @return the number of lines in the widget\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getLineCount()"
		},
		"public void addVerifyKeyListener(VerifyKeyListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null) {\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    }\n    StyledTextListener typedListener = new StyledTextListener(listener);\n    addListener(VerifyKey, typedListener);\n}",
			"comments":"/**\n* Adds a verify key listener. A VerifyKey event is sent by the widget when a key\n* is pressed. The widget ignores the key press if the listener sets the doit field\n* of the event to false.\n* <p>\n*\n* @param listener the listener\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT when listener is null</li>\n* </ul>\n*/\n",
			"methodName":"public void addVerifyKeyListener(VerifyKeyListener listener)"
		},
		"public boolean isClosed()":{
			"methodBody":"{\n    return isClosed;\n}",
			"comments":"/**\n* Returns whether the writer is closed.\n* @return a boolean specifying whether or not the writer is closed\n*/\n",
			"methodName":"public boolean isClosed()"
		},
		"public void removeExtendedModifyListener(ExtendedModifyListener extendedModifyListener)":{
			"methodBody":"{\n    checkWidget();\n    if (extendedModifyListener == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    removeListener(ExtendedModify, extendedModifyListener);\n}",
			"comments":"/**\n* Removes the specified extended modify listener.\n* <p>\n*\n* @param extendedModifyListener the listener\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT when listener is null</li>\n* </ul>\n*/\n",
			"methodName":"public void removeExtendedModifyListener(ExtendedModifyListener extendedModifyListener)"
		},
		"void printDecorationSegment(String segment, int alignment, int page, boolean header)":{
			"methodBody":"{\n    int pageIndex = segment.indexOf(StyledTextPrintOptions.PAGE_TAG);\n    if (pageIndex != -1) {\n        final int PageTagLength = StyledTextPrintOptions.PAGE_TAG.length();\n        StringBuffer buffer = new StringBuffer(segment.substring(0, pageIndex));\n        buffer.append(page);\n        buffer.append(segment.substring(pageIndex + PageTagLength));\n        segment = buffer.toString();\n    }\n    if (segment.length() > 0) {\n        int segmentWidth;\n        int drawX = 0;\n        int drawY = 0;\n        TextLayout layout = new TextLayout(printer);\n        layout.setText(segment);\n        layout.setFont(printerFont);\n        segmentWidth = layout.getLineBounds(0).width;\n        if (header) {\n            drawY = clientArea.y - renderer.getLineHeight() * 2;\n        } else {\n            drawY = clientArea.y + clientArea.height + renderer.getLineHeight();\n        }\n        if (alignment == LEFT) {\n            drawX = clientArea.x;\n        } else if (alignment == CENTER) {\n            drawX = (pageWidth - segmentWidth) / 2;\n        } else if (alignment == RIGHT) {\n            drawX = clientArea.x + clientArea.width - segmentWidth;\n        }\n        layout.draw(gc, drawX, drawY);\n        layout.dispose();\n    }\n}",
			"comments":"/**\n* Print one segment of a header or footer decoration.\n* Headers and footers have three different segments.\n* One each for left aligned, centered, and right aligned text.\n*\n* @param segment decoration segment to print\n* @param alignment alignment of the segment. 0=left, 1=center, 2=right\n* @param page page number to print, if specified in the decoration segment.\n* @param header true = print the header, false = print the footer\n*/\n",
			"methodName":"void printDecorationSegment(String segment, int alignment, int page, boolean header)"
		},
		"void doContentStart()":{
			"methodBody":"{\n    if (caretOffset > 0) {\n        caretOffset = 0;\n        showCaret();\n    }\n}",
			"comments":"/**\n* Moves the caret in front of the first character of the widget content.\n*/\n",
			"methodName":"void doContentStart()"
		},
		"public void addBidiSegmentListener(BidiSegmentListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null) {\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    }\n    StyledTextListener typedListener = new StyledTextListener(listener);\n    addListener(LineGetSegments, typedListener);\n}",
			"comments":"/**\n* Adds a bidirectional segment listener. A BidiSegmentEvent is sent\n* whenever a line of text is measured or rendered. The user can\n* specify text ranges in the line that should be treated as if they\n* had a different direction than the surrounding text.\n* This may be used when adjacent segments of right-to-left text should\n* not be reordered relative to each other.\n* E.g., Multiple Java string literals in a right-to-left language\n* should generally remain in logical order to each other, that is, the\n* way they are stored.\n* <p>\n*\n* @param listener the listener\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT when listener is null</li>\n* </ul>\n* @see BidiSegmentEvent\n* @since 2.0\n*/\n",
			"methodName":"public void addBidiSegmentListener(BidiSegmentListener listener)"
		},
		"void setScrollBars()":{
			"methodBody":"{\n    ScrollBar verticalBar = getVerticalBar();\n    if (verticalBar != null) {\n        Rectangle clientArea = getClientArea();\n        final int INACTIVE = 1;\n        int maximum = content.getLineCount() * getVerticalIncrement();\n        \n        if (clientArea.height < maximum) {\n            verticalBar.setValues(verticalBar.getSelection(), verticalBar.getMinimum(), maximum, \n            clientArea.height, verticalBar.getIncrement(), \n            clientArea.height);\n        } else if (verticalBar.getThumb() != INACTIVE || verticalBar.getMaximum() != INACTIVE) {\n            verticalBar.setValues(verticalBar.getSelection(), verticalBar.getMinimum(), INACTIVE, INACTIVE, verticalBar.getIncrement(), INACTIVE);\n        }\n    }\n    setHorizontalScrollBar();\n}",
			"comments":"/**\n* Adjusts the maximum and the page size of the scroll bars to\n* reflect content width/length changes.\n*/\n// only set the real values if the scroll bar can be used\n// (ie. because the thumb size is less than the scroll maximum)\n// avoids flashing on Motif, fixes 1G7RE1J and 1G5SE92\n// thumb size\n// page size\n",
			"methodName":"void setScrollBars()"
		},
		"void handleKeyDown(Event event)":{
			"methodBody":"{\n    if (clipboardSelection == null) {\n        clipboardSelection = new Point(selection.x, selection.y);\n    }\n    Event verifyEvent = new Event();\n    verifyEvent.character = event.character;\n    verifyEvent.keyCode = event.keyCode;\n    verifyEvent.stateMask = event.stateMask;\n    verifyEvent.doit = true;\n    notifyListeners(VerifyKey, verifyEvent);\n    if (verifyEvent.doit == true) {\n        handleKey(event);\n    }\n}",
			"comments":"/**\n* If a VerifyKey listener exists, verify that the key that was entered\n* should be processed.\n* <p>\n*\n* @param event keyboard event\n*/\n",
			"methodName":"void handleKeyDown(Event event)"
		},
		"void installDefaultContent()":{
			"methodBody":"{\n    textChangeListener = new TextChangeListener() {\n\n        public void textChanging(TextChangingEvent event) {\n            handleTextChanging(event);\n        }\n\n        public void textChanged(TextChangedEvent event) {\n            handleTextChanged(event);\n        }\n\n        public void textSet(TextChangedEvent event) {\n            handleTextSet(event);\n        }\n    };\n    logicalContent = content = new DefaultContent();\n    content.addTextChangeListener(textChangeListener);\n}",
			"comments":"/**\n* Creates content change listeners and set the default content model.\n*/\n",
			"methodName":"void installDefaultContent()"
		},
		"public StyleRange[] getStyleRanges()":{
			"methodBody":"{\n    checkWidget();\n    StyleRange[] styles;\n    if (userLineStyle == false) {\n        styles = defaultLineStyler.getStyleRanges();\n    } else {\n        styles = new StyleRange[0];\n    }\n    return styles;\n}",
			"comments":"/**\n* Returns the styles.\n* Returns an empty array if a LineStyleListener has been set.\n* Should not be called if a LineStyleListener has been set since the\n* listener maintains the styles.\n* <p>\n*\n* @return the styles or an empty array if a LineStyleListener has been set.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public StyleRange[] getStyleRanges()"
		},
		"public int getOffsetAtLine(int lineIndex)":{
			"methodBody":"{\n    checkWidget();\n    if (lineIndex < 0 || (lineIndex > 0 && lineIndex >= logicalContent.getLineCount())) {\n        SWT.error(SWT.ERROR_INVALID_RANGE);\n    }\n    return logicalContent.getOffsetAtLine(lineIndex);\n}",
			"comments":"/**\n* Returns the character offset of the first character of the given line.\n* <p>\n*\n* @param lineIndex index of the line, 0 based relative to the first\n* \tline in the content. 0 <= lineIndex < getLineCount(), except\n* \tlineIndex may always be 0\n* @return offset offset of the first character of the line, relative to\n* \tthe beginning of the document. The first character of the document is\n*\tat offset 0.\n*  When there are not any lines, getOffsetAtLine(0) is a valid call that\n* \tanswers 0.\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*   <li>ERROR_INVALID_RANGE when the offset is outside the valid range (< 0 or > getCharCount())</li>\n* </ul>\n* @since 2.0\n*/\n",
			"methodName":"public int getOffsetAtLine(int lineIndex)"
		},
		"boolean scrollHorizontalBar(int pixels)":{
			"methodBody":"{\n    if (pixels == 0) {\n        return false;\n    }\n    ScrollBar horizontalBar = getHorizontalBar();\n    if (horizontalBar != null) {\n        horizontalBar.setSelection(horizontalScrollOffset + pixels);\n    }\n    scrollHorizontal(pixels);\n    return true;\n}",
			"comments":"/**\n* Scrolls the widget horizontally and adjust the horizontal scroll\n* bar to reflect the new horizontal offset..\n* <p>\n*\n* @param pixels number of pixels to scroll, > 0 = scroll left,\n* \t< 0 scroll right\n* @return\n*\ttrue=the widget was scrolled\n*\tfalse=the widget was not scrolled, the given offset is not valid.\n*/\n",
			"methodName":"boolean scrollHorizontalBar(int pixels)"
		},
		"boolean isBidiCaret()":{
			"methodBody":"{\n    return BidiUtil.isBidiPlatform();\n}",
			"comments":"",
			"methodName":"boolean isBidiCaret()"
		},
		"void initializeRenderer()":{
			"methodBody":"{\n    if (renderer != null) {\n        renderer.dispose();\n    }\n    renderer = new DisplayRenderer(getDisplay(), getFont(), this, tabLength);\n    lineHeight = renderer.getLineHeight();\n    if (wordWrap) {\n        content = new WrappedContent(renderer, logicalContent);\n    }\n}",
			"comments":"/**\n* Initializes the fonts used to render font styles.\n* Presently only regular and bold fonts are supported.\n*/\n",
			"methodName":"void initializeRenderer()"
		},
		"public void writeLine(String line, int lineOffset)":{
			"methodBody":"{\n    int lineLength = line.length();\n    int lineIndex;\n    int copyEnd;\n    int writeOffset = startOffset - lineOffset;\n    if (isClosed) {\n        SWT.error(SWT.ERROR_IO);\n    }\n    if (writeOffset >= lineLength) {\n        \n        return;\n    } else if (writeOffset > 0) {\n        \n        lineIndex = writeOffset;\n    } else {\n        lineIndex = 0;\n    }\n    copyEnd = Math.min(lineLength, endOffset - lineOffset);\n    if (lineIndex < copyEnd) {\n        write(line.substring(lineIndex, copyEnd));\n    }\n}",
			"comments":"/**\n* Appends the specified line text to the data.\n* <p>\n*\n* @param line line text to write. Must not contain line breaks\n* \tLine breaks should be written using writeLineDelimiter()\n* @param lineOffset offset of the line. 0 based from the start of the\n* \twidget document. Any text occurring before the start offset or after the\n*\tend offset specified during object creation is ignored.\n* @exception SWTException <ul>\n*   <li>ERROR_IO when the writer is closed.</li>\n* </ul>\n*/\n// whole line is outside write range\n// line starts before write start\n",
			"methodName":"public void writeLine(String line, int lineOffset)"
		},
		"void doSelectionPageUp(int lines)":{
			"methodBody":"{\n    int oldColumnX;\n    int caretLine = getCaretLine();\n    int lineStartOffset = content.getOffsetAtLine(caretLine);\n    \n    oldColumnX = columnX = getXAtOffset(content.getLine(caretLine), caretLine, caretOffset - lineStartOffset);\n    doPageUp(true, lines);\n    columnX = oldColumnX;\n}",
			"comments":"/**\n* Scrolls one page up so that the first line (truncated or whole)\n* of the current page becomes the fully visible last line.\n* The caret is scrolled the same number of lines so that its location\n* relative to the top line remains the same. The exception is the beginning\n* of the text where a full page scroll is not possible. In this case the\n* caret is moved in front of the first character.\n* <p>\n* Adjusts the selection according to the caret change. This can either add\n* to or subtract from the old selection, depending on the previous selection\n* direction.\n* </p>\n*/\n// reset columnX on selection\n",
			"methodName":"void doSelectionPageUp(int lines)"
		},
		"public String getSelectionText()":{
			"methodBody":"{\n    checkWidget();\n    return content.getTextRange(selection.x, selection.y - selection.x);\n}",
			"comments":"/**\n* Returns the selected text.\n* <p>\n*\n* @return selected text, or an empty String if there is no selection.\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public String getSelectionText()"
		},
		"void doLineStart()":{
			"methodBody":"{\n    int caretLine = getCaretLine();\n    int lineOffset = content.getOffsetAtLine(caretLine);\n    if (caretOffset > lineOffset) {\n        caretOffset = lineOffset;\n        showCaret(caretLine);\n    }\n}",
			"comments":"/**\n* Moves the caret to the beginning of the line.\n*/\n",
			"methodName":"void doLineStart()"
		},
		"public void textChanged(TextChangedEvent event)":{
			"methodBody":"{\n    handleTextChanged(event);\n}",
			"comments":"",
			"methodName":"public void textChanged(TextChangedEvent event)"
		},
		"int getBottomIndex()":{
			"methodBody":"{\n    int lineCount = 1;\n    if (lineHeight != 0) {\n        \n        int partialTopLineHeight = topIndex * lineHeight - verticalScrollOffset;\n        lineCount = (getClientArea().height - partialTopLineHeight) / lineHeight;\n    }\n    return Math.min(content.getLineCount() - 1, topIndex + Math.max(0, lineCount - 1));\n}",
			"comments":"/**\n* Returns the index of the last fully visible line.\n* <p>\n*\n* @return index of the last fully visible line.\n*/\n// calculate the number of lines that are fully visible\n",
			"methodName":"int getBottomIndex()"
		},
		"int[] getBidiSegmentsCompatibility(String line, int lineOffset)":{
			"methodBody":"{\n    StyledTextEvent event;\n    StyleRange[] styles = new StyleRange[0];\n    int lineLength = line.length();\n    if (bidiColoring == false) {\n        return new int[] { 0, lineLength };\n    }\n    event = renderer.getLineStyleData(lineOffset, line);\n    if (event != null) {\n        styles = event.styles;\n    }\n    if (styles.length == 0) {\n        return new int[] { 0, lineLength };\n    }\n    int k = 0, count = 1;\n    while (k < styles.length && styles[k].start == 0 && styles[k].length == lineLength) {\n        k++;\n    }\n    int[] offsets = new int[(styles.length - k) * 2 + 2];\n    for (int i = k; i < styles.length; i++) {\n        StyleRange style = styles[i];\n        int styleLineStart = Math.max(style.start - lineOffset, 0);\n        int styleLineEnd = Math.max(style.start + style.length - lineOffset, styleLineStart);\n        styleLineEnd = Math.min(styleLineEnd, line.length());\n        if (i > 0 && count > 1 && ((styleLineStart >= offsets[count - 2] && styleLineStart <= offsets[count - 1]) || (styleLineEnd >= offsets[count - 2] && styleLineEnd <= offsets[count - 1])) && style.similarTo(styles[i - 1])) {\n            offsets[count - 2] = Math.min(offsets[count - 2], styleLineStart);\n            offsets[count - 1] = Math.max(offsets[count - 1], styleLineEnd);\n        } else {\n            if (styleLineStart > offsets[count - 1]) {\n                offsets[count] = styleLineStart;\n                count++;\n            }\n            offsets[count] = styleLineEnd;\n            count++;\n        }\n    }\n    \n    if (lineLength > offsets[count - 1]) {\n        offsets[count] = lineLength;\n        count++;\n    }\n    if (count == offsets.length) {\n        return offsets;\n    }\n    int[] result = new int[count];\n    System.arraycopy(offsets, 0, result, 0, count);\n    return result;\n}",
			"comments":"/**\n* @see #getBidiSegments\n* Supports deprecated setBidiColoring API. Remove when API is removed.\n*/\n// add offset for last non-colored segment in line, if any\n",
			"methodName":"int[] getBidiSegmentsCompatibility(String line, int lineOffset)"
		},
		"int getWordEnd(int offset)":{
			"methodBody":"{\n    int line = logicalContent.getLineAtOffset(offset);\n    int lineOffset = logicalContent.getOffsetAtLine(line);\n    String lineText = logicalContent.getLine(line);\n    int lineLength = lineText.length();\n    if (offset >= getCharCount()) {\n        return offset;\n    }\n    if (offset == lineOffset + lineLength) {\n        line++;\n        offset = logicalContent.getOffsetAtLine(line);\n    } else {\n        TextLayout layout = renderer.getTextLayout(lineText, lineOffset);\n        offset -= lineOffset;\n        offset = layout.getNextOffset(offset, SWT.MOVEMENT_WORD);\n        offset += lineOffset;\n        renderer.disposeTextLayout(layout);\n    }\n    return offset;\n}",
			"comments":"/**\n* Returns the offset of the character after the word at the specified\n* offset.\n* <p>\n* There are two classes of words formed by a sequence of characters:\n* <ul>\n* <li>from 0-9 and A-z (ASCII 48-57 and 65-122)\n* <li>every other character except line breaks\n* </ul>\n* </p>\n* <p>\n* Space characters ' ' (ASCII 20) are special as they are treated as\n* part of the word leading up to the space character.  Line breaks are\n* treated as one word.\n* </p>\n*/\n",
			"methodName":"int getWordEnd(int offset)"
		},
		"public void removeLineBackgroundListener(LineBackgroundListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    removeListener(LineGetBackground, listener);\n    \n    if (isListening(LineGetBackground) == false && userLineBackground) {\n        StyledTextListener typedListener = new StyledTextListener(defaultLineStyler);\n        addListener(LineGetBackground, typedListener);\n        userLineBackground = false;\n    }\n}",
			"comments":"/**\n* Removes the specified line background listener.\n* <p>\n*\n* @param listener the listener\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT when listener is null</li>\n* </ul>\n*/\n// use default line styler if last user line styler was removed.\n",
			"methodName":"public void removeLineBackgroundListener(LineBackgroundListener listener)"
		},
		"public String getText(int start, int end)":{
			"methodBody":"{\n    checkWidget();\n    int contentLength = getCharCount();\n    if (start < 0 || start >= contentLength || end < 0 || end >= contentLength || start > end) {\n        SWT.error(SWT.ERROR_INVALID_RANGE);\n    }\n    return content.getTextRange(start, end - start + 1);\n}",
			"comments":"/**\n* Returns the widget content between the two offsets.\n* <p>\n*\n* @param start offset of the first character in the returned String\n* @param end offset of the last character in the returned String\n* @return widget content starting at start and ending at end\n* @see #getTextRange(int,int)\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*   <li>ERROR_INVALID_RANGE when start and/or end are outside the widget content</li>\n* </ul>\n*/\n",
			"methodName":"public String getText(int start, int end)"
		},
		"public void selectAll()":{
			"methodBody":"{\n    checkWidget();\n    setSelection(0, Math.max(getCharCount(), 0));\n}",
			"comments":"/**\n* Selects all the text.\n* <p>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void selectAll()"
		},
		"int doLineUp()":{
			"methodBody":"{\n    int caretLine = getCaretLine();\n    if (caretLine > 0) {\n        caretLine--;\n        caretOffset = getOffsetAtMouseLocation(columnX, caretLine);\n    }\n    return caretLine;\n}",
			"comments":"/**\n* Moves the caret one line up and to the same character offset relative\n* to the beginning of the line. Move the caret to the end of the new line\n* if the new line is shorter than the character offset.\n*\n* @return index of the new line relative to the first line in the document\n*/\n",
			"methodName":"int doLineUp()"
		},
		"public void print()":{
			"methodBody":"{\n    checkWidget();\n    Printer printer = new Printer();\n    StyledTextPrintOptions options = new StyledTextPrintOptions();\n    options.printTextForeground = true;\n    options.printTextBackground = true;\n    options.printTextFontStyle = true;\n    options.printLineBackground = true;\n    new Printing(this, printer, options).run();\n    printer.dispose();\n}",
			"comments":"/**\n* Prints the widget's text to the default printer.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void print()"
		},
		"void claimBottomFreeSpace()":{
			"methodBody":"{\n    int newVerticalOffset = Math.max(0, content.getLineCount() * lineHeight - getClientArea().height);\n    if (newVerticalOffset < verticalScrollOffset) {\n        \n        \n        setVerticalScrollOffset(newVerticalOffset, true);\n    }\n}",
			"comments":"/**\n* Scrolls down the text to use new space made available by a resize or by\n* deleted lines.\n*/\n// Scroll up so that empty lines below last text line are used.\n// Fixes 1GEYJM0\n",
			"methodName":"void claimBottomFreeSpace()"
		},
		"public Color getSelectionBackground()":{
			"methodBody":"{\n    checkWidget();\n    if (selectionBackground == null) {\n        return getDisplay().getSystemColor(SWT.COLOR_LIST_SELECTION);\n    }\n    return selectionBackground;\n}",
			"comments":"/**\n* Returns the receiver's selection background color.\n*\n* @return the selection background color\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @since 2.1\n*/\n",
			"methodName":"public Color getSelectionBackground()"
		},
		"void doPageStart()":{
			"methodBody":"{\n    int topCaretOffset = content.getOffsetAtLine(topIndex);\n    if (caretOffset > topCaretOffset) {\n        caretOffset = topCaretOffset;\n        \n        \n        showCaret(topIndex);\n    }\n}",
			"comments":"/**\n* Moves the cursor to the beginning of the first fully visible line.\n*/\n// explicitly go to the calculated caret line. may be different\n// from content.getLineAtOffset(caretOffset) when in word wrap mode\n",
			"methodName":"void doPageStart()"
		},
		"Object getClipboardContent(int clipboardType)":{
			"methodBody":"{\n    TextTransfer plainTextTransfer = TextTransfer.getInstance();\n    return clipboard.getContents(plainTextTransfer, clipboardType);\n}",
			"comments":"",
			"methodName":"Object getClipboardContent(int clipboardType)"
		},
		"public void setSelection(int start, int end)":{
			"methodBody":"{\n    \n    setSelectionRange(start, end - start);\n    showSelection();\n}",
			"comments":"/**\n* Sets the selection and scrolls it into view.\n* <p>\n* Indexing is zero based.  Text selections are specified in terms of\n* caret positions.  In a text widget that contains N characters, there are\n* N+1 caret positions, ranging from 0..N\n* </p>\n*\n* @param start selection start offset. The caret will be placed at the\n* \tselection start when start > end.\n* @param end selection end offset\n* @see #setSelectionRange(int,int)\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*   <li>ERROR_INVALID_ARGUMENT when either the start or the end of the selection range is inside a\n* multi byte line delimiter (and thus neither clearly in front of or after the line delimiter)\n* </ul>\n*/\n// checkWidget test done in setSelectionRange\n",
			"methodName":"public void setSelection(int start, int end)"
		},
		"int[] getBidiSegments(int lineOffset, String line)":{
			"methodBody":"{\n    if (isListening(LineGetSegments) == false) {\n        return getBidiSegmentsCompatibility(line, lineOffset);\n    }\n    StyledTextEvent event = sendLineEvent(LineGetSegments, lineOffset, line);\n    int lineLength = line.length();\n    int[] segments;\n    if (event == null || event.segments == null || event.segments.length == 0) {\n        segments = new int[] { 0, lineLength };\n    } else {\n        int segmentCount = event.segments.length;\n        \n        if (event.segments[0] != 0) {\n            SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n        }\n        for (int i = 1; i < segmentCount; i++) {\n            if (event.segments[i] <= event.segments[i - 1] || event.segments[i] > lineLength) {\n                SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n            }\n        }\n        \n        if (event.segments[segmentCount - 1] != lineLength) {\n            segments = new int[segmentCount + 1];\n            System.arraycopy(event.segments, 0, segments, 0, segmentCount);\n            segments[segmentCount] = lineLength;\n        } else {\n            segments = event.segments;\n        }\n    }\n    return segments;\n}",
			"comments":"/**\n* Returns the text segments that should be treated as if they\n* had a different direction than the surrounding text.\n* <p>\n*\n* @param lineOffset offset of the first character in the line.\n* \t0 based from the beginning of the document.\n* @param line text of the line to specify bidi segments for\n* @return text segments that should be treated as if they had a\n* \tdifferent direction than the surrounding text. Only the start\n* \tindex of a segment is specified, relative to the start of the\n* \tline. Always starts with 0 and ends with the line length.\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the segment indices returned\n* \t\tby the listener do not start with 0, are not in ascending order,\n* \t\texceed the line length or have duplicates</li>\n* </ul>\n*/\n// test segment index consistency\n// ensure that last segment index is line end offset\n",
			"methodName":"int[] getBidiSegments(int lineOffset, String line)"
		},
		"void draw(int x, int y, int width, int height, boolean clearBackground)":{
			"methodBody":"{\n    if (clearBackground) {\n        redraw(x + leftMargin, y + topMargin, width, height, true);\n    } else {\n        int startLine = (y + verticalScrollOffset) / lineHeight;\n        int endY = y + height;\n        int paintYFromTopLine = (startLine - topIndex) * lineHeight;\n        int topLineOffset = (topIndex * lineHeight - verticalScrollOffset);\n        \n        int paintY = paintYFromTopLine + topLineOffset + topMargin;\n        int lineCount = content.getLineCount();\n        Color background = getBackground();\n        Color foreground = getForeground();\n        GC gc = getGC();\n        if (isSingleLine()) {\n            lineCount = 1;\n        }\n        for (int i = startLine; paintY < endY && i < lineCount; i++, paintY += lineHeight) {\n            String line = content.getLine(i);\n            renderer.drawLine(line, i, paintY, gc, background, foreground, clearBackground);\n        }\n        gc.dispose();\n    }\n}",
			"comments":"/**\n* Draws the specified rectangle.\n* Draw directly without invalidating the affected area when clearBackground is\n* false.\n* <p>\n*\n* @param x the x position\n* @param y the y position\n* @param width the width\n* @param height the height\n* @param clearBackground true=clear the background by invalidating the requested\n* \tredraw area, false=draw the foreground directly without invalidating the\n* \tredraw area.\n*/\n// adjust y position for pixel based scrolling\n",
			"methodName":"void draw(int x, int y, int width, int height, boolean clearBackground)"
		},
		"void doDeleteWordPrevious()":{
			"methodBody":"{\n    if (selection.x != selection.y) {\n        \n        \n        doBackspace();\n    } else {\n        Event event = new Event();\n        event.text = \"\";\n        event.start = getWordStart(caretOffset);\n        event.end = caretOffset;\n        sendKeyEvent(event);\n    }\n}",
			"comments":"/**\n* Deletes the previous word.\n*/\n// if a selection exists, treat as if\n// only the backspace key was pressed\n",
			"methodName":"void doDeleteWordPrevious()"
		},
		"public void setSelectionForeground(Color color)":{
			"methodBody":"{\n    checkWidget();\n    if (color != null) {\n        if (color.isDisposed())\n            SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    }\n    selectionForeground = color;\n    redraw();\n}",
			"comments":"/**\n* Sets the receiver's selection foreground color to the color specified\n* by the argument, or to the default system color for the control\n* if the argument is null.\n*\n* @param color the new color (or null)\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @since 2.1\n*/\n",
			"methodName":"public void setSelectionForeground(Color color)"
		},
		"void resetSelection()":{
			"methodBody":"{\n    selection.x = selection.y = caretOffset;\n    selectionAnchor = -1;\n}",
			"comments":"/**\n* Resets the selection.\n*/\n",
			"methodName":"void resetSelection()"
		},
		"public void addModifyListener(ModifyListener modifyListener)":{
			"methodBody":"{\n    checkWidget();\n    if (modifyListener == null) {\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    }\n    TypedListener typedListener = new TypedListener(modifyListener);\n    addListener(SWT.Modify, typedListener);\n}",
			"comments":"/**\n* Adds a modify listener. A Modify event is sent by the widget when the widget text\n* has changed.\n* <p>\n*\n* @param modifyListener the listener\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT when listener is null</li>\n* </ul>\n*/\n",
			"methodName":"public void addModifyListener(ModifyListener modifyListener)"
		},
		"public String getTextRange(int start, int length)":{
			"methodBody":"{\n    checkWidget();\n    int contentLength = getCharCount();\n    int end = start + length;\n    if (start > end || start < 0 || end > contentLength) {\n        SWT.error(SWT.ERROR_INVALID_RANGE);\n    }\n    return content.getTextRange(start, length);\n}",
			"comments":"/**\n* Returns the widget content starting at start for length characters.\n* <p>\n*\n* @param start offset of the first character in the returned String\n* @param length number of characters to return\n* @return widget content starting at start and extending length characters.\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*   <li>ERROR_INVALID_RANGE when start and/or length are outside the widget content</li>\n* </ul>\n*/\n",
			"methodName":"public String getTextRange(int start, int length)"
		},
		"public int getStart()":{
			"methodBody":"{\n    return startOffset;\n}",
			"comments":"/**\n* Returns the offset where writing starts. 0 based from the start of\n* the widget text. Used to write partial lines.\n* @return the integer offset where writing starts\n*/\n",
			"methodName":"public int getStart()"
		},
		"public int getStyle()":{
			"methodBody":"{\n    int style = super.getStyle();\n    style &= ~(SWT.LEFT_TO_RIGHT | SWT.RIGHT_TO_LEFT | SWT.MIRRORED);\n    if (isMirrored()) {\n        style |= SWT.RIGHT_TO_LEFT | SWT.MIRRORED;\n    } else {\n        style |= SWT.LEFT_TO_RIGHT;\n    }\n    return style;\n}",
			"comments":"",
			"methodName":"public int getStyle()"
		},
		"void doWordPrevious()":{
			"methodBody":"{\n    if (selection.y - selection.x > 0) {\n        int caretLine;\n        caretOffset = selection.x;\n        caretLine = getCaretLine();\n        showCaret(caretLine);\n    } else {\n        doSelectionWordPrevious();\n    }\n}",
			"comments":"/**\n* Moves the caret to the start of the previous word.\n* If a selection exists, move the caret to the start of the selection\n* and remove the selection.\n*/\n",
			"methodName":"void doWordPrevious()"
		},
		"public void setCursor(Cursor cursor)":{
			"methodBody":"{\n    if (cursor == null) {\n        super.setCursor(ibeamCursor);\n    } else {\n        super.setCursor(cursor);\n    }\n}",
			"comments":"/**\n* Sets the receiver's cursor to the cursor specified by the\n* argument.  Overridden to handle the null case since the\n* StyledText widget uses an ibeam as its default cursor.\n*\n* @see org.eclipse.swt.widgets.Control#setCursor\n*/\n",
			"methodName":"public void setCursor(Cursor cursor)"
		},
		"public void copy(int clipboardType)":{
			"methodBody":"{\n    checkWidget();\n    if (clipboardType != DND.CLIPBOARD && clipboardType != DND.SELECTION_CLIPBOARD)\n        return;\n    int length = selection.y - selection.x;\n    if (length > 0) {\n        try {\n            setClipboardContent(selection.x, length, clipboardType);\n        } catch (SWTError error) {\n            \n            if (error.code != DND.ERROR_CANNOT_SET_CLIPBOARD) {\n                throw error;\n            }\n        }\n    }\n}",
			"comments":"/**\n* Copies the selected text to the specified clipboard.  The text will be put in the\n* clipboard in plain text format and RTF format.\n*\n* <p>The clipboardType is  one of the clipboard constants defined in class\n* <code>DND</code>.  The <code>DND.CLIPBOARD</code>  clipboard is\n* used for data that is transferred by keyboard accelerator (such as Ctrl+C/Ctrl+V)\n* or by menu action.  The <code>DND.SELECTION_CLIPBOARD</code>\n* clipboard is used for data that is transferred by selecting text and pasting\n* with the middle mouse button.</p>\n*\n* @param clipboardType indicates the type of clipboard\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.1\n*/\n// Copy to clipboard failed. This happens when another application\n// is accessing the clipboard while we copy. Ignore the error.\n// Fixes 1GDQAVN\n// Rethrow all other errors. Fixes bug 17578.\n",
			"methodName":"public void copy(int clipboardType)"
		},
		"public String getText()":{
			"methodBody":"{\n    checkWidget();\n    return content.getTextRange(0, getCharCount());\n}",
			"comments":"/**\n* Returns a copy of the widget content.\n* <p>\n*\n* @return copy of the widget content\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public String getText()"
		},
		"int getVerticalIncrement()":{
			"methodBody":"{\n    return lineHeight;\n}",
			"comments":"/**\n* Returns the vertical scroll increment.\n* <p>\n*\n* @return vertical scroll increment.\n*/\n",
			"methodName":"int getVerticalIncrement()"
		},
		"public int getBaseline()":{
			"methodBody":"{\n    checkWidget();\n    return renderer.getBaseline();\n}",
			"comments":"/**\n* Returns the baseline, in pixels.\n*\n* @return baseline the baseline\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @since 3.0\n*/\n",
			"methodName":"public int getBaseline()"
		},
		"void redrawLine(int line, int offset)":{
			"methodBody":"{\n    int redrawX = 0;\n    if (offset > 0) {\n        String lineText = content.getLine(line);\n        redrawX = getXAtOffset(lineText, line, offset);\n    }\n    int redrawY = line * lineHeight - verticalScrollOffset;\n    super.redraw(redrawX + leftMargin, redrawY + topMargin, getClientArea().width - leftMargin - rightMargin, lineHeight, true);\n}",
			"comments":"/**\n* Redraw the given line.\n* <p>\n*\n* @param line index of the line to redraw\n* @param offset offset in line to start redrawing\n*/\n",
			"methodName":"void redrawLine(int line, int offset)"
		},
		"int getHorizontalIncrement()":{
			"methodBody":"{\n    GC gc = getGC();\n    int increment = gc.getFontMetrics().getAverageCharWidth();\n    gc.dispose();\n    return increment;\n}",
			"comments":"/**\n* Returns the horizontal scroll increment.\n* <p>\n*\n* @return horizontal scroll increment.\n*/\n",
			"methodName":"int getHorizontalIncrement()"
		},
		"public int getSelectionCount()":{
			"methodBody":"{\n    checkWidget();\n    return getSelectionRange().y;\n}",
			"comments":"/**\n* Gets the number of selected characters.\n* <p>\n*\n* @return the number of selected characters.\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getSelectionCount()"
		},
		"public void setText(String text)":{
			"methodBody":"{\n    checkWidget();\n    Event event = new Event();\n    if (text == null) {\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    }\n    event.start = 0;\n    event.end = getCharCount();\n    event.text = text;\n    event.doit = true;\n    notifyListeners(SWT.Verify, event);\n    if (event.doit) {\n        StyledTextEvent styledTextEvent = null;\n        if (isListening(ExtendedModify)) {\n            styledTextEvent = new StyledTextEvent(logicalContent);\n            styledTextEvent.start = event.start;\n            styledTextEvent.end = event.start + event.text.length();\n            styledTextEvent.text = content.getTextRange(event.start, event.end - event.start);\n        }\n        content.setText(event.text);\n        sendModifyEvent(event);\n        if (styledTextEvent != null) {\n            notifyListeners(ExtendedModify, styledTextEvent);\n        }\n    }\n}",
			"comments":"/**\n* Sets the widget content.\n* If the widget has the SWT.SINGLE style and \"text\" contains more than\n* one line, only the first line is rendered but the text is stored\n* unchanged. A subsequent call to getText will return the same text\n* that was set.\n* <p>\n* <b>Note:</b> Only a single line of text should be set when the SWT.SINGLE\n* style is used.\n* </p>\n*\n* @param text new widget content. Replaces existing content. Line styles\n* \tthat were set using StyledText API are discarded.  The\n* \tcurrent selection is also discarded.\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT when string is null</li>\n* </ul>\n*/\n",
			"methodName":"public void setText(String text)"
		},
		"public Color getLineBackground(int index)":{
			"methodBody":"{\n    checkWidget();\n    Color lineBackground = null;\n    if (index < 0 || index > logicalContent.getLineCount()) {\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    }\n    if (userLineBackground == false) {\n        lineBackground = defaultLineStyler.getLineBackground(index);\n    }\n    return lineBackground;\n}",
			"comments":"/**\n* Returns the background color of the line at the given index.\n* Returns null if a LineBackgroundListener has been set or if no background\n* color has been specified for the line. Should not be called if a\n* LineBackgroundListener has been set since the listener maintains the\n* line background colors.\n*\n* @param index the index of the line\n* @return the background color of the line at the given index.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT when the index is invalid</li>\n* </ul>\n*/\n",
			"methodName":"public Color getLineBackground(int index)"
		},
		"void calculateScrollBars()":{
			"methodBody":"{\n    ScrollBar horizontalBar = getHorizontalBar();\n    ScrollBar verticalBar = getVerticalBar();\n    setScrollBars();\n    if (verticalBar != null) {\n        verticalBar.setIncrement(getVerticalIncrement());\n    }\n    if (horizontalBar != null) {\n        horizontalBar.setIncrement(getHorizontalIncrement());\n    }\n}",
			"comments":"/**\n* Calculates the scroll bars\n*/\n",
			"methodName":"void calculateScrollBars()"
		},
		"public int getTextLimit()":{
			"methodBody":"{\n    checkWidget();\n    return textLimit;\n}",
			"comments":"/**\n* Returns the maximum number of characters that the receiver is capable of holding.\n*\n* @return the text limit\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getTextLimit()"
		},
		"public void removeVerifyListener(VerifyListener verifyListener)":{
			"methodBody":"{\n    checkWidget();\n    if (verifyListener == null) {\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    }\n    removeListener(SWT.Verify, verifyListener);\n}",
			"comments":"/**\n* Removes the specified verify listener.\n* <p>\n*\n* @param verifyListener the listener\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT when listener is null</li>\n* </ul>\n*/\n",
			"methodName":"public void removeVerifyListener(VerifyListener verifyListener)"
		},
		"int getWordStart(int offset)":{
			"methodBody":"{\n    int line = logicalContent.getLineAtOffset(offset);\n    int lineOffset = logicalContent.getOffsetAtLine(line);\n    String lineText = logicalContent.getLine(line);\n    if (offset <= 0) {\n        return offset;\n    }\n    if (offset == lineOffset) {\n        line--;\n        lineText = logicalContent.getLine(line);\n        offset = logicalContent.getOffsetAtLine(line) + lineText.length();\n    } else {\n        TextLayout layout = renderer.getTextLayout(lineText, lineOffset);\n        offset -= lineOffset;\n        offset = layout.getPreviousOffset(offset, SWT.MOVEMENT_WORD);\n        offset += lineOffset;\n        renderer.disposeTextLayout(layout);\n    }\n    return offset;\n}",
			"comments":"/**\n* Returns the start offset of the word at the specified offset.\n* There are two classes of words formed by a sequence of characters:\n* <p>\n* <ul>\n* <li>from 0-9 and A-z (ASCII 48-57 and 65-122)\n* <li>every other character except line breaks\n* </ul>\n* </p>\n* <p>\n* Space characters ' ' (ASCII 20) are special as they are treated as\n* part of the word leading up to the space character.  Line breaks are treated\n* as one word.\n* </p>\n*/\n",
			"methodName":"int getWordStart(int offset)"
		},
		"StyledTextEvent getLineBackgroundData(int lineOffset, String line)":{
			"methodBody":"{\n    return sendLineEvent(LineGetBackground, lineOffset, line);\n}",
			"comments":"/**\n* Returns the line background data for the given line or null if\n* there is none.\n* <p>\n* @param lineOffset offset of the line start relative to the start\n* \tof the content.\n* @param line line to get line background data for\n* @return line background data for the given line.\n*/\n",
			"methodName":"StyledTextEvent getLineBackgroundData(int lineOffset, String line)"
		},
		"void handlePaint(Event event)":{
			"methodBody":"{\n    int startLine = Math.max(0, (event.y - topMargin + verticalScrollOffset) / lineHeight);\n    int paintYFromTopLine = (startLine - topIndex) * lineHeight;\n    int topLineOffset = topIndex * lineHeight - verticalScrollOffset;\n    \n    int startY = paintYFromTopLine + topLineOffset + topMargin;\n    int renderHeight = event.y + event.height - startY;\n    \n    if (event.height == 0) {\n        return;\n    }\n    performPaint(event.gc, startLine, startY, renderHeight);\n}",
			"comments":"/**\n* Renders the invalidated area specified in the paint event.\n* <p>\n*\n* @param event paint event\n*/\n// adjust y position for pixel based scrolling and top margin\n// Check if there is work to do\n",
			"methodName":"void handlePaint(Event event)"
		},
		"public void setHorizontalPixel(int pixel)":{
			"methodBody":"{\n    checkWidget();\n    int clientAreaWidth = getClientArea().width;\n    if (getCharCount() == 0) {\n        return;\n    }\n    if (pixel < 0) {\n        pixel = 0;\n    }\n    \n    if (clientAreaWidth > 0) {\n        int width = lineCache.getWidth();\n        \n        if (pixel > width - clientAreaWidth) {\n            pixel = Math.max(0, width - clientAreaWidth);\n        }\n    }\n    scrollHorizontalBar(pixel - horizontalScrollOffset);\n}",
			"comments":"/**\n* Sets the horizontal pixel offset relative to the start of the line.\n* Do nothing if there is no text set.\n* <p>\n* <b>NOTE:</b> The horizontal pixel offset is reset to 0 when new text\n* is set in the widget.\n* </p>\n*\n* @param pixel horizontal pixel offset relative to the start\n* \tof the line.\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @since 2.0\n*/\n// allow any value if client area width is unknown or 0.\n// offset will be checked in resize handler.\n// don't use isVisible since width is known even if widget\n// is temporarily invisible\n// prevent scrolling if the content fits in the client area.\n// align end of longest line with right border of client area\n// if offset is out of range.\n",
			"methodName":"public void setHorizontalPixel(int pixel)"
		},
		"void sendKeyEvent(Event event)":{
			"methodBody":"{\n    if (editable == false) {\n        return;\n    }\n    modifyContent(event, true);\n}",
			"comments":"/**\n* Replaces/inserts text as defined by the event.\n* <p>\n*\n* @param event the text change event.\n*\t<ul>\n*\t<li>event.start - the replace start offset</li>\n* \t<li>event.end - the replace end offset</li>\n* \t<li>event.text - the new text</li>\n*\t</ul>\n*/\n",
			"methodName":"void sendKeyEvent(Event event)"
		},
		"void showCaret(int caretLine)":{
			"methodBody":"{\n    int lineOffset = content.getOffsetAtLine(caretLine);\n    String line = content.getLine(caretLine);\n    int offsetInLine = caretOffset - lineOffset;\n    int newCaretX = getXAtOffset(line, caretLine, offsetInLine);\n    boolean scrolled = showLocation(newCaretX, caretLine);\n    boolean setWrapCaretLocation = false;\n    Caret caret = getCaret();\n    if (wordWrap && caret != null) {\n        int caretY = caret.getLocation().y;\n        if ((caretY + verticalScrollOffset) / getVerticalIncrement() - 1 != caretLine) {\n            setWrapCaretLocation = true;\n        }\n    }\n    if (scrolled == false || setWrapCaretLocation) {\n        \n        \n        \n        \n        setCaretLocation(newCaretX, caretLine, getCaretDirection());\n    }\n}",
			"comments":"/**\n* Sets the caret location and scrolls the caret offset into view.\n*/\n// set the caret location if a scroll operation did not set it (as a\n// sideeffect of scrolling) or when in word wrap mode and the caret\n// line was explicitly specified (i.e., because getWrapCaretLine does\n// not return the desired line causing scrolling to not set it correctly)\n",
			"methodName":"void showCaret(int caretLine)"
		},
		"public Rectangle getTextBounds(int start, int end)":{
			"methodBody":"{\n    checkWidget();\n    int contentLength = getCharCount();\n    if (start < 0 || start >= contentLength || end < 0 || end >= contentLength || start > end) {\n        SWT.error(SWT.ERROR_INVALID_RANGE);\n    }\n    int lineStart = content.getLineAtOffset(start);\n    int lineEnd = content.getLineAtOffset(end);\n    Rectangle rect;\n    int y = lineStart * lineHeight;\n    int height = (lineEnd + 1) * lineHeight - y;\n    int left = 0x7fffffff, right = 0;\n    for (int i = lineStart; i <= lineEnd; i++) {\n        int lineOffset = content.getOffsetAtLine(i);\n        String line = content.getLine(i);\n        TextLayout layout = renderer.getTextLayout(line, lineOffset);\n        if (i == lineStart && i == lineEnd) {\n            rect = layout.getBounds(start - lineOffset, end - lineOffset);\n        } else if (i == lineStart) {\n            rect = layout.getBounds(start - lineOffset, line.length());\n        } else if (i == lineEnd) {\n            rect = layout.getBounds(0, end - lineOffset);\n        } else {\n            rect = layout.getLineBounds(0);\n        }\n        left = Math.min(left, rect.x);\n        right = Math.max(right, rect.x + rect.width);\n        renderer.disposeTextLayout(layout);\n    }\n    rect = new Rectangle(left, y, right - left, height);\n    rect.x += leftMargin - horizontalScrollOffset;\n    rect.y -= verticalScrollOffset;\n    return rect;\n}",
			"comments":"/**\n* Returns the smallest bounding rectangle that includes the characters between two offsets.\n* <p>\n*\n* @param start offset of the first character included in the bounding box\n* @param end offset of the last character included in the bounding box\n* @return bounding box of the text between start and end\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*   <li>ERROR_INVALID_RANGE when start and/or end are outside the widget content</li>\n* </ul>\n* @since 3.1\n*/\n",
			"methodName":"public Rectangle getTextBounds(int start, int end)"
		},
		"void doContent(char key)":{
			"methodBody":"{\n    Event event;\n    if (textLimit > 0 && content.getCharCount() - (selection.y - selection.x) >= textLimit) {\n        return;\n    }\n    event = new Event();\n    event.start = selection.x;\n    event.end = selection.y;\n    \n    if (key == SWT.CR || key == SWT.LF) {\n        if (isSingleLine() == false) {\n            event.text = getLineDelimiter();\n        }\n    } else if (selection.x == selection.y && overwrite == true && key != TAB) {\n        int lineIndex = content.getLineAtOffset(event.end);\n        int lineOffset = content.getOffsetAtLine(lineIndex);\n        String line = content.getLine(lineIndex);\n        \n        if (event.end < lineOffset + line.length()) {\n            event.end++;\n        }\n        event.text = new String(new char[] { key });\n    } else {\n        event.text = new String(new char[] { key });\n    }\n    if (event.text != null) {\n        sendKeyEvent(event);\n    }\n}",
			"comments":"/**\n* Replaces the selection with the character or insert the character at the\n* current caret position if no selection exists.\n* If a carriage return was typed replace it with the line break character\n* used by the widget on this platform.\n* <p>\n*\n* @param key the character typed by the user\n*/\n// replace a CR line break with the widget line break\n// CR does not make sense on Windows since most (all?) applications\n// don't recognize CR as a line break.\n// no selection and overwrite mode is on and the typed key is not a\n// tab character (tabs are always inserted without overwriting)?\n// replace character at caret offset if the caret is not at the\n// end of the line\n",
			"methodName":"void doContent(char key)"
		},
		"int getPartialBottomIndex()":{
			"methodBody":"{\n    int partialLineCount = Compatibility.ceil(getClientArea().height, lineHeight);\n    return Math.min(content.getLineCount(), topIndex + partialLineCount) - 1;\n}",
			"comments":"/**\n* Returns the index of the last partially visible line.\n*\n* @return index of the last partially visible line.\n*/\n",
			"methodName":"int getPartialBottomIndex()"
		},
		"public Color getBackground()":{
			"methodBody":"{\n    checkWidget();\n    if (background == null) {\n        return getDisplay().getSystemColor(SWT.COLOR_LIST_BACKGROUND);\n    }\n    return background;\n}",
			"comments":"",
			"methodName":"public Color getBackground()"
		},
		"void handleMouseDoubleClick(Event event)":{
			"methodBody":"{\n    if (event.button != 1 || doubleClickEnabled == false) {\n        return;\n    }\n    event.y -= topMargin;\n    mouseDoubleClick = true;\n    caretOffset = getWordStart(caretOffset);\n    resetSelection();\n    caretOffset = getWordEndNoSpaces(caretOffset);\n    showCaret();\n    doMouseSelection();\n    doubleClickSelection = new Point(selection.x, selection.y);\n}",
			"comments":"/**\n* Updates the caret location and selection if mouse button 1 has been\n* pressed.\n*/\n",
			"methodName":"void handleMouseDoubleClick(Event event)"
		},
		"void installDefaultLineStyler()":{
			"methodBody":"{\n    defaultLineStyler = new DefaultLineStyler(logicalContent);\n    StyledTextListener typedListener = new StyledTextListener(defaultLineStyler);\n    if (userLineStyle == false) {\n        addListener(LineGetStyle, typedListener);\n    }\n    if (userLineBackground == false) {\n        addListener(LineGetBackground, typedListener);\n    }\n}",
			"comments":"/**\n* Creates a default line style listener.\n* Used to store line background colors and styles.\n* Removed when the user sets a LineStyleListener.\n* <p>\n*\n* @see #addLineStyleListener\n*/\n",
			"methodName":"void installDefaultLineStyler()"
		},
		"void write(String string, int start, int end)":{
			"methodBody":"{\n    for (int index = start; index < end; index++) {\n        char ch = string.charAt(index);\n        if (ch > 0xFF && WriteUnicode) {\n            \n            if (index > start) {\n                write(string.substring(start, index));\n            }\n            write(\"\\\\u\");\n            write(Integer.toString((short) ch));\n            \n            write(' ');\n            start = index + 1;\n        } else if (ch == '}' || ch == '{' || ch == '\\\\') {\n            \n            if (index > start) {\n                write(string.substring(start, index));\n            }\n            write('\\\\');\n            write(ch);\n            start = index + 1;\n        }\n    }\n    \n    if (start < end) {\n        write(string.substring(start, end));\n    }\n}",
			"comments":"/**\n* Appends the specified segment of \"string\" to the RTF data.\n* Copy from <code>start</code> up to, but excluding, <code>end</code>.\n* <p>\n*\n* @param string string to copy a segment from. Must not contain\n* \tline breaks. Line breaks should be written using writeLineDelimiter()\n* @param start start offset of segment. 0 based.\n* @param end end offset of segment\n*/\n// write the sub string from the last escaped character\n// to the current one. Fixes bug 21698.\n// control word delimiter\n// write the sub string from the last escaped character\n// to the current one. Fixes bug 21698.\n// write from the last escaped character to the end.\n// Fixes bug 21698.\n",
			"methodName":"void write(String string, int start, int end)"
		},
		"void internalSetSelection(int start, int length, boolean sendEvent)":{
			"methodBody":"{\n    int end = start + length;\n    if (start > end) {\n        int temp = end;\n        end = start;\n        start = temp;\n    }\n    \n    if (selection.x != start || selection.y != end || (length > 0 && selectionAnchor != selection.x) || (length < 0 && selectionAnchor != selection.y)) {\n        clearSelection(sendEvent);\n        if (length < 0) {\n            selectionAnchor = selection.y = end;\n            caretOffset = selection.x = start;\n        } else {\n            selectionAnchor = selection.x = start;\n            caretOffset = selection.y = end;\n        }\n        internalRedrawRange(selection.x, selection.y - selection.x, true);\n    }\n}",
			"comments":"/**\n* Sets the selection.\n* The new selection may not be visible. Call showSelection to scroll\n* the selection into view.\n* <p>\n*\n* @param start offset of the first selected character, start >= 0 must be true.\n* @param length number of characters to select, 0 <= start + length\n* \t<= getCharCount() must be true.\n* \tA negative length places the caret at the selection start.\n* @param sendEvent a Selection event is sent when set to true and when\n* \tthe selection is reset.\n*/\n// is the selection range different or is the selection direction\n// different?\n",
			"methodName":"void internalSetSelection(int start, int length, boolean sendEvent)"
		},
		"static int checkStyle(int style)":{
			"methodBody":"{\n    if ((style & SWT.SINGLE) != 0) {\n        style &= ~(SWT.H_SCROLL | SWT.V_SCROLL | SWT.WRAP | SWT.MULTI);\n    } else {\n        style |= SWT.MULTI;\n        if ((style & SWT.WRAP) != 0) {\n            style &= ~SWT.H_SCROLL;\n        }\n    }\n    return style;\n}",
			"comments":"/**\n* Hides the scroll bars if widget is created in single line mode.\n*/\n",
			"methodName":"static int checkStyle(int style)"
		},
		"public void textChanged(int startOffset, int newLineCount, int replaceLineCount, int newCharCount, int replaceCharCount)":{
			"methodBody":"{\n    int startLine = visualContent.getLineAtOffset(startOffset);\n    visualContent.textChanged(startOffset, newLineCount, replaceLineCount, newCharCount, replaceCharCount);\n    \n    if (wordWrap) {\n        int lineCount = content.getLineCount();\n        if (startLine >= lineCount)\n            startLine = lineCount - 1;\n    }\n    if (startLine <= getPartialBottomIndex()) {\n        \n        \n        \n        parent.internalRedraw();\n    }\n}",
			"comments":"/**\n* Passes the text change notification to the line wrap content.\n* <p>\n*\n* @param startOffset\tthe start offset of the text change\n* @param newLineCount the number of inserted lines\n* @param replaceLineCount the number of deleted lines\n* @param newCharCount the number of new characters\n* @param replaceCharCount the number of deleted characters\n*/\n// if we are wrapping then it is possible for a deletion on the last\n// line of text to shorten the total text length by a line.  If this\n// occurs then the startIndex must be adjusted such that a redraw will\n// be performed if a visible region is affected.  fixes bug 42947.\n// only redraw if the text change affects text inside or above\n// the visible lines. if it is below the visible lines it will\n// not affect the word wrapping. fixes bug 14047.\n",
			"methodName":"public void textChanged(int startOffset, int newLineCount, int replaceLineCount, int newCharCount, int replaceCharCount)"
		},
		"public void close()":{
			"methodBody":"{\n    if (isClosed == false) {\n        isClosed = true;\n    }\n}",
			"comments":"/**\n* Closes the writer. Once closed no more content can be written.\n* <b>NOTE:</b>  <code>toString()</code> is not guaranteed to return a valid string unless\n* the writer is closed.\n*/\n",
			"methodName":"public void close()"
		},
		"public Point computeSize(int wHint, int hHint, boolean changed)":{
			"methodBody":"{\n    checkWidget();\n    int count, width, height;\n    boolean singleLine = (getStyle() & SWT.SINGLE) != 0;\n    if (singleLine) {\n        count = 1;\n    } else {\n        count = content.getLineCount();\n    }\n    if (wHint != SWT.DEFAULT) {\n        width = wHint;\n    } else {\n        width = DEFAULT_WIDTH;\n    }\n    if (wHint == SWT.DEFAULT) {\n        LineCache computeLineCache = lineCache;\n        if (wordWrap) {\n            \n            \n            computeLineCache = new ContentWidthCache(this, logicalContent);\n            if (singleLine == false) {\n                count = logicalContent.getLineCount();\n            }\n        }\n        \n        \n        \n        int visibleCount = Math.min(count, getDisplay().getBounds().height / lineHeight);\n        computeLineCache.calculate(0, visibleCount);\n        width = computeLineCache.getWidth() + leftMargin + rightMargin;\n    } else if (wordWrap && singleLine == false) {\n        \n        \n        WrappedContent wrappedContent = new WrappedContent(renderer, logicalContent);\n        wrappedContent.wrapLines(width);\n        count = wrappedContent.getLineCount();\n    }\n    if (hHint != SWT.DEFAULT) {\n        height = hHint;\n    } else {\n        height = count * lineHeight + topMargin + bottomMargin;\n    }\n    \n    if (width == 0) {\n        width = DEFAULT_WIDTH;\n    }\n    if (height == 0) {\n        if (singleLine) {\n            height = lineHeight;\n        } else {\n            height = DEFAULT_HEIGHT;\n        }\n    }\n    Rectangle rect = computeTrim(0, 0, width, height);\n    return new Point(rect.width, rect.height);\n}",
			"comments":"// set non-wrapping content width calculator. Ensures ideal line width\n// that does not required wrapping. Fixes bug 31195.\n// Only calculate what can actually be displayed.\n// Do this because measuring each text line is a\n// time-consuming process.\n// calculate to wrap to width hint. Fixes bug 20377.\n// don't wrap live content. Fixes bug 38344.\n// Use default values if no text is defined.\n",
			"methodName":"public Point computeSize(int wHint, int hHint, boolean changed)"
		},
		"void setCaretLocation()":{
			"methodBody":"{\n    int lineIndex = getCaretLine();\n    String line = content.getLine(lineIndex);\n    int lineOffset = content.getOffsetAtLine(lineIndex);\n    int offsetInLine = caretOffset - lineOffset;\n    int newCaretX = getXAtOffset(line, lineIndex, offsetInLine);\n    setCaretLocation(newCaretX, lineIndex, getCaretDirection());\n}",
			"comments":"/**\n* Moves the Caret to the current caret offset.\n*/\n",
			"methodName":"void setCaretLocation()"
		},
		"void sendModifyEvent(Event event)":{
			"methodBody":"{\n    Accessible accessible = getAccessible();\n    if (event.text.length() == 0) {\n        accessible.textChanged(ACC.TEXT_DELETE, event.start, event.end - event.start);\n    } else {\n        if (event.start == event.end) {\n            accessible.textChanged(ACC.TEXT_INSERT, event.start, event.text.length());\n        } else {\n            accessible.textChanged(ACC.TEXT_DELETE, event.start, event.end - event.start);\n            accessible.textChanged(ACC.TEXT_INSERT, event.start, event.text.length());\n        }\n    }\n    notifyListeners(SWT.Modify, event);\n}",
			"comments":"",
			"methodName":"void sendModifyEvent(Event event)"
		},
		"void writeHeader()":{
			"methodBody":"{\n    StringBuffer header = new StringBuffer();\n    FontData fontData = getFont().getFontData()[0];\n    header.append(\"{\\\\rtf1\\\\ansi\");\n    \n    \n    String cpg = System.getProperty(\"file.encoding\").toLowerCase();\n    if (cpg.startsWith(\"cp\") || cpg.startsWith(\"ms\")) {\n        cpg = cpg.substring(2, cpg.length());\n        header.append(\"\\\\ansicpg\");\n        header.append(cpg);\n    }\n    header.append(\"\\\\uc0\\\\deff0{\\\\fonttbl{\\\\f0\\\\fnil \");\n    header.append(fontData.getName());\n    header.append(\";}}\\n{\\\\colortbl\");\n    for (int i = 0; i < colorTable.size(); i++) {\n        Color color = (Color) colorTable.elementAt(i);\n        header.append(\"\\\\red\");\n        header.append(color.getRed());\n        header.append(\"\\\\green\");\n        header.append(color.getGreen());\n        header.append(\"\\\\blue\");\n        header.append(color.getBlue());\n        header.append(\";\");\n    }\n    \n    \n    header.append(\"}\\n{\\\\f0\\\\fs\");\n    \n    header.append(fontData.getHeight() * 2);\n    header.append(\" \");\n    write(header.toString(), 0);\n}",
			"comments":"/**\n* Writes the RTF header including font table and color table.\n*/\n// specify code page, necessary for copy to work in bidi\n// systems that don't support Unicode RTF.\n// some RTF readers ignore the deff0 font tag. Explicitly\n// set the font for the whole document to work around this.\n// font size is specified in half points\n",
			"methodName":"void writeHeader()"
		},
		"void doDeleteWordNext()":{
			"methodBody":"{\n    if (selection.x != selection.y) {\n        \n        \n        doDelete();\n    } else {\n        Event event = new Event();\n        event.text = \"\";\n        event.start = caretOffset;\n        event.end = getWordEnd(caretOffset);\n        sendKeyEvent(event);\n    }\n}",
			"comments":"/**\n* Deletes the next word.\n*/\n// if a selection exists, treat the as if\n// only the delete key was pressed\n",
			"methodName":"void doDeleteWordNext()"
		},
		"int internalGetHorizontalPixel()":{
			"methodBody":"{\n    return horizontalScrollOffset;\n}",
			"comments":"",
			"methodName":"int internalGetHorizontalPixel()"
		},
		"void internalRedrawRange(int start, int length, boolean clearBackground)":{
			"methodBody":"{\n    int end = start + length;\n    int firstLine = content.getLineAtOffset(start);\n    int lastLine = content.getLineAtOffset(end);\n    int offsetInFirstLine;\n    int partialBottomIndex = getPartialBottomIndex();\n    int partialTopIndex = verticalScrollOffset / lineHeight;\n    \n    if (firstLine > partialBottomIndex || lastLine < partialTopIndex) {\n        return;\n    }\n    \n    if (partialTopIndex > firstLine) {\n        firstLine = partialTopIndex;\n        offsetInFirstLine = 0;\n    } else {\n        offsetInFirstLine = start - content.getOffsetAtLine(firstLine);\n    }\n    if (partialBottomIndex + 1 < lastLine) {\n        \n        lastLine = partialBottomIndex + 1;\n        end = content.getOffsetAtLine(lastLine);\n    }\n    redrawLines(firstLine, offsetInFirstLine, lastLine, end, clearBackground);\n    \n    if (lastLine - firstLine > 1) {\n        Rectangle clientArea = getClientArea();\n        int redrawStopY = lastLine * lineHeight - verticalScrollOffset;\n        int redrawY = (firstLine + 1) * lineHeight - verticalScrollOffset;\n        draw(0, redrawY, clientArea.width, redrawStopY - redrawY, clearBackground);\n    }\n}",
			"comments":"/**\n* Redraws the specified text range.\n* <p>\n*\n* @param start offset of the first character to redraw\n* @param length number of characters to redraw\n* @param clearBackground true if the background should be cleared as\n* \tpart of the redraw operation.  If true, the entire redraw range will\n*  be cleared before anything is redrawn.  If the redraw range includes\n*\tthe last character of a line (i.e., the entire line is redrawn) the\n* \tline is cleared all the way to the right border of the widget.\n*  The redraw operation will be faster and smoother if clearBackground is\n* \tset to false.  Whether or not the flag can be set to false depends on\n* \tthe type of change that has taken place.  If font styles or background\n* \tcolors for the redraw range have changed, clearBackground should be\n* \tset to true.  If only foreground colors have changed for the redraw\n* \trange, clearBackground can be set to false.\n*/\n// do nothing if redraw range is completely invisible\n// only redraw visible lines\n// + 1 to redraw whole bottom line, including line break\n// redraw entire center lines if redraw range includes more than two lines\n",
			"methodName":"void internalRedrawRange(int start, int length, boolean clearBackground)"
		},
		"void scrollHorizontal(int pixels)":{
			"methodBody":"{\n    Rectangle clientArea;\n    if (pixels == 0) {\n        return;\n    }\n    clientArea = getClientArea();\n    if (pixels > 0) {\n        int sourceX = leftMargin + pixels;\n        int scrollWidth = clientArea.width - sourceX - rightMargin;\n        int scrollHeight = clientArea.height - topMargin - bottomMargin;\n        scroll(\n        leftMargin, \n        topMargin, \n        sourceX, \n        topMargin, scrollWidth, scrollHeight, true);\n        if (sourceX > scrollWidth) {\n            \n            \n            super.redraw(leftMargin + scrollWidth, topMargin, pixels - scrollWidth, scrollHeight, true);\n        }\n    } else {\n        int destinationX = leftMargin - pixels;\n        int scrollWidth = clientArea.width - destinationX - rightMargin;\n        int scrollHeight = clientArea.height - topMargin - bottomMargin;\n        scroll(\n        destinationX, \n        topMargin, \n        leftMargin, \n        topMargin, scrollWidth, scrollHeight, true);\n        if (destinationX > scrollWidth) {\n            \n            \n            super.redraw(leftMargin + scrollWidth, topMargin, -pixels - scrollWidth, scrollHeight, true);\n        }\n    }\n    horizontalScrollOffset += pixels;\n    int oldColumnX = columnX - pixels;\n    setCaretLocation();\n    \n    columnX = oldColumnX;\n}",
			"comments":"/**\n* Scrolls the widget horizontally.\n* <p>\n*\n* @param pixels number of pixels to scroll, > 0 = scroll left,\n* \t< 0 scroll right\n*/\n// destination x, y\n// source x, y\n// redraw from end of scrolled area to beginning of scroll\n// invalidated area\n// destination x, y\n// source x, y\n// redraw from end of scroll invalidated area to scroll\n// destination\n// restore the original horizontal caret index\n",
			"methodName":"void scrollHorizontal(int pixels)"
		},
		"void calculateVisible(int startLine, int newLineCount)":{
			"methodBody":"{\n    int topIndex = parent.getTopIndex();\n    int bottomLine = Math.min(getPartialBottomIndex(), startLine + newLineCount);\n    startLine = Math.max(startLine, topIndex);\n    calculate(startLine, bottomLine - startLine + 1);\n}",
			"comments":"/**\n* Calculates the width of the visible lines in the specified\n* range.\n* <p>\n*\n* @param startLine\tthe first changed line\n* @param newLineCount the number of inserted lines\n*/\n",
			"methodName":"void calculateVisible(int startLine, int newLineCount)"
		},
		"void doContentEnd()":{
			"methodBody":"{\n    \n    if (isSingleLine()) {\n        doLineEnd();\n    } else {\n        int length = content.getCharCount();\n        if (caretOffset < length) {\n            caretOffset = length;\n            showCaret();\n        }\n    }\n}",
			"comments":"/**\n* Moves the caret after the last character of the widget content.\n*/\n// place caret at end of first line if receiver is in single\n// line mode. fixes 4820.\n",
			"methodName":"void doContentEnd()"
		},
		"void sendSelectionEvent()":{
			"methodBody":"{\n    getAccessible().textSelectionChanged();\n    Event event = new Event();\n    event.x = selection.x;\n    event.y = selection.y;\n    notifyListeners(SWT.Selection, event);\n}",
			"comments":"/**\n* Sends the specified selection event.\n*/\n",
			"methodName":"void sendSelectionEvent()"
		},
		"public void setSelection(int start)":{
			"methodBody":"{\n    \n    setSelection(start, start);\n}",
			"comments":"/**\n* Sets the selection to the given position and scrolls it into view.  Equivalent to setSelection(start,start).\n* <p>\n*\n* @param start new caret position\n* @see #setSelection(int,int)\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*   <li>ERROR_INVALID_ARGUMENT when either the start or the end of the selection range is inside a\n* multi byte line delimiter (and thus neither clearly in front of or after the line delimiter)\n* </ul>\n*/\n// checkWidget test done in setSelectionRange\n",
			"methodName":"public void setSelection(int start)"
		},
		"void setUnicode()":{
			"methodBody":"{\n    final String Win95 = \"windows 95\";\n    final String Win98 = \"windows 98\";\n    final String WinME = \"windows me\";\n    final String WinNT = \"windows nt\";\n    String osName = System.getProperty(\"os.name\").toLowerCase();\n    String osVersion = System.getProperty(\"os.version\");\n    int majorVersion = 0;\n    if (osName.startsWith(WinNT) && osVersion != null) {\n        int majorIndex = osVersion.indexOf('.');\n        if (majorIndex != -1) {\n            osVersion = osVersion.substring(0, majorIndex);\n            try {\n                majorVersion = Integer.parseInt(osVersion);\n            } catch (NumberFormatException exception) {\n            \n            \n            }\n        }\n    }\n    if (osName.startsWith(Win95) == false && osName.startsWith(Win98) == false && osName.startsWith(WinME) == false && (osName.startsWith(WinNT) == false || majorVersion > 4)) {\n        WriteUnicode = true;\n    } else {\n        WriteUnicode = false;\n    }\n}",
			"comments":"/**\n* Determines if Unicode RTF should be written.\n* Don't write Unicode RTF on Windows 95/98/ME or NT.\n*/\n// ignore exception. version number remains unknown.\n// will write without Unicode\n",
			"methodName":"void setUnicode()"
		},
		"void modifyContent(Event event, boolean updateCaret)":{
			"methodBody":"{\n    event.doit = true;\n    notifyListeners(SWT.Verify, event);\n    if (event.doit) {\n        StyledTextEvent styledTextEvent = null;\n        int replacedLength = event.end - event.start;\n        if (isListening(ExtendedModify)) {\n            styledTextEvent = new StyledTextEvent(logicalContent);\n            styledTextEvent.start = event.start;\n            styledTextEvent.end = event.start + event.text.length();\n            styledTextEvent.text = content.getTextRange(event.start, replacedLength);\n        }\n        if (updateCaret) {\n            \n            if (event.text.length() == 0) {\n                int lineIndex = content.getLineAtOffset(event.start);\n                int lineOffset = content.getOffsetAtLine(lineIndex);\n                String lineText = content.getLine(lineIndex);\n                TextLayout layout = renderer.getTextLayout(lineText, lineOffset);\n                int levelStart = layout.getLevel(event.start - lineOffset);\n                int lineIndexEnd = content.getLineAtOffset(event.end);\n                if (lineIndex != lineIndexEnd) {\n                    renderer.disposeTextLayout(layout);\n                    lineOffset = content.getOffsetAtLine(lineIndexEnd);\n                    lineText = content.getLine(lineIndexEnd);\n                    layout = renderer.getTextLayout(lineText, lineOffset);\n                }\n                int levelEnd = layout.getLevel(event.end - lineOffset);\n                renderer.disposeTextLayout(layout);\n                advancing = levelStart != levelEnd;\n            }\n        }\n        content.replaceTextRange(event.start, replacedLength, event.text);\n        \n        if (updateCaret) {\n            \n            internalSetSelection(event.start + event.text.length(), 0, true);\n            showCaret();\n        }\n        sendModifyEvent(event);\n        if (isListening(ExtendedModify)) {\n            notifyListeners(ExtendedModify, styledTextEvent);\n        }\n    }\n}",
			"comments":"/**\n* Sends the specified verify event, replace/insert text as defined by\n* the event and send a modify event.\n* <p>\n*\n* @param event\tthe text change event.\n*\t<ul>\n*\t<li>event.start - the replace start offset</li>\n* \t<li>event.end - the replace end offset</li>\n* \t<li>event.text - the new text</li>\n*\t</ul>\n* @param updateCaret whether or not he caret should be set behind\n*\tthe new text\n*/\n//Fix advancing flag for delete/backspace key on direction boundary\n// set the caret position prior to sending the modify event.\n// fixes 1GBB8NJ\n// always update the caret location. fixes 1G8FODP\n",
			"methodName":"void modifyContent(Event event, boolean updateCaret)"
		},
		"void createKeyBindings()":{
			"methodBody":"{\n    \n    setKeyBinding(SWT.ARROW_UP, ST.LINE_UP);\n    setKeyBinding(SWT.ARROW_DOWN, ST.LINE_DOWN);\n    setKeyBinding(SWT.HOME, ST.LINE_START);\n    setKeyBinding(SWT.END, ST.LINE_END);\n    setKeyBinding(SWT.PAGE_UP, ST.PAGE_UP);\n    setKeyBinding(SWT.PAGE_DOWN, ST.PAGE_DOWN);\n    setKeyBinding(SWT.HOME | SWT.MOD1, ST.TEXT_START);\n    setKeyBinding(SWT.END | SWT.MOD1, ST.TEXT_END);\n    setKeyBinding(SWT.PAGE_UP | SWT.MOD1, ST.WINDOW_START);\n    setKeyBinding(SWT.PAGE_DOWN | SWT.MOD1, ST.WINDOW_END);\n    if (isMirrored()) {\n        setKeyBinding(SWT.ARROW_LEFT, ST.COLUMN_NEXT);\n        setKeyBinding(SWT.ARROW_RIGHT, ST.COLUMN_PREVIOUS);\n        setKeyBinding(SWT.ARROW_LEFT | SWT.MOD1, ST.WORD_NEXT);\n        setKeyBinding(SWT.ARROW_RIGHT | SWT.MOD1, ST.WORD_PREVIOUS);\n    } else {\n        setKeyBinding(SWT.ARROW_LEFT, ST.COLUMN_PREVIOUS);\n        setKeyBinding(SWT.ARROW_RIGHT, ST.COLUMN_NEXT);\n        setKeyBinding(SWT.ARROW_LEFT | SWT.MOD1, ST.WORD_PREVIOUS);\n        setKeyBinding(SWT.ARROW_RIGHT | SWT.MOD1, ST.WORD_NEXT);\n    }\n    \n    setKeyBinding(SWT.ARROW_UP | SWT.MOD2, ST.SELECT_LINE_UP);\n    setKeyBinding(SWT.ARROW_DOWN | SWT.MOD2, ST.SELECT_LINE_DOWN);\n    setKeyBinding(SWT.HOME | SWT.MOD2, ST.SELECT_LINE_START);\n    setKeyBinding(SWT.END | SWT.MOD2, ST.SELECT_LINE_END);\n    setKeyBinding(SWT.PAGE_UP | SWT.MOD2, ST.SELECT_PAGE_UP);\n    setKeyBinding(SWT.PAGE_DOWN | SWT.MOD2, ST.SELECT_PAGE_DOWN);\n    setKeyBinding(SWT.HOME | SWT.MOD1 | SWT.MOD2, ST.SELECT_TEXT_START);\n    setKeyBinding(SWT.END | SWT.MOD1 | SWT.MOD2, ST.SELECT_TEXT_END);\n    setKeyBinding(SWT.PAGE_UP | SWT.MOD1 | SWT.MOD2, ST.SELECT_WINDOW_START);\n    setKeyBinding(SWT.PAGE_DOWN | SWT.MOD1 | SWT.MOD2, ST.SELECT_WINDOW_END);\n    if (isMirrored()) {\n        setKeyBinding(SWT.ARROW_LEFT | SWT.MOD2, ST.SELECT_COLUMN_NEXT);\n        setKeyBinding(SWT.ARROW_RIGHT | SWT.MOD2, ST.SELECT_COLUMN_PREVIOUS);\n        setKeyBinding(SWT.ARROW_LEFT | SWT.MOD1 | SWT.MOD2, ST.SELECT_WORD_NEXT);\n        setKeyBinding(SWT.ARROW_RIGHT | SWT.MOD1 | SWT.MOD2, ST.SELECT_WORD_PREVIOUS);\n    } else {\n        setKeyBinding(SWT.ARROW_LEFT | SWT.MOD2, ST.SELECT_COLUMN_PREVIOUS);\n        setKeyBinding(SWT.ARROW_RIGHT | SWT.MOD2, ST.SELECT_COLUMN_NEXT);\n        setKeyBinding(SWT.ARROW_LEFT | SWT.MOD1 | SWT.MOD2, ST.SELECT_WORD_PREVIOUS);\n        setKeyBinding(SWT.ARROW_RIGHT | SWT.MOD1 | SWT.MOD2, ST.SELECT_WORD_NEXT);\n    }\n    \n    \n    setKeyBinding('X' | SWT.MOD1, ST.CUT);\n    setKeyBinding('C' | SWT.MOD1, ST.COPY);\n    setKeyBinding('V' | SWT.MOD1, ST.PASTE);\n    \n    setKeyBinding(SWT.DEL | SWT.MOD2, ST.CUT);\n    setKeyBinding(SWT.INSERT | SWT.MOD1, ST.COPY);\n    setKeyBinding(SWT.INSERT | SWT.MOD2, ST.PASTE);\n    setKeyBinding(SWT.BS | SWT.MOD2, ST.DELETE_PREVIOUS);\n    setKeyBinding(SWT.BS, ST.DELETE_PREVIOUS);\n    setKeyBinding(SWT.DEL, ST.DELETE_NEXT);\n    setKeyBinding(SWT.BS | SWT.MOD1, ST.DELETE_WORD_PREVIOUS);\n    setKeyBinding(SWT.DEL | SWT.MOD1, ST.DELETE_WORD_NEXT);\n    \n    setKeyBinding(SWT.INSERT, ST.TOGGLE_OVERWRITE);\n}",
			"comments":"/**\n* Creates default key bindings.\n*/\n// Navigation\n// Selection\n// Modification\n// Cut, Copy, Paste\n// Cut, Copy, Paste Wordstar style\n// Miscellaneous\n",
			"methodName":"void createKeyBindings()"
		},
		"boolean isLineDelimiter(int offset)":{
			"methodBody":"{\n    int line = content.getLineAtOffset(offset);\n    int lineOffset = content.getOffsetAtLine(line);\n    int offsetInLine = offset - lineOffset;\n    \n    return offsetInLine > content.getLine(line).length();\n}",
			"comments":"/**\n* Returns whether the given offset is inside a multi byte line delimiter.\n* Example:\n* \"Line1\\r\\n\" isLineDelimiter(5) == false but isLineDelimiter(6) == true\n*\n* @return true if the given offset is inside a multi byte line delimiter.\n* false if the given offset is before or after a line delimiter.\n*/\n// offsetInLine will be greater than line length if the line\n// delimiter is longer than one character and the offset is set\n// in between parts of the line delimiter.\n",
			"methodName":"boolean isLineDelimiter(int offset)"
		},
		"public void replaceStyleRanges(int start, int length, StyleRange[] ranges)":{
			"methodBody":"{\n    checkWidget();\n    if (userLineStyle) {\n        return;\n    }\n    if (ranges == null) {\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    }\n    if (ranges.length == 0) {\n        setStyleRange(new StyleRange(start, length, null, null));\n        return;\n    }\n    int end = start + length;\n    if (start > end || start < 0 || end > getCharCount()) {\n        SWT.error(SWT.ERROR_INVALID_RANGE);\n    }\n    int firstLine = content.getLineAtOffset(start);\n    int lastLine = content.getLineAtOffset(end);\n    defaultLineStyler.replaceStyleRanges(start, length, ranges);\n    lineCache.reset(firstLine, lastLine - firstLine + 1, true);\n    \n    if (isAreaVisible(firstLine, lastLine)) {\n        int redrawY = firstLine * lineHeight - verticalScrollOffset;\n        int redrawStopY = (lastLine + 1) * lineHeight - verticalScrollOffset;\n        draw(0, redrawY, getClientArea().width, redrawStopY - redrawY, true);\n    }\n    \n    \n    \n    setCaretLocation();\n}",
			"comments":"/**\n* Replaces the styles in the given range with new styles.  This method\n* effectively deletes the styles in the given range and then adds the\n* the new styles.\n* <p>\n* Should not be called if a LineStyleListener has been set since the\n* listener maintains the styles.\n* </p>\n*\n* @param start offset of first character where styles will be deleted\n* @param length length of the range to delete styles in\n* @param ranges StyleRange objects containing the new style information.\n* The ranges should not overlap and should be within the specified start\n* and length. The style rendering is undefined if the ranges do overlap\n* or are ill-defined. Must not be null.\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*   <li>ERROR_INVALID_RANGE when either start or end is outside the valid range (0 <= offset <= getCharCount())</li>\n*   <li>ERROR_NULL_ARGUMENT when string is null</li>\n* </ul>\n* @since 2.0\n*/\n// if the area is not visible, there is no need to redraw\n// make sure that the caret is positioned correctly.\n// caret location may change if font style changes.\n// fixes 1G8FODP\n",
			"methodName":"public void replaceStyleRanges(int start, int length, StyleRange[] ranges)"
		},
		"void cacheLineData(StyledTextContent printerContent)":{
			"methodBody":"{\n    for (int i = 0; i < printerContent.getLineCount(); i++) {\n        int lineOffset = printerContent.getOffsetAtLine(i);\n        String line = printerContent.getLine(i);\n        if (printOptions.printLineBackground) {\n            cacheLineBackground(lineOffset, line);\n        }\n        if (printOptions.printTextBackground || printOptions.printTextForeground || printOptions.printTextFontStyle) {\n            cacheLineStyle(lineOffset, line);\n        }\n        if (parent.isBidi()) {\n            cacheBidiSegments(lineOffset, line);\n        }\n    }\n}",
			"comments":"/**\n* Caches all line data that needs to be requested from a listener.\n* </p>\n* @param printerContent <class>StyledTextContent</class> to request\n* \tline data for.\n*/\n",
			"methodName":"void cacheLineData(StyledTextContent printerContent)"
		},
		"void calculateTopIndex()":{
			"methodBody":"{\n    int oldTopIndex = topIndex;\n    int verticalIncrement = getVerticalIncrement();\n    int clientAreaHeight = getClientArea().height;\n    if (verticalIncrement == 0) {\n        return;\n    }\n    topIndex = Compatibility.ceil(verticalScrollOffset, verticalIncrement);\n    \n    if (topIndex > 0) {\n        if (clientAreaHeight > 0) {\n            int bottomPixel = verticalScrollOffset + clientAreaHeight;\n            int fullLineTopPixel = topIndex * verticalIncrement;\n            int fullLineVisibleHeight = bottomPixel - fullLineTopPixel;\n            \n            if (fullLineVisibleHeight < verticalIncrement) {\n                topIndex--;\n            }\n        } else if (topIndex >= content.getLineCount()) {\n            topIndex = content.getLineCount() - 1;\n        }\n    }\n    if (topIndex != oldTopIndex) {\n        topOffset = content.getOffsetAtLine(topIndex);\n        lineCache.calculate(topIndex, getPartialBottomIndex() - topIndex + 1);\n        setHorizontalScrollBar();\n    }\n}",
			"comments":"/**\n* Calculates the top index based on the current vertical scroll offset.\n* The top index is the index of the topmost fully visible line or the\n* topmost partially visible line if no line is fully visible.\n* The top index starts at 0.\n*/\n// Set top index to partially visible top line if no line is fully\n// visible but at least some of the widget client area is visible.\n// Fixes bug 15088.\n// set top index to partially visible line if no line fully fits in\n// client area or if space is available but not used (the latter should\n// never happen because we use claimBottomFreeSpace)\n",
			"methodName":"void calculateTopIndex()"
		},
		"void redrawLines(int firstLine, int offsetInFirstLine, int lastLine, int endOffset, boolean clearBackground)":{
			"methodBody":"{\n    String line = content.getLine(firstLine);\n    int lineCount = lastLine - firstLine + 1;\n    int redrawY, redrawWidth;\n    int lineOffset = content.getOffsetAtLine(firstLine);\n    boolean fullLineRedraw;\n    Rectangle clientArea = getClientArea();\n    fullLineRedraw = ((getStyle() & SWT.FULL_SELECTION) != 0 && lastLine > firstLine);\n    \n    if (clearBackground && endOffset - lineOffset >= line.length()) {\n        fullLineRedraw = true;\n    }\n    TextLayout layout = renderer.getTextLayout(line, lineOffset);\n    Rectangle rect = layout.getBounds(offsetInFirstLine, Math.min(endOffset, line.length()) - 1);\n    renderer.disposeTextLayout(layout);\n    rect.x -= horizontalScrollOffset;\n    rect.intersect(clientArea);\n    redrawY = firstLine * lineHeight - verticalScrollOffset;\n    redrawWidth = fullLineRedraw ? clientArea.width - leftMargin - rightMargin : rect.width;\n    draw(rect.x, redrawY, redrawWidth, lineHeight, clearBackground);\n    \n    if (lineCount > 1) {\n        lineOffset = content.getOffsetAtLine(lastLine);\n        int offsetInLastLine = endOffset - lineOffset;\n        \n        if (offsetInLastLine > 0) {\n            line = content.getLine(lastLine);\n            \n            if (clearBackground && offsetInLastLine >= line.length()) {\n                fullLineRedraw = true;\n            }\n            line = content.getLine(lastLine);\n            layout = renderer.getTextLayout(line, lineOffset);\n            rect = layout.getBounds(0, offsetInLastLine - 1);\n            renderer.disposeTextLayout(layout);\n            rect.x -= horizontalScrollOffset;\n            rect.intersect(clientArea);\n            redrawY = lastLine * lineHeight - verticalScrollOffset;\n            redrawWidth = fullLineRedraw ? clientArea.width - leftMargin - rightMargin : rect.width;\n            draw(rect.x, redrawY, redrawWidth, lineHeight, clearBackground);\n        }\n    }\n}",
			"comments":"/**\n* Redraws a text range in the specified lines\n* <p>\n*\n* @param firstLine first line to redraw at the specified offset\n* @param offsetInFirstLine offset in firstLine to start redrawing\n* @param lastLine last line to redraw\n* @param endOffset offset in the last where redrawing should stop\n* @param clearBackground true=clear the background by invalidating\n*  the requested redraw range. If the redraw range includes the\n* \tlast character of a line (i.e., the entire line is redrawn) the\n* \tline is cleared all the way to the right border of the widget.\n*  false=draw the foreground directly without invalidating the\n* \tredraw range.\n*/\n// if redraw range includes last character on the first line,\n// clear background to right widget border. fixes bug 19595.\n// redraw last line if more than one line needs redrawing\n// no redraw necessary if redraw offset is 0\n// if redraw range includes last character on the last line,\n// clear background to right widget border. fixes bug 19595.\n",
			"methodName":"void redrawLines(int firstLine, int offsetInFirstLine, int lastLine, int endOffset, boolean clearBackground)"
		},
		"void reset()":{
			"methodBody":"{\n    ScrollBar verticalBar = getVerticalBar();\n    ScrollBar horizontalBar = getHorizontalBar();\n    caretOffset = 0;\n    topIndex = 0;\n    topOffset = 0;\n    verticalScrollOffset = 0;\n    horizontalScrollOffset = 0;\n    resetSelection();\n    \n    if (defaultLineStyler != null) {\n        removeLineBackgroundListener(defaultLineStyler);\n        removeLineStyleListener(defaultLineStyler);\n        installDefaultLineStyler();\n    }\n    calculateContentWidth();\n    if (verticalBar != null) {\n        verticalBar.setSelection(0);\n    }\n    if (horizontalBar != null) {\n        horizontalBar.setSelection(0);\n    }\n    setScrollBars();\n    setCaretLocation();\n    super.redraw();\n}",
			"comments":"/**\n* Resets the caret position, selection and scroll offsets. Recalculate\n* the content width and scroll bars. Redraw the widget.\n*/\n// discard any styles that may have been set by creating a\n// new default line styler\n",
			"methodName":"void reset()"
		},
		"void doCursorPrevious()":{
			"methodBody":"{\n    advancing = false;\n    if (selection.y - selection.x > 0) {\n        int caretLine;\n        caretOffset = selection.x;\n        caretLine = getCaretLine();\n        showCaret(caretLine);\n    } else {\n        doSelectionCursorPrevious();\n    }\n}",
			"comments":"/**\n* Moves the caret to the start of the selection if a selection exists.\n* Otherwise, if no selection exists move the cursor according to the\n* cursor selection rules.\n* <p>\n*\n* @see #doSelectionCursorPrevious\n*/\n",
			"methodName":"void doCursorPrevious()"
		},
		"public boolean getBidiColoring()":{
			"methodBody":"{\n    checkWidget();\n    return bidiColoring;\n}",
			"comments":"/**\n* Gets the BIDI coloring mode.  When true the BIDI text display\n* algorithm is applied to segments of text that are the same\n* color.\n*\n* @return the current coloring mode\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* <p>\n* @deprecated use BidiSegmentListener instead.\n* </p>\n*/\n",
			"methodName":"public boolean getBidiColoring()"
		},
		"int getColorIndex(Color color, int defaultIndex)":{
			"methodBody":"{\n    int index;\n    if (color == null) {\n        index = defaultIndex;\n    } else {\n        index = colorTable.indexOf(color);\n        if (index == -1) {\n            index = colorTable.size();\n            colorTable.addElement(color);\n        }\n    }\n    return index;\n}",
			"comments":"/**\n* Returns the index of the specified color in the RTF color table.\n* <p>\n*\n* @param color the color\n* @param defaultIndex return value if color is null\n* @return the index of the specified color in the RTF color table\n* \tor \"defaultIndex\" if \"color\" is null.\n*/\n",
			"methodName":"int getColorIndex(Color color, int defaultIndex)"
		},
		"public Point getSelection()":{
			"methodBody":"{\n    checkWidget();\n    return new Point(selection.x, selection.y);\n}",
			"comments":"/**\n* Returns the selection.\n* <p>\n* Text selections are specified in terms of caret positions.  In a text\n* widget that contains N characters, there are N+1 caret positions,\n* ranging from 0..N\n* <p>\n*\n* @return start and end of the selection, x is the offset of the first\n* \tselected character, y is the offset after the last selected character.\n*  The selection values returned are visual (i.e., x will always always be\n*  <= y).  To determine if a selection is right-to-left (RtoL) vs. left-to-right\n*  (LtoR), compare the caretOffset to the start and end of the selection\n*  (e.g., caretOffset == start of selection implies that the selection is RtoL).\n* @see #getSelectionRange\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Point getSelection()"
		},
		"void write(int i)":{
			"methodBody":"{\n    buffer.append(i);\n}",
			"comments":"/**\n* Appends the given int to the data.\n*/\n",
			"methodName":"void write(int i)"
		},
		"public void setWordWrap(boolean wrap)":{
			"methodBody":"{\n    checkWidget();\n    if ((getStyle() & SWT.SINGLE) != 0)\n        return;\n    if (wrap != wordWrap) {\n        ScrollBar horizontalBar = getHorizontalBar();\n        wordWrap = wrap;\n        if (wordWrap) {\n            logicalContent = content;\n            content = new WrappedContent(renderer, logicalContent);\n        } else {\n            content = logicalContent;\n        }\n        calculateContentWidth();\n        horizontalScrollOffset = 0;\n        if (horizontalBar != null) {\n            horizontalBar.setVisible(!wordWrap);\n        }\n        setScrollBars();\n        setCaretLocation();\n        super.redraw();\n    }\n}",
			"comments":"/**\n* Sets whether the widget wraps lines.\n* This overrides the creation style bit SWT.WRAP.\n* <p>\n*\n* @param wrap true=widget wraps lines, false=widget does not wrap lines\n* @since 2.0\n*/\n",
			"methodName":"public void setWordWrap(boolean wrap)"
		},
		"void setCaretLocation(int newCaretX, int line, int direction)":{
			"methodBody":"{\n    Caret caret = getCaret();\n    if (caret != null) {\n        boolean updateImage = caret == defaultCaret;\n        int imageDirection = direction;\n        if (isMirrored()) {\n            if (imageDirection == SWT.LEFT) {\n                imageDirection = SWT.RIGHT;\n            } else if (imageDirection == SWT.RIGHT) {\n                imageDirection = SWT.LEFT;\n            }\n        }\n        if (updateImage && imageDirection == SWT.RIGHT) {\n            newCaretX -= (caret.getSize().x - 1);\n        }\n        int newCaretY = line * lineHeight - verticalScrollOffset + topMargin;\n        caret.setLocation(newCaretX, newCaretY);\n        getAccessible().textCaretMoved(getCaretOffset());\n        if (direction != caretDirection) {\n            caretDirection = direction;\n            if (updateImage) {\n                if (imageDirection == SWT.DEFAULT) {\n                    defaultCaret.setImage(null);\n                } else if (imageDirection == SWT.LEFT) {\n                    defaultCaret.setImage(leftCaretBitmap);\n                } else if (imageDirection == SWT.RIGHT) {\n                    defaultCaret.setImage(rightCaretBitmap);\n                }\n            }\n            caret.setSize(caret.getSize().x, lineHeight);\n            if (caretDirection == SWT.LEFT) {\n                BidiUtil.setKeyboardLanguage(BidiUtil.KEYBOARD_NON_BIDI);\n            } else if (caretDirection == SWT.RIGHT) {\n                BidiUtil.setKeyboardLanguage(BidiUtil.KEYBOARD_BIDI);\n            }\n        }\n    }\n    columnX = newCaretX;\n}",
			"comments":"",
			"methodName":"void setCaretLocation(int newCaretX, int line, int direction)"
		},
		"public void setOrientation(int orientation)":{
			"methodBody":"{\n    if ((orientation & (SWT.RIGHT_TO_LEFT | SWT.LEFT_TO_RIGHT)) == 0) {\n        return;\n    }\n    if ((orientation & SWT.RIGHT_TO_LEFT) != 0 && (orientation & SWT.LEFT_TO_RIGHT) != 0) {\n        return;\n    }\n    if ((orientation & SWT.RIGHT_TO_LEFT) != 0 && isMirrored()) {\n        return;\n    }\n    if ((orientation & SWT.LEFT_TO_RIGHT) != 0 && isMirrored() == false) {\n        return;\n    }\n    if (BidiUtil.setOrientation(handle, orientation) == false) {\n        return;\n    }\n    isMirrored = (orientation & SWT.RIGHT_TO_LEFT) != 0;\n    initializeRenderer();\n    caretDirection = SWT.NULL;\n    setCaretLocation();\n    keyActionMap.clear();\n    createKeyBindings();\n    super.redraw();\n}",
			"comments":"/**\n* Sets the orientation of the receiver, which must be one\n* of the constants <code>SWT.LEFT_TO_RIGHT</code> or <code>SWT.RIGHT_TO_LEFT</code>.\n* <p>\n*\n* @param orientation new orientation style\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 2.1.2\n*/\n",
			"methodName":"public void setOrientation(int orientation)"
		},
		"void clearSelection(boolean sendEvent)":{
			"methodBody":"{\n    int selectionStart = selection.x;\n    int selectionEnd = selection.y;\n    int length = content.getCharCount();\n    resetSelection();\n    \n    if (selectionEnd - selectionStart > 0) {\n        \n        \n        int redrawStart = Math.min(selectionStart, length);\n        int redrawEnd = Math.min(selectionEnd, length);\n        if (redrawEnd - redrawStart > 0) {\n            internalRedrawRange(redrawStart, redrawEnd - redrawStart, true);\n        }\n        if (sendEvent == true) {\n            sendSelectionEvent();\n        }\n    }\n}",
			"comments":"/**\n* Removes the widget selection.\n* <p>\n*\n* @param sendEvent a Selection event is sent when set to true and when the selection is actually reset.\n*/\n// redraw old selection, if any\n// called internally to remove selection after text is removed\n// therefore make sure redraw range is valid.\n",
			"methodName":"void clearSelection(boolean sendEvent)"
		},
		"void claimRightFreeSpace()":{
			"methodBody":"{\n    int newHorizontalOffset = Math.max(0, lineCache.getWidth() - (getClientArea().width - leftMargin - rightMargin));\n    if (newHorizontalOffset < horizontalScrollOffset) {\n        \n        \n        \n        scrollHorizontalBar(newHorizontalOffset - horizontalScrollOffset);\n    }\n}",
			"comments":"/**\n* Scrolls text to the right to use new space made available by a resize.\n*/\n// item is no longer drawn past the right border of the client area\n// align the right end of the item with the right border of the\n// client area (window is scrolled right).\n",
			"methodName":"void claimRightFreeSpace()"
		},
		"void dispose()":{
			"methodBody":"{\n    if (printerColors != null) {\n        Enumeration colors = printerColors.elements();\n        while (colors.hasMoreElements()) {\n            Color color = (Color) colors.nextElement();\n            color.dispose();\n        }\n        printerColors = null;\n    }\n    if (gc != null) {\n        gc.dispose();\n        gc = null;\n    }\n    if (printerFont != null) {\n        printerFont.dispose();\n        printerFont = null;\n    }\n    if (renderer != null) {\n        renderer.dispose();\n        renderer = null;\n    }\n}",
			"comments":"/**\n* Disposes of the resources and the <class>PrintRenderer</class>.\n*/\n",
			"methodName":"void dispose()"
		},
		"public void redrawRange(int start, int length, boolean clearBackground)":{
			"methodBody":"{\n    checkWidget();\n    int end = start + length;\n    int contentLength = content.getCharCount();\n    int firstLine;\n    int lastLine;\n    if (start > end || start < 0 || end > contentLength) {\n        SWT.error(SWT.ERROR_INVALID_RANGE);\n    }\n    firstLine = content.getLineAtOffset(start);\n    lastLine = content.getLineAtOffset(end);\n    \n    \n    lineCache.reset(firstLine, lastLine - firstLine + 1, true);\n    internalRedrawRange(start, length, clearBackground);\n}",
			"comments":"/**\n* Redraws the specified text range.\n* <p>\n*\n* @param start offset of the first character to redraw\n* @param length number of characters to redraw\n* @param clearBackground true if the background should be cleared as\n*  part of the redraw operation.  If true, the entire redraw range will\n*  be cleared before anything is redrawn.  If the redraw range includes\n*\tthe last character of a line (i.e., the entire line is redrawn) the\n* \tline is cleared all the way to the right border of the widget.\n* \tThe redraw operation will be faster and smoother if clearBackground\n* \tis set to false.  Whether or not the flag can be set to false depends\n* \ton the type of change that has taken place.  If font styles or\n* \tbackground colors for the redraw range have changed, clearBackground\n* \tshould be set to true.  If only foreground colors have changed for\n* \tthe redraw range, clearBackground can be set to false.\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*   <li>ERROR_INVALID_RANGE when start and/or end are outside the widget content</li>\n* </ul>\n*/\n// reset all affected lines but let the redraw recalculate only\n// those that are visible.\n",
			"methodName":"public void redrawRange(int start, int length, boolean clearBackground)"
		},
		"void startPage(int page)":{
			"methodBody":"{\n    printer.startPage();\n    printDecoration(page, true);\n}",
			"comments":"/**\n* Start printing a new page.\n*\n* @param page page number to be started\n*/\n",
			"methodName":"void startPage(int page)"
		},
		"public void redraw()":{
			"methodBody":"{\n    int itemCount;\n    super.redraw();\n    itemCount = getPartialBottomIndex() - topIndex + 1;\n    lineCache.redrawReset(topIndex, itemCount, true);\n    lineCache.calculate(topIndex, itemCount);\n    setHorizontalScrollBar();\n}",
			"comments":"/**\n* Causes the entire bounds of the receiver to be marked\n* as needing to be redrawn. The next time a paint request\n* is processed, the control will be completely painted.\n* <p>\n* Recalculates the content width for all lines in the bounds.\n* When a <code>LineStyleListener</code> is used a redraw call\n* is the only notification to the widget that styles have changed\n* and that the content width may have changed.\n* </p>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see Control#update\n*/\n",
			"methodName":"public void redraw()"
		},
		"public void setContent(StyledTextContent newContent)":{
			"methodBody":"{\n    checkWidget();\n    if (newContent == null) {\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    }\n    if (content != null) {\n        content.removeTextChangeListener(textChangeListener);\n    }\n    logicalContent = newContent;\n    if (wordWrap) {\n        content = new WrappedContent(renderer, logicalContent);\n    } else {\n        content = logicalContent;\n    }\n    content.addTextChangeListener(textChangeListener);\n    reset();\n}",
			"comments":"/**\n* Sets the content implementation to use for text storage.\n* <p>\n*\n* @param newContent StyledTextContent implementation to use for text storage.\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT when listener is null</li>\n* </ul>\n*/\n",
			"methodName":"public void setContent(StyledTextContent newContent)"
		},
		"void printDecoration(int page, boolean header)":{
			"methodBody":"{\n    int lastSegmentIndex = 0;\n    final int SegmentCount = 3;\n    String text;\n    if (header) {\n        text = printOptions.header;\n    } else {\n        text = printOptions.footer;\n    }\n    if (text == null) {\n        return;\n    }\n    for (int i = 0; i < SegmentCount; i++) {\n        int segmentIndex = text.indexOf(StyledTextPrintOptions.SEPARATOR, lastSegmentIndex);\n        String segment;\n        if (segmentIndex == -1) {\n            segment = text.substring(lastSegmentIndex);\n            printDecorationSegment(segment, i, page, header);\n            break;\n        } else {\n            segment = text.substring(lastSegmentIndex, segmentIndex);\n            printDecorationSegment(segment, i, page, header);\n            lastSegmentIndex = segmentIndex + StyledTextPrintOptions.SEPARATOR.length();\n        }\n    }\n}",
			"comments":"/**\n* Print header or footer decorations.\n*\n* @param page page number to print, if specified in the StyledTextPrintOptions header or footer.\n* @param header true = print the header, false = print the footer\n*/\n",
			"methodName":"void printDecoration(int page, boolean header)"
		},
		"public void reset(int startLine, int lineCount, boolean calculateMaxWidth)":{
			"methodBody":"{\n    int itemCount = getPartialBottomIndex() - topIndex + 1;\n    int[] oldLineOffsets = new int[itemCount];\n    for (int i = 0; i < itemCount; i++) {\n        oldLineOffsets[i] = visualContent.getOffsetAtLine(i + topIndex);\n    }\n    redrawReset(startLine, lineCount, calculateMaxWidth);\n    \n    if (getPartialBottomIndex() - topIndex + 1 != itemCount) {\n        \n        parent.internalRedraw();\n    } else {\n        for (int i = 0; i < itemCount; i++) {\n            if (visualContent.getOffsetAtLine(i + topIndex) != oldLineOffsets[i]) {\n                \n                parent.internalRedraw();\n                break;\n            }\n        }\n    }\n}",
			"comments":"/**\n* Rewraps the lines in the specified range and redraws\n* the widget if the line wrapping has changed.\n* <p>\n*\n* @param startLine the first line to reset\n* @param lineCount the number of lines to reset\n* @param calculateMaxWidth true=implementors should retain a\n* \tvalid width even if it is affected by the reset operation.\n* \tfalse=the width may be set to 0\n*/\n// check for cases which will require a full redraw\n// number of visible lines has changed\n// wrapping of one of the visible lines has changed\n",
			"methodName":"public void reset(int startLine, int lineCount, boolean calculateMaxWidth)"
		},
		"void doSelectionWordNext()":{
			"methodBody":"{\n    int newCaretOffset = getWordEnd(caretOffset);\n    \n    advancing = false;\n    \n    if (isSingleLine() == false || content.getLineAtOffset(caretOffset) == content.getLineAtOffset(newCaretOffset)) {\n        caretOffset = newCaretOffset;\n        showCaret();\n    }\n}",
			"comments":"/**\n* Moves the caret to the end of the next word .\n*/\n// Force symmetrical movement for word next and previous. Fixes 14536\n// don't change caret position if in single line mode and the cursor\n// would be on a different line. fixes 5673\n",
			"methodName":"void doSelectionWordNext()"
		},
		"int getXAtOffset(String line, int lineIndex, int offsetInLine)":{
			"methodBody":"{\n    int x = 0;\n    int lineLength = line.length();\n    if (lineIndex < content.getLineCount() - 1) {\n        int endLineOffset = content.getOffsetAtLine(lineIndex + 1) - 1;\n        if (lineLength < offsetInLine && offsetInLine <= endLineOffset) {\n            offsetInLine = lineLength;\n        }\n    }\n    if (lineLength != 0 && offsetInLine <= lineLength) {\n        int lineOffset = content.getOffsetAtLine(lineIndex);\n        TextLayout layout = renderer.getTextLayout(line, lineOffset);\n        if (!advancing || offsetInLine == 0) {\n            x = layout.getLocation(offsetInLine, false).x;\n        } else {\n            x = layout.getLocation(offsetInLine - 1, true).x;\n        }\n        renderer.disposeTextLayout(layout);\n    }\n    return x + leftMargin - horizontalScrollOffset;\n}",
			"comments":"/**\n* Returns the x location of the character at the give offset in the line.\n* <b>NOTE:</b> Does not return correct values for true italic fonts (vs. slanted fonts).\n* <p>\n*\n* @return x location of the character at the given offset in the line.\n*/\n",
			"methodName":"int getXAtOffset(String line, int lineIndex, int offsetInLine)"
		},
		"public int getCharCount()":{
			"methodBody":"{\n    checkWidget();\n    return content.getCharCount();\n}",
			"comments":"/**\n* Gets the number of characters.\n* <p>\n*\n* @return number of characters in the widget\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getCharCount()"
		},
		"public void removeModifyListener(ModifyListener modifyListener)":{
			"methodBody":"{\n    checkWidget();\n    if (modifyListener == null) {\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    }\n    removeListener(SWT.Modify, modifyListener);\n}",
			"comments":"/**\n* Removes the specified modify listener.\n* <p>\n*\n* @param modifyListener the listener\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT when listener is null</li>\n* </ul>\n*/\n",
			"methodName":"public void removeModifyListener(ModifyListener modifyListener)"
		},
		"public Runnable print(Printer printer, StyledTextPrintOptions options)":{
			"methodBody":"{\n    checkWidget();\n    if (printer == null || options == null) {\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    }\n    return new Printing(this, printer, options);\n}",
			"comments":"/**\n* Returns a runnable that will print the widget's text\n* to the specified printer.\n* <p>\n* The runnable may be run in a non-UI thread.\n* </p>\n*\n* @param printer the printer to print to\n* @param options print options to use during printing\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT when printer or options is null</li>\n* </ul>\n* @since 2.1\n*/\n",
			"methodName":"public Runnable print(Printer printer, StyledTextPrintOptions options)"
		},
		"void handleTraverse(Event event)":{
			"methodBody":"{\n    switch(event.detail) {\n        case SWT.TRAVERSE_ESCAPE:\n        case SWT.TRAVERSE_PAGE_NEXT:\n        case SWT.TRAVERSE_PAGE_PREVIOUS:\n            event.doit = true;\n            break;\n        case SWT.TRAVERSE_RETURN:\n        case SWT.TRAVERSE_TAB_NEXT:\n        case SWT.TRAVERSE_TAB_PREVIOUS:\n            if ((getStyle() & SWT.SINGLE) != 0) {\n                event.doit = true;\n            } else {\n                if (!editable || (event.stateMask & SWT.MODIFIER_MASK) != 0) {\n                    event.doit = true;\n                }\n            }\n            break;\n    }\n}",
			"comments":"/**\n* Called when a traversal key is pressed.\n* Allow tab next traversal to occur when the widget is in single\n* line mode or in multi line and non-editable mode .\n* When in editable multi line mode we want to prevent the tab\n* traversal and receive the tab key event instead.\n* <p>\n*\n* @param event the event\n*/\n",
			"methodName":"void handleTraverse(Event event)"
		},
		"public void getValue(AccessibleControlEvent e)":{
			"methodBody":"{\n    e.result = StyledText.this.getText();\n}",
			"comments":"",
			"methodName":"public void getValue(AccessibleControlEvent e)"
		},
		"String getPlatformDelimitedText(TextWriter writer)":{
			"methodBody":"{\n    int end = writer.getStart() + writer.getCharCount();\n    int startLine = logicalContent.getLineAtOffset(writer.getStart());\n    int endLine = logicalContent.getLineAtOffset(end);\n    String endLineText = logicalContent.getLine(endLine);\n    int endLineOffset = logicalContent.getOffsetAtLine(endLine);\n    for (int i = startLine; i <= endLine; i++) {\n        writer.writeLine(logicalContent.getLine(i), logicalContent.getOffsetAtLine(i));\n        if (i < endLine) {\n            writer.writeLineDelimiter(PlatformLineDelimiter);\n        }\n    }\n    if (end > endLineOffset + endLineText.length()) {\n        writer.writeLineDelimiter(PlatformLineDelimiter);\n    }\n    writer.close();\n    return writer.toString();\n}",
			"comments":"/**\n* Returns the content in the specified range using the platform line\n* delimiter to separate lines.\n* <p>\n*\n* @param writer the TextWriter to write line text into\n* @return the content in the specified range using the platform line\n* \tdelimiter to separate lines as written by the specified TextWriter.\n*/\n",
			"methodName":"String getPlatformDelimitedText(TextWriter writer)"
		},
		"void showCaret()":{
			"methodBody":"{\n    int caretLine = content.getLineAtOffset(caretOffset);\n    showCaret(caretLine);\n}",
			"comments":"/**\n* Sets the caret location and scrolls the caret offset into view.\n*/\n",
			"methodName":"void showCaret()"
		},
		"void write(String string, int offset)":{
			"methodBody":"{\n    if (offset < 0 || offset > buffer.length()) {\n        return;\n    }\n    buffer.insert(offset, string);\n}",
			"comments":"/**\n* Inserts the given string to the data at the specified offset.\n* Do nothing if \"offset\" is < 0 or > getCharCount()\n* <p>\n*\n* @param string text to insert\n* @param offset offset in the existing data to insert \"string\" at.\n*/\n",
			"methodName":"void write(String string, int offset)"
		},
		"void doSelectionCursorPrevious()":{
			"methodBody":"{\n    int caretLine = getCaretLine();\n    int lineOffset = content.getOffsetAtLine(caretLine);\n    int offsetInLine = caretOffset - lineOffset;\n    advancing = false;\n    if (offsetInLine > 0) {\n        caretOffset = getClusterPrevious(caretOffset, caretLine);\n        showCaret(caretLine);\n    } else if (caretLine > 0) {\n        caretLine--;\n        lineOffset = content.getOffsetAtLine(caretLine);\n        caretOffset = lineOffset + content.getLine(caretLine).length();\n        showCaret();\n    }\n}",
			"comments":"/**\n* Moves the caret to the previous character or to the end of the previous\n* line if the cursor is at the beginning of a line.\n*/\n",
			"methodName":"void doSelectionCursorPrevious()"
		},
		"int getOffsetAtX(String line, int lineOffset, int lineXOffset)":{
			"methodBody":"{\n    int x = lineXOffset - leftMargin + horizontalScrollOffset;\n    TextLayout layout = renderer.getTextLayout(line, lineOffset);\n    int[] trailing = new int[1];\n    int offsetInLine = layout.getOffset(x, 0, trailing);\n    advancing = false;\n    if (trailing[0] != 0) {\n        int lineLength = line.length();\n        if (offsetInLine + trailing[0] >= lineLength) {\n            offsetInLine = lineLength;\n            advancing = true;\n        } else {\n            int level;\n            int offset = offsetInLine;\n            while (offset > 0 && Character.isDigit(line.charAt(offset))) offset--;\n            if (offset == 0 && Character.isDigit(line.charAt(offset))) {\n                level = isMirrored() ? 1 : 0;\n            } else {\n                level = layout.getLevel(offset) & 0x1;\n            }\n            offsetInLine += trailing[0];\n            int trailingLevel = layout.getLevel(offsetInLine) & 0x1;\n            advancing = (level ^ trailingLevel) != 0;\n        }\n    }\n    renderer.disposeTextLayout(layout);\n    return offsetInLine;\n}",
			"comments":"/**\n* Returns the caret offset at the given x location in the line.\n* The caret offset is the offset of the character where the caret will be\n* placed when a mouse click occurs. The caret offset will be the offset of\n* the character after the clicked one if the mouse click occurs at the second\n* half of a character.\n* Doesn't properly handle ligatures and other context dependent characters\n* unless the current locale is a bidi locale.\n* Ligatures are handled properly as long as they don't occur at lineXOffset.\n* <p>\n*\n* @param line text of the line to calculate the offset in\n* @param lineOffset offset of the first character in the line.\n* \t0 based from the beginning of the document.\n* @param lineXOffset x location in the line\n* @return caret offset at the x location relative to the start of the line.\n*/\n",
			"methodName":"int getOffsetAtX(String line, int lineOffset, int lineXOffset)"
		},
		"void updateSelection(int startOffset, int replacedLength, int newLength)":{
			"methodBody":"{\n    if (selection.y <= startOffset) {\n        \n        return;\n    }\n    if (selection.x < startOffset) {\n        \n        internalRedrawRange(selection.x, startOffset - selection.x, true);\n    }\n    if (selection.y > startOffset + replacedLength && selection.x < startOffset + replacedLength) {\n        \n        \n        \n        int netNewLength = newLength - replacedLength;\n        int redrawStart = startOffset + newLength;\n        internalRedrawRange(redrawStart, selection.y + netNewLength - redrawStart, true);\n    }\n    if (selection.y > startOffset && selection.x < startOffset + replacedLength) {\n        \n        internalSetSelection(startOffset + newLength, 0, true);\n        \n        setCaretLocation();\n    } else {\n        \n        internalSetSelection(selection.x + newLength - replacedLength, selection.y - selection.x, true);\n        \n        setCaretLocation();\n    }\n}",
			"comments":"/**\n* Updates the selection and caret position depending on the text change.\n* If the selection intersects with the replaced text, the selection is\n* reset and the caret moved to the end of the new text.\n* If the selection is behind the replaced text it is moved so that the\n* same text remains selected.  If the selection is before the replaced text\n* it is left unchanged.\n* <p>\n*\n* @param startOffset offset of the text change\n* @param replacedLength length of text being replaced\n* @param newLength length of new text\n*/\n// selection ends before text change\n// clear selection fragment before text change\n// clear selection fragment after text change.\n// do this only when the selection is actually affected by the\n// change. Selection is only affected if it intersects the change (1GDY217).\n// selection intersects replaced text. set caret behind text change\n// always update the caret location. fixes 1G8FODP\n// move selection to keep same text selected\n// always update the caret location. fixes 1G8FODP\n",
			"methodName":"void updateSelection(int startOffset, int replacedLength, int newLength)"
		},
		"void handleVerticalScroll(Event event)":{
			"methodBody":"{\n    setVerticalScrollOffset(getVerticalBar().getSelection(), false);\n}",
			"comments":"/**\n* Scrolls the widget vertically.\n*/\n",
			"methodName":"void handleVerticalScroll(Event event)"
		},
		"public void addExtendedModifyListener(ExtendedModifyListener extendedModifyListener)":{
			"methodBody":"{\n    checkWidget();\n    if (extendedModifyListener == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    StyledTextListener typedListener = new StyledTextListener(extendedModifyListener);\n    addListener(ExtendedModify, typedListener);\n}",
			"comments":"/**\n* Adds an extended modify listener. An ExtendedModify event is sent by the\n* widget when the widget text has changed.\n* <p>\n*\n* @param extendedModifyListener the listener\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT when listener is null</li>\n* </ul>\n*/\n",
			"methodName":"public void addExtendedModifyListener(ExtendedModifyListener extendedModifyListener)"
		},
		"public void setStyleRanges(StyleRange[] ranges)":{
			"methodBody":"{\n    checkWidget();\n    \n    if (userLineStyle) {\n        return;\n    }\n    if (ranges == null) {\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    }\n    \n    if (ranges.length != 0) {\n        StyleRange last = ranges[ranges.length - 1];\n        int lastEnd = last.start + last.length;\n        int firstLine = content.getLineAtOffset(ranges[0].start);\n        int lastLine;\n        if (lastEnd > content.getCharCount()) {\n            SWT.error(SWT.ERROR_INVALID_RANGE);\n        }\n        lastLine = content.getLineAtOffset(lastEnd);\n        \n        lineCache.reset(firstLine, lastLine - firstLine + 1, true);\n    } else {\n        \n        lineCache.reset(0, content.getLineCount(), false);\n    }\n    defaultLineStyler.setStyleRanges(ranges);\n    \n    redraw();\n    \n    \n    \n    setCaretLocation();\n}",
			"comments":"/**\n* Sets styles to be used for rendering the widget content. All styles\n* in the widget will be replaced with the given set of styles.\n* <p>\n* Should not be called if a LineStyleListener has been set since the\n* listener maintains the styles.\n* </p>\n*\n* @param ranges StyleRange objects containing the style information.\n* The ranges should not overlap. The style rendering is undefined if\n* the ranges do overlap. Must not be null. The styles need to be in order.\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT when listener is null</li>\n*    <li>ERROR_INVALID_RANGE when the last of the style ranges is outside the valid range (> getCharCount())</li>\n* </ul>\n*/\n// this API can not be used if the client is providing the line styles\n// check the last range, make sure it falls within the range of the\n// current text\n// reset all lines affected by the style change\n// reset all lines\n// should only redraw affected area to avoid flashing\n// make sure that the caret is positioned correctly.\n// caret location may change if font style changes.\n// fixes 1G8FODP\n",
			"methodName":"public void setStyleRanges(StyleRange[] ranges)"
		},
		"void linesChanged(int startLine, int delta)":{
			"methodBody":"{\n    boolean inserting = delta > 0;\n    if (delta == 0) {\n        return;\n    }\n    if (inserting) {\n        \n        expandLines(delta);\n        for (int i = lineCount - 1; i >= startLine; i--) {\n            lineWidth[i + delta] = lineWidth[i];\n        }\n        \n        for (int i = startLine + 1; i <= startLine + delta && i < lineWidth.length; i++) {\n            lineWidth[i] = -1;\n        }\n        \n        if (maxWidthLineIndex >= startLine) {\n            maxWidthLineIndex += delta;\n        }\n    } else {\n        \n        for (int i = startLine - delta; i < lineCount; i++) {\n            lineWidth[i + delta] = lineWidth[i];\n        }\n        \n        if (maxWidthLineIndex > startLine && maxWidthLineIndex <= startLine - delta) {\n            maxWidth = 0;\n            maxWidthLineIndex = -1;\n        } else if (maxWidthLineIndex >= startLine - delta) {\n            maxWidthLineIndex += delta;\n        }\n    }\n    lineCount += delta;\n}",
			"comments":"/**\n* Updates the line width array to reflect inserted or deleted lines.\n* <p>\n*\n* @param startLine\tthe starting line of the change that took place\n* @param delta\tthe number of lines in the change, > 0 indicates lines inserted,\n* \t< 0 indicates lines deleted\n*/\n// shift the lines down to make room for new lines\n// reset the new lines\n// have new lines been inserted above the longest line?\n// shift up the lines\n// has the longest line been removed?\n",
			"methodName":"void linesChanged(int startLine, int delta)"
		},
		"public int getLineHeight()":{
			"methodBody":"{\n    checkWidget();\n    return lineHeight;\n}",
			"comments":"/**\n* Returns the line height.\n* <p>\n*\n* @return line height in pixel.\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getLineHeight()"
		},
		"void handleTextChanged(TextChangedEvent event)":{
			"methodBody":"{\n    lineCache.textChanged(lastTextChangeStart, lastTextChangeNewLineCount, lastTextChangeReplaceLineCount, lastTextChangeNewCharCount, lastTextChangeReplaceCharCount);\n    setScrollBars();\n    \n    \n    \n    \n    \n    \n    \n    \n    updateSelection(lastTextChangeStart, lastTextChangeReplaceCharCount, lastTextChangeNewCharCount);\n    if (lastTextChangeReplaceLineCount > 0) {\n        \n        \n        \n        \n        claimBottomFreeSpace();\n    }\n    if (lastTextChangeReplaceCharCount > 0) {\n        \n        claimRightFreeSpace();\n    }\n    \n    if (lastTextChangeNewLineCount == 0 && lastTextChangeReplaceLineCount == 0) {\n        int startLine = content.getLineAtOffset(lastTextChangeStart);\n        int startY = startLine * lineHeight - verticalScrollOffset + topMargin;\n        if (DOUBLE_BUFFER) {\n            GC gc = getGC();\n            Caret caret = getCaret();\n            boolean caretVisible = false;\n            if (caret != null) {\n                caretVisible = caret.getVisible();\n                caret.setVisible(false);\n            }\n            performPaint(gc, startLine, startY, lineHeight);\n            if (caret != null) {\n                caret.setVisible(caretVisible);\n            }\n            gc.dispose();\n        } else {\n            redraw(0, startY, getClientArea().width, lineHeight, false);\n            update();\n        }\n    }\n}",
			"comments":"/**\n* Updates the caret position and selection and the scroll bars to reflect\n* the content change.\n* <p>\n*/\n// update selection/caret location after styles have been changed.\n// otherwise any text measuring could be incorrect\n//\n// also, this needs to be done after all scrolling. Otherwise,\n// selection redraw would be flushed during scroll which is wrong.\n// in some cases new text would be drawn in scroll source area even\n// though the intent is to scroll it.\n// fixes 1GB93QT\n// Only check for unused space when lines are deleted.\n// Fixes 1GFL4LY\n// Scroll up so that empty lines below last text line are used.\n// Fixes 1GEYJM0\n// fixes bug 8273\n// do direct drawing if the text change is confined to a single line.\n// optimization and fixes bug 13999. see also handleTextChanging.\n",
			"methodName":"void handleTextChanged(TextChangedEvent event)"
		},
		"public void setStyleRange(StyleRange range)":{
			"methodBody":"{\n    checkWidget();\n    \n    if (userLineStyle) {\n        return;\n    }\n    \n    if (range != null && range.start + range.length > content.getCharCount()) {\n        SWT.error(SWT.ERROR_INVALID_RANGE);\n    }\n    defaultLineStyler.setStyleRange(range);\n    if (range != null) {\n        int firstLine = content.getLineAtOffset(range.start);\n        int lastLine = content.getLineAtOffset(range.start + range.length);\n        lineCache.reset(firstLine, lastLine - firstLine + 1, true);\n        \n        if (isAreaVisible(firstLine, lastLine)) {\n            int redrawY = firstLine * lineHeight - verticalScrollOffset;\n            int redrawStopY = (lastLine + 1) * lineHeight - verticalScrollOffset;\n            draw(0, redrawY, getClientArea().width, redrawStopY - redrawY, true);\n        }\n    } else {\n        \n        lineCache.reset(0, content.getLineCount(), false);\n        redraw();\n    }\n    \n    \n    \n    setCaretLocation();\n}",
			"comments":"/**\n* Adds the specified style. The new style overwrites existing styles for the\n* specified range.  Existing style ranges are adjusted if they partially\n* overlap with the new style, To clear an individual style, call setStyleRange\n* with a StyleRange that has null attributes.\n* <p>\n* Should not be called if a LineStyleListener has been set since the\n* listener maintains the styles.\n* </p>\n*\n* @param range StyleRange object containing the style information.\n* Overwrites the old style in the given range. May be null to delete\n* all styles.\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*   <li>ERROR_INVALID_RANGE when the style range is outside the valid range (> getCharCount())</li>\n* </ul>\n*/\n// this API can not be used if the client is providing the line styles\n// check the range, make sure it falls within the range of the text\n// if the style is not visible, there is no need to redraw\n// clearing all styles\n// make sure that the caret is positioned correctly.\n// caret location may change if font style changes.\n// fixes 1G8FODP\n",
			"methodName":"public void setStyleRange(StyleRange range)"
		},
		"void doVisualNext()":{
			"methodBody":"{\n    caretOffset = getClusterNext(caretOffset, getCaretLine());\n    showCaret();\n}",
			"comments":"/**\n* Moves the caret one character to the right.  Do not go to the next line.\n* When in a bidi locale and at a R2L character the caret is moved to the\n* end of the R2L segment (visually left) and then one character to the\n* right (visually right because it's now in a L2R segment).\n*/\n",
			"methodName":"void doVisualNext()"
		},
		"void doSelectionWordPrevious()":{
			"methodBody":"{\n    int caretLine;\n    advancing = false;\n    caretOffset = getWordStart(caretOffset);\n    caretLine = content.getLineAtOffset(caretOffset);\n    \n    if (wordWrap && caretLine < content.getLineCount() - 1 && caretOffset == content.getOffsetAtLine(caretLine + 1)) {\n        caretLine++;\n    }\n    showCaret(caretLine);\n}",
			"comments":"/**\n* Moves the caret to the start of the previous word.\n*/\n// word previous always comes from bottom line. when\n// wrapping lines, stay on bottom line when on line boundary\n",
			"methodName":"void doSelectionWordPrevious()"
		},
		"void doPageUp(boolean select, int lines)":{
			"methodBody":"{\n    int oldColumnX = columnX;\n    int oldHScrollOffset = horizontalScrollOffset;\n    int caretLine = getCaretLine();\n    if (caretLine > 0) {\n        int scrollLines = Math.max(1, Math.min(caretLine, lines));\n        int scrollOffset;\n        caretLine -= scrollLines;\n        caretOffset = getOffsetAtMouseLocation(columnX, caretLine);\n        if (select) {\n            doSelection(ST.COLUMN_PREVIOUS);\n        }\n        \n        scrollOffset = Math.max(0, verticalScrollOffset - scrollLines * getVerticalIncrement());\n        if (scrollOffset < verticalScrollOffset) {\n            setVerticalScrollOffset(scrollOffset, true);\n        }\n    }\n    \n    \n    showCaret(caretLine);\n    \n    int hScrollChange = oldHScrollOffset - horizontalScrollOffset;\n    columnX = oldColumnX + hScrollChange;\n}",
			"comments":"/**\n* Scrolls one page up so that the first line (truncated or whole)\n* of the current page becomes the fully visible last line.\n* The caret is scrolled the same number of lines so that its location\n* relative to the top line remains the same. The exception is the beginning\n* of the text where a full page scroll is not possible. In this case the\n* caret is moved in front of the first character.\n*/\n// scroll one page up or to the top\n// explicitly go to the calculated caret line. may be different\n// from content.getLineAtOffset(caretOffset) when in word wrap mode\n// restore the original horizontal caret position\n",
			"methodName":"void doPageUp(boolean select, int lines)"
		},
		"public StyleRange getStyleRangeAtOffset(int offset)":{
			"methodBody":"{\n    checkWidget();\n    if (offset < 0 || offset >= getCharCount()) {\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    }\n    if (userLineStyle == false) {\n        return defaultLineStyler.getStyleRangeAtOffset(offset);\n    }\n    return null;\n}",
			"comments":"/**\n* Returns the style range at the given offset.\n* Returns null if a LineStyleListener has been set or if a style is not set\n* for the offset.\n* Should not be called if a LineStyleListener has been set since the\n* listener maintains the styles.\n* <p>\n*\n* @param offset the offset to return the style for.\n* \t0 <= offset < getCharCount() must be true.\n* @return a StyleRange with start == offset and length == 1, indicating\n* \tthe style at the given offset. null if a LineStyleListener has been set\n* \tor if a style is not set for the given offset.\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*   <li>ERROR_INVALID_ARGUMENT when the offset is invalid</li>\n* </ul>\n*/\n",
			"methodName":"public StyleRange getStyleRangeAtOffset(int offset)"
		},
		"void clearMargin(GC gc, Color background, Rectangle clientArea, int y)":{
			"methodBody":"{\n    \n    gc.setBackground(background);\n    if (topMargin > 0) {\n        gc.fillRectangle(0, -y, clientArea.width, topMargin);\n    }\n    if (bottomMargin > 0) {\n        gc.fillRectangle(0, clientArea.height - bottomMargin - y, clientArea.width, bottomMargin);\n    }\n    if (leftMargin > 0) {\n        gc.fillRectangle(0, -y, leftMargin, clientArea.height);\n    }\n    if (rightMargin > 0) {\n        gc.fillRectangle(clientArea.width - rightMargin, -y, rightMargin, clientArea.height);\n    }\n}",
			"comments":"/**\n* Clears the widget margin.\n*\n* @param gc GC to render on\n* @param background background color to use for clearing the margin\n* @param clientArea widget client area dimensions\n*/\n// clear the margin background\n",
			"methodName":"void clearMargin(GC gc, Color background, Rectangle clientArea, int y)"
		},
		"int contentWidth(String line, int lineOffset)":{
			"methodBody":"{\n    TextLayout layout = renderer.getTextLayout(line, lineOffset);\n    Rectangle rect = layout.getLineBounds(0);\n    renderer.disposeTextLayout(layout);\n    return rect.x + rect.width + leftMargin + rightMargin;\n}",
			"comments":"/**\n* Measures the width of the given line.\n* <p>\n*\n* @param line the line to measure\n* @param lineOffset start offset of the line to measure, relative\n* \tto the start of the document\n* @return the width of the given line\n*/\n",
			"methodName":"int contentWidth(String line, int lineOffset)"
		},
		"boolean setVerticalScrollOffset(int pixelOffset, boolean adjustScrollBar)":{
			"methodBody":"{\n    Rectangle clientArea;\n    ScrollBar verticalBar = getVerticalBar();\n    if (pixelOffset == verticalScrollOffset) {\n        return false;\n    }\n    if (verticalBar != null && adjustScrollBar) {\n        verticalBar.setSelection(pixelOffset);\n    }\n    clientArea = getClientArea();\n    scroll(\n    0, \n    0, \n    0, \n    pixelOffset - verticalScrollOffset, clientArea.width, clientArea.height, true);\n    verticalScrollOffset = pixelOffset;\n    calculateTopIndex();\n    int oldColumnX = columnX;\n    setCaretLocation();\n    \n    columnX = oldColumnX;\n    return true;\n}",
			"comments":"/**\n* Scrolls the widget vertically.\n* <p>\n*\n* @param pixelOffset the new vertical scroll offset\n* @param adjustScrollBar\n* \ttrue= the scroll thumb will be moved to reflect the new scroll offset.\n* \tfalse = the scroll thumb will not be moved\n* @return\n*\ttrue=the widget was scrolled\n*\tfalse=the widget was not scrolled, the given offset is not valid.\n*/\n// destination x, y\n// source x, y\n// restore the original horizontal caret index\n",
			"methodName":"boolean setVerticalScrollOffset(int pixelOffset, boolean adjustScrollBar)"
		},
		"LineCache getLineCache(StyledTextContent content)":{
			"methodBody":"{\n    LineCache lineCache;\n    if (wordWrap) {\n        lineCache = new WordWrapCache(this, (WrappedContent) content);\n    } else {\n        lineCache = new ContentWidthCache(this, content);\n    }\n    return lineCache;\n}",
			"comments":"/**\n* Returns a LineCache implementation. Depending on whether or not\n* word wrap is on this may be a line wrapping or line width\n* calculating implementaiton.\n* <p>\n*\n* @param content StyledTextContent to create the LineCache on.\n* @return a LineCache implementation\n*/\n",
			"methodName":"LineCache getLineCache(StyledTextContent content)"
		},
		"public void showSelection()":{
			"methodBody":"{\n    checkWidget();\n    boolean selectionFits;\n    int startOffset, startLine, startX, endOffset, endLine, endX, offsetInLine;\n    \n    boolean rightToLeft = caretOffset == selection.x;\n    if (rightToLeft) {\n        startOffset = selection.y;\n        endOffset = selection.x;\n    } else {\n        startOffset = selection.x;\n        endOffset = selection.y;\n    }\n    \n    startLine = content.getLineAtOffset(startOffset);\n    offsetInLine = startOffset - content.getOffsetAtLine(startLine);\n    startX = getXAtOffset(content.getLine(startLine), startLine, offsetInLine);\n    endLine = content.getLineAtOffset(endOffset);\n    offsetInLine = endOffset - content.getOffsetAtLine(endLine);\n    endX = getXAtOffset(content.getLine(endLine), endLine, offsetInLine);\n    \n    int w = getClientArea().width;\n    if (rightToLeft) {\n        selectionFits = startX - endX <= w;\n    } else {\n        selectionFits = endX - startX <= w;\n    }\n    if (selectionFits) {\n        \n        \n        showLocation(startX, startLine);\n        \n        endX = getXAtOffset(content.getLine(endLine), endLine, offsetInLine);\n        showLocation(endX, endLine);\n    } else {\n        \n        \n        showLocation(endX, endLine);\n    }\n}",
			"comments":"/**\n/**\n* Scrolls the selection into view.  The end of the selection will be scrolled into\n* view.  Note that if a right-to-left selection exists, the end of the selection is the\n* visual beginning of the selection (i.e., where the caret is located).\n* <p>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n// is selection from right-to-left?\n// calculate the logical start and end values for the selection\n// can the selection be fully displayed within the widget's visible width?\n// show as much of the selection as possible by first showing\n// the start of the selection\n// endX value could change if showing startX caused a scroll to occur\n// just show the end of the selection since the selection start\n// will not be visible\n",
			"methodName":"public void showSelection()"
		},
		"public boolean getWordWrap()":{
			"methodBody":"{\n    checkWidget();\n    return wordWrap;\n}",
			"comments":"/**\n* Returns whether the widget wraps lines.\n* <p>\n*\n* @return true if widget wraps lines, false otherwise\n* @since 2.0\n*/\n",
			"methodName":"public boolean getWordWrap()"
		},
		"StyledTextContent internalGetContent()":{
			"methodBody":"{\n    return content;\n}",
			"comments":"",
			"methodName":"StyledTextContent internalGetContent()"
		},
		"public Runnable print(Printer printer)":{
			"methodBody":"{\n    checkWidget();\n    StyledTextPrintOptions options = new StyledTextPrintOptions();\n    options.printTextForeground = true;\n    options.printTextBackground = true;\n    options.printTextFontStyle = true;\n    options.printLineBackground = true;\n    if (printer == null) {\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    }\n    return print(printer, options);\n}",
			"comments":"/**\n* Returns a runnable that will print the widget's text\n* to the specified printer.\n* <p>\n* The runnable may be run in a non-UI thread.\n* </p>\n*\n* @param printer the printer to print to\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT when printer is null</li>\n* </ul>\n*/\n",
			"methodName":"public Runnable print(Printer printer)"
		},
		"void installListeners()":{
			"methodBody":"{\n    ScrollBar verticalBar = getVerticalBar();\n    ScrollBar horizontalBar = getHorizontalBar();\n    listener = new Listener() {\n\n        public void handleEvent(Event event) {\n            switch(event.type) {\n                case SWT.Dispose:\n                    handleDispose(event);\n                    break;\n                case SWT.KeyDown:\n                    handleKeyDown(event);\n                    break;\n                case SWT.KeyUp:\n                    handleKeyUp(event);\n                    break;\n                case SWT.MouseDown:\n                    handleMouseDown(event);\n                    break;\n                case SWT.MouseUp:\n                    handleMouseUp(event);\n                    break;\n                case SWT.MouseDoubleClick:\n                    handleMouseDoubleClick(event);\n                    break;\n                case SWT.MouseMove:\n                    handleMouseMove(event);\n                    break;\n                case SWT.Paint:\n                    handlePaint(event);\n                    break;\n                case SWT.Resize:\n                    handleResize(event);\n                    break;\n                case SWT.Traverse:\n                    handleTraverse(event);\n                    break;\n            }\n        }\n    };\n    addListener(SWT.Dispose, listener);\n    addListener(SWT.KeyDown, listener);\n    addListener(SWT.KeyUp, listener);\n    addListener(SWT.MouseDown, listener);\n    addListener(SWT.MouseUp, listener);\n    addListener(SWT.MouseDoubleClick, listener);\n    addListener(SWT.MouseMove, listener);\n    addListener(SWT.Paint, listener);\n    addListener(SWT.Resize, listener);\n    addListener(SWT.Traverse, listener);\n    if (verticalBar != null) {\n        verticalBar.addListener(SWT.Selection, new Listener() {\n\n            public void handleEvent(Event event) {\n                handleVerticalScroll(event);\n            }\n        });\n    }\n    if (horizontalBar != null) {\n        horizontalBar.addListener(SWT.Selection, new Listener() {\n\n            public void handleEvent(Event event) {\n                handleHorizontalScroll(event);\n            }\n        });\n    }\n}",
			"comments":"/**\n* Adds event listeners\n*/\n",
			"methodName":"void installListeners()"
		},
		"public void setTopPixel(int pixel)":{
			"methodBody":"{\n    checkWidget();\n    int lineCount = content.getLineCount();\n    int height = getClientArea().height;\n    int maxTopPixel = Math.max(0, lineCount * getVerticalIncrement() - height);\n    if (getCharCount() == 0) {\n        return;\n    }\n    if (pixel < 0) {\n        pixel = 0;\n    } else if (pixel > maxTopPixel) {\n        pixel = maxTopPixel;\n    }\n    setVerticalScrollOffset(pixel, true);\n}",
			"comments":"/**\n* Sets the top pixel offset. Do nothing if there is no text set.\n* <p>\n* The top pixel offset is the vertical pixel offset of the widget. The\n* widget is scrolled so that the given pixel position is at the top.\n* The top index is adjusted to the corresponding top line.\n* Note: The top pixel is reset to 0 when new text is set in the widget.\n* </p>\n*\n* @param pixel new top pixel offset. Must be between 0 and\n* \t(getLineCount() - visible lines per page) / getLineHeight()). An out\n* \tof range offset will be adjusted accordingly.\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @since 2.0\n*/\n",
			"methodName":"public void setTopPixel(int pixel)"
		},
		"public StyledTextContent getContent()":{
			"methodBody":"{\n    checkWidget();\n    return logicalContent;\n}",
			"comments":"/**\n* Returns the content implementation that is used for text storage\n* or null if no user defined content implementation has been set.\n* <p>\n*\n* @return content implementation that is used for text storage or null\n* if no user defined content implementation has been set.\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public StyledTextContent getContent()"
		},
		"public int getOffsetAtLocation(Point point)":{
			"methodBody":"{\n    checkWidget();\n    TextLayout layout;\n    int line;\n    int lineOffset;\n    int offsetInLine;\n    String lineText;\n    if (point == null) {\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    }\n    \n    if (point.y + verticalScrollOffset < 0 || point.x + horizontalScrollOffset < 0) {\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    }\n    line = (getTopPixel() + point.y) / lineHeight;\n    \n    if (line >= content.getLineCount()) {\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    }\n    lineText = content.getLine(line);\n    lineOffset = content.getOffsetAtLine(line);\n    int x = point.x - leftMargin + horizontalScrollOffset;\n    layout = renderer.getTextLayout(lineText, lineOffset);\n    Rectangle rect = layout.getLineBounds(0);\n    if (x > rect.x + rect.width) {\n        renderer.disposeTextLayout(layout);\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    }\n    int[] trailing = new int[1];\n    offsetInLine = layout.getOffset(x, 0, trailing);\n    if (offsetInLine != lineText.length() - 1) {\n        offsetInLine = Math.min(lineText.length(), offsetInLine + trailing[0]);\n    }\n    renderer.disposeTextLayout(layout);\n    return lineOffset + offsetInLine;\n}",
			"comments":"/**\n* Returns the offset of the character at the given location relative\n* to the first character in the document.\n* The return value reflects the character offset that the caret will\n* be placed at if a mouse click occurred at the specified location.\n* If the x coordinate of the location is beyond the center of a character\n* the returned offset will be behind the character.\n* <p>\n*\n* @param point the origin of character bounding box relative to\n* \tthe origin of the widget client area.\n* @return offset of the character at the given location relative\n* \tto the first character in the document.\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*   <li>ERROR_NULL_ARGUMENT when point is null</li>\n*   <li>ERROR_INVALID_ARGUMENT when there is no character at the specified location</li>\n* </ul>\n*/\n// is y above first line or is x before first column?\n// does the referenced line exist?\n",
			"methodName":"public int getOffsetAtLocation(Point point)"
		},
		"void createCaretBitmaps()":{
			"methodBody":"{\n    int caretWidth = BIDI_CARET_WIDTH;\n    Display display = getDisplay();\n    if (leftCaretBitmap != null) {\n        if (defaultCaret != null && leftCaretBitmap.equals(defaultCaret.getImage())) {\n            defaultCaret.setImage(null);\n        }\n        leftCaretBitmap.dispose();\n    }\n    leftCaretBitmap = new Image(display, caretWidth, lineHeight);\n    GC gc = new GC(leftCaretBitmap);\n    gc.setBackground(display.getSystemColor(SWT.COLOR_BLACK));\n    gc.fillRectangle(0, 0, caretWidth, lineHeight);\n    gc.setForeground(display.getSystemColor(SWT.COLOR_WHITE));\n    gc.drawLine(0, 0, 0, lineHeight);\n    gc.drawLine(0, 0, caretWidth - 1, 0);\n    gc.drawLine(0, 1, 1, 1);\n    gc.dispose();\n    if (rightCaretBitmap != null) {\n        if (defaultCaret != null && rightCaretBitmap.equals(defaultCaret.getImage())) {\n            defaultCaret.setImage(null);\n        }\n        rightCaretBitmap.dispose();\n    }\n    rightCaretBitmap = new Image(display, caretWidth, lineHeight);\n    gc = new GC(rightCaretBitmap);\n    gc.setBackground(display.getSystemColor(SWT.COLOR_BLACK));\n    gc.fillRectangle(0, 0, caretWidth, lineHeight);\n    gc.setForeground(display.getSystemColor(SWT.COLOR_WHITE));\n    gc.drawLine(caretWidth - 1, 0, caretWidth - 1, lineHeight);\n    gc.drawLine(0, 0, caretWidth - 1, 0);\n    gc.drawLine(caretWidth - 1, 1, 1, 1);\n    gc.dispose();\n}",
			"comments":"/**\n* Create the bitmaps to use for the caret in bidi mode.  This\n* method only needs to be called upon widget creation and when the\n* font changes (the caret bitmap height needs to match font height).\n*/\n",
			"methodName":"void createCaretBitmaps()"
		},
		"void doSelectionCursorNext()":{
			"methodBody":"{\n    int caretLine = getCaretLine();\n    int lineOffset = content.getOffsetAtLine(caretLine);\n    int offsetInLine = caretOffset - lineOffset;\n    advancing = true;\n    if (offsetInLine < content.getLine(caretLine).length()) {\n        caretOffset = getClusterNext(caretOffset, caretLine);\n        showCaret();\n    } else if (caretLine < content.getLineCount() - 1 && isSingleLine() == false) {\n        \n        caretLine++;\n        caretOffset = content.getOffsetAtLine(caretLine);\n        \n        \n        showCaret(caretLine);\n    }\n}",
			"comments":"/**\n* Moves the caret to the next character or to the beginning of the\n* next line if the cursor is at the end of a line.\n*/\n// only go to next line if not in single line mode. fixes 5673\n// explicitly go to the calculated caret line. may be different\n// from content.getLineAtOffset(caretOffset) when in word wrap mode\n",
			"methodName":"void doSelectionCursorNext()"
		},
		"public void removeBidiSegmentListener(BidiSegmentListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    removeListener(LineGetSegments, listener);\n}",
			"comments":"/**\n* Removes the specified bidirectional segment listener.\n* <p>\n*\n* @param listener the listener\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT when listener is null</li>\n* </ul>\n* @since 2.0\n*/\n",
			"methodName":"public void removeBidiSegmentListener(BidiSegmentListener listener)"
		},
		"void cacheBidiSegments(int lineOffset, String line)":{
			"methodBody":"{\n    int[] segments = parent.getBidiSegments(lineOffset, line);\n    if (segments != null) {\n        bidiSegments.put(new Integer(lineOffset), segments);\n    }\n}",
			"comments":"/**\n* Caches the bidi segments of the given line.\n* </p>\n* @param lineOffset offset of the line to cache bidi segments for.\n* \tRelative to the start of the document.\n* @param line line to cache bidi segments for.\n*/\n",
			"methodName":"void cacheBidiSegments(int lineOffset, String line)"
		},
		"public void addVerifyListener(VerifyListener verifyListener)":{
			"methodBody":"{\n    checkWidget();\n    if (verifyListener == null) {\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    }\n    TypedListener typedListener = new TypedListener(verifyListener);\n    addListener(SWT.Verify, typedListener);\n}",
			"comments":"/**\n* Adds a verify listener. A Verify event is sent by the widget when the widget text\n* is about to change. The listener can set the event text and the doit field to\n* change the text that is set in the widget or to force the widget to ignore the\n* text change.\n* <p>\n*\n* @param verifyListener the listener\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT when listener is null</li>\n* </ul>\n*/\n",
			"methodName":"public void addVerifyListener(VerifyListener verifyListener)"
		},
		"StyledTextEvent getLineStyleData(int lineOffset, String line)":{
			"methodBody":"{\n    return sendLineEvent(LineGetStyle, lineOffset, line);\n}",
			"comments":"/**\n* Returns the line style data for the given line or null if there is\n* none. If there is a LineStyleListener but it does not set any styles,\n* the StyledTextEvent.styles field will be initialized to an empty\n* array.\n* <p>\n*\n* @param lineOffset offset of the line start relative to the start of\n* \tthe content.\n* @param line line to get line styles for\n* @return line style data for the given line. Styles may start before\n* \tline start and end after line end\n*/\n",
			"methodName":"StyledTextEvent getLineStyleData(int lineOffset, String line)"
		},
		"void handleDispose(Event event)":{
			"methodBody":"{\n    removeListener(SWT.Dispose, listener);\n    notifyListeners(SWT.Dispose, event);\n    event.type = SWT.None;\n    clipboard.dispose();\n    ibeamCursor.dispose();\n    if (renderer != null) {\n        renderer.dispose();\n        renderer = null;\n    }\n    if (content != null) {\n        content.removeTextChangeListener(textChangeListener);\n        content = null;\n    }\n    if (defaultCaret != null) {\n        defaultCaret.dispose();\n        defaultCaret = null;\n    }\n    if (leftCaretBitmap != null) {\n        leftCaretBitmap.dispose();\n        leftCaretBitmap = null;\n    }\n    if (rightCaretBitmap != null) {\n        rightCaretBitmap.dispose();\n        rightCaretBitmap = null;\n    }\n    if (defaultLineStyler != null) {\n        defaultLineStyler.release();\n        defaultLineStyler = null;\n    }\n    if (isBidiCaret()) {\n        BidiUtil.removeLanguageListener(handle);\n    }\n    selectionBackground = null;\n    selectionForeground = null;\n    logicalContent = null;\n    textChangeListener = null;\n    lineCache = null;\n    ibeamCursor = null;\n    selection = null;\n    doubleClickSelection = null;\n    keyActionMap = null;\n    background = null;\n    foreground = null;\n    clipboard = null;\n}",
			"comments":"/**\n* Frees resources.\n*/\n",
			"methodName":"void handleDispose(Event event)"
		},
		"public void setTextLimit(int limit)":{
			"methodBody":"{\n    checkWidget();\n    if (limit == 0) {\n        SWT.error(SWT.ERROR_CANNOT_BE_ZERO);\n    }\n    textLimit = limit;\n}",
			"comments":"/**\n* Sets the text limit to the specified number of characters.\n* <p>\n* The text limit specifies the amount of text that\n* the user can type into the widget.\n* </p>\n*\n* @param limit the new text limit.\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*   <li>ERROR_CANNOT_BE_ZERO when limit is 0</li>\n* </ul>\n*/\n",
			"methodName":"public void setTextLimit(int limit)"
		},
		"void performPaint(GC gc, int startLine, int startY, int renderHeight)":{
			"methodBody":"{\n    Rectangle clientArea = getClientArea();\n    Color background = getBackground();\n    \n    if (clientArea.width == 0) {\n        return;\n    }\n    if (renderHeight > 0) {\n        \n        Color foreground = getForeground();\n        int lineCount = content.getLineCount();\n        int gcStyle = isMirrored() ? SWT.RIGHT_TO_LEFT : SWT.LEFT_TO_RIGHT;\n        if (isSingleLine()) {\n            lineCount = 1;\n        }\n        int paintY, paintHeight;\n        Image lineBuffer;\n        GC lineGC;\n        boolean doubleBuffer = DOUBLE_BUFFER && lastPaintTopIndex == topIndex;\n        lastPaintTopIndex = topIndex;\n        if (doubleBuffer) {\n            paintY = 0;\n            paintHeight = renderHeight;\n            lineBuffer = new Image(getDisplay(), clientArea.width, renderHeight);\n            lineGC = new GC(lineBuffer, gcStyle);\n            lineGC.setFont(getFont());\n            lineGC.setForeground(foreground);\n            lineGC.setBackground(background);\n        } else {\n            paintY = startY;\n            paintHeight = startY + renderHeight;\n            lineBuffer = null;\n            lineGC = gc;\n        }\n        for (int i = startLine; paintY < paintHeight && i < lineCount; i++, paintY += lineHeight) {\n            String line = content.getLine(i);\n            renderer.drawLine(line, i, paintY, lineGC, background, foreground, true);\n        }\n        if (paintY < paintHeight) {\n            lineGC.setBackground(background);\n            lineGC.fillRectangle(0, paintY, clientArea.width, paintHeight - paintY);\n        }\n        if (doubleBuffer) {\n            clearMargin(lineGC, background, clientArea, startY);\n            gc.drawImage(lineBuffer, 0, startY);\n            lineGC.dispose();\n            lineBuffer.dispose();\n        }\n    }\n    clearMargin(gc, background, clientArea, 0);\n}",
			"comments":"/**\n* Render the specified area.  Broken out as its own method to support\n* direct drawing.\n* <p>\n*\n* @param gc GC to render on\n* @param startLine first line to render\n* @param startY y pixel location to start rendering at\n* @param renderHeight renderHeight widget area that needs to be filled with lines\n*/\n// Check if there is work to do. We never want to try and create\n// an Image with 0 width or 0 height.\n// renderHeight will be negative when only top margin needs redrawing\n",
			"methodName":"void performPaint(GC gc, int startLine, int startY, int renderHeight)"
		},
		"public void setBackground(Color color)":{
			"methodBody":"{\n    checkWidget();\n    background = color;\n    super.setBackground(getBackground());\n    redraw();\n}",
			"comments":"/**\n* @see org.eclipse.swt.widgets.Control#setBackground\n*/\n",
			"methodName":"public void setBackground(Color color)"
		},
		"void doAutoScroll(Event event)":{
			"methodBody":"{\n    Rectangle area = getClientArea();\n    if (event.y > area.height) {\n        doAutoScroll(SWT.DOWN, event.y - area.height);\n    } else if (event.y < 0) {\n        doAutoScroll(SWT.UP, -event.y);\n    } else if (event.x < leftMargin && wordWrap == false) {\n        doAutoScroll(ST.COLUMN_PREVIOUS, leftMargin - event.x);\n    } else if (event.x > area.width - leftMargin - rightMargin && wordWrap == false) {\n        doAutoScroll(ST.COLUMN_NEXT, event.x - (area.width - leftMargin - rightMargin));\n    } else {\n        endAutoScroll();\n    }\n}",
			"comments":"/**\n* A mouse move event has occurred.  See if we should start autoscrolling.  If\n* the move position is outside of the client area, initiate autoscrolling.\n* Otherwise, we've moved back into the widget so end autoscrolling.\n*/\n",
			"methodName":"void doAutoScroll(Event event)"
		},
		"public Point getSelectionRange()":{
			"methodBody":"{\n    checkWidget();\n    return new Point(selection.x, selection.y - selection.x);\n}",
			"comments":"/**\n* Returns the selection.\n* <p>\n*\n* @return start and length of the selection, x is the offset of the\n* \tfirst selected character, relative to the first character of the\n* \twidget content. y is the length of the selection.\n*  The selection values returned are visual (i.e., length will always always be\n*  positive).  To determine if a selection is right-to-left (RtoL) vs. left-to-right\n*  (LtoR), compare the caretOffset to the start and end of the selection\n*  (e.g., caretOffset == start of selection implies that the selection is RtoL).\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Point getSelectionRange()"
		},
		"public void cut()":{
			"methodBody":"{\n    checkWidget();\n    int length = selection.y - selection.x;\n    if (length > 0) {\n        try {\n            setClipboardContent(selection.x, length, DND.CLIPBOARD);\n        } catch (SWTError error) {\n            \n            if (error.code != DND.ERROR_CANNOT_SET_CLIPBOARD) {\n                throw error;\n            }\n            \n            return;\n        }\n        doDelete();\n    }\n}",
			"comments":"/**\n* Moves the selected text to the clipboard.  The text will be put in the\n* clipboard in plain text format and RTF format.\n* <p>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n// Copy to clipboard failed. This happens when another application\n// is accessing the clipboard while we copy. Ignore the error.\n// Fixes 1GDQAVN\n// Rethrow all other errors. Fixes bug 17578.\n// Abort cut operation if copy to clipboard fails.\n// Fixes bug 21030.\n",
			"methodName":"public void cut()"
		},
		"public int getHorizontalIndex()":{
			"methodBody":"{\n    checkWidget();\n    return horizontalScrollOffset / getHorizontalIncrement();\n}",
			"comments":"/**\n* Returns the horizontal scroll offset relative to the start of the line.\n* <p>\n*\n* @return horizontal scroll offset relative to the start of the line,\n* measured in character increments starting at 0, if > 0 the content is scrolled\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getHorizontalIndex()"
		},
		"public void setSelectionRange(int start, int length)":{
			"methodBody":"{\n    checkWidget();\n    int contentLength = getCharCount();\n    start = Math.max(0, Math.min(start, contentLength));\n    int end = start + length;\n    if (end < 0) {\n        length = -start;\n    } else {\n        if (end > contentLength)\n            length = contentLength - start;\n    }\n    if (isLineDelimiter(start) || isLineDelimiter(start + length)) {\n        \n        \n        \n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    }\n    internalSetSelection(start, length, false);\n    \n    setCaretLocation();\n}",
			"comments":"/**\n* Sets the selection. The new selection may not be visible. Call showSelection to scroll\n* the selection into view. A negative length places the caret at the visual start of the\n* selection. <p>\n*\n* @param start offset of the first selected character\n* @param length number of characters to select\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*   <li>ERROR_INVALID_ARGUMENT when either the start or the end of the selection range is inside a\n* multi byte line delimiter (and thus neither clearly in front of or after the line delimiter)\n* </ul>\n*/\n// the start offset or end offset of the selection range is inside a\n// multi byte line delimiter. This is an illegal operation and an exception\n// is thrown. Fixes 1GDKK3R\n// always update the caret location. fixes 1G8FODP\n",
			"methodName":"public void setSelectionRange(int start, int length)"
		},
		"void cacheLineStyle(int lineOffset, String line)":{
			"methodBody":"{\n    StyledTextEvent event = parent.getLineStyleData(lineOffset, line);\n    if (event != null) {\n        StyleRange[] styles = event.styles;\n        for (int i = 0; i < styles.length; i++) {\n            StyleRange styleCopy = null;\n            if (printOptions.printTextBackground == false && styles[i].background != null) {\n                styleCopy = (StyleRange) styles[i].clone();\n                styleCopy.background = null;\n            }\n            if (printOptions.printTextForeground == false && styles[i].foreground != null) {\n                if (styleCopy == null) {\n                    styleCopy = (StyleRange) styles[i].clone();\n                }\n                styleCopy.foreground = null;\n            }\n            if (printOptions.printTextFontStyle == false && styles[i].fontStyle != SWT.NORMAL) {\n                if (styleCopy == null) {\n                    styleCopy = (StyleRange) styles[i].clone();\n                }\n                styleCopy.fontStyle = SWT.NORMAL;\n            }\n            if (styleCopy != null) {\n                styles[i] = styleCopy;\n            }\n        }\n        lineStyles.put(new Integer(lineOffset), event);\n    }\n}",
			"comments":"/**\n* Caches all line styles of the given line.\n* </p>\n* @param lineOffset offset of the line to cache the styles for.\n* \tRelative to the start of the document.\n* @param line line to cache the styles for.\n*/\n",
			"methodName":"void cacheLineStyle(int lineOffset, String line)"
		},
		"String getRtf()":{
			"methodBody":"{\n    checkWidget();\n    RTFWriter rtfWriter = new RTFWriter(0, getCharCount());\n    return getPlatformDelimitedText(rtfWriter);\n}",
			"comments":"/**\n* Returns the widget text with style information encoded using RTF format\n* specification version 1.5.\n*\n* @return the widget text with style information encoded using RTF format\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"String getRtf()"
		},
		"int doLineDown()":{
			"methodBody":"{\n    if (isSingleLine()) {\n        return 0;\n    }\n    \n    \n    int caretLine = getCaretLine();\n    if (caretLine < content.getLineCount() - 1) {\n        caretLine++;\n        caretOffset = getOffsetAtMouseLocation(columnX, caretLine);\n    }\n    return caretLine;\n}",
			"comments":"/**\n* Moves the caret one line down and to the same character offset relative\n* to the beginning of the line. Move the caret to the end of the new line\n* if the new line is shorter than the character offset.\n*\n* @return index of the new line relative to the first line in the document\n*/\n// allow line down action only if receiver is not in single line mode.\n// fixes 4820.\n",
			"methodName":"int doLineDown()"
		},
		"public void setTabs(int tabs)":{
			"methodBody":"{\n    checkWidget();\n    tabLength = tabs;\n    renderer.setTabLength(tabLength);\n    if (caretOffset > 0) {\n        caretOffset = 0;\n        showCaret();\n        clearSelection(false);\n    }\n    \n    lineCache.reset(0, content.getLineCount(), false);\n    redraw();\n}",
			"comments":"/**\n* Sets the tab width.\n* <p>\n*\n* @param tabs tab width measured in characters.\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n// reset all line widths when the tab width changes\n",
			"methodName":"public void setTabs(int tabs)"
		},
		"void doSelectionPageDown(int lines)":{
			"methodBody":"{\n    int oldColumnX;\n    int caretLine = getCaretLine();\n    int lineStartOffset = content.getOffsetAtLine(caretLine);\n    \n    oldColumnX = columnX = getXAtOffset(content.getLine(caretLine), caretLine, caretOffset - lineStartOffset);\n    doPageDown(true, lines);\n    columnX = oldColumnX;\n}",
			"comments":"/**\n* Scrolls one page down so that the last line (truncated or whole)\n* of the current page becomes the fully visible top line.\n* The caret is scrolled the same number of lines so that its location\n* relative to the top line remains the same. The exception is the end\n* of the text where a full page scroll is not possible. In this case\n* the caret is moved after the last character.\n* <p>\n* Adjusts the selection according to the caret change. This can either add\n* to or subtract from the old selection, depending on the previous selection\n* direction.\n* </p>\n*/\n// reset columnX on selection\n",
			"methodName":"void doSelectionPageDown(int lines)"
		},
		"void handleKey(Event event)":{
			"methodBody":"{\n    int action;\n    advancing = true;\n    if (event.keyCode != 0) {\n        \n        action = getKeyBinding(event.keyCode | event.stateMask);\n    } else {\n        \n        action = getKeyBinding(event.character | event.stateMask);\n        if (action == SWT.NULL) {\n            \n            if ((event.stateMask & SWT.CTRL) != 0 && (event.character >= 0) && event.character <= 31) {\n                \n                \n                int c = event.character + 64;\n                action = getKeyBinding(c | event.stateMask);\n            }\n        }\n    }\n    if (action == SWT.NULL) {\n        boolean ignore = false;\n        if (IS_CARBON) {\n            \n            \n            \n            \n            ignore = (event.stateMask ^ SWT.COMMAND) == 0 || (event.stateMask ^ (SWT.COMMAND | SWT.SHIFT)) == 0;\n        } else if (IS_MOTIF) {\n            \n            \n            \n            \n            ignore = (event.stateMask ^ SWT.CTRL) == 0 || (event.stateMask ^ (SWT.CTRL | SWT.SHIFT)) == 0;\n        } else {\n            \n            \n            \n            \n            ignore = (event.stateMask ^ SWT.ALT) == 0 || (event.stateMask ^ SWT.CTRL) == 0 || (event.stateMask ^ (SWT.ALT | SWT.SHIFT)) == 0 || (event.stateMask ^ (SWT.CTRL | SWT.SHIFT)) == 0;\n        }\n        \n        if (!ignore && event.character > 31 && event.character != SWT.DEL || event.character == SWT.CR || event.character == SWT.LF || event.character == TAB) {\n            doContent(event.character);\n        }\n    } else {\n        invokeAction(action);\n    }\n}",
			"comments":"/**\n* If an action has been registered for the key stroke execute the action.\n* Otherwise, if a character has been entered treat it as new content.\n* <p>\n*\n* @param event keyboard event\n*/\n// special key pressed (e.g., F1)\n// character key pressed\n// see if we have a control character\n// get the character from the CTRL+char sequence, the control\n// key subtracts 64 from the value of the key that it modifies\n// Ignore accelerator key combinations (we do not want to\n// insert a character in the text in this instance). Do not\n// ignore COMMAND+ALT combinations since that key sequence\n// produces characters on the mac.\n// Ignore accelerator key combinations (we do not want to\n// insert a character in the text in this instance). Do not\n// ignore ALT combinations since this key sequence\n// produces characters on motif.\n// Ignore accelerator key combinations (we do not want to\n// insert a character in the text in this instance). Don't\n// ignore CTRL+ALT combinations since that is the Alt Gr\n// key on some keyboards.  See bug 20953.\n// -ignore anything below SPACE except for line delimiter keys and tab.\n// -ignore DEL\n",
			"methodName":"void handleKey(Event event)"
		},
		"boolean isSingleLine()":{
			"methodBody":"{\n    return (getStyle() & SWT.SINGLE) != 0;\n}",
			"comments":"/**\n* Returns whether the widget can have only one line.\n* <p>\n*\n* @return true if widget can have only one line, false if widget can have\n* \tmultiple lines\n*/\n",
			"methodName":"boolean isSingleLine()"
		},
		"public void append(String string)":{
			"methodBody":"{\n    checkWidget();\n    if (string == null) {\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    }\n    int lastChar = Math.max(getCharCount(), 0);\n    replaceTextRange(lastChar, 0, string);\n}",
			"comments":"/**\n* Appends a string to the text at the end of the widget.\n* <p>\n*\n* @param string the string to be appended\n* @see #replaceTextRange(int,int,String)\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT when listener is null</li>\n* </ul>\n*/\n",
			"methodName":"public void append(String string)"
		},
		"public int getKeyBinding(int key)":{
			"methodBody":"{\n    checkWidget();\n    Integer action = (Integer) keyActionMap.get(new Integer(key));\n    int intAction;\n    if (action == null) {\n        intAction = SWT.NULL;\n    } else {\n        intAction = action.intValue();\n    }\n    return intAction;\n}",
			"comments":"/**\n* Returns the action assigned to the key.\n* Returns SWT.NULL if there is no action associated with the key.\n* <p>\n*\n* @param key a key code defined in SWT.java or a character.\n* \tOptionally ORd with a state mask.  Preferred state masks are one or more of\n*  SWT.MOD1, SWT.MOD2, SWT.MOD3, since these masks account for modifier platform\n*  differences.  However, there may be cases where using the specific state masks\n*  (i.e., SWT.CTRL, SWT.SHIFT, SWT.ALT, SWT.COMMAND) makes sense.\n* @return one of the predefined actions defined in ST.java or SWT.NULL\n* \tif there is no action associated with the key.\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getKeyBinding(int key)"
		}
	},
	"ClassORInterfaceName":[
		"StyledText",
		"Printing",
		"RTFWriter",
		"TextWriter",
		"LineCache",
		"ContentWidthCache",
		"WordWrapCache"
	]
}
