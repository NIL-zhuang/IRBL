{
	"variables":[
		"refCount",
		"enumIndex",
		"objIAccessible",
		"objIEnumVARIANT",
		"iaccessible",
		"accessibleListeners",
		"accessibleControlListeners",
		"textListeners",
		"variants",
		"control",
		"ppvObject",
		"result",
		"guid",
		"ppvObject",
		"result",
		"code",
		"event",
		"i",
		"listener",
		"childID",
		"osLeft",
		"osTop",
		"osWidth",
		"osHeight",
		"code",
		"pLeft",
		"pTop",
		"pWidth",
		"pHeight",
		"event",
		"i",
		"listener",
		"code",
		"code",
		"code",
		"event",
		"i",
		"listener",
		"accessible",
		"osChildCount",
		"code",
		"pChildCount",
		"event",
		"i",
		"listener",
		"osDefaultAction",
		"code",
		"pDefaultAction",
		"size",
		"buffer",
		"event",
		"i",
		"listener",
		"data",
		"ptr",
		"osDescription",
		"code",
		"pDescription",
		"size",
		"buffer",
		"event",
		"tree",
		"columnCount",
		"hwnd",
		"hItem",
		"widget",
		"item",
		"i",
		"i",
		"listener",
		"data",
		"ptr",
		"osChild",
		"code",
		"pvt",
		"pChild",
		"event",
		"i",
		"listener",
		"accessible",
		"childID",
		"osHelp",
		"code",
		"pHelp",
		"size",
		"buffer",
		"event",
		"i",
		"listener",
		"data",
		"ptr",
		"code",
		"osKeyboardShortcut",
		"code",
		"pKeyboardShortcut",
		"size",
		"buffer",
		"event",
		"i",
		"listener",
		"data",
		"ptr",
		"osName",
		"code",
		"pName",
		"size",
		"buffer",
		"event",
		"i",
		"listener",
		"data",
		"ptr",
		"osRole",
		"code",
		"pvt",
		"pRole",
		"event",
		"i",
		"listener",
		"role",
		"osChild",
		"code",
		"pvt",
		"pChild",
		"event",
		"i",
		"listener",
		"accessible",
		"childID",
		"osState",
		"code",
		"pvt",
		"pState",
		"event",
		"hwnd",
		"tvItem",
		"result",
		"checked",
		"table",
		"item",
		"i",
		"listener",
		"state",
		"osValue",
		"code",
		"pValue",
		"size",
		"buffer",
		"event",
		"i",
		"listener",
		"data",
		"ptr",
		"code",
		"code",
		"ppvObject",
		"code",
		"ienumvariant",
		"celtFetched",
		"event",
		"i",
		"listener",
		"nextItems",
		"endIndex",
		"i",
		"child",
		"i",
		"nextItem",
		"item",
		"address",
		"ppvObject",
		"code",
		"ienumvariant",
		"ppvObject",
		"code",
		"ienumvariant",
		"osState",
		"state",
		"role",
		"control",
		"COM",
		"control",
		"COM",
		"COM",
		"ppvObject",
		"ppvObject",
		"result",
		"COM",
		"OLE",
		"OLE",
		"result",
		"iaccessible",
		"ppvObject",
		"iaccessible",
		"objIAccessible",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"objIEnumVARIANT",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"control",
		"listener",
		"SWT",
		"SWT",
		"accessibleListeners",
		"listener",
		"listener",
		"SWT",
		"SWT",
		"accessibleControlListeners",
		"listener",
		"listener",
		"SWT",
		"SWT",
		"textListeners",
		"listener",
		"control",
		"iaccessible",
		"iaccessible",
		"iaccessible",
		"objIAccessible",
		"lParam",
		"COM",
		"COM",
		"COM",
		"wParam",
		"objIAccessible",
		"listener",
		"SWT",
		"SWT",
		"accessibleListeners",
		"listener",
		"listener",
		"SWT",
		"SWT",
		"accessibleControlListeners",
		"listener",
		"listener",
		"SWT",
		"SWT",
		"textListeners",
		"listener",
		"COM",
		"COM",
		"control",
		"COM",
		"COM",
		"COM",
		"COM",
		"control",
		"COM",
		"childID",
		"COM",
		"COM",
		"control",
		"COM",
		"COM",
		"COM",
		"COM",
		"control",
		"COM",
		"COM",
		"iaccessible",
		"COM",
		"COM",
		"guid",
		"arg1",
		"GUID",
		"COM",
		"guid",
		"COM",
		"COM",
		"arg2",
		"objIAccessible",
		"COM",
		"COM",
		"guid",
		"COM",
		"COM",
		"arg2",
		"objIAccessible",
		"COM",
		"COM",
		"guid",
		"COM",
		"COM",
		"arg2",
		"objIAccessible",
		"COM",
		"COM",
		"guid",
		"COM",
		"COM",
		"arg2",
		"objIEnumVARIANT",
		"enumIndex",
		"COM",
		"iaccessible",
		"guid",
		"ppvObject",
		"COM",
		"arg2",
		"ppvObject",
		"result",
		"refCount",
		"refCount",
		"refCount",
		"refCount",
		"objIAccessible",
		"objIAccessible",
		"objIAccessible",
		"objIEnumVARIANT",
		"objIEnumVARIANT",
		"objIEnumVARIANT",
		"refCount",
		"iaccessible",
		"COM",
		"iaccessible",
		"varChild_vt",
		"varChild_reserved1",
		"varChild_lVal",
		"varChild_reserved2",
		"code",
		"COM",
		"code",
		"COM",
		"code",
		"iaccessible",
		"COM",
		"accessibleControlListeners",
		"iaccessible",
		"xLeft",
		"yTop",
		"pvarChild",
		"event",
		"ACC",
		"event",
		"xLeft",
		"event",
		"yTop",
		"i",
		"accessibleControlListeners",
		"i",
		"accessibleControlListeners",
		"i",
		"listener",
		"event",
		"event",
		"childID",
		"ACC",
		"iaccessible",
		"xLeft",
		"yTop",
		"pvarChild",
		"COM",
		"pvarChild",
		"COM",
		"COM",
		"pvarChild",
		"childID",
		"COM",
		"iaccessible",
		"COM",
		"varChild_vt",
		"COM",
		"COM",
		"iaccessible",
		"pxLeft",
		"pyTop",
		"pcxWidth",
		"pcyHeight",
		"varChild_vt",
		"varChild_reserved1",
		"varChild_lVal",
		"varChild_reserved2",
		"code",
		"COM",
		"code",
		"COM",
		"accessibleControlListeners",
		"code",
		"code",
		"COM",
		"COM",
		"pLeft",
		"pxLeft",
		"COM",
		"pTop",
		"pyTop",
		"COM",
		"pWidth",
		"pcxWidth",
		"COM",
		"pHeight",
		"pcyHeight",
		"osLeft",
		"pLeft",
		"osTop",
		"pTop",
		"osWidth",
		"pWidth",
		"osHeight",
		"pHeight",
		"event",
		"varChild_lVal",
		"event",
		"osLeft",
		"event",
		"osTop",
		"event",
		"osWidth",
		"event",
		"osHeight",
		"i",
		"accessibleControlListeners",
		"i",
		"accessibleControlListeners",
		"i",
		"listener",
		"event",
		"OS",
		"pxLeft",
		"event",
		"OS",
		"pyTop",
		"event",
		"OS",
		"pcxWidth",
		"event",
		"OS",
		"pcyHeight",
		"event",
		"COM",
		"iaccessible",
		"COM",
		"iaccessible",
		"navDir",
		"varStart_vt",
		"varStart_reserved1",
		"varStart_lVal",
		"varStart_reserved2",
		"pvarEndUpAt",
		"code",
		"COM",
		"code",
		"COM",
		"code",
		"iaccessible",
		"COM",
		"iaccessible",
		"flagsSelect",
		"varChild_vt",
		"varChild_reserved1",
		"varChild_lVal",
		"varChild_reserved2",
		"code",
		"COM",
		"code",
		"COM",
		"code",
		"iaccessible",
		"COM",
		"varChild_vt",
		"COM",
		"COM",
		"accessibleControlListeners",
		"iaccessible",
		"varChild_vt",
		"varChild_reserved1",
		"varChild_lVal",
		"varChild_reserved2",
		"ppdispChild",
		"code",
		"COM",
		"code",
		"COM",
		"code",
		"event",
		"varChild_lVal",
		"i",
		"accessibleControlListeners",
		"i",
		"accessibleControlListeners",
		"i",
		"listener",
		"event",
		"event",
		"accessible",
		"COM",
		"ppdispChild",
		"accessible",
		"COM",
		"COM",
		"iaccessible",
		"COM",
		"iaccessible",
		"pcountChildren",
		"accessibleControlListeners",
		"code",
		"code",
		"COM",
		"COM",
		"pChildCount",
		"pcountChildren",
		"osChildCount",
		"pChildCount",
		"event",
		"ACC",
		"event",
		"osChildCount",
		"i",
		"accessibleControlListeners",
		"i",
		"accessibleControlListeners",
		"i",
		"listener",
		"event",
		"COM",
		"pcountChildren",
		"event",
		"COM",
		"iaccessible",
		"COM",
		"varChild_vt",
		"COM",
		"COM",
		"iaccessible",
		"varChild_vt",
		"varChild_reserved1",
		"varChild_lVal",
		"varChild_reserved2",
		"pszDefaultAction",
		"code",
		"COM",
		"code",
		"COM",
		"accessibleControlListeners",
		"code",
		"code",
		"COM",
		"COM",
		"pDefaultAction",
		"pszDefaultAction",
		"COM",
		"pDefaultAction",
		"size",
		"size",
		"COM",
		"buffer",
		"pDefaultAction",
		"size",
		"osDefaultAction",
		"buffer",
		"event",
		"varChild_lVal",
		"event",
		"osDefaultAction",
		"i",
		"accessibleControlListeners",
		"i",
		"accessibleControlListeners",
		"i",
		"listener",
		"event",
		"event",
		"code",
		"event",
		"COM",
		"data",
		"COM",
		"pszDefaultAction",
		"ptr",
		"COM",
		"iaccessible",
		"COM",
		"varChild_vt",
		"COM",
		"COM",
		"iaccessible",
		"varChild_vt",
		"varChild_reserved1",
		"varChild_lVal",
		"varChild_reserved2",
		"pszDescription",
		"code",
		"COM",
		"code",
		"COM",
		"accessibleListeners",
		"control",
		"code",
		"code",
		"COM",
		"COM",
		"pDescription",
		"pszDescription",
		"COM",
		"pDescription",
		"size",
		"size",
		"COM",
		"buffer",
		"pDescription",
		"size",
		"osDescription",
		"buffer",
		"event",
		"varChild_lVal",
		"event",
		"osDescription",
		"varChild_lVal",
		"COM",
		"control",
		"control",
		"tree",
		"columnCount",
		"control",
		"OS",
		"hItem",
		"OS",
		"hwnd",
		"OS",
		"varChild_lVal",
		"hItem",
		"varChild_lVal",
		"tree",
		"hwnd",
		"hItem",
		"event",
		"widget",
		"widget",
		"widget",
		"i",
		"columnCount",
		"i",
		"event",
		"tree",
		"i",
		"item",
		"i",
		"i",
		"columnCount",
		"event",
		"i",
		"accessibleListeners",
		"i",
		"accessibleListeners",
		"i",
		"listener",
		"event",
		"event",
		"code",
		"event",
		"COM",
		"data",
		"COM",
		"pszDescription",
		"ptr",
		"COM",
		"iaccessible",
		"COM",
		"ACC",
		"iaccessible",
		"pvarChild",
		"accessibleControlListeners",
		"code",
		"code",
		"COM",
		"COM",
		"pvt",
		"pvarChild",
		"pvt",
		"COM",
		"COM",
		"pChild",
		"pvarChild",
		"osChild",
		"pChild",
		"event",
		"osChild",
		"i",
		"accessibleControlListeners",
		"i",
		"accessibleControlListeners",
		"i",
		"listener",
		"event",
		"event",
		"accessible",
		"COM",
		"pvarChild",
		"COM",
		"COM",
		"pvarChild",
		"accessible",
		"COM",
		"event",
		"childID",
		"ACC",
		"COM",
		"pvarChild",
		"COM",
		"COM",
		"childID",
		"ACC",
		"COM",
		"pvarChild",
		"COM",
		"COM",
		"pvarChild",
		"objIAccessible",
		"COM",
		"COM",
		"pvarChild",
		"COM",
		"COM",
		"pvarChild",
		"childID",
		"COM",
		"iaccessible",
		"COM",
		"varChild_vt",
		"COM",
		"COM",
		"iaccessible",
		"varChild_vt",
		"varChild_reserved1",
		"varChild_lVal",
		"varChild_reserved2",
		"pszHelp",
		"code",
		"COM",
		"code",
		"COM",
		"accessibleListeners",
		"code",
		"code",
		"COM",
		"COM",
		"pHelp",
		"pszHelp",
		"COM",
		"pHelp",
		"size",
		"size",
		"COM",
		"buffer",
		"pHelp",
		"size",
		"osHelp",
		"buffer",
		"event",
		"varChild_lVal",
		"event",
		"osHelp",
		"i",
		"accessibleListeners",
		"i",
		"accessibleListeners",
		"i",
		"listener",
		"event",
		"event",
		"code",
		"event",
		"COM",
		"data",
		"COM",
		"pszHelp",
		"ptr",
		"COM",
		"iaccessible",
		"COM",
		"iaccessible",
		"pszHelpFile",
		"varChild_vt",
		"varChild_reserved1",
		"varChild_lVal",
		"varChild_reserved2",
		"pidTopic",
		"code",
		"COM",
		"code",
		"COM",
		"code",
		"iaccessible",
		"COM",
		"varChild_vt",
		"COM",
		"COM",
		"iaccessible",
		"varChild_vt",
		"varChild_reserved1",
		"varChild_lVal",
		"varChild_reserved2",
		"pszKeyboardShortcut",
		"code",
		"COM",
		"code",
		"COM",
		"accessibleListeners",
		"code",
		"code",
		"COM",
		"COM",
		"pKeyboardShortcut",
		"pszKeyboardShortcut",
		"COM",
		"pKeyboardShortcut",
		"size",
		"size",
		"COM",
		"buffer",
		"pKeyboardShortcut",
		"size",
		"osKeyboardShortcut",
		"buffer",
		"event",
		"varChild_lVal",
		"event",
		"osKeyboardShortcut",
		"i",
		"accessibleListeners",
		"i",
		"accessibleListeners",
		"i",
		"listener",
		"event",
		"event",
		"code",
		"event",
		"COM",
		"data",
		"COM",
		"pszKeyboardShortcut",
		"ptr",
		"COM",
		"iaccessible",
		"COM",
		"varChild_vt",
		"COM",
		"COM",
		"iaccessible",
		"varChild_vt",
		"varChild_reserved1",
		"varChild_lVal",
		"varChild_reserved2",
		"pszName",
		"code",
		"COM",
		"code",
		"COM",
		"accessibleListeners",
		"code",
		"code",
		"COM",
		"COM",
		"pName",
		"pszName",
		"COM",
		"pName",
		"size",
		"size",
		"COM",
		"buffer",
		"pName",
		"size",
		"osName",
		"buffer",
		"event",
		"varChild_lVal",
		"event",
		"osName",
		"i",
		"accessibleListeners",
		"i",
		"accessibleListeners",
		"i",
		"listener",
		"event",
		"event",
		"code",
		"event",
		"COM",
		"data",
		"COM",
		"pszName",
		"ptr",
		"COM",
		"iaccessible",
		"COM",
		"iaccessible",
		"ppdispParent",
		"iaccessible",
		"COM",
		"varChild_vt",
		"COM",
		"COM",
		"COM",
		"iaccessible",
		"varChild_vt",
		"varChild_reserved1",
		"varChild_lVal",
		"varChild_reserved2",
		"pvarRole",
		"code",
		"COM",
		"code",
		"COM",
		"accessibleControlListeners",
		"control",
		"control",
		"code",
		"code",
		"COM",
		"COM",
		"pvt",
		"pvarRole",
		"pvt",
		"COM",
		"COM",
		"pRole",
		"pvarRole",
		"osRole",
		"pRole",
		"event",
		"varChild_lVal",
		"event",
		"osRole",
		"varChild_lVal",
		"COM",
		"control",
		"control",
		"control",
		"SWT",
		"event",
		"ACC",
		"i",
		"accessibleControlListeners",
		"i",
		"accessibleControlListeners",
		"i",
		"listener",
		"event",
		"event",
		"COM",
		"pvarRole",
		"COM",
		"COM",
		"pvarRole",
		"role",
		"COM",
		"iaccessible",
		"COM",
		"ACC",
		"iaccessible",
		"pvarChildren",
		"accessibleControlListeners",
		"code",
		"code",
		"COM",
		"COM",
		"pvt",
		"pvarChildren",
		"pvt",
		"COM",
		"COM",
		"pChild",
		"pvarChildren",
		"osChild",
		"pChild",
		"pvt",
		"COM",
		"osChild",
		"ACC",
		"event",
		"osChild",
		"i",
		"accessibleControlListeners",
		"i",
		"accessibleControlListeners",
		"i",
		"listener",
		"event",
		"event",
		"accessible",
		"COM",
		"pvarChildren",
		"COM",
		"COM",
		"pvarChildren",
		"accessible",
		"COM",
		"event",
		"childID",
		"ACC",
		"COM",
		"pvarChildren",
		"COM",
		"COM",
		"childID",
		"ACC",
		"COM",
		"pvarChildren",
		"COM",
		"COM",
		"pvarChildren",
		"objIAccessible",
		"COM",
		"childID",
		"ACC",
		"COM",
		"pvarChildren",
		"COM",
		"COM",
		"pvarChildren",
		"objIAccessible",
		"COM",
		"COM",
		"pvarChildren",
		"COM",
		"COM",
		"pvarChildren",
		"childID",
		"COM",
		"iaccessible",
		"COM",
		"varChild_vt",
		"COM",
		"COM",
		"iaccessible",
		"varChild_vt",
		"varChild_reserved1",
		"varChild_lVal",
		"varChild_reserved2",
		"pvarState",
		"code",
		"COM",
		"code",
		"COM",
		"accessibleControlListeners",
		"control",
		"control",
		"code",
		"code",
		"COM",
		"COM",
		"pvt",
		"pvarState",
		"pvt",
		"COM",
		"COM",
		"pState",
		"pvarState",
		"osState",
		"pState",
		"event",
		"varChild_lVal",
		"event",
		"osState",
		"varChild_lVal",
		"COM",
		"control",
		"control",
		"SWT",
		"control",
		"tvItem",
		"OS",
		"OS",
		"tvItem",
		"OS",
		"OS",
		"tvItem",
		"OS",
		"hwnd",
		"OS",
		"varChild_lVal",
		"tvItem",
		"varChild_lVal",
		"OS",
		"hwnd",
		"OS",
		"tvItem",
		"result",
		"tvItem",
		"checked",
		"event",
		"ACC",
		"control",
		"control",
		"SWT",
		"control",
		"table",
		"event",
		"item",
		"item",
		"event",
		"ACC",
		"i",
		"accessibleControlListeners",
		"i",
		"accessibleControlListeners",
		"i",
		"listener",
		"event",
		"event",
		"COM",
		"pvarState",
		"COM",
		"COM",
		"pvarState",
		"state",
		"COM",
		"iaccessible",
		"COM",
		"varChild_vt",
		"COM",
		"COM",
		"iaccessible",
		"varChild_vt",
		"varChild_reserved1",
		"varChild_lVal",
		"varChild_reserved2",
		"pszValue",
		"code",
		"COM",
		"code",
		"COM",
		"accessibleControlListeners",
		"code",
		"code",
		"COM",
		"COM",
		"pValue",
		"pszValue",
		"COM",
		"pValue",
		"size",
		"size",
		"COM",
		"buffer",
		"pValue",
		"size",
		"osValue",
		"buffer",
		"event",
		"varChild_lVal",
		"event",
		"osValue",
		"i",
		"accessibleControlListeners",
		"i",
		"accessibleControlListeners",
		"i",
		"listener",
		"event",
		"event",
		"code",
		"event",
		"COM",
		"data",
		"COM",
		"pszValue",
		"ptr",
		"COM",
		"iaccessible",
		"COM",
		"iaccessible",
		"varChild_vt",
		"varChild_reserved1",
		"varChild_lVal",
		"varChild_reserved2",
		"szName",
		"code",
		"COM",
		"code",
		"COM",
		"code",
		"iaccessible",
		"COM",
		"iaccessible",
		"varChild_vt",
		"varChild_reserved1",
		"varChild_lVal",
		"varChild_reserved2",
		"szValue",
		"code",
		"COM",
		"code",
		"COM",
		"code",
		"accessibleControlListeners",
		"iaccessible",
		"COM",
		"ppvObject",
		"code",
		"COM",
		"code",
		"ppvObject",
		"code",
		"ienumvariant",
		"celt",
		"rgvar",
		"celtFetched",
		"COM",
		"pceltFetched",
		"celtFetched",
		"code",
		"rgvar",
		"COM",
		"pceltFetched",
		"celt",
		"COM",
		"enumIndex",
		"event",
		"ACC",
		"i",
		"accessibleControlListeners",
		"i",
		"accessibleControlListeners",
		"i",
		"listener",
		"event",
		"variants",
		"event",
		"variants",
		"celt",
		"enumIndex",
		"celt",
		"endIndex",
		"variants",
		"endIndex",
		"variants",
		"enumIndex",
		"endIndex",
		"nextItems",
		"endIndex",
		"enumIndex",
		"i",
		"nextItems",
		"i",
		"variants",
		"enumIndex",
		"child",
		"nextItems",
		"i",
		"child",
		"nextItems",
		"i",
		"child",
		"enumIndex",
		"nextItems",
		"i",
		"nextItems",
		"i",
		"nextItems",
		"i",
		"nextItem",
		"nextItem",
		"COM",
		"rgvar",
		"i",
		"COM",
		"COM",
		"rgvar",
		"i",
		"item",
		"nextItem",
		"COM",
		"rgvar",
		"i",
		"COM",
		"COM",
		"rgvar",
		"i",
		"address",
		"pceltFetched",
		"COM",
		"pceltFetched",
		"nextItems",
		"nextItems",
		"celt",
		"COM",
		"pceltFetched",
		"COM",
		"pceltFetched",
		"COM",
		"accessibleControlListeners",
		"iaccessible",
		"COM",
		"ppvObject",
		"code",
		"COM",
		"code",
		"ppvObject",
		"code",
		"ienumvariant",
		"celt",
		"code",
		"celt",
		"COM",
		"enumIndex",
		"celt",
		"enumIndex",
		"variants",
		"enumIndex",
		"variants",
		"COM",
		"COM",
		"accessibleControlListeners",
		"iaccessible",
		"COM",
		"ppvObject",
		"code",
		"COM",
		"code",
		"ppvObject",
		"code",
		"ienumvariant",
		"code",
		"enumIndex",
		"COM",
		"childID",
		"ACC",
		"COM",
		"control",
		"childID",
		"OS",
		"childID",
		"OS",
		"control",
		"OS",
		"childID",
		"osChildID",
		"COM",
		"ACC",
		"control",
		"osChildID",
		"OS",
		"osChildID",
		"OS",
		"control",
		"OS",
		"osChildID",
		"state",
		"ACC",
		"osState",
		"COM",
		"state",
		"ACC",
		"osState",
		"COM",
		"state",
		"ACC",
		"osState",
		"COM",
		"state",
		"ACC",
		"osState",
		"COM",
		"state",
		"ACC",
		"osState",
		"COM",
		"state",
		"ACC",
		"osState",
		"COM",
		"state",
		"ACC",
		"osState",
		"COM",
		"state",
		"ACC",
		"osState",
		"COM",
		"state",
		"ACC",
		"osState",
		"COM",
		"state",
		"ACC",
		"osState",
		"COM",
		"state",
		"ACC",
		"osState",
		"COM",
		"state",
		"ACC",
		"osState",
		"COM",
		"state",
		"ACC",
		"osState",
		"COM",
		"state",
		"ACC",
		"osState",
		"COM",
		"state",
		"ACC",
		"osState",
		"COM",
		"state",
		"ACC",
		"osState",
		"COM",
		"osState",
		"ACC",
		"osState",
		"COM",
		"state",
		"ACC",
		"osState",
		"COM",
		"state",
		"ACC",
		"osState",
		"COM",
		"state",
		"ACC",
		"osState",
		"COM",
		"state",
		"ACC",
		"osState",
		"COM",
		"state",
		"ACC",
		"osState",
		"COM",
		"state",
		"ACC",
		"osState",
		"COM",
		"state",
		"ACC",
		"osState",
		"COM",
		"state",
		"ACC",
		"osState",
		"COM",
		"state",
		"ACC",
		"osState",
		"COM",
		"state",
		"ACC",
		"osState",
		"COM",
		"state",
		"ACC",
		"osState",
		"COM",
		"state",
		"ACC",
		"osState",
		"COM",
		"state",
		"ACC",
		"osState",
		"COM",
		"state",
		"ACC",
		"osState",
		"COM",
		"state",
		"ACC",
		"osState",
		"COM",
		"state",
		"ACC",
		"state",
		"role",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"COM",
		"COM",
		"osRole",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"COM",
		"ACC",
		"role",
		"SWT",
		"SWT",
		"control",
		"SWT",
		"SWT",
		"control",
		"Thread",
		"control",
		"handle",
		"OBJID_CLIENT",
		"IIDIAccessible",
		"S_OK",
		"ERROR_CANNOT_CREATE_OBJECT",
		"ERROR_NULL_ARGUMENT",
		"ERROR_NULL_ARGUMENT",
		"ERROR_NULL_ARGUMENT",
		"OBJID_CLIENT",
		"IIDIAccessible",
		"ERROR_NULL_ARGUMENT",
		"ERROR_NULL_ARGUMENT",
		"ERROR_NULL_ARGUMENT",
		"EVENT_OBJECT_SELECTIONWITHIN",
		"handle",
		"OBJID_CLIENT",
		"CHILDID_SELF",
		"EVENT_OBJECT_FOCUS",
		"handle",
		"OBJID_CLIENT",
		"EVENT_OBJECT_LOCATIONCHANGE",
		"handle",
		"OBJID_CARET",
		"CHILDID_SELF",
		"EVENT_OBJECT_VALUECHANGE",
		"handle",
		"OBJID_CLIENT",
		"CHILDID_SELF",
		"CO_E_OBJNOTCONNECTED",
		"sizeof",
		"IIDIUnknown",
		"S_OK",
		"IIDIDispatch",
		"S_OK",
		"IIDIAccessible",
		"S_OK",
		"IIDIEnumVARIANT",
		"S_OK",
		"CO_E_OBJNOTCONNECTED",
		"E_INVALIDARG",
		"S_FALSE",
		"CO_E_OBJNOTCONNECTED",
		"childID",
		"CHILDID_NONE",
		"x",
		"y",
		"childID",
		"CHILDID_NONE",
		"VT_I4",
		"S_OK",
		"CO_E_OBJNOTCONNECTED",
		"VT_I4",
		"E_INVALIDARG",
		"E_INVALIDARG",
		"S_FALSE",
		"S_OK",
		"childID",
		"x",
		"y",
		"width",
		"height",
		"x",
		"y",
		"width",
		"height",
		"S_OK",
		"CO_E_OBJNOTCONNECTED",
		"E_INVALIDARG",
		"S_FALSE",
		"CO_E_OBJNOTCONNECTED",
		"E_INVALIDARG",
		"S_FALSE",
		"CO_E_OBJNOTCONNECTED",
		"VT_I4",
		"E_INVALIDARG",
		"E_INVALIDARG",
		"S_FALSE",
		"childID",
		"accessible",
		"objIAccessible",
		"S_OK",
		"S_FALSE",
		"CO_E_OBJNOTCONNECTED",
		"S_OK",
		"childID",
		"CHILDID_SELF",
		"detail",
		"detail",
		"S_OK",
		"CO_E_OBJNOTCONNECTED",
		"VT_I4",
		"E_INVALIDARG",
		"E_INVALIDARG",
		"S_FALSE",
		"S_OK",
		"childID",
		"result",
		"result",
		"result",
		"S_OK",
		"CO_E_OBJNOTCONNECTED",
		"VT_I4",
		"E_INVALIDARG",
		"E_INVALIDARG",
		"S_FALSE",
		"S_OK",
		"childID",
		"result",
		"CHILDID_SELF",
		"handle",
		"COMCTL32_MAJOR",
		"TVM_MAPACCIDTOHTREEITEM",
		"result",
		"result",
		"result",
		"result",
		"result",
		"S_OK",
		"CO_E_OBJNOTCONNECTED",
		"CHILDID_NONE",
		"S_OK",
		"VT_I4",
		"childID",
		"accessible",
		"VT_DISPATCH",
		"objIAccessible",
		"S_OK",
		"childID",
		"CHILDID_NONE",
		"VT_EMPTY",
		"S_FALSE",
		"CHILDID_SELF",
		"VT_DISPATCH",
		"S_OK",
		"VT_I4",
		"S_OK",
		"CO_E_OBJNOTCONNECTED",
		"VT_I4",
		"E_INVALIDARG",
		"E_INVALIDARG",
		"S_FALSE",
		"S_OK",
		"childID",
		"result",
		"result",
		"result",
		"S_OK",
		"CO_E_OBJNOTCONNECTED",
		"E_INVALIDARG",
		"S_FALSE",
		"CO_E_OBJNOTCONNECTED",
		"VT_I4",
		"E_INVALIDARG",
		"E_INVALIDARG",
		"S_FALSE",
		"S_OK",
		"childID",
		"result",
		"result",
		"result",
		"S_OK",
		"CO_E_OBJNOTCONNECTED",
		"VT_I4",
		"E_INVALIDARG",
		"E_INVALIDARG",
		"S_FALSE",
		"S_OK",
		"childID",
		"result",
		"result",
		"result",
		"S_OK",
		"CO_E_OBJNOTCONNECTED",
		"CO_E_OBJNOTCONNECTED",
		"VT_I4",
		"E_INVALIDARG",
		"ROLE_SYSTEM_CLIENT",
		"E_INVALIDARG",
		"S_FALSE",
		"S_OK",
		"VT_I4",
		"childID",
		"detail",
		"CHILDID_SELF",
		"CHECK",
		"detail",
		"ROLE_CHECKBUTTON",
		"detail",
		"VT_I4",
		"S_OK",
		"CO_E_OBJNOTCONNECTED",
		"CHILDID_NONE",
		"S_OK",
		"VT_I4",
		"VT_UNKNOWN",
		"CHILDID_MULTIPLE",
		"childID",
		"accessible",
		"VT_DISPATCH",
		"objIAccessible",
		"S_OK",
		"childID",
		"CHILDID_NONE",
		"VT_EMPTY",
		"S_FALSE",
		"CHILDID_MULTIPLE",
		"VT_UNKNOWN",
		"S_OK",
		"CHILDID_SELF",
		"VT_DISPATCH",
		"S_OK",
		"VT_I4",
		"S_OK",
		"CO_E_OBJNOTCONNECTED",
		"VT_I4",
		"E_INVALIDARG",
		"E_INVALIDARG",
		"S_FALSE",
		"S_OK",
		"VT_I4",
		"childID",
		"detail",
		"CHILDID_SELF",
		"CHECK",
		"handle",
		"mask",
		"TVIF_HANDLE",
		"TVIF_STATE",
		"stateMask",
		"TVIS_STATEIMAGEMASK",
		"COMCTL32_MAJOR",
		"hItem",
		"TVM_MAPACCIDTOHTREEITEM",
		"hItem",
		"TVM_GETITEM",
		"state",
		"detail",
		"STATE_CHECKED",
		"CHECK",
		"childID",
		"detail",
		"STATE_CHECKED",
		"detail",
		"VT_I4",
		"S_OK",
		"CO_E_OBJNOTCONNECTED",
		"VT_I4",
		"E_INVALIDARG",
		"E_INVALIDARG",
		"S_FALSE",
		"S_OK",
		"childID",
		"result",
		"result",
		"result",
		"S_OK",
		"CO_E_OBJNOTCONNECTED",
		"E_INVALIDARG",
		"S_FALSE",
		"CO_E_OBJNOTCONNECTED",
		"E_INVALIDARG",
		"S_FALSE",
		"IIDIEnumVARIANT",
		"S_OK",
		"E_INVALIDARG",
		"E_INVALIDARG",
		"childID",
		"CHILDID_SELF",
		"children",
		"length",
		"length",
		"length",
		"length",
		"VT_I4",
		"objIAccessible",
		"VT_DISPATCH",
		"length",
		"length",
		"S_OK",
		"S_FALSE",
		"IIDIEnumVARIANT",
		"S_OK",
		"E_INVALIDARG",
		"length",
		"length",
		"S_FALSE",
		"S_OK",
		"IIDIEnumVARIANT",
		"S_OK",
		"S_OK",
		"CHILDID_SELF",
		"CHILDID_SELF",
		"COMCTL32_MAJOR",
		"handle",
		"TVM_MAPHTREEITEMTOACCID",
		"CHILDID_SELF",
		"CHILDID_SELF",
		"COMCTL32_MAJOR",
		"handle",
		"TVM_MAPACCIDTOHTREEITEM",
		"STATE_SELECTED",
		"STATE_SYSTEM_SELECTED",
		"STATE_SELECTABLE",
		"STATE_SYSTEM_SELECTABLE",
		"STATE_MULTISELECTABLE",
		"STATE_SYSTEM_MULTISELECTABLE",
		"STATE_FOCUSED",
		"STATE_SYSTEM_FOCUSED",
		"STATE_FOCUSABLE",
		"STATE_SYSTEM_FOCUSABLE",
		"STATE_PRESSED",
		"STATE_SYSTEM_PRESSED",
		"STATE_CHECKED",
		"STATE_SYSTEM_CHECKED",
		"STATE_EXPANDED",
		"STATE_SYSTEM_EXPANDED",
		"STATE_COLLAPSED",
		"STATE_SYSTEM_COLLAPSED",
		"STATE_HOTTRACKED",
		"STATE_SYSTEM_HOTTRACKED",
		"STATE_BUSY",
		"STATE_SYSTEM_BUSY",
		"STATE_READONLY",
		"STATE_SYSTEM_READONLY",
		"STATE_INVISIBLE",
		"STATE_SYSTEM_INVISIBLE",
		"STATE_OFFSCREEN",
		"STATE_SYSTEM_OFFSCREEN",
		"STATE_SIZEABLE",
		"STATE_SYSTEM_SIZEABLE",
		"STATE_LINKED",
		"STATE_SYSTEM_LINKED",
		"STATE_NORMAL",
		"STATE_SYSTEM_SELECTED",
		"STATE_SELECTED",
		"STATE_SYSTEM_SELECTABLE",
		"STATE_SELECTABLE",
		"STATE_SYSTEM_MULTISELECTABLE",
		"STATE_MULTISELECTABLE",
		"STATE_SYSTEM_FOCUSED",
		"STATE_FOCUSED",
		"STATE_SYSTEM_FOCUSABLE",
		"STATE_FOCUSABLE",
		"STATE_SYSTEM_PRESSED",
		"STATE_PRESSED",
		"STATE_SYSTEM_CHECKED",
		"STATE_CHECKED",
		"STATE_SYSTEM_EXPANDED",
		"STATE_EXPANDED",
		"STATE_SYSTEM_COLLAPSED",
		"STATE_COLLAPSED",
		"STATE_SYSTEM_HOTTRACKED",
		"STATE_HOTTRACKED",
		"STATE_SYSTEM_BUSY",
		"STATE_BUSY",
		"STATE_SYSTEM_READONLY",
		"STATE_READONLY",
		"STATE_SYSTEM_INVISIBLE",
		"STATE_INVISIBLE",
		"STATE_SYSTEM_OFFSCREEN",
		"STATE_OFFSCREEN",
		"STATE_SYSTEM_SIZEABLE",
		"STATE_SIZEABLE",
		"STATE_SYSTEM_LINKED",
		"STATE_LINKED",
		"ROLE_CLIENT_AREA",
		"ROLE_SYSTEM_CLIENT",
		"ROLE_WINDOW",
		"ROLE_SYSTEM_WINDOW",
		"ROLE_MENUBAR",
		"ROLE_SYSTEM_MENUBAR",
		"ROLE_MENU",
		"ROLE_SYSTEM_MENUPOPUP",
		"ROLE_MENUITEM",
		"ROLE_SYSTEM_MENUITEM",
		"ROLE_SEPARATOR",
		"ROLE_SYSTEM_SEPARATOR",
		"ROLE_TOOLTIP",
		"ROLE_SYSTEM_TOOLTIP",
		"ROLE_SCROLLBAR",
		"ROLE_SYSTEM_SCROLLBAR",
		"ROLE_DIALOG",
		"ROLE_SYSTEM_DIALOG",
		"ROLE_LABEL",
		"ROLE_SYSTEM_STATICTEXT",
		"ROLE_PUSHBUTTON",
		"ROLE_SYSTEM_PUSHBUTTON",
		"ROLE_CHECKBUTTON",
		"ROLE_SYSTEM_CHECKBUTTON",
		"ROLE_RADIOBUTTON",
		"ROLE_SYSTEM_RADIOBUTTON",
		"ROLE_COMBOBOX",
		"ROLE_SYSTEM_COMBOBOX",
		"ROLE_TEXT",
		"ROLE_SYSTEM_TEXT",
		"ROLE_TOOLBAR",
		"ROLE_SYSTEM_TOOLBAR",
		"ROLE_LIST",
		"ROLE_SYSTEM_LIST",
		"ROLE_LISTITEM",
		"ROLE_SYSTEM_LISTITEM",
		"ROLE_TABLE",
		"ROLE_SYSTEM_TABLE",
		"ROLE_TABLECELL",
		"ROLE_SYSTEM_CELL",
		"ROLE_TABLECOLUMNHEADER",
		"ROLE_SYSTEM_COLUMNHEADER",
		"ROLE_TABLEROWHEADER",
		"ROLE_SYSTEM_ROWHEADER",
		"ROLE_TREE",
		"ROLE_SYSTEM_OUTLINE",
		"ROLE_TREEITEM",
		"ROLE_SYSTEM_OUTLINEITEM",
		"ROLE_TABFOLDER",
		"ROLE_SYSTEM_PAGETABLIST",
		"ROLE_TABITEM",
		"ROLE_SYSTEM_PAGETAB",
		"ROLE_PROGRESSBAR",
		"ROLE_SYSTEM_PROGRESSBAR",
		"ROLE_SLIDER",
		"ROLE_SYSTEM_SLIDER",
		"ROLE_LINK",
		"ROLE_SYSTEM_LINK",
		"ROLE_SYSTEM_CLIENT",
		"ROLE_SYSTEM_CLIENT",
		"ROLE_SYSTEM_CLIENT",
		"ROLE_CLIENT_AREA",
		"ROLE_SYSTEM_WINDOW",
		"ROLE_WINDOW",
		"ROLE_SYSTEM_MENUBAR",
		"ROLE_MENUBAR",
		"ROLE_SYSTEM_MENUPOPUP",
		"ROLE_MENU",
		"ROLE_SYSTEM_MENUITEM",
		"ROLE_MENUITEM",
		"ROLE_SYSTEM_SEPARATOR",
		"ROLE_SEPARATOR",
		"ROLE_SYSTEM_TOOLTIP",
		"ROLE_TOOLTIP",
		"ROLE_SYSTEM_SCROLLBAR",
		"ROLE_SCROLLBAR",
		"ROLE_SYSTEM_DIALOG",
		"ROLE_DIALOG",
		"ROLE_SYSTEM_STATICTEXT",
		"ROLE_LABEL",
		"ROLE_SYSTEM_PUSHBUTTON",
		"ROLE_PUSHBUTTON",
		"ROLE_SYSTEM_CHECKBUTTON",
		"ROLE_CHECKBUTTON",
		"ROLE_SYSTEM_RADIOBUTTON",
		"ROLE_RADIOBUTTON",
		"ROLE_SYSTEM_COMBOBOX",
		"ROLE_COMBOBOX",
		"ROLE_SYSTEM_TEXT",
		"ROLE_TEXT",
		"ROLE_SYSTEM_TOOLBAR",
		"ROLE_TOOLBAR",
		"ROLE_SYSTEM_LIST",
		"ROLE_LIST",
		"ROLE_SYSTEM_LISTITEM",
		"ROLE_LISTITEM",
		"ROLE_SYSTEM_TABLE",
		"ROLE_TABLE",
		"ROLE_SYSTEM_CELL",
		"ROLE_TABLECELL",
		"ROLE_SYSTEM_COLUMNHEADER",
		"ROLE_TABLECOLUMNHEADER",
		"ROLE_SYSTEM_ROWHEADER",
		"ROLE_TABLEROWHEADER",
		"ROLE_SYSTEM_OUTLINE",
		"ROLE_TREE",
		"ROLE_SYSTEM_OUTLINEITEM",
		"ROLE_TREEITEM",
		"ROLE_SYSTEM_PAGETABLIST",
		"ROLE_TABFOLDER",
		"ROLE_SYSTEM_PAGETAB",
		"ROLE_TABITEM",
		"ROLE_SYSTEM_PROGRESSBAR",
		"ROLE_PROGRESSBAR",
		"ROLE_SYSTEM_SLIDER",
		"ROLE_SLIDER",
		"ROLE_SYSTEM_LINK",
		"ROLE_LINK",
		"ERROR_THREAD_INVALID_ACCESS",
		"ERROR_WIDGET_DISPOSED",
		"control",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"args",
		"control",
		"listener",
		"listener",
		"listener",
		"wParam",
		"lParam",
		"listener",
		"listener",
		"listener",
		"childID",
		"index",
		"type",
		"startIndex",
		"length",
		"arg1",
		"arg2",
		"varChild_vt",
		"varChild_reserved1",
		"varChild_lVal",
		"varChild_reserved2",
		"xLeft",
		"yTop",
		"pvarChild",
		"pxLeft",
		"pyTop",
		"pcxWidth",
		"pcyHeight",
		"varChild_vt",
		"varChild_reserved1",
		"varChild_lVal",
		"varChild_reserved2",
		"navDir",
		"varStart_vt",
		"varStart_reserved1",
		"varStart_lVal",
		"varStart_reserved2",
		"pvarEndUpAt",
		"flagsSelect",
		"varChild_vt",
		"varChild_reserved1",
		"varChild_lVal",
		"varChild_reserved2",
		"varChild_vt",
		"varChild_reserved1",
		"varChild_lVal",
		"varChild_reserved2",
		"ppdispChild",
		"pcountChildren",
		"varChild_vt",
		"varChild_reserved1",
		"varChild_lVal",
		"varChild_reserved2",
		"pszDefaultAction",
		"varChild_vt",
		"varChild_reserved1",
		"varChild_lVal",
		"varChild_reserved2",
		"pszDescription",
		"pvarChild",
		"varChild_vt",
		"varChild_reserved1",
		"varChild_lVal",
		"varChild_reserved2",
		"pszHelp",
		"pszHelpFile",
		"varChild_vt",
		"varChild_reserved1",
		"varChild_lVal",
		"varChild_reserved2",
		"pidTopic",
		"varChild_vt",
		"varChild_reserved1",
		"varChild_lVal",
		"varChild_reserved2",
		"pszKeyboardShortcut",
		"varChild_vt",
		"varChild_reserved1",
		"varChild_lVal",
		"varChild_reserved2",
		"pszName",
		"ppdispParent",
		"varChild_vt",
		"varChild_reserved1",
		"varChild_lVal",
		"varChild_reserved2",
		"pvarRole",
		"pvarChildren",
		"varChild_vt",
		"varChild_reserved1",
		"varChild_lVal",
		"varChild_reserved2",
		"pvarState",
		"varChild_vt",
		"varChild_reserved1",
		"varChild_lVal",
		"varChild_reserved2",
		"pszValue",
		"varChild_vt",
		"varChild_reserved1",
		"varChild_lVal",
		"varChild_reserved2",
		"szName",
		"varChild_vt",
		"varChild_reserved1",
		"varChild_lVal",
		"varChild_reserved2",
		"szValue",
		"celt",
		"rgvar",
		"pceltFetched",
		"celt",
		"childID",
		"osChildID",
		"state",
		"osState",
		"role",
		"osRole"
	],
	"extendORImplementFiles":[],
	"package":[
		"org.eclipse.swt.accessibility"
	],
	"import":[
		"java.util.Vector",
		"org.eclipse.swt",
		"org.eclipse.swt.widgets",
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt.ole.win32",
		"org.eclipse.swt.internal.ole.win32"
	],
	"methods":[
		"method0",
		"method1",
		"method2",
		"method7",
		"method8",
		"method9",
		"method10",
		"method11",
		"method12",
		"method13",
		"method14",
		"method15",
		"method16",
		"method17",
		"method18",
		"method19",
		"method20",
		"method21",
		"method22",
		"method23",
		"method24",
		"method25",
		"method26",
		"method27",
		"method0",
		"method1",
		"method2",
		"method3",
		"method4",
		"method5",
		"internal_new_Accessible",
		"addAccessibleListener",
		"addAccessibleControlListener",
		"addAccessibleTextListener",
		"getControl",
		"internal_dispose_Accessible",
		"internal_WM_GETOBJECT",
		"removeAccessibleListener",
		"removeAccessibleControlListener",
		"removeAccessibleTextListener",
		"selectionChanged",
		"setFocus",
		"textCaretMoved",
		"textChanged",
		"textSelectionChanged",
		"QueryInterface",
		"AddRef",
		"Release",
		"accDoDefaultAction",
		"accHitTest",
		"accLocation",
		"accNavigate",
		"accSelect",
		"get_accChild",
		"get_accChildCount",
		"get_accDefaultAction",
		"get_accDescription",
		"get_accFocus",
		"get_accHelp",
		"get_accHelpTopic",
		"get_accKeyboardShortcut",
		"get_accName",
		"get_accParent",
		"get_accRole",
		"get_accSelection",
		"get_accState",
		"get_accValue",
		"put_accName",
		"put_accValue",
		"Next",
		"Skip",
		"Reset",
		"childIDToOs",
		"osToChildID",
		"stateToOs",
		"osToState",
		"roleToOs",
		"osToRole",
		"checkWidget",
		"isValidThread",
		"CreateStdAccessibleObject",
		"error",
		"AddRef",
		"QueryInterface",
		"AddRef",
		"Release",
		"get_accParent",
		"get_accChildCount",
		"get_accChild",
		"get_accName",
		"get_accValue",
		"get_accDescription",
		"get_accRole",
		"get_accState",
		"get_accHelp",
		"get_accHelpTopic",
		"get_accKeyboardShortcut",
		"get_accFocus",
		"get_accSelection",
		"get_accDefaultAction",
		"accSelect",
		"accLocation",
		"accNavigate",
		"accHitTest",
		"accDoDefaultAction",
		"put_accName",
		"put_accValue",
		"QueryInterface",
		"AddRef",
		"Release",
		"Next",
		"Skip",
		"Reset",
		"AddRef",
		"checkWidget",
		"error",
		"addElement",
		"checkWidget",
		"error",
		"addElement",
		"checkWidget",
		"error",
		"addElement",
		"Release",
		"Release",
		"LresultFromObject",
		"getAddress",
		"checkWidget",
		"error",
		"removeElement",
		"checkWidget",
		"error",
		"removeElement",
		"checkWidget",
		"error",
		"removeElement",
		"checkWidget",
		"NotifyWinEvent",
		"checkWidget",
		"NotifyWinEvent",
		"childIDToOs",
		"checkWidget",
		"NotifyWinEvent",
		"checkWidget",
		"NotifyWinEvent",
		"checkWidget",
		"MoveMemory",
		"IsEqualGUID",
		"MoveMemory",
		"getAddress",
		"AddRef",
		"IsEqualGUID",
		"MoveMemory",
		"getAddress",
		"AddRef",
		"IsEqualGUID",
		"MoveMemory",
		"getAddress",
		"AddRef",
		"IsEqualGUID",
		"MoveMemory",
		"getAddress",
		"AddRef",
		"QueryInterface",
		"MoveMemory",
		"dispose",
		"dispose",
		"accDoDefaultAction",
		"size",
		"accHitTest",
		"size",
		"elementAt",
		"getChildAtPoint",
		"accHitTest",
		"MoveMemory",
		"MoveMemory",
		"childIDToOs",
		"accLocation",
		"size",
		"MoveMemory",
		"MoveMemory",
		"MoveMemory",
		"MoveMemory",
		"osToChildID",
		"size",
		"elementAt",
		"getLocation",
		"MoveMemory",
		"MoveMemory",
		"MoveMemory",
		"MoveMemory",
		"accNavigate",
		"accSelect",
		"size",
		"get_accChild",
		"osToChildID",
		"size",
		"elementAt",
		"getChild",
		"MoveMemory",
		"getAddress",
		"get_accChildCount",
		"size",
		"MoveMemory",
		"size",
		"elementAt",
		"getChildCount",
		"MoveMemory",
		"get_accDefaultAction",
		"size",
		"MoveMemory",
		"SysStringByteLen",
		"MoveMemory",
		"osToChildID",
		"size",
		"elementAt",
		"getDefaultAction",
		"toCharArray",
		"SysAllocString",
		"MoveMemory",
		"get_accDescription",
		"size",
		"MoveMemory",
		"SysStringByteLen",
		"MoveMemory",
		"osToChildID",
		"getColumnCount",
		"SendMessage",
		"findWidget",
		"getDisplay",
		"getText",
		"getColumn",
		"getText",
		"size",
		"elementAt",
		"getDescription",
		"toCharArray",
		"SysAllocString",
		"MoveMemory",
		"get_accFocus",
		"size",
		"MoveMemory",
		"MoveMemory",
		"osToChildID",
		"size",
		"elementAt",
		"getFocus",
		"MoveMemory",
		"MoveMemory",
		"getAddress",
		"MoveMemory",
		"MoveMemory",
		"MoveMemory",
		"getAddress",
		"MoveMemory",
		"MoveMemory",
		"childIDToOs",
		"get_accHelp",
		"size",
		"MoveMemory",
		"SysStringByteLen",
		"MoveMemory",
		"osToChildID",
		"size",
		"elementAt",
		"getHelp",
		"toCharArray",
		"SysAllocString",
		"MoveMemory",
		"get_accHelpTopic",
		"get_accKeyboardShortcut",
		"size",
		"MoveMemory",
		"SysStringByteLen",
		"MoveMemory",
		"osToChildID",
		"size",
		"elementAt",
		"getKeyboardShortcut",
		"toCharArray",
		"SysAllocString",
		"MoveMemory",
		"get_accName",
		"size",
		"MoveMemory",
		"SysStringByteLen",
		"MoveMemory",
		"osToChildID",
		"size",
		"elementAt",
		"getName",
		"toCharArray",
		"SysAllocString",
		"MoveMemory",
		"get_accParent",
		"get_accRole",
		"size",
		"MoveMemory",
		"MoveMemory",
		"osToChildID",
		"osToRole",
		"getStyle",
		"size",
		"elementAt",
		"getRole",
		"roleToOs",
		"MoveMemory",
		"MoveMemory",
		"get_accSelection",
		"size",
		"MoveMemory",
		"MoveMemory",
		"osToChildID",
		"size",
		"elementAt",
		"getSelection",
		"MoveMemory",
		"MoveMemory",
		"getAddress",
		"MoveMemory",
		"MoveMemory",
		"MoveMemory",
		"getAddress",
		"MoveMemory",
		"MoveMemory",
		"getAddress",
		"MoveMemory",
		"MoveMemory",
		"childIDToOs",
		"get_accState",
		"size",
		"MoveMemory",
		"MoveMemory",
		"osToChildID",
		"osToState",
		"getStyle",
		"SendMessage",
		"SendMessage",
		"getStyle",
		"getItem",
		"getChecked",
		"size",
		"elementAt",
		"getState",
		"stateToOs",
		"MoveMemory",
		"MoveMemory",
		"get_accValue",
		"size",
		"MoveMemory",
		"SysStringByteLen",
		"MoveMemory",
		"osToChildID",
		"size",
		"elementAt",
		"getValue",
		"toCharArray",
		"SysAllocString",
		"MoveMemory",
		"put_accName",
		"put_accValue",
		"size",
		"QueryInterface",
		"Next",
		"MoveMemory",
		"size",
		"elementAt",
		"getChildren",
		"childIDToOs",
		"intValue",
		"intValue",
		"MoveMemory",
		"MoveMemory",
		"getAddress",
		"MoveMemory",
		"MoveMemory",
		"MoveMemory",
		"MoveMemory",
		"size",
		"QueryInterface",
		"Skip",
		"size",
		"QueryInterface",
		"Reset",
		"SendMessage",
		"SendMessage",
		"isValidThread",
		"error",
		"isDisposed",
		"error",
		"getThread",
		"getDisplay",
		"currentThread",
		"Vector",
		"Vector",
		"Vector",
		"IAccessible",
		"COMObject",
		"COMObject",
		"Accessible",
		"GUID",
		"AccessibleControlEvent",
		"AccessibleControlEvent",
		"AccessibleControlEvent",
		"AccessibleControlEvent",
		"String",
		"AccessibleControlEvent",
		"String",
		"AccessibleEvent",
		"AccessibleControlEvent",
		"String",
		"AccessibleEvent",
		"String",
		"AccessibleEvent",
		"String",
		"AccessibleEvent",
		"AccessibleControlEvent",
		"AccessibleControlEvent",
		"AccessibleControlEvent",
		"TVITEM",
		"String",
		"AccessibleControlEvent",
		"IEnumVARIANT",
		"AccessibleControlEvent",
		"Integer",
		"IEnumVARIANT",
		"IEnumVARIANT"
	],
	"methodsBody":{
		"public static Accessible internal_new_Accessible(Control control)":{
			"methodBody":"{\n    return new Accessible(control);\n}",
			"comments":"/**\n* Invokes platform specific functionality to allocate a new accessible object.\n* <p>\n* <b>IMPORTANT:</b> This method is <em>not</em> part of the public\n* API for <code>Accessible</code>. It is marked public only so that it\n* can be shared within the packages provided by SWT. It is not\n* available on all platforms, and should never be called from\n* application code.\n* </p>\n*\n* @param control the control to get the accessible object for\n* @return the platform specific accessible object\n*/\n",
			"methodName":"public static Accessible internal_new_Accessible(Control control)"
		},
		"int roleToOs(int role)":{
			"methodBody":"{\n    switch(role) {\n        case ACC.ROLE_CLIENT_AREA:\n            return COM.ROLE_SYSTEM_CLIENT;\n        case ACC.ROLE_WINDOW:\n            return COM.ROLE_SYSTEM_WINDOW;\n        case ACC.ROLE_MENUBAR:\n            return COM.ROLE_SYSTEM_MENUBAR;\n        case ACC.ROLE_MENU:\n            return COM.ROLE_SYSTEM_MENUPOPUP;\n        case ACC.ROLE_MENUITEM:\n            return COM.ROLE_SYSTEM_MENUITEM;\n        case ACC.ROLE_SEPARATOR:\n            return COM.ROLE_SYSTEM_SEPARATOR;\n        case ACC.ROLE_TOOLTIP:\n            return COM.ROLE_SYSTEM_TOOLTIP;\n        case ACC.ROLE_SCROLLBAR:\n            return COM.ROLE_SYSTEM_SCROLLBAR;\n        case ACC.ROLE_DIALOG:\n            return COM.ROLE_SYSTEM_DIALOG;\n        case ACC.ROLE_LABEL:\n            return COM.ROLE_SYSTEM_STATICTEXT;\n        case ACC.ROLE_PUSHBUTTON:\n            return COM.ROLE_SYSTEM_PUSHBUTTON;\n        case ACC.ROLE_CHECKBUTTON:\n            return COM.ROLE_SYSTEM_CHECKBUTTON;\n        case ACC.ROLE_RADIOBUTTON:\n            return COM.ROLE_SYSTEM_RADIOBUTTON;\n        case ACC.ROLE_COMBOBOX:\n            return COM.ROLE_SYSTEM_COMBOBOX;\n        case ACC.ROLE_TEXT:\n            return COM.ROLE_SYSTEM_TEXT;\n        case ACC.ROLE_TOOLBAR:\n            return COM.ROLE_SYSTEM_TOOLBAR;\n        case ACC.ROLE_LIST:\n            return COM.ROLE_SYSTEM_LIST;\n        case ACC.ROLE_LISTITEM:\n            return COM.ROLE_SYSTEM_LISTITEM;\n        case ACC.ROLE_TABLE:\n            return COM.ROLE_SYSTEM_TABLE;\n        case ACC.ROLE_TABLECELL:\n            return COM.ROLE_SYSTEM_CELL;\n        case ACC.ROLE_TABLECOLUMNHEADER:\n            return COM.ROLE_SYSTEM_COLUMNHEADER;\n        case ACC.ROLE_TABLEROWHEADER:\n            return COM.ROLE_SYSTEM_ROWHEADER;\n        case ACC.ROLE_TREE:\n            return COM.ROLE_SYSTEM_OUTLINE;\n        case ACC.ROLE_TREEITEM:\n            return COM.ROLE_SYSTEM_OUTLINEITEM;\n        case ACC.ROLE_TABFOLDER:\n            return COM.ROLE_SYSTEM_PAGETABLIST;\n        case ACC.ROLE_TABITEM:\n            return COM.ROLE_SYSTEM_PAGETAB;\n        case ACC.ROLE_PROGRESSBAR:\n            return COM.ROLE_SYSTEM_PROGRESSBAR;\n        case ACC.ROLE_SLIDER:\n            return COM.ROLE_SYSTEM_SLIDER;\n        case ACC.ROLE_LINK:\n            return COM.ROLE_SYSTEM_LINK;\n    }\n    return COM.ROLE_SYSTEM_CLIENT;\n}",
			"comments":"",
			"methodName":"int roleToOs(int role)"
		},
		"int get_accChild(int varChild_vt, int varChild_reserved1, int varChild_lVal, int varChild_reserved2, int ppdispChild)":{
			"methodBody":"{\n    if (iaccessible == null)\n        return COM.CO_E_OBJNOTCONNECTED;\n    if ((varChild_vt & 0xFFFF) != COM.VT_I4)\n        return COM.E_INVALIDARG;\n    if (accessibleControlListeners.size() == 0) {\n        int code = iaccessible.get_accChild(varChild_vt, varChild_reserved1, varChild_lVal, varChild_reserved2, ppdispChild);\n        \n        if (code == COM.E_INVALIDARG)\n            code = COM.S_FALSE;\n        return code;\n    }\n    AccessibleControlEvent event = new AccessibleControlEvent(this);\n    event.childID = osToChildID(varChild_lVal);\n    for (int i = 0; i < accessibleControlListeners.size(); i++) {\n        AccessibleControlListener listener = (AccessibleControlListener) accessibleControlListeners.elementAt(i);\n        listener.getChild(event);\n    }\n    Accessible accessible = event.accessible;\n    if (accessible != null) {\n        COM.MoveMemory(ppdispChild, new int[] { accessible.objIAccessible.getAddress() }, 4);\n        return COM.S_OK;\n    }\n    return COM.S_FALSE;\n}",
			"comments":"// proxy doesn't know about app childID\n",
			"methodName":"int get_accChild(int varChild_vt, int varChild_reserved1, int varChild_lVal, int varChild_reserved2, int ppdispChild)"
		},
		"public void addAccessibleTextListener(AccessibleTextListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    textListeners.addElement(listener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when an accessible client asks for custom text control\n* specific information. The listener is notified by sending it\n* one of the messages defined in the <code>AccessibleTextListener</code>\n* interface.\n*\n* @param listener the listener that should be notified when the receiver\n* is asked for custom text control specific information\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver's control has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver's control</li>\n* </ul>\n*\n* @see AccessibleTextListener\n* @see #removeAccessibleTextListener\n*\n* @since 3.0\n*/\n",
			"methodName":"public void addAccessibleTextListener(AccessibleTextListener listener)"
		},
		"int get_accState(int varChild_vt, int varChild_reserved1, int varChild_lVal, int varChild_reserved2, int pvarState)":{
			"methodBody":"{\n    if (iaccessible == null)\n        return COM.CO_E_OBJNOTCONNECTED;\n    if ((varChild_vt & 0xFFFF) != COM.VT_I4)\n        return COM.E_INVALIDARG;\n    \n    int osState = 0;\n    int code = iaccessible.get_accState(varChild_vt, varChild_reserved1, varChild_lVal, varChild_reserved2, pvarState);\n    \n    if (code == COM.E_INVALIDARG)\n        code = COM.S_FALSE;\n    \n    if (accessibleControlListeners.size() == 0 && !(control instanceof Tree || control instanceof Table))\n        return code;\n    if (code == COM.S_OK) {\n        short[] pvt = new short[1];\n        COM.MoveMemory(pvt, pvarState, 2);\n        if (pvt[0] == COM.VT_I4) {\n            int[] pState = new int[1];\n            COM.MoveMemory(pState, pvarState + 8, 4);\n            osState = pState[0];\n        }\n    }\n    AccessibleControlEvent event = new AccessibleControlEvent(this);\n    event.childID = osToChildID(varChild_lVal);\n    event.detail = osToState(osState);\n    \n    if (varChild_lVal != COM.CHILDID_SELF) {\n        if (control instanceof Tree && (control.getStyle() & SWT.CHECK) != 0) {\n            int hwnd = control.handle;\n            TVITEM tvItem = new TVITEM();\n            tvItem.mask = OS.TVIF_HANDLE | OS.TVIF_STATE;\n            tvItem.stateMask = OS.TVIS_STATEIMAGEMASK;\n            if (OS.COMCTL32_MAJOR >= 6) {\n                tvItem.hItem = OS.SendMessage(hwnd, OS.TVM_MAPACCIDTOHTREEITEM, varChild_lVal, 0);\n            } else {\n                tvItem.hItem = varChild_lVal;\n            }\n            int result = OS.SendMessage(hwnd, OS.TVM_GETITEM, 0, tvItem);\n            boolean checked = (result != 0) && (((tvItem.state >> 12) & 1) == 0);\n            if (checked)\n                event.detail |= ACC.STATE_CHECKED;\n        } else if (control instanceof Table && (control.getStyle() & SWT.CHECK) != 0) {\n            Table table = (Table) control;\n            TableItem item = table.getItem(event.childID);\n            if (item != null) {\n                if (item.getChecked())\n                    event.detail |= ACC.STATE_CHECKED;\n            }\n        }\n    }\n    for (int i = 0; i < accessibleControlListeners.size(); i++) {\n        AccessibleControlListener listener = (AccessibleControlListener) accessibleControlListeners.elementAt(i);\n        listener.getState(event);\n    }\n    int state = stateToOs(event.detail);\n    COM.MoveMemory(pvarState, new short[] { COM.VT_I4 }, 2);\n    COM.MoveMemory(pvarState + 8, new int[] { state }, 4);\n    return COM.S_OK;\n}",
			"comments":"/* Get the default state from the OS. */\n// proxy doesn't know about app childID\n// TEMPORARY CODE - process tree and table even if there are no apps listening\n// TEMPORARY CODE\n/* Currently our checkbox table and tree are emulated using state mask\n* images, so we need to determine if the item state is 'checked'. */\n",
			"methodName":"int get_accState(int varChild_vt, int varChild_reserved1, int varChild_lVal, int varChild_reserved2, int pvarState)"
		},
		"int AddRef()":{
			"methodBody":"{\n    refCount++;\n    return refCount;\n}",
			"comments":"",
			"methodName":"int AddRef()"
		},
		"int put_accName(int varChild_vt, int varChild_reserved1, int varChild_lVal, int varChild_reserved2, int szName)":{
			"methodBody":"{\n    \n    if (iaccessible == null)\n        return COM.CO_E_OBJNOTCONNECTED;\n    \n    int code = iaccessible.put_accName(varChild_vt, varChild_reserved1, varChild_lVal, varChild_reserved2, szName);\n    \n    if (code == COM.E_INVALIDARG)\n        code = COM.S_FALSE;\n    return code;\n}",
			"comments":"// MSAA: this method is no longer supported\n// We don't implement this. Forward to the proxy.\n// proxy doesn't know about app childID\n",
			"methodName":"int put_accName(int varChild_vt, int varChild_reserved1, int varChild_lVal, int varChild_reserved2, int szName)"
		},
		"public int internal_WM_GETOBJECT(int wParam, int lParam)":{
			"methodBody":"{\n    if (objIAccessible == null)\n        return 0;\n    if (lParam == COM.OBJID_CLIENT) {\n        return COM.LresultFromObject(COM.IIDIAccessible, wParam, objIAccessible.getAddress());\n    }\n    return 0;\n}",
			"comments":"/**\n* Invokes platform specific functionality to handle a window message.\n* <p>\n* <b>IMPORTANT:</b> This method is <em>not</em> part of the public\n* API for <code>Accessible</code>. It is marked public only so that it\n* can be shared within the packages provided by SWT. It is not\n* available on all platforms, and should never be called from\n* application code.\n* </p>\n*/\n",
			"methodName":"public int internal_WM_GETOBJECT(int wParam, int lParam)"
		},
		"int osToState(int osState)":{
			"methodBody":"{\n    int state = ACC.STATE_NORMAL;\n    if ((osState & COM.STATE_SYSTEM_SELECTED) != 0)\n        state |= ACC.STATE_SELECTED;\n    if ((osState & COM.STATE_SYSTEM_SELECTABLE) != 0)\n        state |= ACC.STATE_SELECTABLE;\n    if ((osState & COM.STATE_SYSTEM_MULTISELECTABLE) != 0)\n        state |= ACC.STATE_MULTISELECTABLE;\n    if ((osState & COM.STATE_SYSTEM_FOCUSED) != 0)\n        state |= ACC.STATE_FOCUSED;\n    if ((osState & COM.STATE_SYSTEM_FOCUSABLE) != 0)\n        state |= ACC.STATE_FOCUSABLE;\n    if ((osState & COM.STATE_SYSTEM_PRESSED) != 0)\n        state |= ACC.STATE_PRESSED;\n    if ((osState & COM.STATE_SYSTEM_CHECKED) != 0)\n        state |= ACC.STATE_CHECKED;\n    if ((osState & COM.STATE_SYSTEM_EXPANDED) != 0)\n        state |= ACC.STATE_EXPANDED;\n    if ((osState & COM.STATE_SYSTEM_COLLAPSED) != 0)\n        state |= ACC.STATE_COLLAPSED;\n    if ((osState & COM.STATE_SYSTEM_HOTTRACKED) != 0)\n        state |= ACC.STATE_HOTTRACKED;\n    if ((osState & COM.STATE_SYSTEM_BUSY) != 0)\n        state |= ACC.STATE_BUSY;\n    if ((osState & COM.STATE_SYSTEM_READONLY) != 0)\n        state |= ACC.STATE_READONLY;\n    if ((osState & COM.STATE_SYSTEM_INVISIBLE) != 0)\n        state |= ACC.STATE_INVISIBLE;\n    if ((osState & COM.STATE_SYSTEM_OFFSCREEN) != 0)\n        state |= ACC.STATE_OFFSCREEN;\n    if ((osState & COM.STATE_SYSTEM_SIZEABLE) != 0)\n        state |= ACC.STATE_SIZEABLE;\n    if ((osState & COM.STATE_SYSTEM_LINKED) != 0)\n        state |= ACC.STATE_LINKED;\n    return state;\n}",
			"comments":"",
			"methodName":"int osToState(int osState)"
		},
		"int accDoDefaultAction(int varChild_vt, int varChild_reserved1, int varChild_lVal, int varChild_reserved2)":{
			"methodBody":"{\n    if (iaccessible == null)\n        return COM.CO_E_OBJNOTCONNECTED;\n    \n    int code = iaccessible.accDoDefaultAction(varChild_vt, varChild_reserved1, varChild_lVal, varChild_reserved2);\n    \n    if (code == COM.E_INVALIDARG)\n        code = COM.S_FALSE;\n    return code;\n}",
			"comments":"// Currently, we don't let the application override this. Forward to the proxy.\n// proxy doesn't know about app childID\n",
			"methodName":"int accDoDefaultAction(int varChild_vt, int varChild_reserved1, int varChild_lVal, int varChild_reserved2)"
		},
		"int osToChildID(int osChildID)":{
			"methodBody":"{\n    if (osChildID == COM.CHILDID_SELF)\n        return ACC.CHILDID_SELF;\n    \n    if (!(control instanceof Tree))\n        return osChildID - 1;\n    if (OS.COMCTL32_MAJOR < 6)\n        return osChildID;\n    return OS.SendMessage(control.handle, OS.TVM_MAPACCIDTOHTREEITEM, osChildID, 0);\n}",
			"comments":"/*\n* Feature of Windows:\n* In Windows XP, tree item ids are 1-based indices. Previous versions\n* of Windows use the tree item handle for the accessible child ID.\n* For backward compatibility, we still take a handle childID for tree\n* items on XP. All other childIDs are 1-based indices.\n*/\n",
			"methodName":"int osToChildID(int osChildID)"
		},
		"public int method13(int[] args)":{
			"methodBody":"{\n    return get_accRole(args[0], args[1], args[2], args[3], args[4]);\n}",
			"comments":"",
			"methodName":"public int method13(int[] args)"
		},
		"public void textChanged(int type, int startIndex, int length)":{
			"methodBody":"{\n    checkWidget();\n    COM.NotifyWinEvent(COM.EVENT_OBJECT_VALUECHANGE, control.handle, COM.OBJID_CLIENT, COM.CHILDID_SELF);\n}",
			"comments":"/**\n* Sends a message to accessible clients that the text\n* within a custom control has changed.\n*\n* @param type the type of change, one of <code>ACC.NOTIFY_TEXT_INSERT</code>\n* or <code>ACC.NOTIFY_TEXT_DELETE</code>\n* @param startIndex the text index within the control where the insertion or deletion begins\n* @param length the non-negative length in characters of the insertion or deletion\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver's control has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver's control</li>\n* </ul>\n*\n* @see ACC#TEXT_INSERT\n* @see ACC#TEXT_DELETE\n*\n* @since 3.0\n*/\n",
			"methodName":"public void textChanged(int type, int startIndex, int length)"
		},
		"int Release()":{
			"methodBody":"{\n    refCount--;\n    if (refCount == 0) {\n        if (objIAccessible != null)\n            objIAccessible.dispose();\n        objIAccessible = null;\n        if (objIEnumVARIANT != null)\n            objIEnumVARIANT.dispose();\n        objIEnumVARIANT = null;\n    }\n    return refCount;\n}",
			"comments":"",
			"methodName":"int Release()"
		},
		"public int method14(int[] args)":{
			"methodBody":"{\n    return get_accState(args[0], args[1], args[2], args[3], args[4]);\n}",
			"comments":"",
			"methodName":"public int method14(int[] args)"
		},
		"int Reset()":{
			"methodBody":"{\n    \n    if (accessibleControlListeners.size() == 0) {\n        int[] ppvObject = new int[1];\n        int code = iaccessible.QueryInterface(COM.IIDIEnumVARIANT, ppvObject);\n        if (code != COM.S_OK)\n            return code;\n        IEnumVARIANT ienumvariant = new IEnumVARIANT(ppvObject[0]);\n        code = ienumvariant.Reset();\n        return code;\n    }\n    enumIndex = 0;\n    return COM.S_OK;\n}",
			"comments":"/* Reset the enumeration sequence to the beginning. */\n/* If there are no listeners, query the proxy\n* for its IEnumVariant, and tell it to Reset.\n*/\n",
			"methodName":"int Reset()"
		},
		"public void addAccessibleListener(AccessibleListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    accessibleListeners.addElement(listener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when an accessible client asks for certain strings,\n* such as name, description, help, or keyboard shortcut. The\n* listener is notified by sending it one of the messages defined\n* in the <code>AccessibleListener</code> interface.\n*\n* @param listener the listener that should be notified when the receiver\n* is asked for a name, description, help, or keyboard shortcut string\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver's control has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver's control</li>\n* </ul>\n*\n* @see AccessibleListener\n* @see #removeAccessibleListener\n*/\n",
			"methodName":"public void addAccessibleListener(AccessibleListener listener)"
		},
		"int put_accValue(int varChild_vt, int varChild_reserved1, int varChild_lVal, int varChild_reserved2, int szValue)":{
			"methodBody":"{\n    \n    if (iaccessible == null)\n        return COM.CO_E_OBJNOTCONNECTED;\n    \n    int code = iaccessible.put_accValue(varChild_vt, varChild_reserved1, varChild_lVal, varChild_reserved2, szValue);\n    \n    if (code == COM.E_INVALIDARG)\n        code = COM.S_FALSE;\n    return code;\n}",
			"comments":"// MSAA: this method is typically only used for edit controls\n// We don't implement this. Forward to the proxy.\n// proxy doesn't know about app childID\n",
			"methodName":"int put_accValue(int varChild_vt, int varChild_reserved1, int varChild_lVal, int varChild_reserved2, int szValue)"
		},
		"int get_accValue(int varChild_vt, int varChild_reserved1, int varChild_lVal, int varChild_reserved2, int pszValue)":{
			"methodBody":"{\n    if (iaccessible == null)\n        return COM.CO_E_OBJNOTCONNECTED;\n    if ((varChild_vt & 0xFFFF) != COM.VT_I4)\n        return COM.E_INVALIDARG;\n    \n    String osValue = null;\n    int code = iaccessible.get_accValue(varChild_vt, varChild_reserved1, varChild_lVal, varChild_reserved2, pszValue);\n    \n    if (code == COM.E_INVALIDARG)\n        code = COM.S_FALSE;\n    if (accessibleControlListeners.size() == 0)\n        return code;\n    if (code == COM.S_OK) {\n        int[] pValue = new int[1];\n        COM.MoveMemory(pValue, pszValue, 4);\n        int size = COM.SysStringByteLen(pValue[0]);\n        if (size > 0) {\n            char[] buffer = new char[(size + 1) / 2];\n            COM.MoveMemory(buffer, pValue[0], size);\n            osValue = new String(buffer);\n        }\n    }\n    AccessibleControlEvent event = new AccessibleControlEvent(this);\n    event.childID = osToChildID(varChild_lVal);\n    event.result = osValue;\n    for (int i = 0; i < accessibleControlListeners.size(); i++) {\n        AccessibleControlListener listener = (AccessibleControlListener) accessibleControlListeners.elementAt(i);\n        listener.getValue(event);\n    }\n    if (event.result == null)\n        return code;\n    char[] data = (event.result + \"\\0\").toCharArray();\n    int ptr = COM.SysAllocString(data);\n    COM.MoveMemory(pszValue, new int[] { ptr }, 4);\n    return COM.S_OK;\n}",
			"comments":"/* Get the default value string from the OS. */\n// proxy doesn't know about app childID\n",
			"methodName":"int get_accValue(int varChild_vt, int varChild_reserved1, int varChild_lVal, int varChild_reserved2, int pszValue)"
		},
		"public int method23(int[] args)":{
			"methodBody":"{\n    return accNavigate(args[0], args[1], args[2], args[3], args[4], args[5]);\n}",
			"comments":"",
			"methodName":"public int method23(int[] args)"
		},
		"public int method12(int[] args)":{
			"methodBody":"{\n    return get_accDescription(args[0], args[1], args[2], args[3], args[4]);\n}",
			"comments":"",
			"methodName":"public int method12(int[] args)"
		},
		"public int method22(int[] args)":{
			"methodBody":"{\n    return accLocation(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);\n}",
			"comments":"",
			"methodName":"public int method22(int[] args)"
		},
		"public Control getControl()":{
			"methodBody":"{\n    return control;\n}",
			"comments":"/**\n* Returns the control for this Accessible object.\n*\n* @return the receiver's control\n* @since 3.0\n*/\n",
			"methodName":"public Control getControl()"
		},
		"public int method11(int[] args)":{
			"methodBody":"{\n    return get_accValue(args[0], args[1], args[2], args[3], args[4]);\n}",
			"comments":"",
			"methodName":"public int method11(int[] args)"
		},
		"int get_accRole(int varChild_vt, int varChild_reserved1, int varChild_lVal, int varChild_reserved2, int pvarRole)":{
			"methodBody":"{\n    if (iaccessible == null)\n        return COM.CO_E_OBJNOTCONNECTED;\n    if ((varChild_vt & 0xFFFF) != COM.VT_I4)\n        return COM.E_INVALIDARG;\n    \n    int osRole = COM.ROLE_SYSTEM_CLIENT;\n    int code = iaccessible.get_accRole(varChild_vt, varChild_reserved1, varChild_lVal, varChild_reserved2, pvarRole);\n    \n    if (code == COM.E_INVALIDARG)\n        code = COM.S_FALSE;\n    \n    if (accessibleControlListeners.size() == 0 && !(control instanceof Tree || control instanceof Table))\n        return code;\n    if (code == COM.S_OK) {\n        short[] pvt = new short[1];\n        COM.MoveMemory(pvt, pvarRole, 2);\n        if (pvt[0] == COM.VT_I4) {\n            int[] pRole = new int[1];\n            COM.MoveMemory(pRole, pvarRole + 8, 4);\n            osRole = pRole[0];\n        }\n    }\n    AccessibleControlEvent event = new AccessibleControlEvent(this);\n    event.childID = osToChildID(varChild_lVal);\n    event.detail = osToRole(osRole);\n    \n    if (varChild_lVal != COM.CHILDID_SELF) {\n        if (control instanceof Tree || control instanceof Table) {\n            if ((control.getStyle() & SWT.CHECK) != 0)\n                event.detail = ACC.ROLE_CHECKBUTTON;\n        }\n    }\n    for (int i = 0; i < accessibleControlListeners.size(); i++) {\n        AccessibleControlListener listener = (AccessibleControlListener) accessibleControlListeners.elementAt(i);\n        listener.getRole(event);\n    }\n    int role = roleToOs(event.detail);\n    COM.MoveMemory(pvarRole, new short[] { COM.VT_I4 }, 2);\n    COM.MoveMemory(pvarRole + 8, new int[] { role }, 4);\n    return COM.S_OK;\n}",
			"comments":"/* Get the default role from the OS. */\n// proxy doesn't know about app childID\n// TEMPORARY CODE - process tree and table even if there are no apps listening\n// TEMPORARY CODE\n/* Currently our checkbox table and tree are emulated using state mask\n* images, so we need to specify 'checkbox' role for the items. */\n",
			"methodName":"int get_accRole(int varChild_vt, int varChild_reserved1, int varChild_lVal, int varChild_reserved2, int pvarRole)"
		},
		"public int method20(int[] args)":{
			"methodBody":"{\n    return get_accDefaultAction(args[0], args[1], args[2], args[3], args[4]);\n}",
			"comments":"",
			"methodName":"public int method20(int[] args)"
		},
		"public void selectionChanged()":{
			"methodBody":"{\n    checkWidget();\n    COM.NotifyWinEvent(COM.EVENT_OBJECT_SELECTIONWITHIN, control.handle, COM.OBJID_CLIENT, COM.CHILDID_SELF);\n}",
			"comments":"/**\n* Sends a message to accessible clients that the child selection\n* within a custom container control has changed.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver's control has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver's control</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public void selectionChanged()"
		},
		"public int method21(int[] args)":{
			"methodBody":"{\n    return accSelect(args[0], args[1], args[2], args[3], args[4]);\n}",
			"comments":"",
			"methodName":"public int method21(int[] args)"
		},
		"public int method10(int[] args)":{
			"methodBody":"{\n    return get_accName(args[0], args[1], args[2], args[3], args[4]);\n}",
			"comments":"",
			"methodName":"public int method10(int[] args)"
		},
		"int QueryInterface(int arg1, int arg2)":{
			"methodBody":"{\n    if (iaccessible == null)\n        return COM.CO_E_OBJNOTCONNECTED;\n    GUID guid = new GUID();\n    COM.MoveMemory(guid, arg1, GUID.sizeof);\n    if (COM.IsEqualGUID(guid, COM.IIDIUnknown)) {\n        COM.MoveMemory(arg2, new int[] { objIAccessible.getAddress() }, 4);\n        AddRef();\n        return COM.S_OK;\n    }\n    if (COM.IsEqualGUID(guid, COM.IIDIDispatch)) {\n        COM.MoveMemory(arg2, new int[] { objIAccessible.getAddress() }, 4);\n        AddRef();\n        return COM.S_OK;\n    }\n    if (COM.IsEqualGUID(guid, COM.IIDIAccessible)) {\n        COM.MoveMemory(arg2, new int[] { objIAccessible.getAddress() }, 4);\n        AddRef();\n        return COM.S_OK;\n    }\n    if (COM.IsEqualGUID(guid, COM.IIDIEnumVARIANT)) {\n        COM.MoveMemory(arg2, new int[] { objIEnumVARIANT.getAddress() }, 4);\n        AddRef();\n        enumIndex = 0;\n        return COM.S_OK;\n    }\n    int[] ppvObject = new int[1];\n    int result = iaccessible.QueryInterface(guid, ppvObject);\n    COM.MoveMemory(arg2, ppvObject, 4);\n    return result;\n}",
			"comments":"",
			"methodName":"int QueryInterface(int arg1, int arg2)"
		},
		"int osToRole(int osRole)":{
			"methodBody":"{\n    int role = COM.ROLE_SYSTEM_CLIENT;\n    switch(osRole) {\n        case COM.ROLE_SYSTEM_CLIENT:\n            return ACC.ROLE_CLIENT_AREA;\n        case COM.ROLE_SYSTEM_WINDOW:\n            return ACC.ROLE_WINDOW;\n        case COM.ROLE_SYSTEM_MENUBAR:\n            return ACC.ROLE_MENUBAR;\n        case COM.ROLE_SYSTEM_MENUPOPUP:\n            return ACC.ROLE_MENU;\n        case COM.ROLE_SYSTEM_MENUITEM:\n            return ACC.ROLE_MENUITEM;\n        case COM.ROLE_SYSTEM_SEPARATOR:\n            return ACC.ROLE_SEPARATOR;\n        case COM.ROLE_SYSTEM_TOOLTIP:\n            return ACC.ROLE_TOOLTIP;\n        case COM.ROLE_SYSTEM_SCROLLBAR:\n            return ACC.ROLE_SCROLLBAR;\n        case COM.ROLE_SYSTEM_DIALOG:\n            return ACC.ROLE_DIALOG;\n        case COM.ROLE_SYSTEM_STATICTEXT:\n            return ACC.ROLE_LABEL;\n        case COM.ROLE_SYSTEM_PUSHBUTTON:\n            return ACC.ROLE_PUSHBUTTON;\n        case COM.ROLE_SYSTEM_CHECKBUTTON:\n            return ACC.ROLE_CHECKBUTTON;\n        case COM.ROLE_SYSTEM_RADIOBUTTON:\n            return ACC.ROLE_RADIOBUTTON;\n        case COM.ROLE_SYSTEM_COMBOBOX:\n            return ACC.ROLE_COMBOBOX;\n        case COM.ROLE_SYSTEM_TEXT:\n            return ACC.ROLE_TEXT;\n        case COM.ROLE_SYSTEM_TOOLBAR:\n            return ACC.ROLE_TOOLBAR;\n        case COM.ROLE_SYSTEM_LIST:\n            return ACC.ROLE_LIST;\n        case COM.ROLE_SYSTEM_LISTITEM:\n            return ACC.ROLE_LISTITEM;\n        case COM.ROLE_SYSTEM_TABLE:\n            return ACC.ROLE_TABLE;\n        case COM.ROLE_SYSTEM_CELL:\n            return ACC.ROLE_TABLECELL;\n        case COM.ROLE_SYSTEM_COLUMNHEADER:\n            return ACC.ROLE_TABLECOLUMNHEADER;\n        case COM.ROLE_SYSTEM_ROWHEADER:\n            return ACC.ROLE_TABLEROWHEADER;\n        case COM.ROLE_SYSTEM_OUTLINE:\n            return ACC.ROLE_TREE;\n        case COM.ROLE_SYSTEM_OUTLINEITEM:\n            return ACC.ROLE_TREEITEM;\n        case COM.ROLE_SYSTEM_PAGETABLIST:\n            return ACC.ROLE_TABFOLDER;\n        case COM.ROLE_SYSTEM_PAGETAB:\n            return ACC.ROLE_TABITEM;\n        case COM.ROLE_SYSTEM_PROGRESSBAR:\n            return ACC.ROLE_PROGRESSBAR;\n        case COM.ROLE_SYSTEM_SLIDER:\n            return ACC.ROLE_SLIDER;\n        case COM.ROLE_SYSTEM_LINK:\n            return ACC.ROLE_LINK;\n    }\n    return role;\n}",
			"comments":"",
			"methodName":"int osToRole(int osRole)"
		},
		"public void removeAccessibleTextListener(AccessibleTextListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    textListeners.removeElement(listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when an accessible client asks for custom text control\n* specific information.\n*\n* @param listener the listener that should no longer be notified when the receiver\n* is asked for custom text control specific information\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver's control has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver's control</li>\n* </ul>\n*\n* @see AccessibleTextListener\n* @see #addAccessibleTextListener\n*\n* @since 3.0\n*/\n",
			"methodName":"public void removeAccessibleTextListener(AccessibleTextListener listener)"
		},
		"public int method3(int[] args)":{
			"methodBody":"{\n    return Next(args[0], args[1], args[2]);\n}",
			"comments":"",
			"methodName":"public int method3(int[] args)"
		},
		"public void setFocus(int childID)":{
			"methodBody":"{\n    checkWidget();\n    COM.NotifyWinEvent(COM.EVENT_OBJECT_FOCUS, control.handle, COM.OBJID_CLIENT, childIDToOs(childID));\n}",
			"comments":"/**\n* Sends a message to accessible clients indicating that the focus\n* has changed within a custom control.\n*\n* @param childID an identifier specifying a child of the control\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver's control has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver's control</li>\n* </ul>\n*/\n",
			"methodName":"public void setFocus(int childID)"
		},
		"int get_accDescription(int varChild_vt, int varChild_reserved1, int varChild_lVal, int varChild_reserved2, int pszDescription)":{
			"methodBody":"{\n    if (iaccessible == null)\n        return COM.CO_E_OBJNOTCONNECTED;\n    if ((varChild_vt & 0xFFFF) != COM.VT_I4)\n        return COM.E_INVALIDARG;\n    \n    String osDescription = null;\n    int code = iaccessible.get_accDescription(varChild_vt, varChild_reserved1, varChild_lVal, varChild_reserved2, pszDescription);\n    \n    if (code == COM.E_INVALIDARG)\n        code = COM.S_FALSE;\n    \n    if (accessibleListeners.size() == 0 && !(control instanceof Tree))\n        return code;\n    if (code == COM.S_OK) {\n        int[] pDescription = new int[1];\n        COM.MoveMemory(pDescription, pszDescription, 4);\n        int size = COM.SysStringByteLen(pDescription[0]);\n        if (size > 0) {\n            char[] buffer = new char[(size + 1) / 2];\n            COM.MoveMemory(buffer, pDescription[0], size);\n            osDescription = new String(buffer);\n        }\n    }\n    AccessibleEvent event = new AccessibleEvent(this);\n    event.childID = osToChildID(varChild_lVal);\n    event.result = osDescription;\n    \n    if (varChild_lVal != COM.CHILDID_SELF) {\n        if (control instanceof Tree) {\n            Tree tree = (Tree) control;\n            int columnCount = tree.getColumnCount();\n            if (columnCount > 1) {\n                int hwnd = control.handle, hItem = 0;\n                if (OS.COMCTL32_MAJOR >= 6) {\n                    hItem = OS.SendMessage(hwnd, OS.TVM_MAPACCIDTOHTREEITEM, varChild_lVal, 0);\n                } else {\n                    hItem = varChild_lVal;\n                }\n                Widget widget = tree.getDisplay().findWidget(hwnd, hItem);\n                event.result = \"\";\n                if (widget != null && widget instanceof TreeItem) {\n                    TreeItem item = (TreeItem) widget;\n                    for (int i = 1; i < columnCount; i++) {\n                        event.result += tree.getColumn(i).getText() + \": \" + item.getText(i);\n                        if (i + 1 < columnCount)\n                            event.result += \", \";\n                    }\n                }\n            }\n        }\n    }\n    for (int i = 0; i < accessibleListeners.size(); i++) {\n        AccessibleListener listener = (AccessibleListener) accessibleListeners.elementAt(i);\n        listener.getDescription(event);\n    }\n    if (event.result == null)\n        return code;\n    char[] data = (event.result + \"\\0\").toCharArray();\n    int ptr = COM.SysAllocString(data);\n    COM.MoveMemory(pszDescription, new int[] { ptr }, 4);\n    return COM.S_OK;\n}",
			"comments":"/* Get the default description from the OS. */\n// proxy doesn't know about app childID\n// TEMPORARY CODE - process tree even if there are no apps listening\n// TEMPORARY CODE\n/* Currently our tree columns are emulated using custom draw,\n* so we need to create the description using the tree column\n* header text and tree item text. */\n",
			"methodName":"int get_accDescription(int varChild_vt, int varChild_reserved1, int varChild_lVal, int varChild_reserved2, int pszDescription)"
		},
		"int accHitTest(int xLeft, int yTop, int pvarChild)":{
			"methodBody":"{\n    if (iaccessible == null)\n        return COM.CO_E_OBJNOTCONNECTED;\n    if (accessibleControlListeners.size() == 0) {\n        return iaccessible.accHitTest(xLeft, yTop, pvarChild);\n    }\n    AccessibleControlEvent event = new AccessibleControlEvent(this);\n    event.childID = ACC.CHILDID_NONE;\n    event.x = xLeft;\n    event.y = yTop;\n    for (int i = 0; i < accessibleControlListeners.size(); i++) {\n        AccessibleControlListener listener = (AccessibleControlListener) accessibleControlListeners.elementAt(i);\n        listener.getChildAtPoint(event);\n    }\n    int childID = event.childID;\n    if (childID == ACC.CHILDID_NONE) {\n        return iaccessible.accHitTest(xLeft, yTop, pvarChild);\n    }\n    COM.MoveMemory(pvarChild, new short[] { COM.VT_I4 }, 2);\n    COM.MoveMemory(pvarChild + 8, new int[] { childIDToOs(childID) }, 4);\n    return COM.S_OK;\n}",
			"comments":"",
			"methodName":"int accHitTest(int xLeft, int yTop, int pvarChild)"
		},
		"public int method2(int[] args)":{
			"methodBody":"{\n    return Release();\n}",
			"comments":"",
			"methodName":"public int method2(int[] args)"
		},
		"int childIDToOs(int childID)":{
			"methodBody":"{\n    if (childID == ACC.CHILDID_SELF)\n        return COM.CHILDID_SELF;\n    \n    if (!(control instanceof Tree))\n        return childID + 1;\n    if (OS.COMCTL32_MAJOR < 6)\n        return childID;\n    return OS.SendMessage(control.handle, OS.TVM_MAPHTREEITEMTOACCID, childID, 0);\n}",
			"comments":"/*\n* Feature of Windows:\n* In Windows XP, tree item ids are 1-based indices. Previous versions\n* of Windows use the tree item handle for the accessible child ID.\n* For backward compatibility, we still take a handle childID for tree\n* items on XP. All other childIDs are 1-based indices.\n*/\n",
			"methodName":"int childIDToOs(int childID)"
		},
		"public int method1(int[] args)":{
			"methodBody":"{\n    return AddRef();\n}",
			"comments":"",
			"methodName":"public int method1(int[] args)"
		},
		"int get_accDefaultAction(int varChild_vt, int varChild_reserved1, int varChild_lVal, int varChild_reserved2, int pszDefaultAction)":{
			"methodBody":"{\n    if (iaccessible == null)\n        return COM.CO_E_OBJNOTCONNECTED;\n    if ((varChild_vt & 0xFFFF) != COM.VT_I4)\n        return COM.E_INVALIDARG;\n    \n    String osDefaultAction = null;\n    int code = iaccessible.get_accDefaultAction(varChild_vt, varChild_reserved1, varChild_lVal, varChild_reserved2, pszDefaultAction);\n    \n    if (code == COM.E_INVALIDARG)\n        code = COM.S_FALSE;\n    if (accessibleControlListeners.size() == 0)\n        return code;\n    if (code == COM.S_OK) {\n        int[] pDefaultAction = new int[1];\n        COM.MoveMemory(pDefaultAction, pszDefaultAction, 4);\n        int size = COM.SysStringByteLen(pDefaultAction[0]);\n        if (size > 0) {\n            char[] buffer = new char[(size + 1) / 2];\n            COM.MoveMemory(buffer, pDefaultAction[0], size);\n            osDefaultAction = new String(buffer);\n        }\n    }\n    AccessibleControlEvent event = new AccessibleControlEvent(this);\n    event.childID = osToChildID(varChild_lVal);\n    event.result = osDefaultAction;\n    for (int i = 0; i < accessibleControlListeners.size(); i++) {\n        AccessibleControlListener listener = (AccessibleControlListener) accessibleControlListeners.elementAt(i);\n        listener.getDefaultAction(event);\n    }\n    if (event.result == null)\n        return code;\n    char[] data = (event.result + \"\\0\").toCharArray();\n    int ptr = COM.SysAllocString(data);\n    COM.MoveMemory(pszDefaultAction, new int[] { ptr }, 4);\n    return COM.S_OK;\n}",
			"comments":"/* Get the default defaultAction from the OS. */\n// proxy doesn't know about app childID\n",
			"methodName":"int get_accDefaultAction(int varChild_vt, int varChild_reserved1, int varChild_lVal, int varChild_reserved2, int pszDefaultAction)"
		},
		"int get_accHelpTopic(int pszHelpFile, int varChild_vt, int varChild_reserved1, int varChild_lVal, int varChild_reserved2, int pidTopic)":{
			"methodBody":"{\n    if (iaccessible == null)\n        return COM.CO_E_OBJNOTCONNECTED;\n    \n    int code = iaccessible.get_accHelpTopic(pszHelpFile, varChild_vt, varChild_reserved1, varChild_lVal, varChild_reserved2, pidTopic);\n    \n    if (code == COM.E_INVALIDARG)\n        code = COM.S_FALSE;\n    return code;\n}",
			"comments":"// Currently, we don't let the application override this. Forward to the proxy.\n// proxy doesn't know about app childID\n",
			"methodName":"int get_accHelpTopic(int pszHelpFile, int varChild_vt, int varChild_reserved1, int varChild_lVal, int varChild_reserved2, int pidTopic)"
		},
		"int get_accKeyboardShortcut(int varChild_vt, int varChild_reserved1, int varChild_lVal, int varChild_reserved2, int pszKeyboardShortcut)":{
			"methodBody":"{\n    if (iaccessible == null)\n        return COM.CO_E_OBJNOTCONNECTED;\n    if ((varChild_vt & 0xFFFF) != COM.VT_I4)\n        return COM.E_INVALIDARG;\n    \n    String osKeyboardShortcut = null;\n    int code = iaccessible.get_accKeyboardShortcut(varChild_vt, varChild_reserved1, varChild_lVal, varChild_reserved2, pszKeyboardShortcut);\n    \n    if (code == COM.E_INVALIDARG)\n        code = COM.S_FALSE;\n    if (accessibleListeners.size() == 0)\n        return code;\n    if (code == COM.S_OK) {\n        int[] pKeyboardShortcut = new int[1];\n        COM.MoveMemory(pKeyboardShortcut, pszKeyboardShortcut, 4);\n        int size = COM.SysStringByteLen(pKeyboardShortcut[0]);\n        if (size > 0) {\n            char[] buffer = new char[(size + 1) / 2];\n            COM.MoveMemory(buffer, pKeyboardShortcut[0], size);\n            osKeyboardShortcut = new String(buffer);\n        }\n    }\n    AccessibleEvent event = new AccessibleEvent(this);\n    event.childID = osToChildID(varChild_lVal);\n    event.result = osKeyboardShortcut;\n    for (int i = 0; i < accessibleListeners.size(); i++) {\n        AccessibleListener listener = (AccessibleListener) accessibleListeners.elementAt(i);\n        listener.getKeyboardShortcut(event);\n    }\n    if (event.result == null)\n        return code;\n    char[] data = (event.result + \"\\0\").toCharArray();\n    int ptr = COM.SysAllocString(data);\n    COM.MoveMemory(pszKeyboardShortcut, new int[] { ptr }, 4);\n    return COM.S_OK;\n}",
			"comments":"/* Get the default keyboard shortcut from the OS. */\n// proxy doesn't know about app childID\n",
			"methodName":"int get_accKeyboardShortcut(int varChild_vt, int varChild_reserved1, int varChild_lVal, int varChild_reserved2, int pszKeyboardShortcut)"
		},
		"public int method0(int[] args)":{
			"methodBody":"{\n    return QueryInterface(args[0], args[1]);\n}",
			"comments":"",
			"methodName":"public int method0(int[] args)"
		},
		"int get_accSelection(int pvarChildren)":{
			"methodBody":"{\n    if (iaccessible == null)\n        return COM.CO_E_OBJNOTCONNECTED;\n    \n    int osChild = ACC.CHILDID_NONE;\n    int code = iaccessible.get_accSelection(pvarChildren);\n    if (accessibleControlListeners.size() == 0)\n        return code;\n    if (code == COM.S_OK) {\n        short[] pvt = new short[1];\n        COM.MoveMemory(pvt, pvarChildren, 2);\n        if (pvt[0] == COM.VT_I4) {\n            int[] pChild = new int[1];\n            COM.MoveMemory(pChild, pvarChildren + 8, 4);\n            osChild = osToChildID(pChild[0]);\n        } else if (pvt[0] == COM.VT_UNKNOWN) {\n            osChild = ACC.CHILDID_MULTIPLE;\n        \n        }\n    }\n    AccessibleControlEvent event = new AccessibleControlEvent(this);\n    event.childID = osChild;\n    for (int i = 0; i < accessibleControlListeners.size(); i++) {\n        AccessibleControlListener listener = (AccessibleControlListener) accessibleControlListeners.elementAt(i);\n        listener.getSelection(event);\n    }\n    Accessible accessible = event.accessible;\n    if (accessible != null) {\n        COM.MoveMemory(pvarChildren, new short[] { COM.VT_DISPATCH }, 2);\n        COM.MoveMemory(pvarChildren + 8, new int[] { accessible.objIAccessible.getAddress() }, 4);\n        return COM.S_OK;\n    }\n    int childID = event.childID;\n    if (childID == ACC.CHILDID_NONE) {\n        COM.MoveMemory(pvarChildren, new short[] { COM.VT_EMPTY }, 2);\n        return COM.S_FALSE;\n    }\n    if (childID == ACC.CHILDID_MULTIPLE) {\n        COM.MoveMemory(pvarChildren, new short[] { COM.VT_UNKNOWN }, 2);\n        \n        COM.MoveMemory(pvarChildren + 8, new int[] { objIAccessible.getAddress() }, 4);\n        return COM.S_OK;\n    }\n    if (childID == ACC.CHILDID_SELF) {\n        COM.MoveMemory(pvarChildren, new short[] { COM.VT_DISPATCH }, 2);\n        COM.MoveMemory(pvarChildren + 8, new int[] { objIAccessible.getAddress() }, 4);\n        return COM.S_OK;\n    }\n    COM.MoveMemory(pvarChildren, new short[] { COM.VT_I4 }, 2);\n    COM.MoveMemory(pvarChildren + 8, new int[] { childIDToOs(childID) }, 4);\n    return COM.S_OK;\n}",
			"comments":"/* Get the default selection from the OS. */\n/* Should get IEnumVARIANT from punkVal field... need better API here... */\n/* Should return an IEnumVARIANT for this... so the next line is wrong... need better API here... */\n",
			"methodName":"int get_accSelection(int pvarChildren)"
		},
		"int get_accChildCount(int pcountChildren)":{
			"methodBody":"{\n    if (iaccessible == null)\n        return COM.CO_E_OBJNOTCONNECTED;\n    \n    int osChildCount = 0;\n    int code = iaccessible.get_accChildCount(pcountChildren);\n    if (accessibleControlListeners.size() == 0)\n        return code;\n    if (code == COM.S_OK) {\n        int[] pChildCount = new int[1];\n        COM.MoveMemory(pChildCount, pcountChildren, 4);\n        osChildCount = pChildCount[0];\n    }\n    AccessibleControlEvent event = new AccessibleControlEvent(this);\n    event.childID = ACC.CHILDID_SELF;\n    event.detail = osChildCount;\n    for (int i = 0; i < accessibleControlListeners.size(); i++) {\n        AccessibleControlListener listener = (AccessibleControlListener) accessibleControlListeners.elementAt(i);\n        listener.getChildCount(event);\n    }\n    COM.MoveMemory(pcountChildren, new int[] { event.detail }, 4);\n    return COM.S_OK;\n}",
			"comments":"/* Get the default child count from the OS. */\n",
			"methodName":"int get_accChildCount(int pcountChildren)"
		},
		"public int method4(int[] args)":{
			"methodBody":"{\n    return Skip(args[0]);\n}",
			"comments":"",
			"methodName":"public int method4(int[] args)"
		},
		"int get_accHelp(int varChild_vt, int varChild_reserved1, int varChild_lVal, int varChild_reserved2, int pszHelp)":{
			"methodBody":"{\n    if (iaccessible == null)\n        return COM.CO_E_OBJNOTCONNECTED;\n    if ((varChild_vt & 0xFFFF) != COM.VT_I4)\n        return COM.E_INVALIDARG;\n    \n    String osHelp = null;\n    int code = iaccessible.get_accHelp(varChild_vt, varChild_reserved1, varChild_lVal, varChild_reserved2, pszHelp);\n    \n    if (code == COM.E_INVALIDARG)\n        code = COM.S_FALSE;\n    if (accessibleListeners.size() == 0)\n        return code;\n    if (code == COM.S_OK) {\n        int[] pHelp = new int[1];\n        COM.MoveMemory(pHelp, pszHelp, 4);\n        int size = COM.SysStringByteLen(pHelp[0]);\n        if (size > 0) {\n            char[] buffer = new char[(size + 1) / 2];\n            COM.MoveMemory(buffer, pHelp[0], size);\n            osHelp = new String(buffer);\n        }\n    }\n    AccessibleEvent event = new AccessibleEvent(this);\n    event.childID = osToChildID(varChild_lVal);\n    event.result = osHelp;\n    for (int i = 0; i < accessibleListeners.size(); i++) {\n        AccessibleListener listener = (AccessibleListener) accessibleListeners.elementAt(i);\n        listener.getHelp(event);\n    }\n    if (event.result == null)\n        return code;\n    char[] data = (event.result + \"\\0\").toCharArray();\n    int ptr = COM.SysAllocString(data);\n    COM.MoveMemory(pszHelp, new int[] { ptr }, 4);\n    return COM.S_OK;\n}",
			"comments":"/* Get the default help string from the OS. */\n// proxy doesn't know about app childID\n",
			"methodName":"int get_accHelp(int varChild_vt, int varChild_reserved1, int varChild_lVal, int varChild_reserved2, int pszHelp)"
		},
		"void checkWidget()":{
			"methodBody":"{\n    if (!isValidThread())\n        SWT.error(SWT.ERROR_THREAD_INVALID_ACCESS);\n    if (control.isDisposed())\n        SWT.error(SWT.ERROR_WIDGET_DISPOSED);\n}",
			"comments":"/* checkWidget was copied from Widget, and rewritten to work in this package */\n",
			"methodName":"void checkWidget()"
		},
		"public int method5(int[] args)":{
			"methodBody":"{\n    return Reset();\n}",
			"comments":"",
			"methodName":"public int method5(int[] args)"
		},
		"public int method7(int[] args)":{
			"methodBody":"{\n    return get_accParent(args[0]);\n}",
			"comments":"// method3 GetTypeInfoCount - not implemented\n// method4 GetTypeInfo - not implemented\n// method5 GetIDsOfNames - not implemented\n// method6 Invoke - not implemented\n",
			"methodName":"public int method7(int[] args)"
		},
		"public int method9(int[] args)":{
			"methodBody":"{\n    return get_accChild(args[0], args[1], args[2], args[3], args[4]);\n}",
			"comments":"",
			"methodName":"public int method9(int[] args)"
		},
		"public void textCaretMoved(int index)":{
			"methodBody":"{\n    checkWidget();\n    COM.NotifyWinEvent(COM.EVENT_OBJECT_LOCATIONCHANGE, control.handle, COM.OBJID_CARET, COM.CHILDID_SELF);\n}",
			"comments":"/**\n* Sends a message to accessible clients that the text\n* caret has moved within a custom control.\n*\n* @param index the new caret index within the control\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver's control has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver's control</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public void textCaretMoved(int index)"
		},
		"int get_accFocus(int pvarChild)":{
			"methodBody":"{\n    if (iaccessible == null)\n        return COM.CO_E_OBJNOTCONNECTED;\n    \n    int osChild = ACC.CHILDID_NONE;\n    int code = iaccessible.get_accFocus(pvarChild);\n    if (accessibleControlListeners.size() == 0)\n        return code;\n    if (code == COM.S_OK) {\n        short[] pvt = new short[1];\n        COM.MoveMemory(pvt, pvarChild, 2);\n        if (pvt[0] == COM.VT_I4) {\n            int[] pChild = new int[1];\n            COM.MoveMemory(pChild, pvarChild + 8, 4);\n            osChild = osToChildID(pChild[0]);\n        }\n    }\n    AccessibleControlEvent event = new AccessibleControlEvent(this);\n    event.childID = osChild;\n    for (int i = 0; i < accessibleControlListeners.size(); i++) {\n        AccessibleControlListener listener = (AccessibleControlListener) accessibleControlListeners.elementAt(i);\n        listener.getFocus(event);\n    }\n    Accessible accessible = event.accessible;\n    if (accessible != null) {\n        COM.MoveMemory(pvarChild, new short[] { COM.VT_DISPATCH }, 2);\n        COM.MoveMemory(pvarChild + 8, new int[] { accessible.objIAccessible.getAddress() }, 4);\n        return COM.S_OK;\n    }\n    int childID = event.childID;\n    if (childID == ACC.CHILDID_NONE) {\n        COM.MoveMemory(pvarChild, new short[] { COM.VT_EMPTY }, 2);\n        return COM.S_FALSE;\n    }\n    if (childID == ACC.CHILDID_SELF) {\n        COM.MoveMemory(pvarChild, new short[] { COM.VT_DISPATCH }, 2);\n        COM.MoveMemory(pvarChild + 8, new int[] { objIAccessible.getAddress() }, 4);\n        return COM.S_OK;\n    }\n    COM.MoveMemory(pvarChild, new short[] { COM.VT_I4 }, 2);\n    COM.MoveMemory(pvarChild + 8, new int[] { childIDToOs(childID) }, 4);\n    return COM.S_OK;\n}",
			"comments":"/* Get the default focus child from the OS. */\n",
			"methodName":"int get_accFocus(int pvarChild)"
		},
		"int Skip(int celt)":{
			"methodBody":"{\n    \n    if (accessibleControlListeners.size() == 0) {\n        int[] ppvObject = new int[1];\n        int code = iaccessible.QueryInterface(COM.IIDIEnumVARIANT, ppvObject);\n        if (code != COM.S_OK)\n            return code;\n        IEnumVARIANT ienumvariant = new IEnumVARIANT(ppvObject[0]);\n        code = ienumvariant.Skip(celt);\n        return code;\n    }\n    if (celt < 1)\n        return COM.E_INVALIDARG;\n    enumIndex += celt;\n    if (enumIndex > (variants.length - 1)) {\n        enumIndex = variants.length - 1;\n        return COM.S_FALSE;\n    }\n    return COM.S_OK;\n}",
			"comments":"/* Skip over the specified number of elements in the enumeration sequence. */\n/* If there are no listeners, query the proxy\n* for its IEnumVariant, and tell it to Skip.\n*/\n",
			"methodName":"int Skip(int celt)"
		},
		"public int method24(int[] args)":{
			"methodBody":"{\n    return accHitTest(args[0], args[1], args[2]);\n}",
			"comments":"",
			"methodName":"public int method24(int[] args)"
		},
		"public void removeAccessibleListener(AccessibleListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    accessibleListeners.removeElement(listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when an accessible client asks for certain strings,\n* such as name, description, help, or keyboard shortcut.\n*\n* @param listener the listener that should no longer be notified when the receiver\n* is asked for a name, description, help, or keyboard shortcut string\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver's control has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver's control</li>\n* </ul>\n*\n* @see AccessibleListener\n* @see #addAccessibleListener\n*/\n",
			"methodName":"public void removeAccessibleListener(AccessibleListener listener)"
		},
		"public int method8(int[] args)":{
			"methodBody":"{\n    return get_accChildCount(args[0]);\n}",
			"comments":"",
			"methodName":"public int method8(int[] args)"
		},
		"public int method25(int[] args)":{
			"methodBody":"{\n    return accDoDefaultAction(args[0], args[1], args[2], args[3]);\n}",
			"comments":"",
			"methodName":"public int method25(int[] args)"
		},
		"public int method15(int[] args)":{
			"methodBody":"{\n    return get_accHelp(args[0], args[1], args[2], args[3], args[4]);\n}",
			"comments":"",
			"methodName":"public int method15(int[] args)"
		},
		"public int method26(int[] args)":{
			"methodBody":"{\n    return put_accName(args[0], args[1], args[2], args[3], args[4]);\n}",
			"comments":"",
			"methodName":"public int method26(int[] args)"
		},
		"boolean isValidThread()":{
			"methodBody":"{\n    return control.getDisplay().getThread() == Thread.currentThread();\n}",
			"comments":"/* isValidThread was copied from Widget, and rewritten to work in this package */\n",
			"methodName":"boolean isValidThread()"
		},
		"public int method16(int[] args)":{
			"methodBody":"{\n    return get_accHelpTopic(args[0], args[1], args[2], args[3], args[4], args[5]);\n}",
			"comments":"",
			"methodName":"public int method16(int[] args)"
		},
		"public int method27(int[] args)":{
			"methodBody":"{\n    return put_accValue(args[0], args[1], args[2], args[3], args[4]);\n}",
			"comments":"",
			"methodName":"public int method27(int[] args)"
		},
		"int accSelect(int flagsSelect, int varChild_vt, int varChild_reserved1, int varChild_lVal, int varChild_reserved2)":{
			"methodBody":"{\n    if (iaccessible == null)\n        return COM.CO_E_OBJNOTCONNECTED;\n    \n    int code = iaccessible.accSelect(flagsSelect, varChild_vt, varChild_reserved1, varChild_lVal, varChild_reserved2);\n    \n    if (code == COM.E_INVALIDARG)\n        code = COM.S_FALSE;\n    return code;\n}",
			"comments":"// Currently, we don't let the application override this. Forward to the proxy.\n// proxy doesn't know about app childID\n",
			"methodName":"int accSelect(int flagsSelect, int varChild_vt, int varChild_reserved1, int varChild_lVal, int varChild_reserved2)"
		},
		"public void addAccessibleControlListener(AccessibleControlListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    accessibleControlListeners.addElement(listener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when an accessible client asks for custom control\n* specific information. The listener is notified by sending it\n* one of the messages defined in the <code>AccessibleControlListener</code>\n* interface.\n*\n* @param listener the listener that should be notified when the receiver\n* is asked for custom control specific information\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver's control has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver's control</li>\n* </ul>\n*\n* @see AccessibleControlListener\n* @see #removeAccessibleControlListener\n*/\n",
			"methodName":"public void addAccessibleControlListener(AccessibleControlListener listener)"
		},
		"public int method19(int[] args)":{
			"methodBody":"{\n    return get_accSelection(args[0]);\n}",
			"comments":"",
			"methodName":"public int method19(int[] args)"
		},
		"public int method17(int[] args)":{
			"methodBody":"{\n    return get_accKeyboardShortcut(args[0], args[1], args[2], args[3], args[4]);\n}",
			"comments":"",
			"methodName":"public int method17(int[] args)"
		},
		"int get_accName(int varChild_vt, int varChild_reserved1, int varChild_lVal, int varChild_reserved2, int pszName)":{
			"methodBody":"{\n    if (iaccessible == null)\n        return COM.CO_E_OBJNOTCONNECTED;\n    if ((varChild_vt & 0xFFFF) != COM.VT_I4)\n        return COM.E_INVALIDARG;\n    \n    String osName = null;\n    int code = iaccessible.get_accName(varChild_vt, varChild_reserved1, varChild_lVal, varChild_reserved2, pszName);\n    \n    if (code == COM.E_INVALIDARG)\n        code = COM.S_FALSE;\n    if (accessibleListeners.size() == 0)\n        return code;\n    if (code == COM.S_OK) {\n        int[] pName = new int[1];\n        COM.MoveMemory(pName, pszName, 4);\n        int size = COM.SysStringByteLen(pName[0]);\n        if (size > 0) {\n            char[] buffer = new char[(size + 1) / 2];\n            COM.MoveMemory(buffer, pName[0], size);\n            osName = new String(buffer);\n        }\n    }\n    AccessibleEvent event = new AccessibleEvent(this);\n    event.childID = osToChildID(varChild_lVal);\n    event.result = osName;\n    for (int i = 0; i < accessibleListeners.size(); i++) {\n        AccessibleListener listener = (AccessibleListener) accessibleListeners.elementAt(i);\n        listener.getName(event);\n    }\n    if (event.result == null)\n        return code;\n    char[] data = (event.result + \"\\0\").toCharArray();\n    int ptr = COM.SysAllocString(data);\n    COM.MoveMemory(pszName, new int[] { ptr }, 4);\n    return COM.S_OK;\n}",
			"comments":"/* Get the default name from the OS. */\n// proxy doesn't know about app childID\n",
			"methodName":"int get_accName(int varChild_vt, int varChild_reserved1, int varChild_lVal, int varChild_reserved2, int pszName)"
		},
		"public int method18(int[] args)":{
			"methodBody":"{\n    return get_accFocus(args[0]);\n}",
			"comments":"",
			"methodName":"public int method18(int[] args)"
		},
		"int accNavigate(int navDir, int varStart_vt, int varStart_reserved1, int varStart_lVal, int varStart_reserved2, int pvarEndUpAt)":{
			"methodBody":"{\n    if (iaccessible == null)\n        return COM.CO_E_OBJNOTCONNECTED;\n    \n    int code = iaccessible.accNavigate(navDir, varStart_vt, varStart_reserved1, varStart_lVal, varStart_reserved2, pvarEndUpAt);\n    \n    if (code == COM.E_INVALIDARG)\n        code = COM.S_FALSE;\n    return code;\n}",
			"comments":"// Currently, we don't let the application override this. Forward to the proxy.\n// proxy doesn't know about app childID\n",
			"methodName":"int accNavigate(int navDir, int varStart_vt, int varStart_reserved1, int varStart_lVal, int varStart_reserved2, int pvarEndUpAt)"
		},
		"int get_accParent(int ppdispParent)":{
			"methodBody":"{\n    if (iaccessible == null)\n        return COM.CO_E_OBJNOTCONNECTED;\n    \n    return iaccessible.get_accParent(ppdispParent);\n}",
			"comments":"// Currently, we don't let the application override this. Forward to the proxy.\n",
			"methodName":"int get_accParent(int ppdispParent)"
		},
		"public void removeAccessibleControlListener(AccessibleControlListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    accessibleControlListeners.removeElement(listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when an accessible client asks for custom control\n* specific information.\n*\n* @param listener the listener that should no longer be notified when the receiver\n* is asked for custom control specific information\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver's control has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver's control</li>\n* </ul>\n*\n* @see AccessibleControlListener\n* @see #addAccessibleControlListener\n*/\n",
			"methodName":"public void removeAccessibleControlListener(AccessibleControlListener listener)"
		},
		"int stateToOs(int state)":{
			"methodBody":"{\n    int osState = 0;\n    if ((state & ACC.STATE_SELECTED) != 0)\n        osState |= COM.STATE_SYSTEM_SELECTED;\n    if ((state & ACC.STATE_SELECTABLE) != 0)\n        osState |= COM.STATE_SYSTEM_SELECTABLE;\n    if ((state & ACC.STATE_MULTISELECTABLE) != 0)\n        osState |= COM.STATE_SYSTEM_MULTISELECTABLE;\n    if ((state & ACC.STATE_FOCUSED) != 0)\n        osState |= COM.STATE_SYSTEM_FOCUSED;\n    if ((state & ACC.STATE_FOCUSABLE) != 0)\n        osState |= COM.STATE_SYSTEM_FOCUSABLE;\n    if ((state & ACC.STATE_PRESSED) != 0)\n        osState |= COM.STATE_SYSTEM_PRESSED;\n    if ((state & ACC.STATE_CHECKED) != 0)\n        osState |= COM.STATE_SYSTEM_CHECKED;\n    if ((state & ACC.STATE_EXPANDED) != 0)\n        osState |= COM.STATE_SYSTEM_EXPANDED;\n    if ((state & ACC.STATE_COLLAPSED) != 0)\n        osState |= COM.STATE_SYSTEM_COLLAPSED;\n    if ((state & ACC.STATE_HOTTRACKED) != 0)\n        osState |= COM.STATE_SYSTEM_HOTTRACKED;\n    if ((state & ACC.STATE_BUSY) != 0)\n        osState |= COM.STATE_SYSTEM_BUSY;\n    if ((state & ACC.STATE_READONLY) != 0)\n        osState |= COM.STATE_SYSTEM_READONLY;\n    if ((state & ACC.STATE_INVISIBLE) != 0)\n        osState |= COM.STATE_SYSTEM_INVISIBLE;\n    if ((state & ACC.STATE_OFFSCREEN) != 0)\n        osState |= COM.STATE_SYSTEM_OFFSCREEN;\n    if ((state & ACC.STATE_SIZEABLE) != 0)\n        osState |= COM.STATE_SYSTEM_SIZEABLE;\n    if ((state & ACC.STATE_LINKED) != 0)\n        osState |= COM.STATE_SYSTEM_LINKED;\n    return osState;\n}",
			"comments":"",
			"methodName":"int stateToOs(int state)"
		},
		"public void internal_dispose_Accessible()":{
			"methodBody":"{\n    if (iaccessible != null)\n        iaccessible.Release();\n    iaccessible = null;\n    Release();\n}",
			"comments":"/**\n* Invokes platform specific functionality to dispose an accessible object.\n* <p>\n* <b>IMPORTANT:</b> This method is <em>not</em> part of the public\n* API for <code>Accessible</code>. It is marked public only so that it\n* can be shared within the packages provided by SWT. It is not\n* available on all platforms, and should never be called from\n* application code.\n* </p>\n*/\n",
			"methodName":"public void internal_dispose_Accessible()"
		},
		"int Next(int celt, int rgvar, int pceltFetched)":{
			"methodBody":"{\n    \n    if (accessibleControlListeners.size() == 0) {\n        int[] ppvObject = new int[1];\n        int code = iaccessible.QueryInterface(COM.IIDIEnumVARIANT, ppvObject);\n        if (code != COM.S_OK)\n            return code;\n        IEnumVARIANT ienumvariant = new IEnumVARIANT(ppvObject[0]);\n        int[] celtFetched = new int[1];\n        code = ienumvariant.Next(celt, rgvar, celtFetched);\n        COM.MoveMemory(pceltFetched, celtFetched, 4);\n        return code;\n    }\n    if (rgvar == 0)\n        return COM.E_INVALIDARG;\n    if (pceltFetched == 0 && celt != 1)\n        return COM.E_INVALIDARG;\n    if (enumIndex == 0) {\n        AccessibleControlEvent event = new AccessibleControlEvent(this);\n        event.childID = ACC.CHILDID_SELF;\n        for (int i = 0; i < accessibleControlListeners.size(); i++) {\n            AccessibleControlListener listener = (AccessibleControlListener) accessibleControlListeners.elementAt(i);\n            listener.getChildren(event);\n        }\n        variants = event.children;\n    }\n    Object[] nextItems = null;\n    if (variants != null && celt >= 1) {\n        int endIndex = enumIndex + celt - 1;\n        if (endIndex > (variants.length - 1))\n            endIndex = variants.length - 1;\n        if (enumIndex <= endIndex) {\n            nextItems = new Object[endIndex - enumIndex + 1];\n            for (int i = 0; i < nextItems.length; i++) {\n                Object child = variants[enumIndex];\n                if (child instanceof Integer) {\n                    nextItems[i] = new Integer(childIDToOs(((Integer) child).intValue()));\n                } else {\n                    nextItems[i] = child;\n                }\n                enumIndex++;\n            }\n        }\n    }\n    if (nextItems != null) {\n        for (int i = 0; i < nextItems.length; i++) {\n            Object nextItem = nextItems[i];\n            if (nextItem instanceof Integer) {\n                int item = ((Integer) nextItem).intValue();\n                COM.MoveMemory(rgvar + i * 16, new short[] { COM.VT_I4 }, 2);\n                COM.MoveMemory(rgvar + i * 16 + 8, new int[] { item }, 4);\n            } else {\n                int address = ((Accessible) nextItem).objIAccessible.getAddress();\n                COM.MoveMemory(rgvar + i * 16, new short[] { COM.VT_DISPATCH }, 2);\n                COM.MoveMemory(rgvar + i * 16 + 8, new int[] { address }, 4);\n            }\n        }\n        if (pceltFetched != 0)\n            COM.MoveMemory(pceltFetched, new int[] { nextItems.length }, 4);\n        if (nextItems.length == celt)\n            return COM.S_OK;\n    } else {\n        if (pceltFetched != 0)\n            COM.MoveMemory(pceltFetched, new int[] { 0 }, 4);\n    }\n    return COM.S_FALSE;\n}",
			"comments":"/* IEnumVARIANT methods: Next, Skip, Reset */\n/* Retrieve the next celt items in the enumeration sequence.\n* If there are fewer than the requested number of elements left\n* in the sequence, retrieve the remaining elements.\n* The number of elements actually retrieved is returned in pceltFetched\n* (unless the caller passed in NULL for that parameter).\n*/\n/* If there are no listeners, query the proxy for\n* its IEnumVariant, and get the Next items from it.\n*/\n",
			"methodName":"int Next(int celt, int rgvar, int pceltFetched)"
		},
		"int accLocation(int pxLeft, int pyTop, int pcxWidth, int pcyHeight, int varChild_vt, int varChild_reserved1, int varChild_lVal, int varChild_reserved2)":{
			"methodBody":"{\n    if (iaccessible == null)\n        return COM.CO_E_OBJNOTCONNECTED;\n    if ((varChild_vt & 0xFFFF) != COM.VT_I4)\n        return COM.E_INVALIDARG;\n    \n    int osLeft = 0, osTop = 0, osWidth = 0, osHeight = 0;\n    int code = iaccessible.accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild_vt, varChild_reserved1, varChild_lVal, varChild_reserved2);\n    \n    if (code == COM.E_INVALIDARG)\n        code = COM.S_FALSE;\n    if (accessibleControlListeners.size() == 0)\n        return code;\n    if (code == COM.S_OK) {\n        int[] pLeft = new int[1], pTop = new int[1], pWidth = new int[1], pHeight = new int[1];\n        COM.MoveMemory(pLeft, pxLeft, 4);\n        COM.MoveMemory(pTop, pyTop, 4);\n        COM.MoveMemory(pWidth, pcxWidth, 4);\n        COM.MoveMemory(pHeight, pcyHeight, 4);\n        osLeft = pLeft[0];\n        osTop = pTop[0];\n        osWidth = pWidth[0];\n        osHeight = pHeight[0];\n    }\n    AccessibleControlEvent event = new AccessibleControlEvent(this);\n    event.childID = osToChildID(varChild_lVal);\n    event.x = osLeft;\n    event.y = osTop;\n    event.width = osWidth;\n    event.height = osHeight;\n    for (int i = 0; i < accessibleControlListeners.size(); i++) {\n        AccessibleControlListener listener = (AccessibleControlListener) accessibleControlListeners.elementAt(i);\n        listener.getLocation(event);\n    }\n    OS.MoveMemory(pxLeft, new int[] { event.x }, 4);\n    OS.MoveMemory(pyTop, new int[] { event.y }, 4);\n    OS.MoveMemory(pcxWidth, new int[] { event.width }, 4);\n    OS.MoveMemory(pcyHeight, new int[] { event.height }, 4);\n    return COM.S_OK;\n}",
			"comments":"/* Get the default location from the OS. */\n// proxy doesn't know about app childID\n",
			"methodName":"int accLocation(int pxLeft, int pyTop, int pcxWidth, int pcyHeight, int varChild_vt, int varChild_reserved1, int varChild_lVal, int varChild_reserved2)"
		},
		"public void textSelectionChanged()":{
			"methodBody":"{\n    checkWidget();\n\n}",
			"comments":"/**\n* Sends a message to accessible clients that the text\n* selection has changed within a custom control.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver's control has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver's control</li>\n* </ul>\n*\n* @since 3.0\n*/\n// not an MSAA event\n",
			"methodName":"public void textSelectionChanged()"
		}
	},
	"ClassORInterfaceName":[
		"Accessible"
	]
}
