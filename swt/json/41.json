{
	"variables":[
		"marginWidth",
		"marginHeight",
		"MIN_TAB_WIDTH",
		"borderInsideRGB",
		"borderMiddleRGB",
		"borderOutsideRGB",
		"xClient",
		"yClient",
		"onBottom",
		"single",
		"simple",
		"fixedTabHeight",
		"tabHeight",
		"minChars",
		"items",
		"firstIndex",
		"selectedIndex",
		"priority",
		"mru",
		"folderListeners",
		"tabListeners",
		"selectionBgImage",
		"selectionGradientColors",
		"selectionGradientPercents",
		"selectionGradientVertical",
		"selectionForeground",
		"selectionBackground",
		"bgImage",
		"gradientColors",
		"gradientPercents",
		"gradientVertical",
		"showUnselectedImage",
		"borderColor",
		"showClose",
		"showUnselectedClose",
		"chevronRect",
		"chevronImageState",
		"showChevron",
		"showMenu",
		"showMin",
		"minRect",
		"minimized",
		"minImageState",
		"showMax",
		"maxRect",
		"maximized",
		"maxImageState",
		"topRight",
		"topRightRect",
		"topRightAlignment",
		"borderLeft",
		"borderRight",
		"borderTop",
		"borderBottom",
		"highlight_margin",
		"highlight_header",
		"curve",
		"curveWidth",
		"curveIndent",
		"inDispose",
		"oldSize",
		"oldFont",
		"toolTipEvents",
		"toolTipListener",
		"toolTipShell",
		"toolTipLabel",
		"DEFAULT_WIDTH",
		"DEFAULT_HEIGHT",
		"BUTTON_SIZE",
		"TOP_LEFT_CORNER",
		"TOP_RIGHT_CORNER",
		"BOTTOM_LEFT_CORNER",
		"BOTTOM_RIGHT_CORNER",
		"SIMPLE_TOP_LEFT_CORNER",
		"SIMPLE_TOP_RIGHT_CORNER",
		"SIMPLE_BOTTOM_LEFT_CORNER",
		"SIMPLE_BOTTOM_RIGHT_CORNER",
		"SELECTION_FOREGROUND",
		"SELECTION_BACKGROUND",
		"BORDER1_COLOR",
		"FOREGROUND",
		"BACKGROUND",
		"BUTTON_BORDER",
		"BUTTON_FILL",
		"NONE",
		"NORMAL",
		"HOT",
		"SELECTED",
		"CLOSE_FILL",
		"style2",
		"display",
		"listener",
		"folderEvents",
		"i",
		"mask",
		"platform",
		"clipping",
		"newListeners",
		"newTabListeners",
		"typedListener",
		"index",
		"left",
		"oldY",
		"outer",
		"i",
		"from",
		"to",
		"red",
		"green",
		"blue",
		"color",
		"inner",
		"index",
		"left",
		"oldY",
		"i",
		"from",
		"to",
		"red",
		"green",
		"blue",
		"color",
		"trimX",
		"trimWidth",
		"trimY",
		"trimHeight",
		"trimY",
		"trimHeight",
		"newItems",
		"newPriority",
		"next",
		"priorityIndex",
		"i",
		"index",
		"control",
		"newItems",
		"newPriority",
		"next",
		"i",
		"control",
		"nextSelection",
		"defaultBackground",
		"image",
		"colors",
		"percents",
		"vertical",
		"size",
		"width",
		"height",
		"x",
		"y",
		"clipping",
		"region",
		"imageRect",
		"background",
		"pos",
		"lastColor",
		"i",
		"gradientHeight",
		"lastColor",
		"pos",
		"i",
		"gradientHeight",
		"lastColor",
		"pos",
		"i",
		"gradientWidth",
		"gc",
		"size",
		"width",
		"height",
		"shape",
		"x1",
		"y1",
		"x2",
		"y2",
		"x1",
		"y1",
		"x2",
		"y2",
		"height",
		"x1",
		"x2",
		"y1",
		"y2",
		"display",
		"dpi",
		"fontHeight",
		"fd",
		"f",
		"fHeight",
		"indent",
		"x",
		"y",
		"count",
		"showCount",
		"chevronString",
		"chevronBorder",
		"display",
		"x",
		"y",
		"display",
		"x",
		"y",
		"gc",
		"size",
		"shape",
		"x1",
		"x2",
		"y1",
		"y2",
		"x",
		"y",
		"width",
		"height",
		"left",
		"right",
		"index",
		"i",
		"i",
		"left",
		"right",
		"index",
		"i",
		"i",
		"bkSelected",
		"r",
		"i",
		"item",
		"x1",
		"y1",
		"x2",
		"outside",
		"size",
		"width",
		"height",
		"size",
		"i",
		"item",
		"rect",
		"tabItems",
		"index",
		"length",
		"x",
		"rightSize",
		"style",
		"i",
		"accessible",
		"name",
		"childID",
		"index",
		"help",
		"childID",
		"shortcut",
		"childID",
		"text",
		"mnemonic",
		"testPoint",
		"childID",
		"i",
		"location",
		"location",
		"childID",
		"pt",
		"action",
		"childID",
		"childID",
		"role",
		"childID",
		"state",
		"childID",
		"children",
		"i",
		"count",
		"leadKey",
		"offset",
		"index",
		"visible",
		"idx",
		"current",
		"i",
		"e",
		"i",
		"length",
		"i",
		"consume",
		"i",
		"key",
		"i",
		"mnemonic",
		"e",
		"x",
		"y",
		"i",
		"item",
		"item",
		"bounds",
		"i",
		"bounds",
		"index",
		"close",
		"minimize",
		"maximize",
		"chevron",
		"i",
		"item",
		"selected",
		"e",
		"i",
		"selected",
		"e",
		"i",
		"selected",
		"e",
		"i",
		"item",
		"bounds",
		"i",
		"bounds",
		"selected",
		"e",
		"j",
		"listener",
		"j",
		"listener",
		"display",
		"pt",
		"nextItem",
		"count",
		"index",
		"offset",
		"visible",
		"idx",
		"current",
		"i",
		"e",
		"i",
		"font",
		"gc",
		"gcFont",
		"gcBackground",
		"gcForeground",
		"size",
		"x1",
		"y1",
		"x2",
		"y2",
		"size",
		"index",
		"i",
		"newTabListeners",
		"index",
		"i",
		"newTabListeners",
		"i",
		"same",
		"i",
		"i",
		"i",
		"i",
		"rectBefore",
		"rectAfter",
		"size",
		"oldX",
		"oldY",
		"oldWidth",
		"oldHeight",
		"left",
		"right",
		"top",
		"left",
		"right",
		"top",
		"rightEdge",
		"item",
		"item",
		"topRightSize",
		"rightEdge",
		"left",
		"right",
		"top",
		"item",
		"w",
		"i",
		"lastIndex",
		"lastItem",
		"w",
		"left",
		"right",
		"top",
		"changed",
		"size",
		"y",
		"defaultX",
		"i",
		"item",
		"oldX",
		"oldY",
		"rightItemEdge",
		"maxWidth",
		"width",
		"i",
		"item",
		"x",
		"defaultX",
		"i",
		"item",
		"edge",
		"changed",
		"size",
		"tab",
		"gc",
		"width",
		"widths",
		"gc",
		"tabAreaWidth",
		"rightSize",
		"minWidth",
		"minWidths",
		"i",
		"index",
		"index",
		"maxWidth",
		"maxWidths",
		"i",
		"extra",
		"large",
		"totalWidth",
		"i",
		"i",
		"i",
		"tab",
		"width",
		"idx",
		"next",
		"i",
		"i",
		"index",
		"selection",
		"oldIndex",
		"control",
		"oldSelectedIndex",
		"event",
		"i",
		"same",
		"i",
		"i",
		"i",
		"i",
		"rectBefore",
		"rectAfter",
		"i",
		"rectBefore",
		"rectAfter",
		"rectBefore",
		"rectAfter",
		"index",
		"idx",
		"i",
		"newPriority",
		"items",
		"i",
		"id",
		"i",
		"tab",
		"item",
		"menuItem",
		"index",
		"x",
		"y",
		"location",
		"i",
		"display",
		"i",
		"firstIndex",
		"maxWidth",
		"width",
		"widths",
		"gc",
		"i",
		"i",
		"i",
		"i",
		"index",
		"i",
		"i",
		"oldShowChevron",
		"changed",
		"pt",
		"oldHeight",
		"tempHeight",
		"gc",
		"i",
		"d",
		"d",
		"item",
		"tooltip",
		"labelSize",
		"area",
		"cursorLocation",
		"cursorHeight",
		"size",
		"rect",
		"pt",
		"SWT",
		"NORMAL",
		"NORMAL",
		"NORMAL",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"parent",
		"parent",
		"style",
		"oldFont",
		"onBottom",
		"style2",
		"SWT",
		"showClose",
		"style2",
		"SWT",
		"single",
		"style2",
		"SWT",
		"borderLeft",
		"borderRight",
		"style",
		"SWT",
		"borderTop",
		"onBottom",
		"borderLeft",
		"borderBottom",
		"onBottom",
		"borderLeft",
		"highlight_header",
		"style",
		"SWT",
		"highlight_margin",
		"style",
		"SWT",
		"selectionForeground",
		"display",
		"SELECTION_FOREGROUND",
		"selectionBackground",
		"display",
		"SELECTION_BACKGROUND",
		"borderColor",
		"display",
		"BORDER1_COLOR",
		"event",
		"SWT",
		"SWT",
		"event",
		"SWT",
		"event",
		"SWT",
		"event",
		"SWT",
		"event",
		"SWT",
		"event",
		"SWT",
		"event",
		"SWT",
		"event",
		"SWT",
		"event",
		"SWT",
		"event",
		"SWT",
		"event",
		"SWT",
		"event",
		"SWT",
		"SWT",
		"event",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"i",
		"folderEvents",
		"i",
		"folderEvents",
		"i",
		"listener",
		"toolTipListener",
		"event",
		"SWT",
		"SWT",
		"event",
		"event",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"style",
		"mask",
		"style",
		"SWT",
		"style",
		"style",
		"SWT",
		"style",
		"SWT",
		"style",
		"style",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"platform",
		"platform",
		"style",
		"style",
		"SWT",
		"style",
		"parent",
		"SWT",
		"style",
		"SWT",
		"style",
		"style",
		"SWT",
		"gc",
		"clipping",
		"region",
		"clipping",
		"gc",
		"region",
		"gc",
		"region",
		"gc",
		"clipping",
		"clipping",
		"listener",
		"SWT",
		"SWT",
		"folderListeners",
		"System",
		"folderListeners",
		"newListeners",
		"folderListeners",
		"folderListeners",
		"newListeners",
		"folderListeners",
		"folderListeners",
		"listener",
		"listener",
		"SWT",
		"SWT",
		"tabListeners",
		"System",
		"tabListeners",
		"newTabListeners",
		"tabListeners",
		"tabListeners",
		"newTabListeners",
		"tabListeners",
		"tabListeners",
		"listener",
		"showClose",
		"showClose",
		"listener",
		"SWT",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"SWT",
		"typedListener",
		"simple",
		"SWT",
		"outerRGB",
		"onBottom",
		"shape",
		"i",
		"shape",
		"i",
		"left",
		"index",
		"shape",
		"left",
		"onBottom",
		"oldY",
		"shape",
		"index",
		"oldY",
		"shape",
		"index",
		"oldY",
		"shape",
		"index",
		"outer",
		"index",
		"shape",
		"index",
		"left",
		"outer",
		"index",
		"shape",
		"index",
		"lineRGB",
		"outerRGB",
		"from",
		"to",
		"from",
		"from",
		"to",
		"from",
		"from",
		"to",
		"from",
		"red",
		"green",
		"blue",
		"gc",
		"color",
		"gc",
		"outer",
		"color",
		"innerRGB",
		"shape",
		"onBottom",
		"i",
		"shape",
		"i",
		"left",
		"index",
		"shape",
		"left",
		"onBottom",
		"oldY",
		"shape",
		"index",
		"oldY",
		"shape",
		"index",
		"oldY",
		"shape",
		"index",
		"inner",
		"index",
		"shape",
		"index",
		"left",
		"inner",
		"index",
		"shape",
		"index",
		"lineRGB",
		"innerRGB",
		"from",
		"to",
		"from",
		"from",
		"to",
		"from",
		"from",
		"to",
		"from",
		"red",
		"green",
		"blue",
		"gc",
		"color",
		"gc",
		"inner",
		"color",
		"x",
		"marginWidth",
		"highlight_margin",
		"borderLeft",
		"width",
		"borderLeft",
		"borderRight",
		"marginWidth",
		"highlight_margin",
		"minimized",
		"onBottom",
		"y",
		"borderTop",
		"y",
		"highlight_header",
		"tabHeight",
		"borderTop",
		"borderTop",
		"borderBottom",
		"tabHeight",
		"highlight_header",
		"trimX",
		"trimY",
		"trimWidth",
		"trimHeight",
		"onBottom",
		"y",
		"marginHeight",
		"highlight_margin",
		"borderTop",
		"y",
		"marginHeight",
		"highlight_header",
		"tabHeight",
		"borderTop",
		"height",
		"borderTop",
		"borderBottom",
		"marginHeight",
		"tabHeight",
		"highlight_header",
		"highlight_margin",
		"trimX",
		"trimY",
		"trimWidth",
		"trimHeight",
		"index",
		"index",
		"SWT",
		"SWT",
		"item",
		"items",
		"System",
		"items",
		"newItems",
		"index",
		"newItems",
		"index",
		"item",
		"System",
		"items",
		"index",
		"newItems",
		"index",
		"items",
		"index",
		"items",
		"newItems",
		"selectedIndex",
		"index",
		"selectedIndex",
		"priority",
		"priority",
		"i",
		"priority",
		"i",
		"mru",
		"priority",
		"i",
		"index",
		"priorityIndex",
		"next",
		"newPriority",
		"next",
		"priority",
		"i",
		"index",
		"priority",
		"i",
		"priority",
		"i",
		"newPriority",
		"priorityIndex",
		"index",
		"priority",
		"newPriority",
		"items",
		"inDispose",
		"item",
		"index",
		"items",
		"items",
		"priority",
		"firstIndex",
		"selectedIndex",
		"item",
		"control",
		"control",
		"control",
		"items",
		"System",
		"items",
		"newItems",
		"index",
		"System",
		"items",
		"index",
		"newItems",
		"index",
		"items",
		"index",
		"items",
		"newItems",
		"priority",
		"i",
		"priority",
		"i",
		"priority",
		"i",
		"index",
		"newPriority",
		"next",
		"priority",
		"i",
		"index",
		"priority",
		"i",
		"priority",
		"i",
		"priority",
		"newPriority",
		"selectedIndex",
		"index",
		"item",
		"selectedIndex",
		"mru",
		"priority",
		"Math",
		"index",
		"nextSelection",
		"control",
		"control",
		"control",
		"selectedIndex",
		"index",
		"selectedIndex",
		"selected",
		"selectionBackground",
		"selected",
		"selectionBgImage",
		"bgImage",
		"selected",
		"selectionGradientColors",
		"gradientColors",
		"selected",
		"selectionGradientPercents",
		"gradientPercents",
		"selected",
		"selectionGradientVertical",
		"gradientVertical",
		"size",
		"tabHeight",
		"highlight_header",
		"borderLeft",
		"x",
		"width",
		"onBottom",
		"size",
		"borderBottom",
		"height",
		"borderTop",
		"gc",
		"shape",
		"x",
		"y",
		"width",
		"height",
		"defaultBackground",
		"image",
		"colors",
		"percents",
		"vertical",
		"gc",
		"clipping",
		"region",
		"shape",
		"region",
		"clipping",
		"gc",
		"region",
		"image",
		"gc",
		"defaultBackground",
		"gc",
		"x",
		"y",
		"width",
		"height",
		"image",
		"gc",
		"image",
		"imageRect",
		"imageRect",
		"imageRect",
		"imageRect",
		"x",
		"y",
		"width",
		"height",
		"colors",
		"colors",
		"colors",
		"colors",
		"defaultBackground",
		"gc",
		"background",
		"gc",
		"x",
		"y",
		"width",
		"height",
		"vertical",
		"onBottom",
		"percents",
		"percents",
		"pos",
		"percents",
		"percents",
		"height",
		"gc",
		"defaultBackground",
		"gc",
		"x",
		"y",
		"width",
		"pos",
		"colors",
		"colors",
		"lastColor",
		"lastColor",
		"defaultBackground",
		"percents",
		"i",
		"i",
		"gc",
		"lastColor",
		"lastColor",
		"colors",
		"i",
		"lastColor",
		"lastColor",
		"defaultBackground",
		"gc",
		"lastColor",
		"percents",
		"i",
		"height",
		"gc",
		"x",
		"y",
		"pos",
		"width",
		"gradientHeight",
		"pos",
		"gradientHeight",
		"colors",
		"lastColor",
		"lastColor",
		"defaultBackground",
		"i",
		"percents",
		"i",
		"gc",
		"lastColor",
		"lastColor",
		"colors",
		"i",
		"lastColor",
		"lastColor",
		"defaultBackground",
		"gc",
		"lastColor",
		"percents",
		"i",
		"height",
		"gc",
		"x",
		"y",
		"pos",
		"width",
		"gradientHeight",
		"pos",
		"gradientHeight",
		"pos",
		"height",
		"gc",
		"defaultBackground",
		"gc",
		"x",
		"pos",
		"width",
		"height",
		"pos",
		"y",
		"height",
		"colors",
		"lastColor",
		"lastColor",
		"defaultBackground",
		"i",
		"percents",
		"i",
		"gc",
		"lastColor",
		"lastColor",
		"colors",
		"i",
		"lastColor",
		"lastColor",
		"defaultBackground",
		"gc",
		"lastColor",
		"percents",
		"i",
		"width",
		"pos",
		"gc",
		"x",
		"pos",
		"y",
		"gradientWidth",
		"height",
		"pos",
		"gradientWidth",
		"pos",
		"width",
		"gc",
		"defaultBackground",
		"gc",
		"x",
		"pos",
		"y",
		"width",
		"pos",
		"height",
		"SWT",
		"defaultBackground",
		"gc",
		"defaultBackground",
		"gc",
		"x",
		"y",
		"width",
		"height",
		"gc",
		"clipping",
		"clipping",
		"region",
		"event",
		"minimized",
		"size",
		"borderLeft",
		"borderRight",
		"highlight_margin",
		"size",
		"borderTop",
		"borderBottom",
		"tabHeight",
		"highlight_header",
		"highlight_margin",
		"highlight_margin",
		"onBottom",
		"borderLeft",
		"borderTop",
		"size",
		"borderRight",
		"size",
		"borderBottom",
		"tabHeight",
		"highlight_header",
		"shape",
		"x1",
		"y1",
		"x2",
		"y1",
		"x2",
		"y2",
		"x2",
		"highlight_margin",
		"y2",
		"x2",
		"highlight_margin",
		"y1",
		"highlight_margin",
		"x1",
		"highlight_margin",
		"y1",
		"highlight_margin",
		"x1",
		"highlight_margin",
		"y2",
		"x1",
		"y2",
		"borderLeft",
		"borderTop",
		"tabHeight",
		"highlight_header",
		"size",
		"borderRight",
		"size",
		"borderBottom",
		"shape",
		"x1",
		"y1",
		"x1",
		"highlight_margin",
		"y1",
		"x1",
		"highlight_margin",
		"y2",
		"highlight_margin",
		"x2",
		"highlight_margin",
		"y2",
		"highlight_margin",
		"x2",
		"highlight_margin",
		"y1",
		"x2",
		"y1",
		"x2",
		"y2",
		"x1",
		"y2",
		"selectedIndex",
		"selectionGradientColors",
		"selectionGradientColors",
		"selectionGradientVertical",
		"gc",
		"shape",
		"selectedIndex",
		"gradientColors",
		"gradientColors",
		"gradientVertical",
		"gc",
		"shape",
		"gc",
		"selectedIndex",
		"selectionBackground",
		"gc",
		"shape",
		"SWT",
		"gc",
		"gc",
		"xClient",
		"marginWidth",
		"yClient",
		"marginHeight",
		"width",
		"height",
		"SWT",
		"borderTop",
		"tabHeight",
		"highlight_header",
		"borderBottom",
		"size",
		"height",
		"gc",
		"gc",
		"height",
		"size",
		"size",
		"height",
		"borderLeft",
		"gc",
		"borderColor",
		"borderLeft",
		"size",
		"borderRight",
		"onBottom",
		"borderTop",
		"borderTop",
		"tabHeight",
		"onBottom",
		"size",
		"tabHeight",
		"borderBottom",
		"size",
		"borderBottom",
		"gc",
		"x1",
		"y1",
		"x1",
		"y2",
		"gc",
		"x2",
		"y1",
		"x2",
		"y2",
		"onBottom",
		"gc",
		"x1",
		"y1",
		"x2",
		"y1",
		"gc",
		"x1",
		"y2",
		"x2",
		"y2",
		"chevronRect",
		"chevronRect",
		"display",
		"dpi",
		"fd",
		"fontHeight",
		"display",
		"fd",
		"f",
		"display",
		"Math",
		"chevronRect",
		"fHeight",
		"chevronRect",
		"chevronRect",
		"indent",
		"single",
		"count",
		"selectedIndex",
		"items",
		"items",
		"showCount",
		"priority",
		"items",
		"priority",
		"showCount",
		"showCount",
		"count",
		"items",
		"showCount",
		"count",
		"String",
		"count",
		"chevronImageState",
		"NORMAL",
		"single",
		"gc",
		"chevronBorder",
		"gc",
		"f",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"chevronString",
		"x",
		"y",
		"HOT",
		"gc",
		"display",
		"BUTTON_BORDER",
		"gc",
		"display",
		"BUTTON_FILL",
		"gc",
		"f",
		"gc",
		"chevronRect",
		"chevronRect",
		"chevronRect",
		"chevronRect",
		"gc",
		"chevronRect",
		"chevronRect",
		"chevronRect",
		"chevronRect",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"chevronString",
		"x",
		"y",
		"SELECTED",
		"gc",
		"display",
		"BUTTON_BORDER",
		"gc",
		"display",
		"BUTTON_FILL",
		"gc",
		"f",
		"gc",
		"chevronRect",
		"chevronRect",
		"chevronRect",
		"chevronRect",
		"gc",
		"chevronRect",
		"chevronRect",
		"chevronRect",
		"chevronRect",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"chevronString",
		"x",
		"y",
		"f",
		"maxRect",
		"maxRect",
		"maxRect",
		"CTabFolder",
		"maxRect",
		"gc",
		"display",
		"BUTTON_BORDER",
		"gc",
		"display",
		"BUTTON_FILL",
		"maxImageState",
		"NORMAL",
		"maximized",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"HOT",
		"gc",
		"maxRect",
		"maxRect",
		"maxRect",
		"maxRect",
		"gc",
		"maxRect",
		"maxRect",
		"maxRect",
		"maxRect",
		"maximized",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"SELECTED",
		"gc",
		"maxRect",
		"maxRect",
		"maxRect",
		"maxRect",
		"gc",
		"maxRect",
		"maxRect",
		"maxRect",
		"maxRect",
		"maximized",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"minRect",
		"minRect",
		"minRect",
		"BUTTON_SIZE",
		"minRect",
		"gc",
		"display",
		"BUTTON_BORDER",
		"gc",
		"display",
		"BUTTON_FILL",
		"minImageState",
		"NORMAL",
		"minimized",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"HOT",
		"gc",
		"minRect",
		"minRect",
		"minRect",
		"minRect",
		"gc",
		"minRect",
		"minRect",
		"minRect",
		"minRect",
		"minimized",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"SELECTED",
		"gc",
		"minRect",
		"minRect",
		"minRect",
		"minRect",
		"gc",
		"minRect",
		"minRect",
		"minRect",
		"minRect",
		"minimized",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"event",
		"tabHeight",
		"borderLeft",
		"size",
		"borderRight",
		"onBottom",
		"size",
		"borderBottom",
		"highlight_header",
		"borderTop",
		"highlight_header",
		"onBottom",
		"size",
		"borderBottom",
		"borderTop",
		"borderLeft",
		"onBottom",
		"y2",
		"shape",
		"x1",
		"y1",
		"x1",
		"y2",
		"x2",
		"y2",
		"x2",
		"y1",
		"selectedIndex",
		"selectionGradientColors",
		"selectionGradientColors",
		"selectionGradientVertical",
		"gc",
		"shape",
		"selectedIndex",
		"gradientColors",
		"gradientColors",
		"gradientVertical",
		"gc",
		"shape",
		"gc",
		"selectedIndex",
		"selectionBackground",
		"gc",
		"shape",
		"borderLeft",
		"gc",
		"borderColor",
		"gc",
		"shape",
		"Math",
		"borderLeft",
		"onBottom",
		"size",
		"borderBottom",
		"tabHeight",
		"borderTop",
		"size",
		"borderLeft",
		"borderRight",
		"tabHeight",
		"onBottom",
		"simple",
		"SIMPLE_BOTTOM_LEFT_CORNER",
		"BOTTOM_LEFT_CORNER",
		"simple",
		"SIMPLE_BOTTOM_RIGHT_CORNER",
		"BOTTOM_RIGHT_CORNER",
		"shape",
		"left",
		"right",
		"shape",
		"index",
		"x",
		"shape",
		"index",
		"y",
		"highlight_header",
		"i",
		"left",
		"i",
		"shape",
		"index",
		"x",
		"left",
		"i",
		"shape",
		"index",
		"y",
		"height",
		"left",
		"i",
		"borderLeft",
		"shape",
		"index",
		"i",
		"right",
		"i",
		"shape",
		"index",
		"x",
		"width",
		"right",
		"i",
		"shape",
		"index",
		"y",
		"height",
		"right",
		"i",
		"borderLeft",
		"shape",
		"index",
		"shape",
		"index",
		"x",
		"width",
		"shape",
		"index",
		"y",
		"highlight_header",
		"simple",
		"SIMPLE_TOP_LEFT_CORNER",
		"TOP_LEFT_CORNER",
		"simple",
		"SIMPLE_TOP_RIGHT_CORNER",
		"TOP_RIGHT_CORNER",
		"shape",
		"left",
		"right",
		"shape",
		"index",
		"x",
		"shape",
		"index",
		"y",
		"height",
		"highlight_header",
		"i",
		"left",
		"i",
		"shape",
		"index",
		"x",
		"left",
		"i",
		"shape",
		"index",
		"y",
		"left",
		"i",
		"i",
		"right",
		"i",
		"shape",
		"index",
		"x",
		"width",
		"right",
		"i",
		"shape",
		"index",
		"y",
		"right",
		"i",
		"shape",
		"index",
		"x",
		"width",
		"shape",
		"index",
		"y",
		"height",
		"highlight_header",
		"single",
		"selectedIndex",
		"gc",
		"shape",
		"bkSelected",
		"r",
		"x",
		"y",
		"width",
		"height",
		"r",
		"shape",
		"gc",
		"gc",
		"r",
		"r",
		"single",
		"i",
		"items",
		"i",
		"i",
		"selectedIndex",
		"event",
		"items",
		"i",
		"items",
		"i",
		"gc",
		"selectedIndex",
		"items",
		"selectedIndex",
		"item",
		"gc",
		"borderLeft",
		"onBottom",
		"size",
		"borderBottom",
		"tabHeight",
		"borderTop",
		"tabHeight",
		"size",
		"borderRight",
		"gc",
		"borderColor",
		"gc",
		"x1",
		"y1",
		"x2",
		"y1",
		"gc",
		"gc",
		"gc",
		"borderLeft",
		"shape",
		"borderColor",
		"outside",
		"gc",
		"gc",
		"borderColor",
		"gc",
		"shape",
		"borderLeft",
		"minimized",
		"xClient",
		"yClient",
		"size",
		"borderLeft",
		"borderRight",
		"marginWidth",
		"highlight_margin",
		"size",
		"borderTop",
		"borderBottom",
		"marginHeight",
		"highlight_margin",
		"highlight_header",
		"height",
		"tabHeight",
		"xClient",
		"yClient",
		"width",
		"height",
		"index",
		"index",
		"items",
		"SWT",
		"SWT",
		"items",
		"index",
		"items",
		"size",
		"borderLeft",
		"borderRight",
		"showChevron",
		"chevronRect",
		"pt",
		"i",
		"priority",
		"i",
		"items",
		"priority",
		"i",
		"item",
		"rect",
		"pt",
		"item",
		"items",
		"items",
		"System",
		"items",
		"tabItems",
		"items",
		"tabItems",
		"string",
		"string",
		"index",
		"length",
		"string",
		"index",
		"index",
		"index",
		"length",
		"string",
		"index",
		"string",
		"index",
		"index",
		"index",
		"length",
		"minimized",
		"showMin",
		"minChars",
		"maximized",
		"showMax",
		"mru",
		"borderRight",
		"showMin",
		"x",
		"BUTTON_SIZE",
		"showMax",
		"x",
		"BUTTON_SIZE",
		"showChevron",
		"x",
		"BUTTON_SIZE",
		"topRight",
		"topRightAlignment",
		"SWT",
		"topRight",
		"SWT",
		"SWT",
		"x",
		"rightSize",
		"Math",
		"x",
		"selectedIndex",
		"items",
		"selectedIndex",
		"selectionBackground",
		"selectionForeground",
		"selectedIndex",
		"simple",
		"single",
		"style",
		"SWT",
		"SWT",
		"style",
		"onBottom",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"style",
		"single",
		"SWT",
		"SWT",
		"borderLeft",
		"style",
		"SWT",
		"style",
		"fixedTabHeight",
		"SWT",
		"fixedTabHeight",
		"tabHeight",
		"onBottom",
		"SWT",
		"SWT",
		"topRight",
		"showUnselectedClose",
		"showUnselectedImage",
		"item",
		"SWT",
		"SWT",
		"i",
		"items",
		"i",
		"items",
		"i",
		"item",
		"i",
		"accessible",
		"e",
		"childID",
		"childID",
		"items",
		"name",
		"items",
		"childID",
		"name",
		"index",
		"name",
		"name",
		"index",
		"name",
		"index",
		"e",
		"name",
		"e",
		"childID",
		"ACC",
		"help",
		"childID",
		"childID",
		"items",
		"help",
		"items",
		"childID",
		"e",
		"help",
		"e",
		"childID",
		"childID",
		"items",
		"items",
		"childID",
		"text",
		"text",
		"mnemonic",
		"shortcut",
		"mnemonic",
		"e",
		"shortcut",
		"accessible",
		"e",
		"e",
		"ACC",
		"i",
		"items",
		"i",
		"items",
		"i",
		"testPoint",
		"childID",
		"i",
		"childID",
		"ACC",
		"location",
		"location",
		"location",
		"testPoint",
		"childID",
		"ACC",
		"e",
		"childID",
		"e",
		"childID",
		"ACC",
		"location",
		"childID",
		"childID",
		"items",
		"location",
		"items",
		"childID",
		"location",
		"location",
		"location",
		"e",
		"pt",
		"e",
		"pt",
		"e",
		"location",
		"e",
		"location",
		"e",
		"items",
		"e",
		"childID",
		"childID",
		"items",
		"action",
		"SWT",
		"e",
		"action",
		"ACC",
		"selectedIndex",
		"childID",
		"ACC",
		"childID",
		"selectedIndex",
		"e",
		"childID",
		"e",
		"childID",
		"ACC",
		"role",
		"ACC",
		"childID",
		"childID",
		"items",
		"role",
		"ACC",
		"e",
		"role",
		"e",
		"selectedIndex",
		"ACC",
		"selectedIndex",
		"e",
		"childID",
		"ACC",
		"state",
		"ACC",
		"childID",
		"childID",
		"items",
		"state",
		"ACC",
		"state",
		"ACC",
		"selectedIndex",
		"childID",
		"state",
		"ACC",
		"state",
		"ACC",
		"e",
		"state",
		"items",
		"i",
		"items",
		"i",
		"children",
		"i",
		"i",
		"e",
		"children",
		"SWT",
		"selectedIndex",
		"accessible",
		"ACC",
		"accessible",
		"selectedIndex",
		"SWT",
		"selectedIndex",
		"accessible",
		"ACC",
		"accessible",
		"selectedIndex",
		"event",
		"SWT",
		"SWT",
		"items",
		"count",
		"selectedIndex",
		"SWT",
		"SWT",
		"SWT",
		"event",
		"leadKey",
		"mru",
		"index",
		"selectedIndex",
		"offset",
		"items",
		"i",
		"items",
		"i",
		"items",
		"i",
		"i",
		"selectedIndex",
		"current",
		"idx",
		"visible",
		"idx",
		"i",
		"current",
		"offset",
		"current",
		"offset",
		"idx",
		"index",
		"visible",
		"current",
		"offset",
		"showChevron",
		"e",
		"e",
		"event",
		"e",
		"chevronRect",
		"e",
		"chevronRect",
		"e",
		"chevronRect",
		"e",
		"chevronRect",
		"e",
		"i",
		"folderListeners",
		"i",
		"folderListeners",
		"i",
		"e",
		"e",
		"chevronRect",
		"index",
		"index",
		"count",
		"index",
		"inDispose",
		"showMenu",
		"showMenu",
		"showMenu",
		"showMenu",
		"items",
		"i",
		"length",
		"i",
		"items",
		"i",
		"items",
		"i",
		"selectionGradientColors",
		"selectionGradientPercents",
		"selectionBgImage",
		"selectionBackground",
		"selectionForeground",
		"chevronRect",
		"event",
		"event",
		"minRect",
		"event",
		"event",
		"maxRect",
		"event",
		"event",
		"consume",
		"i",
		"items",
		"i",
		"items",
		"i",
		"event",
		"event",
		"consume",
		"consume",
		"event",
		"SWT",
		"selectedIndex",
		"event",
		"i",
		"items",
		"i",
		"items",
		"i",
		"items",
		"i",
		"mnemonic",
		"Character",
		"key",
		"Character",
		"mnemonic",
		"i",
		"event",
		"event",
		"SWT",
		"event",
		"SWT",
		"e",
		"event",
		"event",
		"e",
		"SWT",
		"e",
		"event",
		"event",
		"event",
		"event",
		"event",
		"SWT",
		"minImageState",
		"NORMAL",
		"minImageState",
		"NORMAL",
		"minRect",
		"minRect",
		"minRect",
		"minRect",
		"maxImageState",
		"NORMAL",
		"maxImageState",
		"NORMAL",
		"maxRect",
		"maxRect",
		"maxRect",
		"maxRect",
		"chevronImageState",
		"NORMAL",
		"chevronImageState",
		"NORMAL",
		"chevronRect",
		"chevronRect",
		"chevronRect",
		"chevronRect",
		"i",
		"items",
		"i",
		"items",
		"i",
		"i",
		"selectedIndex",
		"item",
		"NONE",
		"item",
		"NONE",
		"item",
		"item",
		"item",
		"item",
		"i",
		"selectedIndex",
		"item",
		"NORMAL",
		"item",
		"NORMAL",
		"item",
		"item",
		"item",
		"item",
		"SWT",
		"minRect",
		"x",
		"y",
		"event",
		"minImageState",
		"SELECTED",
		"minRect",
		"minRect",
		"minRect",
		"minRect",
		"maxRect",
		"x",
		"y",
		"event",
		"maxImageState",
		"SELECTED",
		"maxRect",
		"maxRect",
		"maxRect",
		"maxRect",
		"chevronRect",
		"x",
		"y",
		"event",
		"chevronImageState",
		"HOT",
		"chevronImageState",
		"HOT",
		"chevronImageState",
		"SELECTED",
		"chevronRect",
		"chevronRect",
		"chevronRect",
		"chevronRect",
		"single",
		"selectedIndex",
		"items",
		"selectedIndex",
		"bounds",
		"x",
		"y",
		"item",
		"items",
		"selectedIndex",
		"i",
		"items",
		"i",
		"items",
		"i",
		"bounds",
		"x",
		"y",
		"item",
		"items",
		"i",
		"item",
		"item",
		"x",
		"y",
		"event",
		"item",
		"SELECTED",
		"item",
		"item",
		"item",
		"item",
		"item",
		"item",
		"index",
		"SWT",
		"minRect",
		"x",
		"y",
		"minimize",
		"minImageState",
		"SELECTED",
		"minImageState",
		"HOT",
		"minImageState",
		"HOT",
		"minRect",
		"minRect",
		"minRect",
		"minRect",
		"maxRect",
		"x",
		"y",
		"maximize",
		"maxImageState",
		"SELECTED",
		"maxImageState",
		"HOT",
		"maxImageState",
		"HOT",
		"maxRect",
		"maxRect",
		"maxRect",
		"maxRect",
		"chevronRect",
		"x",
		"y",
		"chevron",
		"chevronImageState",
		"SELECTED",
		"chevronImageState",
		"HOT",
		"chevronImageState",
		"HOT",
		"chevronRect",
		"chevronRect",
		"chevronRect",
		"chevronRect",
		"minImageState",
		"NORMAL",
		"minimize",
		"minImageState",
		"NORMAL",
		"minRect",
		"minRect",
		"minRect",
		"minRect",
		"maxImageState",
		"NORMAL",
		"maximize",
		"maxImageState",
		"NORMAL",
		"maxRect",
		"maxRect",
		"maxRect",
		"maxRect",
		"chevronImageState",
		"NORMAL",
		"chevron",
		"chevronImageState",
		"NORMAL",
		"chevronRect",
		"chevronRect",
		"chevronRect",
		"chevronRect",
		"i",
		"items",
		"i",
		"items",
		"i",
		"close",
		"item",
		"x",
		"y",
		"close",
		"item",
		"x",
		"y",
		"item",
		"SELECTED",
		"item",
		"HOT",
		"item",
		"HOT",
		"item",
		"item",
		"item",
		"item",
		"item",
		"NORMAL",
		"item",
		"NORMAL",
		"item",
		"item",
		"item",
		"item",
		"i",
		"selectedIndex",
		"item",
		"NONE",
		"close",
		"item",
		"NONE",
		"item",
		"item",
		"item",
		"item",
		"i",
		"selectedIndex",
		"item",
		"NORMAL",
		"close",
		"item",
		"NORMAL",
		"item",
		"item",
		"item",
		"item",
		"SWT",
		"event",
		"chevronRect",
		"x",
		"y",
		"chevronImageState",
		"SELECTED",
		"selected",
		"e",
		"e",
		"event",
		"e",
		"chevronRect",
		"e",
		"chevronRect",
		"e",
		"chevronRect",
		"e",
		"chevronRect",
		"e",
		"i",
		"folderListeners",
		"i",
		"folderListeners",
		"i",
		"e",
		"e",
		"chevronRect",
		"minRect",
		"x",
		"y",
		"minImageState",
		"SELECTED",
		"minImageState",
		"HOT",
		"minRect",
		"minRect",
		"minRect",
		"minRect",
		"selected",
		"e",
		"e",
		"event",
		"i",
		"folderListeners",
		"i",
		"minimized",
		"folderListeners",
		"i",
		"e",
		"folderListeners",
		"i",
		"e",
		"maxRect",
		"x",
		"y",
		"maxImageState",
		"SELECTED",
		"maxImageState",
		"HOT",
		"maxRect",
		"maxRect",
		"maxRect",
		"maxRect",
		"selected",
		"e",
		"e",
		"event",
		"i",
		"folderListeners",
		"i",
		"maximized",
		"folderListeners",
		"i",
		"e",
		"folderListeners",
		"i",
		"e",
		"single",
		"selectedIndex",
		"items",
		"selectedIndex",
		"bounds",
		"x",
		"y",
		"item",
		"items",
		"selectedIndex",
		"i",
		"items",
		"i",
		"items",
		"i",
		"bounds",
		"x",
		"y",
		"item",
		"items",
		"i",
		"item",
		"item",
		"x",
		"y",
		"item",
		"SELECTED",
		"item",
		"HOT",
		"item",
		"item",
		"item",
		"item",
		"selected",
		"e",
		"e",
		"event",
		"e",
		"item",
		"e",
		"j",
		"folderListeners",
		"j",
		"folderListeners",
		"j",
		"listener",
		"e",
		"j",
		"tabListeners",
		"j",
		"tabListeners",
		"j",
		"listener",
		"e",
		"e",
		"item",
		"display",
		"pt",
		"display",
		"pt",
		"pt",
		"pt",
		"nextItem",
		"nextItem",
		"pt",
		"nextItem",
		"SELECTED",
		"nextItem",
		"HOT",
		"nextItem",
		"HOT",
		"nextItem",
		"nextItem",
		"nextItem",
		"nextItem",
		"nextItem",
		"NORMAL",
		"nextItem",
		"NORMAL",
		"nextItem",
		"nextItem",
		"nextItem",
		"nextItem",
		"items",
		"count",
		"selectedIndex",
		"index",
		"index",
		"event",
		"SWT",
		"mru",
		"index",
		"selectedIndex",
		"offset",
		"count",
		"count",
		"items",
		"i",
		"items",
		"i",
		"items",
		"i",
		"i",
		"selectedIndex",
		"current",
		"idx",
		"visible",
		"idx",
		"i",
		"current",
		"offset",
		"current",
		"offset",
		"idx",
		"index",
		"visible",
		"current",
		"offset",
		"showChevron",
		"e",
		"e",
		"event",
		"e",
		"chevronRect",
		"e",
		"chevronRect",
		"e",
		"chevronRect",
		"e",
		"chevronRect",
		"e",
		"i",
		"folderListeners",
		"i",
		"folderListeners",
		"i",
		"e",
		"e",
		"chevronRect",
		"index",
		"oldFont",
		"oldFont",
		"font",
		"oldFont",
		"font",
		"event",
		"gc",
		"gc",
		"gc",
		"event",
		"gc",
		"gcFont",
		"gc",
		"gcForeground",
		"gc",
		"gcBackground",
		"event",
		"gc",
		"gcFont",
		"gc",
		"gcForeground",
		"gc",
		"gcBackground",
		"oldSize",
		"onBottom",
		"size",
		"oldSize",
		"Math",
		"size",
		"oldSize",
		"size",
		"oldSize",
		"x1",
		"borderRight",
		"highlight_margin",
		"simple",
		"x1",
		"Math",
		"size",
		"oldSize",
		"size",
		"oldSize",
		"y1",
		"borderBottom",
		"highlight_margin",
		"Math",
		"size",
		"oldSize",
		"Math",
		"size",
		"oldSize",
		"y1",
		"x2",
		"y2",
		"y1",
		"x1",
		"x2",
		"x1",
		"y2",
		"oldSize",
		"size",
		"event",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"event",
		"SWT",
		"event",
		"event",
		"event",
		"event",
		"SWT",
		"SWT",
		"SWT",
		"event",
		"event",
		"event",
		"SWT",
		"onBottom",
		"size",
		"borderBottom",
		"tabHeight",
		"highlight_header",
		"size",
		"borderBottom",
		"tabHeight",
		"highlight_header",
		"size",
		"borderTop",
		"tabHeight",
		"highlight_header",
		"listener",
		"SWT",
		"SWT",
		"folderListeners",
		"i",
		"folderListeners",
		"i",
		"listener",
		"folderListeners",
		"i",
		"index",
		"i",
		"index",
		"folderListeners",
		"folderListeners",
		"folderListeners",
		"System",
		"folderListeners",
		"newTabListeners",
		"index",
		"System",
		"folderListeners",
		"index",
		"newTabListeners",
		"index",
		"folderListeners",
		"index",
		"folderListeners",
		"newTabListeners",
		"listener",
		"SWT",
		"SWT",
		"tabListeners",
		"i",
		"tabListeners",
		"i",
		"listener",
		"tabListeners",
		"i",
		"index",
		"i",
		"index",
		"tabListeners",
		"tabListeners",
		"tabListeners",
		"System",
		"tabListeners",
		"newTabListeners",
		"index",
		"System",
		"tabListeners",
		"index",
		"newTabListeners",
		"index",
		"tabListeners",
		"index",
		"tabListeners",
		"newTabListeners",
		"listener",
		"SWT",
		"SWT",
		"SWT",
		"listener",
		"SWT",
		"listener",
		"color",
		"colors",
		"percents",
		"colors",
		"percents",
		"percents",
		"colors",
		"SWT",
		"SWT",
		"i",
		"percents",
		"i",
		"percents",
		"i",
		"percents",
		"i",
		"SWT",
		"SWT",
		"i",
		"percents",
		"i",
		"percents",
		"i",
		"SWT",
		"SWT",
		"colors",
		"colors",
		"colors",
		"percents",
		"bgImage",
		"gradientColors",
		"colors",
		"gradientColors",
		"colors",
		"i",
		"gradientColors",
		"i",
		"gradientColors",
		"i",
		"same",
		"colors",
		"i",
		"same",
		"gradientColors",
		"i",
		"colors",
		"i",
		"same",
		"same",
		"i",
		"gradientPercents",
		"i",
		"same",
		"gradientPercents",
		"i",
		"percents",
		"i",
		"same",
		"same",
		"vertical",
		"bgImage",
		"colors",
		"gradientColors",
		"gradientPercents",
		"gradientVertical",
		"gradientColors",
		"colors",
		"i",
		"colors",
		"i",
		"gradientColors",
		"i",
		"colors",
		"i",
		"gradientPercents",
		"percents",
		"i",
		"percents",
		"i",
		"gradientPercents",
		"i",
		"percents",
		"i",
		"gradientVertical",
		"vertical",
		"gradientColors",
		"gradientColors",
		"image",
		"bgImage",
		"image",
		"gradientColors",
		"gradientPercents",
		"bgImage",
		"image",
		"borderLeft",
		"show",
		"borderLeft",
		"borderRight",
		"show",
		"borderTop",
		"onBottom",
		"borderLeft",
		"borderBottom",
		"onBottom",
		"borderLeft",
		"rectBefore",
		"rectAfter",
		"SWT",
		"oldX",
		"maxRect",
		"oldY",
		"maxRect",
		"oldWidth",
		"maxRect",
		"oldHeight",
		"maxRect",
		"maxRect",
		"maxRect",
		"maxRect",
		"maxRect",
		"showMax",
		"maxRect",
		"size",
		"borderRight",
		"BUTTON_SIZE",
		"borderRight",
		"maxRect",
		"maxRect",
		"onBottom",
		"size",
		"borderBottom",
		"tabHeight",
		"tabHeight",
		"BUTTON_SIZE",
		"borderTop",
		"tabHeight",
		"BUTTON_SIZE",
		"maxRect",
		"BUTTON_SIZE",
		"maxRect",
		"BUTTON_SIZE",
		"oldX",
		"maxRect",
		"oldWidth",
		"maxRect",
		"oldY",
		"maxRect",
		"oldHeight",
		"maxRect",
		"Math",
		"oldX",
		"maxRect",
		"Math",
		"oldX",
		"oldWidth",
		"maxRect",
		"maxRect",
		"onBottom",
		"size",
		"borderBottom",
		"tabHeight",
		"borderTop",
		"left",
		"top",
		"right",
		"left",
		"tabHeight",
		"oldX",
		"minRect",
		"oldY",
		"minRect",
		"oldWidth",
		"minRect",
		"oldHeight",
		"minRect",
		"minRect",
		"minRect",
		"minRect",
		"minRect",
		"showMin",
		"minRect",
		"size",
		"borderRight",
		"maxRect",
		"BUTTON_SIZE",
		"borderRight",
		"minRect",
		"minRect",
		"onBottom",
		"size",
		"borderBottom",
		"tabHeight",
		"tabHeight",
		"BUTTON_SIZE",
		"borderTop",
		"tabHeight",
		"BUTTON_SIZE",
		"minRect",
		"BUTTON_SIZE",
		"minRect",
		"BUTTON_SIZE",
		"oldX",
		"minRect",
		"oldWidth",
		"minRect",
		"oldY",
		"minRect",
		"oldHeight",
		"minRect",
		"Math",
		"oldX",
		"minRect",
		"Math",
		"oldX",
		"oldWidth",
		"minRect",
		"minRect",
		"onBottom",
		"size",
		"borderBottom",
		"tabHeight",
		"borderTop",
		"left",
		"top",
		"right",
		"left",
		"tabHeight",
		"oldX",
		"topRightRect",
		"oldY",
		"topRightRect",
		"oldWidth",
		"topRightRect",
		"oldHeight",
		"topRightRect",
		"topRightRect",
		"topRightRect",
		"topRightRect",
		"topRightRect",
		"topRight",
		"topRightAlignment",
		"SWT",
		"size",
		"borderRight",
		"maxRect",
		"minRect",
		"simple",
		"borderRight",
		"showMax",
		"showMin",
		"rightEdge",
		"single",
		"items",
		"selectedIndex",
		"topRightRect",
		"borderLeft",
		"topRightRect",
		"rightEdge",
		"topRightRect",
		"items",
		"selectedIndex",
		"item",
		"item",
		"BUTTON_SIZE",
		"rightEdge",
		"topRightRect",
		"item",
		"item",
		"BUTTON_SIZE",
		"topRightRect",
		"rightEdge",
		"topRightRect",
		"showChevron",
		"items",
		"topRightRect",
		"borderLeft",
		"items",
		"items",
		"topRightRect",
		"item",
		"item",
		"simple",
		"items",
		"selectedIndex",
		"topRightRect",
		"curveWidth",
		"curveIndent",
		"topRightRect",
		"Math",
		"rightEdge",
		"topRightRect",
		"topRightRect",
		"onBottom",
		"size",
		"borderBottom",
		"tabHeight",
		"borderTop",
		"topRightRect",
		"tabHeight",
		"SWT",
		"topRight",
		"SWT",
		"tabHeight",
		"size",
		"borderRight",
		"maxRect",
		"minRect",
		"simple",
		"borderRight",
		"showMax",
		"showMin",
		"rightEdge",
		"topRightRect",
		"rightEdge",
		"topRightSize",
		"topRightRect",
		"topRightSize",
		"topRightRect",
		"onBottom",
		"size",
		"borderBottom",
		"tabHeight",
		"borderTop",
		"topRightRect",
		"tabHeight",
		"topRight",
		"topRightRect",
		"oldX",
		"topRightRect",
		"oldWidth",
		"topRightRect",
		"oldY",
		"topRightRect",
		"oldHeight",
		"topRightRect",
		"Math",
		"oldX",
		"topRightRect",
		"Math",
		"oldX",
		"oldWidth",
		"topRightRect",
		"topRightRect",
		"onBottom",
		"size",
		"borderBottom",
		"tabHeight",
		"borderTop",
		"left",
		"top",
		"right",
		"left",
		"tabHeight",
		"oldX",
		"chevronRect",
		"oldY",
		"chevronRect",
		"oldWidth",
		"chevronRect",
		"oldHeight",
		"chevronRect",
		"chevronRect",
		"chevronRect",
		"chevronRect",
		"chevronRect",
		"single",
		"selectedIndex",
		"items",
		"chevronRect",
		"BUTTON_SIZE",
		"chevronRect",
		"BUTTON_SIZE",
		"chevronRect",
		"onBottom",
		"size",
		"borderBottom",
		"tabHeight",
		"tabHeight",
		"chevronRect",
		"borderTop",
		"tabHeight",
		"chevronRect",
		"selectedIndex",
		"chevronRect",
		"size",
		"borderRight",
		"minRect",
		"maxRect",
		"topRightRect",
		"chevronRect",
		"items",
		"selectedIndex",
		"size",
		"borderRight",
		"minRect",
		"maxRect",
		"chevronRect",
		"topRightRect",
		"w",
		"topRightRect",
		"chevronRect",
		"Math",
		"item",
		"item",
		"w",
		"borderRight",
		"chevronRect",
		"showChevron",
		"chevronRect",
		"BUTTON_SIZE",
		"chevronRect",
		"BUTTON_SIZE",
		"i",
		"priority",
		"items",
		"priority",
		"i",
		"lastIndex",
		"Math",
		"lastIndex",
		"priority",
		"i",
		"lastIndex",
		"lastIndex",
		"firstIndex",
		"items",
		"lastIndex",
		"lastItem",
		"lastItem",
		"simple",
		"lastIndex",
		"selectedIndex",
		"w",
		"curveWidth",
		"curveIndent",
		"chevronRect",
		"Math",
		"w",
		"chevronRect",
		"onBottom",
		"size",
		"borderBottom",
		"tabHeight",
		"tabHeight",
		"chevronRect",
		"borderTop",
		"tabHeight",
		"chevronRect",
		"oldX",
		"chevronRect",
		"oldWidth",
		"chevronRect",
		"oldY",
		"chevronRect",
		"oldHeight",
		"chevronRect",
		"Math",
		"oldX",
		"chevronRect",
		"Math",
		"oldX",
		"oldWidth",
		"chevronRect",
		"chevronRect",
		"onBottom",
		"size",
		"borderBottom",
		"tabHeight",
		"borderTop",
		"left",
		"top",
		"right",
		"left",
		"tabHeight",
		"font",
		"font",
		"font",
		"oldFont",
		"color",
		"index",
		"index",
		"SWT",
		"SWT",
		"items",
		"onBottom",
		"Math",
		"borderBottom",
		"size",
		"borderBottom",
		"tabHeight",
		"borderTop",
		"single",
		"i",
		"items",
		"i",
		"items",
		"i",
		"i",
		"selectedIndex",
		"firstIndex",
		"selectedIndex",
		"item",
		"item",
		"item",
		"borderLeft",
		"item",
		"y",
		"item",
		"showClose",
		"item",
		"item",
		"borderLeft",
		"CTabItem",
		"item",
		"onBottom",
		"size",
		"borderBottom",
		"tabHeight",
		"tabHeight",
		"BUTTON_SIZE",
		"borderTop",
		"tabHeight",
		"BUTTON_SIZE",
		"item",
		"oldX",
		"item",
		"oldY",
		"changed",
		"item",
		"defaultX",
		"item",
		"rightItemEdge",
		"borderLeft",
		"i",
		"priority",
		"i",
		"items",
		"priority",
		"i",
		"width",
		"item",
		"item",
		"i",
		"item",
		"width",
		"maxWidth",
		"simple",
		"priority",
		"i",
		"selectedIndex",
		"width",
		"curveWidth",
		"curveIndent",
		"firstIndex",
		"items",
		"i",
		"items",
		"i",
		"items",
		"i",
		"item",
		"item",
		"defaultX",
		"changed",
		"item",
		"defaultX",
		"firstIndex",
		"Math",
		"firstIndex",
		"i",
		"item",
		"x",
		"item",
		"y",
		"changed",
		"item",
		"x",
		"item",
		"y",
		"i",
		"selectedIndex",
		"Math",
		"item",
		"item",
		"rightItemEdge",
		"item",
		"edge",
		"CTabItem",
		"BUTTON_SIZE",
		"item",
		"item",
		"item",
		"CTabItem",
		"BUTTON_SIZE",
		"item",
		"onBottom",
		"size",
		"borderBottom",
		"tabHeight",
		"tabHeight",
		"BUTTON_SIZE",
		"borderTop",
		"tabHeight",
		"BUTTON_SIZE",
		"x",
		"x",
		"item",
		"simple",
		"i",
		"selectedIndex",
		"x",
		"curveWidth",
		"curveIndent",
		"changed",
		"changed",
		"size",
		"size",
		"changed",
		"xClient",
		"borderLeft",
		"marginWidth",
		"highlight_margin",
		"onBottom",
		"yClient",
		"borderTop",
		"highlight_margin",
		"marginHeight",
		"yClient",
		"borderTop",
		"tabHeight",
		"highlight_header",
		"marginHeight",
		"showChevron",
		"single",
		"showChevron",
		"selectedIndex",
		"items",
		"selectedIndex",
		"tab",
		"gc",
		"gc",
		"width",
		"Math",
		"width",
		"borderLeft",
		"tab",
		"tabHeight",
		"tab",
		"width",
		"changed",
		"tab",
		"tab",
		"tab",
		"tabHeight",
		"tab",
		"width",
		"tab",
		"tab",
		"showClose",
		"tab",
		"tab",
		"BUTTON_SIZE",
		"tab",
		"BUTTON_SIZE",
		"changed",
		"items",
		"changed",
		"size",
		"borderLeft",
		"borderRight",
		"showMin",
		"tabAreaWidth",
		"BUTTON_SIZE",
		"showMax",
		"tabAreaWidth",
		"BUTTON_SIZE",
		"topRightAlignment",
		"SWT",
		"topRight",
		"topRight",
		"SWT",
		"SWT",
		"tabAreaWidth",
		"rightSize",
		"simple",
		"tabAreaWidth",
		"curveWidth",
		"curveIndent",
		"tabAreaWidth",
		"Math",
		"tabAreaWidth",
		"items",
		"i",
		"priority",
		"i",
		"priority",
		"i",
		"minWidths",
		"index",
		"items",
		"index",
		"gc",
		"index",
		"selectedIndex",
		"minWidth",
		"minWidths",
		"index",
		"minWidth",
		"tabAreaWidth",
		"minWidth",
		"tabAreaWidth",
		"showChevron",
		"items",
		"showChevron",
		"tabAreaWidth",
		"BUTTON_SIZE",
		"widths",
		"minWidths",
		"selectedIndex",
		"selectedIndex",
		"tabAreaWidth",
		"widths",
		"index",
		"widths",
		"index",
		"Math",
		"tabAreaWidth",
		"items",
		"i",
		"items",
		"i",
		"maxWidths",
		"i",
		"items",
		"i",
		"gc",
		"i",
		"selectedIndex",
		"maxWidth",
		"maxWidths",
		"i",
		"maxWidth",
		"tabAreaWidth",
		"widths",
		"maxWidths",
		"tabAreaWidth",
		"minWidth",
		"items",
		"i",
		"items",
		"i",
		"maxWidths",
		"i",
		"minWidths",
		"i",
		"extra",
		"totalWidth",
		"minWidths",
		"i",
		"extra",
		"large",
		"totalWidth",
		"maxWidths",
		"i",
		"totalWidth",
		"tabAreaWidth",
		"extra",
		"large",
		"tabAreaWidth",
		"totalWidth",
		"large",
		"extra",
		"widths",
		"items",
		"i",
		"items",
		"i",
		"widths",
		"i",
		"Math",
		"maxWidths",
		"i",
		"minWidths",
		"i",
		"extra",
		"gc",
		"i",
		"items",
		"i",
		"items",
		"i",
		"widths",
		"i",
		"tab",
		"tabHeight",
		"tab",
		"width",
		"changed",
		"tab",
		"tab",
		"tab",
		"tabHeight",
		"tab",
		"width",
		"tab",
		"tab",
		"showClose",
		"tab",
		"i",
		"selectedIndex",
		"showUnselectedClose",
		"tab",
		"BUTTON_SIZE",
		"tab",
		"BUTTON_SIZE",
		"changed",
		"showMax",
		"visible",
		"showMax",
		"visible",
		"maximize",
		"maximize",
		"maximize",
		"maxRect",
		"maxRect",
		"maxRect",
		"maxRect",
		"showMin",
		"visible",
		"showMin",
		"visible",
		"minimize",
		"minimize",
		"minimize",
		"minRect",
		"minRect",
		"minRect",
		"minRect",
		"count",
		"SWT",
		"SWT",
		"minChars",
		"count",
		"minChars",
		"count",
		"mru",
		"show",
		"mru",
		"show",
		"mru",
		"firstIndex",
		"firstIndex",
		"i",
		"items",
		"i",
		"priority",
		"next",
		"i",
		"i",
		"idx",
		"i",
		"priority",
		"next",
		"i",
		"item",
		"SWT",
		"SWT",
		"item",
		"index",
		"index",
		"index",
		"items",
		"items",
		"index",
		"selectedIndex",
		"index",
		"selection",
		"selectedIndex",
		"selectedIndex",
		"index",
		"oldIndex",
		"items",
		"oldIndex",
		"NONE",
		"selection",
		"NORMAL",
		"selection",
		"selection",
		"control",
		"control",
		"control",
		"control",
		"oldIndex",
		"control",
		"items",
		"oldIndex",
		"control",
		"control",
		"control",
		"selection",
		"selectedIndex",
		"index",
		"notify",
		"selectedIndex",
		"oldSelectedIndex",
		"selectedIndex",
		"event",
		"selectedIndex",
		"SWT",
		"event",
		"selectionBackground",
		"color",
		"color",
		"color",
		"SELECTION_BACKGROUND",
		"selectionBackground",
		"color",
		"selectedIndex",
		"colors",
		"percents",
		"colors",
		"percents",
		"percents",
		"colors",
		"SWT",
		"SWT",
		"i",
		"percents",
		"i",
		"percents",
		"i",
		"percents",
		"i",
		"SWT",
		"SWT",
		"i",
		"percents",
		"i",
		"percents",
		"i",
		"SWT",
		"SWT",
		"colors",
		"colors",
		"colors",
		"percents",
		"selectionBgImage",
		"selectionGradientColors",
		"colors",
		"selectionGradientColors",
		"colors",
		"i",
		"selectionGradientColors",
		"i",
		"selectionGradientColors",
		"i",
		"same",
		"colors",
		"i",
		"same",
		"selectionGradientColors",
		"i",
		"colors",
		"i",
		"same",
		"same",
		"i",
		"selectionGradientPercents",
		"i",
		"same",
		"selectionGradientPercents",
		"i",
		"percents",
		"i",
		"same",
		"same",
		"vertical",
		"selectionBgImage",
		"colors",
		"selectionGradientColors",
		"selectionGradientPercents",
		"selectionGradientVertical",
		"selectionGradientColors",
		"colors",
		"i",
		"colors",
		"i",
		"selectionGradientColors",
		"i",
		"colors",
		"i",
		"selectionGradientPercents",
		"percents",
		"i",
		"percents",
		"i",
		"selectionGradientPercents",
		"i",
		"percents",
		"i",
		"selectionGradientVertical",
		"vertical",
		"selectionGradientColors",
		"selectionGradientColors",
		"selectedIndex",
		"image",
		"selectionBgImage",
		"image",
		"selectionGradientColors",
		"selectionGradientPercents",
		"selectionBgImage",
		"image",
		"selectedIndex",
		"selectionForeground",
		"color",
		"color",
		"color",
		"SELECTION_FOREGROUND",
		"selectionForeground",
		"color",
		"selectedIndex",
		"simple",
		"simple",
		"rectBefore",
		"rectAfter",
		"SWT",
		"single",
		"single",
		"single",
		"i",
		"items",
		"i",
		"i",
		"selectedIndex",
		"items",
		"i",
		"NORMAL",
		"items",
		"i",
		"NONE",
		"rectBefore",
		"rectAfter",
		"SWT",
		"height",
		"SWT",
		"SWT",
		"fixedTabHeight",
		"height",
		"position",
		"SWT",
		"position",
		"SWT",
		"SWT",
		"SWT",
		"onBottom",
		"position",
		"SWT",
		"onBottom",
		"position",
		"SWT",
		"borderTop",
		"onBottom",
		"borderLeft",
		"borderBottom",
		"onBottom",
		"borderRight",
		"rectBefore",
		"rectAfter",
		"SWT",
		"control",
		"SWT",
		"alignment",
		"SWT",
		"alignment",
		"SWT",
		"SWT",
		"SWT",
		"control",
		"control",
		"SWT",
		"SWT",
		"topRight",
		"control",
		"topRightAlignment",
		"alignment",
		"showUnselectedClose",
		"visible",
		"showUnselectedClose",
		"visible",
		"showUnselectedImage",
		"visible",
		"showUnselectedImage",
		"visible",
		"item",
		"SWT",
		"SWT",
		"item",
		"SWT",
		"SWT",
		"item",
		"index",
		"SWT",
		"SWT",
		"i",
		"priority",
		"i",
		"priority",
		"i",
		"index",
		"idx",
		"i",
		"mru",
		"priority",
		"System",
		"priority",
		"newPriority",
		"idx",
		"System",
		"priority",
		"idx",
		"newPriority",
		"idx",
		"priority",
		"idx",
		"newPriority",
		"index",
		"priority",
		"newPriority",
		"item",
		"index",
		"items",
		"showChevron",
		"showMenu",
		"showMenu",
		"showMenu",
		"showMenu",
		"i",
		"items",
		"i",
		"items",
		"i",
		"i",
		"items",
		"i",
		"items",
		"i",
		"tab",
		"showMenu",
		"SWT",
		"item",
		"tab",
		"item",
		"tab",
		"item",
		"id",
		"tab",
		"item",
		"e",
		"menuItem",
		"id",
		"CTabFolder",
		"index",
		"rect",
		"rect",
		"rect",
		"x",
		"y",
		"showMenu",
		"location",
		"location",
		"showMenu",
		"selectedIndex",
		"toolTipShell",
		"i",
		"toolTipEvents",
		"i",
		"toolTipEvents",
		"i",
		"toolTipListener",
		"toolTipShell",
		"toolTipShell",
		"toolTipLabel",
		"toolTipShell",
		"toolTipShell",
		"SWT",
		"SWT",
		"toolTipLabel",
		"toolTipShell",
		"SWT",
		"toolTipShell",
		"toolTipLabel",
		"display",
		"SWT",
		"toolTipLabel",
		"display",
		"SWT",
		"i",
		"toolTipEvents",
		"i",
		"toolTipEvents",
		"i",
		"toolTipListener",
		"x",
		"y",
		"toolTipShell",
		"selectedIndex",
		"single",
		"mru",
		"showIndex",
		"showIndex",
		"priority",
		"showIndex",
		"borderLeft",
		"simple",
		"maxWidth",
		"curveWidth",
		"curveIndent",
		"items",
		"priority",
		"i",
		"showIndex",
		"i",
		"widths",
		"i",
		"items",
		"i",
		"gc",
		"i",
		"selectedIndex",
		"width",
		"widths",
		"i",
		"width",
		"maxWidth",
		"width",
		"maxWidth",
		"width",
		"showIndex",
		"i",
		"i",
		"widths",
		"i",
		"widths",
		"i",
		"items",
		"i",
		"gc",
		"i",
		"selectedIndex",
		"width",
		"widths",
		"i",
		"width",
		"maxWidth",
		"firstIndex",
		"i",
		"firstIndex",
		"priority",
		"showIndex",
		"i",
		"items",
		"i",
		"widths",
		"i",
		"items",
		"i",
		"gc",
		"i",
		"selectedIndex",
		"width",
		"widths",
		"i",
		"width",
		"maxWidth",
		"width",
		"maxWidth",
		"priority",
		"i",
		"i",
		"widths",
		"i",
		"widths",
		"i",
		"items",
		"i",
		"gc",
		"i",
		"selectedIndex",
		"width",
		"widths",
		"i",
		"width",
		"maxWidth",
		"firstIndex",
		"i",
		"gc",
		"firstIndex",
		"priority",
		"firstIndex",
		"i",
		"items",
		"i",
		"priority",
		"index",
		"i",
		"i",
		"firstIndex",
		"i",
		"priority",
		"index",
		"i",
		"showChevron",
		"changed",
		"changed",
		"showChevron",
		"oldShowChevron",
		"changed",
		"toolTipShell",
		"pt",
		"pt",
		"pt",
		"pt",
		"changed",
		"tabHeight",
		"fixedTabHeight",
		"SWT",
		"tabHeight",
		"fixedTabHeight",
		"fixedTabHeight",
		"items",
		"tempHeight",
		"gc",
		"CTabItem",
		"CTabItem",
		"CTabItem",
		"i",
		"items",
		"i",
		"tempHeight",
		"Math",
		"tempHeight",
		"items",
		"i",
		"gc",
		"gc",
		"tabHeight",
		"tempHeight",
		"force",
		"tabHeight",
		"oldHeight",
		"oldSize",
		"onBottom",
		"tabHeight",
		"curve",
		"d",
		"d",
		"d",
		"d",
		"d",
		"d",
		"d",
		"d",
		"d",
		"d",
		"d",
		"d",
		"d",
		"d",
		"d",
		"d",
		"d",
		"d",
		"d",
		"d",
		"curveWidth",
		"d",
		"curveIndent",
		"curveWidth",
		"tabHeight",
		"curve",
		"d",
		"d",
		"d",
		"d",
		"d",
		"d",
		"d",
		"d",
		"d",
		"d",
		"d",
		"d",
		"d",
		"d",
		"d",
		"d",
		"d",
		"d",
		"d",
		"d",
		"curveWidth",
		"d",
		"curveIndent",
		"curveWidth",
		"SWT",
		"showMin",
		"minRect",
		"x",
		"y",
		"minimized",
		"SWT",
		"SWT",
		"showMax",
		"maxRect",
		"x",
		"y",
		"maximized",
		"SWT",
		"SWT",
		"showChevron",
		"chevronRect",
		"x",
		"y",
		"SWT",
		"x",
		"y",
		"item",
		"item",
		"showClose",
		"item",
		"item",
		"x",
		"y",
		"SWT",
		"item",
		"x",
		"y",
		"tooltip",
		"tooltip",
		"toolTipLabel",
		"toolTipLabel",
		"tooltip",
		"toolTipLabel",
		"SWT",
		"SWT",
		"labelSize",
		"labelSize",
		"toolTipLabel",
		"labelSize",
		"toolTipShell",
		"toolTipShell",
		"toolTipLabel",
		"area",
		"area",
		"toolTipShell",
		"cursorLocation",
		"cursorLocation",
		"cursorHeight",
		"pt",
		"Math",
		"pt",
		"rect",
		"pt",
		"size",
		"rect",
		"rect",
		"pt",
		"rect",
		"rect",
		"size",
		"pt",
		"size",
		"rect",
		"rect",
		"pt",
		"cursorLocation",
		"size",
		"toolTipShell",
		"pt",
		"DEFAULT",
		"RIGHT",
		"MouseExit",
		"MouseHover",
		"MouseMove",
		"MouseDown",
		"DragDetect",
		"COLOR_LIST_FOREGROUND",
		"COLOR_LIST_BACKGROUND",
		"COLOR_WIDGET_NORMAL_SHADOW",
		"COLOR_WIDGET_FOREGROUND",
		"COLOR_WIDGET_BACKGROUND",
		"COLOR_WIDGET_DARK_SHADOW",
		"COLOR_LIST_BACKGROUND",
		"BOTTOM",
		"CLOSE",
		"SINGLE",
		"BORDER",
		"FLAT",
		"FLAT",
		"type",
		"Dispose",
		"DragDetect",
		"FocusIn",
		"FocusOut",
		"KeyDown",
		"MouseDoubleClick",
		"MouseDown",
		"MouseExit",
		"MouseHover",
		"MouseMove",
		"MouseUp",
		"Paint",
		"Resize",
		"Traverse",
		"Dispose",
		"DragDetect",
		"FocusIn",
		"FocusOut",
		"KeyDown",
		"MouseDoubleClick",
		"MouseDown",
		"MouseExit",
		"MouseHover",
		"MouseMove",
		"MouseUp",
		"Paint",
		"Resize",
		"Traverse",
		"length",
		"type",
		"MouseHover",
		"MouseMove",
		"x",
		"y",
		"MouseExit",
		"MouseDown",
		"CLOSE",
		"TOP",
		"BOTTOM",
		"FLAT",
		"LEFT_TO_RIGHT",
		"RIGHT_TO_LEFT",
		"SINGLE",
		"MULTI",
		"TOP",
		"BOTTOM",
		"MULTI",
		"SINGLE",
		"NO_REDRAW_RESIZE",
		"RIGHT_TO_LEFT",
		"MIRRORED",
		"LEFT_TO_RIGHT",
		"NO_BACKGROUND",
		"ERROR_NULL_ARGUMENT",
		"length",
		"length",
		"length",
		"ERROR_NULL_ARGUMENT",
		"length",
		"length",
		"length",
		"ERROR_NULL_ARGUMENT",
		"Selection",
		"DefaultSelection",
		"y",
		"length",
		"length",
		"length",
		"red",
		"red",
		"red",
		"green",
		"green",
		"green",
		"blue",
		"blue",
		"blue",
		"length",
		"y",
		"length",
		"length",
		"red",
		"red",
		"red",
		"green",
		"green",
		"green",
		"blue",
		"blue",
		"blue",
		"ERROR_INVALID_RANGE",
		"parent",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"x",
		"y",
		"x",
		"y",
		"width",
		"height",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"y",
		"length",
		"NO_BACKGROUND",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"x",
		"y",
		"length",
		"length",
		"NO_BACKGROUND",
		"NO_BACKGROUND",
		"y",
		"x",
		"y",
		"x",
		"y",
		"y",
		"width",
		"height",
		"y",
		"y",
		"height",
		"x",
		"y",
		"length",
		"length",
		"length",
		"showing",
		"length",
		"x",
		"y",
		"width",
		"height",
		"x",
		"y",
		"width",
		"height",
		"x",
		"y",
		"width",
		"height",
		"x",
		"y",
		"width",
		"height",
		"width",
		"height",
		"x",
		"BUTTON_SIZE",
		"y",
		"x",
		"y",
		"width",
		"height",
		"x",
		"y",
		"width",
		"height",
		"x",
		"y",
		"width",
		"height",
		"x",
		"y",
		"width",
		"height",
		"width",
		"height",
		"x",
		"y",
		"x",
		"y",
		"width",
		"height",
		"x",
		"y",
		"width",
		"height",
		"x",
		"y",
		"width",
		"height",
		"x",
		"y",
		"width",
		"height",
		"gc",
		"x",
		"y",
		"y",
		"length",
		"length",
		"y",
		"x",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"y",
		"x",
		"x",
		"y",
		"length",
		"ERROR_INVALID_RANGE",
		"length",
		"x",
		"length",
		"length",
		"length",
		"length",
		"x",
		"FILL",
		"DEFAULT",
		"DEFAULT",
		"x",
		"TOP",
		"BOTTOM",
		"BOTTOM",
		"TOP",
		"SINGLE",
		"MULTI",
		"SINGLE",
		"MULTI",
		"BORDER",
		"DEFAULT",
		"BOTTOM",
		"TOP",
		"ERROR_NULL_ARGUMENT",
		"length",
		"childID",
		"length",
		"result",
		"childID",
		"CHILDID_SELF",
		"length",
		"result",
		"childID",
		"length",
		"result",
		"x",
		"y",
		"CHILDID_NONE",
		"length",
		"CHILDID_NONE",
		"height",
		"height",
		"height",
		"CHILDID_SELF",
		"childID",
		"childID",
		"CHILDID_SELF",
		"length",
		"x",
		"y",
		"x",
		"x",
		"y",
		"y",
		"width",
		"width",
		"height",
		"height",
		"detail",
		"length",
		"childID",
		"length",
		"result",
		"CHILDID_NONE",
		"CHILDID_SELF",
		"childID",
		"childID",
		"CHILDID_SELF",
		"ROLE_TABFOLDER",
		"length",
		"ROLE_TABITEM",
		"detail",
		"childID",
		"CHILDID_NONE",
		"childID",
		"CHILDID_SELF",
		"STATE_NORMAL",
		"length",
		"STATE_SELECTABLE",
		"STATE_FOCUSABLE",
		"STATE_SELECTED",
		"STATE_FOCUSED",
		"detail",
		"length",
		"length",
		"children",
		"Selection",
		"CHILDID_SELF",
		"FocusIn",
		"CHILDID_SELF",
		"keyCode",
		"ARROW_LEFT",
		"ARROW_RIGHT",
		"length",
		"RIGHT_TO_LEFT",
		"ARROW_RIGHT",
		"ARROW_LEFT",
		"keyCode",
		"length",
		"length",
		"showing",
		"widget",
		"time",
		"time",
		"x",
		"x",
		"y",
		"y",
		"width",
		"width",
		"height",
		"height",
		"doit",
		"length",
		"doit",
		"length",
		"x",
		"y",
		"x",
		"y",
		"x",
		"y",
		"length",
		"closeRect",
		"x",
		"y",
		"type",
		"None",
		"character",
		"length",
		"button",
		"stateMask",
		"BUTTON2",
		"stateMask",
		"BUTTON3",
		"item",
		"x",
		"y",
		"item",
		"DefaultSelection",
		"x",
		"y",
		"x",
		"y",
		"type",
		"MouseExit",
		"x",
		"y",
		"width",
		"height",
		"x",
		"y",
		"width",
		"height",
		"x",
		"y",
		"width",
		"height",
		"length",
		"closeImageState",
		"closeImageState",
		"x",
		"closeRect",
		"y",
		"closeRect",
		"width",
		"closeRect",
		"height",
		"closeRect",
		"closeImageState",
		"closeImageState",
		"x",
		"closeRect",
		"y",
		"closeRect",
		"width",
		"closeRect",
		"height",
		"closeRect",
		"MouseDown",
		"button",
		"x",
		"y",
		"width",
		"height",
		"button",
		"x",
		"y",
		"width",
		"height",
		"button",
		"x",
		"y",
		"width",
		"height",
		"length",
		"closeRect",
		"button",
		"closeImageState",
		"x",
		"closeRect",
		"y",
		"closeRect",
		"width",
		"closeRect",
		"height",
		"closeRect",
		"showing",
		"MouseMove",
		"x",
		"y",
		"width",
		"height",
		"x",
		"y",
		"width",
		"height",
		"x",
		"y",
		"width",
		"height",
		"x",
		"y",
		"width",
		"height",
		"x",
		"y",
		"width",
		"height",
		"x",
		"y",
		"width",
		"height",
		"length",
		"closeRect",
		"closeImageState",
		"closeImageState",
		"closeImageState",
		"x",
		"closeRect",
		"y",
		"closeRect",
		"width",
		"closeRect",
		"height",
		"closeRect",
		"closeImageState",
		"closeImageState",
		"x",
		"closeRect",
		"y",
		"closeRect",
		"width",
		"closeRect",
		"height",
		"closeRect",
		"closeImageState",
		"closeImageState",
		"x",
		"closeRect",
		"y",
		"closeRect",
		"width",
		"closeRect",
		"height",
		"closeRect",
		"closeImageState",
		"closeImageState",
		"x",
		"closeRect",
		"y",
		"closeRect",
		"width",
		"closeRect",
		"height",
		"closeRect",
		"MouseUp",
		"button",
		"widget",
		"time",
		"time",
		"x",
		"x",
		"y",
		"y",
		"width",
		"width",
		"height",
		"height",
		"doit",
		"length",
		"doit",
		"x",
		"y",
		"width",
		"height",
		"widget",
		"time",
		"time",
		"length",
		"x",
		"y",
		"width",
		"height",
		"widget",
		"time",
		"time",
		"length",
		"length",
		"closeRect",
		"closeImageState",
		"closeImageState",
		"x",
		"closeRect",
		"y",
		"closeRect",
		"width",
		"closeRect",
		"height",
		"closeRect",
		"widget",
		"time",
		"time",
		"item",
		"doit",
		"length",
		"length",
		"doit",
		"x",
		"y",
		"closeRect",
		"closeImageState",
		"closeImageState",
		"closeImageState",
		"x",
		"closeRect",
		"y",
		"closeRect",
		"width",
		"closeRect",
		"height",
		"closeRect",
		"closeImageState",
		"closeImageState",
		"x",
		"closeRect",
		"y",
		"closeRect",
		"width",
		"closeRect",
		"height",
		"closeRect",
		"length",
		"detail",
		"TRAVERSE_PAGE_NEXT",
		"length",
		"length",
		"showing",
		"widget",
		"time",
		"time",
		"x",
		"x",
		"y",
		"y",
		"width",
		"width",
		"height",
		"height",
		"doit",
		"length",
		"doit",
		"gc",
		"y",
		"y",
		"x",
		"x",
		"x",
		"x",
		"y",
		"y",
		"y",
		"y",
		"x",
		"x",
		"y",
		"y",
		"detail",
		"TRAVERSE_ESCAPE",
		"TRAVERSE_RETURN",
		"TRAVERSE_TAB_NEXT",
		"TRAVERSE_TAB_PREVIOUS",
		"doit",
		"TRAVERSE_MNEMONIC",
		"doit",
		"doit",
		"detail",
		"TRAVERSE_NONE",
		"TRAVERSE_PAGE_NEXT",
		"TRAVERSE_PAGE_PREVIOUS",
		"doit",
		"detail",
		"TRAVERSE_NONE",
		"y",
		"x",
		"x",
		"ERROR_NULL_ARGUMENT",
		"length",
		"length",
		"length",
		"length",
		"length",
		"ERROR_NULL_ARGUMENT",
		"length",
		"length",
		"length",
		"length",
		"length",
		"ERROR_NULL_ARGUMENT",
		"Selection",
		"DefaultSelection",
		"length",
		"length",
		"ERROR_INVALID_ARGUMENT",
		"length",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"length",
		"length",
		"length",
		"length",
		"length",
		"gradientVertical",
		"length",
		"length",
		"length",
		"length",
		"length",
		"Resize",
		"x",
		"y",
		"width",
		"height",
		"x",
		"y",
		"width",
		"height",
		"x",
		"x",
		"x",
		"y",
		"y",
		"width",
		"height",
		"x",
		"width",
		"y",
		"height",
		"x",
		"x",
		"width",
		"y",
		"x",
		"y",
		"width",
		"height",
		"x",
		"y",
		"width",
		"height",
		"x",
		"x",
		"width",
		"x",
		"y",
		"y",
		"width",
		"height",
		"x",
		"width",
		"y",
		"height",
		"x",
		"x",
		"width",
		"y",
		"x",
		"y",
		"width",
		"height",
		"x",
		"y",
		"width",
		"height",
		"FILL",
		"x",
		"width",
		"width",
		"length",
		"x",
		"width",
		"x",
		"x",
		"width",
		"x",
		"x",
		"width",
		"width",
		"x",
		"length",
		"x",
		"length",
		"x",
		"x",
		"width",
		"length",
		"x",
		"width",
		"x",
		"y",
		"y",
		"height",
		"RIGHT",
		"DEFAULT",
		"x",
		"width",
		"width",
		"x",
		"x",
		"width",
		"x",
		"y",
		"y",
		"height",
		"x",
		"width",
		"y",
		"height",
		"x",
		"x",
		"width",
		"y",
		"x",
		"y",
		"width",
		"height",
		"x",
		"y",
		"height",
		"width",
		"length",
		"width",
		"height",
		"y",
		"y",
		"height",
		"height",
		"x",
		"x",
		"width",
		"width",
		"width",
		"width",
		"x",
		"width",
		"width",
		"width",
		"width",
		"width",
		"x",
		"x",
		"width",
		"x",
		"width",
		"height",
		"length",
		"showing",
		"x",
		"width",
		"x",
		"y",
		"y",
		"height",
		"height",
		"x",
		"width",
		"y",
		"height",
		"x",
		"x",
		"width",
		"y",
		"ERROR_INVALID_ARGUMENT",
		"length",
		"y",
		"width",
		"length",
		"x",
		"y",
		"x",
		"y",
		"showing",
		"showClose",
		"x",
		"closeRect",
		"LEFT_MARGIN",
		"y",
		"closeRect",
		"y",
		"x",
		"y",
		"x",
		"showing",
		"length",
		"width",
		"showing",
		"width",
		"width",
		"length",
		"length",
		"showing",
		"x",
		"x",
		"x",
		"y",
		"x",
		"y",
		"x",
		"width",
		"x",
		"closeRect",
		"RIGHT_MARGIN",
		"x",
		"closeRect",
		"x",
		"width",
		"RIGHT_MARGIN",
		"y",
		"closeRect",
		"y",
		"width",
		"x",
		"y",
		"height",
		"width",
		"shortenedText",
		"shortenedTextWidth",
		"height",
		"width",
		"width",
		"closeRect",
		"height",
		"closeRect",
		"showClose",
		"width",
		"closeRect",
		"height",
		"closeRect",
		"length",
		"x",
		"RIGHT",
		"DEFAULT",
		"DEFAULT",
		"x",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"height",
		"width",
		"shortenedText",
		"shortenedTextWidth",
		"height",
		"width",
		"width",
		"closeRect",
		"height",
		"closeRect",
		"showClose",
		"width",
		"closeRect",
		"height",
		"closeRect",
		"maximized",
		"minimized",
		"maximized",
		"x",
		"y",
		"width",
		"height",
		"minimized",
		"maximized",
		"minimized",
		"x",
		"y",
		"width",
		"height",
		"ERROR_INVALID_RANGE",
		"length",
		"ERROR_NULL_ARGUMENT",
		"length",
		"closeImageState",
		"closeImageState",
		"showing",
		"control",
		"control",
		"item",
		"Selection",
		"length",
		"length",
		"ERROR_INVALID_ARGUMENT",
		"length",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"length",
		"length",
		"length",
		"length",
		"length",
		"selectionGradientVertical",
		"length",
		"length",
		"length",
		"length",
		"length",
		"simple",
		"simple",
		"Resize",
		"single",
		"single",
		"length",
		"closeImageState",
		"closeImageState",
		"Resize",
		"ERROR_INVALID_ARGUMENT",
		"TOP",
		"BOTTOM",
		"ERROR_INVALID_ARGUMENT",
		"BOTTOM",
		"BOTTOM",
		"Resize",
		"RIGHT",
		"RIGHT",
		"FILL",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"showing",
		"NONE",
		"widget",
		"x",
		"y",
		"height",
		"x",
		"y",
		"length",
		"ON_TOP",
		"TOOL",
		"CENTER",
		"COLOR_INFO_FOREGROUND",
		"COLOR_INFO_BACKGROUND",
		"length",
		"length",
		"length",
		"length",
		"x",
		"y",
		"DEFAULT",
		"length",
		"y",
		"FLAGS",
		"TOP_MARGIN",
		"BOTTOM_MARGIN",
		"length",
		"Resize",
		"showing",
		"showClose",
		"closeRect",
		"DEFAULT",
		"DEFAULT",
		"x",
		"y",
		"width",
		"height",
		"x",
		"y",
		"x",
		"x",
		"x",
		"x",
		"x",
		"x",
		"width",
		"x",
		"x",
		"width",
		"x",
		"y",
		"y",
		"y",
		"height",
		"y",
		"y",
		"y",
		"parent",
		"style",
		"event",
		"event",
		"parent",
		"style",
		"gc",
		"region",
		"listener",
		"listener",
		"listener",
		"shape",
		"lineRGB",
		"innerRGB",
		"outerRGB",
		"gc",
		"x",
		"y",
		"width",
		"height",
		"item",
		"index",
		"item",
		"gc",
		"shape",
		"selected",
		"gc",
		"shape",
		"x",
		"y",
		"width",
		"height",
		"defaultBackground",
		"image",
		"colors",
		"percents",
		"vertical",
		"event",
		"gc",
		"gc",
		"gc",
		"event",
		"index",
		"pt",
		"string",
		"item",
		"e",
		"e",
		"e",
		"e",
		"e",
		"e",
		"e",
		"e",
		"e",
		"e",
		"e",
		"e",
		"event",
		"event",
		"event",
		"event",
		"event",
		"event",
		"event",
		"event",
		"event",
		"event",
		"event",
		"event",
		"listener",
		"listener",
		"listener",
		"color",
		"colors",
		"percents",
		"colors",
		"percents",
		"vertical",
		"image",
		"show",
		"font",
		"color",
		"item",
		"after",
		"index",
		"after",
		"visible",
		"layout",
		"maximize",
		"visible",
		"minimize",
		"count",
		"show",
		"item",
		"index",
		"index",
		"notify",
		"color",
		"colors",
		"percents",
		"colors",
		"percents",
		"vertical",
		"image",
		"color",
		"simple",
		"single",
		"height",
		"position",
		"control",
		"control",
		"alignment",
		"visible",
		"visible",
		"item",
		"rect",
		"e",
		"x",
		"y",
		"showIndex",
		"force",
		"x",
		"y",
		"x",
		"y"
	],
	"extendORImplementFiles":[
		"Composite"
	],
	"package":[
		"org.eclipse.swt.custom"
	],
	"import":[
		"org.eclipse.swt",
		"org.eclipse.swt.accessibility",
		"org.eclipse.swt.events",
		"org.eclipse.swt.graphics",
		"org.eclipse.swt.widgets"
	],
	"methods":[
		"handleEvent",
		"handleEvent",
		"checkStyle",
		"fillRegion",
		"addCTabFolder2Listener",
		"addCTabFolderListener",
		"addSelectionListener",
		"antialias",
		"computeTrim",
		"createItem",
		"destroyItem",
		"drawBackground",
		"drawBackground",
		"drawBody",
		"drawChevron",
		"drawMaximize",
		"drawMinimize",
		"drawTabArea",
		"getBorderVisible",
		"getClientArea",
		"getItem",
		"getItem",
		"getItemCount",
		"getItems",
		"_findMnemonic",
		"getMinimized",
		"getMinimizeVisible",
		"getMinimumCharacters",
		"getMaximized",
		"getMaximizeVisible",
		"getMRUVisible",
		"getRightItemEdge",
		"getSelection",
		"getSelectionBackground",
		"getSelectionForeground",
		"getSelectionIndex",
		"getSimple",
		"getSingle",
		"getStyle",
		"getTabHeight",
		"getTabPosition",
		"getTopRight",
		"getUnselectedCloseVisible",
		"getUnselectedImageVisible",
		"indexOf",
		"initAccessible",
		"getName",
		"getHelp",
		"getKeyboardShortcut",
		"getChildAtPoint",
		"getLocation",
		"getChildCount",
		"getDefaultAction",
		"getFocus",
		"getRole",
		"getSelection",
		"getState",
		"getChildren",
		"handleEvent",
		"handleEvent",
		"onKeyDown",
		"onDispose",
		"onDragDetect",
		"onFocus",
		"onMnemonic",
		"onMouseDoubleClick",
		"onMouseHover",
		"onMouse",
		"onPageTraversal",
		"onPaint",
		"onResize",
		"onTraverse",
		"redrawTabs",
		"removeCTabFolder2Listener",
		"removeCTabFolderListener",
		"removeSelectionListener",
		"setBackground",
		"setBackground",
		"setBackground",
		"setBackground",
		"setBorderVisible",
		"setButtonBounds",
		"setFont",
		"setForeground",
		"setInsertMark",
		"setInsertMark",
		"setItemLocation",
		"setItemSize",
		"setMaximizeVisible",
		"setLayout",
		"setMaximized",
		"setMinimizeVisible",
		"setMinimized",
		"setMinimumCharacters",
		"setMRUVisible",
		"setSelection",
		"setSelection",
		"setSelection",
		"setSelectionBackground",
		"setSelectionBackground",
		"setSelectionBackground",
		"setSelectionBackground",
		"setSelectionForeground",
		"setSimple",
		"setSingle",
		"setTabHeight",
		"setTabPosition",
		"setTopRight",
		"setTopRight",
		"setUnselectedCloseVisible",
		"setUnselectedImageVisible",
		"showItem",
		"showList",
		"widgetSelected",
		"showSelection",
		"hideToolTip",
		"showToolTip",
		"updateItems",
		"updateItems",
		"updateTabHeight",
		"_getToolTip",
		"updateToolTip",
		"checkStyle",
		"setLayout",
		"getStyle",
		"getFont",
		"getDisplay",
		"getSystemColor",
		"getSystemColor",
		"getSystemColor",
		"updateTabHeight",
		"initAccessible",
		"onDispose",
		"onDragDetect",
		"onFocus",
		"onFocus",
		"onKeyDown",
		"onMouseDoubleClick",
		"onMouse",
		"onMouse",
		"onMouseHover",
		"onMouse",
		"onMouse",
		"onPaint",
		"onResize",
		"onTraverse",
		"addListener",
		"updateToolTip",
		"hideToolTip",
		"getPlatform",
		"equals",
		"equals",
		"getStyle",
		"getClipping",
		"intersect",
		"setClipping",
		"fillRectangle",
		"getBounds",
		"setClipping",
		"dispose",
		"checkWidget",
		"error",
		"arraycopy",
		"checkWidget",
		"error",
		"arraycopy",
		"updateItems",
		"redraw",
		"checkWidget",
		"error",
		"addListener",
		"addListener",
		"equals",
		"getPlatform",
		"getDepth",
		"getDisplay",
		"getSize",
		"getDisplay",
		"setForeground",
		"drawPolyline",
		"dispose",
		"getSize",
		"getDisplay",
		"setForeground",
		"drawPolyline",
		"dispose",
		"checkWidget",
		"getItemCount",
		"error",
		"arraycopy",
		"arraycopy",
		"updateTabHeight",
		"updateItems",
		"redraw",
		"updateItems",
		"redrawTabs",
		"indexOf",
		"getControl",
		"isDisposed",
		"setVisible",
		"hideToolTip",
		"setButtonBounds",
		"redraw",
		"arraycopy",
		"arraycopy",
		"getControl",
		"max",
		"setSelection",
		"isDisposed",
		"setVisible",
		"updateItems",
		"redrawTabs",
		"getBackground",
		"getSize",
		"drawBackground",
		"getClipping",
		"add",
		"intersect",
		"setClipping",
		"setBackground",
		"fillRectangle",
		"getBounds",
		"drawImage",
		"setBackground",
		"fillRectangle",
		"setBackground",
		"fillRectangle",
		"setForeground",
		"setBackground",
		"fillGradientRectangle",
		"setForeground",
		"setBackground",
		"fillGradientRectangle",
		"setBackground",
		"fillRectangle",
		"getSize",
		"setForeground",
		"setBackground",
		"fillGradientRectangle",
		"setBackground",
		"fillRectangle",
		"getStyle",
		"equals",
		"getBackground",
		"setBackground",
		"fillRectangle",
		"setClipping",
		"dispose",
		"dispose",
		"getSize",
		"drawBackground",
		"drawBackground",
		"setBackground",
		"getBackground",
		"fillPolygon",
		"getStyle",
		"setBackground",
		"getBackground",
		"fillRectangle",
		"getStyle",
		"setBackground",
		"getBackground",
		"getParent",
		"fillRectangle",
		"setForeground",
		"drawLine",
		"drawLine",
		"drawLine",
		"drawLine",
		"getDisplay",
		"getDPI",
		"getFontData",
		"getFont",
		"setHeight",
		"getHeight",
		"getFontData",
		"getDPI",
		"max",
		"valueOf",
		"getSelectionForeground",
		"getForeground",
		"setForeground",
		"setFont",
		"drawLine",
		"drawLine",
		"drawLine",
		"drawLine",
		"drawLine",
		"drawLine",
		"drawLine",
		"drawLine",
		"drawString",
		"setForeground",
		"getSystemColor",
		"setBackground",
		"getSystemColor",
		"setFont",
		"fillRoundRectangle",
		"drawRoundRectangle",
		"drawLine",
		"drawLine",
		"drawLine",
		"drawLine",
		"drawLine",
		"drawLine",
		"drawLine",
		"drawLine",
		"drawString",
		"setForeground",
		"getSystemColor",
		"setBackground",
		"getSystemColor",
		"setFont",
		"fillRoundRectangle",
		"drawRoundRectangle",
		"drawLine",
		"drawLine",
		"drawLine",
		"drawLine",
		"drawLine",
		"drawLine",
		"drawLine",
		"drawLine",
		"drawString",
		"dispose",
		"getDisplay",
		"setForeground",
		"getSystemColor",
		"setBackground",
		"getSystemColor",
		"fillRectangle",
		"drawRectangle",
		"drawLine",
		"fillRectangle",
		"fillRectangle",
		"drawRectangle",
		"drawRectangle",
		"drawLine",
		"drawLine",
		"fillRoundRectangle",
		"drawRoundRectangle",
		"fillRectangle",
		"drawRectangle",
		"drawLine",
		"fillRectangle",
		"fillRectangle",
		"drawRectangle",
		"drawRectangle",
		"drawLine",
		"drawLine",
		"fillRoundRectangle",
		"drawRoundRectangle",
		"fillRectangle",
		"drawRectangle",
		"drawLine",
		"fillRectangle",
		"fillRectangle",
		"drawRectangle",
		"drawRectangle",
		"drawLine",
		"drawLine",
		"getDisplay",
		"setForeground",
		"getSystemColor",
		"setBackground",
		"getSystemColor",
		"fillRectangle",
		"drawRectangle",
		"fillRectangle",
		"fillRectangle",
		"drawRectangle",
		"drawRectangle",
		"drawLine",
		"drawLine",
		"fillRoundRectangle",
		"drawRoundRectangle",
		"fillRectangle",
		"drawRectangle",
		"fillRectangle",
		"fillRectangle",
		"drawRectangle",
		"drawRectangle",
		"drawLine",
		"drawLine",
		"fillRoundRectangle",
		"drawRoundRectangle",
		"fillRectangle",
		"drawRectangle",
		"fillRectangle",
		"fillRectangle",
		"drawRectangle",
		"drawRectangle",
		"drawLine",
		"drawLine",
		"getSize",
		"drawBackground",
		"drawBackground",
		"setBackground",
		"getBackground",
		"fillPolygon",
		"setForeground",
		"drawPolyline",
		"max",
		"drawBackground",
		"add",
		"subtract",
		"setBackground",
		"getBackground",
		"getParent",
		"fillRegion",
		"dispose",
		"intersects",
		"getBounds",
		"getBounds",
		"onPaint",
		"onPaint",
		"setForeground",
		"drawLine",
		"drawChevron",
		"drawMinimize",
		"drawMaximize",
		"getRGB",
		"getBackground",
		"getParent",
		"antialias",
		"getRGB",
		"setForeground",
		"drawPolyline",
		"checkWidget",
		"checkWidget",
		"getSize",
		"error",
		"getSize",
		"contains",
		"getBounds",
		"contains",
		"arraycopy",
		"length",
		"charAt",
		"charAt",
		"charAt",
		"checkWidget",
		"checkWidget",
		"checkWidget",
		"checkWidget",
		"checkWidget",
		"checkWidget",
		"getSize",
		"computeSize",
		"max",
		"checkWidget",
		"checkWidget",
		"checkWidget",
		"checkWidget",
		"getStyle",
		"checkWidget",
		"checkWidget",
		"checkWidget",
		"checkWidget",
		"checkWidget",
		"checkWidget",
		"error",
		"getAccessible",
		"addAccessibleListener",
		"getText",
		"indexOf",
		"substring",
		"substring",
		"getToolTipText",
		"getToolTipText",
		"getText",
		"_findMnemonic",
		"addAccessibleControlListener",
		"toControl",
		"contains",
		"getBounds",
		"getBounds",
		"getClientArea",
		"contains",
		"getBounds",
		"getBounds",
		"toDisplay",
		"getMessage",
		"isFocusControl",
		"isFocusControl",
		"isFocusControl",
		"addListener",
		"isFocusControl",
		"setFocus",
		"setFocus",
		"addListener",
		"setFocus",
		"setFocus",
		"getStyle",
		"showList",
		"isDisposed",
		"showList",
		"setSelection",
		"forceFocus",
		"hideToolTip",
		"isDisposed",
		"dispose",
		"dispose",
		"contains",
		"contains",
		"contains",
		"contains",
		"checkWidget",
		"redraw",
		"setSelection",
		"_findMnemonic",
		"getText",
		"toUpperCase",
		"toUpperCase",
		"setSelection",
		"getItem",
		"notifyListeners",
		"showToolTip",
		"redraw",
		"redraw",
		"redraw",
		"redraw",
		"redraw",
		"contains",
		"redraw",
		"update",
		"contains",
		"redraw",
		"update",
		"contains",
		"redraw",
		"update",
		"getBounds",
		"contains",
		"getBounds",
		"contains",
		"contains",
		"redraw",
		"update",
		"indexOf",
		"setSelection",
		"contains",
		"redraw",
		"contains",
		"redraw",
		"contains",
		"redraw",
		"redraw",
		"redraw",
		"redraw",
		"contains",
		"getBounds",
		"contains",
		"redraw",
		"redraw",
		"redraw",
		"redraw",
		"contains",
		"showList",
		"isDisposed",
		"showList",
		"contains",
		"redraw",
		"restore",
		"minimize",
		"contains",
		"redraw",
		"restore",
		"maximize",
		"getBounds",
		"contains",
		"getBounds",
		"contains",
		"contains",
		"redraw",
		"close",
		"itemClosed",
		"dispose",
		"getDisplay",
		"getCursorLocation",
		"map",
		"getItem",
		"contains",
		"redraw",
		"redraw",
		"showList",
		"isDisposed",
		"showList",
		"setSelection",
		"getFont",
		"equals",
		"updateTabHeight",
		"updateItems",
		"redraw",
		"getFont",
		"getBackground",
		"getForeground",
		"drawBody",
		"setFont",
		"setForeground",
		"setBackground",
		"drawTabArea",
		"setFont",
		"setForeground",
		"setBackground",
		"updateItems",
		"redrawTabs",
		"getSize",
		"redraw",
		"redraw",
		"min",
		"min",
		"max",
		"max",
		"redraw",
		"redraw",
		"onMnemonic",
		"onPageTraversal",
		"getSize",
		"redraw",
		"redraw",
		"checkWidget",
		"error",
		"arraycopy",
		"arraycopy",
		"checkWidget",
		"error",
		"arraycopy",
		"arraycopy",
		"checkWidget",
		"error",
		"removeListener",
		"removeListener",
		"setBackground",
		"redraw",
		"setBackground",
		"checkWidget",
		"error",
		"error",
		"error",
		"getDepth",
		"getDisplay",
		"equals",
		"setBackground",
		"setBackground",
		"redraw",
		"checkWidget",
		"redraw",
		"checkWidget",
		"getClientArea",
		"updateItems",
		"getClientArea",
		"equals",
		"notifyListeners",
		"redraw",
		"getSize",
		"min",
		"max",
		"redraw",
		"min",
		"max",
		"redraw",
		"max",
		"computeSize",
		"setBounds",
		"min",
		"max",
		"redraw",
		"min",
		"max",
		"min",
		"getRightItemEdge",
		"min",
		"max",
		"redraw",
		"checkWidget",
		"equals",
		"getFont",
		"setFont",
		"getFont",
		"updateTabHeight",
		"updateItems",
		"redraw",
		"setForeground",
		"redraw",
		"checkWidget",
		"checkWidget",
		"getItemCount",
		"error",
		"getSize",
		"max",
		"getBounds",
		"getDisplay",
		"getRightItemEdge",
		"getBounds",
		"getDisplay",
		"min",
		"min",
		"isDisposed",
		"getSize",
		"preferredWidth",
		"dispose",
		"min",
		"getRightItemEdge",
		"computeSize",
		"max",
		"preferredWidth",
		"max",
		"preferredWidth",
		"min",
		"dispose",
		"checkWidget",
		"updateItems",
		"redraw",
		"checkWidget",
		"checkWidget",
		"setMinimized",
		"redraw",
		"checkWidget",
		"updateItems",
		"redraw",
		"checkWidget",
		"setMaximized",
		"redraw",
		"checkWidget",
		"error",
		"updateItems",
		"redrawTabs",
		"checkWidget",
		"updateItems",
		"redrawTabs",
		"checkWidget",
		"error",
		"indexOf",
		"setSelection",
		"checkWidget",
		"showItem",
		"isDisposed",
		"setBounds",
		"getClientArea",
		"setVisible",
		"isDisposed",
		"setVisible",
		"showItem",
		"redraw",
		"setSelection",
		"getItem",
		"notifyListeners",
		"checkWidget",
		"getSystemColor",
		"getDisplay",
		"redraw",
		"setSelectionBackground",
		"checkWidget",
		"error",
		"error",
		"error",
		"getDepth",
		"getDisplay",
		"equals",
		"setSelectionBackground",
		"setSelectionBackground",
		"redraw",
		"checkWidget",
		"redraw",
		"checkWidget",
		"getSystemColor",
		"getDisplay",
		"redraw",
		"checkWidget",
		"getClientArea",
		"updateItems",
		"getClientArea",
		"equals",
		"notifyListeners",
		"redraw",
		"checkWidget",
		"getClientArea",
		"updateItems",
		"getClientArea",
		"equals",
		"notifyListeners",
		"redraw",
		"checkWidget",
		"error",
		"updateTabHeight",
		"checkWidget",
		"error",
		"updateTabHeight",
		"getClientArea",
		"updateItems",
		"getClientArea",
		"equals",
		"notifyListeners",
		"redraw",
		"setTopRight",
		"checkWidget",
		"error",
		"getParent",
		"error",
		"updateItems",
		"redraw",
		"checkWidget",
		"updateItems",
		"redraw",
		"checkWidget",
		"updateItems",
		"redraw",
		"checkWidget",
		"error",
		"isDisposed",
		"error",
		"indexOf",
		"error",
		"arraycopy",
		"arraycopy",
		"isShowing",
		"updateItems",
		"redrawTabs",
		"isDisposed",
		"getItems",
		"dispose",
		"setText",
		"getText",
		"setImage",
		"getImage",
		"setData",
		"addSelectionListener",
		"indexOf",
		"getData",
		"setSelection",
		"map",
		"getDisplay",
		"setLocation",
		"setVisible",
		"checkWidget",
		"showItem",
		"getSelection",
		"removeListener",
		"dispose",
		"getShell",
		"getDisplay",
		"setForeground",
		"getSystemColor",
		"setBackground",
		"getSystemColor",
		"addListener",
		"updateToolTip",
		"setVisible",
		"hideToolTip",
		"updateItems",
		"getRightItemEdge",
		"preferredWidth",
		"preferredWidth",
		"preferredWidth",
		"preferredWidth",
		"dispose",
		"setItemSize",
		"setItemLocation",
		"setButtonBounds",
		"getCursorLocation",
		"getDisplay",
		"toControl",
		"updateToolTip",
		"hideToolTip",
		"textExtent",
		"max",
		"preferredHeight",
		"dispose",
		"notifyListeners",
		"contains",
		"getMessage",
		"getMessage",
		"contains",
		"getMessage",
		"getMessage",
		"contains",
		"getMessage",
		"getItem",
		"contains",
		"getMessage",
		"getToolTipText",
		"_getToolTip",
		"equals",
		"getText",
		"setText",
		"computeSize",
		"setSize",
		"pack",
		"getClientArea",
		"setSize",
		"getCursorLocation",
		"getDisplay",
		"getSize",
		"getBounds",
		"getMonitor",
		"max",
		"setLocation",
		"RGB",
		"RGB",
		"RGB",
		"Rectangle",
		"Rectangle",
		"Rectangle",
		"Rectangle",
		"RGB",
		"CTabFolderLayout",
		"Listener",
		"Listener",
		"Region",
		"TypedListener",
		"Color",
		"Color",
		"Rectangle",
		"Rectangle",
		"Region",
		"Region",
		"Font",
		"Region",
		"Rectangle",
		"Rectangle",
		"Rectangle",
		"AccessibleAdapter",
		"AccessibleControlAdapter",
		"Integer",
		"Listener",
		"Listener",
		"CTabFolderEvent",
		"Event",
		"Point",
		"CTabFolderEvent",
		"CTabFolderEvent",
		"CTabFolderEvent",
		"CTabFolderEvent",
		"CTabFolderEvent",
		"Event",
		"GC",
		"GC",
		"Event",
		"Event",
		"Event",
		"Event",
		"Menu",
		"MenuItem",
		"SelectionAdapter",
		"Shell",
		"Label",
		"GC",
		"GC",
		"Event",
		"Point",
		"Point"
	],
	"methodsBody":{
		"void drawTabArea(Event event)":{
			"methodBody":"{\n    GC gc = event.gc;\n    Point size = getSize();\n    int[] shape = null;\n    if (tabHeight == 0) {\n        int x1 = borderLeft - 1;\n        int x2 = size.x - borderRight;\n        int y1 = onBottom ? size.y - borderBottom - highlight_header - 1 : borderTop + highlight_header;\n        int y2 = onBottom ? size.y - borderBottom : borderTop;\n        if (borderLeft > 0 && onBottom)\n            y2 -= 1;\n        shape = new int[] { x1, y1, x1, y2, x2, y2, x2, y1 };\n        \n        if (selectedIndex != -1 && selectionGradientColors != null && selectionGradientColors.length > 1 && !selectionGradientVertical) {\n            drawBackground(gc, shape, true);\n        } else if (selectedIndex == -1 && gradientColors != null && gradientColors.length > 1 && !gradientVertical) {\n            drawBackground(gc, shape, false);\n        } else {\n            gc.setBackground(selectedIndex == -1 ? getBackground() : selectionBackground);\n            gc.fillPolygon(shape);\n        }\n        \n        if (borderLeft > 0) {\n            gc.setForeground(borderColor);\n            gc.drawPolyline(shape);\n        }\n        return;\n    }\n    int x = Math.max(0, borderLeft - 1);\n    int y = onBottom ? size.y - borderBottom - tabHeight : borderTop;\n    int width = size.x - borderLeft - borderRight + 1;\n    int height = tabHeight - 1;\n    \n    if (onBottom) {\n        int[] left = simple ? SIMPLE_BOTTOM_LEFT_CORNER : BOTTOM_LEFT_CORNER;\n        int[] right = simple ? SIMPLE_BOTTOM_RIGHT_CORNER : BOTTOM_RIGHT_CORNER;\n        shape = new int[left.length + right.length + 4];\n        int index = 0;\n        shape[index++] = x;\n        shape[index++] = y - highlight_header;\n        for (int i = 0; i < left.length / 2; i++) {\n            shape[index++] = x + left[2 * i];\n            shape[index++] = y + height + left[2 * i + 1];\n            if (borderLeft == 0)\n                shape[index - 1] += 1;\n        }\n        for (int i = 0; i < right.length / 2; i++) {\n            shape[index++] = x + width + right[2 * i];\n            shape[index++] = y + height + right[2 * i + 1];\n            if (borderLeft == 0)\n                shape[index - 1] += 1;\n        }\n        shape[index++] = x + width;\n        shape[index++] = y - highlight_header;\n    } else {\n        int[] left = simple ? SIMPLE_TOP_LEFT_CORNER : TOP_LEFT_CORNER;\n        int[] right = simple ? SIMPLE_TOP_RIGHT_CORNER : TOP_RIGHT_CORNER;\n        shape = new int[left.length + right.length + 4];\n        int index = 0;\n        shape[index++] = x;\n        shape[index++] = y + height + highlight_header + 1;\n        for (int i = 0; i < left.length / 2; i++) {\n            shape[index++] = x + left[2 * i];\n            shape[index++] = y + left[2 * i + 1];\n        }\n        for (int i = 0; i < right.length / 2; i++) {\n            shape[index++] = x + width + right[2 * i];\n            shape[index++] = y + right[2 * i + 1];\n        }\n        shape[index++] = x + width;\n        shape[index++] = y + height + highlight_header + 1;\n    }\n    \n    boolean bkSelected = single && selectedIndex != -1;\n    drawBackground(gc, shape, bkSelected);\n    \n    Region r = new Region();\n    r.add(new Rectangle(x, y, width + 1, height + 1));\n    r.subtract(shape);\n    gc.setBackground(getParent().getBackground());\n    fillRegion(gc, r);\n    r.dispose();\n    \n    if (!single) {\n        for (int i = 0; i < items.length; i++) {\n            if (i != selectedIndex && event.getBounds().intersects(items[i].getBounds())) {\n                items[i].onPaint(gc, false);\n            }\n        }\n    }\n    \n    if (selectedIndex != -1) {\n        CTabItem item = items[selectedIndex];\n        item.onPaint(gc, true);\n    } else {\n        \n        int x1 = borderLeft;\n        int y1 = (onBottom) ? size.y - borderBottom - tabHeight - 1 : borderTop + tabHeight;\n        int x2 = size.x - borderRight;\n        gc.setForeground(borderColor);\n        gc.drawLine(x1, y1, x2, y1);\n    }\n    \n    drawChevron(gc);\n    drawMinimize(gc);\n    drawMaximize(gc);\n    \n    if (borderLeft > 0) {\n        RGB outside = getParent().getBackground().getRGB();\n        antialias(shape, borderColor.getRGB(), null, outside, gc);\n        gc.setForeground(borderColor);\n        gc.drawPolyline(shape);\n    }\n}",
			"comments":"// If horizontal gradient, show gradient across the whole area\n//draw 1 pixel border\n// Draw Tab Header\n// Fill in background\n// Fill in parent background for non-rectangular shape\n// Draw the unselected tabs.\n// Draw selected tab\n// if no selected tab - draw line across bottom of all tabs\n// Draw Buttons\n// Draw border line\n",
			"methodName":"void drawTabArea(Event event)"
		},
		"public void getSelection(AccessibleControlEvent e)":{
			"methodBody":"{\n    e.childID = (selectedIndex == -1) ? ACC.CHILDID_NONE : selectedIndex;\n}",
			"comments":"",
			"methodName":"public void getSelection(AccessibleControlEvent e)"
		},
		"public boolean getSimple()":{
			"methodBody":"{\n    checkWidget();\n    return simple;\n}",
			"comments":"/**\n* Returns <code>true</code> if the CTabFolder is rendered\n* with a simple, traditional shape.\n*\n* @return <code>true</code> if the CTabFolder is rendered with a simple shape\n*\n* @since 3.0\n*/\n",
			"methodName":"public boolean getSimple()"
		},
		"public void setSelection(CTabItem item)":{
			"methodBody":"{\n    checkWidget();\n    if (item == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    int index = indexOf(item);\n    setSelection(index);\n}",
			"comments":"/**\n* Set the selection to the tab at the specified item.\n*\n* @param item the tab item to be selected\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*    <li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void setSelection(CTabItem item)"
		},
		"void setSelection(int index, boolean notify)":{
			"methodBody":"{\n    int oldSelectedIndex = selectedIndex;\n    setSelection(index);\n    if (notify && selectedIndex != oldSelectedIndex && selectedIndex != -1) {\n        Event event = new Event();\n        event.item = getItem(selectedIndex);\n        notifyListeners(SWT.Selection, event);\n    }\n}",
			"comments":"",
			"methodName":"void setSelection(int index, boolean notify)"
		},
		"public Color getSelectionBackground()":{
			"methodBody":"{\n    checkWidget();\n    return selectionBackground;\n}",
			"comments":"/**\n* Returns the receiver's selection background color.\n*\n* @return the selection background color of the receiver\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public Color getSelectionBackground()"
		},
		"public void getKeyboardShortcut(AccessibleEvent e)":{
			"methodBody":"{\n    String shortcut = null;\n    int childID = e.childID;\n    if (childID >= 0 && childID < items.length) {\n        String text = items[childID].getText();\n        if (text != null) {\n            char mnemonic = _findMnemonic(text);\n            if (mnemonic != '\\0') {\n                \n                shortcut = \"Alt+\" + mnemonic;\n            }\n        }\n    }\n    e.result = shortcut;\n}",
			"comments":"//$NON-NLS-1$\n",
			"methodName":"public void getKeyboardShortcut(AccessibleEvent e)"
		},
		"public void addCTabFolderListener(CTabFolderListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    \n    CTabFolderListener[] newTabListeners = new CTabFolderListener[tabListeners.length + 1];\n    System.arraycopy(tabListeners, 0, newTabListeners, 0, tabListeners.length);\n    tabListeners = newTabListeners;\n    tabListeners[tabListeners.length - 1] = listener;\n    \n    if (!showClose) {\n        showClose = true;\n        updateItems();\n        redraw();\n    }\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when a tab item is closed.\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*    <li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n* </ul>\n*\n* @see CTabFolderListener\n* @see #removeCTabFolderListener(CTabFolderListener)\n*\n* @deprecated use addCTabFolder2Listener(CTabFolder2Listener)\n*/\n// add to array\n// display close button to be backwards compatible\n",
			"methodName":"public void addCTabFolderListener(CTabFolderListener listener)"
		},
		"char _findMnemonic(String string)":{
			"methodBody":"{\n    if (string == null)\n        return '\\0';\n    int index = 0;\n    int length = string.length();\n    do {\n        while (index < length && string.charAt(index) != '&') index++;\n        if (++index >= length)\n            return '\\0';\n        if (string.charAt(index) != '&')\n            return string.charAt(index);\n        index++;\n    } while (index < length);\n    return '\\0';\n}",
			"comments":"",
			"methodName":"char _findMnemonic(String string)"
		},
		"void drawBody(Event event)":{
			"methodBody":"{\n    GC gc = event.gc;\n    Point size = getSize();\n    \n    if (!minimized) {\n        int width = size.x - borderLeft - borderRight - 2 * highlight_margin;\n        int height = size.y - borderTop - borderBottom - tabHeight - highlight_header - highlight_margin;\n        \n        if (highlight_margin > 0) {\n            int[] shape = null;\n            if (onBottom) {\n                int x1 = borderLeft;\n                int y1 = borderTop;\n                int x2 = size.x - borderRight;\n                int y2 = size.y - borderBottom - tabHeight - highlight_header;\n                shape = new int[] { x1, y1, x2, y1, x2, y2, x2 - highlight_margin, y2, x2 - highlight_margin, y1 + highlight_margin, x1 + highlight_margin, y1 + highlight_margin, x1 + highlight_margin, y2, x1, y2 };\n            } else {\n                int x1 = borderLeft;\n                int y1 = borderTop + tabHeight + highlight_header;\n                int x2 = size.x - borderRight;\n                int y2 = size.y - borderBottom;\n                shape = new int[] { x1, y1, x1 + highlight_margin, y1, x1 + highlight_margin, y2 - highlight_margin, x2 - highlight_margin, y2 - highlight_margin, x2 - highlight_margin, y1, x2, y1, x2, y2, x1, y2 };\n            }\n            \n            if (selectedIndex != -1 && selectionGradientColors != null && selectionGradientColors.length > 1 && !selectionGradientVertical) {\n                drawBackground(gc, shape, true);\n            } else if (selectedIndex == -1 && gradientColors != null && gradientColors.length > 1 && !gradientVertical) {\n                drawBackground(gc, shape, false);\n            } else {\n                gc.setBackground(selectedIndex == -1 ? getBackground() : selectionBackground);\n                gc.fillPolygon(shape);\n            }\n        }\n        \n        if ((getStyle() & SWT.NO_BACKGROUND) != 0) {\n            gc.setBackground(getBackground());\n            gc.fillRectangle(xClient - marginWidth, yClient - marginHeight, width, height);\n        }\n    } else {\n        if ((getStyle() & SWT.NO_BACKGROUND) != 0) {\n            int height = borderTop + tabHeight + highlight_header + borderBottom;\n            if (size.y > height) {\n                gc.setBackground(getParent().getBackground());\n                gc.fillRectangle(0, height, size.x, size.y - height);\n            }\n        }\n    }\n    \n    if (borderLeft > 0) {\n        gc.setForeground(borderColor);\n        int x1 = borderLeft - 1;\n        int x2 = size.x - borderRight;\n        int y1 = onBottom ? borderTop - 1 : borderTop + tabHeight;\n        int y2 = onBottom ? size.y - tabHeight - borderBottom - 1 : size.y - borderBottom;\n        \n        gc.drawLine(x1, y1, x1, y2);\n        \n        gc.drawLine(x2, y1, x2, y2);\n        if (onBottom) {\n            \n            gc.drawLine(x1, y1, x2, y1);\n        } else {\n            \n            gc.drawLine(x1, y2, x2, y2);\n        }\n    }\n}",
			"comments":"// fill in body\n// Draw highlight margin\n// If horizontal gradient, show gradient across the whole area\n//Draw client area\n//draw 1 pixel border around outside\n// left\n// right\n// top\n// bottom\n",
			"methodName":"void drawBody(Event event)"
		},
		"public void setSelection(int index)":{
			"methodBody":"{\n    checkWidget();\n    if (index < 0 || index >= items.length)\n        return;\n    CTabItem selection = items[index];\n    if (selectedIndex == index) {\n        showItem(selection);\n        return;\n    }\n    int oldIndex = selectedIndex;\n    selectedIndex = index;\n    if (oldIndex != -1) {\n        items[oldIndex].closeImageState = NONE;\n    }\n    selection.closeImageState = NORMAL;\n    selection.showing = false;\n    Control control = selection.control;\n    if (control != null && !control.isDisposed()) {\n        control.setBounds(getClientArea());\n        control.setVisible(true);\n    }\n    if (oldIndex != -1) {\n        control = items[oldIndex].control;\n        if (control != null && !control.isDisposed()) {\n            control.setVisible(false);\n        }\n    }\n    showItem(selection);\n    redraw();\n}",
			"comments":"/**\n* Set the selection to the tab at the specified index.\n*\n* @param index the index of the tab item to be selected\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setSelection(int index)"
		},
		"public void setBorderVisible(boolean show)":{
			"methodBody":"{\n    checkWidget();\n    if ((borderLeft == 1) == show)\n        return;\n    borderLeft = borderRight = show ? 1 : 0;\n    borderTop = onBottom ? borderLeft : 0;\n    borderBottom = onBottom ? 0 : borderLeft;\n    Rectangle rectBefore = getClientArea();\n    updateItems();\n    Rectangle rectAfter = getClientArea();\n    if (!rectBefore.equals(rectAfter)) {\n        notifyListeners(SWT.Resize, new Event());\n    }\n    redraw();\n}",
			"comments":"/**\n* Toggle the visibility of the border\n*\n* @param show true if the border should be displayed\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setBorderVisible(boolean show)"
		},
		"public void setTopRight(Control control)":{
			"methodBody":"{\n    setTopRight(control, SWT.RIGHT);\n}",
			"comments":"/**\n* Set the control that appears in the top right corner of the tab folder.\n* Typically this is a close button or a composite with a Menu and close button.\n* The topRight control is optional.  Setting the top right control to null will\n* remove it from the tab folder.\n*\n* @param control the control to be displayed in the top right corner or null\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the control is not a child of this CTabFolder</li>\n* </ul>\n*\n* @since 2.1\n*/\n",
			"methodName":"public void setTopRight(Control control)"
		},
		"void drawMaximize(GC gc)":{
			"methodBody":"{\n    if (maxRect.width == 0 || maxRect.height == 0)\n        return;\n    Display display = getDisplay();\n    \n    int x = maxRect.x + (CTabFolder.BUTTON_SIZE - 10) / 2;\n    int y = maxRect.y + 3;\n    gc.setForeground(display.getSystemColor(BUTTON_BORDER));\n    gc.setBackground(display.getSystemColor(BUTTON_FILL));\n    switch(maxImageState) {\n        case NORMAL:\n            {\n                if (!maximized) {\n                    gc.fillRectangle(x, y, 9, 9);\n                    gc.drawRectangle(x, y, 9, 9);\n                    gc.drawLine(x + 1, y + 2, x + 8, y + 2);\n                } else {\n                    gc.fillRectangle(x, y + 3, 5, 4);\n                    gc.fillRectangle(x + 2, y, 5, 4);\n                    gc.drawRectangle(x, y + 3, 5, 4);\n                    gc.drawRectangle(x + 2, y, 5, 4);\n                    gc.drawLine(x + 3, y + 1, x + 6, y + 1);\n                    gc.drawLine(x + 1, y + 4, x + 4, y + 4);\n                }\n                break;\n            }\n        case HOT:\n            {\n                gc.fillRoundRectangle(maxRect.x, maxRect.y, maxRect.width, maxRect.height, 6, 6);\n                gc.drawRoundRectangle(maxRect.x, maxRect.y, maxRect.width - 1, maxRect.height - 1, 6, 6);\n                if (!maximized) {\n                    gc.fillRectangle(x, y, 9, 9);\n                    gc.drawRectangle(x, y, 9, 9);\n                    gc.drawLine(x + 1, y + 2, x + 8, y + 2);\n                } else {\n                    gc.fillRectangle(x, y + 3, 5, 4);\n                    gc.fillRectangle(x + 2, y, 5, 4);\n                    gc.drawRectangle(x, y + 3, 5, 4);\n                    gc.drawRectangle(x + 2, y, 5, 4);\n                    gc.drawLine(x + 3, y + 1, x + 6, y + 1);\n                    gc.drawLine(x + 1, y + 4, x + 4, y + 4);\n                }\n                break;\n            }\n        case SELECTED:\n            {\n                gc.fillRoundRectangle(maxRect.x, maxRect.y, maxRect.width, maxRect.height, 6, 6);\n                gc.drawRoundRectangle(maxRect.x, maxRect.y, maxRect.width - 1, maxRect.height - 1, 6, 6);\n                if (!maximized) {\n                    gc.fillRectangle(x + 1, y + 1, 9, 9);\n                    gc.drawRectangle(x + 1, y + 1, 9, 9);\n                    gc.drawLine(x + 2, y + 3, x + 9, y + 3);\n                } else {\n                    gc.fillRectangle(x + 1, y + 4, 5, 4);\n                    gc.fillRectangle(x + 3, y + 1, 5, 4);\n                    gc.drawRectangle(x + 1, y + 4, 5, 4);\n                    gc.drawRectangle(x + 3, y + 1, 5, 4);\n                    gc.drawLine(x + 4, y + 2, x + 7, y + 2);\n                    gc.drawLine(x + 2, y + 5, x + 5, y + 5);\n                }\n                break;\n            }\n    }\n}",
			"comments":"// 5x4 or 7x9\n",
			"methodName":"void drawMaximize(GC gc)"
		},
		"public void removeSelectionListener(SelectionListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null) {\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    }\n    removeListener(SWT.Selection, listener);\n    removeListener(SWT.DefaultSelection, listener);\n}",
			"comments":"/**\n* Removes the listener.\n*\n* @param listener the listener\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*    <li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void removeSelectionListener(SelectionListener listener)"
		},
		"public void getChildren(AccessibleControlEvent e)":{
			"methodBody":"{\n    Object[] children = new Object[items.length];\n    for (int i = 0; i < items.length; i++) {\n        children[i] = new Integer(i);\n    }\n    e.children = children;\n}",
			"comments":"",
			"methodName":"public void getChildren(AccessibleControlEvent e)"
		},
		"void destroyItem(CTabItem item)":{
			"methodBody":"{\n    if (inDispose)\n        return;\n    int index = indexOf(item);\n    if (index == -1)\n        return;\n    if (items.length == 1) {\n        items = new CTabItem[0];\n        priority = new int[0];\n        firstIndex = -1;\n        selectedIndex = -1;\n        Control control = item.getControl();\n        if (control != null && !control.isDisposed()) {\n            control.setVisible(false);\n        }\n        hideToolTip();\n        setButtonBounds();\n        redraw();\n        return;\n    }\n    CTabItem[] newItems = new CTabItem[items.length - 1];\n    System.arraycopy(items, 0, newItems, 0, index);\n    System.arraycopy(items, index + 1, newItems, index, items.length - index - 1);\n    items = newItems;\n    int[] newPriority = new int[priority.length - 1];\n    int next = 0;\n    for (int i = 0; i < priority.length; i++) {\n        if (priority[i] == index)\n            continue;\n        newPriority[next++] = priority[i] > index ? priority[i] - 1 : priority[i];\n    }\n    priority = newPriority;\n    \n    if (selectedIndex == index) {\n        Control control = item.getControl();\n        selectedIndex = -1;\n        int nextSelection = mru ? priority[0] : Math.max(0, index - 1);\n        setSelection(nextSelection, true);\n        if (control != null && !control.isDisposed()) {\n            control.setVisible(false);\n        }\n    } else if (selectedIndex > index) {\n        selectedIndex--;\n    }\n    updateItems();\n    redrawTabs();\n}",
			"comments":"// move the selection if this item is selected\n",
			"methodName":"void destroyItem(CTabItem item)"
		},
		"public void setSelectionForeground(Color color)":{
			"methodBody":"{\n    checkWidget();\n    if (selectionForeground == color)\n        return;\n    if (color == null)\n        color = getDisplay().getSystemColor(SELECTION_FOREGROUND);\n    selectionForeground = color;\n    if (selectedIndex > -1)\n        redraw();\n}",
			"comments":"/**\n* Set the foreground color of the selected tab.\n*\n* @param color the color of the text displayed in the selected tab\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setSelectionForeground(Color color)"
		},
		"public void handleEvent(Event event)":{
			"methodBody":"{\n    if (selectedIndex == -1) {\n        accessible.setFocus(ACC.CHILDID_SELF);\n    } else {\n        accessible.setFocus(selectedIndex);\n    }\n}",
			"comments":"",
			"methodName":"public void handleEvent(Event event)"
		},
		"public CTabItem getSelection()":{
			"methodBody":"{\n    \n    if (selectedIndex == -1)\n        return null;\n    return items[selectedIndex];\n}",
			"comments":"/**\n* Return the selected tab item, or an empty array if there\n* is no selection.\n*\n* @return the selected tab item\n*\n* @exception SWTException <ul>\n*\t\t<li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*\t\t<li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n*\t</ul>\n*/\n//checkWidget();\n",
			"methodName":"public CTabItem getSelection()"
		},
		"public void getChildCount(AccessibleControlEvent e)":{
			"methodBody":"{\n    e.detail = items.length;\n}",
			"comments":"",
			"methodName":"public void getChildCount(AccessibleControlEvent e)"
		},
		"public boolean getSingle()":{
			"methodBody":"{\n    checkWidget();\n    return single;\n}",
			"comments":"/**\n* Returns <code>true</code> if the CTabFolder only displys the selected tab\n* and <code>false</code> if the CTabFolder displays multiple tabs.\n*\n* @return <code>true</code> if the CTabFolder only displys the selected tab and <code>false</code> if the CTabFolder displays multiple tabs\n*\n* @since 3.0\n*/\n",
			"methodName":"public boolean getSingle()"
		},
		"void showToolTip(int x, int y)":{
			"methodBody":"{\n    if (toolTipShell == null) {\n        toolTipShell = new Shell(getShell(), SWT.ON_TOP | SWT.TOOL);\n        toolTipLabel = new Label(toolTipShell, SWT.CENTER);\n        Display display = toolTipShell.getDisplay();\n        toolTipLabel.setForeground(display.getSystemColor(SWT.COLOR_INFO_FOREGROUND));\n        toolTipLabel.setBackground(display.getSystemColor(SWT.COLOR_INFO_BACKGROUND));\n        for (int i = 0; i < toolTipEvents.length; i++) {\n            addListener(toolTipEvents[i], toolTipListener);\n        }\n    }\n    if (updateToolTip(x, y)) {\n        toolTipShell.setVisible(true);\n    } else {\n        hideToolTip();\n    }\n}",
			"comments":"",
			"methodName":"void showToolTip(int x, int y)"
		},
		"public void getLocation(AccessibleControlEvent e)":{
			"methodBody":"{\n    Rectangle location = null;\n    int childID = e.childID;\n    if (childID == ACC.CHILDID_SELF) {\n        location = getBounds();\n    }\n    if (childID >= 0 && childID < items.length) {\n        location = items[childID].getBounds();\n    }\n    if (location != null) {\n        Point pt = toDisplay(location.x, location.y);\n        e.x = pt.x;\n        e.y = pt.y;\n        e.width = location.width;\n        e.height = location.height;\n    }\n}",
			"comments":"",
			"methodName":"public void getLocation(AccessibleControlEvent e)"
		},
		"void drawBackground(GC gc, int[] shape, int x, int y, int width, int height, Color defaultBackground, Image image, Color[] colors, int[] percents, boolean vertical)":{
			"methodBody":"{\n    Region clipping = new Region();\n    gc.getClipping(clipping);\n    Region region = new Region();\n    region.add(shape);\n    region.intersect(clipping);\n    gc.setClipping(region);\n    if (image != null) {\n        \n        gc.setBackground(defaultBackground);\n        gc.fillRectangle(x, y, width, height);\n        Rectangle imageRect = image.getBounds();\n        gc.drawImage(image, imageRect.x, imageRect.y, imageRect.width, imageRect.height, x, y, width, height);\n    } else if (colors != null) {\n        \n        if (colors.length == 1) {\n            Color background = colors[0] != null ? colors[0] : defaultBackground;\n            gc.setBackground(background);\n            gc.fillRectangle(x, y, width, height);\n        } else {\n            if (vertical) {\n                if (onBottom) {\n                    int pos = 0;\n                    if (percents[percents.length - 1] < 100) {\n                        pos = percents[percents.length - 1] * height / 100;\n                        gc.setBackground(defaultBackground);\n                        gc.fillRectangle(x, y, width, pos);\n                    }\n                    Color lastColor = colors[colors.length - 1];\n                    if (lastColor == null)\n                        lastColor = defaultBackground;\n                    for (int i = percents.length - 1; i >= 0; i--) {\n                        gc.setForeground(lastColor);\n                        lastColor = colors[i];\n                        if (lastColor == null)\n                            lastColor = defaultBackground;\n                        gc.setBackground(lastColor);\n                        int gradientHeight = percents[i] * height / 100;\n                        gc.fillGradientRectangle(x, y + pos, width, gradientHeight, true);\n                        pos += gradientHeight;\n                    }\n                } else {\n                    Color lastColor = colors[0];\n                    if (lastColor == null)\n                        lastColor = defaultBackground;\n                    int pos = 0;\n                    for (int i = 0; i < percents.length; i++) {\n                        gc.setForeground(lastColor);\n                        lastColor = colors[i + 1];\n                        if (lastColor == null)\n                            lastColor = defaultBackground;\n                        gc.setBackground(lastColor);\n                        int gradientHeight = percents[i] * height / 100;\n                        gc.fillGradientRectangle(x, y + pos, width, gradientHeight, true);\n                        pos += gradientHeight;\n                    }\n                    if (pos < height) {\n                        gc.setBackground(defaultBackground);\n                        gc.fillRectangle(x, pos, width, height - pos + 1);\n                    }\n                }\n            } else {\n                \n                y = 0;\n                height = getSize().y;\n                Color lastColor = colors[0];\n                if (lastColor == null)\n                    lastColor = defaultBackground;\n                int pos = 0;\n                for (int i = 0; i < percents.length; ++i) {\n                    gc.setForeground(lastColor);\n                    lastColor = colors[i + 1];\n                    if (lastColor == null)\n                        lastColor = defaultBackground;\n                    gc.setBackground(lastColor);\n                    int gradientWidth = (percents[i] * width / 100) - pos;\n                    gc.fillGradientRectangle(x + pos, y, gradientWidth, height, false);\n                    pos += gradientWidth;\n                }\n                if (pos < width) {\n                    gc.setBackground(defaultBackground);\n                    gc.fillRectangle(x + pos, y, width - pos, height);\n                }\n            }\n        }\n    } else {\n        \n        if ((getStyle() & SWT.NO_BACKGROUND) != 0 || !defaultBackground.equals(getBackground())) {\n            gc.setBackground(defaultBackground);\n            gc.fillRectangle(x, y, width, height);\n        }\n    }\n    gc.setClipping(clipping);\n    clipping.dispose();\n    region.dispose();\n}",
			"comments":"// draw the background image in shape\n// draw gradient\n//horizontal gradient\n// draw a solid background using default background in shape\n",
			"methodName":"void drawBackground(GC gc, int[] shape, int x, int y, int width, int height, Color defaultBackground, Image image, Color[] colors, int[] percents, boolean vertical)"
		},
		"public Control getTopRight()":{
			"methodBody":"{\n    checkWidget();\n    return topRight;\n}",
			"comments":"/**\n* Returns the control in the top right corner of the tab folder.\n* Typically this is a close button or a composite with a menu and close button.\n*\n* @return the control in the top right corner of the tab folder or null\n*\n* @exception  SWTException <ul>\n*\t\t<li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*\t\t<li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n*\t</ul>\n*\n* @since 2.1\n*/\n",
			"methodName":"public Control getTopRight()"
		},
		"public void setSelectionBackground(Color color)":{
			"methodBody":"{\n    checkWidget();\n    if (selectionBackground == color)\n        return;\n    if (color == null)\n        color = getDisplay().getSystemColor(SELECTION_BACKGROUND);\n    selectionBackground = color;\n    if (selectedIndex > -1)\n        redraw();\n}",
			"comments":"/**\n* Sets the receiver's selection background color to the color specified\n* by the argument, or to the default system color for the control\n* if the argument is null.\n*\n* @param color the new color (or null)\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public void setSelectionBackground(Color color)"
		},
		"public boolean getBorderVisible()":{
			"methodBody":"{\n    checkWidget();\n    return borderLeft == 1;\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver's border is visible.\n*\n* @return the receiver's border visibility state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public boolean getBorderVisible()"
		},
		"public int getStyle()":{
			"methodBody":"{\n    int style = super.getStyle();\n    style &= ~(SWT.TOP | SWT.BOTTOM);\n    style |= onBottom ? SWT.BOTTOM : SWT.TOP;\n    style &= ~(SWT.SINGLE | SWT.MULTI);\n    style |= single ? SWT.SINGLE : SWT.MULTI;\n    if (borderLeft != 0)\n        style |= SWT.BORDER;\n    return style;\n}",
			"comments":"",
			"methodName":"public int getStyle()"
		},
		"boolean updateItems(int showIndex)":{
			"methodBody":"{\n    if (!single && !mru && showIndex != -1) {\n        \n        int firstIndex = showIndex;\n        if (priority[0] < showIndex) {\n            int maxWidth = getRightItemEdge() - borderLeft;\n            if (!simple)\n                maxWidth -= curveWidth - 2 * curveIndent;\n            int width = 0;\n            int[] widths = new int[items.length];\n            GC gc = new GC(this);\n            for (int i = priority[0]; i <= showIndex; i++) {\n                widths[i] = items[i].preferredWidth(gc, i == selectedIndex, true);\n                width += widths[i];\n                if (width > maxWidth)\n                    break;\n            }\n            if (width > maxWidth) {\n                width = 0;\n                for (int i = showIndex; i >= 0; i--) {\n                    if (widths[i] == 0)\n                        widths[i] = items[i].preferredWidth(gc, i == selectedIndex, true);\n                    width += widths[i];\n                    if (width > maxWidth)\n                        break;\n                    firstIndex = i;\n                }\n            } else {\n                firstIndex = priority[0];\n                for (int i = showIndex + 1; i < items.length; i++) {\n                    widths[i] = items[i].preferredWidth(gc, i == selectedIndex, true);\n                    width += widths[i];\n                    if (width >= maxWidth)\n                        break;\n                }\n                if (width < maxWidth) {\n                    for (int i = priority[0] - 1; i >= 0; i--) {\n                        if (widths[i] == 0)\n                            widths[i] = items[i].preferredWidth(gc, i == selectedIndex, true);\n                        width += widths[i];\n                        if (width > maxWidth)\n                            break;\n                        firstIndex = i;\n                    }\n                }\n            }\n            gc.dispose();\n        }\n        if (firstIndex != priority[0]) {\n            int index = 0;\n            for (int i = firstIndex; i < items.length; i++) {\n                priority[index++] = i;\n            }\n            for (int i = 0; i < firstIndex; i++) {\n                priority[index++] = i;\n            }\n        }\n    }\n    boolean oldShowChevron = showChevron;\n    boolean changed = setItemSize();\n    changed |= setItemLocation();\n    setButtonBounds();\n    changed |= showChevron != oldShowChevron;\n    if (changed && toolTipShell != null) {\n        Point pt = getDisplay().getCursorLocation();\n        pt = toControl(pt);\n        if (!updateToolTip(pt.x, pt.y))\n            hideToolTip();\n    }\n    return changed;\n}",
			"comments":"// make sure selected item will be showing\n",
			"methodName":"boolean updateItems(int showIndex)"
		},
		"public void setFont(Font font)":{
			"methodBody":"{\n    checkWidget();\n    if (font != null && font.equals(getFont()))\n        return;\n    super.setFont(font);\n    oldFont = getFont();\n    if (!updateTabHeight(false)) {\n        updateItems();\n        redraw();\n    }\n}",
			"comments":"",
			"methodName":"public void setFont(Font font)"
		},
		"public boolean getMaximizeVisible()":{
			"methodBody":"{\n    checkWidget();\n    return showMax;\n}",
			"comments":"/**\n* Returns <code>true</code> if the maximize button\n* is visible.\n*\n* @return the visibility of the maximized button\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public boolean getMaximizeVisible()"
		},
		"public void getName(AccessibleEvent e)":{
			"methodBody":"{\n    String name = null;\n    int childID = e.childID;\n    if (childID >= 0 && childID < items.length) {\n        name = items[childID].getText();\n        int index = name.indexOf('&');\n        if (index > 0) {\n            name = name.substring(0, index) + name.substring(index + 1);\n        }\n    }\n    e.result = name;\n}",
			"comments":"",
			"methodName":"public void getName(AccessibleEvent e)"
		},
		"void onFocus(Event event)":{
			"methodBody":"{\n    checkWidget();\n    if (selectedIndex >= 0) {\n        redraw();\n    } else {\n        setSelection(0, true);\n    }\n}",
			"comments":"",
			"methodName":"void onFocus(Event event)"
		},
		"public void setTabPosition(int position)":{
			"methodBody":"{\n    checkWidget();\n    if (position != SWT.TOP && position != SWT.BOTTOM) {\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    }\n    if (onBottom != (position == SWT.BOTTOM)) {\n        onBottom = position == SWT.BOTTOM;\n        borderTop = onBottom ? borderLeft : 0;\n        borderBottom = onBottom ? 0 : borderRight;\n        updateTabHeight(true);\n        Rectangle rectBefore = getClientArea();\n        updateItems();\n        Rectangle rectAfter = getClientArea();\n        if (!rectBefore.equals(rectAfter)) {\n            notifyListeners(SWT.Resize, new Event());\n        }\n        redraw();\n    }\n}",
			"comments":"/**\n* Specify whether the tabs should appear along the top of the folder\n* or along the bottom of the folder.\n*\n* @param position <code>SWT.TOP</code> for tabs along the top or <code>SWT.BOTTOM</code> for tabs along the bottom\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the position value is not either SWT.TOP or SWT.BOTTOM</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public void setTabPosition(int position)"
		},
		"public int indexOf(CTabItem item)":{
			"methodBody":"{\n    checkWidget();\n    if (item == null) {\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    }\n    for (int i = 0; i < items.length; i++) {\n        if (items[i] == item)\n            return i;\n    }\n    return -1;\n}",
			"comments":"/**\n* Return the index of the specified tab or -1 if the tab is not\n* in the receiver.\n*\n* @param item the tab item for which the index is required\n*\n* @return the index of the specified tab item or -1\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*    <li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public int indexOf(CTabItem item)"
		},
		"public void setMinimumCharacters(int count)":{
			"methodBody":"{\n    checkWidget();\n    if (count < 0)\n        SWT.error(SWT.ERROR_INVALID_RANGE);\n    if (minChars == count)\n        return;\n    minChars = count;\n    if (updateItems())\n        redrawTabs();\n}",
			"comments":"/**\n* Sets the minimum number of characters that will\n* be displayed in a fully compressed tab.\n*\n* @param count the minimum number of characters that will be displayed in a fully compressed tab\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_INVALID_RANGE - if the count is less than zero</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public void setMinimumCharacters(int count)"
		},
		"public void addSelectionListener(SelectionListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null) {\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    }\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.Selection, typedListener);\n    addListener(SWT.DefaultSelection, typedListener);\n}",
			"comments":"/**\n* Adds the listener to receive events.\n* <p>\n*\n* @param listener the listener\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*    <li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void addSelectionListener(SelectionListener listener)"
		},
		"public Color getSelectionForeground()":{
			"methodBody":"{\n    checkWidget();\n    return selectionForeground;\n}",
			"comments":"/**\n* Returns the receiver's selection foreground color.\n*\n* @return the selection foreground color of the receiver\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public Color getSelectionForeground()"
		},
		"int getRightItemEdge()":{
			"methodBody":"{\n    int x = getSize().x - borderRight - 3;\n    if (showMin)\n        x -= BUTTON_SIZE;\n    if (showMax)\n        x -= BUTTON_SIZE;\n    if (showChevron)\n        x -= 3 * BUTTON_SIZE / 2;\n    if (topRight != null && topRightAlignment != SWT.FILL) {\n        Point rightSize = topRight.computeSize(SWT.DEFAULT, SWT.DEFAULT);\n        x -= rightSize.x + 3;\n    }\n    return Math.max(0, x);\n}",
			"comments":"",
			"methodName":"int getRightItemEdge()"
		},
		"boolean onMnemonic(Event event)":{
			"methodBody":"{\n    char key = event.character;\n    for (int i = 0; i < items.length; i++) {\n        if (items[i] != null) {\n            char mnemonic = _findMnemonic(items[i].getText());\n            if (mnemonic != '\\0') {\n                if (Character.toUpperCase(key) == Character.toUpperCase(mnemonic)) {\n                    setSelection(i, true);\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}",
			"comments":"",
			"methodName":"boolean onMnemonic(Event event)"
		},
		"public void removeCTabFolderListener(CTabFolderListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (tabListeners.length == 0)\n        return;\n    int index = -1;\n    for (int i = 0; i < tabListeners.length; i++) {\n        if (listener == tabListeners[i]) {\n            index = i;\n            break;\n        }\n    }\n    if (index == -1)\n        return;\n    if (tabListeners.length == 1) {\n        tabListeners = new CTabFolderListener[0];\n        return;\n    }\n    CTabFolderListener[] newTabListeners = new CTabFolderListener[tabListeners.length - 1];\n    System.arraycopy(tabListeners, 0, newTabListeners, 0, index);\n    System.arraycopy(tabListeners, index + 1, newTabListeners, index, tabListeners.length - index - 1);\n    tabListeners = newTabListeners;\n}",
			"comments":"/**\n* Removes the listener.\n*\n* @param listener the listener\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*    <li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n* </ul>\n*\n* @deprecated see removeCTabFolderCloseListener(CTabFolderListener)\n*/\n",
			"methodName":"public void removeCTabFolderListener(CTabFolderListener listener)"
		},
		"void setBackground(Image image)":{
			"methodBody":"{\n    checkWidget();\n    if (image == bgImage)\n        return;\n    if (image != null) {\n        gradientColors = null;\n        gradientPercents = null;\n    }\n    bgImage = image;\n    redraw();\n}",
			"comments":"/**\n* Set the image to be drawn in the background of the unselected tab.  Image\n* is stretched or compressed to cover entire unselected tab area.\n*\n* @param image the image to be drawn in the background\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"void setBackground(Image image)"
		},
		"public CTabItem getItem(int index)":{
			"methodBody":"{\n    \n    if (index < 0 || index >= items.length)\n        SWT.error(SWT.ERROR_INVALID_RANGE);\n    return items[index];\n}",
			"comments":"/**\n* Return the tab that is located at the specified index.\n*\n* @param index the index of the tab item\n* @return the item at the specified index\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_RANGE - if the index is out of range</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*    <li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n* </ul>\n*/\n//checkWidget();\n",
			"methodName":"public CTabItem getItem(int index)"
		},
		"void drawChevron(GC gc)":{
			"methodBody":"{\n    if (chevronRect.width == 0 || chevronRect.height == 0)\n        return;\n    \n    Display display = getDisplay();\n    Point dpi = display.getDPI();\n    int fontHeight = 72 * 10 / dpi.y;\n    FontData fd = getFont().getFontData()[0];\n    fd.setHeight(fontHeight);\n    Font f = new Font(display, fd);\n    int fHeight = f.getFontData()[0].getHeight() * display.getDPI().y / 72;\n    int indent = Math.max(2, (chevronRect.height - fHeight - 4) / 2);\n    int x = chevronRect.x + 2;\n    int y = chevronRect.y + indent;\n    int count;\n    if (single) {\n        count = selectedIndex == -1 ? items.length : items.length - 1;\n    } else {\n        int showCount = 0;\n        while (showCount < priority.length && items[priority[showCount]].showing) {\n            showCount++;\n        }\n        count = items.length - showCount;\n    }\n    \n    String chevronString = count > 99 ? \"99+\" : String.valueOf(count);\n    switch(chevronImageState) {\n        case NORMAL:\n            {\n                Color chevronBorder = single ? getSelectionForeground() : getForeground();\n                gc.setForeground(chevronBorder);\n                gc.setFont(f);\n                gc.drawLine(x, y, x + 2, y + 2);\n                gc.drawLine(x + 2, y + 2, x, y + 4);\n                gc.drawLine(x + 1, y, x + 3, y + 2);\n                gc.drawLine(x + 3, y + 2, x + 1, y + 4);\n                gc.drawLine(x + 4, y, x + 6, y + 2);\n                gc.drawLine(x + 6, y + 2, x + 5, y + 4);\n                gc.drawLine(x + 5, y, x + 7, y + 2);\n                gc.drawLine(x + 7, y + 2, x + 4, y + 4);\n                gc.drawString(chevronString, x + 7, y + 3, true);\n                break;\n            }\n        case HOT:\n            {\n                gc.setForeground(display.getSystemColor(BUTTON_BORDER));\n                gc.setBackground(display.getSystemColor(BUTTON_FILL));\n                gc.setFont(f);\n                gc.fillRoundRectangle(chevronRect.x, chevronRect.y, chevronRect.width, chevronRect.height, 6, 6);\n                gc.drawRoundRectangle(chevronRect.x, chevronRect.y, chevronRect.width - 1, chevronRect.height - 1, 6, 6);\n                gc.drawLine(x, y, x + 2, y + 2);\n                gc.drawLine(x + 2, y + 2, x, y + 4);\n                gc.drawLine(x + 1, y, x + 3, y + 2);\n                gc.drawLine(x + 3, y + 2, x + 1, y + 4);\n                gc.drawLine(x + 4, y, x + 6, y + 2);\n                gc.drawLine(x + 6, y + 2, x + 5, y + 4);\n                gc.drawLine(x + 5, y, x + 7, y + 2);\n                gc.drawLine(x + 7, y + 2, x + 4, y + 4);\n                gc.drawString(chevronString, x + 7, y + 3, true);\n                break;\n            }\n        case SELECTED:\n            {\n                gc.setForeground(display.getSystemColor(BUTTON_BORDER));\n                gc.setBackground(display.getSystemColor(BUTTON_FILL));\n                gc.setFont(f);\n                gc.fillRoundRectangle(chevronRect.x, chevronRect.y, chevronRect.width, chevronRect.height, 6, 6);\n                gc.drawRoundRectangle(chevronRect.x, chevronRect.y, chevronRect.width - 1, chevronRect.height - 1, 6, 6);\n                gc.drawLine(x + 1, y + 1, x + 3, y + 3);\n                gc.drawLine(x + 3, y + 3, x + 1, y + 5);\n                gc.drawLine(x + 2, y + 1, x + 4, y + 3);\n                gc.drawLine(x + 4, y + 3, x + 2, y + 5);\n                gc.drawLine(x + 5, y + 1, x + 7, y + 3);\n                gc.drawLine(x + 7, y + 3, x + 6, y + 5);\n                gc.drawLine(x + 6, y + 1, x + 8, y + 3);\n                gc.drawLine(x + 8, y + 3, x + 5, y + 5);\n                gc.drawString(chevronString, x + 8, y + 4, true);\n                break;\n            }\n    }\n    f.dispose();\n}",
			"comments":"// draw chevron (10x7)\n//$NON-NLS-1$\n",
			"methodName":"void drawChevron(GC gc)"
		},
		"public void widgetSelected(SelectionEvent e)":{
			"methodBody":"{\n    MenuItem menuItem = (MenuItem) e.widget;\n    int index = indexOf((CTabItem) menuItem.getData(id));\n    CTabFolder.this.setSelection(index, true);\n}",
			"comments":"",
			"methodName":"public void widgetSelected(SelectionEvent e)"
		},
		"public Rectangle getClientArea()":{
			"methodBody":"{\n    checkWidget();\n    if (minimized)\n        return new Rectangle(xClient, yClient, 0, 0);\n    Point size = getSize();\n    int width = size.x - borderLeft - borderRight - 2 * marginWidth - 2 * highlight_margin;\n    int height = size.y - borderTop - borderBottom - 2 * marginHeight - highlight_margin - highlight_header;\n    height -= tabHeight;\n    return new Rectangle(xClient, yClient, width, height);\n}",
			"comments":"",
			"methodName":"public Rectangle getClientArea()"
		},
		"public Rectangle computeTrim(int x, int y, int width, int height)":{
			"methodBody":"{\n    checkWidget();\n    int trimX = x - marginWidth - highlight_margin - borderLeft;\n    int trimWidth = width + borderLeft + borderRight + 2 * marginWidth + 2 * highlight_margin;\n    if (minimized) {\n        int trimY = onBottom ? y - borderTop : y - highlight_header - tabHeight - borderTop;\n        int trimHeight = borderTop + borderBottom + tabHeight + highlight_header;\n        return new Rectangle(trimX, trimY, trimWidth, trimHeight);\n    } else {\n        int trimY = onBottom ? y - marginHeight - highlight_margin - borderTop : y - marginHeight - highlight_header - tabHeight - borderTop;\n        int trimHeight = height + borderTop + borderBottom + 2 * marginHeight + tabHeight + highlight_header + highlight_margin;\n        return new Rectangle(trimX, trimY, trimWidth, trimHeight);\n    }\n}",
			"comments":"",
			"methodName":"public Rectangle computeTrim(int x, int y, int width, int height)"
		},
		"void drawMinimize(GC gc)":{
			"methodBody":"{\n    if (minRect.width == 0 || minRect.height == 0)\n        return;\n    Display display = getDisplay();\n    \n    int x = minRect.x + (BUTTON_SIZE - 10) / 2;\n    int y = minRect.y + 3;\n    gc.setForeground(display.getSystemColor(BUTTON_BORDER));\n    gc.setBackground(display.getSystemColor(BUTTON_FILL));\n    switch(minImageState) {\n        case NORMAL:\n            {\n                if (!minimized) {\n                    gc.fillRectangle(x, y, 9, 3);\n                    gc.drawRectangle(x, y, 9, 3);\n                } else {\n                    gc.fillRectangle(x, y + 3, 5, 4);\n                    gc.fillRectangle(x + 2, y, 5, 4);\n                    gc.drawRectangle(x, y + 3, 5, 4);\n                    gc.drawRectangle(x + 2, y, 5, 4);\n                    gc.drawLine(x + 3, y + 1, x + 6, y + 1);\n                    gc.drawLine(x + 1, y + 4, x + 4, y + 4);\n                }\n                break;\n            }\n        case HOT:\n            {\n                gc.fillRoundRectangle(minRect.x, minRect.y, minRect.width, minRect.height, 6, 6);\n                gc.drawRoundRectangle(minRect.x, minRect.y, minRect.width - 1, minRect.height - 1, 6, 6);\n                if (!minimized) {\n                    gc.fillRectangle(x, y, 9, 3);\n                    gc.drawRectangle(x, y, 9, 3);\n                } else {\n                    gc.fillRectangle(x, y + 3, 5, 4);\n                    gc.fillRectangle(x + 2, y, 5, 4);\n                    gc.drawRectangle(x, y + 3, 5, 4);\n                    gc.drawRectangle(x + 2, y, 5, 4);\n                    gc.drawLine(x + 3, y + 1, x + 6, y + 1);\n                    gc.drawLine(x + 1, y + 4, x + 4, y + 4);\n                }\n                break;\n            }\n        case SELECTED:\n            {\n                gc.fillRoundRectangle(minRect.x, minRect.y, minRect.width, minRect.height, 6, 6);\n                gc.drawRoundRectangle(minRect.x, minRect.y, minRect.width - 1, minRect.height - 1, 6, 6);\n                if (!minimized) {\n                    gc.fillRectangle(x + 1, y + 1, 9, 3);\n                    gc.drawRectangle(x + 1, y + 1, 9, 3);\n                } else {\n                    gc.fillRectangle(x + 1, y + 4, 5, 4);\n                    gc.fillRectangle(x + 3, y + 1, 5, 4);\n                    gc.drawRectangle(x + 1, y + 4, 5, 4);\n                    gc.drawRectangle(x + 3, y + 1, 5, 4);\n                    gc.drawLine(x + 4, y + 2, x + 7, y + 2);\n                    gc.drawLine(x + 2, y + 5, x + 5, y + 5);\n                }\n                break;\n            }\n    }\n}",
			"comments":"// 5x4 or 9x3\n",
			"methodName":"void drawMinimize(GC gc)"
		},
		"public void setInsertMark(CTabItem item, boolean after)":{
			"methodBody":"{\n    checkWidget();\n}",
			"comments":"/**\n* Display an insert marker before or after the specified tab item.\n*\n* A value of null will clear the mark.\n*\n* @param item the item with which the mark is associated or null\n*\n* @param after true if the mark should be displayed after the specified item\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setInsertMark(CTabItem item, boolean after)"
		},
		"public void setLayout(Layout layout)":{
			"methodBody":"{\n    checkWidget();\n    return;\n}",
			"comments":"/**\n* Sets the layout which is associated with the receiver to be\n* the argument which may be null.\n* <p>\n* Note : No Layout can be set on this Control because it already\n* manages the size and position of its children.\n* </p>\n*\n* @param layout the receiver's new layout or null\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setLayout(Layout layout)"
		},
		"void setBackground(Color[] colors, int[] percents)":{
			"methodBody":"{\n    setBackground(colors, percents, false);\n}",
			"comments":"/**\n* Specify a gradient of colours to be drawn in the background of the unselected tabs.\n* For example to draw a gradient that varies from dark blue to blue and then to\n* white, use the following call to setBackground:\n* <pre>\n*\tcfolder.setBackground(new Color[]{display.getSystemColor(SWT.COLOR_DARK_BLUE),\n*\t\t                           display.getSystemColor(SWT.COLOR_BLUE),\n*\t\t                           display.getSystemColor(SWT.COLOR_WHITE),\n*\t\t                           display.getSystemColor(SWT.COLOR_WHITE)},\n*\t\t               new int[] {25, 50, 100});\n* </pre>\n*\n* @param colors an array of Color that specifies the colors to appear in the gradient\n*               in order of appearance left to right.  The value <code>null</code> clears the\n*               background gradient. The value <code>null</code> can be used inside the array of\n*               Color to specify the background color.\n* @param percents an array of integers between 0 and 100 specifying the percent of the width\n*                 of the widget at which the color should change.  The size of the percents array must be one\n*                 less than the size of the colors array.\n*\n* @exception SWTException <ul>\n*\t\t<li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*\t\t<li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n*\t</ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"void setBackground(Color[] colors, int[] percents)"
		},
		"public void getState(AccessibleControlEvent e)":{
			"methodBody":"{\n    int state = 0;\n    int childID = e.childID;\n    if (childID == ACC.CHILDID_SELF) {\n        state = ACC.STATE_NORMAL;\n    } else if (childID >= 0 && childID < items.length) {\n        state = ACC.STATE_SELECTABLE;\n        if (isFocusControl()) {\n            state |= ACC.STATE_FOCUSABLE;\n        }\n        if (selectedIndex == childID) {\n            state |= ACC.STATE_SELECTED;\n            if (isFocusControl()) {\n                state |= ACC.STATE_FOCUSED;\n            }\n        }\n    }\n    e.detail = state;\n}",
			"comments":"",
			"methodName":"public void getState(AccessibleControlEvent e)"
		},
		"public void setMinimized(boolean minimize)":{
			"methodBody":"{\n    checkWidget();\n    if (this.minimized == minimize)\n        return;\n    if (minimize && this.maximized)\n        setMaximized(false);\n    this.minimized = minimize;\n    redraw(minRect.x, minRect.y, minRect.width, minRect.height, false);\n}",
			"comments":"/**\n* Sets the minimized state of the receiver.\n*\n* @param minimize the new minimized state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public void setMinimized(boolean minimize)"
		},
		"void drawBackground(GC gc, int[] shape, boolean selected)":{
			"methodBody":"{\n    Color defaultBackground = selected ? selectionBackground : getBackground();\n    Image image = selected ? selectionBgImage : bgImage;\n    Color[] colors = selected ? selectionGradientColors : gradientColors;\n    int[] percents = selected ? selectionGradientPercents : gradientPercents;\n    boolean vertical = selected ? selectionGradientVertical : gradientVertical;\n    Point size = getSize();\n    int width = size.x;\n    int height = tabHeight + highlight_header;\n    int x = 0;\n    if (borderLeft > 0) {\n        x += 1;\n        width -= 2;\n    }\n    int y = onBottom ? size.y - borderBottom - height : borderTop;\n    drawBackground(gc, shape, x, y, width, height, defaultBackground, image, colors, percents, vertical);\n}",
			"comments":"",
			"methodName":"void drawBackground(GC gc, int[] shape, boolean selected)"
		},
		"void onMouse(Event event)":{
			"methodBody":"{\n    int x = event.x, y = event.y;\n    switch(event.type) {\n        case SWT.MouseExit:\n            {\n                if (minImageState != NORMAL) {\n                    minImageState = NORMAL;\n                    redraw(minRect.x, minRect.y, minRect.width, minRect.height, false);\n                }\n                if (maxImageState != NORMAL) {\n                    maxImageState = NORMAL;\n                    redraw(maxRect.x, maxRect.y, maxRect.width, maxRect.height, false);\n                }\n                if (chevronImageState != NORMAL) {\n                    chevronImageState = NORMAL;\n                    redraw(chevronRect.x, chevronRect.y, chevronRect.width, chevronRect.height, false);\n                }\n                for (int i = 0; i < items.length; i++) {\n                    CTabItem item = items[i];\n                    if (i != selectedIndex && item.closeImageState != NONE) {\n                        item.closeImageState = NONE;\n                        redraw(item.closeRect.x, item.closeRect.y, item.closeRect.width, item.closeRect.height, false);\n                    }\n                    if (i == selectedIndex && item.closeImageState != NORMAL) {\n                        item.closeImageState = NORMAL;\n                        redraw(item.closeRect.x, item.closeRect.y, item.closeRect.width, item.closeRect.height, false);\n                    }\n                }\n                break;\n            }\n        case SWT.MouseDown:\n            {\n                if (minRect.contains(x, y)) {\n                    if (event.button != 1)\n                        return;\n                    minImageState = SELECTED;\n                    redraw(minRect.x, minRect.y, minRect.width, minRect.height, false);\n                    update();\n                    return;\n                }\n                if (maxRect.contains(x, y)) {\n                    if (event.button != 1)\n                        return;\n                    maxImageState = SELECTED;\n                    redraw(maxRect.x, maxRect.y, maxRect.width, maxRect.height, false);\n                    update();\n                    return;\n                }\n                if (chevronRect.contains(x, y)) {\n                    if (event.button != 1)\n                        return;\n                    if (chevronImageState != HOT) {\n                        chevronImageState = HOT;\n                    } else {\n                        chevronImageState = SELECTED;\n                    }\n                    redraw(chevronRect.x, chevronRect.y, chevronRect.width, chevronRect.height, false);\n                    update();\n                    return;\n                }\n                CTabItem item = null;\n                if (single) {\n                    if (selectedIndex != -1) {\n                        Rectangle bounds = items[selectedIndex].getBounds();\n                        if (bounds.contains(x, y)) {\n                            item = items[selectedIndex];\n                        }\n                    }\n                } else {\n                    for (int i = 0; i < items.length; i++) {\n                        Rectangle bounds = items[i].getBounds();\n                        if (bounds.contains(x, y)) {\n                            item = items[i];\n                        }\n                    }\n                }\n                if (item != null) {\n                    if (item.closeRect.contains(x, y)) {\n                        if (event.button != 1)\n                            return;\n                        item.closeImageState = SELECTED;\n                        redraw(item.closeRect.x, item.closeRect.y, item.closeRect.width, item.closeRect.height, false);\n                        update();\n                        return;\n                    }\n                    int index = indexOf(item);\n                    if (item.showing) {\n                        setSelection(index, true);\n                    }\n                    return;\n                }\n                break;\n            }\n        case SWT.MouseMove:\n            {\n                boolean close = false, minimize = false, maximize = false, chevron = false;\n                if (minRect.contains(x, y)) {\n                    minimize = true;\n                    if (minImageState != SELECTED && minImageState != HOT) {\n                        minImageState = HOT;\n                        redraw(minRect.x, minRect.y, minRect.width, minRect.height, false);\n                    }\n                }\n                if (maxRect.contains(x, y)) {\n                    maximize = true;\n                    if (maxImageState != SELECTED && maxImageState != HOT) {\n                        maxImageState = HOT;\n                        redraw(maxRect.x, maxRect.y, maxRect.width, maxRect.height, false);\n                    }\n                }\n                if (chevronRect.contains(x, y)) {\n                    chevron = true;\n                    if (chevronImageState != SELECTED && chevronImageState != HOT) {\n                        chevronImageState = HOT;\n                        redraw(chevronRect.x, chevronRect.y, chevronRect.width, chevronRect.height, false);\n                    }\n                }\n                if (minImageState != NORMAL && !minimize) {\n                    minImageState = NORMAL;\n                    redraw(minRect.x, minRect.y, minRect.width, minRect.height, false);\n                }\n                if (maxImageState != NORMAL && !maximize) {\n                    maxImageState = NORMAL;\n                    redraw(maxRect.x, maxRect.y, maxRect.width, maxRect.height, false);\n                }\n                if (chevronImageState != NORMAL && !chevron) {\n                    chevronImageState = NORMAL;\n                    redraw(chevronRect.x, chevronRect.y, chevronRect.width, chevronRect.height, false);\n                }\n                for (int i = 0; i < items.length; i++) {\n                    CTabItem item = items[i];\n                    close = false;\n                    if (item.getBounds().contains(x, y)) {\n                        close = true;\n                        if (item.closeRect.contains(x, y)) {\n                            if (item.closeImageState != SELECTED && item.closeImageState != HOT) {\n                                item.closeImageState = HOT;\n                                redraw(item.closeRect.x, item.closeRect.y, item.closeRect.width, item.closeRect.height, false);\n                            }\n                        } else {\n                            if (item.closeImageState != NORMAL) {\n                                item.closeImageState = NORMAL;\n                                redraw(item.closeRect.x, item.closeRect.y, item.closeRect.width, item.closeRect.height, false);\n                            }\n                        }\n                    }\n                    if (i != selectedIndex && item.closeImageState != NONE && !close) {\n                        item.closeImageState = NONE;\n                        redraw(item.closeRect.x, item.closeRect.y, item.closeRect.width, item.closeRect.height, false);\n                    }\n                    if (i == selectedIndex && item.closeImageState != NORMAL && !close) {\n                        item.closeImageState = NORMAL;\n                        redraw(item.closeRect.x, item.closeRect.y, item.closeRect.width, item.closeRect.height, false);\n                    }\n                }\n                break;\n            }\n        case SWT.MouseUp:\n            {\n                if (event.button != 1)\n                    return;\n                if (chevronRect.contains(x, y)) {\n                    boolean selected = chevronImageState == SELECTED;\n                    if (!selected)\n                        return;\n                    CTabFolderEvent e = new CTabFolderEvent(this);\n                    e.widget = this;\n                    e.time = event.time;\n                    e.x = chevronRect.x;\n                    e.y = chevronRect.y;\n                    e.width = chevronRect.width;\n                    e.height = chevronRect.height;\n                    e.doit = true;\n                    for (int i = 0; i < folderListeners.length; i++) {\n                        folderListeners[i].showList(e);\n                    }\n                    if (e.doit && !isDisposed()) {\n                        showList(chevronRect);\n                    }\n                    return;\n                }\n                if (minRect.contains(x, y)) {\n                    boolean selected = minImageState == SELECTED;\n                    minImageState = HOT;\n                    redraw(minRect.x, minRect.y, minRect.width, minRect.height, false);\n                    if (!selected)\n                        return;\n                    CTabFolderEvent e = new CTabFolderEvent(this);\n                    e.widget = this;\n                    e.time = event.time;\n                    for (int i = 0; i < folderListeners.length; i++) {\n                        if (minimized) {\n                            folderListeners[i].restore(e);\n                        } else {\n                            folderListeners[i].minimize(e);\n                        }\n                    }\n                    return;\n                }\n                if (maxRect.contains(x, y)) {\n                    boolean selected = maxImageState == SELECTED;\n                    maxImageState = HOT;\n                    redraw(maxRect.x, maxRect.y, maxRect.width, maxRect.height, false);\n                    if (!selected)\n                        return;\n                    CTabFolderEvent e = new CTabFolderEvent(this);\n                    e.widget = this;\n                    e.time = event.time;\n                    for (int i = 0; i < folderListeners.length; i++) {\n                        if (maximized) {\n                            folderListeners[i].restore(e);\n                        } else {\n                            folderListeners[i].maximize(e);\n                        }\n                    }\n                    return;\n                }\n                CTabItem item = null;\n                if (single) {\n                    if (selectedIndex != -1) {\n                        Rectangle bounds = items[selectedIndex].getBounds();\n                        if (bounds.contains(x, y)) {\n                            item = items[selectedIndex];\n                        }\n                    }\n                } else {\n                    for (int i = 0; i < items.length; i++) {\n                        Rectangle bounds = items[i].getBounds();\n                        if (bounds.contains(x, y)) {\n                            item = items[i];\n                        }\n                    }\n                }\n                if (item != null) {\n                    if (item.closeRect.contains(x, y)) {\n                        boolean selected = item.closeImageState == SELECTED;\n                        item.closeImageState = HOT;\n                        redraw(item.closeRect.x, item.closeRect.y, item.closeRect.width, item.closeRect.height, false);\n                        if (!selected)\n                            return;\n                        CTabFolderEvent e = new CTabFolderEvent(this);\n                        e.widget = this;\n                        e.time = event.time;\n                        e.item = item;\n                        e.doit = true;\n                        for (int j = 0; j < folderListeners.length; j++) {\n                            CTabFolder2Listener listener = folderListeners[j];\n                            listener.close(e);\n                        }\n                        for (int j = 0; j < tabListeners.length; j++) {\n                            CTabFolderListener listener = tabListeners[j];\n                            listener.itemClosed(e);\n                        }\n                        if (e.doit) {\n                            item.dispose();\n                            Display display = getDisplay();\n                            Point pt = display.getCursorLocation();\n                            pt = display.map(null, this, pt.x, pt.y);\n                            CTabItem nextItem = getItem(pt);\n                            if (nextItem != null) {\n                                if (nextItem.closeRect.contains(pt)) {\n                                    if (nextItem.closeImageState != SELECTED && nextItem.closeImageState != HOT) {\n                                        nextItem.closeImageState = HOT;\n                                        redraw(nextItem.closeRect.x, nextItem.closeRect.y, nextItem.closeRect.width, nextItem.closeRect.height, false);\n                                    }\n                                } else {\n                                    if (nextItem.closeImageState != NORMAL) {\n                                        nextItem.closeImageState = NORMAL;\n                                        redraw(nextItem.closeRect.x, nextItem.closeRect.y, nextItem.closeRect.width, nextItem.closeRect.height, false);\n                                    }\n                                }\n                            }\n                        }\n                        return;\n                    }\n                }\n            }\n    }\n}",
			"comments":"",
			"methodName":"void onMouse(Event event)"
		},
		"void onMouseDoubleClick(Event event)":{
			"methodBody":"{\n    if (event.button != 1 || (event.stateMask & SWT.BUTTON2) != 0 || (event.stateMask & SWT.BUTTON3) != 0)\n        return;\n    Event e = new Event();\n    e.item = getItem(new Point(event.x, event.y));\n    if (e.item != null) {\n        notifyListeners(SWT.DefaultSelection, e);\n    }\n}",
			"comments":"",
			"methodName":"void onMouseDoubleClick(Event event)"
		},
		"String _getToolTip(int x, int y)":{
			"methodBody":"{\n    \n    if (showMin && minRect.contains(x, y))\n        return minimized ? SWT.getMessage(\"SWT_Restore\") : SWT.getMessage(\"SWT_Minimize\");\n    \n    if (showMax && maxRect.contains(x, y))\n        return maximized ? SWT.getMessage(\"SWT_Restore\") : SWT.getMessage(\"SWT_Maximize\");\n    \n    if (showChevron && chevronRect.contains(x, y))\n        return SWT.getMessage(\"SWT_ShowList\");\n    CTabItem item = getItem(new Point(x, y));\n    if (item == null)\n        return null;\n    if (!item.showing)\n        return null;\n    if ((showClose || item.showClose) && item.closeRect.contains(x, y)) {\n        \n        return SWT.getMessage(\"SWT_Close\");\n    }\n    return item.getToolTipText();\n}",
			"comments":"//$NON-NLS-1$ //$NON-NLS-2$\n//$NON-NLS-1$ //$NON-NLS-2$\n//$NON-NLS-1$\n//$NON-NLS-1$\n",
			"methodName":"String _getToolTip(int x, int y)"
		},
		"public void setInsertMark(int index, boolean after)":{
			"methodBody":"{\n    checkWidget();\n    if (index < -1 || index >= getItemCount()) {\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    }\n}",
			"comments":"/**\n* Display an insert marker before or after the specified tab item.\n*\n* A value of -1 will clear the mark.\n*\n* @param index the index of the item with which the mark is associated or null\n*\n* @param after true if the mark should be displayed after the specified item\n*\n* @exception IllegalArgumentException<ul>\n* </ul>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setInsertMark(int index, boolean after)"
		},
		"void onDispose()":{
			"methodBody":"{\n    \n    inDispose = true;\n    hideToolTip();\n    if (showMenu != null && !showMenu.isDisposed()) {\n        showMenu.dispose();\n        showMenu = null;\n    }\n    int length = items.length;\n    for (int i = 0; i < length; i++) {\n        if (items[i] != null) {\n            items[i].dispose();\n        }\n    }\n    selectionGradientColors = null;\n    selectionGradientPercents = null;\n    selectionBgImage = null;\n    selectionBackground = null;\n    selectionForeground = null;\n}",
			"comments":"/*\n* Usually when an item is disposed, destroyItem will change the size of the items array,\n* reset the bounds of all the tabs and manage the widget associated with the tab.\n* Since the whole folder is being disposed, this is not necessary.  For speed\n* the inDispose flag is used to skip over this part of the item dispose.\n*/\n",
			"methodName":"void onDispose()"
		},
		"public void setUnselectedImageVisible(boolean visible)":{
			"methodBody":"{\n    checkWidget();\n    if (showUnselectedImage == visible)\n        return;\n    \n    showUnselectedImage = visible;\n    updateItems();\n    redraw();\n}",
			"comments":"/**\n* Specify whether the image appears on unselected tabs.\n*\n* @param visible <code>true</code> makes the image appear\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.0\n*/\n// display image on unselected items\n",
			"methodName":"public void setUnselectedImageVisible(boolean visible)"
		},
		"public void setSingle(boolean single)":{
			"methodBody":"{\n    checkWidget();\n    if (this.single != single) {\n        this.single = single;\n        if (!single) {\n            for (int i = 0; i < items.length; i++) {\n                if (i != selectedIndex && items[i].closeImageState == NORMAL) {\n                    items[i].closeImageState = NONE;\n                }\n            }\n        }\n        Rectangle rectBefore = getClientArea();\n        updateItems();\n        Rectangle rectAfter = getClientArea();\n        if (!rectBefore.equals(rectAfter)) {\n            notifyListeners(SWT.Resize, new Event());\n        }\n        redraw();\n    }\n}",
			"comments":"/**\n* Sets the number of tabs that the CTabFolder should display\n*\n* @param single <code>true</code> if only the selected tab should be displayed otherwise, multiple tabs will be shown.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public void setSingle(boolean single)"
		},
		"public CTabItem[] getItems()":{
			"methodBody":"{\n    \n    CTabItem[] tabItems = new CTabItem[items.length];\n    System.arraycopy(items, 0, tabItems, 0, items.length);\n    return tabItems;\n}",
			"comments":"/**\n* Return the tab items.\n*\n* @return the tab items\n*\n* @exception SWTException <ul>\n*\t\t<li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*\t\t<li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n*\t</ul>\n*/\n//checkWidget();\n",
			"methodName":"public CTabItem[] getItems()"
		},
		"public boolean getMRUVisible()":{
			"methodBody":"{\n    checkWidget();\n    return mru;\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver displays most\n* recently used tabs and <code>false</code> otherwise.\n* <p>\n* When there is not enough horizontal space to show all the tabs,\n* by default, tabs are shown sequentially from left to right in\n* order of their index.  When the MRU visibility is turned on,\n* the tabs that are visible will be the tabs most recently selected.\n* Tabs will still maintain their left to right order based on index\n* but only the most recently selected tabs are visible.\n* <p>\n* For example, consider a CTabFolder that contains \"Tab 1\", \"Tab 2\",\n* \"Tab 3\" and \"Tab 4\" (in order by index).  The user selects\n* \"Tab 1\" and then \"Tab 3\".  If the CTabFolder is now\n* compressed so that only two tabs are visible, by default,\n* \"Tab 2\" and \"Tab 3\" will be shown (\"Tab 3\" since it is currently\n* selected and \"Tab 2\" because it is the previous item in index order).\n* If MRU visibility is enabled, the two visible tabs will be \"Tab 1\"\n* and \"Tab 3\" (in that order from left to right).</p>\n*\n* @return the receiver's header's visibility state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public boolean getMRUVisible()"
		},
		"boolean updateTabHeight(boolean force)":{
			"methodBody":"{\n    int oldHeight = tabHeight;\n    if (fixedTabHeight != SWT.DEFAULT) {\n        \n        tabHeight = fixedTabHeight == 0 ? 0 : fixedTabHeight + 1;\n    } else {\n        int tempHeight = 0;\n        GC gc = new GC(this);\n        if (items.length == 0) {\n            \n            tempHeight = gc.textExtent(\"Default\", CTabItem.FLAGS).y + CTabItem.TOP_MARGIN + CTabItem.BOTTOM_MARGIN;\n        } else {\n            for (int i = 0; i < items.length; i++) {\n                tempHeight = Math.max(tempHeight, items[i].preferredHeight(gc));\n            }\n        }\n        gc.dispose();\n        tabHeight = tempHeight;\n    }\n    if (!force && tabHeight == oldHeight)\n        return false;\n    oldSize = null;\n    if (onBottom) {\n        int d = tabHeight - 12;\n        curve = new int[] { 0, 13 + d, 0, 12 + d, 2, 12 + d, 3, 11 + d, 5, 11 + d, 6, 10 + d, 7, 10 + d, 9, 8 + d, 10, 8 + d, 11, 7 + d, 11 + d, 7, 12 + d, 6, 13 + d, 6, 15 + d, 4, 16 + d, 4, 17 + d, 3, 19 + d, 3, 20 + d, 2, 22 + d, 2, 23 + d, 1 };\n        curveWidth = 26 + d;\n        curveIndent = curveWidth / 3;\n    } else {\n        int d = tabHeight - 12;\n        curve = new int[] { 0, 0, 0, 1, 2, 1, 3, 2, 5, 2, 6, 3, 7, 3, 9, 5, 10, 5, 11, 6, 11 + d, 6 + d, 12 + d, 7 + d, 13 + d, 7 + d, 15 + d, 9 + d, 16 + d, 9 + d, 17 + d, 10 + d, 19 + d, 10 + d, 20 + d, 11 + d, 22 + d, 11 + d, 23 + d, 12 + d };\n        curveWidth = 26 + d;\n        curveIndent = curveWidth / 3;\n    }\n    notifyListeners(SWT.Resize, new Event());\n    return true;\n}",
			"comments":"// +1 for line drawn across top of tab\n//$NON-NLS-1$\n",
			"methodName":"boolean updateTabHeight(boolean force)"
		},
		"public boolean getMinimizeVisible()":{
			"methodBody":"{\n    checkWidget();\n    return showMin;\n}",
			"comments":"/**\n* Returns <code>true</code> if the minimize button\n* is visible.\n*\n* @return the visibility of the minimized button\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public boolean getMinimizeVisible()"
		},
		"public void setSelectionBackground(Color[] colors, int[] percents)":{
			"methodBody":"{\n    setSelectionBackground(colors, percents, false);\n}",
			"comments":"/**\n* Specify a gradient of colours to be draw in the background of the selected tab.\n* For example to draw a gradient that varies from dark blue to blue and then to\n* white, use the following call to setBackground:\n* <pre>\n*\tcfolder.setBackground(new Color[]{display.getSystemColor(SWT.COLOR_DARK_BLUE),\n*\t\t                           display.getSystemColor(SWT.COLOR_BLUE),\n*\t\t                           display.getSystemColor(SWT.COLOR_WHITE),\n*\t\t                           display.getSystemColor(SWT.COLOR_WHITE)},\n*\t\t               new int[] {25, 50, 100});\n* </pre>\n*\n* @param colors an array of Color that specifies the colors to appear in the gradient\n*               in order of appearance left to right.  The value <code>null</code> clears the\n*               background gradient. The value <code>null</code> can be used inside the array of\n*               Color to specify the background color.\n* @param percents an array of integers between 0 and 100 specifying the percent of the width\n*                 of the widget at which the color should change.  The size of the percents array must be one\n*                 less than the size of the colors array.\n*\n* @exception SWTException <ul>\n*\t\t<li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*\t\t<li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n*\t</ul>\n*/\n",
			"methodName":"public void setSelectionBackground(Color[] colors, int[] percents)"
		},
		"void setBackground(Color[] colors, int[] percents, boolean vertical)":{
			"methodBody":"{\n    checkWidget();\n    if (colors != null) {\n        if (percents == null || percents.length != colors.length - 1) {\n            SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n        }\n        for (int i = 0; i < percents.length; i++) {\n            if (percents[i] < 0 || percents[i] > 100) {\n                SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n            }\n            if (i > 0 && percents[i] < percents[i - 1]) {\n                SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n            }\n        }\n        if (getDisplay().getDepth() < 15) {\n            \n            colors = new Color[] { colors[colors.length - 1] };\n            percents = new int[] {};\n        }\n    }\n    \n    if (bgImage == null) {\n        if ((gradientColors != null) && (colors != null) && (gradientColors.length == colors.length)) {\n            boolean same = false;\n            for (int i = 0; i < gradientColors.length; i++) {\n                if (gradientColors[i] == null) {\n                    same = colors[i] == null;\n                } else {\n                    same = gradientColors[i].equals(colors[i]);\n                }\n                if (!same)\n                    break;\n            }\n            if (same) {\n                for (int i = 0; i < gradientPercents.length; i++) {\n                    same = gradientPercents[i] == percents[i];\n                    if (!same)\n                        break;\n                }\n            }\n            if (same && this.gradientVertical == vertical)\n                return;\n        }\n    } else {\n        bgImage = null;\n    }\n    \n    if (colors == null) {\n        gradientColors = null;\n        gradientPercents = null;\n        gradientVertical = false;\n        setBackground((Color) null);\n    } else {\n        gradientColors = new Color[colors.length];\n        for (int i = 0; i < colors.length; ++i) {\n            gradientColors[i] = colors[i];\n        }\n        gradientPercents = new int[percents.length];\n        for (int i = 0; i < percents.length; ++i) {\n            gradientPercents[i] = percents[i];\n        }\n        gradientVertical = vertical;\n        setBackground(gradientColors[gradientColors.length - 1]);\n    }\n    \n    redraw();\n}",
			"comments":"/**\n* Specify a gradient of colours to be drawn in the background of the unselected tab.\n* For example to draw a vertical gradient that varies from dark blue to blue and then to\n* white, use the following call to setBackground:\n* <pre>\n*\tcfolder.setBackground(new Color[]{display.getSystemColor(SWT.COLOR_DARK_BLUE),\n*\t\t                           display.getSystemColor(SWT.COLOR_BLUE),\n*\t\t                           display.getSystemColor(SWT.COLOR_WHITE),\n*\t\t                           display.getSystemColor(SWT.COLOR_WHITE)},\n*\t\t                  new int[] {25, 50, 100}, true);\n* </pre>\n*\n* @param colors an array of Color that specifies the colors to appear in the gradient\n*               in order of appearance left to right.  The value <code>null</code> clears the\n*               background gradient. The value <code>null</code> can be used inside the array of\n*               Color to specify the background color.\n* @param percents an array of integers between 0 and 100 specifying the percent of the width\n*                 of the widget at which the color should change.  The size of the percents array must be one\n*                 less than the size of the colors array.\n*\n* @param vertical indicate the direction of the gradient.  True is vertical and false is horizontal.\n*\n* @exception SWTException <ul>\n*\t\t<li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*\t\t<li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n*\t</ul>\n*\n* @since 3.0\n*/\n// Don't use gradients on low color displays\n// Are these settings the same as before?\n// Store the new settings\n// Refresh with the new settings\n",
			"methodName":"void setBackground(Color[] colors, int[] percents, boolean vertical)"
		},
		"public void getChildAtPoint(AccessibleControlEvent e)":{
			"methodBody":"{\n    Point testPoint = toControl(e.x, e.y);\n    int childID = ACC.CHILDID_NONE;\n    for (int i = 0; i < items.length; i++) {\n        if (items[i].getBounds().contains(testPoint)) {\n            childID = i;\n            break;\n        }\n    }\n    if (childID == ACC.CHILDID_NONE) {\n        Rectangle location = getBounds();\n        location.height = location.height - getClientArea().height;\n        if (location.contains(testPoint)) {\n            childID = ACC.CHILDID_SELF;\n        }\n    }\n    e.childID = childID;\n}",
			"comments":"",
			"methodName":"public void getChildAtPoint(AccessibleControlEvent e)"
		},
		"void antialias(int[] shape, RGB lineRGB, RGB innerRGB, RGB outerRGB, GC gc)":{
			"methodBody":"{\n    \n    if (simple || \"carbon\".equals(SWT.getPlatform()))\n        return;\n    \n    if (getDisplay().getDepth() < 15)\n        return;\n    if (outerRGB != null) {\n        int index = 0;\n        boolean left = true;\n        int oldY = onBottom ? 0 : getSize().y;\n        int[] outer = new int[shape.length];\n        for (int i = 0; i < shape.length / 2; i++) {\n            if (left && (index + 3 < shape.length)) {\n                left = onBottom ? oldY <= shape[index + 3] : oldY >= shape[index + 3];\n                oldY = shape[index + 1];\n            }\n            outer[index] = shape[index++] + (left ? -1 : +1);\n            outer[index] = shape[index++];\n        }\n        RGB from = lineRGB;\n        RGB to = outerRGB;\n        int red = from.red + 2 * (to.red - from.red) / 3;\n        int green = from.green + 2 * (to.green - from.green) / 3;\n        int blue = from.blue + 2 * (to.blue - from.blue) / 3;\n        Color color = new Color(getDisplay(), red, green, blue);\n        gc.setForeground(color);\n        gc.drawPolyline(outer);\n        color.dispose();\n    }\n    if (innerRGB != null) {\n        int[] inner = new int[shape.length];\n        int index = 0;\n        boolean left = true;\n        int oldY = onBottom ? 0 : getSize().y;\n        for (int i = 0; i < shape.length / 2; i++) {\n            if (left && (index + 3 < shape.length)) {\n                left = onBottom ? oldY <= shape[index + 3] : oldY >= shape[index + 3];\n                oldY = shape[index + 1];\n            }\n            inner[index] = shape[index++] + (left ? +1 : -1);\n            inner[index] = shape[index++];\n        }\n        RGB from = lineRGB;\n        RGB to = innerRGB;\n        int red = from.red + 2 * (to.red - from.red) / 3;\n        int green = from.green + 2 * (to.green - from.green) / 3;\n        int blue = from.blue + 2 * (to.blue - from.blue) / 3;\n        Color color = new Color(getDisplay(), red, green, blue);\n        gc.setForeground(color);\n        gc.drawPolyline(inner);\n        color.dispose();\n    }\n}",
			"comments":"// Don't perform anti-aliasing on Mac because the platform\n// already does it.  The simple style also does not require anti-aliasing.\n//$NON-NLS-1$\n// Don't perform anti-aliasing on low resolution displays\n",
			"methodName":"void antialias(int[] shape, RGB lineRGB, RGB innerRGB, RGB outerRGB, GC gc)"
		},
		"boolean onPageTraversal(Event event)":{
			"methodBody":"{\n    int count = items.length;\n    if (count == 0)\n        return false;\n    int index = selectedIndex;\n    if (index == -1) {\n        index = 0;\n    } else {\n        int offset = (event.detail == SWT.TRAVERSE_PAGE_NEXT) ? 1 : -1;\n        if (!mru) {\n            index = (selectedIndex + offset + count) % count;\n        } else {\n            int[] visible = new int[items.length];\n            int idx = 0;\n            int current = -1;\n            for (int i = 0; i < items.length; i++) {\n                if (items[i].showing) {\n                    if (i == selectedIndex)\n                        current = idx;\n                    visible[idx++] = i;\n                }\n            }\n            if (current + offset >= 0 && current + offset < idx) {\n                index = visible[current + offset];\n            } else {\n                if (showChevron) {\n                    CTabFolderEvent e = new CTabFolderEvent(this);\n                    e.widget = this;\n                    e.time = event.time;\n                    e.x = chevronRect.x;\n                    e.y = chevronRect.y;\n                    e.width = chevronRect.width;\n                    e.height = chevronRect.height;\n                    e.doit = true;\n                    for (int i = 0; i < folderListeners.length; i++) {\n                        folderListeners[i].showList(e);\n                    }\n                    if (e.doit && !isDisposed()) {\n                        showList(chevronRect);\n                    }\n                }\n                return true;\n            }\n        }\n    }\n    setSelection(index, true);\n    return true;\n}",
			"comments":"",
			"methodName":"boolean onPageTraversal(Event event)"
		},
		"public boolean getMaximized()":{
			"methodBody":"{\n    checkWidget();\n    return maximized;\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver is maximized.\n* <p>\n*\n* @return the receiver's maximized state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public boolean getMaximized()"
		},
		"public void getHelp(AccessibleEvent e)":{
			"methodBody":"{\n    String help = null;\n    int childID = e.childID;\n    if (childID == ACC.CHILDID_SELF) {\n        help = getToolTipText();\n    } else if (childID >= 0 && childID < items.length) {\n        help = items[childID].getToolTipText();\n    }\n    e.result = help;\n}",
			"comments":"",
			"methodName":"public void getHelp(AccessibleEvent e)"
		},
		"public void showItem(CTabItem item)":{
			"methodBody":"{\n    checkWidget();\n    if (item == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (item.isDisposed())\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    int index = indexOf(item);\n    if (index == -1)\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    int idx = -1;\n    for (int i = 0; i < priority.length; i++) {\n        if (priority[i] == index) {\n            idx = i;\n            break;\n        }\n    }\n    if (mru) {\n        \n        int[] newPriority = new int[priority.length];\n        System.arraycopy(priority, 0, newPriority, 1, idx);\n        System.arraycopy(priority, idx + 1, newPriority, idx + 1, priority.length - idx - 1);\n        newPriority[0] = index;\n        priority = newPriority;\n    }\n    if (item.isShowing())\n        return;\n    updateItems(index);\n    redrawTabs();\n}",
			"comments":"/**\n* Shows the item.  If the item is already showing in the receiver,\n* this method simply returns.  Otherwise, the items are scrolled until\n* the item is visible.\n*\n* @param item the item to be shown\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the item is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the item has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see CTabFolder#showSelection()\n*\n* @since 2.0\n*/\n// move to front of mru order\n",
			"methodName":"public void showItem(CTabItem item)"
		},
		"public void setForeground(Color color)":{
			"methodBody":"{\n    super.setForeground(color);\n    redraw();\n}",
			"comments":"",
			"methodName":"public void setForeground(Color color)"
		},
		"void onPaint(Event event)":{
			"methodBody":"{\n    Font font = getFont();\n    if (oldFont == null || !oldFont.equals(font)) {\n        \n        oldFont = font;\n        if (!updateTabHeight(false)) {\n            updateItems();\n            redraw();\n            return;\n        }\n    }\n    GC gc = event.gc;\n    Font gcFont = gc.getFont();\n    Color gcBackground = gc.getBackground();\n    Color gcForeground = gc.getForeground();\n    \n    \n    \n    \n    \n    \n    drawBody(event);\n    gc.setFont(gcFont);\n    gc.setForeground(gcForeground);\n    gc.setBackground(gcBackground);\n    drawTabArea(event);\n    gc.setFont(gcFont);\n    gc.setForeground(gcForeground);\n    gc.setBackground(gcBackground);\n}",
			"comments":"// handle case where  default font changes\n// Useful for debugging paint problems\n//{\n//Point size = getSize();\n//gc.setBackground(getDisplay().getSystemColor(SWT.COLOR_GREEN));\n//gc.fillRectangle(-10, -10, size.x + 20, size.y+20);\n//}\n",
			"methodName":"void onPaint(Event event)"
		},
		"public boolean getUnselectedImageVisible()":{
			"methodBody":"{\n    checkWidget();\n    return showUnselectedImage;\n}",
			"comments":"/**\n* Returns <code>true</code> if an image appears\n* in unselected tabs.\n*\n* @return <code>true</code> if an image appears in unselected tabs\n*\n* @since 3.0\n*/\n",
			"methodName":"public boolean getUnselectedImageVisible()"
		},
		"public void getRole(AccessibleControlEvent e)":{
			"methodBody":"{\n    int role = 0;\n    int childID = e.childID;\n    if (childID == ACC.CHILDID_SELF) {\n        role = ACC.ROLE_TABFOLDER;\n    } else if (childID >= 0 && childID < items.length) {\n        role = ACC.ROLE_TABITEM;\n    }\n    e.detail = role;\n}",
			"comments":"",
			"methodName":"public void getRole(AccessibleControlEvent e)"
		},
		"public void setSelectionBackground(Image image)":{
			"methodBody":"{\n    checkWidget();\n    if (image == selectionBgImage)\n        return;\n    if (image != null) {\n        selectionGradientColors = null;\n        selectionGradientPercents = null;\n    }\n    selectionBgImage = image;\n    if (selectedIndex > -1)\n        redraw();\n}",
			"comments":"/**\n* Set the image to be drawn in the background of the selected tab.  Image\n* is stretched or compressed to cover entire selection tab area.\n*\n* @param image the image to be drawn in the background\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setSelectionBackground(Image image)"
		},
		"void setButtonBounds()":{
			"methodBody":"{\n    Point size = getSize();\n    int oldX, oldY, oldWidth, oldHeight;\n    \n    oldX = maxRect.x;\n    oldY = maxRect.y;\n    oldWidth = maxRect.width;\n    oldHeight = maxRect.height;\n    maxRect.x = maxRect.y = maxRect.width = maxRect.height = 0;\n    if (showMax) {\n        maxRect.x = size.x - borderRight - BUTTON_SIZE - 3;\n        if (borderRight > 0)\n            maxRect.x += 1;\n        maxRect.y = onBottom ? size.y - borderBottom - tabHeight + (tabHeight - BUTTON_SIZE) / 2 : borderTop + (tabHeight - BUTTON_SIZE) / 2;\n        maxRect.width = BUTTON_SIZE;\n        maxRect.height = BUTTON_SIZE;\n    }\n    if (oldX != maxRect.x || oldWidth != maxRect.width || oldY != maxRect.y || oldHeight != maxRect.height) {\n        int left = Math.min(oldX, maxRect.x);\n        int right = Math.max(oldX + oldWidth, maxRect.x + maxRect.width);\n        int top = onBottom ? size.y - borderBottom - tabHeight : borderTop + 1;\n        redraw(left, top, right - left, tabHeight, false);\n    }\n    \n    oldX = minRect.x;\n    oldY = minRect.y;\n    oldWidth = minRect.width;\n    oldHeight = minRect.height;\n    minRect.x = minRect.y = minRect.width = minRect.height = 0;\n    if (showMin) {\n        minRect.x = size.x - borderRight - maxRect.width - BUTTON_SIZE - 3;\n        if (borderRight > 0)\n            minRect.x += 1;\n        minRect.y = onBottom ? size.y - borderBottom - tabHeight + (tabHeight - BUTTON_SIZE) / 2 : borderTop + (tabHeight - BUTTON_SIZE) / 2;\n        minRect.width = BUTTON_SIZE;\n        minRect.height = BUTTON_SIZE;\n    }\n    if (oldX != minRect.x || oldWidth != minRect.width || oldY != minRect.y || oldHeight != minRect.height) {\n        int left = Math.min(oldX, minRect.x);\n        int right = Math.max(oldX + oldWidth, minRect.x + minRect.width);\n        int top = onBottom ? size.y - borderBottom - tabHeight : borderTop + 1;\n        redraw(left, top, right - left, tabHeight, false);\n    }\n    \n    oldX = topRightRect.x;\n    oldY = topRightRect.y;\n    oldWidth = topRightRect.width;\n    oldHeight = topRightRect.height;\n    topRightRect.x = topRightRect.y = topRightRect.width = topRightRect.height = 0;\n    if (topRight != null) {\n        switch(topRightAlignment) {\n            case SWT.FILL:\n                {\n                    int rightEdge = size.x - borderRight - 3 - maxRect.width - minRect.width;\n                    if (!simple && borderRight > 0 && !showMax && !showMin)\n                        rightEdge -= 2;\n                    if (single) {\n                        if (items.length == 0 || selectedIndex == -1) {\n                            topRightRect.x = borderLeft + 3;\n                            topRightRect.width = rightEdge - topRightRect.x;\n                        } else {\n                            \n                            CTabItem item = items[selectedIndex];\n                            if (item.x + item.width + 7 + 3 * BUTTON_SIZE / 2 >= rightEdge)\n                                break;\n                            topRightRect.x = item.x + item.width + 7 + 3 * BUTTON_SIZE / 2;\n                            topRightRect.width = rightEdge - topRightRect.x;\n                        }\n                    } else {\n                        \n                        if (showChevron)\n                            break;\n                        if (items.length == 0) {\n                            topRightRect.x = borderLeft + 3;\n                        } else {\n                            CTabItem item = items[items.length - 1];\n                            topRightRect.x = item.x + item.width;\n                            if (!simple && items.length - 1 == selectedIndex)\n                                topRightRect.x += curveWidth - curveIndent;\n                        }\n                        topRightRect.width = Math.max(0, rightEdge - topRightRect.x);\n                    }\n                    topRightRect.y = onBottom ? size.y - borderBottom - tabHeight : borderTop + 1;\n                    topRightRect.height = tabHeight - 1;\n                    break;\n                }\n            case SWT.RIGHT:\n                {\n                    Point topRightSize = topRight.computeSize(SWT.DEFAULT, tabHeight, false);\n                    int rightEdge = size.x - borderRight - 3 - maxRect.width - minRect.width;\n                    if (!simple && borderRight > 0 && !showMax && !showMin)\n                        rightEdge -= 2;\n                    topRightRect.x = rightEdge - topRightSize.x;\n                    topRightRect.width = topRightSize.x;\n                    topRightRect.y = onBottom ? size.y - borderBottom - tabHeight : borderTop + 1;\n                    topRightRect.height = tabHeight - 1;\n                }\n        }\n        topRight.setBounds(topRightRect);\n    }\n    if (oldX != topRightRect.x || oldWidth != topRightRect.width || oldY != topRightRect.y || oldHeight != topRightRect.height) {\n        int left = Math.min(oldX, topRightRect.x);\n        int right = Math.max(oldX + oldWidth, topRightRect.x + topRightRect.width);\n        int top = onBottom ? size.y - borderBottom - tabHeight : borderTop + 1;\n        redraw(left, top, right - left, tabHeight, false);\n    }\n    \n    oldX = chevronRect.x;\n    oldY = chevronRect.y;\n    oldWidth = chevronRect.width;\n    oldHeight = chevronRect.height;\n    chevronRect.x = chevronRect.y = chevronRect.height = chevronRect.width = 0;\n    if (single) {\n        if (selectedIndex == -1 || items.length > 1) {\n            chevronRect.width = 3 * BUTTON_SIZE / 2;\n            chevronRect.height = BUTTON_SIZE;\n            chevronRect.y = onBottom ? size.y - borderBottom - tabHeight + (tabHeight - chevronRect.height) / 2 : borderTop + (tabHeight - chevronRect.height) / 2;\n            if (selectedIndex == -1) {\n                chevronRect.x = size.x - borderRight - 3 - minRect.width - maxRect.width - topRightRect.width - chevronRect.width;\n            } else {\n                CTabItem item = items[selectedIndex];\n                int w = size.x - borderRight - 3 - minRect.width - maxRect.width - chevronRect.width;\n                if (topRightRect.width > 0)\n                    w -= topRightRect.width + 3;\n                chevronRect.x = Math.min(item.x + item.width + 3, w);\n            }\n            if (borderRight > 0)\n                chevronRect.x += 1;\n        }\n    } else {\n        if (showChevron) {\n            chevronRect.width = 3 * BUTTON_SIZE / 2;\n            chevronRect.height = BUTTON_SIZE;\n            int i = 0, lastIndex = -1;\n            while (i < priority.length && items[priority[i]].showing) {\n                lastIndex = Math.max(lastIndex, priority[i++]);\n            }\n            if (lastIndex == -1)\n                lastIndex = firstIndex;\n            CTabItem lastItem = items[lastIndex];\n            int w = lastItem.x + lastItem.width + 3;\n            if (!simple && lastIndex == selectedIndex)\n                w += curveWidth - 2 * curveIndent;\n            chevronRect.x = Math.min(w, getRightItemEdge());\n            chevronRect.y = onBottom ? size.y - borderBottom - tabHeight + (tabHeight - chevronRect.height) / 2 : borderTop + (tabHeight - chevronRect.height) / 2;\n        }\n    }\n    if (oldX != chevronRect.x || oldWidth != chevronRect.width || oldY != chevronRect.y || oldHeight != chevronRect.height) {\n        int left = Math.min(oldX, chevronRect.x);\n        int right = Math.max(oldX + oldWidth, chevronRect.x + chevronRect.width);\n        int top = onBottom ? size.y - borderBottom - tabHeight : borderTop + 1;\n        redraw(left, top, right - left, tabHeight, false);\n    }\n}",
			"comments":"// max button\n// min button\n// top right control\n// fill size is 0 if item compressed\n// fill size is 0 if chevron showing\n// chevron button\n",
			"methodName":"void setButtonBounds()"
		},
		"void redrawTabs()":{
			"methodBody":"{\n    Point size = getSize();\n    if (onBottom) {\n        redraw(0, size.y - borderBottom - tabHeight - highlight_header - 1, size.x, borderBottom + tabHeight + highlight_header + 1, false);\n    } else {\n        redraw(0, 0, size.x, borderTop + tabHeight + highlight_header + 1, false);\n    }\n}",
			"comments":"",
			"methodName":"void redrawTabs()"
		},
		"void createItem(CTabItem item, int index)":{
			"methodBody":"{\n    if (0 > index || index > getItemCount())\n        SWT.error(SWT.ERROR_INVALID_RANGE);\n    item.parent = this;\n    CTabItem[] newItems = new CTabItem[items.length + 1];\n    System.arraycopy(items, 0, newItems, 0, index);\n    newItems[index] = item;\n    System.arraycopy(items, index, newItems, index + 1, items.length - index);\n    items = newItems;\n    if (selectedIndex >= index)\n        selectedIndex++;\n    int[] newPriority = new int[priority.length + 1];\n    int next = 0, priorityIndex = priority.length;\n    for (int i = 0; i < priority.length; i++) {\n        if (!mru && priority[i] == index) {\n            priorityIndex = next++;\n        }\n        newPriority[next++] = priority[i] >= index ? priority[i] + 1 : priority[i];\n    }\n    newPriority[priorityIndex] = index;\n    priority = newPriority;\n    if (items.length == 1) {\n        if (!updateTabHeight(false))\n            updateItems();\n        redraw();\n    } else {\n        updateItems();\n        redrawTabs();\n    }\n}",
			"comments":"",
			"methodName":"void createItem(CTabItem item, int index)"
		},
		"public int getTabHeight()":{
			"methodBody":"{\n    checkWidget();\n    if (fixedTabHeight != SWT.DEFAULT)\n        return fixedTabHeight;\n    \n    return tabHeight - 1;\n}",
			"comments":"/**\n* Returns the height of the tab\n*\n* @return the height of the tab\n*\n* @exception SWTException <ul>\n*\t\t<li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*\t\t<li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n*\t</ul>\n*/\n// -1 for line drawn across top of tab\n",
			"methodName":"public int getTabHeight()"
		},
		"boolean updateItems()":{
			"methodBody":"{\n    return updateItems(selectedIndex);\n}",
			"comments":"",
			"methodName":"boolean updateItems()"
		},
		"public CTabItem getItem(Point pt)":{
			"methodBody":"{\n    \n    if (items.length == 0)\n        return null;\n    Point size = getSize();\n    if (size.x <= borderLeft + borderRight)\n        return null;\n    if (showChevron && chevronRect.contains(pt))\n        return null;\n    for (int i = 0; i < priority.length; i++) {\n        CTabItem item = items[priority[i]];\n        Rectangle rect = item.getBounds();\n        if (rect.contains(pt))\n            return item;\n    }\n    return null;\n}",
			"comments":"/**\n* Gets the item at a point in the widget.\n*\n* @param pt the point in coordinates relative to the CTabFolder\n* @return the item at a point or null\n*\n* @exception SWTException <ul>\n*\t\t<li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*\t\t<li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n*\t</ul>\n*/\n//checkWidget();\n",
			"methodName":"public CTabItem getItem(Point pt)"
		},
		"public void setTopRight(Control control, int alignment)":{
			"methodBody":"{\n    checkWidget();\n    if (alignment != SWT.RIGHT && alignment != SWT.FILL) {\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    }\n    if (control != null && control.getParent() != this) {\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    }\n    topRight = control;\n    topRightAlignment = alignment;\n    if (updateItems())\n        redraw();\n}",
			"comments":"/**\n* Set the control that appears in the top right corner of the tab folder.\n* Typically this is a close button or a composite with a Menu and close button.\n* The topRight control is optional.  Setting the top right control to null\n* will remove it from the tab folder.\n* <p>\n* The alignment parameter sets the layout of the control in the tab area.\n* <code>SWT.RIGHT</code> will cause the control to be positioned on the far\n* right of the folder and it will have its default size.  <code>SWT.FILL</code>\n* will size the control to fill all the available space to the right of the\n* last tab.  If there is no available space, the control will not be visible.\n* </p>\n*\n* @param control the control to be displayed in the top right corner or null\n* @param alignment <code>SWT.RIGHT</code> or <code>SWT.FILL</code>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the control is not a child of this CTabFolder</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public void setTopRight(Control control, int alignment)"
		},
		"void showList(Rectangle rect)":{
			"methodBody":"{\n    if (items.length == 0 || !showChevron)\n        return;\n    if (showMenu == null || showMenu.isDisposed()) {\n        showMenu = new Menu(this);\n    } else {\n        MenuItem[] items = showMenu.getItems();\n        for (int i = 0; i < items.length; i++) {\n            items[i].dispose();\n        }\n    }\n    \n    final String id = \"CTabFolder_showList_Index\";\n    for (int i = 0; i < items.length; i++) {\n        CTabItem tab = items[i];\n        if (tab.showing)\n            continue;\n        MenuItem item = new MenuItem(showMenu, SWT.NONE);\n        item.setText(tab.getText());\n        item.setImage(tab.getImage());\n        item.setData(id, tab);\n        item.addSelectionListener(new SelectionAdapter() {\n\n            public void widgetSelected(SelectionEvent e) {\n                MenuItem menuItem = (MenuItem) e.widget;\n                int index = indexOf((CTabItem) menuItem.getData(id));\n                CTabFolder.this.setSelection(index, true);\n            }\n        });\n    }\n    int x = rect.x;\n    int y = rect.y + rect.height;\n    Point location = getDisplay().map(this, null, x, y);\n    showMenu.setLocation(location.x, location.y);\n    showMenu.setVisible(true);\n}",
			"comments":"//$NON-NLS-1$\n",
			"methodName":"void showList(Rectangle rect)"
		},
		"public void setMaximizeVisible(boolean visible)":{
			"methodBody":"{\n    checkWidget();\n    if (showMax == visible)\n        return;\n    \n    showMax = visible;\n    updateItems();\n    redraw();\n}",
			"comments":"/**\n* Marks the receiver's maximize button as visible if the argument is <code>true</code>,\n* and marks it invisible otherwise.\n*\n* @param visible the new visibility state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.0\n*/\n// display maximize button\n",
			"methodName":"public void setMaximizeVisible(boolean visible)"
		},
		"public void getDefaultAction(AccessibleControlEvent e)":{
			"methodBody":"{\n    String action = null;\n    int childID = e.childID;\n    if (childID >= 0 && childID < items.length) {\n        \n        action = SWT.getMessage(\"SWT_Switch\");\n    }\n    e.result = action;\n}",
			"comments":"//$NON-NLS-1$\n",
			"methodName":"public void getDefaultAction(AccessibleControlEvent e)"
		},
		"boolean setItemLocation()":{
			"methodBody":"{\n    boolean changed = false;\n    if (items.length == 0)\n        return false;\n    Point size = getSize();\n    int y = onBottom ? Math.max(borderBottom, size.y - borderBottom - tabHeight) : borderTop;\n    if (single) {\n        \n        int defaultX = getDisplay().getBounds().width + 10;\n        for (int i = 0; i < items.length; i++) {\n            CTabItem item = items[i];\n            if (i == selectedIndex) {\n                firstIndex = selectedIndex;\n                int oldX = item.x, oldY = item.y;\n                item.x = borderLeft;\n                item.y = y;\n                item.showing = true;\n                if (showClose || item.showClose) {\n                    item.closeRect.x = borderLeft + CTabItem.LEFT_MARGIN;\n                    item.closeRect.y = onBottom ? size.y - borderBottom - tabHeight + (tabHeight - BUTTON_SIZE) / 2 : borderTop + (tabHeight - BUTTON_SIZE) / 2;\n                }\n                if (item.x != oldX || item.y != oldY)\n                    changed = true;\n            } else {\n                item.x = defaultX;\n                item.showing = false;\n            }\n        }\n    } else {\n        int rightItemEdge = getRightItemEdge();\n        int maxWidth = rightItemEdge - borderLeft;\n        int width = 0;\n        for (int i = 0; i < priority.length; i++) {\n            CTabItem item = items[priority[i]];\n            width += item.width;\n            item.showing = i == 0 ? true : item.width > 0 && width <= maxWidth;\n            if (!simple && priority[i] == selectedIndex)\n                width += curveWidth - 2 * curveIndent;\n        }\n        int x = 0;\n        \n        int defaultX = getDisplay().getBounds().width + 10;\n        firstIndex = items.length - 1;\n        for (int i = 0; i < items.length; i++) {\n            CTabItem item = items[i];\n            if (!item.showing) {\n                if (item.x != defaultX)\n                    changed = true;\n                item.x = defaultX;\n            } else {\n                firstIndex = Math.min(firstIndex, i);\n                if (item.x != x || item.y != y)\n                    changed = true;\n                item.x = x;\n                item.y = y;\n                if (i == selectedIndex) {\n                    int edge = Math.min(item.x + item.width, rightItemEdge);\n                    item.closeRect.x = edge - CTabItem.RIGHT_MARGIN - BUTTON_SIZE;\n                } else {\n                    item.closeRect.x = item.x + item.width - CTabItem.RIGHT_MARGIN - BUTTON_SIZE;\n                }\n                item.closeRect.y = onBottom ? size.y - borderBottom - tabHeight + (tabHeight - BUTTON_SIZE) / 2 : borderTop + (tabHeight - BUTTON_SIZE) / 2;\n                x = x + item.width;\n                if (!simple && i == selectedIndex)\n                    x += curveWidth - 2 * curveIndent;\n            }\n        }\n    }\n    return changed;\n}",
			"comments":"// off screen\n// off screen\n",
			"methodName":"boolean setItemLocation()"
		},
		"void onResize()":{
			"methodBody":"{\n    if (updateItems())\n        redrawTabs();\n    Point size = getSize();\n    if (oldSize == null) {\n        redraw();\n    } else {\n        if (onBottom && size.y != oldSize.y) {\n            redraw();\n        } else {\n            int x1 = Math.min(size.x, oldSize.x);\n            if (size.x != oldSize.x)\n                x1 -= borderRight + highlight_margin;\n            \n            if (!simple)\n                x1 -= 5;\n            int y1 = Math.min(size.y, oldSize.y);\n            if (size.y != oldSize.y)\n                y1 -= borderBottom + highlight_margin;\n            int x2 = Math.max(size.x, oldSize.x);\n            int y2 = Math.max(size.y, oldSize.y);\n            redraw(0, y1, x2, y2 - y1, false);\n            redraw(x1, 0, x2 - x1, y2, false);\n        }\n    }\n    oldSize = size;\n}",
			"comments":"// rounded top right corner\n",
			"methodName":"void onResize()"
		},
		"void onDragDetect(Event event)":{
			"methodBody":"{\n    boolean consume = false;\n    if (chevronRect.contains(event.x, event.y) || minRect.contains(event.x, event.y) || maxRect.contains(event.x, event.y)) {\n        consume = true;\n    } else {\n        for (int i = 0; i < items.length; i++) {\n            if (items[i].closeRect.contains(event.x, event.y)) {\n                consume = true;\n                break;\n            }\n        }\n    }\n    if (consume) {\n        event.type = SWT.None;\n    }\n}",
			"comments":"",
			"methodName":"void onDragDetect(Event event)"
		},
		"public int getItemCount()":{
			"methodBody":"{\n    \n    return items.length;\n}",
			"comments":"/**\n* Return the number of tabs in the folder.\n*\n* @return the number of tabs in the folder\n*\n* @exception SWTException <ul>\n*\t\t<li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*\t\t<li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n*\t</ul>\n*/\n//checkWidget();\n",
			"methodName":"public int getItemCount()"
		},
		"public void setTabHeight(int height)":{
			"methodBody":"{\n    checkWidget();\n    if (height < -1) {\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    }\n    fixedTabHeight = height;\n    updateTabHeight(false);\n}",
			"comments":"/**\n* Specify a fixed height for the tab items.  If no height is specified,\n* the default height is the height of the text or the image, whichever\n* is greater. Specifying a height of -1 will revert to the default height.\n*\n* @param height the pixel value of the height or -1\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_INVALID_ARGUMENT - if called with a height of less than 0</li>\n* </ul>\n*/\n",
			"methodName":"public void setTabHeight(int height)"
		},
		"static void fillRegion(GC gc, Region region)":{
			"methodBody":"{\n    \n    Region clipping = new Region();\n    gc.getClipping(clipping);\n    region.intersect(clipping);\n    gc.setClipping(region);\n    gc.fillRectangle(region.getBounds());\n    gc.setClipping(clipping);\n    clipping.dispose();\n}",
			"comments":"// NOTE: region passed in to this function will be modified\n",
			"methodName":"static void fillRegion(GC gc, Region region)"
		},
		"void onTraverse(Event event)":{
			"methodBody":"{\n    switch(event.detail) {\n        case SWT.TRAVERSE_ESCAPE:\n        case SWT.TRAVERSE_RETURN:\n        case SWT.TRAVERSE_TAB_NEXT:\n        case SWT.TRAVERSE_TAB_PREVIOUS:\n            event.doit = true;\n            break;\n        case SWT.TRAVERSE_MNEMONIC:\n            event.doit = onMnemonic(event);\n            if (event.doit)\n                event.detail = SWT.TRAVERSE_NONE;\n            break;\n        case SWT.TRAVERSE_PAGE_NEXT:\n        case SWT.TRAVERSE_PAGE_PREVIOUS:\n            event.doit = onPageTraversal(event);\n            event.detail = SWT.TRAVERSE_NONE;\n            break;\n    }\n}",
			"comments":"",
			"methodName":"void onTraverse(Event event)"
		},
		"public void setMinimizeVisible(boolean visible)":{
			"methodBody":"{\n    checkWidget();\n    if (showMin == visible)\n        return;\n    \n    showMin = visible;\n    updateItems();\n    redraw();\n}",
			"comments":"/**\n* Marks the receiver's minimize button as visible if the argument is <code>true</code>,\n* and marks it invisible otherwise.\n*\n* @param visible the new visibility state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.0\n*/\n// display maximize button\n",
			"methodName":"public void setMinimizeVisible(boolean visible)"
		},
		"public void addCTabFolder2Listener(CTabFolder2Listener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    \n    CTabFolder2Listener[] newListeners = new CTabFolder2Listener[folderListeners.length + 1];\n    System.arraycopy(folderListeners, 0, newListeners, 0, folderListeners.length);\n    folderListeners = newListeners;\n    folderListeners[folderListeners.length - 1] = listener;\n}",
			"comments":"/**\n*\n* Adds the listener to the collection of listeners who will\n* be notified when a tab item is closed, minimized, maximized,\n* restored, or to show the list of items that are not\n* currently visible.\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*    <li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n* </ul>\n*\n* @see CTabFolder2Listener\n* @see #removeCTabFolder2Listener(CTabFolder2Listener)\n*\n* @since 3.0\n*/\n// add to array\n",
			"methodName":"public void addCTabFolder2Listener(CTabFolder2Listener listener)"
		},
		"public void showSelection()":{
			"methodBody":"{\n    checkWidget();\n    if (selectedIndex != -1) {\n        showItem(getSelection());\n    }\n}",
			"comments":"/**\n* Shows the selection.  If the selection is already showing in the receiver,\n* this method simply returns.  Otherwise, the items are scrolled until\n* the selection is visible.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see CTabFolder#showItem(CTabItem)\n*\n* @since 2.0\n*/\n",
			"methodName":"public void showSelection()"
		},
		"boolean updateToolTip(int x, int y)":{
			"methodBody":"{\n    String tooltip = _getToolTip(x, y);\n    if (tooltip == null)\n        return false;\n    if (tooltip.equals(toolTipLabel.getText()))\n        return true;\n    toolTipLabel.setText(tooltip);\n    Point labelSize = toolTipLabel.computeSize(SWT.DEFAULT, SWT.DEFAULT, true);\n    labelSize.x += 2;\n    labelSize.y += 2;\n    toolTipLabel.setSize(labelSize);\n    toolTipShell.pack();\n    \n    Rectangle area = toolTipShell.getClientArea();\n    toolTipLabel.setSize(area.width, area.height);\n    \n    Point cursorLocation = getDisplay().getCursorLocation();\n    \n    \n    int cursorHeight = 21;\n    Point size = toolTipShell.getSize();\n    Rectangle rect = getMonitor().getBounds();\n    Point pt = new Point(cursorLocation.x, cursorLocation.y + cursorHeight + 2);\n    pt.x = Math.max(pt.x, rect.x);\n    if (pt.x + size.x > rect.x + rect.width)\n        pt.x = rect.x + rect.width - size.x;\n    if (pt.y + size.y > rect.y + rect.height) {\n        pt.y = cursorLocation.y - 2 - size.y;\n    }\n    toolTipShell.setLocation(pt);\n    return true;\n}",
			"comments":"/*\n* On some platforms, there is a minimum size for a shell\n* which may be greater than the label size.\n* To avoid having the background of the tip shell showing\n* around the label, force the label to fill the entire client area.\n*/\n/*\n* Position the tooltip and ensure that it is not located off\n* the screen.\n*/\n// Assuming cursor is 21x21 because this is the size of\n// the arrow cursor on Windows\n",
			"methodName":"boolean updateToolTip(int x, int y)"
		},
		"boolean setItemSize()":{
			"methodBody":"{\n    boolean changed = false;\n    if (isDisposed())\n        return changed;\n    Point size = getSize();\n    if (size.x <= 0 || size.y <= 0)\n        return changed;\n    xClient = borderLeft + marginWidth + highlight_margin;\n    if (onBottom) {\n        yClient = borderTop + highlight_margin + marginHeight;\n    } else {\n        yClient = borderTop + tabHeight + highlight_header + marginHeight;\n    }\n    showChevron = false;\n    if (single) {\n        showChevron = true;\n        if (selectedIndex != -1) {\n            CTabItem tab = items[selectedIndex];\n            GC gc = new GC(this);\n            int width = tab.preferredWidth(gc, true, false);\n            gc.dispose();\n            width = Math.min(width, getRightItemEdge() - borderLeft);\n            if (tab.height != tabHeight || tab.width != width) {\n                changed = true;\n                tab.shortenedText = null;\n                tab.shortenedTextWidth = 0;\n                tab.height = tabHeight;\n                tab.width = width;\n                tab.closeRect.width = tab.closeRect.height = 0;\n                if (showClose || tab.showClose) {\n                    tab.closeRect.width = BUTTON_SIZE;\n                    tab.closeRect.height = BUTTON_SIZE;\n                }\n            }\n        }\n        return changed;\n    }\n    if (items.length == 0)\n        return changed;\n    int[] widths;\n    GC gc = new GC(this);\n    int tabAreaWidth = size.x - borderLeft - borderRight - 3;\n    if (showMin)\n        tabAreaWidth -= BUTTON_SIZE;\n    if (showMax)\n        tabAreaWidth -= BUTTON_SIZE;\n    if (topRightAlignment == SWT.RIGHT && topRight != null) {\n        Point rightSize = topRight.computeSize(SWT.DEFAULT, SWT.DEFAULT, false);\n        tabAreaWidth -= rightSize.x + 3;\n    }\n    if (!simple)\n        tabAreaWidth -= curveWidth - 2 * curveIndent;\n    tabAreaWidth = Math.max(0, tabAreaWidth);\n    \n    int minWidth = 0;\n    int[] minWidths = new int[items.length];\n    for (int i = 0; i < priority.length; i++) {\n        int index = priority[i];\n        minWidths[index] = items[index].preferredWidth(gc, index == selectedIndex, true);\n        minWidth += minWidths[index];\n        if (minWidth > tabAreaWidth)\n            break;\n    }\n    if (minWidth > tabAreaWidth) {\n        \n        showChevron = items.length > 1;\n        if (showChevron)\n            tabAreaWidth -= 3 * BUTTON_SIZE / 2;\n        widths = minWidths;\n        int index = selectedIndex != -1 ? selectedIndex : 0;\n        if (tabAreaWidth < widths[index]) {\n            widths[index] = Math.max(0, tabAreaWidth);\n        }\n    } else {\n        int maxWidth = 0;\n        int[] maxWidths = new int[items.length];\n        for (int i = 0; i < items.length; i++) {\n            maxWidths[i] = items[i].preferredWidth(gc, i == selectedIndex, false);\n            maxWidth += maxWidths[i];\n        }\n        if (maxWidth <= tabAreaWidth) {\n            \n            widths = maxWidths;\n        } else {\n            \n            int extra = (tabAreaWidth - minWidth) / items.length;\n            while (true) {\n                int large = 0, totalWidth = 0;\n                for (int i = 0; i < items.length; i++) {\n                    if (maxWidths[i] > minWidths[i] + extra) {\n                        totalWidth += minWidths[i] + extra;\n                        large++;\n                    } else {\n                        totalWidth += maxWidths[i];\n                    }\n                }\n                if (totalWidth >= tabAreaWidth) {\n                    extra--;\n                    break;\n                }\n                if (large == 0 || tabAreaWidth - totalWidth < large)\n                    break;\n                extra++;\n            }\n            widths = new int[items.length];\n            for (int i = 0; i < items.length; i++) {\n                widths[i] = Math.min(maxWidths[i], minWidths[i] + extra);\n            }\n        }\n    }\n    gc.dispose();\n    for (int i = 0; i < items.length; i++) {\n        CTabItem tab = items[i];\n        int width = widths[i];\n        if (tab.height != tabHeight || tab.width != width) {\n            changed = true;\n            tab.shortenedText = null;\n            tab.shortenedTextWidth = 0;\n            tab.height = tabHeight;\n            tab.width = width;\n            tab.closeRect.width = tab.closeRect.height = 0;\n            if (showClose || tab.showClose) {\n                if (i == selectedIndex || showUnselectedClose) {\n                    tab.closeRect.width = BUTTON_SIZE;\n                    tab.closeRect.height = BUTTON_SIZE;\n                }\n            }\n        }\n    }\n    return changed;\n}",
			"comments":"// First, try the minimum tab size at full compression.\n// full compression required and a chevron\n// no compression required\n// determine compression for each item\n",
			"methodName":"boolean setItemSize()"
		},
		"public void setSelectionBackground(Color[] colors, int[] percents, boolean vertical)":{
			"methodBody":"{\n    checkWidget();\n    if (colors != null) {\n        if (percents == null || percents.length != colors.length - 1) {\n            SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n        }\n        for (int i = 0; i < percents.length; i++) {\n            if (percents[i] < 0 || percents[i] > 100) {\n                SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n            }\n            if (i > 0 && percents[i] < percents[i - 1]) {\n                SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n            }\n        }\n        if (getDisplay().getDepth() < 15) {\n            \n            colors = new Color[] { colors[colors.length - 1] };\n            percents = new int[] {};\n        }\n    }\n    \n    if (selectionBgImage == null) {\n        if ((selectionGradientColors != null) && (colors != null) && (selectionGradientColors.length == colors.length)) {\n            boolean same = false;\n            for (int i = 0; i < selectionGradientColors.length; i++) {\n                if (selectionGradientColors[i] == null) {\n                    same = colors[i] == null;\n                } else {\n                    same = selectionGradientColors[i].equals(colors[i]);\n                }\n                if (!same)\n                    break;\n            }\n            if (same) {\n                for (int i = 0; i < selectionGradientPercents.length; i++) {\n                    same = selectionGradientPercents[i] == percents[i];\n                    if (!same)\n                        break;\n                }\n            }\n            if (same && this.selectionGradientVertical == vertical)\n                return;\n        }\n    } else {\n        selectionBgImage = null;\n    }\n    \n    if (colors == null) {\n        selectionGradientColors = null;\n        selectionGradientPercents = null;\n        selectionGradientVertical = false;\n        setSelectionBackground((Color) null);\n    } else {\n        selectionGradientColors = new Color[colors.length];\n        for (int i = 0; i < colors.length; ++i) {\n            selectionGradientColors[i] = colors[i];\n        }\n        selectionGradientPercents = new int[percents.length];\n        for (int i = 0; i < percents.length; ++i) {\n            selectionGradientPercents[i] = percents[i];\n        }\n        selectionGradientVertical = vertical;\n        setSelectionBackground(selectionGradientColors[selectionGradientColors.length - 1]);\n    }\n    \n    if (selectedIndex > -1)\n        redraw();\n}",
			"comments":"/**\n* Specify a gradient of colours to be draw in the background of the selected tab.\n* For example to draw a vertical gradient that varies from dark blue to blue and then to\n* white, use the following call to setBackground:\n* <pre>\n*\tcfolder.setBackground(new Color[]{display.getSystemColor(SWT.COLOR_DARK_BLUE),\n*\t\t                           display.getSystemColor(SWT.COLOR_BLUE),\n*\t\t                           display.getSystemColor(SWT.COLOR_WHITE),\n*\t\t                           display.getSystemColor(SWT.COLOR_WHITE)},\n*\t\t                  new int[] {25, 50, 100}, true);\n* </pre>\n*\n* @param colors an array of Color that specifies the colors to appear in the gradient\n*               in order of appearance left to right.  The value <code>null</code> clears the\n*               background gradient. The value <code>null</code> can be used inside the array of\n*               Color to specify the background color.\n* @param percents an array of integers between 0 and 100 specifying the percent of the width\n*                 of the widget at which the color should change.  The size of the percents array must be one\n*                 less than the size of the colors array.\n*\n* @param vertical indicate the direction of the gradient.  True is vertical and false is horizontal.\n*\n* @exception SWTException <ul>\n*\t\t<li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*\t\t<li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n*\t</ul>\n*\n* @since 3.0\n*/\n// Don't use gradients on low color displays\n// Are these settings the same as before?\n// Store the new settings\n// Refresh with the new settings\n",
			"methodName":"public void setSelectionBackground(Color[] colors, int[] percents, boolean vertical)"
		},
		"void onKeyDown(Event event)":{
			"methodBody":"{\n    switch(event.keyCode) {\n        case SWT.ARROW_LEFT:\n        case SWT.ARROW_RIGHT:\n            int count = items.length;\n            if (count == 0)\n                return;\n            if (selectedIndex == -1)\n                return;\n            int leadKey = (getStyle() & SWT.RIGHT_TO_LEFT) != 0 ? SWT.ARROW_RIGHT : SWT.ARROW_LEFT;\n            int offset = event.keyCode == leadKey ? -1 : 1;\n            int index;\n            if (!mru) {\n                index = selectedIndex + offset;\n            } else {\n                int[] visible = new int[items.length];\n                int idx = 0;\n                int current = -1;\n                for (int i = 0; i < items.length; i++) {\n                    if (items[i].showing) {\n                        if (i == selectedIndex)\n                            current = idx;\n                        visible[idx++] = i;\n                    }\n                }\n                if (current + offset >= 0 && current + offset < idx) {\n                    index = visible[current + offset];\n                } else {\n                    if (showChevron) {\n                        CTabFolderEvent e = new CTabFolderEvent(this);\n                        e.widget = this;\n                        e.time = event.time;\n                        e.x = chevronRect.x;\n                        e.y = chevronRect.y;\n                        e.width = chevronRect.width;\n                        e.height = chevronRect.height;\n                        e.doit = true;\n                        for (int i = 0; i < folderListeners.length; i++) {\n                            folderListeners[i].showList(e);\n                        }\n                        if (e.doit && !isDisposed()) {\n                            showList(chevronRect);\n                        }\n                    }\n                    return;\n                }\n            }\n            if (index < 0 || index >= count)\n                return;\n            setSelection(index, true);\n            forceFocus();\n    }\n}",
			"comments":"",
			"methodName":"void onKeyDown(Event event)"
		},
		"public void getFocus(AccessibleControlEvent e)":{
			"methodBody":"{\n    int childID = ACC.CHILDID_NONE;\n    if (isFocusControl()) {\n        if (selectedIndex == -1) {\n            childID = ACC.CHILDID_SELF;\n        } else {\n            childID = selectedIndex;\n        }\n    }\n    e.childID = childID;\n}",
			"comments":"",
			"methodName":"public void getFocus(AccessibleControlEvent e)"
		},
		"public boolean getUnselectedCloseVisible()":{
			"methodBody":"{\n    checkWidget();\n    return showUnselectedClose;\n}",
			"comments":"/**\n* Returns <code>true</code> if the close button appears\n* when the user hovers over an unselected tabs.\n*\n* @return <code>true</code> if the close button appears on unselected tabs\n*\n* @since 3.0\n*/\n",
			"methodName":"public boolean getUnselectedCloseVisible()"
		},
		"static int checkStyle(Composite parent, int style)":{
			"methodBody":"{\n    int mask = SWT.CLOSE | SWT.TOP | SWT.BOTTOM | SWT.FLAT | SWT.LEFT_TO_RIGHT | SWT.RIGHT_TO_LEFT | SWT.SINGLE | SWT.MULTI;\n    style = style & mask;\n    \n    if ((style & SWT.TOP) != 0)\n        style = style & ~SWT.BOTTOM;\n    \n    if ((style & SWT.MULTI) != 0)\n        style = style & ~SWT.SINGLE;\n    \n    style |= SWT.NO_REDRAW_RESIZE;\n    \n    \n    String platform = SWT.getPlatform();\n    \n    if (\"carbon\".equals(platform) || \"gtk\".equals(platform))\n        return style;\n    \n    if ((style & SWT.RIGHT_TO_LEFT) != 0)\n        return style;\n    if ((parent.getStyle() & SWT.MIRRORED) != 0 && (style & SWT.LEFT_TO_RIGHT) == 0)\n        return style;\n    return style | SWT.NO_BACKGROUND;\n}",
			"comments":"// TOP and BOTTOM are mutually exlusive.\n// TOP is the default\n// SINGLE and MULTI are mutually exlusive.\n// MULTI is the default\n// reduce the flash by not redrawing the entire area on a Resize event\n//TEMPORARY CODE\n/*\n* The default background on carbon and some GTK themes is not a solid color\n* but a texture.  To show the correct default background, we must allow\n* the operating system to draw it and therefore, we can not use the\n* NO_BACKGROUND style.  The NO_BACKGROUND style is not required on platforms\n* that use double buffering which is true in both of these cases.\n*/\n//$NON-NLS-1$ //$NON-NLS-2$\n//TEMPORARY CODE\n/*\n* In Right To Left orientation on Windows, all GC calls that use a brush are drawing\n* offset by one pixel.  This results in some parts of the CTabFolder not drawing correctly.\n* To alleviate some of the appearance problems, allow the OS to draw the background.\n* This does not draw correctly but the result is less obviously wrong.\n*/\n",
			"methodName":"static int checkStyle(Composite parent, int style)"
		},
		"public int getTabPosition()":{
			"methodBody":"{\n    checkWidget();\n    return onBottom ? SWT.BOTTOM : SWT.TOP;\n}",
			"comments":"/**\n* Returns the position of the tab.  Possible values are SWT.TOP or SWT.BOTTOM.\n*\n* @return the position of the tab\n*\n* @exception SWTException <ul>\n*\t\t<li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*\t\t<li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n*\t</ul>\n*/\n",
			"methodName":"public int getTabPosition()"
		},
		"void onMouseHover(Event event)":{
			"methodBody":"{\n    showToolTip(event.x, event.y);\n}",
			"comments":"",
			"methodName":"void onMouseHover(Event event)"
		},
		"public void setMRUVisible(boolean show)":{
			"methodBody":"{\n    checkWidget();\n    if (mru == show)\n        return;\n    mru = show;\n    if (!mru) {\n        int idx = firstIndex;\n        int next = 0;\n        for (int i = firstIndex; i < items.length; i++) {\n            priority[next++] = i;\n        }\n        for (int i = 0; i < idx; i++) {\n            priority[next++] = i;\n        }\n        if (updateItems())\n            redrawTabs();\n    }\n}",
			"comments":"/**\n* When there is not enough horizontal space to show all the tabs,\n* by default, tabs are shown sequentially from left to right in\n* order of their index.  When the MRU visibility is turned on,\n* the tabs that are visible will be the tabs most recently selected.\n* Tabs will still maintain their left to right order based on index\n* but only the most recently selected tabs are visible.\n* <p>\n* For example, consider a CTabFolder that contains \"Tab 1\", \"Tab 2\",\n* \"Tab 3\" and \"Tab 4\" (in order by index).  The user selects\n* \"Tab 1\" and then \"Tab 3\".  If the CTabFolder is now\n* compressed so that only two tabs are visible, by default,\n* \"Tab 2\" and \"Tab 3\" will be shown (\"Tab 3\" since it is currently\n* selected and \"Tab 2\" because it is the previous item in index order).\n* If MRU visibility is enabled, the two visible tabs will be \"Tab 1\"\n* and \"Tab 3\" (in that order from left to right).</p>\n*\n* @param show the new visibility state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public void setMRUVisible(boolean show)"
		},
		"public void setBackground(Color color)":{
			"methodBody":"{\n    super.setBackground(color);\n    redraw();\n}",
			"comments":"",
			"methodName":"public void setBackground(Color color)"
		},
		"public void setMaximized(boolean maximize)":{
			"methodBody":"{\n    checkWidget();\n    if (this.maximized == maximize)\n        return;\n    if (maximize && this.minimized)\n        setMinimized(false);\n    this.maximized = maximize;\n    redraw(maxRect.x, maxRect.y, maxRect.width, maxRect.height, false);\n}",
			"comments":"/**\n* Sets the maximized state of the receiver.\n*\n* @param maximize the new maximized state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public void setMaximized(boolean maximize)"
		},
		"void hideToolTip()":{
			"methodBody":"{\n    if (toolTipShell == null)\n        return;\n    for (int i = 0; i < toolTipEvents.length; i++) {\n        removeListener(toolTipEvents[i], toolTipListener);\n    }\n    toolTipShell.dispose();\n    toolTipShell = null;\n    toolTipLabel = null;\n}",
			"comments":"",
			"methodName":"void hideToolTip()"
		},
		"public int getMinimumCharacters()":{
			"methodBody":"{\n    checkWidget();\n    return minChars;\n}",
			"comments":"/**\n* Returns the number of characters that will\n* appear in a fully compressed tab.\n*\n* @return number of characters that will appear in a fully compressed tab\n*\n* @since 3.0\n*/\n",
			"methodName":"public int getMinimumCharacters()"
		},
		"public void setUnselectedCloseVisible(boolean visible)":{
			"methodBody":"{\n    checkWidget();\n    if (showUnselectedClose == visible)\n        return;\n    \n    showUnselectedClose = visible;\n    updateItems();\n    redraw();\n}",
			"comments":"/**\n* Specify whether the close button appears\n* when the user hovers over an unselected tabs.\n*\n* @param visible <code>true</code> makes the close button appear\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.0\n*/\n// display close button when mouse hovers\n",
			"methodName":"public void setUnselectedCloseVisible(boolean visible)"
		},
		"public void setSimple(boolean simple)":{
			"methodBody":"{\n    checkWidget();\n    if (this.simple != simple) {\n        this.simple = simple;\n        Rectangle rectBefore = getClientArea();\n        updateItems();\n        Rectangle rectAfter = getClientArea();\n        if (!rectBefore.equals(rectAfter)) {\n            notifyListeners(SWT.Resize, new Event());\n        }\n        redraw();\n    }\n}",
			"comments":"/**\n* Sets the shape that the CTabFolder will use to render itself.\n*\n* @param simple <code>true</code> if the CTabFolder should render itself in a simple, traditional style\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public void setSimple(boolean simple)"
		},
		"public int getSelectionIndex()":{
			"methodBody":"{\n    \n    return selectedIndex;\n}",
			"comments":"/**\n* Return the index of the selected tab item, or -1 if there\n* is no selection.\n*\n* @return the index of the selected tab item or -1\n*\n* @exception SWTException <ul>\n*\t\t<li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*\t\t<li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n*\t</ul>\n*/\n//checkWidget();\n",
			"methodName":"public int getSelectionIndex()"
		},
		"public void removeCTabFolder2Listener(CTabFolder2Listener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (folderListeners.length == 0)\n        return;\n    int index = -1;\n    for (int i = 0; i < folderListeners.length; i++) {\n        if (listener == folderListeners[i]) {\n            index = i;\n            break;\n        }\n    }\n    if (index == -1)\n        return;\n    if (folderListeners.length == 1) {\n        folderListeners = new CTabFolder2Listener[0];\n        return;\n    }\n    CTabFolder2Listener[] newTabListeners = new CTabFolder2Listener[folderListeners.length - 1];\n    System.arraycopy(folderListeners, 0, newTabListeners, 0, index);\n    System.arraycopy(folderListeners, index + 1, newTabListeners, index, folderListeners.length - index - 1);\n    folderListeners = newTabListeners;\n}",
			"comments":"/**\n* Removes the listener.\n*\n* @param listener the listener\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS when called from the wrong thread</li>\n*    <li>ERROR_WIDGET_DISPOSED when the widget has been disposed</li>\n* </ul>\n*\n* @see #addCTabFolder2Listener(CTabFolder2Listener)\n*\n* @since 3.0\n*/\n",
			"methodName":"public void removeCTabFolder2Listener(CTabFolder2Listener listener)"
		},
		"void initAccessible()":{
			"methodBody":"{\n    final Accessible accessible = getAccessible();\n    accessible.addAccessibleListener(new AccessibleAdapter() {\n\n        public void getName(AccessibleEvent e) {\n            String name = null;\n            int childID = e.childID;\n            if (childID >= 0 && childID < items.length) {\n                name = items[childID].getText();\n                int index = name.indexOf('&');\n                if (index > 0) {\n                    name = name.substring(0, index) + name.substring(index + 1);\n                }\n            }\n            e.result = name;\n        }\n\n        public void getHelp(AccessibleEvent e) {\n            String help = null;\n            int childID = e.childID;\n            if (childID == ACC.CHILDID_SELF) {\n                help = getToolTipText();\n            } else if (childID >= 0 && childID < items.length) {\n                help = items[childID].getToolTipText();\n            }\n            e.result = help;\n        }\n\n        public void getKeyboardShortcut(AccessibleEvent e) {\n            String shortcut = null;\n            int childID = e.childID;\n            if (childID >= 0 && childID < items.length) {\n                String text = items[childID].getText();\n                if (text != null) {\n                    char mnemonic = _findMnemonic(text);\n                    if (mnemonic != '\\0') {\n                        \n                        shortcut = \"Alt+\" + mnemonic;\n                    }\n                }\n            }\n            e.result = shortcut;\n        }\n    });\n    accessible.addAccessibleControlListener(new AccessibleControlAdapter() {\n\n        public void getChildAtPoint(AccessibleControlEvent e) {\n            Point testPoint = toControl(e.x, e.y);\n            int childID = ACC.CHILDID_NONE;\n            for (int i = 0; i < items.length; i++) {\n                if (items[i].getBounds().contains(testPoint)) {\n                    childID = i;\n                    break;\n                }\n            }\n            if (childID == ACC.CHILDID_NONE) {\n                Rectangle location = getBounds();\n                location.height = location.height - getClientArea().height;\n                if (location.contains(testPoint)) {\n                    childID = ACC.CHILDID_SELF;\n                }\n            }\n            e.childID = childID;\n        }\n\n        public void getLocation(AccessibleControlEvent e) {\n            Rectangle location = null;\n            int childID = e.childID;\n            if (childID == ACC.CHILDID_SELF) {\n                location = getBounds();\n            }\n            if (childID >= 0 && childID < items.length) {\n                location = items[childID].getBounds();\n            }\n            if (location != null) {\n                Point pt = toDisplay(location.x, location.y);\n                e.x = pt.x;\n                e.y = pt.y;\n                e.width = location.width;\n                e.height = location.height;\n            }\n        }\n\n        public void getChildCount(AccessibleControlEvent e) {\n            e.detail = items.length;\n        }\n\n        public void getDefaultAction(AccessibleControlEvent e) {\n            String action = null;\n            int childID = e.childID;\n            if (childID >= 0 && childID < items.length) {\n                \n                action = SWT.getMessage(\"SWT_Switch\");\n            }\n            e.result = action;\n        }\n\n        public void getFocus(AccessibleControlEvent e) {\n            int childID = ACC.CHILDID_NONE;\n            if (isFocusControl()) {\n                if (selectedIndex == -1) {\n                    childID = ACC.CHILDID_SELF;\n                } else {\n                    childID = selectedIndex;\n                }\n            }\n            e.childID = childID;\n        }\n\n        public void getRole(AccessibleControlEvent e) {\n            int role = 0;\n            int childID = e.childID;\n            if (childID == ACC.CHILDID_SELF) {\n                role = ACC.ROLE_TABFOLDER;\n            } else if (childID >= 0 && childID < items.length) {\n                role = ACC.ROLE_TABITEM;\n            }\n            e.detail = role;\n        }\n\n        public void getSelection(AccessibleControlEvent e) {\n            e.childID = (selectedIndex == -1) ? ACC.CHILDID_NONE : selectedIndex;\n        }\n\n        public void getState(AccessibleControlEvent e) {\n            int state = 0;\n            int childID = e.childID;\n            if (childID == ACC.CHILDID_SELF) {\n                state = ACC.STATE_NORMAL;\n            } else if (childID >= 0 && childID < items.length) {\n                state = ACC.STATE_SELECTABLE;\n                if (isFocusControl()) {\n                    state |= ACC.STATE_FOCUSABLE;\n                }\n                if (selectedIndex == childID) {\n                    state |= ACC.STATE_SELECTED;\n                    if (isFocusControl()) {\n                        state |= ACC.STATE_FOCUSED;\n                    }\n                }\n            }\n            e.detail = state;\n        }\n\n        public void getChildren(AccessibleControlEvent e) {\n            Object[] children = new Object[items.length];\n            for (int i = 0; i < items.length; i++) {\n                children[i] = new Integer(i);\n            }\n            e.children = children;\n        }\n    });\n    addListener(SWT.Selection, new Listener() {\n\n        public void handleEvent(Event event) {\n            if (isFocusControl()) {\n                if (selectedIndex == -1) {\n                    accessible.setFocus(ACC.CHILDID_SELF);\n                } else {\n                    accessible.setFocus(selectedIndex);\n                }\n            }\n        }\n    });\n    addListener(SWT.FocusIn, new Listener() {\n\n        public void handleEvent(Event event) {\n            if (selectedIndex == -1) {\n                accessible.setFocus(ACC.CHILDID_SELF);\n            } else {\n                accessible.setFocus(selectedIndex);\n            }\n        }\n    });\n}",
			"comments":"//$NON-NLS-1$\n//$NON-NLS-1$\n",
			"methodName":"void initAccessible()"
		},
		"public boolean getMinimized()":{
			"methodBody":"{\n    checkWidget();\n    return minimized;\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver is minimized.\n*\n* @return the receiver's minimized state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public boolean getMinimized()"
		}
	},
	"ClassORInterfaceName":[
		"CTabFolder"
	]
}
