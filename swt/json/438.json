{
	"variables":[
		"image",
		"smallImage",
		"largeImage",
		"images",
		"menuBar",
		"menus",
		"savedFocus",
		"defaultButton",
		"saveDefault",
		"swFlags",
		"hAccel",
		"nAccel",
		"moved",
		"resized",
		"opened",
		"oldX",
		"oldY",
		"oldWidth",
		"oldHeight",
		"i",
		"newMenus",
		"event",
		"value1",
		"value2",
		"transparent1",
		"transparent2",
		"rect",
		"bits1",
		"bits2",
		"hasMenu",
		"testRect",
		"maxAccel",
		"items",
		"accel",
		"buffer1",
		"buffer2",
		"i",
		"item",
		"menu",
		"data",
		"mask",
		"width",
		"height",
		"hMask",
		"hBitmap",
		"hDC",
		"dstHdc",
		"oldDstBitmap",
		"srcHdc",
		"oldSrcBitmap",
		"info",
		"hIcon",
		"shell",
		"i",
		"menu",
		"menu",
		"index",
		"lpwndpl",
		"width",
		"height",
		"rect",
		"hwndCB",
		"height",
		"lpwndpl",
		"width",
		"height",
		"rect",
		"bits1",
		"bits2",
		"hasMenu",
		"result",
		"lpwndpl",
		"lpwndpl",
		"width",
		"height",
		"length",
		"buffer",
		"index",
		"menu",
		"i",
		"control",
		"rect",
		"sameOrigin",
		"sameExtent",
		"hSmallIcon",
		"hLargeIcon",
		"smallIcon",
		"largeIcon",
		"depth",
		"datas",
		"bestImages",
		"i",
		"flags",
		"i",
		"rect",
		"width",
		"height",
		"hwndCB",
		"rectCB",
		"flags",
		"resize",
		"resize",
		"hMenu",
		"flags",
		"hwndParent",
		"bits",
		"flags",
		"lpwndpl",
		"sameOrigin",
		"sameExtent",
		"location",
		"rect",
		"hMenu",
		"oldCount",
		"newCount",
		"info",
		"index",
		"buffer",
		"hwndCB",
		"location",
		"rect",
		"length",
		"gap",
		"i",
		"j",
		"swap",
		"swapData",
		"decorations",
		"shell",
		"hwndMDIClient",
		"children",
		"length",
		"index",
		"start",
		"offset",
		"child",
		"bits",
		"shell",
		"bits",
		"result",
		"buffer",
		"className",
		"control",
		"display",
		"lockWindow",
		"control",
		"shell",
		"result",
		"result",
		"result",
		"location",
		"result",
		"control",
		"shell",
		"decorations",
		"hwndShell",
		"result",
		"result",
		"result",
		"changed",
		"newWidth",
		"newHeight",
		"rect",
		"result",
		"cmd",
		"result",
		"lpwp",
		"OS",
		"OS",
		"OS",
		"OS",
		"parent",
		"style",
		"menus",
		"menus",
		"i",
		"menus",
		"i",
		"menus",
		"i",
		"menus",
		"i",
		"menu",
		"menus",
		"newMenus",
		"menus",
		"menu",
		"System",
		"menus",
		"newMenus",
		"menus",
		"menus",
		"newMenus",
		"OS",
		"handle",
		"style",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"OS",
		"style",
		"SWT",
		"style",
		"SWT",
		"style",
		"SWT",
		"style",
		"SWT",
		"style",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"style",
		"SWT",
		"style",
		"SWT",
		"style",
		"opened",
		"resized",
		"SWT",
		"handle",
		"OS",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"SWT",
		"event",
		"event",
		"Math",
		"data1",
		"width",
		"Math",
		"data2",
		"width",
		"value1",
		"value2",
		"data1",
		"data2",
		"transparent1",
		"transparent2",
		"data1",
		"data2",
		"data1",
		"data2",
		"data1",
		"depth",
		"OS",
		"OS",
		"OS",
		"transparent1",
		"SWT",
		"transparent2",
		"SWT",
		"transparent1",
		"SWT",
		"transparent2",
		"SWT",
		"transparent1",
		"SWT",
		"transparent2",
		"SWT",
		"value1",
		"value2",
		"OS",
		"rect",
		"x",
		"y",
		"x",
		"width",
		"y",
		"height",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"rect",
		"bits1",
		"hasMenu",
		"bits2",
		"horizontalBar",
		"rect",
		"OS",
		"OS",
		"verticalBar",
		"rect",
		"OS",
		"OS",
		"hasMenu",
		"OS",
		"testRect",
		"rect",
		"rect",
		"rect",
		"rect",
		"OS",
		"handle",
		"OS",
		"testRect",
		"testRect",
		"testRect",
		"height",
		"rect",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"testRect",
		"rect",
		"rect",
		"rect",
		"rect",
		"OS",
		"handle",
		"OS",
		"testRect",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"hAccel",
		"nAccel",
		"display",
		"menuBar",
		"items",
		"OS",
		"maxAccel",
		"maxAccel",
		"OS",
		"items",
		"items",
		"ACCEL",
		"maxAccel",
		"ACCEL",
		"menuBar",
		"items",
		"i",
		"items",
		"i",
		"items",
		"i",
		"item",
		"item",
		"item",
		"menu",
		"menu",
		"menu",
		"menuBar",
		"menu",
		"menu",
		"menu",
		"menuBar",
		"item",
		"accel",
		"OS",
		"buffer1",
		"accel",
		"ACCEL",
		"System",
		"buffer1",
		"buffer2",
		"nAccel",
		"ACCEL",
		"ACCEL",
		"nAccel",
		"OS",
		"accel",
		"OS",
		"OS",
		"accel",
		"accel",
		"OS",
		"OS",
		"buffer1",
		"accel",
		"ACCEL",
		"System",
		"buffer1",
		"buffer2",
		"nAccel",
		"ACCEL",
		"ACCEL",
		"nAccel",
		"nAccel",
		"hAccel",
		"OS",
		"buffer2",
		"nAccel",
		"image",
		"data",
		"data",
		"data",
		"display",
		"data",
		"mask",
		"data",
		"data",
		"OS",
		"handle",
		"OS",
		"hDC",
		"OS",
		"OS",
		"OS",
		"hBitmap",
		"Display",
		"image",
		"data",
		"data",
		"data",
		"hMask",
		"OS",
		"width",
		"height",
		"oldDstBitmap",
		"OS",
		"dstHdc",
		"hMask",
		"OS",
		"dstHdc",
		"width",
		"height",
		"OS",
		"hMask",
		"Display",
		"data",
		"width",
		"height",
		"hBitmap",
		"OS",
		"hDC",
		"width",
		"height",
		"oldDstBitmap",
		"OS",
		"dstHdc",
		"hBitmap",
		"OS",
		"hDC",
		"OS",
		"srcHdc",
		"image",
		"OS",
		"dstHdc",
		"width",
		"height",
		"OS",
		"OS",
		"dstHdc",
		"width",
		"height",
		"srcHdc",
		"OS",
		"OS",
		"srcHdc",
		"hMask",
		"OS",
		"dstHdc",
		"width",
		"height",
		"srcHdc",
		"OS",
		"OS",
		"srcHdc",
		"image",
		"OS",
		"dstHdc",
		"width",
		"height",
		"srcHdc",
		"OS",
		"OS",
		"srcHdc",
		"oldSrcBitmap",
		"OS",
		"srcHdc",
		"OS",
		"dstHdc",
		"oldDstBitmap",
		"OS",
		"dstHdc",
		"OS",
		"handle",
		"hDC",
		"info",
		"info",
		"hBitmap",
		"info",
		"hMask",
		"OS",
		"info",
		"hIcon",
		"SWT",
		"SWT",
		"OS",
		"hBitmap",
		"OS",
		"hMask",
		"Image",
		"display",
		"SWT",
		"hIcon",
		"parent",
		"style",
		"SWT",
		"swFlags",
		"OS",
		"OS",
		"OS",
		"hAccel",
		"hAccel",
		"hAccel",
		"OS",
		"hAccel",
		"hAccel",
		"SWT",
		"shell",
		"menus",
		"i",
		"menus",
		"i",
		"menus",
		"i",
		"menu",
		"hMenu",
		"menu",
		"menu",
		"newDecorations",
		"control",
		"savedFocus",
		"savedFocus",
		"control",
		"defaultButton",
		"defaultButton",
		"control",
		"saveDefault",
		"saveDefault",
		"menus",
		"control",
		"menu",
		"index",
		"menus",
		"menus",
		"index",
		"menu",
		"control",
		"index",
		"menu",
		"newDecorations",
		"newDecorations",
		"OS",
		"OS",
		"handle",
		"lpwndpl",
		"WINDOWPLACEMENT",
		"OS",
		"handle",
		"lpwndpl",
		"lpwndpl",
		"lpwndpl",
		"lpwndpl",
		"lpwndpl",
		"lpwndpl",
		"lpwndpl",
		"width",
		"height",
		"OS",
		"menuBar",
		"menuBar",
		"OS",
		"hwndCB",
		"rect",
		"height",
		"rect",
		"height",
		"rect",
		"OS",
		"OS",
		"handle",
		"lpwndpl",
		"WINDOWPLACEMENT",
		"OS",
		"handle",
		"lpwndpl",
		"lpwndpl",
		"lpwndpl",
		"lpwndpl",
		"lpwndpl",
		"horizontalBar",
		"width",
		"OS",
		"OS",
		"verticalBar",
		"height",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"rect",
		"bits1",
		"hasMenu",
		"bits2",
		"width",
		"Math",
		"width",
		"rect",
		"rect",
		"height",
		"Math",
		"height",
		"rect",
		"rect",
		"width",
		"height",
		"defaultButton",
		"image",
		"images",
		"images",
		"System",
		"images",
		"result",
		"images",
		"result",
		"OS",
		"OS",
		"handle",
		"lpwndpl",
		"WINDOWPLACEMENT",
		"OS",
		"handle",
		"lpwndpl",
		"lpwndpl",
		"lpwndpl",
		"OS",
		"swFlags",
		"OS",
		"OS",
		"handle",
		"OS",
		"handle",
		"swFlags",
		"OS",
		"menuBar",
		"OS",
		"OS",
		"handle",
		"OS",
		"handle",
		"swFlags",
		"OS",
		"OS",
		"OS",
		"handle",
		"lpwndpl",
		"WINDOWPLACEMENT",
		"OS",
		"handle",
		"lpwndpl",
		"lpwndpl",
		"lpwndpl",
		"lpwndpl",
		"lpwndpl",
		"width",
		"height",
		"OS",
		"handle",
		"length",
		"length",
		"OS",
		"handle",
		"buffer",
		"length",
		"buffer",
		"length",
		"menuBar",
		"menuBar",
		"menuBar",
		"menus",
		"index",
		"menus",
		"menus",
		"index",
		"menu",
		"menu",
		"menu",
		"menu",
		"menu",
		"menu",
		"index",
		"index",
		"menus",
		"menus",
		"smallImage",
		"smallImage",
		"largeImage",
		"largeImage",
		"smallImage",
		"largeImage",
		"image",
		"images",
		"savedFocus",
		"defaultButton",
		"saveDefault",
		"hAccel",
		"hAccel",
		"OS",
		"hAccel",
		"hAccel",
		"menus",
		"i",
		"menus",
		"i",
		"menus",
		"i",
		"menu",
		"menus",
		"i",
		"display",
		"savedFocus",
		"savedFocus",
		"savedFocus",
		"savedFocus",
		"savedFocus",
		"display",
		"control",
		"control",
		"control",
		"control",
		"OS",
		"swFlags",
		"OS",
		"OS",
		"handle",
		"x",
		"y",
		"width",
		"height",
		"flags",
		"OS",
		"handle",
		"rect",
		"OS",
		"flags",
		"sameOrigin",
		"rect",
		"x",
		"rect",
		"y",
		"sameOrigin",
		"moved",
		"OS",
		"flags",
		"sameExtent",
		"rect",
		"rect",
		"width",
		"rect",
		"rect",
		"height",
		"sameExtent",
		"resized",
		"OS",
		"OS",
		"handle",
		"sameOrigin",
		"sameExtent",
		"x",
		"y",
		"width",
		"height",
		"flags",
		"x",
		"y",
		"width",
		"height",
		"flags",
		"defer",
		"button",
		"button",
		"defaultButton",
		"saveDefault",
		"save",
		"saveDefault",
		"button",
		"SWT",
		"button",
		"SWT",
		"button",
		"defaultButton",
		"defaultButton",
		"defaultButton",
		"defaultButton",
		"defaultButton",
		"button",
		"defaultButton",
		"saveDefault",
		"defaultButton",
		"defaultButton",
		"defaultButton",
		"save",
		"saveDefault",
		"defaultButton",
		"saveDefault",
		"saveDefault",
		"saveDefault",
		"image",
		"image",
		"SWT",
		"image",
		"image",
		"OS",
		"smallImage",
		"smallImage",
		"largeImage",
		"largeImage",
		"smallImage",
		"largeImage",
		"image",
		"smallIcon",
		"largeIcon",
		"image",
		"images",
		"images",
		"display",
		"images",
		"images",
		"System",
		"images",
		"bestImages",
		"images",
		"datas",
		"images",
		"i",
		"datas",
		"i",
		"datas",
		"i",
		"images",
		"i",
		"images",
		"bestImages",
		"images",
		"datas",
		"OS",
		"OS",
		"OS",
		"OS",
		"depth",
		"smallIcon",
		"images",
		"images",
		"images",
		"datas",
		"OS",
		"OS",
		"OS",
		"OS",
		"depth",
		"largeIcon",
		"images",
		"smallIcon",
		"smallIcon",
		"SWT",
		"smallImage",
		"smallIcon",
		"hSmallIcon",
		"smallImage",
		"SWT",
		"hSmallIcon",
		"smallIcon",
		"OS",
		"handle",
		"OS",
		"OS",
		"hSmallIcon",
		"largeIcon",
		"largeIcon",
		"SWT",
		"largeImage",
		"largeIcon",
		"hLargeIcon",
		"largeImage",
		"SWT",
		"hLargeIcon",
		"largeIcon",
		"OS",
		"handle",
		"OS",
		"OS",
		"hLargeIcon",
		"OS",
		"hSmallIcon",
		"hLargeIcon",
		"style",
		"SWT",
		"OS",
		"OS",
		"OS",
		"handle",
		"flags",
		"images",
		"SWT",
		"i",
		"images",
		"i",
		"images",
		"i",
		"images",
		"i",
		"SWT",
		"images",
		"images",
		"swFlags",
		"maximized",
		"OS",
		"OS",
		"OS",
		"maximized",
		"OS",
		"OS",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"OS",
		"menuBar",
		"menuBar",
		"OS",
		"hwndCB",
		"rectCB",
		"height",
		"rectCB",
		"rectCB",
		"OS",
		"OS",
		"OS",
		"handle",
		"rect",
		"rect",
		"width",
		"height",
		"flags",
		"OS",
		"handle",
		"maximized",
		"OS",
		"handle",
		"OS",
		"handle",
		"swFlags",
		"OS",
		"handle",
		"menuBar",
		"menu",
		"menu",
		"menu",
		"SWT",
		"menu",
		"SWT",
		"SWT",
		"menu",
		"SWT",
		"OS",
		"OS",
		"menuBar",
		"menu",
		"menuBar",
		"OS",
		"menuBar",
		"menuBar",
		"menu",
		"menuBar",
		"OS",
		"menuBar",
		"resize",
		"SWT",
		"layout",
		"OS",
		"menuBar",
		"menu",
		"menuBar",
		"OS",
		"menuBar",
		"OS",
		"menuBar",
		"menu",
		"menuBar",
		"OS",
		"menuBar",
		"OS",
		"resize",
		"OS",
		"menuBar",
		"OS",
		"menuBar",
		"OS",
		"menuBar",
		"menu",
		"menuBar",
		"OS",
		"menuBar",
		"OS",
		"menu",
		"display",
		"menu",
		"menuBar",
		"menu",
		"menuBar",
		"menuBar",
		"OS",
		"handle",
		"hMenu",
		"OS",
		"swFlags",
		"minimized",
		"OS",
		"OS",
		"OS",
		"handle",
		"minimized",
		"OS",
		"handle",
		"swFlags",
		"flags",
		"OS",
		"handle",
		"OS",
		"flags",
		"OS",
		"OS",
		"handle",
		"flags",
		"OS",
		"handle",
		"parent",
		"display",
		"OS",
		"handle",
		"hwndParent",
		"OS",
		"hwndParent",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"flags",
		"display",
		"lpwndpl",
		"WINDOWPLACEMENT",
		"OS",
		"handle",
		"lpwndpl",
		"lpwndpl",
		"OS",
		"OS",
		"handle",
		"lpwndpl",
		"OS",
		"OS",
		"handle",
		"lpwndpl",
		"OS",
		"flags",
		"OS",
		"sameOrigin",
		"lpwndpl",
		"x",
		"lpwndpl",
		"y",
		"lpwndpl",
		"x",
		"lpwndpl",
		"lpwndpl",
		"lpwndpl",
		"y",
		"lpwndpl",
		"lpwndpl",
		"lpwndpl",
		"x",
		"lpwndpl",
		"y",
		"flags",
		"OS",
		"sameExtent",
		"lpwndpl",
		"lpwndpl",
		"width",
		"lpwndpl",
		"lpwndpl",
		"height",
		"lpwndpl",
		"lpwndpl",
		"width",
		"lpwndpl",
		"lpwndpl",
		"height",
		"OS",
		"handle",
		"lpwndpl",
		"OS",
		"handle",
		"sameOrigin",
		"moved",
		"oldX",
		"location",
		"oldY",
		"location",
		"SWT",
		"sameExtent",
		"resized",
		"oldWidth",
		"rect",
		"oldHeight",
		"rect",
		"SWT",
		"layout",
		"savedFocus",
		"control",
		"OS",
		"OS",
		"handle",
		"hMenu",
		"OS",
		"hMenu",
		"style",
		"SWT",
		"OS",
		"hMenu",
		"OS",
		"OS",
		"style",
		"SWT",
		"OS",
		"hMenu",
		"OS",
		"OS",
		"style",
		"SWT",
		"OS",
		"hMenu",
		"OS",
		"OS",
		"style",
		"SWT",
		"SWT",
		"OS",
		"hMenu",
		"OS",
		"OS",
		"OS",
		"hMenu",
		"style",
		"SWT",
		"newCount",
		"oldCount",
		"OS",
		"hMenu",
		"OS",
		"OS",
		"info",
		"MENUITEMINFO",
		"info",
		"OS",
		"index",
		"newCount",
		"OS",
		"hMenu",
		"index",
		"info",
		"info",
		"OS",
		"index",
		"index",
		"newCount",
		"OS",
		"hMenu",
		"index",
		"OS",
		"style",
		"SWT",
		"OS",
		"hMenu",
		"OS",
		"OS",
		"string",
		"SWT",
		"string",
		"OS",
		"handle",
		"buffer",
		"drawCount",
		"state",
		"HIDDEN",
		"visible",
		"visible",
		"OS",
		"handle",
		"visible",
		"SWT",
		"OS",
		"menuBar",
		"menuBar",
		"OS",
		"hwndCB",
		"drawCount",
		"state",
		"HIDDEN",
		"OS",
		"OS",
		"handle",
		"OS",
		"menuBar",
		"display",
		"menuBar",
		"OS",
		"handle",
		"OS",
		"handle",
		"swFlags",
		"opened",
		"moved",
		"moved",
		"oldX",
		"location",
		"oldY",
		"location",
		"resized",
		"resized",
		"oldWidth",
		"rect",
		"oldHeight",
		"rect",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"swFlags",
		"OS",
		"OS",
		"handle",
		"swFlags",
		"OS",
		"handle",
		"OS",
		"swFlags",
		"OS",
		"swFlags",
		"OS",
		"drawCount",
		"state",
		"HIDDEN",
		"OS",
		"handle",
		"OS",
		"SWT",
		"images",
		"length",
		"length",
		"gap",
		"gap",
		"gap",
		"i",
		"length",
		"i",
		"i",
		"gap",
		"j",
		"j",
		"gap",
		"datas",
		"j",
		"datas",
		"j",
		"gap",
		"width",
		"height",
		"depth",
		"images",
		"j",
		"images",
		"j",
		"images",
		"j",
		"gap",
		"images",
		"j",
		"gap",
		"swap",
		"datas",
		"j",
		"datas",
		"j",
		"datas",
		"j",
		"gap",
		"datas",
		"j",
		"gap",
		"swapData",
		"menuBar",
		"menuBar",
		"msg",
		"msg",
		"parent",
		"decorations",
		"msg",
		"hAccel",
		"hAccel",
		"OS",
		"handle",
		"hAccel",
		"msg",
		"shell",
		"hwndMDIClient",
		"OS",
		"hwndMDIClient",
		"msg",
		"msg",
		"OS",
		"OS",
		"OS",
		"msg",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"msg",
		"OS",
		"msg",
		"OS",
		"OS",
		"shell",
		"OS",
		"parent",
		"children",
		"index",
		"length",
		"children",
		"index",
		"index",
		"index",
		"next",
		"index",
		"index",
		"offset",
		"length",
		"length",
		"start",
		"children",
		"index",
		"child",
		"child",
		"child",
		"defaultButton",
		"defaultButton",
		"defaultButton",
		"defaultButton",
		"defaultButton",
		"OS",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"style",
		"SWT",
		"bits",
		"OS",
		"bits",
		"shell",
		"OS",
		"OS",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"OS",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"OS",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"bits",
		"msg",
		"Display",
		"Display",
		"hAccel",
		"msg",
		"Display",
		"nAccel",
		"hAccel",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"result",
		"result",
		"OS",
		"lParam",
		"handle",
		"OS",
		"lParam",
		"buffer",
		"buffer",
		"buffer",
		"buffer",
		"className",
		"Display",
		"LRESULT",
		"wParam",
		"wParam",
		"result",
		"display",
		"lParam",
		"control",
		"control",
		"SWT",
		"LRESULT",
		"LRESULT",
		"display",
		"lockWindow",
		"display",
		"display",
		"lParam",
		"control",
		"control",
		"SWT",
		"shell",
		"lockWindow",
		"display",
		"LRESULT",
		"result",
		"wParam",
		"lParam",
		"result",
		"result",
		"LRESULT",
		"wParam",
		"lParam",
		"result",
		"result",
		"OS",
		"lParam",
		"OS",
		"style",
		"SWT",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"wParam",
		"lParam",
		"LRESULT",
		"result",
		"wParam",
		"lParam",
		"result",
		"moved",
		"location",
		"oldX",
		"location",
		"oldY",
		"oldX",
		"location",
		"oldY",
		"location",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"result",
		"result",
		"wParam",
		"display",
		"LRESULT",
		"display",
		"lParam",
		"control",
		"control",
		"decorations",
		"shell",
		"LRESULT",
		"display",
		"display",
		"OS",
		"result",
		"LRESULT",
		"OS",
		"hwndShell",
		"OS",
		"wParam",
		"lParam",
		"result",
		"wParam",
		"lParam",
		"result",
		"result",
		"SWT",
		"result",
		"wParam",
		"lParam",
		"savedFocus",
		"result",
		"resized",
		"wParam",
		"OS",
		"OS",
		"newWidth",
		"lParam",
		"newHeight",
		"lParam",
		"OS",
		"newWidth",
		"rect",
		"newHeight",
		"rect",
		"changed",
		"newWidth",
		"oldWidth",
		"newHeight",
		"oldHeight",
		"changed",
		"oldWidth",
		"newWidth",
		"oldHeight",
		"newHeight",
		"changed",
		"result",
		"wParam",
		"lParam",
		"result",
		"wParam",
		"OS",
		"SWT",
		"result",
		"wParam",
		"lParam",
		"result",
		"result",
		"wParam",
		"cmd",
		"OS",
		"OS",
		"handle",
		"OS",
		"LRESULT",
		"OS",
		"LRESULT",
		"result",
		"wParam",
		"lParam",
		"result",
		"result",
		"display",
		"OS",
		"lpwp",
		"lParam",
		"WINDOWPOS",
		"lpwp",
		"OS",
		"OS",
		"lParam",
		"lpwp",
		"WINDOWPOS",
		"result",
		"CW_USEDEFAULT",
		"CW_USEDEFAULT",
		"CW_USEDEFAULT",
		"CW_USEDEFAULT",
		"length",
		"length",
		"length",
		"length",
		"NO_TRIM",
		"CLOSE",
		"TITLE",
		"MIN",
		"MAX",
		"RESIZE",
		"BORDER",
		"IsWinCE",
		"MIN",
		"MIN",
		"MAX",
		"MAX",
		"MENU",
		"MIN",
		"MAX",
		"CLOSE",
		"TITLE",
		"MIN",
		"MAX",
		"CLOSE",
		"CLOSE",
		"TITLE",
		"ERROR_INVALID_SUBCLASS",
		"Close",
		"doit",
		"width",
		"width",
		"depth",
		"depth",
		"depth",
		"depth",
		"depth",
		"IsWinCE",
		"WIN32_VERSION",
		"TRANSPARENCY_ALPHA",
		"TRANSPARENCY_ALPHA",
		"TRANSPARENCY_MASK",
		"TRANSPARENCY_MASK",
		"TRANSPARENCY_PIXEL",
		"TRANSPARENCY_PIXEL",
		"GWL_STYLE",
		"GWL_EXSTYLE",
		"IsWinCE",
		"bottom",
		"SM_CYHSCROLL",
		"right",
		"SM_CXVSCROLL",
		"right",
		"left",
		"bottom",
		"top",
		"WM_NCCALCSIZE",
		"bottom",
		"top",
		"top",
		"SM_CYMENU",
		"SM_CYBORDER",
		"right",
		"left",
		"bottom",
		"top",
		"WM_NCCALCSIZE",
		"left",
		"top",
		"right",
		"left",
		"bottom",
		"top",
		"items",
		"IsPPC",
		"IsPPC",
		"length",
		"length",
		"sizeof",
		"sizeof",
		"length",
		"accelerator",
		"parent",
		"parent",
		"sizeof",
		"sizeof",
		"sizeof",
		"IsPPC",
		"fVirt",
		"FVIRTKEY",
		"FCONTROL",
		"key",
		"cmd",
		"IDOK",
		"sizeof",
		"sizeof",
		"sizeof",
		"alpha",
		"alphaData",
		"width",
		"height",
		"IsWinCE",
		"WIN32_VERSION",
		"handle",
		"alpha",
		"alphaData",
		"transparentPixel",
		"BLACKNESS",
		"handle",
		"BLACKNESS",
		"SRCINVERT",
		"SRCAND",
		"handle",
		"SRCINVERT",
		"fIcon",
		"hbmColor",
		"hbmMask",
		"ERROR_NO_HANDLES",
		"ICON",
		"TOOL",
		"IsWinCE",
		"SW_SHOWMAXIMIZED",
		"SW_SHOWNOACTIVATE",
		"ERROR_THREAD_INVALID_ACCESS",
		"length",
		"handle",
		"menu",
		"length",
		"IsWinCE",
		"length",
		"sizeof",
		"right",
		"left",
		"bottom",
		"top",
		"left",
		"top",
		"IsHPC",
		"hwndCB",
		"y",
		"height",
		"IsWinCE",
		"length",
		"sizeof",
		"right",
		"left",
		"bottom",
		"top",
		"SM_CYHSCROLL",
		"SM_CXVSCROLL",
		"GWL_STYLE",
		"GWL_EXSTYLE",
		"IsWinCE",
		"right",
		"left",
		"bottom",
		"top",
		"length",
		"length",
		"IsWinCE",
		"length",
		"sizeof",
		"left",
		"top",
		"IsWinCE",
		"SW_SHOWMAXIMIZED",
		"SW_SHOWMAXIMIZED",
		"IsWinCE",
		"SW_SHOWMINNOACTIVE",
		"IsWinCE",
		"length",
		"sizeof",
		"right",
		"left",
		"bottom",
		"top",
		"length",
		"length",
		"length",
		"ignoreRestoreFocus",
		"IsWinCE",
		"SW_RESTORE",
		"SWP_NOMOVE",
		"left",
		"top",
		"SWP_NOSIZE",
		"right",
		"left",
		"bottom",
		"top",
		"IsWinCE",
		"ERROR_INVALID_ARGUMENT",
		"style",
		"PUSH",
		"ERROR_INVALID_ARGUMENT",
		"image",
		"IsWinCE",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"SM_CXSMICON",
		"SM_CYSMICON",
		"length",
		"SM_CXICON",
		"SM_CYICON",
		"type",
		"BITMAP",
		"handle",
		"ICON",
		"handle",
		"WM_SETICON",
		"ICON_SMALL",
		"type",
		"BITMAP",
		"handle",
		"ICON",
		"handle",
		"WM_SETICON",
		"ICON_BIG",
		"IsWinCE",
		"BORDER",
		"RDW_FRAME",
		"RDW_INVALIDATE",
		"ERROR_INVALID_ARGUMENT",
		"length",
		"ERROR_INVALID_ARGUMENT",
		"images",
		"SW_SHOWMAXIMIZED",
		"SW_RESTORE",
		"IsWinCE",
		"SPI_GETWORKAREA",
		"right",
		"left",
		"bottom",
		"top",
		"IsPPC",
		"hwndCB",
		"bottom",
		"top",
		"SWP_NOZORDER",
		"SWP_DRAWFRAME",
		"SWP_NOACTIVATE",
		"left",
		"top",
		"ERROR_INVALID_ARGUMENT",
		"style",
		"BAR",
		"ERROR_MENU_NOT_BAR",
		"parent",
		"ERROR_INVALID_PARENT",
		"IsWinCE",
		"IsHPC",
		"hwndCB",
		"hwndCB",
		"Resize",
		"IsPPC",
		"hwndCB",
		"SW_HIDE",
		"hwndCB",
		"SW_SHOW",
		"IsSP",
		"hwndCB",
		"SW_HIDE",
		"hwndCB",
		"SW_SHOW",
		"handle",
		"IsWinCE",
		"SW_SHOWMINNOACTIVE",
		"SW_RESTORE",
		"SW_SHOWMINNOACTIVE",
		"SW_MINIMIZE",
		"handle",
		"lockActiveWindow",
		"SW_SHOWNA",
		"GWL_STYLE",
		"WS_CHILD",
		"GWL_STYLE",
		"WS_POPUP",
		"GWL_ID",
		"SWP_NOSIZE",
		"SWP_NOMOVE",
		"SWP_NOACTIVATE",
		"HWND_BOTTOM",
		"lockActiveWindow",
		"length",
		"sizeof",
		"showCmd",
		"SW_SHOWNA",
		"showCmd",
		"SW_SHOWMINNOACTIVE",
		"showCmd",
		"SW_SHOWMAXIMIZED",
		"SWP_NOMOVE",
		"left",
		"top",
		"right",
		"right",
		"left",
		"bottom",
		"bottom",
		"top",
		"left",
		"top",
		"SWP_NOSIZE",
		"right",
		"left",
		"bottom",
		"top",
		"right",
		"left",
		"bottom",
		"top",
		"x",
		"y",
		"Move",
		"width",
		"height",
		"Resize",
		"IsWinCE",
		"RESIZE",
		"SC_SIZE",
		"MF_BYCOMMAND",
		"MIN",
		"SC_MINIMIZE",
		"MF_BYCOMMAND",
		"MAX",
		"SC_MAXIMIZE",
		"MF_BYCOMMAND",
		"MIN",
		"MAX",
		"SC_RESTORE",
		"MF_BYCOMMAND",
		"CLOSE",
		"SC_TASKLIST",
		"MF_BYCOMMAND",
		"cbSize",
		"sizeof",
		"fMask",
		"MIIM_ID",
		"wID",
		"SC_CLOSE",
		"MF_BYPOSITION",
		"CLOSE",
		"SC_CLOSE",
		"MF_BYCOMMAND",
		"ERROR_NULL_ARGUMENT",
		"Show",
		"IsHPC",
		"hwndCB",
		"IsWinCE",
		"SW_SHOW",
		"x",
		"y",
		"width",
		"height",
		"IsWinCE",
		"SW_SHOWMINNOACTIVE",
		"SW_SHOWMAXIMIZED",
		"SW_RESTORE",
		"SW_SHOWNOACTIVATE",
		"SW_HIDE",
		"Hide",
		"length",
		"hwndMDIClient",
		"message",
		"WM_KEYDOWN",
		"VK_CONTROL",
		"wParam",
		"VK_F4",
		"WM_CLOSE",
		"VK_F6",
		"message",
		"WM_SYSKEYDOWN",
		"wParam",
		"VK_F4",
		"handle",
		"WM_CLOSE",
		"length",
		"WS_EX_MDICHILD",
		"WS_EX_CLIENTEDGE",
		"NO_TRIM",
		"IsPPC",
		"CLOSE",
		"WS_EX_CAPTIONOKBTN",
		"RESIZE",
		"BORDER",
		"WS_EX_DLGMODALFRAME",
		"WS_TABSTOP",
		"WS_VISIBLE",
		"WS_BORDER",
		"NO_TRIM",
		"TITLE",
		"WS_CAPTION",
		"MIN",
		"WS_MINIMIZEBOX",
		"MAX",
		"WS_MAXIMIZEBOX",
		"RESIZE",
		"IsPPC",
		"WS_THICKFRAME",
		"BORDER",
		"WS_BORDER",
		"IsPPC",
		"IsSP",
		"CLOSE",
		"WS_SYSMENU",
		"SWT_GETACCEL",
		"SWT_GETACCELCOUNT",
		"SWT_GETACCELCOUNT",
		"AWT_WINDOW_CLASS",
		"ZERO",
		"Activate",
		"ZERO",
		"ZERO",
		"display",
		"lockActiveWindow",
		"Deactivate",
		"lockActiveWindow",
		"ZERO",
		"ZERO",
		"IsSP",
		"VK_ESCAPE",
		"CLOSE",
		"WM_CLOSE",
		"WM_HOTKEY",
		"ZERO",
		"x",
		"y",
		"x",
		"y",
		"lockActiveWindow",
		"ZERO",
		"ONE",
		"ignoreRestoreFocus",
		"lastHittest",
		"HTCLIENT",
		"ONE",
		"handle",
		"WM_NCACTIVATE",
		"Deiconify",
		"SIZE_RESTORED",
		"SIZE_MAXIMIZED",
		"SIZE_MINIMIZED",
		"width",
		"height",
		"SIZE_MINIMIZED",
		"Iconify",
		"SC_CLOSE",
		"WM_CLOSE",
		"ZERO",
		"SC_NEXTWINDOW",
		"ZERO",
		"lockActiveWindow",
		"sizeof",
		"flags",
		"SWP_NOZORDER",
		"sizeof",
		"parent",
		"style",
		"menu",
		"style",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"data1",
		"data2",
		"width",
		"height",
		"depth",
		"x",
		"y",
		"width",
		"height",
		"image",
		"hMenu",
		"newDecorations",
		"control",
		"menus",
		"menu",
		"x",
		"y",
		"width",
		"height",
		"flags",
		"defer",
		"button",
		"button",
		"save",
		"image",
		"image",
		"images",
		"images",
		"maximized",
		"menu",
		"minimized",
		"x",
		"y",
		"width",
		"height",
		"flags",
		"control",
		"string",
		"visible",
		"images",
		"datas",
		"width",
		"height",
		"depth",
		"msg",
		"msg",
		"msg",
		"next",
		"next",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam"
	],
	"extendORImplementFiles":[
		"Canvas"
	],
	"package":[
		"org.eclipse.swt.widgets"
	],
	"import":[
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt",
		"org.eclipse.swt.graphics"
	],
	"methods":[
		"addMenu",
		"bringToTop",
		"checkStyle",
		"checkBorder",
		"checkOpened",
		"checkSubclass",
		"callWindowProc",
		"closeWidget",
		"compare",
		"computeTabGroup",
		"computeTabRoot",
		"computeTrim",
		"createAccelerators",
		"createIcon",
		"createHandle",
		"createWidget",
		"destroyAccelerators",
		"dispose",
		"findMenu",
		"fixDecorations",
		"getBounds",
		"getClientArea",
		"getDefaultButton",
		"getImage",
		"getImages",
		"getLocation",
		"getMaximized",
		"getMenuBar",
		"getMinimized",
		"getNameText",
		"getSize",
		"getText",
		"isReparentable",
		"isTabGroup",
		"isTabItem",
		"menuShell",
		"releaseWidget",
		"removeMenu",
		"restoreFocus",
		"saveFocus",
		"setBounds",
		"setDefaultButton",
		"setDefaultButton",
		"setImage",
		"setImages",
		"setImages",
		"setMaximized",
		"setMenuBar",
		"setMinimized",
		"setParent",
		"setPlacement",
		"setSavedFocus",
		"setSystemMenu",
		"setText",
		"setVisible",
		"sort",
		"translateAccelerator",
		"translateMenuAccelerator",
		"translateMDIAccelerator",
		"traverseDecorations",
		"traverseItem",
		"traverseReturn",
		"widgetCreateStruct",
		"widgetExtStyle",
		"widgetParent",
		"widgetStyle",
		"windowProc",
		"WM_ACTIVATE",
		"WM_CLOSE",
		"WM_HOTKEY",
		"WM_KILLFOCUS",
		"WM_MOVE",
		"WM_NCACTIVATE",
		"WM_QUERYOPEN",
		"WM_SETFOCUS",
		"WM_SIZE",
		"WM_SYSCOMMAND",
		"WM_WINDOWPOSCHANGING",
		"checkStyle",
		"arraycopy",
		"BringWindowToTop",
		"isValidSubclass",
		"error",
		"DefMDIChildProc",
		"sendEvent",
		"isDisposed",
		"dispose",
		"abs",
		"abs",
		"getTransparencyType",
		"getTransparencyType",
		"VERSION",
		"checkWidget",
		"SetRect",
		"GetWindowLong",
		"GetWindowLong",
		"GetMenu",
		"AdjustWindowRectEx",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"SetRect",
		"SendMessage",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"SetRect",
		"SendMessage",
		"getParentMenu",
		"fillAccel",
		"MoveMemory",
		"arraycopy",
		"MoveMemory",
		"arraycopy",
		"CreateAcceleratorTable",
		"getImageData",
		"getTransparencyMask",
		"GetDC",
		"CreateCompatibleDC",
		"VERSION",
		"create32bitDIB",
		"CreateBitmap",
		"SelectObject",
		"PatBlt",
		"createMaskFromAlpha",
		"CreateCompatibleBitmap",
		"SelectObject",
		"CreateCompatibleDC",
		"SelectObject",
		"PatBlt",
		"BitBlt",
		"SelectObject",
		"BitBlt",
		"SelectObject",
		"BitBlt",
		"SelectObject",
		"DeleteDC",
		"SelectObject",
		"DeleteDC",
		"ReleaseDC",
		"CreateIconIndirect",
		"error",
		"DeleteObject",
		"DeleteObject",
		"win32_new",
		"createHandle",
		"setParent",
		"setSystemMenu",
		"createWidget",
		"DestroyAcceleratorTable",
		"isDisposed",
		"isValidThread",
		"error",
		"setVisible",
		"traverseDecorations",
		"getShell",
		"setFocus",
		"dispose",
		"setMenu",
		"fixMenus",
		"destroyAccelerators",
		"destroyAccelerators",
		"checkWidget",
		"IsIconic",
		"GetWindowPlacement",
		"getBounds",
		"checkWidget",
		"getClientArea",
		"CommandBar_Height",
		"IsIconic",
		"GetWindowPlacement",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"GetWindowLong",
		"GetWindowLong",
		"GetMenu",
		"AdjustWindowRectEx",
		"max",
		"max",
		"getClientArea",
		"checkWidget",
		"checkWidget",
		"checkWidget",
		"arraycopy",
		"checkWidget",
		"IsIconic",
		"GetWindowPlacement",
		"getLocation",
		"checkWidget",
		"IsWindowVisible",
		"IsZoomed",
		"checkWidget",
		"checkWidget",
		"IsWindowVisible",
		"IsIconic",
		"getText",
		"checkWidget",
		"IsIconic",
		"GetWindowPlacement",
		"getSize",
		"checkWidget",
		"GetWindowTextLength",
		"GetWindowText",
		"toString",
		"checkWidget",
		"releaseResources",
		"isDisposed",
		"getParentMenu",
		"getParentMenu",
		"dispose",
		"releaseWidget",
		"dispose",
		"dispose",
		"DestroyAcceleratorTable",
		"isDisposed",
		"setSavedFocus",
		"_getFocusControl",
		"menuShell",
		"setSavedFocus",
		"IsIconic",
		"setPlacement",
		"forceResize",
		"GetWindowRect",
		"IsZoomed",
		"setPlacement",
		"setMaximized",
		"setBounds",
		"checkWidget",
		"setDefaultButton",
		"isDisposed",
		"error",
		"isDisposed",
		"setDefault",
		"isDisposed",
		"setDefault",
		"isDisposed",
		"checkWidget",
		"isDisposed",
		"error",
		"setImages",
		"dispose",
		"dispose",
		"getIconDepth",
		"arraycopy",
		"getImageData",
		"sort",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"sort",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"createIcon",
		"SendMessage",
		"createIcon",
		"SendMessage",
		"RedrawWindow",
		"checkWidget",
		"error",
		"isDisposed",
		"error",
		"setImages",
		"checkWidget",
		"SystemParametersInfo",
		"GetWindowRect",
		"SetWindowPos",
		"IsWindowVisible",
		"IsZoomed",
		"ShowWindow",
		"UpdateWindow",
		"checkWidget",
		"isDisposed",
		"error",
		"error",
		"error",
		"CommandBar_Show",
		"CommandBar_Show",
		"sendEvent",
		"isDisposed",
		"markLayout",
		"updateLayout",
		"getMaximized",
		"ShowWindow",
		"ShowWindow",
		"setMaximized",
		"ShowWindow",
		"ShowWindow",
		"removeBar",
		"SetMenu",
		"destroyAccelerators",
		"checkWidget",
		"IsWindowVisible",
		"IsIconic",
		"GetActiveWindow",
		"ShowWindow",
		"UpdateWindow",
		"SetParent",
		"IsWindowVisible",
		"ShowWindow",
		"GetWindowLong",
		"SetWindowLong",
		"SetWindowLong",
		"SetWindowPos",
		"GetWindowPlacement",
		"IsIconic",
		"IsZoomed",
		"SetWindowPlacement",
		"IsIconic",
		"getLocation",
		"sendEvent",
		"isDisposed",
		"getClientArea",
		"sendEvent",
		"isDisposed",
		"markLayout",
		"updateLayout",
		"GetSystemMenu",
		"GetMenuItemCount",
		"DeleteMenu",
		"DeleteMenu",
		"DeleteMenu",
		"DeleteMenu",
		"GetMenuItemCount",
		"DeleteMenu",
		"GetMenuItemInfo",
		"DeleteMenu",
		"DeleteMenu",
		"checkWidget",
		"error",
		"SetWindowText",
		"checkWidget",
		"IsWindowVisible",
		"sendEvent",
		"isDisposed",
		"CommandBar_DrawMenuBar",
		"ShowWindow",
		"removeBar",
		"DrawMenuBar",
		"ShowWindow",
		"isDisposed",
		"getLocation",
		"getClientArea",
		"UpdateWindow",
		"IsIconic",
		"IsZoomed",
		"GetActiveWindow",
		"ShowWindow",
		"isDisposed",
		"sendEvent",
		"compare",
		"isEnabled",
		"isActive",
		"isEnabled",
		"translateMDIAccelerator",
		"translateMenuAccelerator",
		"menuShell",
		"translateAccelerator",
		"createAccelerators",
		"TranslateAccelerator",
		"getShell",
		"TranslateMDISysAccel",
		"GetKeyState",
		"PostMessage",
		"traverseDecorations",
		"PostMessage",
		"_getChildren",
		"isDisposed",
		"setFocus",
		"isDisposed",
		"isVisible",
		"isEnabled",
		"click",
		"widgetExtStyle",
		"getShell",
		"hwndMDIClient",
		"widgetStyle",
		"createAccelerators",
		"windowProc",
		"WM_ACTIVATE",
		"GetParent",
		"GetClassName",
		"length",
		"toString",
		"strlen",
		"equals",
		"findControl",
		"sendEvent",
		"isDisposed",
		"restoreFocus",
		"isXMouseActive",
		"findControl",
		"sendEvent",
		"isDisposed",
		"getShell",
		"setActiveControl",
		"isDisposed",
		"saveFocus",
		"WM_CLOSE",
		"isEnabled",
		"isActive",
		"closeWidget",
		"WM_HOTKEY",
		"PostMessage",
		"SHSendBackToFocusWindow",
		"WM_KILLFOCUS",
		"saveFocus",
		"getLocation",
		"WM_MOVE",
		"WM_NCACTIVATE",
		"findControl",
		"getShell",
		"menuShell",
		"getShell",
		"getShell",
		"SendMessage",
		"WM_QUERYOPEN",
		"sendEvent",
		"WM_SETFOCUS",
		"restoreFocus",
		"getClientArea",
		"WM_SIZE",
		"isDisposed",
		"sendEvent",
		"WM_SYSCOMMAND",
		"PostMessage",
		"traverseDecorations",
		"WM_WINDOWPOSCHANGING",
		"MoveMemory",
		"MoveMemory",
		"Event",
		"RECT",
		"RECT",
		"Rectangle",
		"ACCEL",
		"Image",
		"ICONINFO",
		"WINDOWPLACEMENT",
		"Rectangle",
		"WINDOWPLACEMENT",
		"RECT",
		"Rectangle",
		"WINDOWPLACEMENT",
		"Point",
		"WINDOWPLACEMENT",
		"Point",
		"TCHAR",
		"RECT",
		"RECT",
		"RECT",
		"WINDOWPLACEMENT",
		"MENUITEMINFO",
		"TCHAR",
		"CREATESTRUCT",
		"TCHAR",
		"WINDOWPOS"
	],
	"methodsBody":{
		"public Menu getMenuBar()":{
			"methodBody":"{\n    checkWidget();\n    return menuBar;\n}",
			"comments":"/**\n* Returns the receiver's menu bar if one had previously\n* been set, otherwise returns null.\n*\n* @return the menu bar or null\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Menu getMenuBar()"
		},
		"public void setText(String string)":{
			"methodBody":"{\n    checkWidget();\n    if (string == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    \n    TCHAR buffer = new TCHAR(0, string, true);\n    OS.SetWindowText(handle, buffer);\n}",
			"comments":"/**\n* Sets the receiver's text, which is the string that the\n* window manager will typically display as the receiver's\n* <em>title</em>, to the argument, which must not be null.\n*\n* @param string the new text\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the text is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/* Use the character encoding for the default locale */\n",
			"methodName":"public void setText(String string)"
		},
		"int windowProc(int hwnd, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    switch(msg) {\n        case Display.SWT_GETACCEL:\n        case Display.SWT_GETACCELCOUNT:\n            if (hAccel == -1)\n                createAccelerators();\n            return msg == Display.SWT_GETACCELCOUNT ? nAccel : hAccel;\n    }\n    return super.windowProc(hwnd, msg, wParam, lParam);\n}",
			"comments":"",
			"methodName":"int windowProc(int hwnd, int msg, int wParam, int lParam)"
		},
		"Menu findMenu(int hMenu)":{
			"methodBody":"{\n    if (menus == null)\n        return null;\n    for (int i = 0; i < menus.length; i++) {\n        Menu menu = menus[i];\n        if (menu != null && hMenu == menu.handle)\n            return menu;\n    }\n    return null;\n}",
			"comments":"",
			"methodName":"Menu findMenu(int hMenu)"
		},
		"public Point getLocation()":{
			"methodBody":"{\n    checkWidget();\n    if (!OS.IsWinCE) {\n        if (OS.IsIconic(handle)) {\n            WINDOWPLACEMENT lpwndpl = new WINDOWPLACEMENT();\n            lpwndpl.length = WINDOWPLACEMENT.sizeof;\n            OS.GetWindowPlacement(handle, lpwndpl);\n            return new Point(lpwndpl.left, lpwndpl.top);\n        }\n    }\n    return super.getLocation();\n}",
			"comments":"",
			"methodName":"public Point getLocation()"
		},
		"boolean isTabGroup()":{
			"methodBody":"{\n    \n    return true;\n}",
			"comments":"/*\n* Can't test WS_TAB bits because they are the same as WS_MAXIMIZEBOX.\n*/\n",
			"methodName":"boolean isTabGroup()"
		},
		"public Image[] getImages()":{
			"methodBody":"{\n    checkWidget();\n    if (images == null)\n        return new Image[0];\n    Image[] result = new Image[images.length];\n    System.arraycopy(images, 0, result, 0, images.length);\n    return result;\n}",
			"comments":"/**\n* Returns the receiver's images if they had previously been\n* set using <code>setImages()</code>. Images are typically\n* displayed by the window manager when the instance is\n* marked as iconified, and may also be displayed somewhere\n* in the trim when the instance is in normal or maximized\n* states. Depending where the icon is displayed, the platform\n* chooses the icon with the \"best\" attributes.  It is expected\n* that the array will contain the same icon rendered at different\n* sizes, with different depth and transparency attributes.\n*\n* <p>\n* Note: This method will return an empty array if called before\n* <code>setImages()</code> is called. It does not provide\n* access to a window manager provided, \"default\" image\n* even if one exists.\n* </p>\n*\n* @return the images\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public Image[] getImages()"
		},
		"void setDefaultButton(Button button, boolean save)":{
			"methodBody":"{\n    if (button == null) {\n        if (defaultButton == saveDefault) {\n            if (save)\n                saveDefault = null;\n            return;\n        }\n    } else {\n        if (button.isDisposed())\n            error(SWT.ERROR_INVALID_ARGUMENT);\n        if ((button.style & SWT.PUSH) == 0)\n            return;\n        if (button == defaultButton)\n            return;\n    }\n    if (defaultButton != null) {\n        if (!defaultButton.isDisposed())\n            defaultButton.setDefault(false);\n    }\n    if ((defaultButton = button) == null)\n        defaultButton = saveDefault;\n    if (defaultButton != null) {\n        if (!defaultButton.isDisposed())\n            defaultButton.setDefault(true);\n    }\n    if (save)\n        saveDefault = defaultButton;\n    if (saveDefault != null && saveDefault.isDisposed())\n        saveDefault = null;\n}",
			"comments":"",
			"methodName":"void setDefaultButton(Button button, boolean save)"
		},
		"void removeMenu(Menu menu)":{
			"methodBody":"{\n    if (menus == null)\n        return;\n    for (int i = 0; i < menus.length; i++) {\n        if (menus[i] == menu) {\n            menus[i] = null;\n            return;\n        }\n    }\n}",
			"comments":"",
			"methodName":"void removeMenu(Menu menu)"
		},
		"LRESULT WM_SETFOCUS(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_SETFOCUS(wParam, lParam);\n    if (savedFocus != this)\n        restoreFocus();\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_SETFOCUS(int wParam, int lParam)"
		},
		"protected void checkSubclass()":{
			"methodBody":"{\n    if (!isValidSubclass())\n        error(SWT.ERROR_INVALID_SUBCLASS);\n}",
			"comments":"",
			"methodName":"protected void checkSubclass()"
		},
		"public boolean getMaximized()":{
			"methodBody":"{\n    checkWidget();\n    if (OS.IsWinCE)\n        return swFlags == OS.SW_SHOWMAXIMIZED;\n    if (OS.IsWindowVisible(handle))\n        return OS.IsZoomed(handle);\n    return swFlags == OS.SW_SHOWMAXIMIZED;\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver is currently\n* maximized, and false otherwise.\n* <p>\n*\n* @return the maximized state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #setMaximized\n*/\n",
			"methodName":"public boolean getMaximized()"
		},
		"boolean translateMDIAccelerator(MSG msg)":{
			"methodBody":"{\n    if (!(this instanceof Shell)) {\n        Shell shell = getShell();\n        int hwndMDIClient = shell.hwndMDIClient;\n        if (hwndMDIClient != 0 && OS.TranslateMDISysAccel(hwndMDIClient, msg)) {\n            return true;\n        }\n        if (msg.message == OS.WM_KEYDOWN) {\n            if (OS.GetKeyState(OS.VK_CONTROL) >= 0)\n                return false;\n            switch(msg.wParam) {\n                case OS.VK_F4:\n                    OS.PostMessage(handle, OS.WM_CLOSE, 0, 0);\n                    return true;\n                case OS.VK_F6:\n                    if (traverseDecorations(true))\n                        return true;\n            }\n            return false;\n        }\n        if (msg.message == OS.WM_SYSKEYDOWN) {\n            switch(msg.wParam) {\n                case OS.VK_F4:\n                    OS.PostMessage(shell.handle, OS.WM_CLOSE, 0, 0);\n                    return true;\n            }\n            return false;\n        }\n    }\n    return false;\n}",
			"comments":"",
			"methodName":"boolean translateMDIAccelerator(MSG msg)"
		},
		"void addMenu(Menu menu)":{
			"methodBody":"{\n    if (menus == null)\n        menus = new Menu[4];\n    for (int i = 0; i < menus.length; i++) {\n        if (menus[i] == null) {\n            menus[i] = menu;\n            return;\n        }\n    }\n    Menu[] newMenus = new Menu[menus.length + 4];\n    newMenus[menus.length] = menu;\n    System.arraycopy(menus, 0, newMenus, 0, menus.length);\n    menus = newMenus;\n}",
			"comments":"",
			"methodName":"void addMenu(Menu menu)"
		},
		"public Button getDefaultButton()":{
			"methodBody":"{\n    checkWidget();\n    return defaultButton;\n}",
			"comments":"/**\n* Returns the receiver's default button if one had\n* previously been set, otherwise returns null.\n*\n* @return the default button or null\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #setDefaultButton\n*/\n",
			"methodName":"public Button getDefaultButton()"
		},
		"LRESULT WM_MOVE(int wParam, int lParam)":{
			"methodBody":"{\n    if (moved) {\n        Point location = getLocation();\n        if (location.x == oldX && location.y == oldY) {\n            return null;\n        }\n        oldX = location.x;\n        oldY = location.y;\n    }\n    return super.WM_MOVE(wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT WM_MOVE(int wParam, int lParam)"
		},
		"boolean translateMenuAccelerator(MSG msg)":{
			"methodBody":"{\n    if (hAccel == -1)\n        createAccelerators();\n    return hAccel != 0 && OS.TranslateAccelerator(handle, hAccel, msg) != 0;\n}",
			"comments":"",
			"methodName":"boolean translateMenuAccelerator(MSG msg)"
		},
		"void createWidget()":{
			"methodBody":"{\n    super.createWidget();\n    swFlags = OS.IsWinCE ? OS.SW_SHOWMAXIMIZED : OS.SW_SHOWNOACTIVATE;\n    hAccel = -1;\n}",
			"comments":"",
			"methodName":"void createWidget()"
		},
		"void setPlacement(int x, int y, int width, int height, int flags)":{
			"methodBody":"{\n    WINDOWPLACEMENT lpwndpl = new WINDOWPLACEMENT();\n    lpwndpl.length = WINDOWPLACEMENT.sizeof;\n    OS.GetWindowPlacement(handle, lpwndpl);\n    lpwndpl.showCmd = OS.SW_SHOWNA;\n    if (OS.IsIconic(handle)) {\n        lpwndpl.showCmd = OS.SW_SHOWMINNOACTIVE;\n    } else {\n        if (OS.IsZoomed(handle)) {\n            lpwndpl.showCmd = OS.SW_SHOWMAXIMIZED;\n        }\n    }\n    boolean sameOrigin = true;\n    if ((flags & OS.SWP_NOMOVE) == 0) {\n        sameOrigin = lpwndpl.left != x || lpwndpl.top != y;\n        lpwndpl.right = x + (lpwndpl.right - lpwndpl.left);\n        lpwndpl.bottom = y + (lpwndpl.bottom - lpwndpl.top);\n        lpwndpl.left = x;\n        lpwndpl.top = y;\n    }\n    boolean sameExtent = true;\n    if ((flags & OS.SWP_NOSIZE) == 0) {\n        sameExtent = lpwndpl.right - lpwndpl.left != width || lpwndpl.bottom - lpwndpl.top != height;\n        lpwndpl.right = lpwndpl.left + width;\n        lpwndpl.bottom = lpwndpl.top + height;\n    }\n    OS.SetWindowPlacement(handle, lpwndpl);\n    if (OS.IsIconic(handle)) {\n        if (sameOrigin) {\n            moved = true;\n            Point location = getLocation();\n            oldX = location.x;\n            oldY = location.y;\n            sendEvent(SWT.Move);\n            if (isDisposed())\n                return;\n        }\n        if (sameExtent) {\n            resized = true;\n            Rectangle rect = getClientArea();\n            oldWidth = rect.width;\n            oldHeight = rect.height;\n            sendEvent(SWT.Resize);\n            if (isDisposed())\n                return;\n            if (layout != null) {\n                markLayout(false, false);\n                updateLayout(true, false);\n            }\n        }\n    }\n}",
			"comments":"",
			"methodName":"void setPlacement(int x, int y, int width, int height, int flags)"
		},
		"int widgetParent()":{
			"methodBody":"{\n    Shell shell = getShell();\n    return shell.hwndMDIClient();\n}",
			"comments":"",
			"methodName":"int widgetParent()"
		},
		"void setBounds(int x, int y, int width, int height, int flags, boolean defer)":{
			"methodBody":"{\n    if (OS.IsWinCE) {\n        swFlags = OS.SW_RESTORE;\n    } else {\n        if (OS.IsIconic(handle)) {\n            setPlacement(x, y, width, height, flags);\n            return;\n        }\n    }\n    forceResize();\n    RECT rect = new RECT();\n    OS.GetWindowRect(handle, rect);\n    boolean sameOrigin = true;\n    if ((OS.SWP_NOMOVE & flags) == 0) {\n        sameOrigin = rect.left == x && rect.top == y;\n        if (!sameOrigin)\n            moved = true;\n    }\n    boolean sameExtent = true;\n    if ((OS.SWP_NOSIZE & flags) == 0) {\n        sameExtent = rect.right - rect.left == width && rect.bottom - rect.top == height;\n        if (!sameExtent)\n            resized = true;\n    }\n    if (!OS.IsWinCE) {\n        if (OS.IsZoomed(handle)) {\n            if (sameOrigin && sameExtent)\n                return;\n            setPlacement(x, y, width, height, flags);\n            setMaximized(false);\n            return;\n        }\n    }\n    super.setBounds(x, y, width, height, flags, defer);\n}",
			"comments":"",
			"methodName":"void setBounds(int x, int y, int width, int height, int flags, boolean defer)"
		},
		"void checkBorder()":{
			"methodBody":"{\n\n}",
			"comments":"/* Do nothing */\n",
			"methodName":"void checkBorder()"
		},
		"boolean traverseReturn()":{
			"methodBody":"{\n    if (defaultButton == null || defaultButton.isDisposed())\n        return false;\n    if (!defaultButton.isVisible() || !defaultButton.isEnabled())\n        return false;\n    defaultButton.click();\n    return true;\n}",
			"comments":"",
			"methodName":"boolean traverseReturn()"
		},
		"void setImages(Image image, Image[] images)":{
			"methodBody":"{\n    \n    if (OS.IsWinCE)\n        return;\n    if (smallImage != null)\n        smallImage.dispose();\n    if (largeImage != null)\n        largeImage.dispose();\n    smallImage = largeImage = null;\n    int hSmallIcon = 0, hLargeIcon = 0;\n    Image smallIcon = null, largeIcon = null;\n    if (image != null) {\n        smallIcon = largeIcon = image;\n    } else {\n        if (images != null && images.length > 0) {\n            int depth = display.getIconDepth();\n            ImageData[] datas = null;\n            if (images.length > 1) {\n                Image[] bestImages = new Image[images.length];\n                System.arraycopy(images, 0, bestImages, 0, images.length);\n                datas = new ImageData[images.length];\n                for (int i = 0; i < datas.length; i++) {\n                    datas[i] = images[i].getImageData();\n                }\n                images = bestImages;\n                sort(images, datas, OS.GetSystemMetrics(OS.SM_CXSMICON), OS.GetSystemMetrics(OS.SM_CYSMICON), depth);\n            }\n            smallIcon = images[0];\n            if (images.length > 1) {\n                sort(images, datas, OS.GetSystemMetrics(OS.SM_CXICON), OS.GetSystemMetrics(OS.SM_CYICON), depth);\n            }\n            largeIcon = images[0];\n        }\n    }\n    if (smallIcon != null) {\n        switch(smallIcon.type) {\n            case SWT.BITMAP:\n                smallImage = createIcon(smallIcon);\n                hSmallIcon = smallImage.handle;\n                break;\n            case SWT.ICON:\n                hSmallIcon = smallIcon.handle;\n                break;\n        }\n    }\n    OS.SendMessage(handle, OS.WM_SETICON, OS.ICON_SMALL, hSmallIcon);\n    if (largeIcon != null) {\n        switch(largeIcon.type) {\n            case SWT.BITMAP:\n                largeImage = createIcon(largeIcon);\n                hLargeIcon = largeImage.handle;\n                break;\n            case SWT.ICON:\n                hLargeIcon = largeIcon.handle;\n                break;\n        }\n    }\n    OS.SendMessage(handle, OS.WM_SETICON, OS.ICON_BIG, hLargeIcon);\n    \n    if (!OS.IsWinCE) {\n        if (hSmallIcon == 0 && hLargeIcon == 0 && (style & SWT.BORDER) != 0) {\n            int flags = OS.RDW_FRAME | OS.RDW_INVALIDATE;\n            OS.RedrawWindow(handle, null, 0, flags);\n        }\n    }\n}",
			"comments":"/*\n* Feature in WinCE.  WM_SETICON and WM_GETICON set the icon\n* for the window class, not the window instance.  This means\n* that it is possible to set an icon into a window and then\n* later free the icon, thus freeing the icon for every window.\n* The fix is to avoid the API.\n*\n* On WinCE PPC, icons in windows are not displayed.\n*/\n/*\n* Bug in Windows.  When WM_SETICON is used to remove an\n* icon from the window trimmings for a window with the\n* extended style bits WS_EX_DLGMODALFRAME, the window\n* trimmings do not redraw to hide the previous icon.\n* The fix is to force a redraw.\n*/\n",
			"methodName":"void setImages(Image image, Image[] images)"
		},
		"boolean traverseDecorations(boolean next)":{
			"methodBody":"{\n    Control[] children = parent._getChildren();\n    int length = children.length;\n    int index = 0;\n    while (index < length) {\n        if (children[index] == this)\n            break;\n        index++;\n    }\n    \n    int start = index, offset = (next) ? 1 : -1;\n    while ((index = (index + offset + length) % length) != start) {\n        Control child = children[index];\n        if (!child.isDisposed() && child instanceof Decorations) {\n            if (child.setFocus())\n                return true;\n        }\n    }\n    return false;\n}",
			"comments":"/*\n* It is possible (but unlikely), that application\n* code could have disposed the widget in focus in\n* or out events.  Ensure that a disposed widget is\n* not accessed.\n*/\n",
			"methodName":"boolean traverseDecorations(boolean next)"
		},
		"int widgetExtStyle()":{
			"methodBody":"{\n    int bits = super.widgetExtStyle() | OS.WS_EX_MDICHILD;\n    bits &= ~OS.WS_EX_CLIENTEDGE;\n    if ((style & SWT.NO_TRIM) != 0)\n        return bits;\n    if (OS.IsPPC) {\n        if ((style & SWT.CLOSE) != 0)\n            bits |= OS.WS_EX_CAPTIONOKBTN;\n    }\n    if ((style & SWT.RESIZE) != 0)\n        return bits;\n    if ((style & SWT.BORDER) != 0)\n        bits |= OS.WS_EX_DLGMODALFRAME;\n    return bits;\n}",
			"comments":"",
			"methodName":"int widgetExtStyle()"
		},
		"public Image getImage()":{
			"methodBody":"{\n    checkWidget();\n    return image;\n}",
			"comments":"/**\n* Returns the receiver's image if it had previously been\n* set using <code>setImage()</code>. The image is typically\n* displayed by the window manager when the instance is\n* marked as iconified, and may also be displayed somewhere\n* in the trim when the instance is in normal or maximized\n* states.\n* <p>\n* Note: This method will return null if called before\n* <code>setImage()</code> is called. It does not provide\n* access to a window manager provided, \"default\" image\n* even if one exists.\n* </p>\n*\n* @return the image\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Image getImage()"
		},
		"LRESULT WM_SIZE(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = null;\n    boolean changed = true;\n    if (resized) {\n        int newWidth = 0, newHeight = 0;\n        switch(wParam) {\n            case OS.SIZE_RESTORED:\n            case OS.SIZE_MAXIMIZED:\n                newWidth = lParam & 0xFFFF;\n                newHeight = lParam >> 16;\n                break;\n            case OS.SIZE_MINIMIZED:\n                Rectangle rect = getClientArea();\n                newWidth = rect.width;\n                newHeight = rect.height;\n                break;\n        }\n        changed = newWidth != oldWidth || newHeight != oldHeight;\n        if (changed) {\n            oldWidth = newWidth;\n            oldHeight = newHeight;\n        }\n    }\n    if (changed) {\n        result = super.WM_SIZE(wParam, lParam);\n        if (isDisposed())\n            return result;\n    }\n    if (wParam == OS.SIZE_MINIMIZED) {\n        sendEvent(SWT.Iconify);\n    \n    }\n    return result;\n}",
			"comments":"// widget could be disposed at this point\n",
			"methodName":"LRESULT WM_SIZE(int wParam, int lParam)"
		},
		"LRESULT WM_HOTKEY(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_HOTKEY(wParam, lParam);\n    if (result != null)\n        return result;\n    if (OS.IsSP) {\n        \n        if (((lParam >> 16) & 0xFFFF) == OS.VK_ESCAPE) {\n            if ((style & SWT.CLOSE) != 0) {\n                OS.PostMessage(handle, OS.WM_CLOSE, 0, 0);\n            } else {\n                OS.SHSendBackToFocusWindow(OS.WM_HOTKEY, wParam, lParam);\n            }\n            return LRESULT.ZERO;\n        }\n    }\n    return result;\n}",
			"comments":"/*\n* Feature on WinCE SP.  The Back key is either used to close\n* the foreground Dialog or used as a regular Back key in an EDIT\n* control. The article 'Back Key' in MSDN for Smartphone\n* describes how an application should handle it.  The\n* workaround is to override the Back key when creating\n* the menubar and handle it based on the style of the Shell.\n* If the Shell has the SWT.CLOSE style, close the Shell.\n* Otherwise, send the Back key to the window with focus.\n*/\n",
			"methodName":"LRESULT WM_HOTKEY(int wParam, int lParam)"
		},
		"public Rectangle getBounds()":{
			"methodBody":"{\n    checkWidget();\n    if (!OS.IsWinCE) {\n        if (OS.IsIconic(handle)) {\n            WINDOWPLACEMENT lpwndpl = new WINDOWPLACEMENT();\n            lpwndpl.length = WINDOWPLACEMENT.sizeof;\n            OS.GetWindowPlacement(handle, lpwndpl);\n            int width = lpwndpl.right - lpwndpl.left;\n            int height = lpwndpl.bottom - lpwndpl.top;\n            return new Rectangle(lpwndpl.left, lpwndpl.top, width, height);\n        }\n    }\n    return super.getBounds();\n}",
			"comments":"",
			"methodName":"public Rectangle getBounds()"
		},
		"void saveFocus()":{
			"methodBody":"{\n    Control control = display._getFocusControl();\n    if (control != null && control != this && this == control.menuShell()) {\n        setSavedFocus(control);\n    }\n}",
			"comments":"",
			"methodName":"void saveFocus()"
		},
		"public Point getSize()":{
			"methodBody":"{\n    checkWidget();\n    if (!OS.IsWinCE) {\n        if (OS.IsIconic(handle)) {\n            WINDOWPLACEMENT lpwndpl = new WINDOWPLACEMENT();\n            lpwndpl.length = WINDOWPLACEMENT.sizeof;\n            OS.GetWindowPlacement(handle, lpwndpl);\n            int width = lpwndpl.right - lpwndpl.left;\n            int height = lpwndpl.bottom - lpwndpl.top;\n            return new Point(width, height);\n        }\n    }\n    return super.getSize();\n}",
			"comments":"",
			"methodName":"public Point getSize()"
		},
		"public void setMaximized(boolean maximized)":{
			"methodBody":"{\n    checkWidget();\n    swFlags = maximized ? OS.SW_SHOWMAXIMIZED : OS.SW_RESTORE;\n    if (OS.IsWinCE) {\n        \n        if (maximized) {\n            RECT rect = new RECT();\n            OS.SystemParametersInfo(OS.SPI_GETWORKAREA, 0, rect, 0);\n            int width = rect.right - rect.left, height = rect.bottom - rect.top;\n            if (OS.IsPPC) {\n                \n                if (menuBar != null) {\n                    int hwndCB = menuBar.hwndCB;\n                    RECT rectCB = new RECT();\n                    OS.GetWindowRect(hwndCB, rectCB);\n                    height -= rectCB.bottom - rectCB.top;\n                }\n            }\n            int flags = OS.SWP_NOZORDER | OS.SWP_DRAWFRAME | OS.SWP_NOACTIVATE;\n            SetWindowPos(handle, 0, rect.left, rect.top, width, height, flags);\n        }\n    } else {\n        if (!OS.IsWindowVisible(handle))\n            return;\n        if (maximized == OS.IsZoomed(handle))\n            return;\n        OS.ShowWindow(handle, swFlags);\n        OS.UpdateWindow(handle);\n    }\n}",
			"comments":"/**\n* Sets the maximized state of the receiver.\n* If the argument is <code>true</code> causes the receiver\n* to switch to the maximized state, and if the argument is\n* <code>false</code> and the receiver was previously maximized,\n* causes the receiver to switch back to either the minimized\n* or normal states.\n* <p>\n* Note: The result of intermixing calls to <code>setMaximized(true)</code>\n* and <code>setMinimized(true)</code> will vary by platform. Typically,\n* the behavior will match the platform user's expectations, but not\n* always. This should be avoided if possible.\n* </p>\n*\n* @param maximized the new maximized state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #setMinimized\n*/\n/*\n* Note: WinCE does not support SW_SHOWMAXIMIZED and SW_RESTORE. The\n* workaround is to resize the window to fit the parent client area.\n*/\n/* Leave space for the menu bar */\n",
			"methodName":"public void setMaximized(boolean maximized)"
		},
		"void setSystemMenu()":{
			"methodBody":"{\n    if (OS.IsWinCE)\n        return;\n    int hMenu = OS.GetSystemMenu(handle, false);\n    if (hMenu == 0)\n        return;\n    int oldCount = OS.GetMenuItemCount(hMenu);\n    if ((style & SWT.RESIZE) == 0) {\n        OS.DeleteMenu(hMenu, OS.SC_SIZE, OS.MF_BYCOMMAND);\n    }\n    if ((style & SWT.MIN) == 0) {\n        OS.DeleteMenu(hMenu, OS.SC_MINIMIZE, OS.MF_BYCOMMAND);\n    }\n    if ((style & SWT.MAX) == 0) {\n        OS.DeleteMenu(hMenu, OS.SC_MAXIMIZE, OS.MF_BYCOMMAND);\n    }\n    if ((style & (SWT.MIN | SWT.MAX)) == 0) {\n        OS.DeleteMenu(hMenu, OS.SC_RESTORE, OS.MF_BYCOMMAND);\n    }\n    int newCount = OS.GetMenuItemCount(hMenu);\n    if ((style & SWT.CLOSE) == 0 || newCount != oldCount) {\n        OS.DeleteMenu(hMenu, OS.SC_TASKLIST, OS.MF_BYCOMMAND);\n        MENUITEMINFO info = new MENUITEMINFO();\n        info.cbSize = MENUITEMINFO.sizeof;\n        info.fMask = OS.MIIM_ID;\n        int index = 0;\n        while (index < newCount) {\n            if (OS.GetMenuItemInfo(hMenu, index, true, info)) {\n                if (info.wID == OS.SC_CLOSE)\n                    break;\n            }\n            index++;\n        }\n        if (index != newCount) {\n            OS.DeleteMenu(hMenu, index - 1, OS.MF_BYPOSITION);\n            if ((style & SWT.CLOSE) == 0) {\n                OS.DeleteMenu(hMenu, OS.SC_CLOSE, OS.MF_BYCOMMAND);\n            }\n        }\n    }\n}",
			"comments":"",
			"methodName":"void setSystemMenu()"
		},
		"void createHandle()":{
			"methodBody":"{\n    super.createHandle();\n    if (parent != null || ((style & SWT.TOOL) != 0)) {\n        setParent();\n        setSystemMenu();\n    }\n}",
			"comments":"",
			"methodName":"void createHandle()"
		},
		"void destroyAccelerators()":{
			"methodBody":"{\n    if (hAccel != 0 && hAccel != -1)\n        OS.DestroyAcceleratorTable(hAccel);\n    hAccel = -1;\n}",
			"comments":"",
			"methodName":"void destroyAccelerators()"
		},
		"public void setMinimized(boolean minimized)":{
			"methodBody":"{\n    checkWidget();\n    if (OS.IsWinCE)\n        return;\n    swFlags = minimized ? OS.SW_SHOWMINNOACTIVE : OS.SW_RESTORE;\n    if (!OS.IsWindowVisible(handle))\n        return;\n    if (minimized == OS.IsIconic(handle))\n        return;\n    int flags = swFlags;\n    if (flags == OS.SW_SHOWMINNOACTIVE && handle == OS.GetActiveWindow()) {\n        flags = OS.SW_MINIMIZE;\n    }\n    OS.ShowWindow(handle, flags);\n    OS.UpdateWindow(handle);\n}",
			"comments":"/**\n* Sets the minimized stated of the receiver.\n* If the argument is <code>true</code> causes the receiver\n* to switch to the minimized state, and if the argument is\n* <code>false</code> and the receiver was previously minimized,\n* causes the receiver to switch back to either the maximized\n* or normal states.\n* <p>\n* Note: The result of intermixing calls to <code>setMaximized(true)</code>\n* and <code>setMinimized(true)</code> will vary by platform. Typically,\n* the behavior will match the platform user's expectations, but not\n* always. This should be avoided if possible.\n* </p>\n*\n* @param minimized the new maximized state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #setMaximized\n*/\n",
			"methodName":"public void setMinimized(boolean minimized)"
		},
		"String getNameText()":{
			"methodBody":"{\n    return getText();\n}",
			"comments":"",
			"methodName":"String getNameText()"
		},
		"void closeWidget()":{
			"methodBody":"{\n    Event event = new Event();\n    sendEvent(SWT.Close, event);\n    if (event.doit && !isDisposed())\n        dispose();\n}",
			"comments":"",
			"methodName":"void closeWidget()"
		},
		"public String getText()":{
			"methodBody":"{\n    checkWidget();\n    int length = OS.GetWindowTextLength(handle);\n    if (length == 0)\n        return \"\";\n    \n    TCHAR buffer = new TCHAR(0, length + 1);\n    OS.GetWindowText(handle, buffer, length + 1);\n    return buffer.toString(0, length);\n}",
			"comments":"/**\n* Returns the receiver's text, which is the string that the\n* window manager will typically display as the receiver's\n* <em>title</em>. If the text has not previously been set,\n* returns an empty string.\n*\n* @return the text\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/* Use the character encoding for the default locale */\n",
			"methodName":"public String getText()"
		},
		"void bringToTop()":{
			"methodBody":"{\n    \n    \n    \n    \n    \n    OS.BringWindowToTop(handle);\n\n\n}",
			"comments":"/*\n* This code is intentionally commented.  On some platforms,\n* the ON_TOP style creates a shell that will stay on top\n* of every other shell on the desktop.  Using SetWindowPos ()\n* with HWND_TOP caused problems on Windows 98 so this code is\n* commented out until this functionality is specified and\n* the problems are fixed.\n*/\n//\tif ((style & SWT.ON_TOP) != 0) {\n//\t\tint flags = OS.SWP_NOSIZE | OS.SWP_NOMOVE | OS.SWP_NOACTIVATE;\n//\t\tOS.SetWindowPos (handle, OS.HWND_TOP, 0, 0, 0, 0, flags);\n//\t} else {\n// widget could be disposed at this point\n//\t}\n",
			"methodName":"void bringToTop()"
		},
		"int widgetStyle()":{
			"methodBody":"{\n    \n    int bits = super.widgetStyle() & ~(OS.WS_TABSTOP | OS.WS_VISIBLE);\n    \n    bits &= ~OS.WS_BORDER;\n    if ((style & SWT.NO_TRIM) != 0)\n        return bits;\n    if ((style & SWT.TITLE) != 0)\n        bits |= OS.WS_CAPTION;\n    \n    if ((style & SWT.MIN) != 0)\n        bits |= OS.WS_MINIMIZEBOX;\n    if ((style & SWT.MAX) != 0)\n        bits |= OS.WS_MAXIMIZEBOX;\n    \n    if ((style & SWT.RESIZE) != 0) {\n        \n        if (!OS.IsPPC)\n            bits |= OS.WS_THICKFRAME;\n    } else {\n        if ((style & SWT.BORDER) == 0)\n            bits |= OS.WS_BORDER;\n    }\n    \n    if (!OS.IsPPC && !OS.IsSP) {\n        if ((style & SWT.CLOSE) != 0)\n            bits |= OS.WS_SYSMENU;\n    }\n    return bits;\n}",
			"comments":"/*\n* Clear WS_VISIBLE and WS_TABSTOP.  NOTE: In Windows, WS_TABSTOP\n* has the same value as WS_MAXIMIZEBOX so these bits cannot be\n* used to control tabbing.\n*/\n/* Set the title bits and no-trim bits */\n/* Set the min and max button bits */\n/* Set the resize, dialog border or border bits */\n/*\n* Note on WinCE PPC.  SWT.RESIZE is used to resize\n* the Shell according to the state of the IME.\n* It does not set the WS_THICKFRAME style.\n*/\n/* Set the system menu and close box bits */\n",
			"methodName":"int widgetStyle()"
		},
		"int compare(ImageData data1, ImageData data2, int width, int height, int depth)":{
			"methodBody":"{\n    int value1 = Math.abs(data1.width - width), value2 = Math.abs(data2.width - width);\n    if (value1 == value2) {\n        int transparent1 = data1.getTransparencyType();\n        int transparent2 = data2.getTransparencyType();\n        if (transparent1 == transparent2) {\n            if (data1.depth == data2.depth)\n                return 0;\n            return data1.depth > data2.depth && data1.depth <= depth ? -1 : 1;\n        }\n        if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION(5, 1)) {\n            if (transparent1 == SWT.TRANSPARENCY_ALPHA)\n                return -1;\n            if (transparent2 == SWT.TRANSPARENCY_ALPHA)\n                return 1;\n        }\n        if (transparent1 == SWT.TRANSPARENCY_MASK)\n            return -1;\n        if (transparent2 == SWT.TRANSPARENCY_MASK)\n            return 1;\n        if (transparent1 == SWT.TRANSPARENCY_PIXEL)\n            return -1;\n        if (transparent2 == SWT.TRANSPARENCY_PIXEL)\n            return 1;\n        return 0;\n    }\n    return value1 < value2 ? -1 : 1;\n}",
			"comments":"",
			"methodName":"int compare(ImageData data1, ImageData data2, int width, int height, int depth)"
		},
		"public void setDefaultButton(Button button)":{
			"methodBody":"{\n    checkWidget();\n    setDefaultButton(button, true);\n}",
			"comments":"/**\n* If the argument is not null, sets the receiver's default\n* button to the argument, and if the argument is null, sets\n* the receiver's default button to the first button which\n* was set as the receiver's default button (called the\n* <em>saved default button</em>). If no default button had\n* previously been set, or the saved default button was\n* disposed, the receiver's default button will be set to\n* null.\n* <p>\n* The default button is the button that is selected when\n* the receiver is active and the user presses ENTER.\n* </p>\n*\n* @param button the new default button\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the button has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setDefaultButton(Button button)"
		},
		"LRESULT WM_NCACTIVATE(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_NCACTIVATE(wParam, lParam);\n    if (result != null)\n        return result;\n    if (wParam == 0) {\n        if (display.lockActiveWindow)\n            return LRESULT.ZERO;\n        Control control = display.findControl(lParam);\n        if (control != null) {\n            Shell shell = getShell();\n            Decorations decorations = control.menuShell();\n            if (decorations.getShell() == shell) {\n                if (this instanceof Shell)\n                    return LRESULT.ONE;\n                if (display.ignoreRestoreFocus) {\n                    if (display.lastHittest != OS.HTCLIENT) {\n                        result = LRESULT.ONE;\n                    }\n                }\n            }\n        }\n    }\n    if (!(this instanceof Shell)) {\n        int hwndShell = getShell().handle;\n        OS.SendMessage(hwndShell, OS.WM_NCACTIVATE, wParam, lParam);\n    }\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_NCACTIVATE(int wParam, int lParam)"
		},
		"void fixDecorations(Decorations newDecorations, Control control, Menu[] menus)":{
			"methodBody":"{\n    if (this == newDecorations)\n        return;\n    if (control == savedFocus)\n        savedFocus = null;\n    if (control == defaultButton)\n        defaultButton = null;\n    if (control == saveDefault)\n        saveDefault = null;\n    if (menus == null)\n        return;\n    Menu menu = control.menu;\n    if (menu != null) {\n        int index = 0;\n        while (index < menus.length) {\n            if (menus[index] == menu) {\n                control.setMenu(null);\n                return;\n            }\n            index++;\n        }\n        menu.fixMenus(newDecorations);\n        destroyAccelerators();\n        newDecorations.destroyAccelerators();\n    }\n}",
			"comments":"",
			"methodName":"void fixDecorations(Decorations newDecorations, Control control, Menu[] menus)"
		},
		"Control computeTabRoot()":{
			"methodBody":"{\n    return this;\n}",
			"comments":"",
			"methodName":"Control computeTabRoot()"
		},
		"boolean translateAccelerator(MSG msg)":{
			"methodBody":"{\n    if (!isEnabled() || !isActive())\n        return false;\n    if (menuBar != null && !menuBar.isEnabled())\n        return false;\n    if (translateMDIAccelerator(msg) || translateMenuAccelerator(msg))\n        return true;\n    Decorations decorations = parent.menuShell();\n    return decorations.translateAccelerator(msg);\n}",
			"comments":"",
			"methodName":"boolean translateAccelerator(MSG msg)"
		},
		"LRESULT WM_QUERYOPEN(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_QUERYOPEN(wParam, lParam);\n    if (result != null)\n        return result;\n    sendEvent(SWT.Deiconify);\n    \n    return result;\n}",
			"comments":"// widget could be disposed at this point\n",
			"methodName":"LRESULT WM_QUERYOPEN(int wParam, int lParam)"
		},
		"void setSavedFocus(Control control)":{
			"methodBody":"{\n    savedFocus = control;\n}",
			"comments":"",
			"methodName":"void setSavedFocus(Control control)"
		},
		"void createAccelerators()":{
			"methodBody":"{\n    hAccel = nAccel = 0;\n    int maxAccel = 0;\n    MenuItem[] items = display.items;\n    if (menuBar == null || items == null) {\n        if (!OS.IsPPC)\n            return;\n        maxAccel = 1;\n    } else {\n        maxAccel = OS.IsPPC ? items.length + 1 : items.length;\n    }\n    ACCEL accel = new ACCEL();\n    byte[] buffer1 = new byte[ACCEL.sizeof];\n    byte[] buffer2 = new byte[maxAccel * ACCEL.sizeof];\n    if (menuBar != null && items != null) {\n        for (int i = 0; i < items.length; i++) {\n            MenuItem item = items[i];\n            if (item != null && item.accelerator != 0) {\n                Menu menu = item.parent;\n                if (menu.parent == this) {\n                    while (menu != null && menu != menuBar) {\n                        menu = menu.getParentMenu();\n                    }\n                    if (menu == menuBar) {\n                        item.fillAccel(accel);\n                        OS.MoveMemory(buffer1, accel, ACCEL.sizeof);\n                        System.arraycopy(buffer1, 0, buffer2, nAccel * ACCEL.sizeof, ACCEL.sizeof);\n                        nAccel++;\n                    }\n                }\n            }\n        }\n    }\n    if (OS.IsPPC) {\n        \n        accel.fVirt = (byte) (OS.FVIRTKEY | OS.FCONTROL);\n        accel.key = (short) 'Q';\n        accel.cmd = (short) OS.IDOK;\n        OS.MoveMemory(buffer1, accel, ACCEL.sizeof);\n        System.arraycopy(buffer1, 0, buffer2, nAccel * ACCEL.sizeof, ACCEL.sizeof);\n        nAccel++;\n    }\n    if (nAccel != 0)\n        hAccel = OS.CreateAcceleratorTable(buffer2, nAccel);\n}",
			"comments":"/*\n* Note on WinCE PPC.  Close the shell when user taps CTRL-Q.\n* IDOK represents the \"Done Button\" which also closes the shell.\n*/\n",
			"methodName":"void createAccelerators()"
		},
		"boolean restoreFocus()":{
			"methodBody":"{\n    if (display.ignoreRestoreFocus)\n        return true;\n    if (savedFocus != null && savedFocus.isDisposed())\n        savedFocus = null;\n    if (savedFocus != null && savedFocus.setSavedFocus())\n        return true;\n    \n    return false;\n}",
			"comments":"/*\n* This code is intentionally commented.  When no widget\n* has been given focus, some platforms give focus to the\n* default button.  Windows doesn't do this.\n*/\n//\tif (defaultButton != null && !defaultButton.isDisposed ()) {\n//\t\tif (defaultButton.setFocus ()) return true;\n//\t}\n",
			"methodName":"boolean restoreFocus()"
		},
		"void checkOpened()":{
			"methodBody":"{\n    if (!opened)\n        resized = false;\n}",
			"comments":"",
			"methodName":"void checkOpened()"
		},
		"Control computeTabGroup()":{
			"methodBody":"{\n    return this;\n}",
			"comments":"",
			"methodName":"Control computeTabGroup()"
		},
		"public Rectangle getClientArea()":{
			"methodBody":"{\n    checkWidget();\n    \n    if (OS.IsHPC) {\n        Rectangle rect = super.getClientArea();\n        if (menuBar != null) {\n            int hwndCB = menuBar.hwndCB;\n            int height = OS.CommandBar_Height(hwndCB);\n            rect.y += height;\n            rect.height -= height;\n        }\n        return rect;\n    }\n    if (!OS.IsWinCE) {\n        if (OS.IsIconic(handle)) {\n            WINDOWPLACEMENT lpwndpl = new WINDOWPLACEMENT();\n            lpwndpl.length = WINDOWPLACEMENT.sizeof;\n            OS.GetWindowPlacement(handle, lpwndpl);\n            int width = lpwndpl.right - lpwndpl.left;\n            int height = lpwndpl.bottom - lpwndpl.top;\n            \n            if (horizontalBar != null)\n                width -= OS.GetSystemMetrics(OS.SM_CYHSCROLL);\n            if (verticalBar != null)\n                height -= OS.GetSystemMetrics(OS.SM_CXVSCROLL);\n            RECT rect = new RECT();\n            int bits1 = OS.GetWindowLong(handle, OS.GWL_STYLE);\n            int bits2 = OS.GetWindowLong(handle, OS.GWL_EXSTYLE);\n            boolean hasMenu = OS.IsWinCE ? false : OS.GetMenu(handle) != 0;\n            OS.AdjustWindowRectEx(rect, bits1, hasMenu, bits2);\n            width = Math.max(0, width - (rect.right - rect.left));\n            height = Math.max(0, height - (rect.bottom - rect.top));\n            return new Rectangle(0, 0, width, height);\n        }\n    }\n    return super.getClientArea();\n}",
			"comments":"/*\n* Note: The CommandBar is part of the client area,\n* not the trim.  Applications don't expect this so\n* subtract the height of the CommandBar.\n*/\n/*\n* Feature in Windows.  For some reason WM_NCCALCSIZE does\n* not compute the client area when the window is minimized.\n* The fix is to compute it using AdjustWindowRectEx() and\n* GetSystemMetrics().\n*\n* NOTE: This code fails to compute the correct client area\n* for a minimized window where the menu bar would wrap were\n* the window restored.  There is no fix for this problem at\n* this time.\n*/\n",
			"methodName":"public Rectangle getClientArea()"
		},
		"public Rectangle computeTrim(int x, int y, int width, int height)":{
			"methodBody":"{\n    checkWidget();\n    \n    RECT rect = new RECT();\n    OS.SetRect(rect, x, y, x + width, y + height);\n    int bits1 = OS.GetWindowLong(handle, OS.GWL_STYLE);\n    int bits2 = OS.GetWindowLong(handle, OS.GWL_EXSTYLE);\n    boolean hasMenu = OS.IsWinCE ? false : OS.GetMenu(handle) != 0;\n    OS.AdjustWindowRectEx(rect, bits1, hasMenu, bits2);\n    \n    if (horizontalBar != null)\n        rect.bottom += OS.GetSystemMetrics(OS.SM_CYHSCROLL);\n    if (verticalBar != null)\n        rect.right += OS.GetSystemMetrics(OS.SM_CXVSCROLL);\n    \n    if (hasMenu) {\n        RECT testRect = new RECT();\n        OS.SetRect(testRect, 0, 0, rect.right - rect.left, rect.bottom - rect.top);\n        OS.SendMessage(handle, OS.WM_NCCALCSIZE, 0, testRect);\n        while ((testRect.bottom - testRect.top) < height) {\n            rect.top -= OS.GetSystemMetrics(OS.SM_CYMENU) - OS.GetSystemMetrics(OS.SM_CYBORDER);\n            OS.SetRect(testRect, 0, 0, rect.right - rect.left, rect.bottom - rect.top);\n            OS.SendMessage(handle, OS.WM_NCCALCSIZE, 0, testRect);\n        }\n    }\n    return new Rectangle(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);\n}",
			"comments":"/* Get the size of the trimmings */\n/* Get the size of the scroll bars */\n/* Get the height of the menu bar */\n",
			"methodName":"public Rectangle computeTrim(int x, int y, int width, int height)"
		},
		"static int checkStyle(int style)":{
			"methodBody":"{\n    if ((style & SWT.NO_TRIM) != 0) {\n        style &= ~(SWT.CLOSE | SWT.TITLE | SWT.MIN | SWT.MAX | SWT.RESIZE | SWT.BORDER);\n    }\n    if (OS.IsWinCE) {\n        \n        if ((style & SWT.MIN) != 0)\n            style &= ~SWT.MIN;\n        if ((style & SWT.MAX) != 0)\n            style &= ~SWT.MAX;\n        return style;\n    }\n    if ((style & (SWT.MENU | SWT.MIN | SWT.MAX | SWT.CLOSE)) != 0) {\n        style |= SWT.TITLE;\n    }\n    \n    if ((style & (SWT.MIN | SWT.MAX)) != 0)\n        style |= SWT.CLOSE;\n    \n    if ((style & SWT.CLOSE) != 0)\n        style |= SWT.TITLE;\n    return style;\n}",
			"comments":"/*\n* Feature in WinCE PPC.  WS_MINIMIZEBOX or WS_MAXIMIZEBOX\n* are not supposed to be used.  If they are, the result\n* is a button which does not repaint correctly.  The fix\n* is to remove this style.\n*/\n/*\n* If either WS_MINIMIZEBOX or WS_MAXIMIZEBOX are set,\n* we must also set WS_SYSMENU or the buttons will not\n* appear.\n*/\n/*\n* Both WS_SYSMENU and WS_CAPTION must be set in order\n* to for the system menu to appear.\n*/\n/*\n* Bug in Windows.  The WS_CAPTION style must be\n* set when the window is resizable or it does not\n* draw properly.\n*/\n/*\n* This code is intentionally commented.  It seems\n* that this problem originally in Windows 3.11,\n* has been fixed in later versions.  Because the\n* exact nature of the drawing problem is unknown,\n* keep the commented code around in case it comes\n* back.\n*/\n//\tif ((style & SWT.RESIZE) != 0) style |= SWT.TITLE;\n",
			"methodName":"static int checkStyle(int style)"
		},
		"public void setMenuBar(Menu menu)":{
			"methodBody":"{\n    checkWidget();\n    if (menuBar == menu)\n        return;\n    if (menu != null) {\n        if (menu.isDisposed())\n            error(SWT.ERROR_INVALID_ARGUMENT);\n        if ((menu.style & SWT.BAR) == 0)\n            error(SWT.ERROR_MENU_NOT_BAR);\n        if (menu.parent != this)\n            error(SWT.ERROR_INVALID_PARENT);\n    }\n    if (OS.IsWinCE) {\n        if (OS.IsHPC) {\n            boolean resize = menuBar != menu;\n            if (menuBar != null)\n                OS.CommandBar_Show(menuBar.hwndCB, false);\n            menuBar = menu;\n            if (menuBar != null)\n                OS.CommandBar_Show(menuBar.hwndCB, true);\n            if (resize) {\n                sendEvent(SWT.Resize);\n                if (isDisposed())\n                    return;\n                if (layout != null) {\n                    markLayout(false, false);\n                    updateLayout(true, false);\n                }\n            }\n        } else {\n            if (OS.IsPPC) {\n                \n                boolean resize = getMaximized() && menuBar != menu;\n                if (menuBar != null)\n                    OS.ShowWindow(menuBar.hwndCB, OS.SW_HIDE);\n                menuBar = menu;\n                if (menuBar != null)\n                    OS.ShowWindow(menuBar.hwndCB, OS.SW_SHOW);\n                if (resize)\n                    setMaximized(true);\n            }\n            if (OS.IsSP) {\n                if (menuBar != null)\n                    OS.ShowWindow(menuBar.hwndCB, OS.SW_HIDE);\n                menuBar = menu;\n                if (menuBar != null)\n                    OS.ShowWindow(menuBar.hwndCB, OS.SW_SHOW);\n            }\n        }\n    } else {\n        if (menu != null)\n            display.removeBar(menu);\n        menuBar = menu;\n        int hMenu = menuBar != null ? menuBar.handle : 0;\n        OS.SetMenu(handle, hMenu);\n    }\n    destroyAccelerators();\n}",
			"comments":"/**\n* Sets the receiver's menu bar to the argument, which\n* may be null.\n*\n* @param menu the new menu bar\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the menu has been disposed</li>\n*    <li>ERROR_INVALID_PARENT - if the menu is not in the same widget tree</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* Note in WinCE PPC.  The menu bar is a separate popup window.\n* If the shell is full screen, resize its window to leave\n* space for the menu bar.\n*/\n",
			"methodName":"public void setMenuBar(Menu menu)"
		},
		"boolean traverseItem(boolean next)":{
			"methodBody":"{\n    return false;\n}",
			"comments":"",
			"methodName":"boolean traverseItem(boolean next)"
		},
		"boolean isTabItem()":{
			"methodBody":"{\n    \n    return false;\n}",
			"comments":"/*\n* Can't test WS_TAB bits because they are the same as WS_MAXIMIZEBOX.\n*/\n",
			"methodName":"boolean isTabItem()"
		},
		"public void setVisible(boolean visible)":{
			"methodBody":"{\n    checkWidget();\n    if (drawCount != 0) {\n        if (((state & HIDDEN) == 0) == visible)\n            return;\n    } else {\n        if (visible == OS.IsWindowVisible(handle))\n            return;\n    }\n    if (visible) {\n        \n        sendEvent(SWT.Show);\n        if (isDisposed())\n            return;\n        if (OS.IsHPC) {\n            if (menuBar != null) {\n                int hwndCB = menuBar.hwndCB;\n                OS.CommandBar_DrawMenuBar(hwndCB, 0);\n            }\n        }\n        if (drawCount != 0) {\n            state &= ~HIDDEN;\n        } else {\n            if (OS.IsWinCE) {\n                OS.ShowWindow(handle, OS.SW_SHOW);\n            } else {\n                if (menuBar != null) {\n                    display.removeBar(menuBar);\n                    OS.DrawMenuBar(handle);\n                }\n                OS.ShowWindow(handle, swFlags);\n            }\n            if (isDisposed())\n                return;\n            opened = true;\n            if (!moved) {\n                moved = true;\n                Point location = getLocation();\n                oldX = location.x;\n                oldY = location.y;\n            }\n            if (!resized) {\n                resized = true;\n                Rectangle rect = getClientArea();\n                oldWidth = rect.width;\n                oldHeight = rect.height;\n            }\n            OS.UpdateWindow(handle);\n        }\n    } else {\n        if (!OS.IsWinCE) {\n            if (OS.IsIconic(handle)) {\n                swFlags = OS.SW_SHOWMINNOACTIVE;\n            } else {\n                if (OS.IsZoomed(handle)) {\n                    swFlags = OS.SW_SHOWMAXIMIZED;\n                } else {\n                    if (handle == OS.GetActiveWindow()) {\n                        swFlags = OS.SW_RESTORE;\n                    } else {\n                        swFlags = OS.SW_SHOWNOACTIVATE;\n                    }\n                }\n            }\n        }\n        if (drawCount != 0) {\n            state |= HIDDEN;\n        } else {\n            OS.ShowWindow(handle, OS.SW_HIDE);\n        }\n        if (isDisposed())\n            return;\n        sendEvent(SWT.Hide);\n    }\n}",
			"comments":"/*\n* It is possible (but unlikely), that application\n* code could have disposed the widget in the show\n* event.  If this happens, just return.\n*/\n",
			"methodName":"public void setVisible(boolean visible)"
		},
		"LRESULT WM_SYSCOMMAND(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_SYSCOMMAND(wParam, lParam);\n    if (result != null)\n        return result;\n    if (!(this instanceof Shell)) {\n        int cmd = wParam & 0xFFF0;\n        switch(cmd) {\n            case OS.SC_CLOSE:\n                {\n                    OS.PostMessage(handle, OS.WM_CLOSE, 0, 0);\n                    return LRESULT.ZERO;\n                }\n            case OS.SC_NEXTWINDOW:\n                {\n                    traverseDecorations(true);\n                    return LRESULT.ZERO;\n                }\n        }\n    }\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_SYSCOMMAND(int wParam, int lParam)"
		},
		"LRESULT WM_WINDOWPOSCHANGING(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_WINDOWPOSCHANGING(wParam, lParam);\n    if (result != null)\n        return result;\n    if (display.lockActiveWindow) {\n        WINDOWPOS lpwp = new WINDOWPOS();\n        OS.MoveMemory(lpwp, lParam, WINDOWPOS.sizeof);\n        lpwp.flags |= OS.SWP_NOZORDER;\n        OS.MoveMemory(lParam, lpwp, WINDOWPOS.sizeof);\n    }\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_WINDOWPOSCHANGING(int wParam, int lParam)"
		},
		"void sort(Image[] images, ImageData[] datas, int width, int height, int depth)":{
			"methodBody":"{\n    \n    int length = images.length;\n    if (length <= 1)\n        return;\n    for (int gap = length / 2; gap > 0; gap /= 2) {\n        for (int i = gap; i < length; i++) {\n            for (int j = i - gap; j >= 0; j -= gap) {\n                if (compare(datas[j], datas[j + gap], width, height, depth) >= 0) {\n                    Image swap = images[j];\n                    images[j] = images[j + gap];\n                    images[j + gap] = swap;\n                    ImageData swapData = datas[j];\n                    datas[j] = datas[j + gap];\n                    datas[j + gap] = swapData;\n                }\n            }\n        }\n    }\n}",
			"comments":"/* Shell Sort from K&R, pg 108 */\n",
			"methodName":"void sort(Image[] images, ImageData[] datas, int width, int height, int depth)"
		},
		"public void dispose()":{
			"methodBody":"{\n    if (isDisposed())\n        return;\n    if (!isValidThread())\n        error(SWT.ERROR_THREAD_INVALID_ACCESS);\n    if (!(this instanceof Shell)) {\n        setVisible(false);\n        if (!traverseDecorations(false)) {\n            Shell shell = getShell();\n            shell.setFocus();\n        }\n    }\n    super.dispose();\n}",
			"comments":"",
			"methodName":"public void dispose()"
		},
		"public boolean isReparentable()":{
			"methodBody":"{\n    checkWidget();\n    \n    return false;\n}",
			"comments":"/*\n* Feature in Windows.  Calling SetParent() for a shell causes\n* a kind of fake MDI to happen.  It doesn't work well on Windows\n* and is not supported on the other platforms.  The fix is to\n* disallow the SetParent().\n*/\n",
			"methodName":"public boolean isReparentable()"
		},
		"public void setImage(Image image)":{
			"methodBody":"{\n    checkWidget();\n    if (image != null && image.isDisposed())\n        error(SWT.ERROR_INVALID_ARGUMENT);\n    this.image = image;\n    setImages(image, null);\n}",
			"comments":"/**\n* Sets the receiver's image to the argument, which may\n* be null. The image is typically displayed by the window\n* manager when the instance is marked as iconified, and\n* may also be displayed somewhere in the trim when the\n* instance is in normal or maximized states.\n*\n* @param image the new image (or null)\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the image has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setImage(Image image)"
		},
		"Decorations menuShell()":{
			"methodBody":"{\n    return this;\n}",
			"comments":"",
			"methodName":"Decorations menuShell()"
		},
		"CREATESTRUCT widgetCreateStruct()":{
			"methodBody":"{\n    return new CREATESTRUCT();\n}",
			"comments":"",
			"methodName":"CREATESTRUCT widgetCreateStruct()"
		},
		"public void setImages(Image[] images)":{
			"methodBody":"{\n    checkWidget();\n    if (images == null)\n        error(SWT.ERROR_INVALID_ARGUMENT);\n    for (int i = 0; i < images.length; i++) {\n        if (images[i] == null || images[i].isDisposed())\n            error(SWT.ERROR_INVALID_ARGUMENT);\n    }\n    this.images = images;\n    setImages(null, images);\n}",
			"comments":"/**\n* Sets the receiver's images to the argument, which may\n* be an empty array. Images are typically displayed by the\n* window manager when the instance is marked as iconified,\n* and may also be displayed somewhere in the trim when the\n* instance is in normal or maximized states. Depending where\n* the icon is displayed, the platform chooses the icon with\n* the \"best\" attributes. It is expected that the array will\n* contain the same icon rendered at different sizes, with\n* different depth and transparency attributes.\n*\n* @param images the new image array\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the array of images is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if one of the images is null or has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public void setImages(Image[] images)"
		},
		"LRESULT WM_KILLFOCUS(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_KILLFOCUS(wParam, lParam);\n    saveFocus();\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_KILLFOCUS(int wParam, int lParam)"
		},
		"void releaseWidget()":{
			"methodBody":"{\n    if (menuBar != null)\n        menuBar.releaseResources();\n    menuBar = null;\n    if (menus != null) {\n        do {\n            int index = 0;\n            while (index < menus.length) {\n                Menu menu = menus[index];\n                if (menu != null && !menu.isDisposed()) {\n                    while (menu.getParentMenu() != null) {\n                        menu = menu.getParentMenu();\n                    }\n                    menu.dispose();\n                    break;\n                }\n                index++;\n            }\n            if (index == menus.length)\n                break;\n        } while (true);\n    }\n    menus = null;\n    super.releaseWidget();\n    if (smallImage != null)\n        smallImage.dispose();\n    if (largeImage != null)\n        largeImage.dispose();\n    smallImage = largeImage = image = null;\n    images = null;\n    savedFocus = null;\n    defaultButton = saveDefault = null;\n    if (hAccel != 0 && hAccel != -1)\n        OS.DestroyAcceleratorTable(hAccel);\n    hAccel = -1;\n}",
			"comments":"",
			"methodName":"void releaseWidget()"
		},
		"LRESULT WM_ACTIVATE(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_ACTIVATE(wParam, lParam);\n    if (result != null)\n        return result;\n    \n    if (OS.GetParent(lParam) == handle) {\n        TCHAR buffer = new TCHAR(0, 128);\n        OS.GetClassName(lParam, buffer, buffer.length());\n        String className = buffer.toString(0, buffer.strlen());\n        if (className.equals(Display.AWT_WINDOW_CLASS)) {\n            return LRESULT.ZERO;\n        }\n    }\n    if ((wParam & 0xFFFF) != 0) {\n        \n        if ((wParam >> 16) != 0)\n            return result;\n        Control control = display.findControl(lParam);\n        if (control == null || control instanceof Shell) {\n            if (this instanceof Shell) {\n                sendEvent(SWT.Activate);\n                if (isDisposed())\n                    return LRESULT.ZERO;\n            }\n        }\n        if (restoreFocus())\n            return LRESULT.ZERO;\n    } else {\n        Display display = this.display;\n        boolean lockWindow = display.isXMouseActive();\n        if (lockWindow)\n            display.lockActiveWindow = true;\n        Control control = display.findControl(lParam);\n        if (control == null || control instanceof Shell) {\n            if (this instanceof Shell) {\n                sendEvent(SWT.Deactivate);\n                if (!isDisposed()) {\n                    Shell shell = getShell();\n                    shell.setActiveControl(null);\n                \n                }\n            }\n        }\n        if (lockWindow)\n            display.lockActiveWindow = false;\n        if (isDisposed())\n            return LRESULT.ZERO;\n        saveFocus();\n    }\n    return result;\n}",
			"comments":"/*\n* Feature in AWT.  When an AWT Window is activated,\n* for some reason, it seems to forward the WM_ACTIVATE\n* message to the parent.  Normally, the parent is an\n* AWT Frame.  When AWT is embedded in SWT, the SWT\n* shell gets the WM_ACTIVATE and assumes that it came\n* from Windows.  When an SWT shell is activated it\n* restores focus to the last control that had focus.\n* If this control is an embedded composite, it takes\n* focus from the AWT Window.  The fix is to ignore\n* WM_ACTIVATE messages that come from AWT Windows.\n*/\n/*\n* When the high word of wParam is non-zero, the activation\n* state of the window is being changed while the window is\n* minimized. If this is the case, do not report activation\n* events or restore the focus.\n*/\n// widget could be disposed at this point\n",
			"methodName":"LRESULT WM_ACTIVATE(int wParam, int lParam)"
		},
		"Image createIcon(Image image)":{
			"methodBody":"{\n    ImageData data = image.getImageData();\n    if (data.alpha == -1 && data.alphaData == null) {\n        ImageData mask = data.getTransparencyMask();\n        return new Image(display, data, mask);\n    }\n    int width = data.width, height = data.height;\n    int hMask, hBitmap;\n    int hDC = OS.GetDC(handle);\n    int dstHdc = OS.CreateCompatibleDC(hDC), oldDstBitmap;\n    if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION(5, 1)) {\n        hBitmap = Display.create32bitDIB(image.handle, data.alpha, data.alphaData, data.transparentPixel);\n        hMask = OS.CreateBitmap(width, height, 1, 1, null);\n        oldDstBitmap = OS.SelectObject(dstHdc, hMask);\n        OS.PatBlt(dstHdc, 0, 0, width, height, OS.BLACKNESS);\n    } else {\n        hMask = Display.createMaskFromAlpha(data, width, height);\n        \n        hBitmap = OS.CreateCompatibleBitmap(hDC, width, height);\n        oldDstBitmap = OS.SelectObject(dstHdc, hBitmap);\n        int srcHdc = OS.CreateCompatibleDC(hDC);\n        int oldSrcBitmap = OS.SelectObject(srcHdc, image.handle);\n        OS.PatBlt(dstHdc, 0, 0, width, height, OS.BLACKNESS);\n        OS.BitBlt(dstHdc, 0, 0, width, height, srcHdc, 0, 0, OS.SRCINVERT);\n        OS.SelectObject(srcHdc, hMask);\n        OS.BitBlt(dstHdc, 0, 0, width, height, srcHdc, 0, 0, OS.SRCAND);\n        OS.SelectObject(srcHdc, image.handle);\n        OS.BitBlt(dstHdc, 0, 0, width, height, srcHdc, 0, 0, OS.SRCINVERT);\n        OS.SelectObject(srcHdc, oldSrcBitmap);\n        OS.DeleteDC(srcHdc);\n    }\n    OS.SelectObject(dstHdc, oldDstBitmap);\n    OS.DeleteDC(dstHdc);\n    OS.ReleaseDC(handle, hDC);\n    ICONINFO info = new ICONINFO();\n    info.fIcon = true;\n    info.hbmColor = hBitmap;\n    info.hbmMask = hMask;\n    int hIcon = OS.CreateIconIndirect(info);\n    if (hIcon == 0)\n        SWT.error(SWT.ERROR_NO_HANDLES);\n    OS.DeleteObject(hBitmap);\n    OS.DeleteObject(hMask);\n    return Image.win32_new(display, SWT.ICON, hIcon);\n}",
			"comments":"/* Icons need black pixels where the mask is transparent */\n",
			"methodName":"Image createIcon(Image image)"
		},
		"void setParent()":{
			"methodBody":"{\n    \n    int hwndParent = parent.handle;\n    display.lockActiveWindow = true;\n    OS.SetParent(handle, hwndParent);\n    if (!OS.IsWindowVisible(hwndParent)) {\n        OS.ShowWindow(handle, OS.SW_SHOWNA);\n    }\n    int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n    bits &= ~OS.WS_CHILD;\n    OS.SetWindowLong(handle, OS.GWL_STYLE, bits | OS.WS_POPUP);\n    OS.SetWindowLong(handle, OS.GWL_ID, 0);\n    int flags = OS.SWP_NOSIZE | OS.SWP_NOMOVE | OS.SWP_NOACTIVATE;\n    SetWindowPos(handle, OS.HWND_BOTTOM, 0, 0, 0, 0, flags);\n    display.lockActiveWindow = false;\n}",
			"comments":"/*\n* In order for an MDI child window to support\n* a menu bar, setParent () is needed to reset\n* the parent.  Otherwise, the MDI child window\n* will appear as a separate shell.  This is an\n* undocumented and possibly dangerous Windows\n* feature.\n*/\n",
			"methodName":"void setParent()"
		},
		"int callWindowProc(int hwnd, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    if (handle == 0)\n        return 0;\n    return OS.DefMDIChildProc(hwnd, msg, wParam, lParam);\n}",
			"comments":"",
			"methodName":"int callWindowProc(int hwnd, int msg, int wParam, int lParam)"
		},
		"public boolean getMinimized()":{
			"methodBody":"{\n    checkWidget();\n    if (OS.IsWinCE)\n        return false;\n    if (OS.IsWindowVisible(handle))\n        return OS.IsIconic(handle);\n    return swFlags == OS.SW_SHOWMINNOACTIVE;\n}",
			"comments":"/**\n* Returns <code>true</code> if the receiver is currently\n* minimized, and false otherwise.\n* <p>\n*\n* @return the minimized state\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #setMinimized\n*/\n",
			"methodName":"public boolean getMinimized()"
		},
		"LRESULT WM_CLOSE(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_CLOSE(wParam, lParam);\n    if (result != null)\n        return result;\n    if (isEnabled() && isActive())\n        closeWidget();\n    return LRESULT.ZERO;\n}",
			"comments":"",
			"methodName":"LRESULT WM_CLOSE(int wParam, int lParam)"
		}
	},
	"ClassORInterfaceName":[
		"Decorations"
	]
}
