{
	"variables":[
		"KEYBOARD_NON_BIDI",
		"KEYBOARD_BIDI",
		"isBidiPlatform",
		"CLASSIN",
		"LINKBEFORE",
		"LINKAFTER",
		"languageMap",
		"keyMap",
		"oldProcMap",
		"CLASS_NAME",
		"callback",
		"GCP_REORDER",
		"GCP_GLYPHSHAPE",
		"GCP_LIGATE",
		"GCP_CLASSIN",
		"GCPCLASS_ARABIC",
		"GCPCLASS_HEBREW",
		"GCPCLASS_LOCALNUMBER",
		"GCPCLASS_LATINNUMBER",
		"GCPGLYPH_LINKBEFORE",
		"GCPGLYPH_LINKAFTER",
		"ETO_CLIPPED",
		"ETO_GLYPH_INDEX",
		"LANG_ARABIC",
		"LANG_HEBREW",
		"CD_PG_HEBREW",
		"CD_PG_ARABIC",
		"HKL_NEXT",
		"HKL_PREV",
		"CLASS_HEBREW",
		"CLASS_ARABIC",
		"CLASS_LOCALNUMBER",
		"CLASS_LATINNUMBER",
		"REORDER",
		"LIGATE",
		"GLYPHSHAPE",
		"length",
		"oldBkMode",
		"fontLanguageInfo",
		"hHeap",
		"lpCs",
		"cs",
		"isRightOriented",
		"textBuffer",
		"byteCount",
		"linkBefore",
		"linkAfter",
		"result",
		"lpOrder",
		"lpDx",
		"lpClass",
		"lpGlyphs",
		"dwFlags",
		"glyphFlags",
		"lpGlyphs2",
		"glyphBuffer",
		"glyphCount",
		"i",
		"offset",
		"length",
		"textBuffer2",
		"dx2",
		"order2",
		"classBuffer2",
		"glyphBuffer2",
		"fontLanguageInfo",
		"hHeap",
		"lpCs",
		"cs",
		"textBuffer",
		"byteCount",
		"isRightOriented",
		"result",
		"lpOrder",
		"lpClass",
		"dwFlags",
		"glyphCount",
		"i",
		"offset",
		"length",
		"textBuffer2",
		"order2",
		"classBuffer2",
		"fontStyle",
		"fontLanguageInfo",
		"layout",
		"maxSize",
		"tempList",
		"size",
		"list",
		"callback",
		"lpEnumSystemLanguageGroupsProc",
		"codePage",
		"list",
		"i",
		"id",
		"list",
		"i",
		"id",
		"list",
		"i",
		"id",
		"bits",
		"key",
		"oldProc",
		"length",
		"i",
		"tmp",
		"length",
		"i",
		"tmp",
		"maxOrder",
		"length",
		"i",
		"i",
		"key",
		"proc",
		"key",
		"runnable",
		"oldProc",
		"callback",
		"Class",
		"CLASS_NAME",
		"callback",
		"SWT",
		"SWT",
		"GCPCLASS_ARABIC",
		"GCPCLASS_HEBREW",
		"GCPCLASS_LOCALNUMBER",
		"GCPCLASS_LATINNUMBER",
		"GCP_REORDER",
		"GCP_LIGATE",
		"GCP_GLYPHSHAPE",
		"languageMap",
		"hwnd",
		"runnable",
		"hwnd",
		"lpLangGrpId",
		"OS",
		"isBidiPlatform",
		"lpLangGrpId",
		"OS",
		"isBidiPlatform",
		"renderDx",
		"OS",
		"OS",
		"OS",
		"OS",
		"gc",
		"renderDx",
		"renderDx",
		"length",
		"renderBuffer",
		"OS",
		"gc",
		"OS",
		"OS",
		"gc",
		"x",
		"y",
		"ETO_GLYPH_INDEX",
		"renderBuffer",
		"renderBuffer",
		"renderDx",
		"OS",
		"gc",
		"oldBkMode",
		"OS",
		"gc",
		"OS",
		"OS",
		"gc",
		"OS",
		"OS",
		"OS",
		"isRightOriented",
		"OS",
		"gc",
		"OS",
		"cs",
		"lpCs",
		"OS",
		"lpCs",
		"text",
		"textBuffer",
		"flags",
		"LINKBEFORE",
		"LINKBEFORE",
		"flags",
		"LINKAFTER",
		"LINKAFTER",
		"result",
		"GCP_RESULTS",
		"result",
		"byteCount",
		"result",
		"OS",
		"hHeap",
		"OS",
		"byteCount",
		"result",
		"OS",
		"hHeap",
		"OS",
		"byteCount",
		"result",
		"OS",
		"hHeap",
		"OS",
		"byteCount",
		"result",
		"OS",
		"hHeap",
		"OS",
		"byteCount",
		"dwFlags",
		"GCP_REORDER",
		"fontLanguageInfo",
		"GCP_LIGATE",
		"GCP_LIGATE",
		"dwFlags",
		"GCP_LIGATE",
		"glyphFlags",
		"fontLanguageInfo",
		"GCP_GLYPHSHAPE",
		"GCP_GLYPHSHAPE",
		"dwFlags",
		"GCP_GLYPHSHAPE",
		"linkBefore",
		"glyphFlags",
		"GCPGLYPH_LINKBEFORE",
		"linkAfter",
		"glyphFlags",
		"GCPGLYPH_LINKAFTER",
		"linkBefore",
		"linkAfter",
		"lpGlyphs2",
		"lpGlyphs2",
		"glyphFlags",
		"lpGlyphs2",
		"glyphFlags",
		"lpGlyphs2",
		"glyphFlags",
		"OS",
		"result",
		"lpGlyphs2",
		"lpGlyphs2",
		"flags",
		"CLASSIN",
		"CLASSIN",
		"dwFlags",
		"GCP_CLASSIN",
		"OS",
		"result",
		"classBuffer",
		"classBuffer",
		"result",
		"i",
		"offsets",
		"i",
		"offsets",
		"i",
		"offsets",
		"i",
		"offsets",
		"i",
		"result",
		"length",
		"lpCs",
		"text",
		"offset",
		"offset",
		"length",
		"OS",
		"gc",
		"textBuffer2",
		"textBuffer2",
		"result",
		"dwFlags",
		"dx",
		"result",
		"OS",
		"dx2",
		"result",
		"dx2",
		"isRightOriented",
		"dx2",
		"System",
		"dx2",
		"dx",
		"glyphCount",
		"dx2",
		"order",
		"length",
		"OS",
		"order2",
		"result",
		"order2",
		"order2",
		"glyphCount",
		"isRightOriented",
		"System",
		"order2",
		"order",
		"offset",
		"length",
		"classBuffer",
		"length",
		"OS",
		"classBuffer2",
		"result",
		"classBuffer2",
		"System",
		"classBuffer2",
		"classBuffer",
		"offset",
		"length",
		"result",
		"OS",
		"glyphBuffer2",
		"result",
		"glyphBuffer2",
		"isRightOriented",
		"glyphBuffer2",
		"System",
		"glyphBuffer2",
		"glyphBuffer",
		"glyphCount",
		"glyphBuffer2",
		"glyphCount",
		"glyphBuffer2",
		"result",
		"length",
		"result",
		"length",
		"result",
		"length",
		"result",
		"glyphBuffer2",
		"OS",
		"hHeap",
		"lpGlyphs",
		"OS",
		"hHeap",
		"lpClass",
		"OS",
		"hHeap",
		"lpDx",
		"OS",
		"hHeap",
		"lpOrder",
		"glyphBuffer",
		"OS",
		"gc",
		"OS",
		"OS",
		"gc",
		"OS",
		"cs",
		"lpCs",
		"OS",
		"lpCs",
		"text",
		"textBuffer",
		"OS",
		"OS",
		"OS",
		"isRightOriented",
		"OS",
		"gc",
		"result",
		"GCP_RESULTS",
		"result",
		"byteCount",
		"result",
		"OS",
		"hHeap",
		"OS",
		"byteCount",
		"result",
		"OS",
		"hHeap",
		"OS",
		"byteCount",
		"dwFlags",
		"GCP_REORDER",
		"fontLanguageInfo",
		"GCP_LIGATE",
		"GCP_LIGATE",
		"dwFlags",
		"GCP_LIGATE",
		"fontLanguageInfo",
		"GCP_GLYPHSHAPE",
		"GCP_GLYPHSHAPE",
		"dwFlags",
		"GCP_GLYPHSHAPE",
		"flags",
		"CLASSIN",
		"CLASSIN",
		"dwFlags",
		"GCP_CLASSIN",
		"OS",
		"result",
		"classBuffer",
		"classBuffer",
		"i",
		"offsets",
		"i",
		"offsets",
		"i",
		"offsets",
		"i",
		"offsets",
		"i",
		"result",
		"length",
		"lpCs",
		"text",
		"offset",
		"offset",
		"length",
		"OS",
		"gc",
		"textBuffer2",
		"textBuffer2",
		"result",
		"dwFlags",
		"order",
		"length",
		"OS",
		"order2",
		"result",
		"order2",
		"order2",
		"glyphCount",
		"isRightOriented",
		"System",
		"order2",
		"order",
		"offset",
		"length",
		"classBuffer",
		"length",
		"OS",
		"classBuffer2",
		"result",
		"classBuffer2",
		"System",
		"classBuffer2",
		"classBuffer",
		"offset",
		"length",
		"glyphCount",
		"result",
		"result",
		"length",
		"result",
		"length",
		"OS",
		"hHeap",
		"lpClass",
		"OS",
		"hHeap",
		"lpOrder",
		"OS",
		"gc",
		"fontLanguageInfo",
		"GCP_REORDER",
		"fontStyle",
		"REORDER",
		"fontLanguageInfo",
		"GCP_LIGATE",
		"fontStyle",
		"LIGATE",
		"fontLanguageInfo",
		"GCP_GLYPHSHAPE",
		"fontStyle",
		"GLYPHSHAPE",
		"fontStyle",
		"OS",
		"layout",
		"layout",
		"layout",
		"LANG_HEBREW",
		"KEYBOARD_BIDI",
		"layout",
		"LANG_ARABIC",
		"KEYBOARD_BIDI",
		"KEYBOARD_NON_BIDI",
		"maxSize",
		"OS",
		"maxSize",
		"tempList",
		"size",
		"System",
		"tempList",
		"list",
		"size",
		"list",
		"OS",
		"isBidiPlatform",
		"isBidiPlatform",
		"isBidiPlatform",
		"callback",
		"Class",
		"CLASS_NAME",
		"callback",
		"lpEnumSystemLanguageGroupsProc",
		"SWT",
		"SWT",
		"OS",
		"lpEnumSystemLanguageGroupsProc",
		"OS",
		"callback",
		"callback",
		"callback",
		"isBidiPlatform",
		"String",
		"OS",
		"CD_PG_ARABIC",
		"codePage",
		"CD_PG_HEBREW",
		"codePage",
		"isBidiPlatform",
		"isBidiPlatform",
		"i",
		"list",
		"i",
		"list",
		"i",
		"id",
		"LANG_ARABIC",
		"id",
		"LANG_HEBREW",
		"languageMap",
		"hwnd",
		"hwnd",
		"language",
		"language",
		"KEYBOARD_BIDI",
		"i",
		"list",
		"i",
		"list",
		"i",
		"id",
		"LANG_ARABIC",
		"id",
		"LANG_HEBREW",
		"OS",
		"list",
		"i",
		"i",
		"list",
		"i",
		"list",
		"i",
		"id",
		"LANG_HEBREW",
		"id",
		"LANG_ARABIC",
		"OS",
		"list",
		"i",
		"OS",
		"OS",
		"OS",
		"OS",
		"hwnd",
		"OS",
		"orientation",
		"SWT",
		"bits",
		"OS",
		"bits",
		"OS",
		"OS",
		"hwnd",
		"OS",
		"bits",
		"hwnd",
		"oldProcMap",
		"key",
		"OS",
		"hwnd",
		"OS",
		"oldProcMap",
		"key",
		"oldProc",
		"OS",
		"hwnd",
		"OS",
		"callback",
		"charArray",
		"i",
		"length",
		"i",
		"charArray",
		"i",
		"charArray",
		"i",
		"charArray",
		"length",
		"i",
		"charArray",
		"length",
		"i",
		"tmp",
		"intArray",
		"i",
		"length",
		"i",
		"intArray",
		"i",
		"intArray",
		"i",
		"intArray",
		"length",
		"i",
		"intArray",
		"length",
		"i",
		"tmp",
		"orderArray",
		"isRightOriented",
		"i",
		"length",
		"i",
		"maxOrder",
		"Math",
		"maxOrder",
		"orderArray",
		"i",
		"i",
		"length",
		"i",
		"isRightOriented",
		"orderArray",
		"i",
		"maxOrder",
		"orderArray",
		"i",
		"orderArray",
		"i",
		"glyphCount",
		"hwnd",
		"languageMap",
		"key",
		"keyMap",
		"key",
		"oldProcMap",
		"key",
		"proc",
		"OS",
		"hwnd",
		"OS",
		"proc",
		"hwnd",
		"msg",
		"languageMap",
		"key",
		"runnable",
		"runnable",
		"oldProcMap",
		"key",
		"OS",
		"oldProc",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"ERROR_NO_MORE_CALLBACKS",
		"LGRPID_HEBREW",
		"LGRPID_ARABIC",
		"length",
		"IsWinCE",
		"WIN32_VERSION",
		"handle",
		"handle",
		"TRANSPARENT",
		"handle",
		"length",
		"handle",
		"handle",
		"handle",
		"IsWinCE",
		"WIN32_VERSION",
		"handle",
		"TCI_SRCCHARSET",
		"lStructSize",
		"sizeof",
		"nGlyphs",
		"lpOrder",
		"HEAP_ZERO_MEMORY",
		"lpDx",
		"HEAP_ZERO_MEMORY",
		"lpClass",
		"HEAP_ZERO_MEMORY",
		"lpGlyphs",
		"HEAP_ZERO_MEMORY",
		"lpGlyphs",
		"length",
		"lpClass",
		"length",
		"nGlyphs",
		"length",
		"nGlyphs",
		"handle",
		"nGlyphs",
		"lpDx",
		"length",
		"length",
		"lpOrder",
		"length",
		"lpClass",
		"length",
		"nGlyphs",
		"lpGlyphs",
		"length",
		"length",
		"length",
		"lpOrder",
		"lpDx",
		"lpClass",
		"lpGlyphs",
		"length",
		"handle",
		"handle",
		"TCI_SRCCHARSET",
		"IsWinCE",
		"WIN32_VERSION",
		"handle",
		"lStructSize",
		"sizeof",
		"nGlyphs",
		"lpOrder",
		"HEAP_ZERO_MEMORY",
		"lpClass",
		"HEAP_ZERO_MEMORY",
		"lpClass",
		"length",
		"length",
		"nGlyphs",
		"handle",
		"lpOrder",
		"length",
		"lpClass",
		"length",
		"nGlyphs",
		"lpOrder",
		"lpClass",
		"handle",
		"IsWinCE",
		"ERROR_NO_MORE_CALLBACKS",
		"LGRPID_INSTALLED",
		"length",
		"length",
		"length",
		"IsWinCE",
		"WIN32_VERSION",
		"GWL_EXSTYLE",
		"RIGHT_TO_LEFT",
		"WS_EX_LAYOUTRTL",
		"WS_EX_LAYOUTRTL",
		"GWL_EXSTYLE",
		"GWL_WNDPROC",
		"GWL_WNDPROC",
		"length",
		"length",
		"length",
		"GWL_WNDPROC",
		"e",
		"hwnd",
		"runnable",
		"lpLangGrpId",
		"lpLangGrpIdString",
		"lpLangGrpName",
		"options",
		"lParam",
		"gc",
		"renderBuffer",
		"renderDx",
		"x",
		"y",
		"gc",
		"text",
		"order",
		"classBuffer",
		"dx",
		"flags",
		"offsets",
		"gc",
		"text",
		"order",
		"classBuffer",
		"flags",
		"offsets",
		"gc",
		"e",
		"hwnd",
		"language",
		"hwnd",
		"orientation",
		"hwnd",
		"charArray",
		"intArray",
		"orderArray",
		"glyphCount",
		"isRightOriented",
		"hwnd",
		"hwnd",
		"msg",
		"wParam",
		"lParam"
	],
	"extendORImplementFiles":[],
	"package":[
		"org.eclipse.swt.internal"
	],
	"import":[
		"java.util.Hashtable",
		"org.eclipse.swt.SWT",
		"org.eclipse.swt.graphics.GC",
		"org.eclipse.swt.internal.win32"
	],
	"methods":[
		"addLanguageListener",
		"EnumSystemLanguageGroupsProc",
		"drawGlyphs",
		"getRenderInfo",
		"getOrderInfo",
		"getFontBidiAttributes",
		"getKeyboardLanguage",
		"getKeyboardLanguageList",
		"isBidiPlatform",
		"isKeyboardBidi",
		"removeLanguageListener",
		"setKeyboardLanguage",
		"setOrientation",
		"subclass",
		"reverse",
		"reverse",
		"translateOrder",
		"unsubclass",
		"windowProc",
		"forName",
		"getAddress",
		"error",
		"put",
		"subclass",
		"VERSION",
		"GetLayout",
		"reverse",
		"reverse",
		"SetBkMode",
		"ExtTextOutW",
		"SetBkMode",
		"GetFontLanguageInfo",
		"GetProcessHeap",
		"GetTextCharset",
		"VERSION",
		"GetLayout",
		"TranslateCharsetInfo",
		"length",
		"HeapAlloc",
		"HeapAlloc",
		"HeapAlloc",
		"HeapAlloc",
		"MoveMemory",
		"MoveMemory",
		"substring",
		"GetCharacterPlacement",
		"length",
		"MoveMemory",
		"reverse",
		"arraycopy",
		"MoveMemory",
		"translateOrder",
		"arraycopy",
		"MoveMemory",
		"arraycopy",
		"MoveMemory",
		"reverse",
		"arraycopy",
		"HeapFree",
		"HeapFree",
		"HeapFree",
		"HeapFree",
		"GetFontLanguageInfo",
		"GetProcessHeap",
		"GetTextCharset",
		"TranslateCharsetInfo",
		"length",
		"VERSION",
		"GetLayout",
		"HeapAlloc",
		"HeapAlloc",
		"MoveMemory",
		"substring",
		"GetCharacterPlacement",
		"length",
		"MoveMemory",
		"translateOrder",
		"arraycopy",
		"MoveMemory",
		"arraycopy",
		"HeapFree",
		"HeapFree",
		"GetFontLanguageInfo",
		"GetKeyboardLayout",
		"GetKeyboardLayoutList",
		"arraycopy",
		"isKeyboardBidi",
		"forName",
		"getAddress",
		"error",
		"EnumSystemLanguageGroups",
		"dispose",
		"dispose",
		"valueOf",
		"GetACP",
		"equals",
		"equals",
		"getKeyboardLanguageList",
		"remove",
		"unsubclass",
		"getKeyboardLanguage",
		"getKeyboardLanguageList",
		"ActivateKeyboardLayout",
		"getKeyboardLanguageList",
		"ActivateKeyboardLayout",
		"VERSION",
		"GetWindowLong",
		"SetWindowLong",
		"get",
		"GetWindowLong",
		"put",
		"SetWindowLong",
		"getAddress",
		"max",
		"get",
		"get",
		"remove",
		"SetWindowLong",
		"intValue",
		"get",
		"run",
		"get",
		"CallWindowProc",
		"intValue",
		"Hashtable",
		"Hashtable",
		"Hashtable",
		"Callback",
		"Integer",
		"TCHAR",
		"GCP_RESULTS",
		"TCHAR",
		"TCHAR",
		"GCP_RESULTS",
		"TCHAR",
		"Callback",
		"Integer",
		"Integer",
		"Integer",
		"Integer",
		"Integer"
	],
	"methodsBody":{
		"public static boolean isKeyboardBidi()":{
			"methodBody":"{\n    int[] list = getKeyboardLanguageList();\n    for (int i = 0; i < list.length; i++) {\n        int id = list[i] & 0x000000FF;\n        if ((id == LANG_ARABIC) || (id == LANG_HEBREW)) {\n            return true;\n        }\n    }\n    return false;\n}",
			"comments":"/**\n* Return whether or not the keyboard supports input of a bidi language.  Determine this\n* by looking at the languages that are installed for the keyboard.\n* <p>\n*\n* @return true if bidi is supported, false otherwise.\n*/\n",
			"methodName":"public static boolean isKeyboardBidi()"
		},
		"static void reverse(char[] charArray)":{
			"methodBody":"{\n    int length = charArray.length;\n    for (int i = 0; i <= (length - 1) / 2; i++) {\n        char tmp = charArray[i];\n        charArray[i] = charArray[length - 1 - i];\n        charArray[length - 1 - i] = tmp;\n    }\n}",
			"comments":"/**\n*  Reverse the character array.  Used for right orientation.\n*\n* @param charArray character array to reverse\n*/\n",
			"methodName":"static void reverse(char[] charArray)"
		},
		"public static char[] getRenderInfo(GC gc, String text, int[] order, byte[] classBuffer, int[] dx, int flags, int[] offsets)":{
			"methodBody":"{\n    int fontLanguageInfo = OS.GetFontLanguageInfo(gc.handle);\n    int hHeap = OS.GetProcessHeap();\n    int[] lpCs = new int[8];\n    int cs = OS.GetTextCharset(gc.handle);\n    boolean isRightOriented = false;\n    if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION(4, 10)) {\n        isRightOriented = OS.GetLayout(gc.handle) != 0;\n    }\n    OS.TranslateCharsetInfo(cs, lpCs, OS.TCI_SRCCHARSET);\n    TCHAR textBuffer = new TCHAR(lpCs[1], text, false);\n    int byteCount = textBuffer.length();\n    boolean linkBefore = (flags & LINKBEFORE) == LINKBEFORE;\n    boolean linkAfter = (flags & LINKAFTER) == LINKAFTER;\n    GCP_RESULTS result = new GCP_RESULTS();\n    result.lStructSize = GCP_RESULTS.sizeof;\n    result.nGlyphs = byteCount;\n    int lpOrder = result.lpOrder = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, byteCount * 4);\n    int lpDx = result.lpDx = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, byteCount * 4);\n    int lpClass = result.lpClass = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, byteCount);\n    int lpGlyphs = result.lpGlyphs = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, byteCount * 2);\n    \n    int dwFlags = 0;\n    int glyphFlags = 0;\n    \n    \n    dwFlags |= GCP_REORDER;\n    if ((fontLanguageInfo & GCP_LIGATE) == GCP_LIGATE) {\n        dwFlags |= GCP_LIGATE;\n        glyphFlags |= 0;\n    }\n    if ((fontLanguageInfo & GCP_GLYPHSHAPE) == GCP_GLYPHSHAPE) {\n        dwFlags |= GCP_GLYPHSHAPE;\n        if (linkBefore) {\n            glyphFlags |= GCPGLYPH_LINKBEFORE;\n        }\n        if (linkAfter) {\n            glyphFlags |= GCPGLYPH_LINKAFTER;\n        }\n    }\n    byte[] lpGlyphs2;\n    if (linkBefore || linkAfter) {\n        lpGlyphs2 = new byte[2];\n        lpGlyphs2[0] = (byte) glyphFlags;\n        lpGlyphs2[1] = (byte) (glyphFlags >> 8);\n    } else {\n        lpGlyphs2 = new byte[] { (byte) glyphFlags };\n    }\n    OS.MoveMemory(result.lpGlyphs, lpGlyphs2, lpGlyphs2.length);\n    if ((flags & CLASSIN) == CLASSIN) {\n        \n        dwFlags |= GCP_CLASSIN;\n        OS.MoveMemory(result.lpClass, classBuffer, classBuffer.length);\n    }\n    char[] glyphBuffer = new char[result.nGlyphs];\n    int glyphCount = 0;\n    for (int i = 0; i < offsets.length - 1; i++) {\n        int offset = offsets[i];\n        int length = offsets[i + 1] - offsets[i];\n        \n        \n        result.nGlyphs = length;\n        TCHAR textBuffer2 = new TCHAR(lpCs[1], text.substring(offset, offset + length), false);\n        OS.GetCharacterPlacement(gc.handle, textBuffer2, textBuffer2.length(), 0, result, dwFlags);\n        if (dx != null) {\n            int[] dx2 = new int[result.nGlyphs];\n            OS.MoveMemory(dx2, result.lpDx, dx2.length * 4);\n            if (isRightOriented) {\n                reverse(dx2);\n            }\n            System.arraycopy(dx2, 0, dx, glyphCount, dx2.length);\n        }\n        if (order != null) {\n            int[] order2 = new int[length];\n            OS.MoveMemory(order2, result.lpOrder, order2.length * 4);\n            translateOrder(order2, glyphCount, isRightOriented);\n            System.arraycopy(order2, 0, order, offset, length);\n        }\n        if (classBuffer != null) {\n            byte[] classBuffer2 = new byte[length];\n            OS.MoveMemory(classBuffer2, result.lpClass, classBuffer2.length);\n            System.arraycopy(classBuffer2, 0, classBuffer, offset, length);\n        }\n        char[] glyphBuffer2 = new char[result.nGlyphs];\n        OS.MoveMemory(glyphBuffer2, result.lpGlyphs, glyphBuffer2.length * 2);\n        if (isRightOriented) {\n            reverse(glyphBuffer2);\n        }\n        System.arraycopy(glyphBuffer2, 0, glyphBuffer, glyphCount, glyphBuffer2.length);\n        glyphCount += glyphBuffer2.length;\n        \n        \n        \n        \n        \n        result.lpOrder += length * 4;\n        result.lpDx += length * 4;\n        result.lpClass += length;\n        result.lpGlyphs += glyphBuffer2.length * 2;\n    }\n    \n    OS.HeapFree(hHeap, 0, lpGlyphs);\n    OS.HeapFree(hHeap, 0, lpClass);\n    OS.HeapFree(hHeap, 0, lpDx);\n    OS.HeapFree(hHeap, 0, lpOrder);\n    return glyphBuffer;\n}",
			"comments":"/**\n* Return ordering and rendering information for the given text.  Wraps the GetFontLanguageInfo\n* and GetCharacterPlacement functions.\n* <p>\n*\n* @param gc the GC to use for measuring of this line, input parameter\n* @param text text that bidi data should be calculated for, input parameter\n* @param order an array of integers representing the visual position of each character in\n*  the text array, output parameter\n* @param classBuffer an array of integers representing the type (e.g., ARABIC, HEBREW,\n*  LOCALNUMBER) of each character in the text array, input/output parameter\n* @param dx an array of integers representing the pixel width of each glyph in the returned\n*  glyph buffer, output paramteter\n* @param flags an integer representing rendering flag information, input parameter\n* @param offsets text segments that should be measured and reordered separately, input\n*  parameter. See org.eclipse.swt.custom.BidiSegmentEvent for details.\n* @return buffer with the glyphs that should be rendered for the given text\n*/\n// set required dwFlags\n// Always reorder.  We assume that if we are calling this function we're\n// on a platform that supports bidi.  Fixes 20690.\n// set classification values for the substring\n// The number of glyphs expected is <= length (segment length);\n// the actual number returned may be less in case of Arabic ligatures.\n// We concatenate successive results of calls to GCP.\n// For Arabic, it is the only good method since the number of output\n// glyphs might be less than the number of input characters.\n// This assumes that the whole line is built by successive adjacent\n// segments without overlapping.\n/* Free the memory that was allocated. */\n",
			"methodName":"public static char[] getRenderInfo(GC gc, String text, int[] order, byte[] classBuffer, int[] dx, int flags, int[] offsets)"
		},
		"static int windowProc(int hwnd, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    Integer key = new Integer(hwnd);\n    switch(msg) {\n        case 0x51:\n            \n            Runnable runnable = (Runnable) languageMap.get(key);\n            if (runnable != null)\n                runnable.run();\n            break;\n    }\n    Integer oldProc = (Integer) oldProcMap.get(key);\n    return OS.CallWindowProc(oldProc.intValue(), hwnd, msg, wParam, lParam);\n}",
			"comments":"/**\n* Window proc to intercept keyboard language switch event (WS_INPUTLANGCHANGE)\n* and widget orientation changes.\n* Run the Control's registered runnable when the keyboard language is switched.\n*\n* @param hwnd handle of the control that is listening for the keyboard language\n*  change event\n* @param msg window message\n*/\n/*OS.WM_INPUTLANGCHANGE*/\n",
			"methodName":"static int windowProc(int hwnd, int msg, int wParam, int lParam)"
		},
		"public static int getKeyboardLanguage()":{
			"methodBody":"{\n    int layout = OS.GetKeyboardLayout(0);\n    \n    \n    layout = layout & 0x000000FF;\n    if (layout == LANG_HEBREW)\n        return KEYBOARD_BIDI;\n    if (layout == LANG_ARABIC)\n        return KEYBOARD_BIDI;\n    \n    return KEYBOARD_NON_BIDI;\n}",
			"comments":"/**\n* Return the active keyboard language type.\n* <p>\n*\n* @return an integer representing the active keyboard language (KEYBOARD_BIDI,\n*  KEYBOARD_NON_BIDI)\n*/\n// only interested in low 2 bytes, which is the primary\n// language identifier\n// return non-bidi for all other languages\n",
			"methodName":"public static int getKeyboardLanguage()"
		},
		"public static void removeLanguageListener(int hwnd)":{
			"methodBody":"{\n    languageMap.remove(new Integer(hwnd));\n    unsubclass(hwnd);\n}",
			"comments":"/**\n* Removes the specified language listener.\n* <p>\n*\n* @param hwnd the handle of the Control that is listening for keyboard language changes\n*/\n",
			"methodName":"public static void removeLanguageListener(int hwnd)"
		},
		"static void reverse(int[] intArray)":{
			"methodBody":"{\n    int length = intArray.length;\n    for (int i = 0; i <= (length - 1) / 2; i++) {\n        int tmp = intArray[i];\n        intArray[i] = intArray[length - 1 - i];\n        intArray[length - 1 - i] = tmp;\n    }\n}",
			"comments":"/**\n*  Reverse the integer array.  Used for right orientation.\n*\n* @param intArray integer array to reverse\n*/\n",
			"methodName":"static void reverse(int[] intArray)"
		},
		"static int[] getKeyboardLanguageList()":{
			"methodBody":"{\n    int maxSize = 10;\n    int[] tempList = new int[maxSize];\n    int size = OS.GetKeyboardLayoutList(maxSize, tempList);\n    int[] list = new int[size];\n    System.arraycopy(tempList, 0, list, 0, size);\n    return list;\n}",
			"comments":"/**\n* Return the languages that are installed for the keyboard.\n* <p>\n*\n* @return integer array with an entry for each installed language\n*/\n",
			"methodName":"static int[] getKeyboardLanguageList()"
		},
		"static void subclass(int hwnd)":{
			"methodBody":"{\n    Integer key = new Integer(hwnd);\n    if (oldProcMap.get(key) == null) {\n        int oldProc = OS.GetWindowLong(hwnd, OS.GWL_WNDPROC);\n        oldProcMap.put(key, new Integer(oldProc));\n        OS.SetWindowLong(hwnd, OS.GWL_WNDPROC, callback.getAddress());\n    }\n}",
			"comments":"/**\n* Override the window proc.\n*\n* @param hwnd control to override the window proc of\n*/\n",
			"methodName":"static void subclass(int hwnd)"
		},
		"public static void addLanguageListener(int hwnd, Runnable runnable)":{
			"methodBody":"{\n    languageMap.put(new Integer(hwnd), runnable);\n    subclass(hwnd);\n}",
			"comments":"/**\n* Adds a language listener. The listener will get notified when the language of\n* the keyboard changes (via Alt-Shift on Win platforms).  Do this by creating a\n* window proc for the Control so that the window messages for the Control can be\n* monitored.\n* <p>\n*\n* @param hwnd the handle of the Control that is listening for keyboard language\n*  changes\n* @param runnable the code that should be executed when a keyboard language change\n*  occurs\n*/\n",
			"methodName":"public static void addLanguageListener(int hwnd, Runnable runnable)"
		},
		"public static void drawGlyphs(GC gc, char[] renderBuffer, int[] renderDx, int x, int y)":{
			"methodBody":"{\n    int length = renderDx.length;\n    if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION(4, 10)) {\n        if (OS.GetLayout(gc.handle) != 0) {\n            reverse(renderDx);\n            \n            renderDx[length - 1]--;\n            reverse(renderBuffer);\n        }\n    }\n    \n    int oldBkMode = OS.SetBkMode(gc.handle, OS.TRANSPARENT);\n    OS.ExtTextOutW(gc.handle, x, y, ETO_GLYPH_INDEX, null, renderBuffer, renderBuffer.length, renderDx);\n    OS.SetBkMode(gc.handle, oldBkMode);\n}",
			"comments":"/**\n* Wraps the ExtTextOut function.\n* <p>\n*\n* @param gc the gc to use for rendering\n* @param renderBuffer the glyphs to render as an array of characters\n* @param renderDx the width of each glyph in renderBuffer\n* @param x x position to start rendering\n* @param y y position to start rendering\n*/\n//fixes bug 40006\n// render transparently to avoid overlapping segments. fixes bug 40006\n",
			"methodName":"public static void drawGlyphs(GC gc, char[] renderBuffer, int[] renderDx, int x, int y)"
		},
		"public static void getOrderInfo(GC gc, String text, int[] order, byte[] classBuffer, int flags, int[] offsets)":{
			"methodBody":"{\n    int fontLanguageInfo = OS.GetFontLanguageInfo(gc.handle);\n    int hHeap = OS.GetProcessHeap();\n    int[] lpCs = new int[8];\n    int cs = OS.GetTextCharset(gc.handle);\n    OS.TranslateCharsetInfo(cs, lpCs, OS.TCI_SRCCHARSET);\n    TCHAR textBuffer = new TCHAR(lpCs[1], text, false);\n    int byteCount = textBuffer.length();\n    boolean isRightOriented = false;\n    if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION(4, 10)) {\n        isRightOriented = OS.GetLayout(gc.handle) != 0;\n    }\n    GCP_RESULTS result = new GCP_RESULTS();\n    result.lStructSize = GCP_RESULTS.sizeof;\n    result.nGlyphs = byteCount;\n    int lpOrder = result.lpOrder = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, byteCount * 4);\n    int lpClass = result.lpClass = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, byteCount);\n    \n    \n    int dwFlags = 0;\n    \n    \n    dwFlags |= GCP_REORDER;\n    if ((fontLanguageInfo & GCP_LIGATE) == GCP_LIGATE) {\n        dwFlags |= GCP_LIGATE;\n    }\n    if ((fontLanguageInfo & GCP_GLYPHSHAPE) == GCP_GLYPHSHAPE) {\n        dwFlags |= GCP_GLYPHSHAPE;\n    }\n    if ((flags & CLASSIN) == CLASSIN) {\n        \n        \n        dwFlags |= GCP_CLASSIN;\n        OS.MoveMemory(result.lpClass, classBuffer, classBuffer.length);\n    }\n    int glyphCount = 0;\n    for (int i = 0; i < offsets.length - 1; i++) {\n        int offset = offsets[i];\n        int length = offsets[i + 1] - offsets[i];\n        \n        \n        result.nGlyphs = length;\n        TCHAR textBuffer2 = new TCHAR(lpCs[1], text.substring(offset, offset + length), false);\n        OS.GetCharacterPlacement(gc.handle, textBuffer2, textBuffer2.length(), 0, result, dwFlags);\n        if (order != null) {\n            int[] order2 = new int[length];\n            OS.MoveMemory(order2, result.lpOrder, order2.length * 4);\n            translateOrder(order2, glyphCount, isRightOriented);\n            System.arraycopy(order2, 0, order, offset, length);\n        }\n        if (classBuffer != null) {\n            byte[] classBuffer2 = new byte[length];\n            OS.MoveMemory(classBuffer2, result.lpClass, classBuffer2.length);\n            System.arraycopy(classBuffer2, 0, classBuffer, offset, length);\n        }\n        glyphCount += result.nGlyphs;\n        \n        \n        \n        \n        \n        result.lpOrder += length * 4;\n        result.lpClass += length;\n    }\n    \n    OS.HeapFree(hHeap, 0, lpClass);\n    OS.HeapFree(hHeap, 0, lpOrder);\n}",
			"comments":"/**\n* Return bidi ordering information for the given text.  Does not return rendering\n* information (e.g., glyphs, glyph distances).  Use this method when you only need\n* ordering information.  Doing so will improve performance.  Wraps the\n* GetFontLanguageInfo and GetCharacterPlacement functions.\n* <p>\n*\n* @param gc the GC to use for measuring of this line, input parameter\n* @param text text that bidi data should be calculated for, input parameter\n* @param order an array of integers representing the visual position of each character in\n*  the text array, output parameter\n* @param classBuffer an array of integers representing the type (e.g., ARABIC, HEBREW,\n*  LOCALNUMBER) of each character in the text array, input/output parameter\n* @param flags an integer representing rendering flag information, input parameter\n* @param offsets text segments that should be measured and reordered separately, input\n*  parameter. See org.eclipse.swt.custom.BidiSegmentEvent for details.\n*/\n// set required dwFlags, these values will affect how the text gets rendered and\n// ordered\n// Always reorder.  We assume that if we are calling this function we're\n// on a platform that supports bidi.  Fixes 20690.\n// set classification values for the substring, classification values\n// can be specified on input\n// The number of glyphs expected is <= length (segment length);\n// the actual number returned may be less in case of Arabic ligatures.\n// We concatenate successive results of calls to GCP.\n// For Arabic, it is the only good method since the number of output\n// glyphs might be less than the number of input characters.\n// This assumes that the whole line is built by successive adjacent\n// segments without overlapping.\n/* Free the memory that was allocated. */\n",
			"methodName":"public static void getOrderInfo(GC gc, String text, int[] order, byte[] classBuffer, int flags, int[] offsets)"
		},
		"public static void setKeyboardLanguage(int language)":{
			"methodBody":"{\n    \n    if (language == getKeyboardLanguage())\n        return;\n    if (language == KEYBOARD_BIDI) {\n        \n        int[] list = getKeyboardLanguageList();\n        \n        for (int i = 0; i < list.length; i++) {\n            int id = list[i] & 0x000000FF;\n            if ((id == LANG_ARABIC) || (id == LANG_HEBREW)) {\n                OS.ActivateKeyboardLayout(list[i], 0);\n                return;\n            }\n        }\n    } else {\n        \n        int[] list = getKeyboardLanguageList();\n        \n        for (int i = 0; i < list.length; i++) {\n            int id = list[i] & 0x000000FF;\n            if ((id != LANG_HEBREW) && (id != LANG_ARABIC)) {\n                OS.ActivateKeyboardLayout(list[i], 0);\n                return;\n            }\n        }\n    }\n}",
			"comments":"/**\n* Switch the keyboard language to the specified language type.  We do\n* not distinguish between mulitple bidi or multiple non-bidi languages, so\n* set the keyboard to the first language of the given type.\n* <p>\n*\n* @param language integer representing language. One of\n* \tKEYBOARD_BIDI, KEYBOARD_NON_BIDI.\n*/\n// don't switch the keyboard if it doesn't need to be\n// get the list of active languages\n// set to first bidi language\n// get the list of active languages\n// set to the first non-bidi language (anything not\n// hebrew or arabic)\n",
			"methodName":"public static void setKeyboardLanguage(int language)"
		},
		"public static boolean setOrientation(int hwnd, int orientation)":{
			"methodBody":"{\n    if (OS.IsWinCE)\n        return false;\n    if (OS.WIN32_VERSION < OS.VERSION(4, 10))\n        return false;\n    int bits = OS.GetWindowLong(hwnd, OS.GWL_EXSTYLE);\n    if ((orientation & SWT.RIGHT_TO_LEFT) != 0) {\n        bits |= OS.WS_EX_LAYOUTRTL;\n    } else {\n        bits &= ~OS.WS_EX_LAYOUTRTL;\n    }\n    OS.SetWindowLong(hwnd, OS.GWL_EXSTYLE, bits);\n    return true;\n}",
			"comments":"/**\n* Sets the orientation (writing order) of the specified control. Text will\n* be right aligned for right to left writing order.\n* <p>\n*\n* @param hwnd the handle of the Control to change the orientation of\n* @param orientation one of SWT.RIGHT_TO_LEFT or SWT.LEFT_TO_RIGHT\n* @return true if the orientation was changed, false if the orientation\n* \tcould not be changed\n*/\n",
			"methodName":"public static boolean setOrientation(int hwnd, int orientation)"
		},
		"static void translateOrder(int[] orderArray, int glyphCount, boolean isRightOriented)":{
			"methodBody":"{\n    int maxOrder = 0;\n    int length = orderArray.length;\n    if (isRightOriented) {\n        for (int i = 0; i < length; i++) {\n            maxOrder = Math.max(maxOrder, orderArray[i]);\n        }\n    }\n    for (int i = 0; i < length; i++) {\n        if (isRightOriented)\n            orderArray[i] = maxOrder - orderArray[i];\n        orderArray[i] += glyphCount;\n    }\n}",
			"comments":"/**\n* Adjust the order array so that it is relative to the start of the line.  Also reverse the order array if the orientation\n* is to the right.\n*\n* @param orderArray  integer array of order values to translate\n* @param glyphCount  number of glyphs that have been processed for the current line\n* @param isRightOriented  flag indicating whether or not current orientation is to the right\n*/\n",
			"methodName":"static void translateOrder(int[] orderArray, int glyphCount, boolean isRightOriented)"
		},
		"static int EnumSystemLanguageGroupsProc(int lpLangGrpId, int lpLangGrpIdString, int lpLangGrpName, int options, int lParam)":{
			"methodBody":"{\n    if (lpLangGrpId == OS.LGRPID_HEBREW) {\n        isBidiPlatform = 1;\n        return 0;\n    }\n    if (lpLangGrpId == OS.LGRPID_ARABIC) {\n        isBidiPlatform = 1;\n        return 0;\n    }\n    return 1;\n}",
			"comments":"/**\n* Proc used for OS.EnumSystemLanguageGroups call during isBidiPlatform test.\n*/\n",
			"methodName":"static int EnumSystemLanguageGroupsProc(int lpLangGrpId, int lpLangGrpIdString, int lpLangGrpName, int options, int lParam)"
		},
		"static void unsubclass(int hwnd)":{
			"methodBody":"{\n    Integer key = new Integer(hwnd);\n    if (languageMap.get(key) == null && keyMap.get(key) == null) {\n        Integer proc = (Integer) oldProcMap.remove(key);\n        if (proc == null)\n            return;\n        OS.SetWindowLong(hwnd, OS.GWL_WNDPROC, proc.intValue());\n    }\n}",
			"comments":"/**\n* Remove the overridden the window proc.\n*\n* @param hwnd control to remove the window proc override for\n*/\n",
			"methodName":"static void unsubclass(int hwnd)"
		},
		"public static boolean isBidiPlatform()":{
			"methodBody":"{\n    if (OS.IsWinCE)\n        return false;\n    \n    if (isBidiPlatform != -1)\n        return isBidiPlatform == 1;\n    isBidiPlatform = 0;\n    \n    if (!isKeyboardBidi())\n        return false;\n    Callback callback = null;\n    try {\n        \n        callback = new Callback(Class.forName(CLASS_NAME), \"EnumSystemLanguageGroupsProc\", 5);\n        int lpEnumSystemLanguageGroupsProc = callback.getAddress();\n        if (lpEnumSystemLanguageGroupsProc == 0)\n            SWT.error(SWT.ERROR_NO_MORE_CALLBACKS);\n        OS.EnumSystemLanguageGroups(lpEnumSystemLanguageGroupsProc, OS.LGRPID_INSTALLED, 0);\n        callback.dispose();\n    } catch (ClassNotFoundException e) {\n        if (callback != null)\n            callback.dispose();\n    }\n    if (isBidiPlatform == 1)\n        return true;\n    \n    \n    String codePage = String.valueOf(OS.GetACP());\n    if (CD_PG_ARABIC.equals(codePage) || CD_PG_HEBREW.equals(codePage)) {\n        isBidiPlatform = 1;\n    }\n    return isBidiPlatform == 1;\n}",
			"comments":"/**\n* Return whether or not the platform supports a bidi language.  Determine this\n* by looking at the languages that are installed.\n* <p>\n*\n* @return true if bidi is supported, false otherwise. Always\n* \tfalse on Windows CE.\n*/\n// already set\n// The following test is a workaround for bug report 27629. On WinXP,\n// both bidi and complex script (e.g., Thai) languages must be installed\n// at the same time.  Since the bidi platform calls do not support\n// double byte characters, there is no way to run Eclipse using the\n// complex script languages on XP, so constrain this test to answer true\n// only if a bidi input language is defined.  Doing so will allow complex\n// script languages to work (e.g., one can install bidi and complex script\n// languages, but only install the Thai keyboard).\n//$NON-NLS-1$\n// need to look at system code page for NT & 98 platforms since EnumSystemLanguageGroups is\n// not supported for these platforms\n",
			"methodName":"public static boolean isBidiPlatform()"
		},
		"public static int getFontBidiAttributes(GC gc)":{
			"methodBody":"{\n    int fontStyle = 0;\n    int fontLanguageInfo = OS.GetFontLanguageInfo(gc.handle);\n    if (((fontLanguageInfo & GCP_REORDER) != 0)) {\n        fontStyle |= REORDER;\n    }\n    if (((fontLanguageInfo & GCP_LIGATE) != 0)) {\n        fontStyle |= LIGATE;\n    }\n    if (((fontLanguageInfo & GCP_GLYPHSHAPE) != 0)) {\n        fontStyle |= GLYPHSHAPE;\n    }\n    return fontStyle;\n}",
			"comments":"/**\n* Return bidi attribute information for the font in the specified gc.\n* <p>\n*\n* @param gc the gc to query\n* @return bitwise OR of the REORDER, LIGATE and GLYPHSHAPE flags\n* \tdefined by this class.\n*/\n",
			"methodName":"public static int getFontBidiAttributes(GC gc)"
		}
	},
	"ClassORInterfaceName":[
		"BidiUtil"
	]
}
