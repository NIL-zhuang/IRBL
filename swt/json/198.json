{
	"variables":[
		"signature",
		"screenWidth",
		"screenHeight",
		"backgroundPixel",
		"bitsPerPixel",
		"defaultDepth",
		"disposalMethod",
		"delayTime",
		"transparentPixel",
		"repeatCount",
		"GIF_APPLICATION_EXTENSION_BLOCK_ID",
		"GIF_GRAPHICS_CONTROL_BLOCK_ID",
		"GIF_PLAIN_TEXT_BLOCK_ID",
		"GIF_COMMENT_BLOCK_ID",
		"GIF_EXTENSION_BLOCK_ID",
		"GIF_IMAGE_BLOCK_ID",
		"GIF_TRAILER_ID",
		"n",
		"colors",
		"i",
		"intensity",
		"signature",
		"signatureBytes",
		"versionBytes",
		"block",
		"bitField",
		"palette",
		"id",
		"images",
		"image",
		"oldImages",
		"id",
		"extensionID",
		"extSize",
		"ext",
		"comment",
		"block",
		"size",
		"oldComment",
		"info",
		"text",
		"block",
		"size",
		"oldText",
		"controlBlock",
		"bitField",
		"colorIndex",
		"applicationBytes",
		"application",
		"authenticationBytes",
		"authentication",
		"data",
		"block",
		"size",
		"oldData",
		"depth",
		"palette",
		"block",
		"left",
		"top",
		"width",
		"height",
		"bitField",
		"interlaced",
		"initialCodeSize",
		"image",
		"codec",
		"bytes",
		"colors",
		"i",
		"bitField",
		"gcBlock",
		"block",
		"bytes",
		"offset",
		"i",
		"color",
		"numGrays",
		"numGrays",
		"i",
		"numGrays",
		"i",
		"i",
		"n",
		"colors",
		"i",
		"intensity",
		"intensity",
		"intensity",
		"colors",
		"stream",
		"signature",
		"stream",
		"signature",
		"signature",
		"inputStream",
		"signatureBytes",
		"signature",
		"signatureBytes",
		"signature",
		"SWT",
		"SWT",
		"inputStream",
		"versionBytes",
		"inputStream",
		"block",
		"SWT",
		"SWT",
		"e",
		"screenWidth",
		"block",
		"block",
		"loader",
		"screenWidth",
		"screenHeight",
		"block",
		"block",
		"loader",
		"screenHeight",
		"block",
		"backgroundPixel",
		"block",
		"bitsPerPixel",
		"bitField",
		"defaultDepth",
		"bitField",
		"bitField",
		"palette",
		"defaultDepth",
		"backgroundPixel",
		"defaultDepth",
		"bitsPerPixel",
		"loader",
		"backgroundPixel",
		"id",
		"GIF_IMAGE_BLOCK_ID",
		"palette",
		"loader",
		"loader",
		"loader",
		"image",
		"images",
		"images",
		"oldImages",
		"System",
		"oldImages",
		"images",
		"oldImages",
		"images",
		"images",
		"image",
		"id",
		"inputStream",
		"id",
		"inputStream",
		"id",
		"SWT",
		"SWT",
		"e",
		"id",
		"images",
		"inputStream",
		"SWT",
		"SWT",
		"e",
		"id",
		"GIF_IMAGE_BLOCK_ID",
		"id",
		"GIF_TRAILER_ID",
		"id",
		"id",
		"GIF_EXTENSION_BLOCK_ID",
		"SWT",
		"SWT",
		"id",
		"id",
		"GIF_IMAGE_BLOCK_ID",
		"id",
		"GIF_TRAILER_ID",
		"inputStream",
		"id",
		"SWT",
		"SWT",
		"e",
		"extensionID",
		"GIF_COMMENT_BLOCK_ID",
		"extensionID",
		"GIF_PLAIN_TEXT_BLOCK_ID",
		"extensionID",
		"GIF_GRAPHICS_CONTROL_BLOCK_ID",
		"extensionID",
		"GIF_APPLICATION_EXTENSION_BLOCK_ID",
		"inputStream",
		"extSize",
		"SWT",
		"SWT",
		"extSize",
		"inputStream",
		"ext",
		"extSize",
		"ext",
		"SWT",
		"SWT",
		"e",
		"inputStream",
		"size",
		"inputStream",
		"block",
		"size",
		"comment",
		"comment",
		"oldComment",
		"size",
		"System",
		"oldComment",
		"comment",
		"oldComment",
		"System",
		"block",
		"comment",
		"oldComment",
		"size",
		"size",
		"inputStream",
		"comment",
		"SWT",
		"SWT",
		"e",
		"inputStream",
		"inputStream",
		"info",
		"inputStream",
		"size",
		"inputStream",
		"block",
		"size",
		"text",
		"text",
		"oldText",
		"size",
		"System",
		"oldText",
		"text",
		"oldText",
		"System",
		"block",
		"text",
		"oldText",
		"size",
		"size",
		"inputStream",
		"text",
		"SWT",
		"SWT",
		"e",
		"inputStream",
		"inputStream",
		"controlBlock",
		"controlBlock",
		"disposalMethod",
		"bitField",
		"delayTime",
		"controlBlock",
		"controlBlock",
		"bitField",
		"controlBlock",
		"colorIndex",
		"defaultDepth",
		"transparentPixel",
		"colorIndex",
		"transparentPixel",
		"inputStream",
		"controlBlock",
		"SWT",
		"SWT",
		"e",
		"inputStream",
		"inputStream",
		"applicationBytes",
		"applicationBytes",
		"inputStream",
		"authenticationBytes",
		"authenticationBytes",
		"inputStream",
		"size",
		"inputStream",
		"block",
		"size",
		"data",
		"data",
		"oldData",
		"size",
		"System",
		"oldData",
		"data",
		"oldData",
		"System",
		"block",
		"data",
		"oldData",
		"size",
		"size",
		"inputStream",
		"application",
		"authentication",
		"data",
		"repeatCount",
		"data",
		"data",
		"loader",
		"repeatCount",
		"data",
		"SWT",
		"SWT",
		"e",
		"inputStream",
		"block",
		"SWT",
		"SWT",
		"e",
		"block",
		"block",
		"block",
		"block",
		"block",
		"block",
		"block",
		"block",
		"block",
		"bitField",
		"bitField",
		"depth",
		"bitField",
		"palette",
		"depth",
		"depth",
		"defaultDepth",
		"palette",
		"defaultPalette",
		"depth",
		"depth",
		"depth",
		"depth",
		"depth",
		"depth",
		"palette",
		"palette",
		"depth",
		"initialCodeSize",
		"inputStream",
		"SWT",
		"SWT",
		"e",
		"initialCodeSize",
		"SWT",
		"SWT",
		"ImageData",
		"width",
		"height",
		"depth",
		"palette",
		"transparentPixel",
		"SWT",
		"left",
		"top",
		"disposalMethod",
		"delayTime",
		"codec",
		"inputStream",
		"loader",
		"image",
		"interlaced",
		"initialCodeSize",
		"image",
		"numColors",
		"inputStream",
		"bytes",
		"bytes",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"e",
		"numColors",
		"i",
		"numColors",
		"i",
		"colors",
		"i",
		"bytes",
		"i",
		"bytes",
		"i",
		"bytes",
		"i",
		"colors",
		"image",
		"image",
		"image",
		"SWT",
		"SWT",
		"image",
		"image",
		"outputStream",
		"outputStream",
		"outputStream",
		"image",
		"outputStream",
		"image",
		"outputStream",
		"bitField",
		"outputStream",
		"outputStream",
		"SWT",
		"SWT",
		"e",
		"image",
		"image",
		"image",
		"image",
		"image",
		"image",
		"image",
		"outputStream",
		"SWT",
		"SWT",
		"e",
		"outputStream",
		"GIF_EXTENSION_BLOCK_ID",
		"outputStream",
		"GIF_GRAPHICS_CONTROL_BLOCK_ID",
		"outputStream",
		"gcBlock",
		"gcBlock",
		"gcBlock",
		"gcBlock",
		"image",
		"gcBlock",
		"gcBlock",
		"gcBlock",
		"gcBlock",
		"gcBlock",
		"image",
		"image",
		"gcBlock",
		"gcBlock",
		"image",
		"image",
		"gcBlock",
		"image",
		"gcBlock",
		"image",
		"outputStream",
		"gcBlock",
		"outputStream",
		"SWT",
		"SWT",
		"e",
		"outputStream",
		"GIF_IMAGE_BLOCK_ID",
		"block",
		"image",
		"block",
		"image",
		"block",
		"image",
		"block",
		"image",
		"block",
		"image",
		"block",
		"image",
		"block",
		"image",
		"block",
		"image",
		"block",
		"outputStream",
		"block",
		"outputStream",
		"image",
		"SWT",
		"SWT",
		"e",
		"outputStream",
		"image",
		"depth",
		"i",
		"palette",
		"i",
		"palette",
		"i",
		"bytes",
		"offset",
		"color",
		"bytes",
		"offset",
		"color",
		"bytes",
		"offset",
		"color",
		"offset",
		"outputStream",
		"bytes",
		"SWT",
		"SWT",
		"e",
		"ERROR_INVALID_IMAGE",
		"ERROR_IO",
		"logicalScreenWidth",
		"logicalScreenHeight",
		"backgroundPixel",
		"length",
		"length",
		"length",
		"ERROR_IO",
		"ERROR_IO",
		"ERROR_INVALID_IMAGE",
		"ERROR_IO",
		"ERROR_INVALID_IMAGE",
		"ERROR_IO",
		"length",
		"length",
		"length",
		"ERROR_IO",
		"length",
		"length",
		"length",
		"ERROR_IO",
		"ERROR_IO",
		"length",
		"length",
		"length",
		"repeatCount",
		"ERROR_IO",
		"ERROR_IO",
		"ERROR_IO",
		"ERROR_INVALID_IMAGE",
		"IMAGE_GIF",
		"length",
		"ERROR_INVALID_IMAGE",
		"ERROR_IO",
		"depth",
		"depth",
		"depth",
		"ERROR_UNSUPPORTED_DEPTH",
		"depth",
		"depth",
		"width",
		"height",
		"ERROR_IO",
		"palette",
		"depth",
		"transparentPixel",
		"disposalMethod",
		"delayTime",
		"ERROR_IO",
		"transparentPixel",
		"transparentPixel",
		"disposalMethod",
		"disposalMethod",
		"delayTime",
		"delayTime",
		"delayTime",
		"ERROR_IO",
		"x",
		"x",
		"y",
		"y",
		"width",
		"width",
		"height",
		"height",
		"depth",
		"ERROR_IO",
		"length",
		"colors",
		"colors",
		"red",
		"green",
		"blue",
		"ERROR_IO",
		"numGrays",
		"stream",
		"e",
		"e",
		"e",
		"e",
		"e",
		"e",
		"e",
		"e",
		"e",
		"e",
		"defaultPalette",
		"e",
		"e",
		"numColors",
		"e",
		"image",
		"e",
		"e",
		"image",
		"e",
		"image",
		"e",
		"palette",
		"depth",
		"e"
	],
	"extendORImplementFiles":[
		"FileFormat"
	],
	"package":[
		"org.eclipse.swt.internal.image"
	],
	"import":[
		"org.eclipse.swt",
		"org.eclipse.swt.graphics",
		"java.io"
	],
	"methods":[
		"grayRamp",
		"isFileFormat",
		"loadFromByteStream",
		"readID",
		"getExtensions",
		"readExtension",
		"readCommentExtension",
		"readPlainTextExtension",
		"readGraphicsControlExtension",
		"readApplicationExtension",
		"readImageBlock",
		"readPalette",
		"unloadIntoByteStream",
		"writeGraphicsControlBlock",
		"writeImageBlock",
		"writePalette",
		"read",
		"unread",
		"equals",
		"read",
		"equals",
		"error",
		"read",
		"read",
		"error",
		"readPalette",
		"getExtensions",
		"readID",
		"readImageBlock",
		"hasListeners",
		"notifyListeners",
		"arraycopy",
		"read",
		"unread",
		"error",
		"getExtensions",
		"readID",
		"read",
		"error",
		"readID",
		"readExtension",
		"error",
		"readID",
		"unread",
		"error",
		"readID",
		"readCommentExtension",
		"readPlainTextExtension",
		"readGraphicsControlExtension",
		"readApplicationExtension",
		"read",
		"error",
		"read",
		"error",
		"read",
		"read",
		"arraycopy",
		"arraycopy",
		"read",
		"error",
		"read",
		"read",
		"read",
		"read",
		"arraycopy",
		"arraycopy",
		"read",
		"error",
		"read",
		"read",
		"read",
		"error",
		"read",
		"read",
		"read",
		"read",
		"read",
		"arraycopy",
		"arraycopy",
		"read",
		"equals",
		"equals",
		"error",
		"read",
		"error",
		"readPalette",
		"grayRamp",
		"read",
		"error",
		"error",
		"internal_new",
		"decode",
		"read",
		"error",
		"error",
		"error",
		"write",
		"write",
		"writeShort",
		"writeShort",
		"writeByte",
		"writeByte",
		"writeByte",
		"error",
		"writePalette",
		"writeGraphicsControlBlock",
		"writeImageBlock",
		"write",
		"error",
		"write",
		"write",
		"write",
		"write",
		"write",
		"error",
		"write",
		"write",
		"write",
		"error",
		"encode",
		"write",
		"error",
		"RGB",
		"PaletteData",
		"String",
		"String",
		"ImageLoaderEvent",
		"String",
		"String",
		"LZWCodec",
		"RGB",
		"PaletteData",
		"LZWCodec"
	],
	"methodsBody":{
		"ImageData[] loadFromByteStream()":{
			"methodBody":"{\n    byte[] signatureBytes = new byte[3];\n    byte[] versionBytes = new byte[3];\n    byte[] block = new byte[7];\n    try {\n        inputStream.read(signatureBytes);\n        signature = new String(signatureBytes);\n        if (\n        !signature.equals(\"GIF\"))\n            SWT.error(SWT.ERROR_INVALID_IMAGE);\n        inputStream.read(versionBytes);\n        inputStream.read(block);\n    } catch (IOException e) {\n        SWT.error(SWT.ERROR_IO, e);\n    }\n    screenWidth = (block[0] & 0xFF) | ((block[1] & 0xFF) << 8);\n    loader.logicalScreenWidth = screenWidth;\n    screenHeight = (block[2] & 0xFF) | ((block[3] & 0xFF) << 8);\n    loader.logicalScreenHeight = screenHeight;\n    byte bitField = block[4];\n    backgroundPixel = block[5] & 0xFF;\n    \n    bitsPerPixel = ((bitField >> 4) & 0x07) + 1;\n    defaultDepth = (bitField & 0x7) + 1;\n    PaletteData palette = null;\n    if ((bitField & 0x80) != 0) {\n        \n        \n        palette = readPalette(1 << defaultDepth);\n    } else {\n        \n        \n        backgroundPixel = -1;\n        defaultDepth = bitsPerPixel;\n    }\n    loader.backgroundPixel = backgroundPixel;\n    getExtensions();\n    int id = readID();\n    ImageData[] images = new ImageData[0];\n    while (id == GIF_IMAGE_BLOCK_ID) {\n        ImageData image = readImageBlock(palette);\n        if (loader.hasListeners()) {\n            loader.notifyListeners(new ImageLoaderEvent(loader, image, 3, true));\n        }\n        ImageData[] oldImages = images;\n        images = new ImageData[oldImages.length + 1];\n        System.arraycopy(oldImages, 0, images, 0, oldImages.length);\n        images[images.length - 1] = image;\n        try {\n            \n            id = inputStream.read();\n            if (id > 0) {\n                \n                inputStream.unread(new byte[] { (byte) id });\n            }\n        } catch (IOException e) {\n            SWT.error(SWT.ERROR_IO, e);\n        }\n        getExtensions();\n        id = readID();\n    }\n    return images;\n}",
			"comments":"/**\n* Load the GIF image(s) stored in the input stream.\n* Return an array of ImageData representing the image(s).\n*/\n//$NON-NLS-1$\n//aspect = block[6] & 0xFF;\n// Global palette.\n//sorted = (bitField & 0x8) != 0;\n// No global palette.\n//sorted = false;\n/* Read the 0-byte terminator at the end of the image. */\n/* We read the terminator earlier. */\n",
			"methodName":"ImageData[] loadFromByteStream()"
		},
		"PaletteData readPalette(int numColors)":{
			"methodBody":"{\n    byte[] bytes = new byte[numColors * 3];\n    try {\n        if (inputStream.read(bytes) != bytes.length)\n            SWT.error(SWT.ERROR_INVALID_IMAGE);\n    } catch (IOException e) {\n        SWT.error(SWT.ERROR_IO, e);\n    }\n    RGB[] colors = new RGB[numColors];\n    for (int i = 0; i < numColors; i++) colors[i] = new RGB(bytes[i * 3] & 0xFF, bytes[i * 3 + 1] & 0xFF, bytes[i * 3 + 2] & 0xFF);\n    return new PaletteData(colors);\n}",
			"comments":"/**\n* Read a palette from the input stream.\n*/\n",
			"methodName":"PaletteData readPalette(int numColors)"
		},
		"byte[] readPlainTextExtension()":{
			"methodBody":"{\n    try {\n        \n        inputStream.read();\n        \n        byte[] info = new byte[12];\n        inputStream.read(info);\n        \n        byte[] text = new byte[0];\n        byte[] block = new byte[255];\n        int size = inputStream.read();\n        while ((size > 0) && (inputStream.read(block, 0, size) != -1)) {\n            byte[] oldText = text;\n            text = new byte[oldText.length + size];\n            System.arraycopy(oldText, 0, text, 0, oldText.length);\n            System.arraycopy(block, 0, text, oldText.length, size);\n            size = inputStream.read();\n        }\n        return text;\n    } catch (Exception e) {\n        SWT.error(SWT.ERROR_IO, e);\n        return null;\n    }\n}",
			"comments":"/**\n* We have just read the PlainText extension identifier\n* from the input stream. Read in the plain text info and text,\n* and return the text. GIF plain text blocks are variable size.\n*/\n// Read size of block = 0x0C.\n// Read the text information (x, y, width, height, colors).\n// Read the text.\n",
			"methodName":"byte[] readPlainTextExtension()"
		},
		"byte[] readGraphicsControlExtension()":{
			"methodBody":"{\n    try {\n        \n        inputStream.read();\n        \n        byte[] controlBlock = new byte[4];\n        inputStream.read(controlBlock);\n        byte bitField = controlBlock[0];\n        \n        \n        \n        disposalMethod = (bitField >> 2) & 0x07;\n        \n        delayTime = (controlBlock[1] & 0xFF) | ((controlBlock[2] & 0xFF) << 8);\n        \n        if ((bitField & 0x01) != 0) {\n            int colorIndex = controlBlock[3] & 0xFF;\n            \n            if (colorIndex <= 1 << defaultDepth) {\n                transparentPixel = colorIndex;\n            }\n        } else {\n            transparentPixel = -1;\n        }\n        \n        inputStream.read();\n        return controlBlock;\n    } catch (Exception e) {\n        SWT.error(SWT.ERROR_IO, e);\n        return null;\n    }\n}",
			"comments":"/**\n* We have just read the GraphicsControl extension identifier\n* from the input stream. Read in the control information, store\n* it, and return it.\n*/\n// Read size of block = 0x04.\n// Read the control block.\n// Store the user input field.\n//userInput = (bitField & 0x02) != 0;\n// Store the disposal method.\n// Store the delay time.\n// Store the transparent color.\n/* Work around: a customer has a GIF that specifies an\n* invalid color index that is larger than the number\n* of entries in the palette. Detect this case, and\n* ignore the specified color index. */\n// Read block terminator.\n",
			"methodName":"byte[] readGraphicsControlExtension()"
		},
		"byte[] readCommentExtension()":{
			"methodBody":"{\n    try {\n        byte[] comment = new byte[0];\n        byte[] block = new byte[255];\n        int size = inputStream.read();\n        while ((size > 0) && (inputStream.read(block, 0, size) != -1)) {\n            byte[] oldComment = comment;\n            comment = new byte[oldComment.length + size];\n            System.arraycopy(oldComment, 0, comment, 0, oldComment.length);\n            System.arraycopy(block, 0, comment, oldComment.length, size);\n            size = inputStream.read();\n        }\n        return comment;\n    } catch (Exception e) {\n        SWT.error(SWT.ERROR_IO, e);\n        return null;\n    }\n}",
			"comments":"/**\n* We have just read the Comment extension identifier\n* from the input stream. Read in the rest of the comment\n* and return it. GIF comment blocks are variable size.\n*/\n",
			"methodName":"byte[] readCommentExtension()"
		},
		"byte[] readApplicationExtension()":{
			"methodBody":"{\n    try {\n        \n        inputStream.read();\n        \n        byte[] applicationBytes = new byte[8];\n        inputStream.read(applicationBytes);\n        String application = new String(applicationBytes);\n        \n        byte[] authenticationBytes = new byte[3];\n        inputStream.read(authenticationBytes);\n        String authentication = new String(authenticationBytes);\n        \n        byte[] data = new byte[0];\n        byte[] block = new byte[255];\n        int size = inputStream.read();\n        while ((size > 0) && (inputStream.read(block, 0, size) != -1)) {\n            byte[] oldData = data;\n            data = new byte[oldData.length + size];\n            System.arraycopy(oldData, 0, data, 0, oldData.length);\n            System.arraycopy(block, 0, data, oldData.length, size);\n            size = inputStream.read();\n        }\n        \n        if (application.equals(\"NETSCAPE\") && authentication.equals(\"2.0\") && data[0] == 01) {\n            \n            repeatCount = (data[1] & 0xFF) | ((data[2] & 0xFF) << 8);\n            loader.repeatCount = repeatCount;\n        }\n        return data;\n    } catch (Exception e) {\n        SWT.error(SWT.ERROR_IO, e);\n        return null;\n    }\n}",
			"comments":"/**\n* We have just read the Application extension identifier\n* from the input stream.  Read in the rest of the extension,\n* look for and store 'number of repeats', and return the data.\n*/\n// Read size of block = 0x0B.\n// Read application identifier.\n// Read authentication code.\n// Read application data.\n// Look for the NETSCAPE 'repeat count' field for an animated GIF.\n//$NON-NLS-1$ //$NON-NLS-2$\n",
			"methodName":"byte[] readApplicationExtension()"
		},
		"void getExtensions()":{
			"methodBody":"{\n    int id = readID();\n    while (id != GIF_IMAGE_BLOCK_ID && id != GIF_TRAILER_ID && id > 0) {\n        if (id == GIF_EXTENSION_BLOCK_ID) {\n            readExtension();\n        } else {\n            SWT.error(SWT.ERROR_INVALID_IMAGE);\n        }\n        id = readID();\n    }\n    if (id == GIF_IMAGE_BLOCK_ID || id == GIF_TRAILER_ID) {\n        try {\n            inputStream.unread(new byte[] { (byte) id });\n        } catch (IOException e) {\n            SWT.error(SWT.ERROR_IO, e);\n        }\n    }\n}",
			"comments":"/**\n* Read extensions until an image descriptor appears.\n* In the future, if we care about the extensions, they\n* should be properly grouped with the image data before\n* which they appeared. Right now, the interesting parts\n* of some extensions are kept, but the rest is discarded.\n* Throw an error if an error occurs.\n*/\n",
			"methodName":"void getExtensions()"
		},
		"void writeImageBlock(ImageData image)":{
			"methodBody":"{\n    try {\n        outputStream.write(GIF_IMAGE_BLOCK_ID);\n        byte[] block = new byte[9];\n        block[0] = (byte) (image.x & 0xFF);\n        block[1] = (byte) ((image.x >> 8) & 0xFF);\n        block[2] = (byte) (image.y & 0xFF);\n        block[3] = (byte) ((image.y >> 8) & 0xFF);\n        block[4] = (byte) (image.width & 0xFF);\n        block[5] = (byte) ((image.width >> 8) & 0xFF);\n        block[6] = (byte) (image.height & 0xFF);\n        block[7] = (byte) ((image.height >> 8) & 0xFF);\n        \n        block[8] = 0;\n        outputStream.write(block);\n        outputStream.write(image.depth);\n    } catch (IOException e) {\n        SWT.error(SWT.ERROR_IO, e);\n    }\n    new LZWCodec().encode(outputStream, image);\n}",
			"comments":"/**\n* Write the specified device independent image\n* to the current position in the output stream.\n*/\n// no interlace, no sort, no local palette\n",
			"methodName":"void writeImageBlock(ImageData image)"
		},
		"boolean isFileFormat(LEDataInputStream stream)":{
			"methodBody":"{\n    try {\n        byte[] signature = new byte[3];\n        stream.read(signature);\n        stream.unread(signature);\n        \n        return new String(signature).equals(\"GIF\");\n    } catch (Exception e) {\n        return false;\n    }\n}",
			"comments":"//$NON-NLS-1$\n",
			"methodName":"boolean isFileFormat(LEDataInputStream stream)"
		},
		"static PaletteData grayRamp(int numGrays)":{
			"methodBody":"{\n    int n = numGrays - 1;\n    RGB[] colors = new RGB[numGrays];\n    for (int i = 0; i < numGrays; i++) {\n        int intensity = (byte) ((i * 3) * 256 / n);\n        colors[i] = new RGB(intensity, intensity, intensity);\n    }\n    return new PaletteData(colors);\n}",
			"comments":"/**\n* Answer a palette containing numGrays\n* shades of gray, ranging from black to white.\n*/\n",
			"methodName":"static PaletteData grayRamp(int numGrays)"
		},
		"ImageData readImageBlock(PaletteData defaultPalette)":{
			"methodBody":"{\n    int depth;\n    PaletteData palette;\n    byte[] block = new byte[9];\n    try {\n        inputStream.read(block);\n    } catch (IOException e) {\n        SWT.error(SWT.ERROR_IO, e);\n    }\n    int left = (block[0] & 0xFF) | ((block[1] & 0xFF) << 8);\n    int top = (block[2] & 0xFF) | ((block[3] & 0xFF) << 8);\n    int width = (block[4] & 0xFF) | ((block[5] & 0xFF) << 8);\n    int height = (block[6] & 0xFF) | ((block[7] & 0xFF) << 8);\n    byte bitField = block[8];\n    boolean interlaced = (bitField & 0x40) != 0;\n    \n    if ((bitField & 0x80) != 0) {\n        \n        depth = (bitField & 0x7) + 1;\n        palette = readPalette(1 << depth);\n    } else {\n        \n        depth = defaultDepth;\n        palette = defaultPalette;\n    }\n    \n    if (!(depth == 1 || depth == 4 || depth == 8)) {\n        if (depth < 4)\n            depth = 4;\n        else\n            depth = 8;\n    }\n    if (palette == null) {\n        palette = grayRamp(1 << depth);\n    }\n    int initialCodeSize = -1;\n    try {\n        initialCodeSize = inputStream.read();\n    } catch (IOException e) {\n        SWT.error(SWT.ERROR_IO, e);\n    }\n    if (initialCodeSize < 0) {\n        SWT.error(SWT.ERROR_INVALID_IMAGE);\n    }\n    ImageData image = ImageData.internal_new(width, height, depth, palette, 4, null, 0, null, null, -1, transparentPixel, SWT.IMAGE_GIF, left, top, disposalMethod, delayTime);\n    LZWCodec codec = new LZWCodec();\n    codec.decode(inputStream, loader, image, interlaced, initialCodeSize);\n    return image;\n}",
			"comments":"/**\n* Return a DeviceIndependentImage representing the\n* image block at the current position in the input stream.\n* Throw an error if an error occurs.\n*/\n//boolean sorted = (bitField & 0x20) != 0;\n// Local palette.\n// No local palette.\n// Promote depth to next highest supported value.\n",
			"methodName":"ImageData readImageBlock(PaletteData defaultPalette)"
		},
		"void unloadIntoByteStream(ImageData image)":{
			"methodBody":"{\n    if (!((image.depth == 1) || (image.depth == 4) || (image.depth == 8))) {\n        SWT.error(SWT.ERROR_UNSUPPORTED_DEPTH);\n    }\n    byte bitField = (byte) ((0x80 & 0xF8 & 0xF7 & 0x8F) + (image.depth - 1) + ((image.depth - 1) * 16));\n    try {\n        outputStream.write(new byte[] { (byte) 'G', (byte) 'I', (byte) 'F' });\n        outputStream.write(new byte[] { (byte) '8', (byte) '9', (byte) 'a' });\n        outputStream.writeShort((short) image.width);\n        outputStream.writeShort((short) image.height);\n        outputStream.writeByte(bitField);\n        outputStream.writeByte((byte) 0);\n        outputStream.writeByte((byte) 0);\n    } catch (IOException e) {\n        SWT.error(SWT.ERROR_IO, e);\n    }\n    writePalette(image.palette, image.depth);\n    if (image.transparentPixel != -1 || image.disposalMethod != 0 || image.delayTime != 0) {\n        writeGraphicsControlBlock(image);\n    }\n    writeImageBlock(image);\n    try {\n        outputStream.write(0x3B);\n    } catch (IOException e) {\n        SWT.error(SWT.ERROR_IO, e);\n    }\n}",
			"comments":"/**\n* Write the specified device independent image\n* to the output stream.\n*/\n",
			"methodName":"void unloadIntoByteStream(ImageData image)"
		},
		"int readID()":{
			"methodBody":"{\n    try {\n        return inputStream.read();\n    } catch (IOException e) {\n        SWT.error(SWT.ERROR_IO, e);\n    }\n    return -1;\n}",
			"comments":"/**\n* Read and return the next block or extension identifier from the file.\n*/\n",
			"methodName":"int readID()"
		},
		"void writeGraphicsControlBlock(ImageData image)":{
			"methodBody":"{\n    try {\n        outputStream.write(GIF_EXTENSION_BLOCK_ID);\n        outputStream.write(GIF_GRAPHICS_CONTROL_BLOCK_ID);\n        \n        outputStream.write(0x04);\n        byte[] gcBlock = new byte[4];\n        gcBlock[0] = (byte) 0xFD;\n        gcBlock[1] = 0;\n        gcBlock[2] = 0;\n        gcBlock[3] = 0;\n        if (image.transparentPixel == -1) {\n            gcBlock[0] = (byte) (gcBlock[0] & 0xFE);\n        } else {\n            gcBlock[0] = (byte) (gcBlock[0] | 0x01);\n            gcBlock[3] = (byte) image.transparentPixel;\n        }\n        if (image.disposalMethod != 0) {\n            gcBlock[0] = (byte) (gcBlock[0] | ((image.disposalMethod & 0x07) << 2));\n        }\n        if (image.delayTime != 0) {\n            gcBlock[1] = (byte) (image.delayTime & 0xFF);\n            gcBlock[2] = (byte) ((image.delayTime >> 8) & 0xFF);\n        }\n        outputStream.write(gcBlock);\n        \n        outputStream.write(0);\n    } catch (IOException e) {\n        SWT.error(SWT.ERROR_IO, e);\n    }\n}",
			"comments":"/**\n* Write out a GraphicsControlBlock to describe\n* the specified device independent image.\n*/\n// size of block\n// block terminator\n",
			"methodName":"void writeGraphicsControlBlock(ImageData image)"
		},
		"byte[] readExtension()":{
			"methodBody":"{\n    int extensionID = readID();\n    if (extensionID == GIF_COMMENT_BLOCK_ID)\n        return readCommentExtension();\n    if (extensionID == GIF_PLAIN_TEXT_BLOCK_ID)\n        return readPlainTextExtension();\n    if (extensionID == GIF_GRAPHICS_CONTROL_BLOCK_ID)\n        return readGraphicsControlExtension();\n    if (extensionID == GIF_APPLICATION_EXTENSION_BLOCK_ID)\n        return readApplicationExtension();\n    \n    try {\n        int extSize = inputStream.read();\n        if (extSize < 0) {\n            SWT.error(SWT.ERROR_INVALID_IMAGE);\n        }\n        byte[] ext = new byte[extSize];\n        inputStream.read(ext, 0, extSize);\n        return ext;\n    } catch (IOException e) {\n        SWT.error(SWT.ERROR_IO, e);\n        return null;\n    }\n}",
			"comments":"/**\n* Read a control extension.\n* Return the extension block data.\n*/\n// Otherwise, we don't recognize the block. If the\n// field size is correct, we can just skip over\n// the block contents.\n",
			"methodName":"byte[] readExtension()"
		},
		"void writePalette(PaletteData palette, int depth)":{
			"methodBody":"{\n    byte[] bytes = new byte[(1 << depth) * 3];\n    int offset = 0;\n    for (int i = 0; i < palette.colors.length; i++) {\n        RGB color = palette.colors[i];\n        bytes[offset] = (byte) color.red;\n        bytes[offset + 1] = (byte) color.green;\n        bytes[offset + 2] = (byte) color.blue;\n        offset += 3;\n    }\n    try {\n        outputStream.write(bytes);\n    } catch (IOException e) {\n        SWT.error(SWT.ERROR_IO, e);\n    }\n}",
			"comments":"/**\n* Write the specified palette to the output stream.\n*/\n",
			"methodName":"void writePalette(PaletteData palette, int depth)"
		}
	},
	"ClassORInterfaceName":[
		"GIFFileFormat"
	]
}
