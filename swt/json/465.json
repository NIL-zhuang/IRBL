{
	"variables":[
		"increment",
		"pageIncrement",
		"ScrollBarProc",
		"ScrollBarClass",
		"lpWndClass",
		"typedListener",
		"border",
		"width",
		"height",
		"info",
		"flags",
		"info",
		"info",
		"info",
		"info",
		"info",
		"info",
		"result",
		"info",
		"info",
		"info",
		"bits",
		"bits",
		"result",
		"key",
		"code",
		"oldBits",
		"newBits",
		"result",
		"oldBits",
		"newBits",
		"result",
		"code",
		"event",
		"info",
		"OS",
		"ScrollBarClass",
		"lpWndClass",
		"ScrollBarProc",
		"lpWndClass",
		"parent",
		"style",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"SWT",
		"typedListener",
		"handle",
		"msg",
		"OS",
		"OS",
		"display",
		"OS",
		"ScrollBarProc",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"style",
		"SWT",
		"SWT",
		"border",
		"border",
		"style",
		"SWT",
		"width",
		"OS",
		"OS",
		"height",
		"OS",
		"OS",
		"width",
		"OS",
		"OS",
		"height",
		"OS",
		"OS",
		"wHint",
		"SWT",
		"width",
		"wHint",
		"border",
		"hHint",
		"SWT",
		"height",
		"hHint",
		"border",
		"width",
		"height",
		"increment",
		"pageIncrement",
		"info",
		"SCROLLINFO",
		"info",
		"OS",
		"info",
		"info",
		"OS",
		"handle",
		"OS",
		"info",
		"OS",
		"OS",
		"OS",
		"OS",
		"enabled",
		"OS",
		"enabled",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"flags",
		"enabled",
		"state",
		"DISABLED",
		"state",
		"DISABLED",
		"state",
		"DISABLED",
		"increment",
		"info",
		"SCROLLINFO",
		"info",
		"OS",
		"OS",
		"handle",
		"OS",
		"info",
		"info",
		"info",
		"SCROLLINFO",
		"info",
		"OS",
		"OS",
		"handle",
		"OS",
		"info",
		"info",
		"pageIncrement",
		"info",
		"SCROLLINFO",
		"info",
		"OS",
		"OS",
		"handle",
		"OS",
		"info",
		"info",
		"info",
		"SCROLLINFO",
		"info",
		"OS",
		"OS",
		"handle",
		"OS",
		"info",
		"info",
		"info",
		"info",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"eventTable",
		"SWT",
		"listener",
		"x",
		"y",
		"width",
		"height",
		"flags",
		"OS",
		"handle",
		"OS",
		"handle",
		"OS",
		"value",
		"increment",
		"value",
		"value",
		"info",
		"SCROLLINFO",
		"info",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"info",
		"value",
		"info",
		"info",
		"info",
		"value",
		"handle",
		"OS",
		"info",
		"value",
		"info",
		"SCROLLINFO",
		"info",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"info",
		"info",
		"value",
		"info",
		"info",
		"value",
		"handle",
		"OS",
		"info",
		"value",
		"pageIncrement",
		"value",
		"state",
		"DISABLED",
		"fRedraw",
		"OS",
		"hwnd",
		"flags",
		"info",
		"fRedraw",
		"state",
		"DISABLED",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"handle",
		"OS",
		"result",
		"info",
		"SCROLLINFO",
		"info",
		"OS",
		"info",
		"value",
		"handle",
		"OS",
		"info",
		"value",
		"info",
		"SCROLLINFO",
		"info",
		"OS",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"info",
		"info",
		"value",
		"info",
		"info",
		"handle",
		"OS",
		"info",
		"minimum",
		"maximum",
		"thumb",
		"increment",
		"pageIncrement",
		"increment",
		"pageIncrement",
		"info",
		"SCROLLINFO",
		"info",
		"OS",
		"OS",
		"OS",
		"OS",
		"info",
		"selection",
		"info",
		"minimum",
		"info",
		"maximum",
		"info",
		"thumb",
		"info",
		"info",
		"handle",
		"OS",
		"info",
		"style",
		"SWT",
		"bits",
		"OS",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"bits",
		"OS",
		"ScrollBarClass",
		"ScrollBarProc",
		"wParam",
		"lParam",
		"result",
		"result",
		"style",
		"SWT",
		"result",
		"style",
		"SWT",
		"wParam",
		"OS",
		"OS",
		"wParam",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"key",
		"lParam",
		"code",
		"result",
		"OS",
		"handle",
		"OS",
		"oldBits",
		"OS",
		"OS",
		"handle",
		"OS",
		"newBits",
		"wParam",
		"lParam",
		"OS",
		"handle",
		"OS",
		"oldBits",
		"OS",
		"SWT",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"OS",
		"handle",
		"OS",
		"result",
		"OS",
		"handle",
		"OS",
		"oldBits",
		"OS",
		"OS",
		"handle",
		"OS",
		"newBits",
		"wParam",
		"lParam",
		"OS",
		"handle",
		"OS",
		"oldBits",
		"OS",
		"SWT",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"OS",
		"handle",
		"OS",
		"result",
		"wParam",
		"code",
		"OS",
		"info",
		"SCROLLINFO",
		"info",
		"OS",
		"OS",
		"OS",
		"OS",
		"handle",
		"OS",
		"info",
		"info",
		"OS",
		"code",
		"OS",
		"event",
		"SWT",
		"info",
		"info",
		"OS",
		"event",
		"SWT",
		"info",
		"info",
		"OS",
		"event",
		"SWT",
		"info",
		"info",
		"OS",
		"event",
		"SWT",
		"info",
		"info",
		"OS",
		"event",
		"SWT",
		"info",
		"increment",
		"OS",
		"event",
		"SWT",
		"info",
		"Math",
		"info",
		"info",
		"increment",
		"OS",
		"event",
		"SWT",
		"info",
		"pageIncrement",
		"OS",
		"event",
		"SWT",
		"info",
		"Math",
		"info",
		"info",
		"pageIncrement",
		"OS",
		"handle",
		"OS",
		"info",
		"SWT",
		"event",
		"lpfnWndProc",
		"ERROR_NULL_ARGUMENT",
		"Selection",
		"DefaultSelection",
		"WM_LBUTTONDOWN",
		"WM_LBUTTONDBLCLK",
		"HORIZONTAL",
		"VERTICAL",
		"HORIZONTAL",
		"SM_CXHSCROLL",
		"SM_CYHSCROLL",
		"SM_CXVSCROLL",
		"SM_CYVSCROLL",
		"DEFAULT",
		"DEFAULT",
		"cbSize",
		"sizeof",
		"fMask",
		"SIF_ALL",
		"nMax",
		"nPage",
		"SB_CTL",
		"COLOR_SCROLLBAR",
		"COLOR_BTNFACE",
		"IsWinCE",
		"ESB_ENABLE_BOTH",
		"ESB_DISABLE_BOTH",
		"SB_CTL",
		"cbSize",
		"sizeof",
		"fMask",
		"SIF_RANGE",
		"SB_CTL",
		"nMax",
		"cbSize",
		"sizeof",
		"fMask",
		"SIF_RANGE",
		"SB_CTL",
		"nMin",
		"cbSize",
		"sizeof",
		"fMask",
		"SIF_POS",
		"SB_CTL",
		"nPos",
		"cbSize",
		"sizeof",
		"fMask",
		"SIF_PAGE",
		"SB_CTL",
		"nPage",
		"nPage",
		"nPage",
		"ERROR_NULL_ARGUMENT",
		"Selection",
		"DefaultSelection",
		"WM_SETFOCUS",
		"cbSize",
		"sizeof",
		"fMask",
		"SIF_RANGE",
		"SIF_DISABLENOSCROLL",
		"SB_CTL",
		"nMin",
		"nPage",
		"nMax",
		"SB_CTL",
		"cbSize",
		"sizeof",
		"fMask",
		"SIF_RANGE",
		"SIF_DISABLENOSCROLL",
		"SB_CTL",
		"nMax",
		"nPage",
		"nMin",
		"SB_CTL",
		"IsWinCE",
		"SB_CTL",
		"ESB_DISABLE_BOTH",
		"WM_SETFOCUS",
		"cbSize",
		"sizeof",
		"fMask",
		"SIF_POS",
		"nPos",
		"SB_CTL",
		"cbSize",
		"sizeof",
		"fMask",
		"SIF_PAGE",
		"SIF_RANGE",
		"SIF_DISABLENOSCROLL",
		"SB_CTL",
		"nPage",
		"nPage",
		"nPage",
		"SB_CTL",
		"increment",
		"pageIncrement",
		"cbSize",
		"sizeof",
		"fMask",
		"SIF_POS",
		"SIF_PAGE",
		"SIF_RANGE",
		"SIF_DISABLENOSCROLL",
		"nPos",
		"nMin",
		"nMax",
		"nPage",
		"nPage",
		"nPage",
		"SB_CTL",
		"BORDER",
		"WS_EX_CLIENTEDGE",
		"WS_TABSTOP",
		"BORDER",
		"WS_BORDER",
		"HORIZONTAL",
		"SBS_HORZ",
		"SBS_VERT",
		"VERTICAL",
		"MIRRORED",
		"VK_LEFT",
		"VK_RIGHT",
		"VK_LEFT",
		"VK_RIGHT",
		"VK_LEFT",
		"WM_KEYDOWN",
		"GWL_STYLE",
		"WS_TABSTOP",
		"GWL_STYLE",
		"GWL_STYLE",
		"IsWinCE",
		"MouseUp",
		"WM_LBUTTONUP",
		"GWL_STYLE",
		"WS_TABSTOP",
		"GWL_STYLE",
		"GWL_STYLE",
		"IsWinCE",
		"MouseUp",
		"WM_LBUTTONUP",
		"SB_ENDSCROLL",
		"cbSize",
		"sizeof",
		"fMask",
		"SIF_TRACKPOS",
		"SIF_POS",
		"SIF_RANGE",
		"SB_CTL",
		"fMask",
		"SIF_POS",
		"SB_THUMBPOSITION",
		"detail",
		"NONE",
		"nPos",
		"nTrackPos",
		"SB_THUMBTRACK",
		"detail",
		"DRAG",
		"nPos",
		"nTrackPos",
		"SB_TOP",
		"detail",
		"HOME",
		"nPos",
		"nMin",
		"SB_BOTTOM",
		"detail",
		"END",
		"nPos",
		"nMax",
		"SB_LINEDOWN",
		"detail",
		"ARROW_DOWN",
		"nPos",
		"SB_LINEUP",
		"detail",
		"ARROW_UP",
		"nPos",
		"nMin",
		"nPos",
		"SB_PAGEDOWN",
		"detail",
		"PAGE_DOWN",
		"nPos",
		"SB_PAGEUP",
		"detail",
		"PAGE_UP",
		"nPos",
		"nMin",
		"nPos",
		"SB_CTL",
		"Selection",
		"parent",
		"style",
		"listener",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"style",
		"wHint",
		"hHint",
		"changed",
		"enabled",
		"listener",
		"x",
		"y",
		"width",
		"height",
		"flags",
		"value",
		"value",
		"value",
		"value",
		"hwnd",
		"flags",
		"info",
		"fRedraw",
		"value",
		"value",
		"selection",
		"minimum",
		"maximum",
		"thumb",
		"increment",
		"pageIncrement",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam"
	],
	"extendORImplementFiles":[
		"Control"
	],
	"package":[
		"org.eclipse.swt.widgets"
	],
	"import":[
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt",
		"org.eclipse.swt.graphics",
		"org.eclipse.swt.events"
	],
	"methods":[
		"addSelectionListener",
		"callWindowProc",
		"checkStyle",
		"computeSize",
		"createWidget",
		"defaultBackground",
		"defaultForeground",
		"enableWidget",
		"getEnabled",
		"getIncrement",
		"getMaximum",
		"getMinimum",
		"getPageIncrement",
		"getSelection",
		"getThumb",
		"removeSelectionListener",
		"setBounds",
		"setIncrement",
		"setMaximum",
		"setMinimum",
		"setPageIncrement",
		"SetScrollInfo",
		"setSelection",
		"setThumb",
		"setValues",
		"widgetExtStyle",
		"widgetStyle",
		"windowClass",
		"windowProc",
		"WM_KEYDOWN",
		"WM_LBUTTONDBLCLK",
		"WM_LBUTTONDOWN",
		"wmScrollChild",
		"GetClassInfo",
		"checkStyle",
		"checkWidget",
		"error",
		"addListener",
		"addListener",
		"runDeferredEvents",
		"CallWindowProc",
		"checkBits",
		"checkWidget",
		"getBorderWidth",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"createWidget",
		"SetScrollInfo",
		"GetSysColor",
		"GetSysColor",
		"enableWidget",
		"EnableScrollBar",
		"checkWidget",
		"checkWidget",
		"checkWidget",
		"GetScrollInfo",
		"checkWidget",
		"GetScrollInfo",
		"checkWidget",
		"checkWidget",
		"GetScrollInfo",
		"checkWidget",
		"GetScrollInfo",
		"checkWidget",
		"error",
		"unhook",
		"unhook",
		"setBounds",
		"GetFocus",
		"PostMessage",
		"checkWidget",
		"checkWidget",
		"GetScrollInfo",
		"SetScrollInfo",
		"checkWidget",
		"GetScrollInfo",
		"SetScrollInfo",
		"checkWidget",
		"SetScrollInfo",
		"EnableWindow",
		"EnableScrollBar",
		"GetFocus",
		"PostMessage",
		"checkWidget",
		"SetScrollInfo",
		"checkWidget",
		"GetScrollInfo",
		"SetScrollInfo",
		"checkWidget",
		"SetScrollInfo",
		"widgetExtStyle",
		"widgetStyle",
		"WM_KEYDOWN",
		"callWindowProc",
		"GetWindowLong",
		"SetWindowLong",
		"WM_LBUTTONDBLCLK",
		"SetWindowLong",
		"sendMouseEvent",
		"GetCapture",
		"ReleaseCapture",
		"GetWindowLong",
		"SetWindowLong",
		"WM_LBUTTONDOWN",
		"SetWindowLong",
		"sendMouseEvent",
		"GetCapture",
		"ReleaseCapture",
		"GetScrollInfo",
		"max",
		"max",
		"SetScrollInfo",
		"sendEvent",
		"TCHAR",
		"WNDCLASS",
		"TypedListener",
		"Point",
		"SCROLLINFO",
		"SCROLLINFO",
		"SCROLLINFO",
		"SCROLLINFO",
		"SCROLLINFO",
		"SCROLLINFO",
		"SCROLLINFO",
		"SCROLLINFO",
		"SCROLLINFO",
		"SCROLLINFO",
		"LRESULT",
		"Event",
		"SCROLLINFO"
	],
	"methodsBody":{
		"void enableWidget(boolean enabled)":{
			"methodBody":"{\n    super.enableWidget(enabled);\n    if (!OS.IsWinCE) {\n        int flags = enabled ? OS.ESB_ENABLE_BOTH : OS.ESB_DISABLE_BOTH;\n        OS.EnableScrollBar(handle, OS.SB_CTL, flags);\n    }\n    if (enabled) {\n        state &= ~DISABLED;\n    } else {\n        state |= DISABLED;\n    }\n}",
			"comments":"",
			"methodName":"void enableWidget(boolean enabled)"
		},
		"public int getPageIncrement()":{
			"methodBody":"{\n    checkWidget();\n    return pageIncrement;\n}",
			"comments":"/**\n* Returns the amount that the receiver's value will be\n* modified by when the page increment/decrement areas\n* are selected.\n*\n* @return the page increment\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getPageIncrement()"
		},
		"public void setValues(int selection, int minimum, int maximum, int thumb, int increment, int pageIncrement)":{
			"methodBody":"{\n    checkWidget();\n    if (minimum < 0)\n        return;\n    if (maximum < 0)\n        return;\n    if (thumb < 1)\n        return;\n    if (increment < 1)\n        return;\n    if (pageIncrement < 1)\n        return;\n    this.increment = increment;\n    this.pageIncrement = pageIncrement;\n    SCROLLINFO info = new SCROLLINFO();\n    info.cbSize = SCROLLINFO.sizeof;\n    info.fMask = OS.SIF_POS | OS.SIF_PAGE | OS.SIF_RANGE | OS.SIF_DISABLENOSCROLL;\n    info.nPos = selection;\n    info.nMin = minimum;\n    info.nMax = maximum;\n    info.nPage = thumb;\n    if (info.nPage != 0)\n        info.nPage++;\n    SetScrollInfo(handle, OS.SB_CTL, info, true);\n}",
			"comments":"/**\n* Sets the receiver's selection, minimum value, maximum\n* value, thumb, increment and page increment all at once.\n* <p>\n* Note: This is equivalent to setting the values individually\n* using the appropriate methods, but may be implemented in a\n* more efficient fashion on some platforms.\n* </p>\n*\n* @param selection the new selection value\n* @param minimum the new minimum value\n* @param maximum the new maximum value\n* @param thumb the new thumb value\n* @param increment the new increment value\n* @param pageIncrement the new pageIncrement value\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setValues(int selection, int minimum, int maximum, int thumb, int increment, int pageIncrement)"
		},
		"public void setPageIncrement(int value)":{
			"methodBody":"{\n    checkWidget();\n    if (value < 1)\n        return;\n    pageIncrement = value;\n}",
			"comments":"/**\n* Sets the amount that the receiver's value will be\n* modified by when the page increment/decrement areas\n* are selected to the argument, which must be at least\n* one.\n*\n* @param value the page increment (must be greater than zero)\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setPageIncrement(int value)"
		},
		"int defaultForeground()":{
			"methodBody":"{\n    return OS.GetSysColor(OS.COLOR_BTNFACE);\n}",
			"comments":"",
			"methodName":"int defaultForeground()"
		},
		"LRESULT WM_LBUTTONDBLCLK(int wParam, int lParam)":{
			"methodBody":"{\n    \n    int oldBits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n    int newBits = oldBits & ~OS.WS_TABSTOP;\n    OS.SetWindowLong(handle, OS.GWL_STYLE, newBits);\n    LRESULT result = super.WM_LBUTTONDBLCLK(wParam, lParam);\n    OS.SetWindowLong(handle, OS.GWL_STYLE, oldBits);\n    \n    if (!OS.IsWinCE) {\n        sendMouseEvent(SWT.MouseUp, 1, handle, OS.WM_LBUTTONUP, wParam, lParam);\n        if (OS.GetCapture() == handle)\n            OS.ReleaseCapture();\n    }\n    return result;\n}",
			"comments":"/*\n* Feature in Windows.  Windows uses the WS_TABSTOP\n* style for the scroll bar to decide that focus\n* should be set during WM_LBUTTONDBLCLK.  This is\n* not the desired behavior.  The fix is to clear\n* and restore WS_TABSTOP so that Windows will not\n* assign focus.\n*/\n/*\n* Feature in Windows.  Windows runs a modal message loop\n* when the user drags a scroll bar that terminates when\n* it sees an WM_LBUTTONUP.  Unfortunately the WM_LBUTTONUP\n* is consumed.  The fix is to send a fake mouse up and\n* release the automatic capture.\n*/\n",
			"methodName":"LRESULT WM_LBUTTONDBLCLK(int wParam, int lParam)"
		},
		"public int getMaximum()":{
			"methodBody":"{\n    checkWidget();\n    SCROLLINFO info = new SCROLLINFO();\n    info.cbSize = SCROLLINFO.sizeof;\n    info.fMask = OS.SIF_RANGE;\n    OS.GetScrollInfo(handle, OS.SB_CTL, info);\n    return info.nMax;\n}",
			"comments":"/**\n* Returns the maximum value which the receiver will allow.\n*\n* @return the maximum\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getMaximum()"
		},
		"public int getSelection()":{
			"methodBody":"{\n    checkWidget();\n    SCROLLINFO info = new SCROLLINFO();\n    info.cbSize = SCROLLINFO.sizeof;\n    info.fMask = OS.SIF_POS;\n    OS.GetScrollInfo(handle, OS.SB_CTL, info);\n    return info.nPos;\n}",
			"comments":"/**\n* Returns the 'selection', which is the receiver's value.\n*\n* @return the selection\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getSelection()"
		},
		"public void setThumb(int value)":{
			"methodBody":"{\n    checkWidget();\n    if (value < 1)\n        return;\n    SCROLLINFO info = new SCROLLINFO();\n    info.cbSize = SCROLLINFO.sizeof;\n    info.fMask = OS.SIF_PAGE | OS.SIF_RANGE | OS.SIF_DISABLENOSCROLL;\n    OS.GetScrollInfo(handle, OS.SB_CTL, info);\n    info.nPage = value;\n    if (info.nPage != 0)\n        info.nPage++;\n    SetScrollInfo(handle, OS.SB_CTL, info, true);\n}",
			"comments":"/**\n* Sets the size of the receiver's thumb relative to the\n* difference between its maximum and minimum values.  This new\n* value will be ignored if it is less than one, and will be\n* clamped if it exceeds the receiver's current range.\n*\n* @param value the new thumb value, which must be at least one and not\n* larger than the size of the current range\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setThumb(int value)"
		},
		"static int checkStyle(int style)":{
			"methodBody":"{\n    return checkBits(style, SWT.HORIZONTAL, SWT.VERTICAL, 0, 0, 0, 0);\n}",
			"comments":"",
			"methodName":"static int checkStyle(int style)"
		},
		"public void removeSelectionListener(SelectionListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.Selection, listener);\n    eventTable.unhook(SWT.DefaultSelection, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when the receiver's value changes.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see SelectionListener\n* @see #addSelectionListener\n*/\n",
			"methodName":"public void removeSelectionListener(SelectionListener listener)"
		},
		"void createWidget()":{
			"methodBody":"{\n    super.createWidget();\n    increment = 1;\n    pageIncrement = 10;\n    \n    SCROLLINFO info = new SCROLLINFO();\n    info.cbSize = SCROLLINFO.sizeof;\n    info.fMask = OS.SIF_ALL;\n    info.nMax = 100;\n    info.nPage = 11;\n    OS.SetScrollInfo(handle, OS.SB_CTL, info, true);\n}",
			"comments":"/*\n* Set the intial values of the maximum\n* to 100 and the thumb to 10.  Note that\n* info.nPage needs to be 11 in order to\n* get a thumb that is 10.\n*/\n",
			"methodName":"void createWidget()"
		},
		"LRESULT WM_LBUTTONDOWN(int wParam, int lParam)":{
			"methodBody":"{\n    \n    int oldBits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n    int newBits = oldBits & ~OS.WS_TABSTOP;\n    OS.SetWindowLong(handle, OS.GWL_STYLE, newBits);\n    LRESULT result = super.WM_LBUTTONDOWN(wParam, lParam);\n    OS.SetWindowLong(handle, OS.GWL_STYLE, oldBits);\n    \n    if (!OS.IsWinCE) {\n        sendMouseEvent(SWT.MouseUp, 1, handle, OS.WM_LBUTTONUP, wParam, lParam);\n        if (OS.GetCapture() == handle)\n            OS.ReleaseCapture();\n    }\n    return result;\n}",
			"comments":"/*\n* Feature in Windows.  Windows uses the WS_TABSTOP\n* style for the scroll bar to decide that focus\n* should be set during WM_LBUTTONDOWN.  This is\n* not the desired behavior.  The fix is to clear\n* and restore WS_TABSTOP so that Windows will not\n* assign focus.\n*/\n/*\n* Feature in Windows.  Windows runs a modal message loop\n* when the user drags a scroll bar that terminates when\n* it sees an WM_LBUTTONUP.  Unfortunately the WM_LBUTTONUP\n* is consumed.  The fix is to send a fake mouse up and\n* release the automatic capture.\n*/\n",
			"methodName":"LRESULT WM_LBUTTONDOWN(int wParam, int lParam)"
		},
		"public boolean getEnabled()":{
			"methodBody":"{\n    checkWidget();\n    return (state & DISABLED) == 0;\n}",
			"comments":"",
			"methodName":"public boolean getEnabled()"
		},
		"public Point computeSize(int wHint, int hHint, boolean changed)":{
			"methodBody":"{\n    checkWidget();\n    int border = getBorderWidth();\n    int width = border * 2, height = border * 2;\n    if ((style & SWT.HORIZONTAL) != 0) {\n        width += OS.GetSystemMetrics(OS.SM_CXHSCROLL) * 10;\n        height += OS.GetSystemMetrics(OS.SM_CYHSCROLL);\n    } else {\n        width += OS.GetSystemMetrics(OS.SM_CXVSCROLL);\n        height += OS.GetSystemMetrics(OS.SM_CYVSCROLL) * 10;\n    }\n    if (wHint != SWT.DEFAULT)\n        width = wHint + (border * 2);\n    if (hHint != SWT.DEFAULT)\n        height = hHint + (border * 2);\n    return new Point(width, height);\n}",
			"comments":"",
			"methodName":"public Point computeSize(int wHint, int hHint, boolean changed)"
		},
		"public int getIncrement()":{
			"methodBody":"{\n    checkWidget();\n    return increment;\n}",
			"comments":"/**\n* Returns the amount that the receiver's value will be\n* modified by when the up/down (or right/left) arrows\n* are pressed.\n*\n* @return the increment\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getIncrement()"
		},
		"int defaultBackground()":{
			"methodBody":"{\n    return OS.GetSysColor(OS.COLOR_SCROLLBAR);\n}",
			"comments":"",
			"methodName":"int defaultBackground()"
		},
		"int widgetExtStyle()":{
			"methodBody":"{\n    \n    int bits = super.widgetExtStyle();\n    if ((style & SWT.BORDER) != 0)\n        bits &= ~OS.WS_EX_CLIENTEDGE;\n    return bits;\n}",
			"comments":"/*\n* Bug in Windows.  If a scroll bar control is given a border,\n* dragging the scroll bar thumb eats away parts of the border\n* while the thumb is dragged.  The fix is to clear border for\n* all scroll bars.\n*/\n",
			"methodName":"int widgetExtStyle()"
		},
		"TCHAR windowClass()":{
			"methodBody":"{\n    return ScrollBarClass;\n}",
			"comments":"",
			"methodName":"TCHAR windowClass()"
		},
		"public int getMinimum()":{
			"methodBody":"{\n    checkWidget();\n    SCROLLINFO info = new SCROLLINFO();\n    info.cbSize = SCROLLINFO.sizeof;\n    info.fMask = OS.SIF_RANGE;\n    OS.GetScrollInfo(handle, OS.SB_CTL, info);\n    return info.nMin;\n}",
			"comments":"/**\n* Returns the minimum value which the receiver will allow.\n*\n* @return the minimum\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getMinimum()"
		},
		"LRESULT wmScrollChild(int wParam, int lParam)":{
			"methodBody":"{\n    \n    int code = wParam & 0xFFFF;\n    if (code == OS.SB_ENDSCROLL)\n        return null;\n    \n    Event event = new Event();\n    SCROLLINFO info = new SCROLLINFO();\n    info.cbSize = SCROLLINFO.sizeof;\n    info.fMask = OS.SIF_TRACKPOS | OS.SIF_POS | OS.SIF_RANGE;\n    OS.GetScrollInfo(handle, OS.SB_CTL, info);\n    info.fMask = OS.SIF_POS;\n    switch(code) {\n        case OS.SB_THUMBPOSITION:\n            event.detail = SWT.NONE;\n            info.nPos = info.nTrackPos;\n            break;\n        case OS.SB_THUMBTRACK:\n            event.detail = SWT.DRAG;\n            info.nPos = info.nTrackPos;\n            break;\n        case OS.SB_TOP:\n            event.detail = SWT.HOME;\n            info.nPos = info.nMin;\n            break;\n        case OS.SB_BOTTOM:\n            event.detail = SWT.END;\n            info.nPos = info.nMax;\n            break;\n        case OS.SB_LINEDOWN:\n            event.detail = SWT.ARROW_DOWN;\n            info.nPos += increment;\n            break;\n        case OS.SB_LINEUP:\n            event.detail = SWT.ARROW_UP;\n            info.nPos = Math.max(info.nMin, info.nPos - increment);\n            break;\n        case OS.SB_PAGEDOWN:\n            event.detail = SWT.PAGE_DOWN;\n            info.nPos += pageIncrement;\n            break;\n        case OS.SB_PAGEUP:\n            event.detail = SWT.PAGE_UP;\n            info.nPos = Math.max(info.nMin, info.nPos - pageIncrement);\n            break;\n    }\n    OS.SetScrollInfo(handle, OS.SB_CTL, info, true);\n    \n    sendEvent(SWT.Selection, event);\n    \n    return null;\n}",
			"comments":"/* Do nothing when scrolling is ending */\n/* Move the thumb */\n/*\n* Feature in Windows.  Windows runs a modal message\n* loop when the user drags a scroll bar.  This means\n* that selection event must be sent because WM_HSCROLL\n* and WM_VSCROLL are sent from the modal message loop\n* so that they are delivered during inside the loop.\n*/\n// the widget could be destroyed at this point\n",
			"methodName":"LRESULT wmScrollChild(int wParam, int lParam)"
		},
		"public void setSelection(int value)":{
			"methodBody":"{\n    checkWidget();\n    SCROLLINFO info = new SCROLLINFO();\n    info.cbSize = SCROLLINFO.sizeof;\n    info.fMask = OS.SIF_POS;\n    info.nPos = value;\n    SetScrollInfo(handle, OS.SB_CTL, info, true);\n}",
			"comments":"/**\n* Sets the 'selection', which is the receiver's\n* value, to the argument which must be greater than or equal\n* to zero.\n*\n* @param value the new selection (must be zero or greater)\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setSelection(int value)"
		},
		"public void setMinimum(int value)":{
			"methodBody":"{\n    checkWidget();\n    if (value < 0)\n        return;\n    SCROLLINFO info = new SCROLLINFO();\n    info.cbSize = SCROLLINFO.sizeof;\n    info.fMask = OS.SIF_RANGE | OS.SIF_DISABLENOSCROLL;\n    OS.GetScrollInfo(handle, OS.SB_CTL, info);\n    if (info.nMax - value - info.nPage < 1)\n        return;\n    info.nMin = value;\n    SetScrollInfo(handle, OS.SB_CTL, info, true);\n}",
			"comments":"/**\n* Sets the minimum value. If this value is negative or greater\n* than or equal to the maximum, the value is ignored. If necessary,\n* first the thumb and then the selection are adjusted to fit within\n* the new range.\n*\n* @param value the new minimum\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setMinimum(int value)"
		},
		"public void setIncrement(int value)":{
			"methodBody":"{\n    checkWidget();\n    if (value < 1)\n        return;\n    increment = value;\n}",
			"comments":"/**\n* Sets the amount that the receiver's value will be\n* modified by when the up/down (or right/left) arrows\n* are pressed to the argument, which must be at least\n* one.\n*\n* @param value the new increment (must be greater than zero)\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setIncrement(int value)"
		},
		"int windowProc()":{
			"methodBody":"{\n    return ScrollBarProc;\n}",
			"comments":"",
			"methodName":"int windowProc()"
		},
		"boolean SetScrollInfo(int hwnd, int flags, SCROLLINFO info, boolean fRedraw)":{
			"methodBody":"{\n    \n    if ((state & DISABLED) != 0)\n        fRedraw = false;\n    boolean result = OS.SetScrollInfo(hwnd, flags, info, fRedraw);\n    if ((state & DISABLED) != 0) {\n        OS.EnableWindow(handle, false);\n        if (!OS.IsWinCE) {\n            OS.EnableScrollBar(handle, OS.SB_CTL, OS.ESB_DISABLE_BOTH);\n        }\n    }\n    \n    if (OS.GetFocus() == handle) {\n        OS.PostMessage(handle, OS.WM_SETFOCUS, 0, 0);\n    }\n    return result;\n}",
			"comments":"/*\n* Feature in Windows.  Using SIF_DISABLENOSCROLL,\n* SetScrollInfo () can change enabled and disabled\n* state of the scroll bar causing a scroll bar that\n* was disabled by the application to become enabled.\n* The fix is to disable the scroll bar (again) when\n* the application has disabled the scroll bar.\n*/\n/*\n* Bug in Windows.  If the thumb is resized when it has focus,\n* the flashing cursor that is used to show that the scroll bar\n* has focus is not moved.  The fix is to post a fake WM_SETFOCUS\n* to get the scroll bar to recompute the size of the flashing\n* cursor.\n*/\n",
			"methodName":"boolean SetScrollInfo(int hwnd, int flags, SCROLLINFO info, boolean fRedraw)"
		},
		"public int getThumb()":{
			"methodBody":"{\n    checkWidget();\n    SCROLLINFO info = new SCROLLINFO();\n    info.cbSize = SCROLLINFO.sizeof;\n    info.fMask = OS.SIF_PAGE;\n    OS.GetScrollInfo(handle, OS.SB_CTL, info);\n    if (info.nPage != 0)\n        --info.nPage;\n    return info.nPage;\n}",
			"comments":"/**\n* Returns the size of the receiver's thumb relative to the\n* difference between its maximum and minimum values.\n*\n* @return the thumb value\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getThumb()"
		},
		"public void setMaximum(int value)":{
			"methodBody":"{\n    checkWidget();\n    if (value < 0)\n        return;\n    SCROLLINFO info = new SCROLLINFO();\n    info.cbSize = SCROLLINFO.sizeof;\n    info.fMask = OS.SIF_RANGE | OS.SIF_DISABLENOSCROLL;\n    OS.GetScrollInfo(handle, OS.SB_CTL, info);\n    if (value - info.nMin - info.nPage < 1)\n        return;\n    info.nMax = value;\n    SetScrollInfo(handle, OS.SB_CTL, info, true);\n}",
			"comments":"/**\n* Sets the maximum. If this value is negative or less than or\n* equal to the minimum, the value is ignored. If necessary, first\n* the thumb and then the selection are adjusted to fit within the\n* new range.\n*\n* @param value the new maximum, which must be greater than the current minimum\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setMaximum(int value)"
		},
		"public void addSelectionListener(SelectionListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.Selection, typedListener);\n    addListener(SWT.DefaultSelection, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when the receiver's value changes, by sending\n* it one of the messages defined in the <code>SelectionListener</code>\n* interface.\n* <p>\n* When <code>widgetSelected</code> is called, the event object detail field contains one of the following values:\n* <code>SWT.NONE</code> - for the end of a drag.\n* <code>SWT.DRAG</code>.\n* <code>SWT.HOME</code>.\n* <code>SWT.END</code>.\n* <code>SWT.ARROW_DOWN</code>.\n* <code>SWT.ARROW_UP</code>.\n* <code>SWT.PAGE_DOWN</code>.\n* <code>SWT.PAGE_UP</code>.\n* <code>widgetDefaultSelected</code> is not called.\n* </p>\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see SelectionListener\n* @see #removeSelectionListener\n* @see SelectionEvent\n*/\n",
			"methodName":"public void addSelectionListener(SelectionListener listener)"
		},
		"int callWindowProc(int hwnd, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    if (handle == 0)\n        return 0;\n    \n    switch(msg) {\n        case OS.WM_LBUTTONDOWN:\n        case OS.WM_LBUTTONDBLCLK:\n            display.runDeferredEvents();\n    }\n    return OS.CallWindowProc(ScrollBarProc, hwnd, msg, wParam, lParam);\n}",
			"comments":"/*\n* Feature in Windows.  Windows runs a modal message\n* loop when the user drags a scroll bar.  This means\n* that mouse down events won't get delivered until\n* after the loop finishes.  The fix is to run any\n* deferred messages, including mouse down messages\n* before calling the scroll bar window proc.\n*/\n",
			"methodName":"int callWindowProc(int hwnd, int msg, int wParam, int lParam)"
		},
		"void setBounds(int x, int y, int width, int height, int flags)":{
			"methodBody":"{\n    super.setBounds(x, y, width, height, flags);\n    \n    if (OS.GetFocus() == handle) {\n        OS.PostMessage(handle, OS.WM_SETFOCUS, 0, 0);\n    }\n}",
			"comments":"/*\n* Bug in Windows.  If the scroll bar is resized when it has focus,\n* the flashing cursor that is used to show that the scroll bar has\n* focus is not moved.  The fix is to post a fake WM_SETFOCUS to\n* get the scroll bar to recompute the size of the flashing cursor.\n*/\n",
			"methodName":"void setBounds(int x, int y, int width, int height, int flags)"
		},
		"int widgetStyle()":{
			"methodBody":"{\n    int bits = super.widgetStyle() | OS.WS_TABSTOP;\n    \n    if ((style & SWT.BORDER) != 0)\n        bits &= ~OS.WS_BORDER;\n    if ((style & SWT.HORIZONTAL) != 0)\n        return bits | OS.SBS_HORZ;\n    return bits | OS.SBS_VERT;\n}",
			"comments":"/*\n* Bug in Windows.  If a scroll bar control is given a border,\n* dragging the scroll bar thumb eats away parts of the border\n* while the thumb is dragged.  The fix is to clear WS_BORDER.\n*/\n",
			"methodName":"int widgetStyle()"
		},
		"LRESULT WM_KEYDOWN(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_KEYDOWN(wParam, lParam);\n    if (result != null)\n        return result;\n    if ((style & SWT.VERTICAL) != 0)\n        return result;\n    \n    if ((style & SWT.MIRRORED) != 0) {\n        switch(wParam) {\n            case OS.VK_LEFT:\n            case OS.VK_RIGHT:\n                {\n                    int key = wParam == OS.VK_LEFT ? OS.VK_RIGHT : OS.VK_LEFT;\n                    int code = callWindowProc(handle, OS.WM_KEYDOWN, key, lParam);\n                    return new LRESULT(code);\n                }\n        }\n    }\n    return result;\n}",
			"comments":"/*\n* Bug in Windows.  When a horizontal scroll bar is mirrored,\n* the native control does not correctly swap the arrow keys.\n* The fix is to swap them before calling the scroll bar window\n* proc.\n*\n* NOTE: This fix is not ideal.  It breaks when the bug is fixed\n* in the operating system.\n*/\n",
			"methodName":"LRESULT WM_KEYDOWN(int wParam, int lParam)"
		}
	},
	"ClassORInterfaceName":[
		"Slider"
	]
}
