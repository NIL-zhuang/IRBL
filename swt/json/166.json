{
	"variables":[
		"width",
		"height",
		"depth",
		"scanlinePad",
		"bytesPerLine",
		"data",
		"palette",
		"transparentPixel",
		"maskData",
		"maskPad",
		"alphaData",
		"alpha",
		"type",
		"x",
		"y",
		"disposalMethod",
		"delayTime",
		"ANY_TO_EIGHT",
		"b",
		"data",
		"inc",
		"bit",
		"v",
		"p",
		"ONE_TO_ONE_MAPPING",
		"DITHER_MATRIX",
		"data",
		"i",
		"data",
		"i",
		"bytesPerLine",
		"mask",
		"row",
		"y",
		"i",
		"cloneData",
		"cloneMaskData",
		"cloneAlphaData",
		"endIndex",
		"i",
		"index",
		"theByte",
		"mask",
		"offset",
		"index",
		"theByte",
		"mask",
		"n",
		"i",
		"srcX",
		"srcY",
		"offset",
		"j",
		"index",
		"theByte",
		"mask",
		"n",
		"i",
		"srcX",
		"srcY",
		"offset",
		"j",
		"j",
		"j",
		"j",
		"flipX",
		"flipY",
		"dest",
		"destBpl",
		"srcBpl",
		"index",
		"theByte",
		"mask",
		"offset",
		"index",
		"theByte",
		"mask",
		"n",
		"i",
		"srcX",
		"srcY",
		"masks",
		"offset",
		"high",
		"j",
		"index",
		"theByte",
		"mask",
		"n",
		"i",
		"pixel",
		"srcX",
		"srcY",
		"masks",
		"offset",
		"high",
		"j",
		"j",
		"j",
		"j",
		"i",
		"rshift",
		"gshift",
		"bshift",
		"r",
		"g",
		"b",
		"minDistance",
		"nearestPixel",
		"n",
		"j",
		"distance",
		"palette",
		"newMask",
		"blackIndex",
		"rgbs",
		"pixels",
		"y",
		"i",
		"stride",
		"bpl",
		"newBpl",
		"newData",
		"srcIndex",
		"destIndex",
		"y",
		"BLIT_SRC",
		"BLIT_ALPHA",
		"BLIT_DITHER",
		"ALPHA_OPAQUE",
		"ALPHA_TRANSPARENT",
		"ALPHA_CHANNEL_SEPARATE",
		"ALPHA_CHANNEL_SOURCE",
		"ALPHA_MASK_UNPACKED",
		"ALPHA_MASK_PACKED",
		"ALPHA_MASK_INDEX",
		"ALPHA_MASK_RGB",
		"LSB_FIRST",
		"MSB_FIRST",
		"TYPE_GENERIC_8",
		"TYPE_GENERIC_16_MSB",
		"TYPE_GENERIC_16_LSB",
		"TYPE_GENERIC_24",
		"TYPE_GENERIC_32_MSB",
		"TYPE_GENERIC_32_LSB",
		"TYPE_INDEX_8",
		"TYPE_INDEX_4",
		"TYPE_INDEX_2",
		"TYPE_INDEX_1_MSB",
		"TYPE_INDEX_1_LSB",
		"srcAlphaMask",
		"destAlphaMask",
		"dwm1",
		"sfxi",
		"dhm1",
		"sfyi",
		"sbpp",
		"stype",
		"spr",
		"dbpp",
		"dtype",
		"dpr",
		"dprxi",
		"dpryi",
		"apr",
		"dp",
		"sp",
		"dy",
		"sfy",
		"dx",
		"sfx",
		"dy",
		"sfy",
		"dx",
		"sfx",
		"dy",
		"sfy",
		"dx",
		"sfx",
		"dy",
		"sfy",
		"dx",
		"sfx",
		"srcRedShift",
		"srcReds",
		"srcGreenShift",
		"srcGreens",
		"srcBlueShift",
		"srcBlues",
		"srcAlphaShift",
		"srcAlphas",
		"destRedShift",
		"destRedWidth",
		"destReds",
		"destRedPreShift",
		"destGreenShift",
		"destGreenWidth",
		"destGreens",
		"destGreenPreShift",
		"destBlueShift",
		"destBlueWidth",
		"destBlues",
		"destBluePreShift",
		"destAlphaShift",
		"destAlphaWidth",
		"destAlphas",
		"destAlphaPreShift",
		"ap",
		"alpha",
		"r",
		"g",
		"b",
		"a",
		"rq",
		"gq",
		"bq",
		"aq",
		"dy",
		"sfy",
		"dx",
		"sfx",
		"data",
		"data",
		"data",
		"data",
		"data",
		"data",
		"i",
		"data",
		"data",
		"data",
		"data",
		"data",
		"data",
		"data",
		"dwm1",
		"sfxi",
		"dhm1",
		"sfyi",
		"stype",
		"spr",
		"dtype",
		"dpr",
		"dprxi",
		"dpryi",
		"apr",
		"ditherEnabled",
		"dp",
		"sp",
		"ap",
		"destPaletteSize",
		"paletteMapping",
		"isExactPaletteMapping",
		"mask",
		"i",
		"srcPaletteSize",
		"i",
		"r",
		"g",
		"b",
		"index",
		"minDistance",
		"j",
		"dr",
		"dg",
		"db",
		"distance",
		"dy",
		"sfy",
		"dx",
		"sfx",
		"dy",
		"sfy",
		"dx",
		"sfx",
		"v",
		"dy",
		"sfy",
		"dx",
		"sfx",
		"index",
		"shift",
		"dy",
		"sfy",
		"dx",
		"sfx",
		"index",
		"shift",
		"dy",
		"sfy",
		"dx",
		"sfx",
		"index",
		"shift",
		"dy",
		"sfy",
		"dx",
		"sfx",
		"index",
		"mask",
		"mask",
		"i",
		"r",
		"g",
		"b",
		"i",
		"shift",
		"shift",
		"shift",
		"alpha",
		"index",
		"indexq",
		"lastindex",
		"lastr",
		"lastg",
		"lastb",
		"rerr",
		"gerr",
		"berr",
		"dy",
		"sfy",
		"lrerr",
		"lgerr",
		"lberr",
		"dx",
		"sfx",
		"r",
		"g",
		"b",
		"i",
		"i",
		"rq",
		"gq",
		"bq",
		"j",
		"dr",
		"dg",
		"db",
		"distance",
		"minDistance",
		"dxm1",
		"dxp1",
		"acc",
		"shift",
		"shift",
		"shift",
		"destAlphaMask",
		"dwm1",
		"sfxi",
		"dhm1",
		"sfyi",
		"stype",
		"spr",
		"dbpp",
		"dtype",
		"dpr",
		"dprxi",
		"dpryi",
		"apr",
		"destRedShift",
		"destRedWidth",
		"destReds",
		"destRedPreShift",
		"destGreenShift",
		"destGreenWidth",
		"destGreens",
		"destGreenPreShift",
		"destBlueShift",
		"destBlueWidth",
		"destBlues",
		"destBluePreShift",
		"destAlphaShift",
		"destAlphaWidth",
		"destAlphas",
		"destAlphaPreShift",
		"dp",
		"sp",
		"ap",
		"alpha",
		"r",
		"g",
		"b",
		"a",
		"index",
		"rq",
		"gq",
		"bq",
		"aq",
		"dy",
		"sfy",
		"dx",
		"sfx",
		"i",
		"i",
		"data",
		"data",
		"data",
		"data",
		"data",
		"data",
		"data",
		"srcAlphaMask",
		"dwm1",
		"sfxi",
		"dhm1",
		"sfyi",
		"sbpp",
		"stype",
		"spr",
		"dtype",
		"dpr",
		"dprxi",
		"dpryi",
		"apr",
		"ditherEnabled",
		"srcRedShift",
		"srcReds",
		"srcGreenShift",
		"srcGreens",
		"srcBlueShift",
		"srcBlues",
		"srcAlphaShift",
		"srcAlphas",
		"dp",
		"sp",
		"ap",
		"alpha",
		"r",
		"g",
		"b",
		"a",
		"indexq",
		"lastindex",
		"lastr",
		"lastg",
		"lastb",
		"rerr",
		"gerr",
		"berr",
		"destPaletteSize",
		"dy",
		"sfy",
		"lrerr",
		"lgerr",
		"lberr",
		"dx",
		"sfx",
		"data",
		"data",
		"data",
		"data",
		"data",
		"data",
		"i",
		"rq",
		"gq",
		"bq",
		"j",
		"dr",
		"dg",
		"db",
		"distance",
		"minDistance",
		"dxm1",
		"dxp1",
		"acc",
		"shift",
		"shift",
		"shift",
		"i",
		"i",
		"shift",
		"bandWidth",
		"bandHeight",
		"bitmapDepth",
		"bitmapData",
		"paletteData",
		"steps",
		"bytesPerLine",
		"steps",
		"bytesPerLine",
		"blendi",
		"bytesPerLine",
		"dy",
		"blend",
		"dp",
		"dx",
		"dx",
		"blend",
		"dy",
		"dptr",
		"val",
		"inc",
		"dy",
		"dx",
		"mask",
		"val",
		"inc",
		"dy",
		"dx",
		"dptr",
		"thresh",
		"temp",
		"dx",
		"dy",
		"dptr",
		"thresh",
		"temp",
		"band",
		"image",
		"dx",
		"blitWidth",
		"dy",
		"blitHeight",
		"b",
		"b",
		"ANY_TO_EIGHT",
		"b",
		"b",
		"b",
		"bit",
		"b",
		"inc",
		"bit",
		"v",
		"v",
		"inc",
		"data",
		"p",
		"v",
		"ANY_TO_EIGHT",
		"width",
		"height",
		"depth",
		"palette",
		"SWT",
		"width",
		"height",
		"depth",
		"palette",
		"scanlinePad",
		"data",
		"SWT",
		"ImageDataLoader",
		"stream",
		"data",
		"SWT",
		"SWT",
		"data",
		"i",
		"i",
		"i",
		"i",
		"i",
		"i",
		"i",
		"i",
		"i",
		"i",
		"i",
		"i",
		"i",
		"i",
		"i",
		"i",
		"i",
		"ImageDataLoader",
		"filename",
		"data",
		"SWT",
		"SWT",
		"data",
		"i",
		"i",
		"i",
		"i",
		"i",
		"i",
		"i",
		"i",
		"i",
		"i",
		"i",
		"i",
		"i",
		"i",
		"i",
		"i",
		"i",
		"palette",
		"SWT",
		"SWT",
		"depth",
		"depth",
		"depth",
		"depth",
		"depth",
		"depth",
		"depth",
		"SWT",
		"SWT",
		"width",
		"height",
		"SWT",
		"SWT",
		"scanlinePad",
		"SWT",
		"SWT",
		"width",
		"depth",
		"scanlinePad",
		"scanlinePad",
		"scanlinePad",
		"width",
		"height",
		"depth",
		"scanlinePad",
		"bytesPerLine",
		"data",
		"data",
		"bytesPerLine",
		"height",
		"palette",
		"transparentPixel",
		"maskData",
		"maskPad",
		"alphaData",
		"alpha",
		"type",
		"x",
		"y",
		"disposalMethod",
		"delayTime",
		"width",
		"height",
		"depth",
		"scanlinePad",
		"bytesPerLine",
		"data",
		"palette",
		"transparentPixel",
		"maskData",
		"maskPad",
		"alphaData",
		"alpha",
		"type",
		"x",
		"y",
		"disposalMethod",
		"delayTime",
		"width",
		"height",
		"depth",
		"palette",
		"scanlinePad",
		"data",
		"maskPad",
		"maskData",
		"alphaData",
		"alpha",
		"transparentPixel",
		"type",
		"x",
		"y",
		"disposalMethod",
		"delayTime",
		"width",
		"height",
		"SWT",
		"width",
		"y",
		"height",
		"y",
		"y",
		"width",
		"row",
		"i",
		"width",
		"i",
		"pixel",
		"row",
		"i",
		"pixel",
		"row",
		"i",
		"row",
		"i",
		"mask",
		"y",
		"width",
		"row",
		"mask",
		"data",
		"SWT",
		"SWT",
		"data",
		"data",
		"System",
		"data",
		"cloneData",
		"data",
		"maskData",
		"cloneMaskData",
		"maskData",
		"System",
		"maskData",
		"cloneMaskData",
		"maskData",
		"alphaData",
		"cloneAlphaData",
		"alphaData",
		"System",
		"alphaData",
		"cloneAlphaData",
		"alphaData",
		"width",
		"height",
		"depth",
		"palette",
		"scanlinePad",
		"cloneData",
		"maskPad",
		"cloneMaskData",
		"cloneAlphaData",
		"alpha",
		"transparentPixel",
		"type",
		"x",
		"y",
		"disposalMethod",
		"delayTime",
		"x",
		"width",
		"y",
		"height",
		"x",
		"y",
		"SWT",
		"SWT",
		"alphaData",
		"alphaData",
		"y",
		"width",
		"x",
		"alphas",
		"SWT",
		"SWT",
		"getWidth",
		"x",
		"width",
		"y",
		"height",
		"x",
		"y",
		"SWT",
		"SWT",
		"getWidth",
		"alphaData",
		"startIndex",
		"getWidth",
		"startIndex",
		"i",
		"endIndex",
		"i",
		"alphas",
		"i",
		"System",
		"alphaData",
		"y",
		"width",
		"x",
		"alphas",
		"startIndex",
		"getWidth",
		"x",
		"width",
		"y",
		"height",
		"x",
		"y",
		"SWT",
		"SWT",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"theByte",
		"data",
		"index",
		"mask",
		"x",
		"theByte",
		"mask",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"theByte",
		"data",
		"index",
		"x",
		"mask",
		"offset",
		"theByte",
		"mask",
		"offset",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"theByte",
		"data",
		"index",
		"x",
		"theByte",
		"theByte",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"data",
		"index",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"data",
		"index",
		"data",
		"index",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"data",
		"index",
		"data",
		"index",
		"data",
		"index",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"data",
		"index",
		"data",
		"index",
		"data",
		"index",
		"data",
		"index",
		"SWT",
		"SWT",
		"pixels",
		"SWT",
		"SWT",
		"getWidth",
		"x",
		"width",
		"y",
		"height",
		"x",
		"y",
		"SWT",
		"SWT",
		"getWidth",
		"getWidth",
		"startIndex",
		"x",
		"y",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"theByte",
		"data",
		"index",
		"n",
		"mask",
		"srcX",
		"theByte",
		"mask",
		"pixels",
		"i",
		"pixels",
		"i",
		"i",
		"n",
		"srcX",
		"srcX",
		"width",
		"srcY",
		"index",
		"srcY",
		"bytesPerLine",
		"n",
		"theByte",
		"data",
		"index",
		"srcX",
		"mask",
		"index",
		"n",
		"theByte",
		"data",
		"index",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"theByte",
		"data",
		"index",
		"n",
		"offset",
		"srcX",
		"mask",
		"offset",
		"pixels",
		"i",
		"theByte",
		"mask",
		"offset",
		"i",
		"n",
		"srcX",
		"srcX",
		"width",
		"srcY",
		"index",
		"srcY",
		"bytesPerLine",
		"n",
		"theByte",
		"data",
		"index",
		"srcX",
		"offset",
		"index",
		"theByte",
		"data",
		"index",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"x",
		"theByte",
		"data",
		"index",
		"pixels",
		"i",
		"theByte",
		"i",
		"n",
		"srcX",
		"srcX",
		"width",
		"srcY",
		"index",
		"srcY",
		"bytesPerLine",
		"srcX",
		"index",
		"n",
		"theByte",
		"data",
		"index",
		"pixels",
		"i",
		"theByte",
		"i",
		"n",
		"srcX",
		"srcX",
		"width",
		"srcY",
		"index",
		"srcY",
		"bytesPerLine",
		"srcX",
		"pixels",
		"i",
		"theByte",
		"i",
		"n",
		"srcX",
		"srcX",
		"width",
		"srcY",
		"index",
		"srcY",
		"bytesPerLine",
		"srcX",
		"index",
		"n",
		"theByte",
		"data",
		"index",
		"pixels",
		"i",
		"theByte",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"j",
		"getWidth",
		"j",
		"pixels",
		"i",
		"data",
		"index",
		"i",
		"srcX",
		"srcX",
		"width",
		"srcY",
		"index",
		"srcY",
		"bytesPerLine",
		"srcX",
		"index",
		"SWT",
		"SWT",
		"pixels",
		"SWT",
		"SWT",
		"getWidth",
		"x",
		"width",
		"y",
		"height",
		"x",
		"y",
		"SWT",
		"SWT",
		"getWidth",
		"getWidth",
		"startIndex",
		"x",
		"y",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"theByte",
		"data",
		"index",
		"n",
		"mask",
		"srcX",
		"theByte",
		"mask",
		"pixels",
		"i",
		"pixels",
		"i",
		"i",
		"n",
		"srcX",
		"srcX",
		"width",
		"srcY",
		"index",
		"srcY",
		"bytesPerLine",
		"n",
		"theByte",
		"data",
		"index",
		"srcX",
		"mask",
		"index",
		"n",
		"theByte",
		"data",
		"index",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"theByte",
		"data",
		"index",
		"n",
		"offset",
		"srcX",
		"mask",
		"offset",
		"pixels",
		"i",
		"theByte",
		"mask",
		"offset",
		"i",
		"n",
		"srcX",
		"srcX",
		"width",
		"srcY",
		"index",
		"srcY",
		"bytesPerLine",
		"n",
		"theByte",
		"data",
		"index",
		"srcX",
		"offset",
		"index",
		"theByte",
		"data",
		"index",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"x",
		"theByte",
		"data",
		"index",
		"pixels",
		"i",
		"theByte",
		"i",
		"n",
		"srcX",
		"srcX",
		"width",
		"srcY",
		"index",
		"srcY",
		"bytesPerLine",
		"srcX",
		"index",
		"n",
		"theByte",
		"data",
		"index",
		"pixels",
		"i",
		"theByte",
		"i",
		"n",
		"srcX",
		"srcX",
		"width",
		"srcY",
		"index",
		"srcY",
		"bytesPerLine",
		"srcX",
		"pixels",
		"i",
		"theByte",
		"i",
		"n",
		"srcX",
		"srcX",
		"width",
		"srcY",
		"index",
		"srcY",
		"bytesPerLine",
		"srcX",
		"index",
		"n",
		"theByte",
		"data",
		"index",
		"pixels",
		"i",
		"theByte",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"j",
		"getWidth",
		"j",
		"pixels",
		"i",
		"data",
		"index",
		"i",
		"srcX",
		"srcX",
		"width",
		"srcY",
		"index",
		"srcY",
		"bytesPerLine",
		"srcX",
		"index",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"j",
		"getWidth",
		"j",
		"pixels",
		"i",
		"data",
		"index",
		"data",
		"index",
		"i",
		"srcX",
		"srcX",
		"width",
		"srcY",
		"index",
		"srcY",
		"bytesPerLine",
		"srcX",
		"index",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"j",
		"getWidth",
		"j",
		"pixels",
		"i",
		"data",
		"index",
		"data",
		"index",
		"data",
		"index",
		"i",
		"srcX",
		"srcX",
		"width",
		"srcY",
		"index",
		"srcY",
		"bytesPerLine",
		"srcX",
		"index",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"i",
		"startIndex",
		"j",
		"getWidth",
		"j",
		"pixels",
		"i",
		"data",
		"index",
		"data",
		"index",
		"data",
		"index",
		"data",
		"index",
		"i",
		"srcX",
		"srcX",
		"width",
		"srcY",
		"index",
		"srcY",
		"bytesPerLine",
		"srcX",
		"index",
		"SWT",
		"SWT",
		"palette",
		"SWT",
		"width",
		"height",
		"maskPad",
		"maskData",
		"transparentPixel",
		"maskData",
		"SWT",
		"transparentPixel",
		"SWT",
		"alphaData",
		"SWT",
		"SWT",
		"depth",
		"MSB_FIRST",
		"LSB_FIRST",
		"width",
		"flipX",
		"width",
		"width",
		"height",
		"flipY",
		"height",
		"height",
		"width",
		"height",
		"depth",
		"palette",
		"scanlinePad",
		"transparentPixel",
		"type",
		"x",
		"y",
		"disposalMethod",
		"delayTime",
		"palette",
		"BLIT_SRC",
		"ALPHA_OPAQUE",
		"dest",
		"dest",
		"dest",
		"dest",
		"dest",
		"dest",
		"flipX",
		"flipY",
		"BLIT_SRC",
		"ALPHA_OPAQUE",
		"dest",
		"dest",
		"dest",
		"dest",
		"dest",
		"dest",
		"flipX",
		"flipY",
		"maskData",
		"dest",
		"dest",
		"destBpl",
		"destBpl",
		"dest",
		"dest",
		"dest",
		"dest",
		"destBpl",
		"dest",
		"srcBpl",
		"srcBpl",
		"BLIT_SRC",
		"srcBpl",
		"MSB_FIRST",
		"ALPHA_OPAQUE",
		"dest",
		"destBpl",
		"MSB_FIRST",
		"dest",
		"dest",
		"flipX",
		"flipY",
		"alpha",
		"dest",
		"alphaData",
		"dest",
		"dest",
		"dest",
		"BLIT_SRC",
		"MSB_FIRST",
		"ALPHA_OPAQUE",
		"dest",
		"dest",
		"MSB_FIRST",
		"dest",
		"dest",
		"flipX",
		"flipY",
		"dest",
		"x",
		"width",
		"y",
		"height",
		"x",
		"y",
		"alpha",
		"alpha",
		"SWT",
		"SWT",
		"alphaData",
		"alphaData",
		"width",
		"height",
		"alphaData",
		"y",
		"width",
		"x",
		"alpha",
		"alphas",
		"SWT",
		"SWT",
		"putWidth",
		"x",
		"width",
		"y",
		"height",
		"x",
		"y",
		"SWT",
		"SWT",
		"putWidth",
		"alphaData",
		"alphaData",
		"width",
		"height",
		"System",
		"alphas",
		"startIndex",
		"alphaData",
		"y",
		"width",
		"x",
		"putWidth",
		"x",
		"width",
		"y",
		"height",
		"x",
		"y",
		"SWT",
		"SWT",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"theByte",
		"data",
		"index",
		"mask",
		"x",
		"pixelValue",
		"data",
		"index",
		"theByte",
		"mask",
		"data",
		"index",
		"theByte",
		"mask",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"theByte",
		"data",
		"index",
		"x",
		"mask",
		"offset",
		"data",
		"index",
		"data",
		"index",
		"mask",
		"pixelValue",
		"offset",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"x",
		"data",
		"index",
		"data",
		"index",
		"pixelValue",
		"data",
		"index",
		"data",
		"index",
		"pixelValue",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"data",
		"index",
		"pixelValue",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"data",
		"index",
		"pixelValue",
		"data",
		"index",
		"pixelValue",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"data",
		"index",
		"pixelValue",
		"data",
		"index",
		"pixelValue",
		"data",
		"index",
		"pixelValue",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"data",
		"index",
		"pixelValue",
		"data",
		"index",
		"pixelValue",
		"data",
		"index",
		"pixelValue",
		"data",
		"index",
		"pixelValue",
		"SWT",
		"SWT",
		"pixels",
		"SWT",
		"SWT",
		"putWidth",
		"x",
		"width",
		"y",
		"height",
		"x",
		"y",
		"SWT",
		"SWT",
		"putWidth",
		"putWidth",
		"startIndex",
		"x",
		"y",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"n",
		"mask",
		"srcX",
		"pixels",
		"i",
		"data",
		"index",
		"data",
		"index",
		"mask",
		"data",
		"index",
		"data",
		"index",
		"mask",
		"i",
		"n",
		"srcX",
		"srcX",
		"width",
		"srcY",
		"index",
		"srcY",
		"bytesPerLine",
		"srcX",
		"mask",
		"index",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"x",
		"n",
		"theByte",
		"pixels",
		"i",
		"data",
		"index",
		"data",
		"index",
		"masks",
		"offset",
		"theByte",
		"offset",
		"i",
		"n",
		"srcX",
		"srcX",
		"width",
		"srcY",
		"index",
		"srcY",
		"bytesPerLine",
		"offset",
		"srcX",
		"offset",
		"index",
		"offset",
		"offset",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"x",
		"n",
		"theByte",
		"pixels",
		"i",
		"high",
		"data",
		"index",
		"data",
		"index",
		"theByte",
		"data",
		"index",
		"data",
		"index",
		"theByte",
		"i",
		"n",
		"srcX",
		"srcX",
		"width",
		"srcY",
		"index",
		"srcY",
		"bytesPerLine",
		"high",
		"srcX",
		"high",
		"index",
		"high",
		"high",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"j",
		"putWidth",
		"j",
		"data",
		"index",
		"pixels",
		"i",
		"i",
		"srcX",
		"srcX",
		"width",
		"srcY",
		"index",
		"srcY",
		"bytesPerLine",
		"srcX",
		"index",
		"SWT",
		"SWT",
		"pixels",
		"SWT",
		"SWT",
		"putWidth",
		"x",
		"width",
		"y",
		"height",
		"x",
		"y",
		"SWT",
		"SWT",
		"putWidth",
		"putWidth",
		"startIndex",
		"x",
		"y",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"n",
		"mask",
		"srcX",
		"pixels",
		"i",
		"data",
		"index",
		"data",
		"index",
		"mask",
		"data",
		"index",
		"data",
		"index",
		"mask",
		"i",
		"n",
		"srcX",
		"srcX",
		"width",
		"srcY",
		"index",
		"srcY",
		"bytesPerLine",
		"srcX",
		"mask",
		"index",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"x",
		"n",
		"theByte",
		"pixels",
		"i",
		"data",
		"index",
		"data",
		"index",
		"masks",
		"offset",
		"theByte",
		"offset",
		"i",
		"n",
		"srcX",
		"srcX",
		"width",
		"srcY",
		"index",
		"srcY",
		"bytesPerLine",
		"offset",
		"srcX",
		"offset",
		"index",
		"offset",
		"offset",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"x",
		"n",
		"theByte",
		"pixels",
		"i",
		"high",
		"data",
		"index",
		"data",
		"index",
		"theByte",
		"data",
		"index",
		"data",
		"index",
		"theByte",
		"i",
		"n",
		"srcX",
		"srcX",
		"width",
		"srcY",
		"index",
		"srcY",
		"bytesPerLine",
		"high",
		"srcX",
		"high",
		"index",
		"high",
		"high",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"j",
		"putWidth",
		"j",
		"data",
		"index",
		"pixels",
		"i",
		"i",
		"srcX",
		"srcX",
		"width",
		"srcY",
		"index",
		"srcY",
		"bytesPerLine",
		"srcX",
		"index",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"j",
		"putWidth",
		"j",
		"pixel",
		"pixels",
		"i",
		"data",
		"index",
		"pixel",
		"data",
		"index",
		"pixel",
		"i",
		"srcX",
		"srcX",
		"width",
		"srcY",
		"index",
		"srcY",
		"bytesPerLine",
		"srcX",
		"index",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"j",
		"putWidth",
		"j",
		"pixel",
		"pixels",
		"i",
		"data",
		"index",
		"pixel",
		"data",
		"index",
		"pixel",
		"data",
		"index",
		"pixel",
		"i",
		"srcX",
		"srcX",
		"width",
		"srcY",
		"index",
		"srcY",
		"bytesPerLine",
		"srcX",
		"index",
		"depth",
		"index",
		"y",
		"bytesPerLine",
		"x",
		"j",
		"putWidth",
		"j",
		"pixel",
		"pixels",
		"i",
		"data",
		"index",
		"pixel",
		"data",
		"index",
		"pixel",
		"data",
		"index",
		"pixel",
		"data",
		"index",
		"pixel",
		"i",
		"srcX",
		"srcX",
		"width",
		"srcY",
		"index",
		"srcY",
		"bytesPerLine",
		"srcX",
		"index",
		"SWT",
		"SWT",
		"i",
		"i",
		"mask",
		"i",
		"i",
		"depth",
		"redMask",
		"greenMask",
		"blueMask",
		"red",
		"rshift",
		"redMask",
		"green",
		"gshift",
		"greenMask",
		"blue",
		"bshift",
		"blueMask",
		"reds",
		"j",
		"n",
		"j",
		"r",
		"reds",
		"j",
		"red",
		"g",
		"greens",
		"j",
		"green",
		"b",
		"blues",
		"j",
		"blue",
		"r",
		"r",
		"g",
		"g",
		"b",
		"b",
		"distance",
		"minDistance",
		"nearestPixel",
		"j",
		"distance",
		"minDistance",
		"distance",
		"nearestPixel",
		"mask",
		"mask",
		"mask",
		"mask",
		"palette",
		"mask",
		"rgbs",
		"blackIndex",
		"rgbs",
		"rgbs",
		"blackIndex",
		"palette",
		"blackIndex",
		"mask",
		"y",
		"mask",
		"y",
		"mask",
		"y",
		"mask",
		"pixels",
		"i",
		"pixels",
		"i",
		"pixels",
		"i",
		"blackIndex",
		"pixels",
		"i",
		"pixels",
		"i",
		"newMask",
		"y",
		"mask",
		"pixels",
		"newMask",
		"pad",
		"newPad",
		"data",
		"width",
		"depth",
		"stride",
		"pad",
		"pad",
		"pad",
		"stride",
		"newPad",
		"newPad",
		"newPad",
		"height",
		"newBpl",
		"y",
		"height",
		"y",
		"System",
		"data",
		"srcIndex",
		"newData",
		"destIndex",
		"stride",
		"srcIndex",
		"bpl",
		"destIndex",
		"newBpl",
		"newData",
		"destWidth",
		"destHeight",
		"alphaMode",
		"ALPHA_TRANSPARENT",
		"destWidth",
		"dwm1",
		"srcWidth",
		"dwm1",
		"destHeight",
		"dhm1",
		"srcHeight",
		"dhm1",
		"srcDepth",
		"sbpp",
		"stype",
		"TYPE_GENERIC_8",
		"sbpp",
		"stype",
		"srcOrder",
		"MSB_FIRST",
		"TYPE_GENERIC_16_MSB",
		"TYPE_GENERIC_16_LSB",
		"sbpp",
		"stype",
		"TYPE_GENERIC_24",
		"sbpp",
		"stype",
		"srcOrder",
		"MSB_FIRST",
		"TYPE_GENERIC_32_MSB",
		"TYPE_GENERIC_32_LSB",
		"srcY",
		"srcStride",
		"srcX",
		"sbpp",
		"destDepth",
		"dbpp",
		"dtype",
		"TYPE_GENERIC_8",
		"dbpp",
		"dtype",
		"destOrder",
		"MSB_FIRST",
		"TYPE_GENERIC_16_MSB",
		"TYPE_GENERIC_16_LSB",
		"dbpp",
		"dtype",
		"TYPE_GENERIC_24",
		"dbpp",
		"dtype",
		"destOrder",
		"MSB_FIRST",
		"TYPE_GENERIC_32_MSB",
		"TYPE_GENERIC_32_LSB",
		"flipY",
		"destY",
		"dhm1",
		"destY",
		"destStride",
		"flipX",
		"destX",
		"dwm1",
		"destX",
		"dbpp",
		"flipX",
		"dbpp",
		"dbpp",
		"flipY",
		"destStride",
		"destStride",
		"op",
		"BLIT_ALPHA",
		"alphaMode",
		"ALPHA_MASK_UNPACKED",
		"ALPHA_CHANNEL_SEPARATE",
		"alphaData",
		"alphaMode",
		"apr",
		"alphaY",
		"alphaStride",
		"alphaX",
		"ALPHA_MASK_PACKED",
		"alphaData",
		"alphaMode",
		"alphaStride",
		"apr",
		"alphaY",
		"alphaStride",
		"alphaX",
		"ALPHA_MASK_INDEX",
		"ALPHA_MASK_RGB",
		"alphaData",
		"alphaMode",
		"apr",
		"alphaMode",
		"alphaMode",
		"ALPHA_CHANNEL_SOURCE",
		"apr",
		"alphaMode",
		"apr",
		"dpr",
		"spr",
		"alphaMode",
		"stype",
		"dtype",
		"srcRedMask",
		"destRedMask",
		"srcGreenMask",
		"destGreenMask",
		"srcBlueMask",
		"destBlueMask",
		"srcAlphaMask",
		"destAlphaMask",
		"sbpp",
		"destHeight",
		"sfyi",
		"dy",
		"dy",
		"sp",
		"spr",
		"sfy",
		"srcStride",
		"sfy",
		"sfy",
		"sfyi",
		"dp",
		"dpr",
		"dpryi",
		"destWidth",
		"sfxi",
		"dx",
		"dx",
		"dp",
		"dprxi",
		"sfx",
		"sfx",
		"sfxi",
		"destData",
		"dp",
		"srcData",
		"sp",
		"sp",
		"sfx",
		"destHeight",
		"sfyi",
		"dy",
		"dy",
		"sp",
		"spr",
		"sfy",
		"srcStride",
		"sfy",
		"sfy",
		"sfyi",
		"dp",
		"dpr",
		"dpryi",
		"destWidth",
		"sfxi",
		"dx",
		"dx",
		"dp",
		"dprxi",
		"sfx",
		"sfx",
		"sfxi",
		"destData",
		"dp",
		"srcData",
		"sp",
		"destData",
		"dp",
		"srcData",
		"sp",
		"sp",
		"sfx",
		"destHeight",
		"sfyi",
		"dy",
		"dy",
		"sp",
		"spr",
		"sfy",
		"srcStride",
		"sfy",
		"sfy",
		"sfyi",
		"dp",
		"dpr",
		"dpryi",
		"destWidth",
		"sfxi",
		"dx",
		"dx",
		"dp",
		"dprxi",
		"sfx",
		"sfx",
		"sfxi",
		"destData",
		"dp",
		"srcData",
		"sp",
		"destData",
		"dp",
		"srcData",
		"sp",
		"destData",
		"dp",
		"srcData",
		"sp",
		"sp",
		"sfx",
		"destHeight",
		"sfyi",
		"dy",
		"dy",
		"sp",
		"spr",
		"sfy",
		"srcStride",
		"sfy",
		"sfy",
		"sfyi",
		"dp",
		"dpr",
		"dpryi",
		"destWidth",
		"sfxi",
		"dx",
		"dx",
		"dp",
		"dprxi",
		"sfx",
		"sfx",
		"sfxi",
		"destData",
		"dp",
		"srcData",
		"sp",
		"destData",
		"dp",
		"srcData",
		"sp",
		"destData",
		"dp",
		"srcData",
		"sp",
		"destData",
		"dp",
		"srcData",
		"sp",
		"sp",
		"sfx",
		"srcRedMask",
		"ANY_TO_EIGHT",
		"srcRedMask",
		"srcRedShift",
		"srcGreenMask",
		"ANY_TO_EIGHT",
		"srcGreenMask",
		"srcGreenShift",
		"srcBlueMask",
		"ANY_TO_EIGHT",
		"srcBlueMask",
		"srcBlueShift",
		"srcAlphaMask",
		"ANY_TO_EIGHT",
		"srcAlphaMask",
		"srcAlphaShift",
		"destRedMask",
		"destRedMask",
		"destRedShift",
		"ANY_TO_EIGHT",
		"destRedWidth",
		"destRedWidth",
		"destGreenMask",
		"destGreenMask",
		"destGreenShift",
		"ANY_TO_EIGHT",
		"destGreenWidth",
		"destGreenWidth",
		"destBlueMask",
		"destBlueMask",
		"destBlueShift",
		"ANY_TO_EIGHT",
		"destBlueWidth",
		"destBlueWidth",
		"destAlphaMask",
		"destAlphaMask",
		"destAlphaShift",
		"ANY_TO_EIGHT",
		"destAlphaWidth",
		"destAlphaWidth",
		"apr",
		"alphaMode",
		"destHeight",
		"sfyi",
		"dy",
		"dy",
		"sp",
		"spr",
		"sfy",
		"srcStride",
		"ap",
		"apr",
		"sfy",
		"alphaStride",
		"sfy",
		"sfy",
		"sfyi",
		"dp",
		"dpr",
		"dpryi",
		"destWidth",
		"sfxi",
		"dx",
		"dx",
		"dp",
		"dprxi",
		"sfx",
		"sfx",
		"sfxi",
		"stype",
		"TYPE_GENERIC_8",
		"srcData",
		"sp",
		"sp",
		"sfx",
		"r",
		"srcReds",
		"data",
		"srcRedMask",
		"srcRedShift",
		"g",
		"srcGreens",
		"data",
		"srcGreenMask",
		"srcGreenShift",
		"b",
		"srcBlues",
		"data",
		"srcBlueMask",
		"srcBlueShift",
		"a",
		"srcAlphas",
		"data",
		"srcAlphaMask",
		"srcAlphaShift",
		"TYPE_GENERIC_16_MSB",
		"srcData",
		"sp",
		"srcData",
		"sp",
		"sp",
		"sfx",
		"r",
		"srcReds",
		"data",
		"srcRedMask",
		"srcRedShift",
		"g",
		"srcGreens",
		"data",
		"srcGreenMask",
		"srcGreenShift",
		"b",
		"srcBlues",
		"data",
		"srcBlueMask",
		"srcBlueShift",
		"a",
		"srcAlphas",
		"data",
		"srcAlphaMask",
		"srcAlphaShift",
		"TYPE_GENERIC_16_LSB",
		"srcData",
		"sp",
		"srcData",
		"sp",
		"sp",
		"sfx",
		"r",
		"srcReds",
		"data",
		"srcRedMask",
		"srcRedShift",
		"g",
		"srcGreens",
		"data",
		"srcGreenMask",
		"srcGreenShift",
		"b",
		"srcBlues",
		"data",
		"srcBlueMask",
		"srcBlueShift",
		"a",
		"srcAlphas",
		"data",
		"srcAlphaMask",
		"srcAlphaShift",
		"TYPE_GENERIC_24",
		"srcData",
		"sp",
		"srcData",
		"sp",
		"srcData",
		"sp",
		"sp",
		"sfx",
		"r",
		"srcReds",
		"data",
		"srcRedMask",
		"srcRedShift",
		"g",
		"srcGreens",
		"data",
		"srcGreenMask",
		"srcGreenShift",
		"b",
		"srcBlues",
		"data",
		"srcBlueMask",
		"srcBlueShift",
		"a",
		"srcAlphas",
		"data",
		"srcAlphaMask",
		"srcAlphaShift",
		"TYPE_GENERIC_32_MSB",
		"srcData",
		"sp",
		"srcData",
		"sp",
		"srcData",
		"sp",
		"srcData",
		"sp",
		"sp",
		"sfx",
		"r",
		"srcReds",
		"data",
		"srcRedMask",
		"srcRedShift",
		"g",
		"srcGreens",
		"data",
		"srcGreenMask",
		"srcGreenShift",
		"b",
		"srcBlues",
		"data",
		"srcBlueMask",
		"srcBlueShift",
		"a",
		"srcAlphas",
		"data",
		"srcAlphaMask",
		"srcAlphaShift",
		"TYPE_GENERIC_32_LSB",
		"srcData",
		"sp",
		"srcData",
		"sp",
		"srcData",
		"sp",
		"srcData",
		"sp",
		"sp",
		"sfx",
		"r",
		"srcReds",
		"data",
		"srcRedMask",
		"srcRedShift",
		"g",
		"srcGreens",
		"data",
		"srcGreenMask",
		"srcGreenShift",
		"b",
		"srcBlues",
		"data",
		"srcBlueMask",
		"srcBlueShift",
		"a",
		"srcAlphas",
		"data",
		"srcAlphaMask",
		"srcAlphaShift",
		"alphaMode",
		"ALPHA_CHANNEL_SEPARATE",
		"alpha",
		"alphaData",
		"ap",
		"ap",
		"sfx",
		"ALPHA_CHANNEL_SOURCE",
		"alpha",
		"a",
		"ALPHA_MASK_UNPACKED",
		"alpha",
		"alphaData",
		"ap",
		"ap",
		"sfx",
		"ALPHA_MASK_PACKED",
		"alpha",
		"alphaData",
		"ap",
		"ap",
		"ap",
		"sfx",
		"ALPHA_MASK_RGB",
		"alpha",
		"i",
		"alphaData",
		"i",
		"r",
		"alphaData",
		"i",
		"g",
		"alphaData",
		"i",
		"b",
		"alphaData",
		"i",
		"alpha",
		"alpha",
		"alpha",
		"dtype",
		"TYPE_GENERIC_8",
		"destData",
		"dp",
		"rq",
		"destReds",
		"data",
		"destRedMask",
		"destRedShift",
		"gq",
		"destGreens",
		"data",
		"destGreenMask",
		"destGreenShift",
		"bq",
		"destBlues",
		"data",
		"destBlueMask",
		"destBlueShift",
		"aq",
		"destAlphas",
		"data",
		"destAlphaMask",
		"destAlphaShift",
		"TYPE_GENERIC_16_MSB",
		"destData",
		"dp",
		"destData",
		"dp",
		"rq",
		"destReds",
		"data",
		"destRedMask",
		"destRedShift",
		"gq",
		"destGreens",
		"data",
		"destGreenMask",
		"destGreenShift",
		"bq",
		"destBlues",
		"data",
		"destBlueMask",
		"destBlueShift",
		"aq",
		"destAlphas",
		"data",
		"destAlphaMask",
		"destAlphaShift",
		"TYPE_GENERIC_16_LSB",
		"destData",
		"dp",
		"destData",
		"dp",
		"rq",
		"destReds",
		"data",
		"destRedMask",
		"destRedShift",
		"gq",
		"destGreens",
		"data",
		"destGreenMask",
		"destGreenShift",
		"bq",
		"destBlues",
		"data",
		"destBlueMask",
		"destBlueShift",
		"aq",
		"destAlphas",
		"data",
		"destAlphaMask",
		"destAlphaShift",
		"TYPE_GENERIC_24",
		"destData",
		"dp",
		"destData",
		"dp",
		"destData",
		"dp",
		"rq",
		"destReds",
		"data",
		"destRedMask",
		"destRedShift",
		"gq",
		"destGreens",
		"data",
		"destGreenMask",
		"destGreenShift",
		"bq",
		"destBlues",
		"data",
		"destBlueMask",
		"destBlueShift",
		"aq",
		"destAlphas",
		"data",
		"destAlphaMask",
		"destAlphaShift",
		"TYPE_GENERIC_32_MSB",
		"destData",
		"dp",
		"destData",
		"dp",
		"destData",
		"dp",
		"destData",
		"dp",
		"rq",
		"destReds",
		"data",
		"destRedMask",
		"destRedShift",
		"gq",
		"destGreens",
		"data",
		"destGreenMask",
		"destGreenShift",
		"bq",
		"destBlues",
		"data",
		"destBlueMask",
		"destBlueShift",
		"aq",
		"destAlphas",
		"data",
		"destAlphaMask",
		"destAlphaShift",
		"TYPE_GENERIC_32_LSB",
		"destData",
		"dp",
		"destData",
		"dp",
		"destData",
		"dp",
		"destData",
		"dp",
		"rq",
		"destReds",
		"data",
		"destRedMask",
		"destRedShift",
		"gq",
		"destGreens",
		"data",
		"destGreenMask",
		"destGreenShift",
		"bq",
		"destBlues",
		"data",
		"destBlueMask",
		"destBlueShift",
		"aq",
		"destAlphas",
		"data",
		"destAlphaMask",
		"destAlphaShift",
		"a",
		"aq",
		"a",
		"aq",
		"alpha",
		"r",
		"rq",
		"r",
		"rq",
		"alpha",
		"g",
		"gq",
		"g",
		"gq",
		"alpha",
		"b",
		"bq",
		"b",
		"bq",
		"alpha",
		"r",
		"destRedPreShift",
		"destRedShift",
		"g",
		"destGreenPreShift",
		"destGreenShift",
		"b",
		"destBluePreShift",
		"destBlueShift",
		"a",
		"destAlphaPreShift",
		"destAlphaShift",
		"dtype",
		"TYPE_GENERIC_8",
		"destData",
		"dp",
		"data",
		"TYPE_GENERIC_16_MSB",
		"destData",
		"dp",
		"data",
		"destData",
		"dp",
		"data",
		"TYPE_GENERIC_16_LSB",
		"destData",
		"dp",
		"data",
		"destData",
		"dp",
		"data",
		"TYPE_GENERIC_24",
		"destData",
		"dp",
		"data",
		"destData",
		"dp",
		"data",
		"destData",
		"dp",
		"data",
		"TYPE_GENERIC_32_MSB",
		"destData",
		"dp",
		"data",
		"destData",
		"dp",
		"data",
		"destData",
		"dp",
		"data",
		"destData",
		"dp",
		"data",
		"TYPE_GENERIC_32_LSB",
		"destData",
		"dp",
		"data",
		"destData",
		"dp",
		"data",
		"destData",
		"dp",
		"data",
		"destData",
		"dp",
		"data",
		"destWidth",
		"destHeight",
		"alphaMode",
		"ALPHA_TRANSPARENT",
		"destWidth",
		"dwm1",
		"srcWidth",
		"dwm1",
		"destHeight",
		"dhm1",
		"srcHeight",
		"dhm1",
		"srcDepth",
		"stype",
		"TYPE_INDEX_8",
		"srcStride",
		"stype",
		"TYPE_INDEX_4",
		"srcStride",
		"stype",
		"TYPE_INDEX_2",
		"srcStride",
		"stype",
		"srcOrder",
		"MSB_FIRST",
		"TYPE_INDEX_1_MSB",
		"TYPE_INDEX_1_LSB",
		"srcY",
		"srcStride",
		"srcX",
		"destDepth",
		"dtype",
		"TYPE_INDEX_8",
		"destStride",
		"dtype",
		"TYPE_INDEX_4",
		"destStride",
		"dtype",
		"TYPE_INDEX_2",
		"destStride",
		"dtype",
		"destOrder",
		"MSB_FIRST",
		"TYPE_INDEX_1_MSB",
		"TYPE_INDEX_1_LSB",
		"flipY",
		"destY",
		"dhm1",
		"destY",
		"destStride",
		"flipX",
		"destX",
		"dwm1",
		"destX",
		"flipX",
		"flipY",
		"destStride",
		"destStride",
		"op",
		"BLIT_ALPHA",
		"alphaMode",
		"ALPHA_MASK_UNPACKED",
		"ALPHA_CHANNEL_SEPARATE",
		"alphaData",
		"alphaMode",
		"apr",
		"alphaY",
		"alphaStride",
		"alphaX",
		"ALPHA_MASK_PACKED",
		"alphaData",
		"alphaMode",
		"alphaStride",
		"apr",
		"alphaY",
		"alphaStride",
		"alphaX",
		"ALPHA_MASK_INDEX",
		"ALPHA_MASK_RGB",
		"alphaData",
		"alphaMode",
		"apr",
		"alphaMode",
		"alphaMode",
		"ALPHA_CHANNEL_SOURCE",
		"apr",
		"alphaMode",
		"apr",
		"op",
		"BLIT_DITHER",
		"dpr",
		"spr",
		"apr",
		"destDepth",
		"destReds",
		"destReds",
		"destPaletteSize",
		"destPaletteSize",
		"destReds",
		"alphaMode",
		"stype",
		"dtype",
		"srcReds",
		"destReds",
		"srcGreens",
		"destGreens",
		"srcBlues",
		"destBlues",
		"paletteMapping",
		"ONE_TO_ONE_MAPPING",
		"srcReds",
		"destReds",
		"srcDepth",
		"destDepth",
		"paletteMapping",
		"ONE_TO_ONE_MAPPING",
		"paletteMapping",
		"srcDepth",
		"destDepth",
		"i",
		"paletteMapping",
		"i",
		"paletteMapping",
		"i",
		"i",
		"mask",
		"ALPHA_MASK_UNPACKED",
		"ALPHA_MASK_PACKED",
		"ALPHA_MASK_INDEX",
		"ALPHA_MASK_RGB",
		"srcDepth",
		"paletteMapping",
		"srcPaletteSize",
		"srcReds",
		"srcReds",
		"srcPaletteSize",
		"srcPaletteSize",
		"srcReds",
		"i",
		"srcPaletteSize",
		"i",
		"r",
		"srcReds",
		"i",
		"g",
		"srcGreens",
		"i",
		"b",
		"srcBlues",
		"i",
		"index",
		"j",
		"destPaletteSize",
		"j",
		"dr",
		"destReds",
		"j",
		"r",
		"dg",
		"destGreens",
		"j",
		"g",
		"db",
		"destBlues",
		"j",
		"b",
		"distance",
		"dr",
		"dr",
		"dg",
		"dg",
		"db",
		"db",
		"distance",
		"minDistance",
		"index",
		"j",
		"distance",
		"minDistance",
		"distance",
		"paletteMapping",
		"i",
		"index",
		"minDistance",
		"isExactPaletteMapping",
		"paletteMapping",
		"isExactPaletteMapping",
		"ditherEnabled",
		"stype",
		"dtype",
		"alphaMode",
		"stype",
		"TYPE_INDEX_8",
		"destHeight",
		"sfyi",
		"dy",
		"dy",
		"sp",
		"spr",
		"sfy",
		"srcStride",
		"sfy",
		"sfy",
		"sfyi",
		"dp",
		"dpr",
		"dpryi",
		"destWidth",
		"sfxi",
		"dx",
		"dx",
		"dp",
		"dprxi",
		"sfx",
		"sfx",
		"sfxi",
		"destData",
		"dp",
		"paletteMapping",
		"srcData",
		"sp",
		"sp",
		"sfx",
		"TYPE_INDEX_4",
		"destHeight",
		"sfyi",
		"dy",
		"dy",
		"sp",
		"spr",
		"sfy",
		"srcStride",
		"sfy",
		"sfy",
		"sfyi",
		"dp",
		"dpr",
		"dpryi",
		"destWidth",
		"sfxi",
		"dx",
		"dx",
		"dp",
		"dprxi",
		"sfx",
		"sfx",
		"sfxi",
		"sp",
		"v",
		"paletteMapping",
		"srcData",
		"sp",
		"v",
		"srcData",
		"sp",
		"sp",
		"sfx",
		"dp",
		"destData",
		"dp",
		"destData",
		"dp",
		"v",
		"destData",
		"dp",
		"destData",
		"dp",
		"v",
		"TYPE_INDEX_2",
		"destHeight",
		"sfyi",
		"dy",
		"dy",
		"sp",
		"spr",
		"sfy",
		"srcStride",
		"sfy",
		"sfy",
		"sfyi",
		"dp",
		"dpr",
		"dpryi",
		"destWidth",
		"sfxi",
		"dx",
		"dx",
		"dp",
		"dprxi",
		"sfx",
		"sfx",
		"sfxi",
		"paletteMapping",
		"srcData",
		"sp",
		"sp",
		"sp",
		"sfx",
		"dp",
		"destData",
		"dp",
		"destData",
		"dp",
		"shift",
		"index",
		"shift",
		"TYPE_INDEX_1_MSB",
		"destHeight",
		"sfyi",
		"dy",
		"dy",
		"sp",
		"spr",
		"sfy",
		"srcStride",
		"sfy",
		"sfy",
		"sfyi",
		"dp",
		"dpr",
		"dpryi",
		"destWidth",
		"sfxi",
		"dx",
		"dx",
		"dp",
		"dprxi",
		"sfx",
		"sfx",
		"sfxi",
		"paletteMapping",
		"srcData",
		"sp",
		"sp",
		"sp",
		"sfx",
		"dp",
		"destData",
		"dp",
		"destData",
		"dp",
		"shift",
		"index",
		"shift",
		"TYPE_INDEX_1_LSB",
		"destHeight",
		"sfyi",
		"dy",
		"dy",
		"sp",
		"spr",
		"sfy",
		"srcStride",
		"sfy",
		"sfy",
		"sfyi",
		"dp",
		"dpr",
		"dpryi",
		"destWidth",
		"sfxi",
		"dx",
		"dx",
		"dp",
		"dprxi",
		"sfx",
		"sfx",
		"sfxi",
		"paletteMapping",
		"srcData",
		"sp",
		"sp",
		"sp",
		"sfx",
		"dp",
		"destData",
		"dp",
		"destData",
		"dp",
		"shift",
		"index",
		"shift",
		"destHeight",
		"sfyi",
		"dy",
		"dy",
		"sp",
		"spr",
		"sfy",
		"srcStride",
		"sfy",
		"sfy",
		"sfyi",
		"dp",
		"dpr",
		"dpryi",
		"destWidth",
		"sfxi",
		"dx",
		"dx",
		"dp",
		"dprxi",
		"sfx",
		"sfx",
		"sfxi",
		"stype",
		"TYPE_INDEX_8",
		"index",
		"srcData",
		"sp",
		"sp",
		"sfx",
		"TYPE_INDEX_4",
		"sp",
		"index",
		"srcData",
		"sp",
		"index",
		"srcData",
		"sp",
		"sp",
		"sfx",
		"TYPE_INDEX_2",
		"index",
		"srcData",
		"sp",
		"sp",
		"sp",
		"sfx",
		"TYPE_INDEX_1_MSB",
		"index",
		"srcData",
		"sp",
		"sp",
		"sp",
		"sfx",
		"TYPE_INDEX_1_LSB",
		"index",
		"srcData",
		"sp",
		"sp",
		"sp",
		"sfx",
		"alphaMode",
		"ALPHA_MASK_UNPACKED",
		"alphaData",
		"ap",
		"ap",
		"sfx",
		"mask",
		"ALPHA_MASK_PACKED",
		"alphaData",
		"ap",
		"ap",
		"ap",
		"sfx",
		"mask",
		"ALPHA_MASK_INDEX",
		"i",
		"alphaData",
		"index",
		"alphaData",
		"i",
		"i",
		"alphaData",
		"ALPHA_MASK_RGB",
		"srcReds",
		"index",
		"srcGreens",
		"index",
		"srcBlues",
		"index",
		"i",
		"alphaData",
		"r",
		"alphaData",
		"i",
		"g",
		"alphaData",
		"i",
		"b",
		"alphaData",
		"i",
		"i",
		"i",
		"alphaData",
		"index",
		"paletteMapping",
		"index",
		"dtype",
		"TYPE_INDEX_8",
		"destData",
		"dp",
		"index",
		"TYPE_INDEX_4",
		"dp",
		"destData",
		"dp",
		"destData",
		"dp",
		"index",
		"destData",
		"dp",
		"destData",
		"dp",
		"index",
		"TYPE_INDEX_2",
		"dp",
		"destData",
		"dp",
		"destData",
		"dp",
		"shift",
		"index",
		"shift",
		"TYPE_INDEX_1_MSB",
		"dp",
		"destData",
		"dp",
		"destData",
		"dp",
		"shift",
		"index",
		"shift",
		"TYPE_INDEX_1_LSB",
		"dp",
		"destData",
		"dp",
		"destData",
		"dp",
		"shift",
		"index",
		"shift",
		"alphaMode",
		"ditherEnabled",
		"rerr",
		"destWidth",
		"gerr",
		"destWidth",
		"berr",
		"destWidth",
		"rerr",
		"gerr",
		"berr",
		"destHeight",
		"sfyi",
		"dy",
		"dy",
		"sp",
		"spr",
		"sfy",
		"srcStride",
		"ap",
		"apr",
		"sfy",
		"alphaStride",
		"sfy",
		"sfy",
		"sfyi",
		"dp",
		"dpr",
		"dpryi",
		"destWidth",
		"sfxi",
		"dx",
		"dx",
		"dp",
		"dprxi",
		"sfx",
		"sfx",
		"sfxi",
		"stype",
		"TYPE_INDEX_8",
		"index",
		"srcData",
		"sp",
		"sp",
		"sfx",
		"TYPE_INDEX_4",
		"sp",
		"index",
		"srcData",
		"sp",
		"index",
		"srcData",
		"sp",
		"sp",
		"sfx",
		"TYPE_INDEX_2",
		"index",
		"srcData",
		"sp",
		"sp",
		"sp",
		"sfx",
		"TYPE_INDEX_1_MSB",
		"index",
		"srcData",
		"sp",
		"sp",
		"sp",
		"sfx",
		"TYPE_INDEX_1_LSB",
		"index",
		"srcData",
		"sp",
		"sp",
		"sp",
		"sfx",
		"srcReds",
		"index",
		"srcGreens",
		"index",
		"srcBlues",
		"index",
		"alphaMode",
		"ALPHA_CHANNEL_SEPARATE",
		"alpha",
		"alphaData",
		"ap",
		"ap",
		"sfx",
		"ALPHA_MASK_UNPACKED",
		"alpha",
		"alphaData",
		"ap",
		"ap",
		"sfx",
		"ALPHA_MASK_PACKED",
		"alpha",
		"alphaData",
		"ap",
		"ap",
		"ap",
		"sfx",
		"ALPHA_MASK_INDEX",
		"i",
		"alphaData",
		"index",
		"alphaData",
		"i",
		"i",
		"alphaData",
		"ALPHA_MASK_RGB",
		"i",
		"alphaData",
		"r",
		"alphaData",
		"i",
		"g",
		"alphaData",
		"i",
		"b",
		"alphaData",
		"i",
		"i",
		"i",
		"alphaData",
		"alpha",
		"alpha",
		"dtype",
		"TYPE_INDEX_8",
		"indexq",
		"destData",
		"dp",
		"TYPE_INDEX_4",
		"dp",
		"indexq",
		"destData",
		"dp",
		"indexq",
		"destData",
		"dp",
		"TYPE_INDEX_2",
		"indexq",
		"destData",
		"dp",
		"dp",
		"TYPE_INDEX_1_MSB",
		"indexq",
		"destData",
		"dp",
		"dp",
		"TYPE_INDEX_1_LSB",
		"indexq",
		"destData",
		"dp",
		"dp",
		"destReds",
		"indexq",
		"destGreens",
		"indexq",
		"destBlues",
		"indexq",
		"r",
		"rq",
		"r",
		"rq",
		"alpha",
		"g",
		"gq",
		"g",
		"gq",
		"alpha",
		"b",
		"bq",
		"b",
		"bq",
		"alpha",
		"ditherEnabled",
		"r",
		"rerr",
		"dx",
		"r",
		"r",
		"r",
		"r",
		"g",
		"gerr",
		"dx",
		"g",
		"g",
		"g",
		"g",
		"b",
		"berr",
		"dx",
		"b",
		"b",
		"b",
		"b",
		"rerr",
		"dx",
		"lrerr",
		"gerr",
		"dx",
		"lgerr",
		"berr",
		"dx",
		"lberr",
		"r",
		"lastr",
		"g",
		"lastg",
		"b",
		"lastb",
		"j",
		"destPaletteSize",
		"j",
		"dr",
		"destReds",
		"j",
		"r",
		"dg",
		"destGreens",
		"j",
		"g",
		"db",
		"destBlues",
		"j",
		"b",
		"distance",
		"dr",
		"dr",
		"dg",
		"dg",
		"db",
		"db",
		"distance",
		"minDistance",
		"lastindex",
		"j",
		"distance",
		"minDistance",
		"distance",
		"lastr",
		"r",
		"lastg",
		"g",
		"lastb",
		"b",
		"ditherEnabled",
		"dx",
		"dx",
		"rerr",
		"dxp1",
		"acc",
		"lrerr",
		"r",
		"destReds",
		"lastindex",
		"lrerr",
		"lrerr",
		"rerr",
		"dx",
		"acc",
		"lrerr",
		"lrerr",
		"rerr",
		"dxm1",
		"acc",
		"lrerr",
		"lrerr",
		"gerr",
		"dxp1",
		"acc",
		"lgerr",
		"g",
		"destGreens",
		"lastindex",
		"lgerr",
		"lgerr",
		"gerr",
		"dx",
		"acc",
		"lgerr",
		"lgerr",
		"gerr",
		"dxm1",
		"acc",
		"lgerr",
		"lgerr",
		"berr",
		"dxp1",
		"acc",
		"lberr",
		"b",
		"destBlues",
		"lastindex",
		"lberr",
		"lberr",
		"berr",
		"dx",
		"acc",
		"lberr",
		"lberr",
		"berr",
		"dxm1",
		"acc",
		"lberr",
		"lberr",
		"dtype",
		"TYPE_INDEX_8",
		"destData",
		"dp",
		"lastindex",
		"TYPE_INDEX_4",
		"dp",
		"destData",
		"dp",
		"destData",
		"dp",
		"lastindex",
		"destData",
		"dp",
		"destData",
		"dp",
		"lastindex",
		"TYPE_INDEX_2",
		"dp",
		"destData",
		"dp",
		"destData",
		"dp",
		"shift",
		"lastindex",
		"shift",
		"TYPE_INDEX_1_MSB",
		"dp",
		"destData",
		"dp",
		"destData",
		"dp",
		"shift",
		"lastindex",
		"shift",
		"TYPE_INDEX_1_LSB",
		"dp",
		"destData",
		"dp",
		"destData",
		"dp",
		"shift",
		"lastindex",
		"shift",
		"destWidth",
		"destHeight",
		"alphaMode",
		"ALPHA_TRANSPARENT",
		"destWidth",
		"dwm1",
		"srcWidth",
		"dwm1",
		"destHeight",
		"dhm1",
		"srcHeight",
		"dhm1",
		"srcDepth",
		"stype",
		"TYPE_INDEX_8",
		"srcStride",
		"stype",
		"TYPE_INDEX_4",
		"srcStride",
		"stype",
		"TYPE_INDEX_2",
		"srcStride",
		"stype",
		"srcOrder",
		"MSB_FIRST",
		"TYPE_INDEX_1_MSB",
		"TYPE_INDEX_1_LSB",
		"srcY",
		"srcStride",
		"srcX",
		"destDepth",
		"dbpp",
		"dtype",
		"TYPE_GENERIC_8",
		"dbpp",
		"dtype",
		"destOrder",
		"MSB_FIRST",
		"TYPE_GENERIC_16_MSB",
		"TYPE_GENERIC_16_LSB",
		"dbpp",
		"dtype",
		"TYPE_GENERIC_24",
		"dbpp",
		"dtype",
		"destOrder",
		"MSB_FIRST",
		"TYPE_GENERIC_32_MSB",
		"TYPE_GENERIC_32_LSB",
		"flipY",
		"destY",
		"dhm1",
		"destY",
		"destStride",
		"flipX",
		"destX",
		"dwm1",
		"destX",
		"dbpp",
		"flipX",
		"dbpp",
		"dbpp",
		"flipY",
		"destStride",
		"destStride",
		"op",
		"BLIT_ALPHA",
		"alphaMode",
		"ALPHA_MASK_UNPACKED",
		"ALPHA_CHANNEL_SEPARATE",
		"alphaData",
		"alphaMode",
		"apr",
		"alphaY",
		"alphaStride",
		"alphaX",
		"ALPHA_MASK_PACKED",
		"alphaData",
		"alphaMode",
		"alphaStride",
		"apr",
		"alphaY",
		"alphaStride",
		"alphaX",
		"ALPHA_MASK_INDEX",
		"ALPHA_MASK_RGB",
		"alphaData",
		"alphaMode",
		"apr",
		"alphaMode",
		"alphaMode",
		"ALPHA_CHANNEL_SOURCE",
		"apr",
		"alphaMode",
		"apr",
		"destRedMask",
		"destRedMask",
		"destRedShift",
		"ANY_TO_EIGHT",
		"destRedWidth",
		"destRedWidth",
		"destGreenMask",
		"destGreenMask",
		"destGreenShift",
		"ANY_TO_EIGHT",
		"destGreenWidth",
		"destGreenWidth",
		"destBlueMask",
		"destBlueMask",
		"destBlueShift",
		"ANY_TO_EIGHT",
		"destBlueWidth",
		"destBlueWidth",
		"destAlphaMask",
		"destAlphaMask",
		"destAlphaShift",
		"ANY_TO_EIGHT",
		"destAlphaWidth",
		"destAlphaWidth",
		"dpr",
		"spr",
		"apr",
		"alphaMode",
		"destHeight",
		"sfyi",
		"dy",
		"dy",
		"sp",
		"spr",
		"sfy",
		"srcStride",
		"ap",
		"apr",
		"sfy",
		"alphaStride",
		"sfy",
		"sfy",
		"sfyi",
		"dp",
		"dpr",
		"dpryi",
		"destWidth",
		"sfxi",
		"dx",
		"dx",
		"dp",
		"dprxi",
		"sfx",
		"sfx",
		"sfxi",
		"stype",
		"TYPE_INDEX_8",
		"index",
		"srcData",
		"sp",
		"sp",
		"sfx",
		"TYPE_INDEX_4",
		"sp",
		"index",
		"srcData",
		"sp",
		"index",
		"srcData",
		"sp",
		"sp",
		"sfx",
		"TYPE_INDEX_2",
		"index",
		"srcData",
		"sp",
		"sp",
		"sp",
		"sfx",
		"TYPE_INDEX_1_MSB",
		"index",
		"srcData",
		"sp",
		"sp",
		"sp",
		"sfx",
		"TYPE_INDEX_1_LSB",
		"index",
		"srcData",
		"sp",
		"sp",
		"sp",
		"sfx",
		"r",
		"srcReds",
		"index",
		"g",
		"srcGreens",
		"index",
		"b",
		"srcBlues",
		"index",
		"alphaMode",
		"ALPHA_CHANNEL_SEPARATE",
		"alpha",
		"alphaData",
		"ap",
		"ap",
		"sfx",
		"ALPHA_MASK_UNPACKED",
		"alpha",
		"alphaData",
		"ap",
		"ap",
		"sfx",
		"ALPHA_MASK_PACKED",
		"alpha",
		"alphaData",
		"ap",
		"ap",
		"ap",
		"sfx",
		"ALPHA_MASK_INDEX",
		"i",
		"alphaData",
		"index",
		"alphaData",
		"i",
		"i",
		"alphaData",
		"ALPHA_MASK_RGB",
		"i",
		"alphaData",
		"r",
		"alphaData",
		"i",
		"g",
		"alphaData",
		"i",
		"b",
		"alphaData",
		"i",
		"i",
		"i",
		"alphaData",
		"alpha",
		"alpha",
		"dtype",
		"TYPE_GENERIC_8",
		"destData",
		"dp",
		"rq",
		"destReds",
		"data",
		"destRedMask",
		"destRedShift",
		"gq",
		"destGreens",
		"data",
		"destGreenMask",
		"destGreenShift",
		"bq",
		"destBlues",
		"data",
		"destBlueMask",
		"destBlueShift",
		"aq",
		"destAlphas",
		"data",
		"destAlphaMask",
		"destAlphaShift",
		"TYPE_GENERIC_16_MSB",
		"destData",
		"dp",
		"destData",
		"dp",
		"rq",
		"destReds",
		"data",
		"destRedMask",
		"destRedShift",
		"gq",
		"destGreens",
		"data",
		"destGreenMask",
		"destGreenShift",
		"bq",
		"destBlues",
		"data",
		"destBlueMask",
		"destBlueShift",
		"aq",
		"destAlphas",
		"data",
		"destAlphaMask",
		"destAlphaShift",
		"TYPE_GENERIC_16_LSB",
		"destData",
		"dp",
		"destData",
		"dp",
		"rq",
		"destReds",
		"data",
		"destRedMask",
		"destRedShift",
		"gq",
		"destGreens",
		"data",
		"destGreenMask",
		"destGreenShift",
		"bq",
		"destBlues",
		"data",
		"destBlueMask",
		"destBlueShift",
		"aq",
		"destAlphas",
		"data",
		"destAlphaMask",
		"destAlphaShift",
		"TYPE_GENERIC_24",
		"destData",
		"dp",
		"destData",
		"dp",
		"destData",
		"dp",
		"rq",
		"destReds",
		"data",
		"destRedMask",
		"destRedShift",
		"gq",
		"destGreens",
		"data",
		"destGreenMask",
		"destGreenShift",
		"bq",
		"destBlues",
		"data",
		"destBlueMask",
		"destBlueShift",
		"aq",
		"destAlphas",
		"data",
		"destAlphaMask",
		"destAlphaShift",
		"TYPE_GENERIC_32_MSB",
		"destData",
		"dp",
		"destData",
		"dp",
		"destData",
		"dp",
		"destData",
		"dp",
		"rq",
		"destReds",
		"data",
		"destRedMask",
		"destRedShift",
		"gq",
		"destGreens",
		"data",
		"destGreenMask",
		"destGreenShift",
		"bq",
		"destBlues",
		"data",
		"destBlueMask",
		"destBlueShift",
		"aq",
		"destAlphas",
		"data",
		"destAlphaMask",
		"destAlphaShift",
		"TYPE_GENERIC_32_LSB",
		"destData",
		"dp",
		"destData",
		"dp",
		"destData",
		"dp",
		"destData",
		"dp",
		"rq",
		"destReds",
		"data",
		"destRedMask",
		"destRedShift",
		"gq",
		"destGreens",
		"data",
		"destGreenMask",
		"destGreenShift",
		"bq",
		"destBlues",
		"data",
		"destBlueMask",
		"destBlueShift",
		"aq",
		"destAlphas",
		"data",
		"destAlphaMask",
		"destAlphaShift",
		"a",
		"aq",
		"a",
		"aq",
		"alpha",
		"r",
		"rq",
		"r",
		"rq",
		"alpha",
		"g",
		"gq",
		"g",
		"gq",
		"alpha",
		"b",
		"bq",
		"b",
		"bq",
		"alpha",
		"r",
		"destRedPreShift",
		"destRedShift",
		"g",
		"destGreenPreShift",
		"destGreenShift",
		"b",
		"destBluePreShift",
		"destBlueShift",
		"a",
		"destAlphaPreShift",
		"destAlphaShift",
		"dtype",
		"TYPE_GENERIC_8",
		"destData",
		"dp",
		"data",
		"TYPE_GENERIC_16_MSB",
		"destData",
		"dp",
		"data",
		"destData",
		"dp",
		"data",
		"TYPE_GENERIC_16_LSB",
		"destData",
		"dp",
		"data",
		"destData",
		"dp",
		"data",
		"TYPE_GENERIC_24",
		"destData",
		"dp",
		"data",
		"destData",
		"dp",
		"data",
		"destData",
		"dp",
		"data",
		"TYPE_GENERIC_32_MSB",
		"destData",
		"dp",
		"data",
		"destData",
		"dp",
		"data",
		"destData",
		"dp",
		"data",
		"destData",
		"dp",
		"data",
		"TYPE_GENERIC_32_LSB",
		"destData",
		"dp",
		"data",
		"destData",
		"dp",
		"data",
		"destData",
		"dp",
		"data",
		"destData",
		"dp",
		"data",
		"destWidth",
		"destHeight",
		"alphaMode",
		"ALPHA_TRANSPARENT",
		"destWidth",
		"dwm1",
		"srcWidth",
		"dwm1",
		"destHeight",
		"dhm1",
		"srcHeight",
		"dhm1",
		"srcDepth",
		"sbpp",
		"stype",
		"TYPE_GENERIC_8",
		"sbpp",
		"stype",
		"srcOrder",
		"MSB_FIRST",
		"TYPE_GENERIC_16_MSB",
		"TYPE_GENERIC_16_LSB",
		"sbpp",
		"stype",
		"TYPE_GENERIC_24",
		"sbpp",
		"stype",
		"srcOrder",
		"MSB_FIRST",
		"TYPE_GENERIC_32_MSB",
		"TYPE_GENERIC_32_LSB",
		"srcY",
		"srcStride",
		"srcX",
		"sbpp",
		"destDepth",
		"dtype",
		"TYPE_INDEX_8",
		"destStride",
		"dtype",
		"TYPE_INDEX_4",
		"destStride",
		"dtype",
		"TYPE_INDEX_2",
		"destStride",
		"dtype",
		"destOrder",
		"MSB_FIRST",
		"TYPE_INDEX_1_MSB",
		"TYPE_INDEX_1_LSB",
		"flipY",
		"destY",
		"dhm1",
		"destY",
		"destStride",
		"flipX",
		"destX",
		"dwm1",
		"destX",
		"flipX",
		"flipY",
		"destStride",
		"destStride",
		"op",
		"BLIT_ALPHA",
		"alphaMode",
		"ALPHA_MASK_UNPACKED",
		"ALPHA_CHANNEL_SEPARATE",
		"alphaData",
		"alphaMode",
		"apr",
		"alphaY",
		"alphaStride",
		"alphaX",
		"ALPHA_MASK_PACKED",
		"alphaData",
		"alphaMode",
		"alphaStride",
		"apr",
		"alphaY",
		"alphaStride",
		"alphaX",
		"ALPHA_MASK_INDEX",
		"ALPHA_MASK_RGB",
		"alphaData",
		"alphaMode",
		"apr",
		"alphaMode",
		"alphaMode",
		"ALPHA_CHANNEL_SOURCE",
		"apr",
		"alphaMode",
		"apr",
		"op",
		"BLIT_DITHER",
		"srcRedMask",
		"ANY_TO_EIGHT",
		"srcRedMask",
		"srcRedShift",
		"srcGreenMask",
		"ANY_TO_EIGHT",
		"srcGreenMask",
		"srcGreenShift",
		"srcBlueMask",
		"ANY_TO_EIGHT",
		"srcBlueMask",
		"srcBlueShift",
		"srcAlphaMask",
		"ANY_TO_EIGHT",
		"srcAlphaMask",
		"srcAlphaShift",
		"dpr",
		"spr",
		"apr",
		"alphaMode",
		"destDepth",
		"destReds",
		"destReds",
		"destPaletteSize",
		"destPaletteSize",
		"destReds",
		"ditherEnabled",
		"rerr",
		"destWidth",
		"gerr",
		"destWidth",
		"berr",
		"destWidth",
		"rerr",
		"gerr",
		"berr",
		"destHeight",
		"sfyi",
		"dy",
		"dy",
		"sp",
		"spr",
		"sfy",
		"srcStride",
		"ap",
		"apr",
		"sfy",
		"alphaStride",
		"sfy",
		"sfy",
		"sfyi",
		"dp",
		"dpr",
		"dpryi",
		"destWidth",
		"sfxi",
		"dx",
		"dx",
		"dp",
		"dprxi",
		"sfx",
		"sfx",
		"sfxi",
		"stype",
		"TYPE_GENERIC_8",
		"srcData",
		"sp",
		"sp",
		"sfx",
		"r",
		"srcReds",
		"data",
		"srcRedMask",
		"srcRedShift",
		"g",
		"srcGreens",
		"data",
		"srcGreenMask",
		"srcGreenShift",
		"b",
		"srcBlues",
		"data",
		"srcBlueMask",
		"srcBlueShift",
		"a",
		"srcAlphas",
		"data",
		"srcAlphaMask",
		"srcAlphaShift",
		"TYPE_GENERIC_16_MSB",
		"srcData",
		"sp",
		"srcData",
		"sp",
		"sp",
		"sfx",
		"r",
		"srcReds",
		"data",
		"srcRedMask",
		"srcRedShift",
		"g",
		"srcGreens",
		"data",
		"srcGreenMask",
		"srcGreenShift",
		"b",
		"srcBlues",
		"data",
		"srcBlueMask",
		"srcBlueShift",
		"a",
		"srcAlphas",
		"data",
		"srcAlphaMask",
		"srcAlphaShift",
		"TYPE_GENERIC_16_LSB",
		"srcData",
		"sp",
		"srcData",
		"sp",
		"sp",
		"sfx",
		"r",
		"srcReds",
		"data",
		"srcRedMask",
		"srcRedShift",
		"g",
		"srcGreens",
		"data",
		"srcGreenMask",
		"srcGreenShift",
		"b",
		"srcBlues",
		"data",
		"srcBlueMask",
		"srcBlueShift",
		"a",
		"srcAlphas",
		"data",
		"srcAlphaMask",
		"srcAlphaShift",
		"TYPE_GENERIC_24",
		"srcData",
		"sp",
		"srcData",
		"sp",
		"srcData",
		"sp",
		"sp",
		"sfx",
		"r",
		"srcReds",
		"data",
		"srcRedMask",
		"srcRedShift",
		"g",
		"srcGreens",
		"data",
		"srcGreenMask",
		"srcGreenShift",
		"b",
		"srcBlues",
		"data",
		"srcBlueMask",
		"srcBlueShift",
		"a",
		"srcAlphas",
		"data",
		"srcAlphaMask",
		"srcAlphaShift",
		"TYPE_GENERIC_32_MSB",
		"srcData",
		"sp",
		"srcData",
		"sp",
		"srcData",
		"sp",
		"srcData",
		"sp",
		"sp",
		"sfx",
		"r",
		"srcReds",
		"data",
		"srcRedMask",
		"srcRedShift",
		"g",
		"srcGreens",
		"data",
		"srcGreenMask",
		"srcGreenShift",
		"b",
		"srcBlues",
		"data",
		"srcBlueMask",
		"srcBlueShift",
		"a",
		"srcAlphas",
		"data",
		"srcAlphaMask",
		"srcAlphaShift",
		"TYPE_GENERIC_32_LSB",
		"srcData",
		"sp",
		"srcData",
		"sp",
		"srcData",
		"sp",
		"srcData",
		"sp",
		"sp",
		"sfx",
		"r",
		"srcReds",
		"data",
		"srcRedMask",
		"srcRedShift",
		"g",
		"srcGreens",
		"data",
		"srcGreenMask",
		"srcGreenShift",
		"b",
		"srcBlues",
		"data",
		"srcBlueMask",
		"srcBlueShift",
		"a",
		"srcAlphas",
		"data",
		"srcAlphaMask",
		"srcAlphaShift",
		"alphaMode",
		"ALPHA_CHANNEL_SEPARATE",
		"alpha",
		"alphaData",
		"ap",
		"ap",
		"sfx",
		"ALPHA_CHANNEL_SOURCE",
		"alpha",
		"a",
		"ALPHA_MASK_UNPACKED",
		"alpha",
		"alphaData",
		"ap",
		"ap",
		"sfx",
		"ALPHA_MASK_PACKED",
		"alpha",
		"alphaData",
		"ap",
		"ap",
		"ap",
		"sfx",
		"ALPHA_MASK_RGB",
		"alpha",
		"i",
		"alphaData",
		"i",
		"r",
		"alphaData",
		"i",
		"g",
		"alphaData",
		"i",
		"b",
		"alphaData",
		"i",
		"alpha",
		"alpha",
		"alpha",
		"dtype",
		"TYPE_INDEX_8",
		"indexq",
		"destData",
		"dp",
		"TYPE_INDEX_4",
		"dp",
		"indexq",
		"destData",
		"dp",
		"indexq",
		"destData",
		"dp",
		"TYPE_INDEX_2",
		"indexq",
		"destData",
		"dp",
		"dp",
		"TYPE_INDEX_1_MSB",
		"indexq",
		"destData",
		"dp",
		"dp",
		"TYPE_INDEX_1_LSB",
		"indexq",
		"destData",
		"dp",
		"dp",
		"destReds",
		"indexq",
		"destGreens",
		"indexq",
		"destBlues",
		"indexq",
		"r",
		"rq",
		"r",
		"rq",
		"alpha",
		"g",
		"gq",
		"g",
		"gq",
		"alpha",
		"b",
		"bq",
		"b",
		"bq",
		"alpha",
		"ditherEnabled",
		"r",
		"rerr",
		"dx",
		"r",
		"r",
		"r",
		"r",
		"g",
		"gerr",
		"dx",
		"g",
		"g",
		"g",
		"g",
		"b",
		"berr",
		"dx",
		"b",
		"b",
		"b",
		"b",
		"rerr",
		"dx",
		"lrerr",
		"gerr",
		"dx",
		"lgerr",
		"berr",
		"dx",
		"lberr",
		"r",
		"lastr",
		"g",
		"lastg",
		"b",
		"lastb",
		"j",
		"destPaletteSize",
		"j",
		"dr",
		"destReds",
		"j",
		"r",
		"dg",
		"destGreens",
		"j",
		"g",
		"db",
		"destBlues",
		"j",
		"b",
		"distance",
		"dr",
		"dr",
		"dg",
		"dg",
		"db",
		"db",
		"distance",
		"minDistance",
		"lastindex",
		"j",
		"distance",
		"minDistance",
		"distance",
		"lastr",
		"r",
		"lastg",
		"g",
		"lastb",
		"b",
		"ditherEnabled",
		"dx",
		"dx",
		"rerr",
		"dxp1",
		"acc",
		"lrerr",
		"r",
		"destReds",
		"lastindex",
		"lrerr",
		"lrerr",
		"rerr",
		"dx",
		"acc",
		"lrerr",
		"lrerr",
		"rerr",
		"dxm1",
		"acc",
		"lrerr",
		"lrerr",
		"gerr",
		"dxp1",
		"acc",
		"lgerr",
		"g",
		"destGreens",
		"lastindex",
		"lgerr",
		"lgerr",
		"gerr",
		"dx",
		"acc",
		"lgerr",
		"lgerr",
		"gerr",
		"dxm1",
		"acc",
		"lgerr",
		"lgerr",
		"berr",
		"dxp1",
		"acc",
		"lberr",
		"b",
		"destBlues",
		"lastindex",
		"lberr",
		"lberr",
		"berr",
		"dx",
		"acc",
		"lberr",
		"lberr",
		"berr",
		"dxm1",
		"acc",
		"lberr",
		"lberr",
		"dtype",
		"TYPE_INDEX_8",
		"destData",
		"dp",
		"lastindex",
		"TYPE_INDEX_4",
		"dp",
		"destData",
		"dp",
		"destData",
		"dp",
		"lastindex",
		"destData",
		"dp",
		"destData",
		"dp",
		"lastindex",
		"TYPE_INDEX_2",
		"dp",
		"destData",
		"dp",
		"destData",
		"dp",
		"shift",
		"lastindex",
		"shift",
		"TYPE_INDEX_1_MSB",
		"dp",
		"destData",
		"dp",
		"destData",
		"dp",
		"shift",
		"lastindex",
		"shift",
		"TYPE_INDEX_1_LSB",
		"dp",
		"destData",
		"dp",
		"destData",
		"dp",
		"shift",
		"lastindex",
		"shift",
		"mask",
		"i",
		"mask",
		"i",
		"i",
		"mask",
		"i",
		"mask",
		"mask",
		"shift",
		"i",
		"shift",
		"mask",
		"i",
		"i",
		"mask",
		"i",
		"shift",
		"mask",
		"ANY_TO_EIGHT",
		"mask",
		"shift",
		"data",
		"mask",
		"shift",
		"redBits",
		"greenBits",
		"blueBits",
		"paletteData",
		"bitmapDepth",
		"redBits",
		"greenBits",
		"blueBits",
		"vertical",
		"bandWidth",
		"bandHeight",
		"height",
		"steps",
		"bandHeight",
		"bandHeight",
		"bandWidth",
		"width",
		"bandHeight",
		"steps",
		"bandWidth",
		"bandWidth",
		"bandWidth",
		"bitmapData",
		"bandHeight",
		"bytesPerLine",
		"fromRGB",
		"toRGB",
		"steps",
		"bandWidth",
		"bandHeight",
		"vertical",
		"bitmapData",
		"bytesPerLine",
		"fromRGB",
		"toRGB",
		"steps",
		"bandWidth",
		"bandHeight",
		"vertical",
		"bitmapData",
		"bytesPerLine",
		"fromRGB",
		"toRGB",
		"steps",
		"bandWidth",
		"bandHeight",
		"vertical",
		"bitmapData",
		"bytesPerLine",
		"vertical",
		"bandWidth",
		"width",
		"width",
		"bandHeight",
		"height",
		"steps",
		"bandHeight",
		"bandHeight",
		"bandWidth",
		"width",
		"bandHeight",
		"height",
		"height",
		"steps",
		"bandWidth",
		"bandWidth",
		"bandWidth",
		"bitmapData",
		"bandHeight",
		"bytesPerLine",
		"fromRGB",
		"toRGB",
		"steps",
		"bandWidth",
		"bandHeight",
		"vertical",
		"bitmapData",
		"bytesPerLine",
		"blueBits",
		"fromRGB",
		"toRGB",
		"steps",
		"bandWidth",
		"bandHeight",
		"vertical",
		"bitmapData",
		"bytesPerLine",
		"greenBits",
		"fromRGB",
		"toRGB",
		"steps",
		"bandWidth",
		"bandHeight",
		"vertical",
		"bitmapData",
		"bytesPerLine",
		"redBits",
		"paletteData",
		"fromRGB",
		"toRGB",
		"bitmapDepth",
		"vertical",
		"bandWidth",
		"width",
		"width",
		"bandHeight",
		"height",
		"blendi",
		"bandHeight",
		"bandHeight",
		"bandWidth",
		"width",
		"bandHeight",
		"height",
		"height",
		"blendi",
		"bandWidth",
		"bandWidth",
		"bandWidth",
		"bitmapData",
		"bandHeight",
		"bytesPerLine",
		"vertical",
		"dy",
		"bandHeight",
		"dy",
		"blend",
		"blendi",
		"dp",
		"bytesPerLine",
		"dx",
		"bandWidth",
		"dx",
		"bitmapData",
		"dp",
		"dx",
		"blend",
		"DITHER_MATRIX",
		"dy",
		"dx",
		"dx",
		"bandWidth",
		"dx",
		"blend",
		"blendi",
		"dx",
		"dy",
		"bandHeight",
		"dy",
		"dptr",
		"bytesPerLine",
		"bitmapData",
		"dptr",
		"blend",
		"DITHER_MATRIX",
		"dy",
		"dx",
		"bandWidth",
		"bandHeight",
		"bitmapDepth",
		"paletteData",
		"bitmapData",
		"from",
		"to",
		"val",
		"steps",
		"vertical",
		"dy",
		"bandHeight",
		"dy",
		"dp",
		"bytesPerLine",
		"bitmapData",
		"dp",
		"val",
		"val",
		"inc",
		"dx",
		"bandWidth",
		"dx",
		"dp",
		"bitmapData",
		"dp",
		"val",
		"val",
		"inc",
		"bits",
		"from",
		"to",
		"val",
		"steps",
		"vertical",
		"dy",
		"bandHeight",
		"dy",
		"dp",
		"bytesPerLine",
		"dp",
		"dx",
		"bandWidth",
		"dx",
		"dptr",
		"DITHER_MATRIX",
		"dy",
		"dx",
		"bits",
		"val",
		"thresh",
		"temp",
		"bitmapData",
		"dptr",
		"bitmapData",
		"dptr",
		"temp",
		"mask",
		"val",
		"inc",
		"dx",
		"bandWidth",
		"dx",
		"dp",
		"dp",
		"dy",
		"bandHeight",
		"dy",
		"dptr",
		"bytesPerLine",
		"DITHER_MATRIX",
		"dy",
		"dx",
		"bits",
		"val",
		"thresh",
		"temp",
		"bitmapData",
		"dptr",
		"bitmapData",
		"dptr",
		"temp",
		"mask",
		"val",
		"inc",
		"width",
		"height",
		"vertical",
		"fromRGB",
		"toRGB",
		"redBits",
		"greenBits",
		"blueBits",
		"device",
		"band",
		"band",
		"band",
		"gc",
		"image",
		"band",
		"band",
		"x",
		"y",
		"width",
		"height",
		"vertical",
		"dx",
		"width",
		"dx",
		"band",
		"width",
		"dx",
		"blitWidth",
		"band",
		"blitWidth",
		"band",
		"gc",
		"image",
		"blitWidth",
		"band",
		"dx",
		"x",
		"y",
		"blitWidth",
		"band",
		"dy",
		"height",
		"dy",
		"band",
		"height",
		"dy",
		"blitHeight",
		"band",
		"blitHeight",
		"band",
		"gc",
		"image",
		"band",
		"blitHeight",
		"x",
		"dy",
		"y",
		"band",
		"blitHeight",
		"image",
		"IMAGE_UNDEFINED",
		"IMAGE_UNDEFINED",
		"length",
		"ERROR_INVALID_IMAGE",
		"width",
		"height",
		"depth",
		"scanlinePad",
		"bytesPerLine",
		"data",
		"palette",
		"transparentPixel",
		"maskData",
		"maskPad",
		"alphaData",
		"alpha",
		"type",
		"x",
		"y",
		"disposalMethod",
		"delayTime",
		"length",
		"ERROR_INVALID_IMAGE",
		"width",
		"height",
		"depth",
		"scanlinePad",
		"bytesPerLine",
		"data",
		"palette",
		"transparentPixel",
		"maskData",
		"maskPad",
		"alphaData",
		"alpha",
		"type",
		"x",
		"y",
		"disposalMethod",
		"delayTime",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_CANNOT_BE_ZERO",
		"width",
		"height",
		"depth",
		"scanlinePad",
		"bytesPerLine",
		"data",
		"palette",
		"transparentPixel",
		"maskData",
		"maskPad",
		"alphaData",
		"alpha",
		"type",
		"x",
		"y",
		"disposalMethod",
		"delayTime",
		"IMAGE_UNDEFINED",
		"ERROR_NULL_ARGUMENT",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_UNSUPPORTED_DEPTH",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_UNSUPPORTED_DEPTH",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_UNSUPPORTED_DEPTH",
		"TRANSPARENCY_MASK",
		"TRANSPARENCY_MASK",
		"TRANSPARENCY_PIXEL",
		"TRANSPARENCY_ALPHA",
		"TRANSPARENCY_NONE",
		"isDirect",
		"data",
		"depth",
		"bytesPerLine",
		"width",
		"height",
		"data",
		"depth",
		"bytesPerLine",
		"width",
		"height",
		"data",
		"depth",
		"bytesPerLine",
		"width",
		"height",
		"data",
		"depth",
		"bytesPerLine",
		"width",
		"height",
		"maskPad",
		"maskPad",
		"width",
		"maskPad",
		"maskPad",
		"maskPad",
		"maskData",
		"height",
		"width",
		"maskPad",
		"maskPad",
		"maskPad",
		"maskData",
		"width",
		"height",
		"maskData",
		"width",
		"height",
		"alpha",
		"alpha",
		"alphaData",
		"width",
		"height",
		"alphaData",
		"width",
		"width",
		"height",
		"alphaData",
		"width",
		"width",
		"height",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_UNSUPPORTED_DEPTH",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_UNSUPPORTED_DEPTH",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_UNSUPPORTED_DEPTH",
		"length",
		"depth",
		"width",
		"height",
		"length",
		"colors",
		"width",
		"height",
		"width",
		"length",
		"width",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"blue",
		"blue",
		"green",
		"green",
		"red",
		"red",
		"blue",
		"blue",
		"green",
		"green",
		"red",
		"red",
		"width",
		"height",
		"width",
		"height",
		"width",
		"width",
		"width",
		"height",
		"height",
		"height",
		"height",
		"height",
		"width",
		"width",
		"width",
		"height",
		"depth",
		"palette",
		"width",
		"height",
		"depth",
		"palette",
		"scanlinePad",
		"data",
		"stream",
		"filename",
		"width",
		"height",
		"depth",
		"palette",
		"scanlinePad",
		"data",
		"maskPad",
		"maskData",
		"alphaData",
		"alpha",
		"transparentPixel",
		"type",
		"x",
		"y",
		"disposalMethod",
		"delayTime",
		"width",
		"height",
		"depth",
		"scanlinePad",
		"bytesPerLine",
		"data",
		"palette",
		"transparentPixel",
		"maskData",
		"maskPad",
		"alphaData",
		"alpha",
		"type",
		"x",
		"y",
		"disposalMethod",
		"delayTime",
		"width",
		"height",
		"depth",
		"palette",
		"scanlinePad",
		"data",
		"maskPad",
		"maskData",
		"alphaData",
		"alpha",
		"transparentPixel",
		"type",
		"x",
		"y",
		"disposalMethod",
		"delayTime",
		"pixel",
		"data",
		"x",
		"y",
		"x",
		"y",
		"getWidth",
		"alphas",
		"startIndex",
		"x",
		"y",
		"x",
		"y",
		"getWidth",
		"pixels",
		"startIndex",
		"x",
		"y",
		"getWidth",
		"pixels",
		"startIndex",
		"width",
		"height",
		"x",
		"y",
		"alpha",
		"x",
		"y",
		"putWidth",
		"alphas",
		"startIndex",
		"x",
		"y",
		"pixelValue",
		"x",
		"y",
		"putWidth",
		"pixels",
		"startIndex",
		"x",
		"y",
		"putWidth",
		"pixels",
		"startIndex",
		"mask",
		"depth",
		"red",
		"green",
		"blue",
		"redMask",
		"greenMask",
		"blueMask",
		"reds",
		"greens",
		"blues",
		"mask",
		"data",
		"width",
		"height",
		"depth",
		"pad",
		"newPad",
		"op",
		"srcData",
		"srcDepth",
		"srcStride",
		"srcOrder",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"srcRedMask",
		"srcGreenMask",
		"srcBlueMask",
		"alphaMode",
		"alphaData",
		"alphaStride",
		"alphaX",
		"alphaY",
		"destData",
		"destDepth",
		"destStride",
		"destOrder",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"destRedMask",
		"destGreenMask",
		"destBlueMask",
		"flipX",
		"flipY",
		"op",
		"srcData",
		"srcDepth",
		"srcStride",
		"srcOrder",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"srcReds",
		"srcGreens",
		"srcBlues",
		"alphaMode",
		"alphaData",
		"alphaStride",
		"alphaX",
		"alphaY",
		"destData",
		"destDepth",
		"destStride",
		"destOrder",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"destReds",
		"destGreens",
		"destBlues",
		"flipX",
		"flipY",
		"op",
		"srcData",
		"srcDepth",
		"srcStride",
		"srcOrder",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"srcReds",
		"srcGreens",
		"srcBlues",
		"alphaMode",
		"alphaData",
		"alphaStride",
		"alphaX",
		"alphaY",
		"destData",
		"destDepth",
		"destStride",
		"destOrder",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"destRedMask",
		"destGreenMask",
		"destBlueMask",
		"flipX",
		"flipY",
		"op",
		"srcData",
		"srcDepth",
		"srcStride",
		"srcOrder",
		"srcX",
		"srcY",
		"srcWidth",
		"srcHeight",
		"srcRedMask",
		"srcGreenMask",
		"srcBlueMask",
		"alphaMode",
		"alphaData",
		"alphaStride",
		"alphaX",
		"alphaY",
		"destData",
		"destDepth",
		"destStride",
		"destOrder",
		"destX",
		"destY",
		"destWidth",
		"destHeight",
		"destReds",
		"destGreens",
		"destBlues",
		"flipX",
		"flipY",
		"mask",
		"mask",
		"shift",
		"data",
		"mask",
		"width",
		"height",
		"vertical",
		"fromRGB",
		"toRGB",
		"redBits",
		"greenBits",
		"blueBits",
		"from",
		"to",
		"steps",
		"bandWidth",
		"bandHeight",
		"vertical",
		"bitmapData",
		"dp",
		"bytesPerLine",
		"from",
		"to",
		"steps",
		"bandWidth",
		"bandHeight",
		"vertical",
		"bitmapData",
		"dp",
		"bytesPerLine",
		"bits",
		"gc",
		"device",
		"x",
		"y",
		"width",
		"height",
		"vertical",
		"fromRGB",
		"toRGB",
		"redBits",
		"greenBits",
		"blueBits"
	],
	"extendORImplementFiles":[
		"CloneableCompatibility"
	],
	"package":[
		"org.eclipse.swt.graphics"
	],
	"import":[
		"java.io",
		"org.eclipse.swt",
		"org.eclipse.swt.internal.CloneableCompatibility"
	],
	"methods":[
		"setAllFields",
		"internal_new",
		"colorMaskImage",
		"checkData",
		"clone",
		"getAlpha",
		"getAlphas",
		"getPixel",
		"getPixels",
		"getPixels",
		"getRGBs",
		"getTransparencyMask",
		"getTransparencyType",
		"getByteOrder",
		"scaledTo",
		"setAlpha",
		"setAlphas",
		"setPixel",
		"setPixels",
		"setPixels",
		"bwPalette",
		"getMSBOffset",
		"closestMatch",
		"convertMask",
		"convertPad",
		"blit",
		"blit",
		"blit",
		"blit",
		"getChannelShift",
		"getChannelWidth",
		"getChannelField",
		"createGradientBand",
		"buildPreciseGradientChannel",
		"buildDitheredGradientChannel",
		"fillGradientRectangle",
		"checkData",
		"load",
		"error",
		"setAllFields",
		"load",
		"error",
		"setAllFields",
		"error",
		"error",
		"error",
		"error",
		"setAllFields",
		"bwPalette",
		"getPixels",
		"setPixels",
		"error",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"error",
		"error",
		"error",
		"arraycopy",
		"error",
		"error",
		"error",
		"error",
		"error",
		"error",
		"error",
		"error",
		"getRGBs",
		"getTransparencyType",
		"bwPalette",
		"colorMaskImage",
		"blit",
		"getByteOrder",
		"getByteOrder",
		"blit",
		"getByteOrder",
		"getByteOrder",
		"blit",
		"blit",
		"error",
		"error",
		"error",
		"arraycopy",
		"error",
		"error",
		"error",
		"error",
		"error",
		"error",
		"error",
		"error",
		"getMSBOffset",
		"getMSBOffset",
		"getMSBOffset",
		"getRGBs",
		"equals",
		"getPixels",
		"setPixels",
		"arraycopy",
		"getChannelShift",
		"getChannelWidth",
		"getChannelShift",
		"getChannelWidth",
		"getChannelShift",
		"getChannelWidth",
		"getChannelShift",
		"getChannelWidth",
		"getChannelShift",
		"getChannelWidth",
		"getChannelShift",
		"getChannelWidth",
		"getChannelShift",
		"getChannelWidth",
		"getChannelShift",
		"getChannelWidth",
		"getChannelShift",
		"getChannelWidth",
		"getChannelShift",
		"getChannelWidth",
		"getChannelShift",
		"getChannelWidth",
		"getChannelShift",
		"getChannelWidth",
		"getChannelShift",
		"getChannelWidth",
		"getChannelShift",
		"getChannelWidth",
		"getChannelShift",
		"getChannelWidth",
		"getChannelShift",
		"getChannelWidth",
		"getChannelShift",
		"getChannelWidth",
		"buildPreciseGradientChannel",
		"buildPreciseGradientChannel",
		"buildPreciseGradientChannel",
		"buildDitheredGradientChannel",
		"buildDitheredGradientChannel",
		"buildDitheredGradientChannel",
		"createGradientBand",
		"drawImage",
		"drawImage",
		"drawImage",
		"dispose",
		"ImageData",
		"ImageData",
		"ImageData",
		"ImageData",
		"ImageData",
		"PaletteData",
		"RGB",
		"RGB",
		"PaletteData",
		"RGB",
		"RGB",
		"ImageData",
		"PaletteData",
		"PaletteData",
		"ImageData",
		"Image"
	],
	"methodsBody":{
		"void setAllFields(int width, int height, int depth, int scanlinePad, int bytesPerLine, byte[] data, PaletteData palette, int transparentPixel, byte[] maskData, int maskPad, byte[] alphaData, int alpha, int type, int x, int y, int disposalMethod, int delayTime)":{
			"methodBody":"{\n    this.width = width;\n    this.height = height;\n    this.depth = depth;\n    this.scanlinePad = scanlinePad;\n    this.bytesPerLine = bytesPerLine;\n    this.data = data;\n    this.palette = palette;\n    this.transparentPixel = transparentPixel;\n    this.maskData = maskData;\n    this.maskPad = maskPad;\n    this.alphaData = alphaData;\n    this.alpha = alpha;\n    this.type = type;\n    this.x = x;\n    this.y = y;\n    this.disposalMethod = disposalMethod;\n    this.delayTime = delayTime;\n}",
			"comments":"/**\n* Initializes all fields in the receiver. This method must be called\n* by all public constructors to ensure that all fields are initialized\n* for a new ImageData object. If a new field is added to the class,\n* then it must be added to this method.\n* <p>\n* This method is for internal use, and is not described further.\n* </p>\n*/\n",
			"methodName":"void setAllFields(int width, int height, int depth, int scanlinePad, int bytesPerLine, byte[] data, PaletteData palette, int transparentPixel, byte[] maskData, int maskPad, byte[] alphaData, int alpha, int type, int x, int y, int disposalMethod, int delayTime)"
		},
		"public ImageData scaledTo(int width, int height)":{
			"methodBody":"{\n    \n    final boolean flipX = (width < 0);\n    if (flipX)\n        width = -width;\n    final boolean flipY = (height < 0);\n    if (flipY)\n        height = -height;\n    ImageData dest = new ImageData(width, height, depth, palette, scanlinePad, null, 0, null, null, -1, transparentPixel, type, x, y, disposalMethod, delayTime);\n    \n    if (palette.isDirect)\n        blit(BLIT_SRC, this.data, this.depth, this.bytesPerLine, this.getByteOrder(), 0, 0, this.width, this.height, 0, 0, 0, ALPHA_OPAQUE, null, 0, 0, 0, dest.data, dest.depth, dest.bytesPerLine, dest.getByteOrder(), 0, 0, dest.width, dest.height, 0, 0, 0, flipX, flipY);\n    else\n        blit(BLIT_SRC, this.data, this.depth, this.bytesPerLine, this.getByteOrder(), 0, 0, this.width, this.height, null, null, null, ALPHA_OPAQUE, null, 0, 0, 0, dest.data, dest.depth, dest.bytesPerLine, dest.getByteOrder(), 0, 0, dest.width, dest.height, null, null, null, flipX, flipY);\n    \n    if (maskData != null) {\n        dest.maskPad = this.maskPad;\n        int destBpl = (dest.width + 7) / 8;\n        destBpl = (destBpl + (dest.maskPad - 1)) / dest.maskPad * dest.maskPad;\n        dest.maskData = new byte[destBpl * dest.height];\n        int srcBpl = (this.width + 7) / 8;\n        srcBpl = (srcBpl + (this.maskPad - 1)) / this.maskPad * this.maskPad;\n        blit(BLIT_SRC, this.maskData, 1, srcBpl, MSB_FIRST, 0, 0, this.width, this.height, null, null, null, ALPHA_OPAQUE, null, 0, 0, 0, dest.maskData, 1, destBpl, MSB_FIRST, 0, 0, dest.width, dest.height, null, null, null, flipX, flipY);\n    } else if (alpha != -1) {\n        dest.alpha = this.alpha;\n    } else if (alphaData != null) {\n        dest.alphaData = new byte[dest.width * dest.height];\n        blit(BLIT_SRC, this.alphaData, 8, this.width, MSB_FIRST, 0, 0, this.width, this.height, null, null, null, ALPHA_OPAQUE, null, 0, 0, 0, dest.alphaData, 8, dest.width, MSB_FIRST, 0, 0, dest.width, dest.height, null, null, null, flipX, flipY);\n    }\n    return dest;\n}",
			"comments":"/**\n* Returns a copy of the receiver which has been stretched or\n* shrunk to the specified size. If either the width or height\n* is negative, the resulting image will be inverted in the\n* associated axis.\n*\n* @param width the width of the new ImageData\n* @param height the height of the new ImageData\n* @return a scaled copy of the image\n*/\n/* Create a destination image with no data */\n/* Scale the image contents */\n/* Scale the image mask or alpha */\n",
			"methodName":"public ImageData scaledTo(int width, int height)"
		},
		"public void setPixels(int x, int y, int putWidth, byte[] pixels, int startIndex)":{
			"methodBody":"{\n    if (pixels == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (putWidth < 0 || x >= width || y >= height || x < 0 || y < 0)\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    if (putWidth == 0)\n        return;\n    int index;\n    int theByte;\n    int mask;\n    int n = putWidth;\n    int i = startIndex;\n    int srcX = x, srcY = y;\n    if (depth == 1) {\n        index = (y * bytesPerLine) + (x >> 3);\n        while (n > 0) {\n            mask = 1 << (7 - (srcX & 0x7));\n            if ((pixels[i] & 0x1) == 1) {\n                data[index] = (byte) ((data[index] & 0xFF) | mask);\n            } else {\n                data[index] = (byte) ((data[index] & 0xFF) & (mask ^ -1));\n            }\n            i++;\n            n--;\n            srcX++;\n            if (srcX >= width) {\n                srcY++;\n                index = srcY * bytesPerLine;\n                srcX = 0;\n            } else {\n                if (mask == 1) {\n                    index++;\n                }\n            }\n        }\n        return;\n    }\n    if (depth == 2) {\n        byte[] masks = { (byte) 0xFC, (byte) 0xF3, (byte) 0xCF, (byte) 0x3F };\n        index = (y * bytesPerLine) + (x >> 2);\n        int offset = 3 - (x % 4);\n        while (n > 0) {\n            theByte = pixels[i] & 0x3;\n            data[index] = (byte) ((data[index] & masks[offset]) | (theByte << (offset * 2)));\n            i++;\n            n--;\n            srcX++;\n            if (srcX >= width) {\n                srcY++;\n                index = srcY * bytesPerLine;\n                offset = 0;\n                srcX = 0;\n            } else {\n                if (offset == 0) {\n                    index++;\n                    offset = 3;\n                } else {\n                    offset--;\n                }\n            }\n        }\n        return;\n    }\n    if (depth == 4) {\n        index = (y * bytesPerLine) + (x >> 1);\n        boolean high = (x & 0x1) == 0;\n        while (n > 0) {\n            theByte = pixels[i] & 0x0F;\n            if (high) {\n                data[index] = (byte) ((data[index] & 0x0F) | (theByte << 4));\n            } else {\n                data[index] = (byte) ((data[index] & 0xF0) | theByte);\n            }\n            i++;\n            n--;\n            srcX++;\n            if (srcX >= width) {\n                srcY++;\n                index = srcY * bytesPerLine;\n                high = true;\n                srcX = 0;\n            } else {\n                if (!high)\n                    index++;\n                high = !high;\n            }\n        }\n        return;\n    }\n    if (depth == 8) {\n        index = (y * bytesPerLine) + x;\n        for (int j = 0; j < putWidth; j++) {\n            data[index] = (byte) (pixels[i] & 0xFF);\n            i++;\n            srcX++;\n            if (srcX >= width) {\n                srcY++;\n                index = srcY * bytesPerLine;\n                srcX = 0;\n            } else {\n                index++;\n            }\n        }\n        return;\n    }\n    SWT.error(SWT.ERROR_UNSUPPORTED_DEPTH);\n}",
			"comments":"/**\n* Sets the pixel values starting at offset <code>x</code> in\n* scanline <code>y</code> in the receiver's data to the\n* values from the array <code>pixels</code> starting at\n* <code>startIndex</code>.\n*\n* @param x the x position of the pixel to set\n* @param y the y position of the pixel to set\n* @param putWidth the width of the pixels to set\n* @param pixels the pixels to set\n* @param startIndex the index at which to begin setting\n*\n* @exception IndexOutOfBoundsException if putWidth is too large\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if pixels is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if x or y is out of bounds</li>\n*    <li>ERROR_INVALID_ARGUMENT - if putWidth is negative</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_UNSUPPORTED_DEPTH if the depth is not one of 1, 2, 4, 8\n*        (For higher depths, use the int[] version of this method.)</li>\n* </ul>\n*/\n",
			"methodName":"public void setPixels(int x, int y, int putWidth, byte[] pixels, int startIndex)"
		},
		"static ImageData createGradientBand(int width, int height, boolean vertical, RGB fromRGB, RGB toRGB, int redBits, int greenBits, int blueBits)":{
			"methodBody":"{\n    \n    final int bandWidth, bandHeight, bitmapDepth;\n    final byte[] bitmapData;\n    final PaletteData paletteData;\n    \n    if (redBits != 0 && greenBits != 0 && blueBits != 0) {\n        paletteData = new PaletteData(0x0000ff00, 0x00ff0000, 0xff000000);\n        bitmapDepth = 32;\n        if (redBits >= 8 && greenBits >= 8 && blueBits >= 8) {\n            \n            final int steps;\n            if (vertical) {\n                bandWidth = 1;\n                bandHeight = height;\n                steps = bandHeight > 1 ? bandHeight - 1 : 1;\n            } else {\n                bandWidth = width;\n                bandHeight = 1;\n                steps = bandWidth > 1 ? bandWidth - 1 : 1;\n            }\n            final int bytesPerLine = bandWidth * 4;\n            bitmapData = new byte[bandHeight * bytesPerLine];\n            buildPreciseGradientChannel(fromRGB.blue, toRGB.blue, steps, bandWidth, bandHeight, vertical, bitmapData, 0, bytesPerLine);\n            buildPreciseGradientChannel(fromRGB.green, toRGB.green, steps, bandWidth, bandHeight, vertical, bitmapData, 1, bytesPerLine);\n            buildPreciseGradientChannel(fromRGB.red, toRGB.red, steps, bandWidth, bandHeight, vertical, bitmapData, 2, bytesPerLine);\n        } else {\n            \n            final int steps;\n            if (vertical) {\n                bandWidth = (width < 8) ? width : 8;\n                bandHeight = height;\n                steps = bandHeight > 1 ? bandHeight - 1 : 1;\n            } else {\n                bandWidth = width;\n                bandHeight = (height < 8) ? height : 8;\n                steps = bandWidth > 1 ? bandWidth - 1 : 1;\n            }\n            final int bytesPerLine = bandWidth * 4;\n            bitmapData = new byte[bandHeight * bytesPerLine];\n            buildDitheredGradientChannel(fromRGB.blue, toRGB.blue, steps, bandWidth, bandHeight, vertical, bitmapData, 0, bytesPerLine, blueBits);\n            buildDitheredGradientChannel(fromRGB.green, toRGB.green, steps, bandWidth, bandHeight, vertical, bitmapData, 1, bytesPerLine, greenBits);\n            buildDitheredGradientChannel(fromRGB.red, toRGB.red, steps, bandWidth, bandHeight, vertical, bitmapData, 2, bytesPerLine, redBits);\n        }\n    } else {\n        \n        paletteData = new PaletteData(new RGB[] { fromRGB, toRGB });\n        bitmapDepth = 8;\n        final int blendi;\n        if (vertical) {\n            bandWidth = (width < 8) ? width : 8;\n            bandHeight = height;\n            blendi = (bandHeight > 1) ? 0x1040000 / (bandHeight - 1) + 1 : 1;\n        } else {\n            bandWidth = width;\n            bandHeight = (height < 8) ? height : 8;\n            blendi = (bandWidth > 1) ? 0x1040000 / (bandWidth - 1) + 1 : 1;\n        }\n        final int bytesPerLine = (bandWidth + 3) & -4;\n        bitmapData = new byte[bandHeight * bytesPerLine];\n        if (vertical) {\n            for (int dy = 0, blend = 0, dp = 0; dy < bandHeight; ++dy, blend += blendi, dp += bytesPerLine) {\n                for (int dx = 0; dx < bandWidth; ++dx) {\n                    bitmapData[dp + dx] = (blend + DITHER_MATRIX[dy & 7][dx]) < 0x1000000 ? (byte) 0 : (byte) 1;\n                }\n            }\n        } else {\n            for (int dx = 0, blend = 0; dx < bandWidth; ++dx, blend += blendi) {\n                for (int dy = 0, dptr = dx; dy < bandHeight; ++dy, dptr += bytesPerLine) {\n                    bitmapData[dptr] = (blend + DITHER_MATRIX[dy][dx & 7]) < 0x1000000 ? (byte) 0 : (byte) 1;\n                }\n            }\n        }\n    }\n    return new ImageData(bandWidth, bandHeight, bitmapDepth, paletteData, 4, bitmapData);\n}",
			"comments":"/**\n* Creates an ImageData containing one band's worth of a gradient filled\n* block.  If <code>vertical</code> is true, the band must be tiled\n* horizontally to fill a region, otherwise it must be tiled vertically.\n*\n* @param width the width of the region to be filled\n* @param height the height of the region to be filled\n* @param vertical if true sweeps from top to bottom, else\n*        sweeps from left to right\n* @param fromRGB the color to start with\n* @param toRGB the color to end with\n* @param redBits the number of significant red bits, 0 for palette modes\n* @param greenBits the number of significant green bits, 0 for palette modes\n* @param blueBits the number of significant blue bits, 0 for palette modes\n* @return the new ImageData\n*/\n/* Gradients are drawn as tiled bands */\n/* Select an algorithm depending on the depth of the screen */\n/* Precise color */\n/* Dithered color */\n/* Dithered two tone */\n",
			"methodName":"static ImageData createGradientBand(int width, int height, boolean vertical, RGB fromRGB, RGB toRGB, int redBits, int greenBits, int blueBits)"
		},
		"static final ImageData convertMask(ImageData mask)":{
			"methodBody":"{\n    if (mask.depth == 1)\n        return mask;\n    PaletteData palette = new PaletteData(new RGB[] { new RGB(0, 0, 0), new RGB(255, 255, 255) });\n    ImageData newMask = new ImageData(mask.width, mask.height, 1, palette);\n    \n    int blackIndex = 0;\n    RGB[] rgbs = mask.getRGBs();\n    if (rgbs != null) {\n        while (blackIndex < rgbs.length) {\n            if (rgbs[blackIndex].equals(palette.colors[0]))\n                break;\n            blackIndex++;\n        }\n    }\n    int[] pixels = new int[mask.width];\n    for (int y = 0; y < mask.height; y++) {\n        mask.getPixels(0, y, mask.width, pixels, 0);\n        for (int i = 0; i < pixels.length; i++) {\n            if (pixels[i] == blackIndex) {\n                pixels[i] = 0;\n            } else {\n                pixels[i] = 1;\n            }\n        }\n        newMask.setPixels(0, y, mask.width, pixels, 0);\n    }\n    return newMask;\n}",
			"comments":"/* Find index of black in mask palette */\n",
			"methodName":"static final ImageData convertMask(ImageData mask)"
		},
		"public Object clone()":{
			"methodBody":"{\n    byte[] cloneData = new byte[data.length];\n    System.arraycopy(data, 0, cloneData, 0, data.length);\n    byte[] cloneMaskData = null;\n    if (maskData != null) {\n        cloneMaskData = new byte[maskData.length];\n        System.arraycopy(maskData, 0, cloneMaskData, 0, maskData.length);\n    }\n    byte[] cloneAlphaData = null;\n    if (alphaData != null) {\n        cloneAlphaData = new byte[alphaData.length];\n        System.arraycopy(alphaData, 0, cloneAlphaData, 0, alphaData.length);\n    }\n    return new ImageData(width, height, depth, palette, scanlinePad, cloneData, maskPad, cloneMaskData, cloneAlphaData, alpha, transparentPixel, type, x, y, disposalMethod, delayTime);\n}",
			"comments":"/**\n* Returns a new instance of the same class as the receiver,\n* whose slots have been filled in with <em>copies</em> of\n* the values in the slots of the receiver. That is, the\n* returned object is a <em>deep copy</em> of the receiver.\n*\n* @return a copy of the receiver.\n*/\n",
			"methodName":"public Object clone()"
		},
		"static final void buildDitheredGradientChannel(int from, int to, int steps, int bandWidth, int bandHeight, boolean vertical, byte[] bitmapData, int dp, int bytesPerLine, int bits)":{
			"methodBody":"{\n    final int mask = 0xff00 >>> bits;\n    int val = from << 16;\n    final int inc = ((to << 16) - val) / steps + 1;\n    if (vertical) {\n        for (int dy = 0; dy < bandHeight; ++dy, dp += bytesPerLine) {\n            for (int dx = 0, dptr = dp; dx < bandWidth; ++dx, dptr += 4) {\n                final int thresh = DITHER_MATRIX[dy & 7][dx] >>> bits;\n                int temp = val + thresh;\n                if (temp > 0xffffff)\n                    bitmapData[dptr] = -1;\n                else\n                    bitmapData[dptr] = (byte) ((temp >>> 16) & mask);\n            }\n            val += inc;\n        }\n    } else {\n        for (int dx = 0; dx < bandWidth; ++dx, dp += 4) {\n            for (int dy = 0, dptr = dp; dy < bandHeight; ++dy, dptr += bytesPerLine) {\n                final int thresh = DITHER_MATRIX[dy][dx & 7] >>> bits;\n                int temp = val + thresh;\n                if (temp > 0xffffff)\n                    bitmapData[dptr] = -1;\n                else\n                    bitmapData[dptr] = (byte) ((temp >>> 16) & mask);\n            }\n            val += inc;\n        }\n    }\n}",
			"comments":"/*\n* Fill in dithered gradated values for a color channel\n*/\n",
			"methodName":"static final void buildDitheredGradientChannel(int from, int to, int steps, int bandWidth, int bandHeight, boolean vertical, byte[] bitmapData, int dp, int bytesPerLine, int bits)"
		},
		"static void blit(int op, byte[] srcData, int srcDepth, int srcStride, int srcOrder, int srcX, int srcY, int srcWidth, int srcHeight, int srcRedMask, int srcGreenMask, int srcBlueMask, int alphaMode, byte[] alphaData, int alphaStride, int alphaX, int alphaY, byte[] destData, int destDepth, int destStride, int destOrder, int destX, int destY, int destWidth, int destHeight, byte[] destReds, byte[] destGreens, byte[] destBlues, boolean flipX, boolean flipY)":{
			"methodBody":"{\n    if ((destWidth <= 0) || (destHeight <= 0) || (alphaMode == ALPHA_TRANSPARENT))\n        return;\n    \n    final int srcAlphaMask = 0;\n    \n    final int dwm1 = destWidth - 1;\n    final int sfxi = (dwm1 != 0) ? (int) ((((long) srcWidth << 16) - 1) / dwm1) : 0;\n    final int dhm1 = destHeight - 1;\n    final int sfyi = (dhm1 != 0) ? (int) ((((long) srcHeight << 16) - 1) / dhm1) : 0;\n    \n    final int sbpp, stype;\n    switch(srcDepth) {\n        case 8:\n            sbpp = 1;\n            stype = TYPE_GENERIC_8;\n            break;\n        case 16:\n            sbpp = 2;\n            stype = (srcOrder == MSB_FIRST) ? TYPE_GENERIC_16_MSB : TYPE_GENERIC_16_LSB;\n            break;\n        case 24:\n            sbpp = 3;\n            stype = TYPE_GENERIC_24;\n            break;\n        case 32:\n            sbpp = 4;\n            stype = (srcOrder == MSB_FIRST) ? TYPE_GENERIC_32_MSB : TYPE_GENERIC_32_LSB;\n            break;\n        default:\n            \n            return;\n    }\n    int spr = srcY * srcStride + srcX * sbpp;\n    \n    final int dtype;\n    switch(destDepth) {\n        case 8:\n            dtype = TYPE_INDEX_8;\n            break;\n        case 4:\n            destStride <<= 1;\n            dtype = TYPE_INDEX_4;\n            break;\n        case 2:\n            destStride <<= 2;\n            dtype = TYPE_INDEX_2;\n            break;\n        case 1:\n            destStride <<= 3;\n            dtype = (destOrder == MSB_FIRST) ? TYPE_INDEX_1_MSB : TYPE_INDEX_1_LSB;\n            break;\n        default:\n            \n            return;\n    }\n    int dpr = ((flipY) ? destY + dhm1 : destY) * destStride + ((flipX) ? destX + dwm1 : destX);\n    final int dprxi = (flipX) ? -1 : 1;\n    final int dpryi = (flipY) ? -destStride : destStride;\n    \n    int apr;\n    if ((op & BLIT_ALPHA) != 0) {\n        switch(alphaMode) {\n            case ALPHA_MASK_UNPACKED:\n            case ALPHA_CHANNEL_SEPARATE:\n                if (alphaData == null)\n                    alphaMode = 0x10000;\n                apr = alphaY * alphaStride + alphaX;\n                break;\n            case ALPHA_MASK_PACKED:\n                if (alphaData == null)\n                    alphaMode = 0x10000;\n                alphaStride <<= 3;\n                apr = alphaY * alphaStride + alphaX;\n                break;\n            case ALPHA_MASK_INDEX:\n                \n                return;\n            case ALPHA_MASK_RGB:\n                if (alphaData == null)\n                    alphaMode = 0x10000;\n                apr = 0;\n                break;\n            default:\n                \n                alphaMode = (alphaMode << 16) / 255;\n            case ALPHA_CHANNEL_SOURCE:\n                apr = 0;\n                break;\n        }\n    } else {\n        alphaMode = 0x10000;\n        apr = 0;\n    }\n    final boolean ditherEnabled = (op & BLIT_DITHER) != 0;\n    \n    final int srcRedShift = getChannelShift(srcRedMask);\n    final byte[] srcReds = ANY_TO_EIGHT[getChannelWidth(srcRedMask, srcRedShift)];\n    final int srcGreenShift = getChannelShift(srcGreenMask);\n    final byte[] srcGreens = ANY_TO_EIGHT[getChannelWidth(srcGreenMask, srcGreenShift)];\n    final int srcBlueShift = getChannelShift(srcBlueMask);\n    final byte[] srcBlues = ANY_TO_EIGHT[getChannelWidth(srcBlueMask, srcBlueShift)];\n    final int srcAlphaShift = getChannelShift(srcAlphaMask);\n    final byte[] srcAlphas = ANY_TO_EIGHT[getChannelWidth(srcAlphaMask, srcAlphaShift)];\n    int dp = dpr;\n    int sp = spr;\n    int ap = apr, alpha = alphaMode;\n    int r = 0, g = 0, b = 0, a = 0;\n    int indexq = 0;\n    int lastindex = 0, lastr = -1, lastg = -1, lastb = -1;\n    final int[] rerr, gerr, berr;\n    int destPaletteSize = 1 << destDepth;\n    if ((destReds != null) && (destReds.length < destPaletteSize))\n        destPaletteSize = destReds.length;\n    if (ditherEnabled) {\n        rerr = new int[destWidth + 2];\n        gerr = new int[destWidth + 2];\n        berr = new int[destWidth + 2];\n    } else {\n        rerr = null;\n        gerr = null;\n        berr = null;\n    }\n    for (int dy = destHeight, sfy = sfyi; dy > 0; --dy, sp = spr += (sfy >>> 16) * srcStride, ap = apr += (sfy >>> 16) * alphaStride, sfy = (sfy & 0xffff) + sfyi, dp = dpr += dpryi) {\n        int lrerr = 0, lgerr = 0, lberr = 0;\n        for (int dx = destWidth, sfx = sfxi; dx > 0; --dx, dp += dprxi, sfx = (sfx & 0xffff) + sfxi) {\n            \n            switch(stype) {\n                case TYPE_GENERIC_8:\n                    {\n                        final int data = srcData[sp] & 0xff;\n                        sp += (sfx >>> 16);\n                        r = srcReds[(data & srcRedMask) >>> srcRedShift] & 0xff;\n                        g = srcGreens[(data & srcGreenMask) >>> srcGreenShift] & 0xff;\n                        b = srcBlues[(data & srcBlueMask) >>> srcBlueShift] & 0xff;\n                        a = srcAlphas[(data & srcAlphaMask) >>> srcAlphaShift] & 0xff;\n                    }\n                    break;\n                case TYPE_GENERIC_16_MSB:\n                    {\n                        final int data = ((srcData[sp] & 0xff) << 8) | (srcData[sp + 1] & 0xff);\n                        sp += (sfx >>> 16) * 2;\n                        r = srcReds[(data & srcRedMask) >>> srcRedShift] & 0xff;\n                        g = srcGreens[(data & srcGreenMask) >>> srcGreenShift] & 0xff;\n                        b = srcBlues[(data & srcBlueMask) >>> srcBlueShift] & 0xff;\n                        a = srcAlphas[(data & srcAlphaMask) >>> srcAlphaShift] & 0xff;\n                    }\n                    break;\n                case TYPE_GENERIC_16_LSB:\n                    {\n                        final int data = ((srcData[sp + 1] & 0xff) << 8) | (srcData[sp] & 0xff);\n                        sp += (sfx >>> 16) * 2;\n                        r = srcReds[(data & srcRedMask) >>> srcRedShift] & 0xff;\n                        g = srcGreens[(data & srcGreenMask) >>> srcGreenShift] & 0xff;\n                        b = srcBlues[(data & srcBlueMask) >>> srcBlueShift] & 0xff;\n                        a = srcAlphas[(data & srcAlphaMask) >>> srcAlphaShift] & 0xff;\n                    }\n                    break;\n                case TYPE_GENERIC_24:\n                    {\n                        final int data = ((((srcData[sp] & 0xff) << 8) | (srcData[sp + 1] & 0xff)) << 8) | (srcData[sp + 2] & 0xff);\n                        sp += (sfx >>> 16) * 3;\n                        r = srcReds[(data & srcRedMask) >>> srcRedShift] & 0xff;\n                        g = srcGreens[(data & srcGreenMask) >>> srcGreenShift] & 0xff;\n                        b = srcBlues[(data & srcBlueMask) >>> srcBlueShift] & 0xff;\n                        a = srcAlphas[(data & srcAlphaMask) >>> srcAlphaShift] & 0xff;\n                    }\n                    break;\n                case TYPE_GENERIC_32_MSB:\n                    {\n                        final int data = ((((((srcData[sp] & 0xff) << 8) | (srcData[sp + 1] & 0xff)) << 8) | (srcData[sp + 2] & 0xff)) << 8) | (srcData[sp + 3] & 0xff);\n                        sp += (sfx >>> 16) * 4;\n                        r = srcReds[(data & srcRedMask) >>> srcRedShift] & 0xff;\n                        g = srcGreens[(data & srcGreenMask) >>> srcGreenShift] & 0xff;\n                        b = srcBlues[(data & srcBlueMask) >>> srcBlueShift] & 0xff;\n                        a = srcAlphas[(data & srcAlphaMask) >>> srcAlphaShift] & 0xff;\n                    }\n                    break;\n                case TYPE_GENERIC_32_LSB:\n                    {\n                        final int data = ((((((srcData[sp + 3] & 0xff) << 8) | (srcData[sp + 2] & 0xff)) << 8) | (srcData[sp + 1] & 0xff)) << 8) | (srcData[sp] & 0xff);\n                        sp += (sfx >>> 16) * 4;\n                        r = srcReds[(data & srcRedMask) >>> srcRedShift] & 0xff;\n                        g = srcGreens[(data & srcGreenMask) >>> srcGreenShift] & 0xff;\n                        b = srcBlues[(data & srcBlueMask) >>> srcBlueShift] & 0xff;\n                        a = srcAlphas[(data & srcAlphaMask) >>> srcAlphaShift] & 0xff;\n                    }\n                    break;\n            }\n            \n            switch(alphaMode) {\n                case ALPHA_CHANNEL_SEPARATE:\n                    alpha = ((alphaData[ap] & 0xff) << 16) / 255;\n                    ap += (sfx >> 16);\n                    break;\n                case ALPHA_CHANNEL_SOURCE:\n                    alpha = (a << 16) / 255;\n                    break;\n                case ALPHA_MASK_UNPACKED:\n                    alpha = (alphaData[ap] != 0) ? 0x10000 : 0;\n                    ap += (sfx >> 16);\n                    break;\n                case ALPHA_MASK_PACKED:\n                    alpha = (alphaData[ap >> 3] << ((ap & 7) + 9)) & 0x10000;\n                    ap += (sfx >> 16);\n                    break;\n                case ALPHA_MASK_RGB:\n                    alpha = 0x10000;\n                    for (int i = 0; i < alphaData.length; i += 3) {\n                        if ((r == alphaData[i]) && (g == alphaData[i + 1]) && (b == alphaData[i + 2])) {\n                            alpha = 0x0000;\n                            break;\n                        }\n                    }\n                    break;\n            }\n            if (alpha != 0x10000) {\n                if (alpha == 0x0000)\n                    continue;\n                switch(dtype) {\n                    case TYPE_INDEX_8:\n                        indexq = destData[dp] & 0xff;\n                        break;\n                    case TYPE_INDEX_4:\n                        if ((dp & 1) != 0)\n                            indexq = destData[dp >> 1] & 0x0f;\n                        else\n                            indexq = (destData[dp >> 1] >>> 4) & 0x0f;\n                        break;\n                    case TYPE_INDEX_2:\n                        indexq = (destData[dp >> 2] >>> (6 - (dp & 3) * 2)) & 0x03;\n                        break;\n                    case TYPE_INDEX_1_MSB:\n                        indexq = (destData[dp >> 3] >>> (7 - (dp & 7))) & 0x01;\n                        break;\n                    case TYPE_INDEX_1_LSB:\n                        indexq = (destData[dp >> 3] >>> (dp & 7)) & 0x01;\n                        break;\n                }\n                \n                final int rq = destReds[indexq] & 0xff;\n                final int gq = destGreens[indexq] & 0xff;\n                final int bq = destBlues[indexq] & 0xff;\n                r = rq + ((r - rq) * alpha >> 16);\n                g = gq + ((g - gq) * alpha >> 16);\n                b = bq + ((b - bq) * alpha >> 16);\n            }\n            \n            if (ditherEnabled) {\n                \n                r += rerr[dx] >> 4;\n                if (r < 0)\n                    r = 0;\n                else if (r > 255)\n                    r = 255;\n                g += gerr[dx] >> 4;\n                if (g < 0)\n                    g = 0;\n                else if (g > 255)\n                    g = 255;\n                b += berr[dx] >> 4;\n                if (b < 0)\n                    b = 0;\n                else if (b > 255)\n                    b = 255;\n                rerr[dx] = lrerr;\n                gerr[dx] = lgerr;\n                berr[dx] = lberr;\n            }\n            if (r != lastr || g != lastg || b != lastb) {\n                \n                for (int j = 0, dr, dg, db, distance, minDistance = 0x7fffffff; j < destPaletteSize; ++j) {\n                    dr = (destReds[j] & 0xff) - r;\n                    dg = (destGreens[j] & 0xff) - g;\n                    db = (destBlues[j] & 0xff) - b;\n                    distance = dr * dr + dg * dg + db * db;\n                    if (distance < minDistance) {\n                        lastindex = j;\n                        if (distance == 0)\n                            break;\n                        minDistance = distance;\n                    }\n                }\n                lastr = r;\n                lastg = g;\n                lastb = b;\n            }\n            if (ditherEnabled) {\n                \n                final int dxm1 = dx - 1, dxp1 = dx + 1;\n                int acc;\n                rerr[dxp1] += acc = (lrerr = r - (destReds[lastindex] & 0xff)) + lrerr + lrerr;\n                rerr[dx] += acc += lrerr + lrerr;\n                rerr[dxm1] += acc + lrerr + lrerr;\n                gerr[dxp1] += acc = (lgerr = g - (destGreens[lastindex] & 0xff)) + lgerr + lgerr;\n                gerr[dx] += acc += lgerr + lgerr;\n                gerr[dxm1] += acc + lgerr + lgerr;\n                berr[dxp1] += acc = (lberr = b - (destBlues[lastindex] & 0xff)) + lberr + lberr;\n                berr[dx] += acc += lberr + lberr;\n                berr[dxm1] += acc + lberr + lberr;\n            }\n            \n            switch(dtype) {\n                case TYPE_INDEX_8:\n                    destData[dp] = (byte) lastindex;\n                    break;\n                case TYPE_INDEX_4:\n                    if ((dp & 1) != 0)\n                        destData[dp >> 1] = (byte) ((destData[dp >> 1] & 0xf0) | lastindex);\n                    else\n                        destData[dp >> 1] = (byte) ((destData[dp >> 1] & 0x0f) | (lastindex << 4));\n                    break;\n                case TYPE_INDEX_2:\n                    {\n                        final int shift = 6 - (dp & 3) * 2;\n                        destData[dp >> 2] = (byte) (destData[dp >> 2] & ~(0x03 << shift) | (lastindex << shift));\n                    }\n                    break;\n                case TYPE_INDEX_1_MSB:\n                    {\n                        final int shift = 7 - (dp & 7);\n                        destData[dp >> 3] = (byte) (destData[dp >> 3] & ~(0x01 << shift) | (lastindex << shift));\n                    }\n                    break;\n                case TYPE_INDEX_1_LSB:\n                    {\n                        final int shift = dp & 7;\n                        destData[dp >> 3] = (byte) (destData[dp >> 3] & ~(0x01 << shift) | (lastindex << shift));\n                    }\n                    break;\n            }\n        }\n    }\n}",
			"comments":"/**\n* Blits a direct palette image into an index palette image.\n* <p>\n* Note: The source and destination masks and palettes must\n* always be fully specified.\n* </p>\n*\n* @param op the blitter operation: a combination of BLIT_xxx flags\n*        (see BLIT_xxx constants)\n* @param srcData the source byte array containing image data\n* @param srcDepth the source depth: one of 8, 16, 24, 32\n* @param srcStride the source number of bytes per line\n* @param srcOrder the source byte ordering: one of MSB_FIRST or LSB_FIRST;\n*        ignored if srcDepth is not 16 or 32\n* @param srcX the top-left x-coord of the source blit region\n* @param srcY the top-left y-coord of the source blit region\n* @param srcWidth the width of the source blit region\n* @param srcHeight the height of the source blit region\n* @param srcRedMask the source red channel mask\n* @param srcGreenMask the source green channel mask\n* @param srcBlueMask the source blue channel mask\n* @param alphaMode the alpha blending or mask mode, may be\n*        an integer 0-255 for global alpha; ignored if BLIT_ALPHA\n*        not specified in the blitter operations\n*        (see ALPHA_MODE_xxx constants)\n* @param alphaData the alpha blending or mask data, varies depending\n*        on the value of alphaMode and sometimes ignored\n* @param alphaStride the alpha data number of bytes per line\n* @param alphaX the top-left x-coord of the alpha blit region\n* @param alphaY the top-left y-coord of the alpha blit region\n* @param destData the destination byte array containing image data\n* @param destDepth the destination depth: one of 1, 2, 4, 8\n* @param destStride the destination number of bytes per line\n* @param destOrder the destination byte ordering: one of MSB_FIRST or LSB_FIRST;\n*        ignored if destDepth is not 1\n* @param destX the top-left x-coord of the destination blit region\n* @param destY the top-left y-coord of the destination blit region\n* @param destWidth the width of the destination blit region\n* @param destHeight the height of the destination blit region\n* @param destReds the destination palette red component intensities\n* @param destGreens the destination palette green component intensities\n* @param destBlues the destination palette blue component intensities\n* @param flipX if true the resulting image is flipped along the vertical axis\n* @param flipY if true the resulting image is flipped along the horizontal axis\n*/\n// these should be supplied as params later\n/*** Prepare scaling data ***/\n/*** Prepare source-related data ***/\n//throw new IllegalArgumentException(\"Invalid source type\");\n/*** Prepare destination-related data ***/\n//throw new IllegalArgumentException(\"Invalid source type\");\n/*** Prepare special processing data ***/\n//throw new IllegalArgumentException(\"Invalid alpha type\");\n// prescale\n/*** Comprehensive blit (apply transformations) ***/\n/*** READ NEXT PIXEL ***/\n/*** DO SPECIAL PROCESSING IF REQUIRED ***/\n// Perform alpha blending\n/*** MAP COLOR TO THE PALETTE ***/\n// Floyd-Steinberg error diffusion\n// moving the variable declarations out seems to make the JDK JIT happier...\n// Floyd-Steinberg error diffusion, cont'd...\n/*** WRITE NEXT PIXEL ***/\n",
			"methodName":"static void blit(int op, byte[] srcData, int srcDepth, int srcStride, int srcOrder, int srcX, int srcY, int srcWidth, int srcHeight, int srcRedMask, int srcGreenMask, int srcBlueMask, int alphaMode, byte[] alphaData, int alphaStride, int alphaX, int alphaY, byte[] destData, int destDepth, int destStride, int destOrder, int destX, int destY, int destWidth, int destHeight, byte[] destReds, byte[] destGreens, byte[] destBlues, boolean flipX, boolean flipY)"
		},
		"public RGB[] getRGBs()":{
			"methodBody":"{\n    return palette.getRGBs();\n}",
			"comments":"/**\n* Returns an array of <code>RGB</code>s which comprise the\n* indexed color table of the receiver, or null if the receiver\n* has a direct color model.\n*\n* @return the RGB values for the image or null if direct color\n*\n* @see PaletteData#getRGBs()\n*/\n",
			"methodName":"public RGB[] getRGBs()"
		},
		"int getByteOrder()":{
			"methodBody":"{\n    return depth != 16 ? MSB_FIRST : LSB_FIRST;\n}",
			"comments":"/**\n* Returns the byte order of the receiver.\n*\n* @return MSB_FIRST or LSB_FIRST\n*/\n",
			"methodName":"int getByteOrder()"
		},
		"static void blit(int op, byte[] srcData, int srcDepth, int srcStride, int srcOrder, int srcX, int srcY, int srcWidth, int srcHeight, byte[] srcReds, byte[] srcGreens, byte[] srcBlues, int alphaMode, byte[] alphaData, int alphaStride, int alphaX, int alphaY, byte[] destData, int destDepth, int destStride, int destOrder, int destX, int destY, int destWidth, int destHeight, byte[] destReds, byte[] destGreens, byte[] destBlues, boolean flipX, boolean flipY)":{
			"methodBody":"{\n    if ((destWidth <= 0) || (destHeight <= 0) || (alphaMode == ALPHA_TRANSPARENT))\n        return;\n    \n    final int dwm1 = destWidth - 1;\n    final int sfxi = (dwm1 != 0) ? (int) ((((long) srcWidth << 16) - 1) / dwm1) : 0;\n    final int dhm1 = destHeight - 1;\n    final int sfyi = (dhm1 != 0) ? (int) ((((long) srcHeight << 16) - 1) / dhm1) : 0;\n    \n    final int stype;\n    switch(srcDepth) {\n        case 8:\n            stype = TYPE_INDEX_8;\n            break;\n        case 4:\n            srcStride <<= 1;\n            stype = TYPE_INDEX_4;\n            break;\n        case 2:\n            srcStride <<= 2;\n            stype = TYPE_INDEX_2;\n            break;\n        case 1:\n            srcStride <<= 3;\n            stype = (srcOrder == MSB_FIRST) ? TYPE_INDEX_1_MSB : TYPE_INDEX_1_LSB;\n            break;\n        default:\n            \n            return;\n    }\n    int spr = srcY * srcStride + srcX;\n    \n    final int dtype;\n    switch(destDepth) {\n        case 8:\n            dtype = TYPE_INDEX_8;\n            break;\n        case 4:\n            destStride <<= 1;\n            dtype = TYPE_INDEX_4;\n            break;\n        case 2:\n            destStride <<= 2;\n            dtype = TYPE_INDEX_2;\n            break;\n        case 1:\n            destStride <<= 3;\n            dtype = (destOrder == MSB_FIRST) ? TYPE_INDEX_1_MSB : TYPE_INDEX_1_LSB;\n            break;\n        default:\n            \n            return;\n    }\n    int dpr = ((flipY) ? destY + dhm1 : destY) * destStride + ((flipX) ? destX + dwm1 : destX);\n    final int dprxi = (flipX) ? -1 : 1;\n    final int dpryi = (flipY) ? -destStride : destStride;\n    \n    int apr;\n    if ((op & BLIT_ALPHA) != 0) {\n        switch(alphaMode) {\n            case ALPHA_MASK_UNPACKED:\n            case ALPHA_CHANNEL_SEPARATE:\n                if (alphaData == null)\n                    alphaMode = 0x10000;\n                apr = alphaY * alphaStride + alphaX;\n                break;\n            case ALPHA_MASK_PACKED:\n                if (alphaData == null)\n                    alphaMode = 0x10000;\n                alphaStride <<= 3;\n                apr = alphaY * alphaStride + alphaX;\n                break;\n            case ALPHA_MASK_INDEX:\n            case ALPHA_MASK_RGB:\n                if (alphaData == null)\n                    alphaMode = 0x10000;\n                apr = 0;\n                break;\n            default:\n                \n                alphaMode = (alphaMode << 16) / 255;\n            case ALPHA_CHANNEL_SOURCE:\n                apr = 0;\n                break;\n        }\n    } else {\n        alphaMode = 0x10000;\n        apr = 0;\n    }\n    final boolean ditherEnabled = (op & BLIT_DITHER) != 0;\n    \n    int dp = dpr;\n    int sp = spr;\n    int ap = apr;\n    int destPaletteSize = 1 << destDepth;\n    if ((destReds != null) && (destReds.length < destPaletteSize))\n        destPaletteSize = destReds.length;\n    byte[] paletteMapping = null;\n    boolean isExactPaletteMapping = true;\n    switch(alphaMode) {\n        case 0x10000:\n            \n            if ((stype == dtype) && (srcReds == destReds) && (srcGreens == destGreens) && (srcBlues == destBlues)) {\n                paletteMapping = ONE_TO_ONE_MAPPING;\n                break;\n            \n            } else if ((srcReds == null) || (destReds == null)) {\n                if (srcDepth <= destDepth) {\n                    paletteMapping = ONE_TO_ONE_MAPPING;\n                } else {\n                    paletteMapping = new byte[1 << srcDepth];\n                    int mask = (0xff << destDepth) >>> 8;\n                    for (int i = 0; i < paletteMapping.length; ++i) paletteMapping[i] = (byte) (i & mask);\n                }\n                break;\n            }\n        case ALPHA_MASK_UNPACKED:\n        case ALPHA_MASK_PACKED:\n        case ALPHA_MASK_INDEX:\n        case ALPHA_MASK_RGB:\n            \n            int srcPaletteSize = 1 << srcDepth;\n            paletteMapping = new byte[srcPaletteSize];\n            if ((srcReds != null) && (srcReds.length < srcPaletteSize))\n                srcPaletteSize = srcReds.length;\n            for (int i = 0, r, g, b, index; i < srcPaletteSize; ++i) {\n                r = srcReds[i] & 0xff;\n                g = srcGreens[i] & 0xff;\n                b = srcBlues[i] & 0xff;\n                index = 0;\n                int minDistance = 0x7fffffff;\n                for (int j = 0, dr, dg, db, distance; j < destPaletteSize; ++j) {\n                    dr = (destReds[j] & 0xff) - r;\n                    dg = (destGreens[j] & 0xff) - g;\n                    db = (destBlues[j] & 0xff) - b;\n                    distance = dr * dr + dg * dg + db * db;\n                    if (distance < minDistance) {\n                        index = j;\n                        if (distance == 0)\n                            break;\n                        minDistance = distance;\n                    }\n                }\n                paletteMapping[i] = (byte) index;\n                if (minDistance != 0)\n                    isExactPaletteMapping = false;\n            }\n            break;\n    }\n    if ((paletteMapping != null) && (isExactPaletteMapping || !ditherEnabled)) {\n        if ((stype == dtype) && (alphaMode == 0x10000)) {\n            \n            switch(stype) {\n                case TYPE_INDEX_8:\n                    for (int dy = destHeight, sfy = sfyi; dy > 0; --dy, sp = spr += (sfy >>> 16) * srcStride, sfy = (sfy & 0xffff) + sfyi, dp = dpr += dpryi) {\n                        for (int dx = destWidth, sfx = sfxi; dx > 0; --dx, dp += dprxi, sfx = (sfx & 0xffff) + sfxi) {\n                            destData[dp] = paletteMapping[srcData[sp] & 0xff];\n                            sp += (sfx >>> 16);\n                        }\n                    }\n                    break;\n                case TYPE_INDEX_4:\n                    for (int dy = destHeight, sfy = sfyi; dy > 0; --dy, sp = spr += (sfy >>> 16) * srcStride, sfy = (sfy & 0xffff) + sfyi, dp = dpr += dpryi) {\n                        for (int dx = destWidth, sfx = sfxi; dx > 0; --dx, dp += dprxi, sfx = (sfx & 0xffff) + sfxi) {\n                            final int v;\n                            if ((sp & 1) != 0)\n                                v = paletteMapping[srcData[sp >> 1] & 0x0f];\n                            else\n                                v = (srcData[sp >> 1] >>> 4) & 0x0f;\n                            sp += (sfx >>> 16);\n                            if ((dp & 1) != 0)\n                                destData[dp >> 1] = (byte) ((destData[dp >> 1] & 0xf0) | v);\n                            else\n                                destData[dp >> 1] = (byte) ((destData[dp >> 1] & 0x0f) | (v << 4));\n                        }\n                    }\n                    break;\n                case TYPE_INDEX_2:\n                    for (int dy = destHeight, sfy = sfyi; dy > 0; --dy, sp = spr += (sfy >>> 16) * srcStride, sfy = (sfy & 0xffff) + sfyi, dp = dpr += dpryi) {\n                        for (int dx = destWidth, sfx = sfxi; dx > 0; --dx, dp += dprxi, sfx = (sfx & 0xffff) + sfxi) {\n                            final int index = paletteMapping[(srcData[sp >> 2] >>> (6 - (sp & 3) * 2)) & 0x03];\n                            sp += (sfx >>> 16);\n                            final int shift = 6 - (dp & 3) * 2;\n                            destData[dp >> 2] = (byte) (destData[dp >> 2] & ~(0x03 << shift) | (index << shift));\n                        }\n                    }\n                    break;\n                case TYPE_INDEX_1_MSB:\n                    for (int dy = destHeight, sfy = sfyi; dy > 0; --dy, sp = spr += (sfy >>> 16) * srcStride, sfy = (sfy & 0xffff) + sfyi, dp = dpr += dpryi) {\n                        for (int dx = destWidth, sfx = sfxi; dx > 0; --dx, dp += dprxi, sfx = (sfx & 0xffff) + sfxi) {\n                            final int index = paletteMapping[(srcData[sp >> 3] >>> (7 - (sp & 7))) & 0x01];\n                            sp += (sfx >>> 16);\n                            final int shift = 7 - (dp & 7);\n                            destData[dp >> 3] = (byte) (destData[dp >> 3] & ~(0x01 << shift) | (index << shift));\n                        }\n                    }\n                    break;\n                case TYPE_INDEX_1_LSB:\n                    for (int dy = destHeight, sfy = sfyi; dy > 0; --dy, sp = spr += (sfy >>> 16) * srcStride, sfy = (sfy & 0xffff) + sfyi, dp = dpr += dpryi) {\n                        for (int dx = destWidth, sfx = sfxi; dx > 0; --dx, dp += dprxi, sfx = (sfx & 0xffff) + sfxi) {\n                            final int index = paletteMapping[(srcData[sp >> 3] >>> (sp & 7)) & 0x01];\n                            sp += (sfx >>> 16);\n                            final int shift = dp & 7;\n                            destData[dp >> 3] = (byte) (destData[dp >> 3] & ~(0x01 << shift) | (index << shift));\n                        }\n                    }\n                    break;\n            }\n        } else {\n            \n            for (int dy = destHeight, sfy = sfyi; dy > 0; --dy, sp = spr += (sfy >>> 16) * srcStride, sfy = (sfy & 0xffff) + sfyi, dp = dpr += dpryi) {\n                for (int dx = destWidth, sfx = sfxi; dx > 0; --dx, dp += dprxi, sfx = (sfx & 0xffff) + sfxi) {\n                    int index;\n                    \n                    switch(stype) {\n                        case TYPE_INDEX_8:\n                            index = srcData[sp] & 0xff;\n                            sp += (sfx >>> 16);\n                            break;\n                        case TYPE_INDEX_4:\n                            if ((sp & 1) != 0)\n                                index = srcData[sp >> 1] & 0x0f;\n                            else\n                                index = (srcData[sp >> 1] >>> 4) & 0x0f;\n                            sp += (sfx >>> 16);\n                            break;\n                        case TYPE_INDEX_2:\n                            index = (srcData[sp >> 2] >>> (6 - (sp & 3) * 2)) & 0x03;\n                            sp += (sfx >>> 16);\n                            break;\n                        case TYPE_INDEX_1_MSB:\n                            index = (srcData[sp >> 3] >>> (7 - (sp & 7))) & 0x01;\n                            sp += (sfx >>> 16);\n                            break;\n                        case TYPE_INDEX_1_LSB:\n                            index = (srcData[sp >> 3] >>> (sp & 7)) & 0x01;\n                            sp += (sfx >>> 16);\n                            break;\n                        default:\n                            return;\n                    }\n                    \n                    switch(alphaMode) {\n                        case ALPHA_MASK_UNPACKED:\n                            {\n                                final byte mask = alphaData[ap];\n                                ap += (sfx >> 16);\n                                if (mask == 0)\n                                    continue;\n                            }\n                            break;\n                        case ALPHA_MASK_PACKED:\n                            {\n                                final int mask = alphaData[ap >> 3] & (1 << (ap & 7));\n                                ap += (sfx >> 16);\n                                if (mask == 0)\n                                    continue;\n                            }\n                            break;\n                        case ALPHA_MASK_INDEX:\n                            {\n                                int i = 0;\n                                while (i < alphaData.length) {\n                                    if (index == (alphaData[i] & 0xff))\n                                        break;\n                                }\n                                if (i < alphaData.length)\n                                    continue;\n                            }\n                            break;\n                        case ALPHA_MASK_RGB:\n                            {\n                                final byte r = srcReds[index], g = srcGreens[index], b = srcBlues[index];\n                                int i = 0;\n                                while (i < alphaData.length) {\n                                    if ((r == alphaData[i]) && (g == alphaData[i + 1]) && (b == alphaData[i + 2]))\n                                        break;\n                                    i += 3;\n                                }\n                                if (i < alphaData.length)\n                                    continue;\n                            }\n                            break;\n                    }\n                    index = paletteMapping[index] & 0xff;\n                    \n                    switch(dtype) {\n                        case TYPE_INDEX_8:\n                            destData[dp] = (byte) index;\n                            break;\n                        case TYPE_INDEX_4:\n                            if ((dp & 1) != 0)\n                                destData[dp >> 1] = (byte) ((destData[dp >> 1] & 0xf0) | index);\n                            else\n                                destData[dp >> 1] = (byte) ((destData[dp >> 1] & 0x0f) | (index << 4));\n                            break;\n                        case TYPE_INDEX_2:\n                            {\n                                final int shift = 6 - (dp & 3) * 2;\n                                destData[dp >> 2] = (byte) (destData[dp >> 2] & ~(0x03 << shift) | (index << shift));\n                            }\n                            break;\n                        case TYPE_INDEX_1_MSB:\n                            {\n                                final int shift = 7 - (dp & 7);\n                                destData[dp >> 3] = (byte) (destData[dp >> 3] & ~(0x01 << shift) | (index << shift));\n                            }\n                            break;\n                        case TYPE_INDEX_1_LSB:\n                            {\n                                final int shift = dp & 7;\n                                destData[dp >> 3] = (byte) (destData[dp >> 3] & ~(0x01 << shift) | (index << shift));\n                            }\n                            break;\n                    }\n                }\n            }\n        }\n        return;\n    }\n    \n    int alpha = alphaMode;\n    int index = 0;\n    int indexq = 0;\n    int lastindex = 0, lastr = -1, lastg = -1, lastb = -1;\n    final int[] rerr, gerr, berr;\n    if (ditherEnabled) {\n        rerr = new int[destWidth + 2];\n        gerr = new int[destWidth + 2];\n        berr = new int[destWidth + 2];\n    } else {\n        rerr = null;\n        gerr = null;\n        berr = null;\n    }\n    for (int dy = destHeight, sfy = sfyi; dy > 0; --dy, sp = spr += (sfy >>> 16) * srcStride, ap = apr += (sfy >>> 16) * alphaStride, sfy = (sfy & 0xffff) + sfyi, dp = dpr += dpryi) {\n        int lrerr = 0, lgerr = 0, lberr = 0;\n        for (int dx = destWidth, sfx = sfxi; dx > 0; --dx, dp += dprxi, sfx = (sfx & 0xffff) + sfxi) {\n            \n            switch(stype) {\n                case TYPE_INDEX_8:\n                    index = srcData[sp] & 0xff;\n                    sp += (sfx >>> 16);\n                    break;\n                case TYPE_INDEX_4:\n                    if ((sp & 1) != 0)\n                        index = srcData[sp >> 1] & 0x0f;\n                    else\n                        index = (srcData[sp >> 1] >>> 4) & 0x0f;\n                    sp += (sfx >>> 16);\n                    break;\n                case TYPE_INDEX_2:\n                    index = (srcData[sp >> 2] >>> (6 - (sp & 3) * 2)) & 0x03;\n                    sp += (sfx >>> 16);\n                    break;\n                case TYPE_INDEX_1_MSB:\n                    index = (srcData[sp >> 3] >>> (7 - (sp & 7))) & 0x01;\n                    sp += (sfx >>> 16);\n                    break;\n                case TYPE_INDEX_1_LSB:\n                    index = (srcData[sp >> 3] >>> (sp & 7)) & 0x01;\n                    sp += (sfx >>> 16);\n                    break;\n            }\n            \n            int r = srcReds[index] & 0xff, g = srcGreens[index] & 0xff, b = srcBlues[index] & 0xff;\n            switch(alphaMode) {\n                case ALPHA_CHANNEL_SEPARATE:\n                    alpha = ((alphaData[ap] & 0xff) << 16) / 255;\n                    ap += (sfx >> 16);\n                    break;\n                case ALPHA_MASK_UNPACKED:\n                    alpha = (alphaData[ap] != 0) ? 0x10000 : 0;\n                    ap += (sfx >> 16);\n                    break;\n                case ALPHA_MASK_PACKED:\n                    alpha = (alphaData[ap >> 3] << ((ap & 7) + 9)) & 0x10000;\n                    ap += (sfx >> 16);\n                    break;\n                case ALPHA_MASK_INDEX:\n                    {\n                        \n                        int i = 0;\n                        while (i < alphaData.length) {\n                            if (index == (alphaData[i] & 0xff))\n                                break;\n                        }\n                        if (i < alphaData.length)\n                            continue;\n                    }\n                    break;\n                case ALPHA_MASK_RGB:\n                    {\n                        int i = 0;\n                        while (i < alphaData.length) {\n                            if ((r == (alphaData[i] & 0xff)) && (g == (alphaData[i + 1] & 0xff)) && (b == (alphaData[i + 2] & 0xff)))\n                                break;\n                            i += 3;\n                        }\n                        if (i < alphaData.length)\n                            continue;\n                    }\n                    break;\n            }\n            if (alpha != 0x10000) {\n                if (alpha == 0x0000)\n                    continue;\n                switch(dtype) {\n                    case TYPE_INDEX_8:\n                        indexq = destData[dp] & 0xff;\n                        break;\n                    case TYPE_INDEX_4:\n                        if ((dp & 1) != 0)\n                            indexq = destData[dp >> 1] & 0x0f;\n                        else\n                            indexq = (destData[dp >> 1] >>> 4) & 0x0f;\n                        break;\n                    case TYPE_INDEX_2:\n                        indexq = (destData[dp >> 2] >>> (6 - (dp & 3) * 2)) & 0x03;\n                        break;\n                    case TYPE_INDEX_1_MSB:\n                        indexq = (destData[dp >> 3] >>> (7 - (dp & 7))) & 0x01;\n                        break;\n                    case TYPE_INDEX_1_LSB:\n                        indexq = (destData[dp >> 3] >>> (dp & 7)) & 0x01;\n                        break;\n                }\n                \n                final int rq = destReds[indexq] & 0xff;\n                final int gq = destGreens[indexq] & 0xff;\n                final int bq = destBlues[indexq] & 0xff;\n                r = rq + ((r - rq) * alpha >> 16);\n                g = gq + ((g - gq) * alpha >> 16);\n                b = bq + ((b - bq) * alpha >> 16);\n            }\n            \n            if (ditherEnabled) {\n                \n                r += rerr[dx] >> 4;\n                if (r < 0)\n                    r = 0;\n                else if (r > 255)\n                    r = 255;\n                g += gerr[dx] >> 4;\n                if (g < 0)\n                    g = 0;\n                else if (g > 255)\n                    g = 255;\n                b += berr[dx] >> 4;\n                if (b < 0)\n                    b = 0;\n                else if (b > 255)\n                    b = 255;\n                rerr[dx] = lrerr;\n                gerr[dx] = lgerr;\n                berr[dx] = lberr;\n            }\n            if (r != lastr || g != lastg || b != lastb) {\n                \n                for (int j = 0, dr, dg, db, distance, minDistance = 0x7fffffff; j < destPaletteSize; ++j) {\n                    dr = (destReds[j] & 0xff) - r;\n                    dg = (destGreens[j] & 0xff) - g;\n                    db = (destBlues[j] & 0xff) - b;\n                    distance = dr * dr + dg * dg + db * db;\n                    if (distance < minDistance) {\n                        lastindex = j;\n                        if (distance == 0)\n                            break;\n                        minDistance = distance;\n                    }\n                }\n                lastr = r;\n                lastg = g;\n                lastb = b;\n            }\n            if (ditherEnabled) {\n                \n                final int dxm1 = dx - 1, dxp1 = dx + 1;\n                int acc;\n                rerr[dxp1] += acc = (lrerr = r - (destReds[lastindex] & 0xff)) + lrerr + lrerr;\n                rerr[dx] += acc += lrerr + lrerr;\n                rerr[dxm1] += acc + lrerr + lrerr;\n                gerr[dxp1] += acc = (lgerr = g - (destGreens[lastindex] & 0xff)) + lgerr + lgerr;\n                gerr[dx] += acc += lgerr + lgerr;\n                gerr[dxm1] += acc + lgerr + lgerr;\n                berr[dxp1] += acc = (lberr = b - (destBlues[lastindex] & 0xff)) + lberr + lberr;\n                berr[dx] += acc += lberr + lberr;\n                berr[dxm1] += acc + lberr + lberr;\n            }\n            \n            switch(dtype) {\n                case TYPE_INDEX_8:\n                    destData[dp] = (byte) lastindex;\n                    break;\n                case TYPE_INDEX_4:\n                    if ((dp & 1) != 0)\n                        destData[dp >> 1] = (byte) ((destData[dp >> 1] & 0xf0) | lastindex);\n                    else\n                        destData[dp >> 1] = (byte) ((destData[dp >> 1] & 0x0f) | (lastindex << 4));\n                    break;\n                case TYPE_INDEX_2:\n                    {\n                        final int shift = 6 - (dp & 3) * 2;\n                        destData[dp >> 2] = (byte) (destData[dp >> 2] & ~(0x03 << shift) | (lastindex << shift));\n                    }\n                    break;\n                case TYPE_INDEX_1_MSB:\n                    {\n                        final int shift = 7 - (dp & 7);\n                        destData[dp >> 3] = (byte) (destData[dp >> 3] & ~(0x01 << shift) | (lastindex << shift));\n                    }\n                    break;\n                case TYPE_INDEX_1_LSB:\n                    {\n                        final int shift = dp & 7;\n                        destData[dp >> 3] = (byte) (destData[dp >> 3] & ~(0x01 << shift) | (lastindex << shift));\n                    }\n                    break;\n            }\n        }\n    }\n}",
			"comments":"/**\n* Blits an index palette image into an index palette image.\n* <p>\n* Note: The source and destination red, green, and blue\n* arrays may be null if no alpha blending or dither is to be\n* performed.\n* </p>\n*\n* @param op the blitter operation: a combination of BLIT_xxx flags\n*        (see BLIT_xxx constants)\n* @param srcData the source byte array containing image data\n* @param srcDepth the source depth: one of 1, 2, 4, 8\n* @param srcStride the source number of bytes per line\n* @param srcOrder the source byte ordering: one of MSB_FIRST or LSB_FIRST;\n*        ignored if srcDepth is not 1\n* @param srcX the top-left x-coord of the source blit region\n* @param srcY the top-left y-coord of the source blit region\n* @param srcWidth the width of the source blit region\n* @param srcHeight the height of the source blit region\n* @param srcReds the source palette red component intensities\n* @param srcGreens the source palette green component intensities\n* @param srcBlues the source palette blue component intensities\n* @param alphaMode the alpha blending or mask mode, may be\n*        an integer 0-255 for global alpha; ignored if BLIT_ALPHA\n*        not specified in the blitter operations\n*        (see ALPHA_MODE_xxx constants)\n* @param alphaData the alpha blending or mask data, varies depending\n*        on the value of alphaMode and sometimes ignored\n* @param alphaStride the alpha data number of bytes per line\n* @param alphaX the top-left x-coord of the alpha blit region\n* @param alphaY the top-left y-coord of the alpha blit region\n* @param destData the destination byte array containing image data\n* @param destDepth the destination depth: one of 1, 2, 4, 8\n* @param destStride the destination number of bytes per line\n* @param destOrder the destination byte ordering: one of MSB_FIRST or LSB_FIRST;\n*        ignored if destDepth is not 1\n* @param destX the top-left x-coord of the destination blit region\n* @param destY the top-left y-coord of the destination blit region\n* @param destWidth the width of the destination blit region\n* @param destHeight the height of the destination blit region\n* @param destReds the destination palette red component intensities\n* @param destGreens the destination palette green component intensities\n* @param destBlues the destination palette blue component intensities\n* @param flipX if true the resulting image is flipped along the vertical axis\n* @param flipY if true the resulting image is flipped along the horizontal axis\n*/\n/*** Prepare scaling data ***/\n/*** Prepare source-related data ***/\n//throw new IllegalArgumentException(\"Invalid source type\");\n/*** Prepare destination-related data ***/\n//throw new IllegalArgumentException(\"Invalid source type\");\n/*** Prepare special processing data ***/\n// prescale\n/*** Blit ***/\n/*** If the palettes and formats are equivalent use a one-to-one mapping ***/\n/*** If palettes have not been supplied, supply a suitable mapping ***/\n/*** Generate a palette mapping ***/\n/*** Fast blit (copy w/ mapping) ***/\n/*** Convert between indexed modes using mapping and mask ***/\n/*** READ NEXT PIXEL ***/\n/*** APPLY MASK ***/\n/*** WRITE NEXT PIXEL ***/\n/*** Comprehensive blit (apply transformations) ***/\n/*** READ NEXT PIXEL ***/\n/*** DO SPECIAL PROCESSING IF REQUIRED ***/\n// could speed up using binary search if we sorted the indices\n// Perform alpha blending\n/*** MAP COLOR TO THE PALETTE ***/\n// Floyd-Steinberg error diffusion\n// moving the variable declarations out seems to make the JDK JIT happier...\n// Floyd-Steinberg error diffusion, cont'd...\n/*** WRITE NEXT PIXEL ***/\n",
			"methodName":"static void blit(int op, byte[] srcData, int srcDepth, int srcStride, int srcOrder, int srcX, int srcY, int srcWidth, int srcHeight, byte[] srcReds, byte[] srcGreens, byte[] srcBlues, int alphaMode, byte[] alphaData, int alphaStride, int alphaX, int alphaY, byte[] destData, int destDepth, int destStride, int destOrder, int destX, int destY, int destWidth, int destHeight, byte[] destReds, byte[] destGreens, byte[] destBlues, boolean flipX, boolean flipY)"
		},
		"ImageData colorMaskImage(int pixel)":{
			"methodBody":"{\n    ImageData mask = new ImageData(width, height, 1, bwPalette(), 2, null, 0, null, null, -1, -1, SWT.IMAGE_UNDEFINED, 0, 0, 0, 0);\n    int[] row = new int[width];\n    for (int y = 0; y < height; y++) {\n        getPixels(0, y, width, row, 0);\n        for (int i = 0; i < width; i++) {\n            if (pixel != -1 && row[i] == pixel) {\n                row[i] = 0;\n            } else {\n                row[i] = 1;\n            }\n        }\n        mask.setPixels(0, y, width, row, 0);\n    }\n    return mask;\n}",
			"comments":"",
			"methodName":"ImageData colorMaskImage(int pixel)"
		},
		"public void setPixel(int x, int y, int pixelValue)":{
			"methodBody":"{\n    if (x >= width || y >= height || x < 0 || y < 0)\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    int index;\n    byte theByte;\n    int mask;\n    if (depth == 1) {\n        index = (y * bytesPerLine) + (x >> 3);\n        theByte = data[index];\n        mask = 1 << (7 - (x & 0x7));\n        if ((pixelValue & 0x1) == 1) {\n            data[index] = (byte) (theByte | mask);\n        } else {\n            data[index] = (byte) (theByte & (mask ^ -1));\n        }\n        return;\n    }\n    if (depth == 2) {\n        index = (y * bytesPerLine) + (x >> 2);\n        theByte = data[index];\n        int offset = 3 - (x % 4);\n        mask = 0xFF ^ (3 << (offset * 2));\n        data[index] = (byte) ((data[index] & mask) | (pixelValue << (offset * 2)));\n        return;\n    }\n    if (depth == 4) {\n        index = (y * bytesPerLine) + (x >> 1);\n        if ((x & 0x1) == 0) {\n            data[index] = (byte) ((data[index] & 0x0F) | ((pixelValue & 0x0F) << 4));\n        } else {\n            data[index] = (byte) ((data[index] & 0xF0) | (pixelValue & 0x0F));\n        }\n        return;\n    }\n    if (depth == 8) {\n        index = (y * bytesPerLine) + x;\n        data[index] = (byte) (pixelValue & 0xFF);\n        return;\n    }\n    if (depth == 16) {\n        index = (y * bytesPerLine) + (x * 2);\n        data[index + 1] = (byte) ((pixelValue >> 8) & 0xFF);\n        data[index] = (byte) (pixelValue & 0xFF);\n        return;\n    }\n    if (depth == 24) {\n        index = (y * bytesPerLine) + (x * 3);\n        data[index] = (byte) ((pixelValue >> 16) & 0xFF);\n        data[index + 1] = (byte) ((pixelValue >> 8) & 0xFF);\n        data[index + 2] = (byte) (pixelValue & 0xFF);\n        return;\n    }\n    if (depth == 32) {\n        index = (y * bytesPerLine) + (x * 4);\n        data[index] = (byte) ((pixelValue >> 24) & 0xFF);\n        data[index + 1] = (byte) ((pixelValue >> 16) & 0xFF);\n        data[index + 2] = (byte) ((pixelValue >> 8) & 0xFF);\n        data[index + 3] = (byte) (pixelValue & 0xFF);\n        return;\n    }\n    SWT.error(SWT.ERROR_UNSUPPORTED_DEPTH);\n}",
			"comments":"/**\n* Sets the pixel value at offset <code>x</code> in\n* scanline <code>y</code> in the receiver's data.\n*\n* @param x the x coordinate of the pixel to set\n* @param y the y coordinate of the pixel to set\n* @param pixelValue the value to set the pixel to\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if x or y is out of bounds</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_UNSUPPORTED_DEPTH if the depth is not one of 1, 2, 4, 8, 16, 24 or 32</li>\n* </ul>\n*/\n",
			"methodName":"public void setPixel(int x, int y, int pixelValue)"
		},
		"public void getPixels(int x, int y, int getWidth, int[] pixels, int startIndex)":{
			"methodBody":"{\n    if (pixels == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (getWidth < 0 || x >= width || y >= height || x < 0 || y < 0)\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    if (getWidth == 0)\n        return;\n    int index;\n    int theByte;\n    int mask;\n    int n = getWidth;\n    int i = startIndex;\n    int srcX = x, srcY = y;\n    if (depth == 1) {\n        index = (y * bytesPerLine) + (x >> 3);\n        theByte = data[index] & 0xFF;\n        while (n > 0) {\n            mask = 1 << (7 - (srcX & 0x7));\n            if ((theByte & mask) == 0) {\n                pixels[i] = 0;\n            } else {\n                pixels[i] = 1;\n            }\n            i++;\n            n--;\n            srcX++;\n            if (srcX >= width) {\n                srcY++;\n                index = srcY * bytesPerLine;\n                if (n > 0)\n                    theByte = data[index] & 0xFF;\n                srcX = 0;\n            } else {\n                if (mask == 1) {\n                    index++;\n                    if (n > 0)\n                        theByte = data[index] & 0xFF;\n                }\n            }\n        }\n        return;\n    }\n    if (depth == 2) {\n        index = (y * bytesPerLine) + (x >> 2);\n        theByte = data[index] & 0xFF;\n        int offset;\n        while (n > 0) {\n            offset = 3 - (srcX % 4);\n            mask = 3 << (offset * 2);\n            pixels[i] = (byte) ((theByte & mask) >> (offset * 2));\n            i++;\n            n--;\n            srcX++;\n            if (srcX >= width) {\n                srcY++;\n                index = srcY * bytesPerLine;\n                if (n > 0)\n                    theByte = data[index] & 0xFF;\n                srcX = 0;\n            } else {\n                if (offset == 0) {\n                    index++;\n                    theByte = data[index] & 0xFF;\n                }\n            }\n        }\n        return;\n    }\n    if (depth == 4) {\n        index = (y * bytesPerLine) + (x >> 1);\n        if ((x & 0x1) == 1) {\n            theByte = data[index] & 0xFF;\n            pixels[i] = theByte & 0x0F;\n            i++;\n            n--;\n            srcX++;\n            if (srcX >= width) {\n                srcY++;\n                index = srcY * bytesPerLine;\n                srcX = 0;\n            } else {\n                index++;\n            }\n        }\n        while (n > 1) {\n            theByte = data[index] & 0xFF;\n            pixels[i] = theByte >> 4;\n            i++;\n            n--;\n            srcX++;\n            if (srcX >= width) {\n                srcY++;\n                index = srcY * bytesPerLine;\n                srcX = 0;\n            } else {\n                pixels[i] = theByte & 0x0F;\n                i++;\n                n--;\n                srcX++;\n                if (srcX >= width) {\n                    srcY++;\n                    index = srcY * bytesPerLine;\n                    srcX = 0;\n                } else {\n                    index++;\n                }\n            }\n        }\n        if (n > 0) {\n            theByte = data[index] & 0xFF;\n            pixels[i] = theByte >> 4;\n        }\n        return;\n    }\n    if (depth == 8) {\n        index = (y * bytesPerLine) + x;\n        for (int j = 0; j < getWidth; j++) {\n            pixels[i] = data[index] & 0xFF;\n            i++;\n            srcX++;\n            if (srcX >= width) {\n                srcY++;\n                index = srcY * bytesPerLine;\n                srcX = 0;\n            } else {\n                index++;\n            }\n        }\n        return;\n    }\n    if (depth == 16) {\n        index = (y * bytesPerLine) + (x * 2);\n        for (int j = 0; j < getWidth; j++) {\n            pixels[i] = ((data[index + 1] & 0xFF) << 8) + (data[index] & 0xFF);\n            i++;\n            srcX++;\n            if (srcX >= width) {\n                srcY++;\n                index = srcY * bytesPerLine;\n                srcX = 0;\n            } else {\n                index += 2;\n            }\n        }\n        return;\n    }\n    if (depth == 24) {\n        index = (y * bytesPerLine) + (x * 3);\n        for (int j = 0; j < getWidth; j++) {\n            pixels[i] = ((data[index] & 0xFF) << 16) | ((data[index + 1] & 0xFF) << 8) | (data[index + 2] & 0xFF);\n            i++;\n            srcX++;\n            if (srcX >= width) {\n                srcY++;\n                index = srcY * bytesPerLine;\n                srcX = 0;\n            } else {\n                index += 3;\n            }\n        }\n        return;\n    }\n    if (depth == 32) {\n        index = (y * bytesPerLine) + (x * 4);\n        i = startIndex;\n        for (int j = 0; j < getWidth; j++) {\n            pixels[i] = ((data[index] & 0xFF) << 24) | ((data[index + 1] & 0xFF) << 16) | ((data[index + 2] & 0xFF) << 8) | (data[index + 3] & 0xFF);\n            i++;\n            srcX++;\n            if (srcX >= width) {\n                srcY++;\n                index = srcY * bytesPerLine;\n                srcX = 0;\n            } else {\n                index += 4;\n            }\n        }\n        return;\n    }\n    SWT.error(SWT.ERROR_UNSUPPORTED_DEPTH);\n}",
			"comments":"/**\n* Returns <code>getWidth</code> pixel values starting at offset\n* <code>x</code> in scanline <code>y</code> in the receiver's\n* data starting at <code>startIndex</code>.\n*\n* @param x the x position of the first pixel to get\n* @param y the y position of the first pixel to get\n* @param getWidth the width of the data to get\n* @param pixels the buffer in which to put the pixels\n* @param startIndex the offset into the buffer to begin storing pixels\n*\n* @exception IndexOutOfBoundsException if getWidth is too large\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if pixels is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if x or y is out of bounds</li>\n*    <li>ERROR_INVALID_ARGUMENT - if getWidth is negative</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_UNSUPPORTED_DEPTH - if the depth is not one of 1, 2, 4, 8, 16, 24 or 32</li>\n* </ul>\n*/\n",
			"methodName":"public void getPixels(int x, int y, int getWidth, int[] pixels, int startIndex)"
		},
		"public void setPixels(int x, int y, int putWidth, int[] pixels, int startIndex)":{
			"methodBody":"{\n    if (pixels == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (putWidth < 0 || x >= width || y >= height || x < 0 || y < 0)\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    if (putWidth == 0)\n        return;\n    int index;\n    int theByte;\n    int mask;\n    int n = putWidth;\n    int i = startIndex;\n    int pixel;\n    int srcX = x, srcY = y;\n    if (depth == 1) {\n        index = (y * bytesPerLine) + (x >> 3);\n        while (n > 0) {\n            mask = 1 << (7 - (srcX & 0x7));\n            if ((pixels[i] & 0x1) == 1) {\n                data[index] = (byte) ((data[index] & 0xFF) | mask);\n            } else {\n                data[index] = (byte) ((data[index] & 0xFF) & (mask ^ -1));\n            }\n            i++;\n            n--;\n            srcX++;\n            if (srcX >= width) {\n                srcY++;\n                index = srcY * bytesPerLine;\n                srcX = 0;\n            } else {\n                if (mask == 1) {\n                    index++;\n                }\n            }\n        }\n        return;\n    }\n    if (depth == 2) {\n        byte[] masks = { (byte) 0xFC, (byte) 0xF3, (byte) 0xCF, (byte) 0x3F };\n        index = (y * bytesPerLine) + (x >> 2);\n        int offset = 3 - (x % 4);\n        while (n > 0) {\n            theByte = pixels[i] & 0x3;\n            data[index] = (byte) ((data[index] & masks[offset]) | (theByte << (offset * 2)));\n            i++;\n            n--;\n            srcX++;\n            if (srcX >= width) {\n                srcY++;\n                index = srcY * bytesPerLine;\n                offset = 3;\n                srcX = 0;\n            } else {\n                if (offset == 0) {\n                    index++;\n                    offset = 3;\n                } else {\n                    offset--;\n                }\n            }\n        }\n        return;\n    }\n    if (depth == 4) {\n        index = (y * bytesPerLine) + (x >> 1);\n        boolean high = (x & 0x1) == 0;\n        while (n > 0) {\n            theByte = pixels[i] & 0x0F;\n            if (high) {\n                data[index] = (byte) ((data[index] & 0x0F) | (theByte << 4));\n            } else {\n                data[index] = (byte) ((data[index] & 0xF0) | theByte);\n            }\n            i++;\n            n--;\n            srcX++;\n            if (srcX >= width) {\n                srcY++;\n                index = srcY * bytesPerLine;\n                high = true;\n                srcX = 0;\n            } else {\n                if (!high)\n                    index++;\n                high = !high;\n            }\n        }\n        return;\n    }\n    if (depth == 8) {\n        index = (y * bytesPerLine) + x;\n        for (int j = 0; j < putWidth; j++) {\n            data[index] = (byte) (pixels[i] & 0xFF);\n            i++;\n            srcX++;\n            if (srcX >= width) {\n                srcY++;\n                index = srcY * bytesPerLine;\n                srcX = 0;\n            } else {\n                index++;\n            }\n        }\n        return;\n    }\n    if (depth == 16) {\n        index = (y * bytesPerLine) + (x * 2);\n        for (int j = 0; j < putWidth; j++) {\n            pixel = pixels[i];\n            data[index] = (byte) (pixel & 0xFF);\n            data[index + 1] = (byte) ((pixel >> 8) & 0xFF);\n            i++;\n            srcX++;\n            if (srcX >= width) {\n                srcY++;\n                index = srcY * bytesPerLine;\n                srcX = 0;\n            } else {\n                index += 2;\n            }\n        }\n        return;\n    }\n    if (depth == 24) {\n        index = (y * bytesPerLine) + (x * 3);\n        for (int j = 0; j < putWidth; j++) {\n            pixel = pixels[i];\n            data[index] = (byte) ((pixel >> 16) & 0xFF);\n            data[index + 1] = (byte) ((pixel >> 8) & 0xFF);\n            data[index + 2] = (byte) (pixel & 0xFF);\n            i++;\n            srcX++;\n            if (srcX >= width) {\n                srcY++;\n                index = srcY * bytesPerLine;\n                srcX = 0;\n            } else {\n                index += 3;\n            }\n        }\n        return;\n    }\n    if (depth == 32) {\n        index = (y * bytesPerLine) + (x * 4);\n        for (int j = 0; j < putWidth; j++) {\n            pixel = pixels[i];\n            data[index] = (byte) ((pixel >> 24) & 0xFF);\n            data[index + 1] = (byte) ((pixel >> 16) & 0xFF);\n            data[index + 2] = (byte) ((pixel >> 8) & 0xFF);\n            data[index + 3] = (byte) (pixel & 0xFF);\n            i++;\n            srcX++;\n            if (srcX >= width) {\n                srcY++;\n                index = srcY * bytesPerLine;\n                srcX = 0;\n            } else {\n                index += 4;\n            }\n        }\n        return;\n    }\n    SWT.error(SWT.ERROR_UNSUPPORTED_DEPTH);\n}",
			"comments":"/**\n* Sets the pixel values starting at offset <code>x</code> in\n* scanline <code>y</code> in the receiver's data to the\n* values from the array <code>pixels</code> starting at\n* <code>startIndex</code>.\n*\n* @param x the x position of the pixel to set\n* @param y the y position of the pixel to set\n* @param putWidth the width of the pixels to set\n* @param pixels the pixels to set\n* @param startIndex the index at which to begin setting\n*\n* @exception IndexOutOfBoundsException if putWidth is too large\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if pixels is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if x or y is out of bounds</li>\n*    <li>ERROR_INVALID_ARGUMENT - if putWidth is negative</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_UNSUPPORTED_DEPTH if the depth is not one of 1, 2, 4, 8, 16, 24 or 32</li>\n* </ul>\n*/\n",
			"methodName":"public void setPixels(int x, int y, int putWidth, int[] pixels, int startIndex)"
		},
		"public static ImageData internal_new(int width, int height, int depth, PaletteData palette, int scanlinePad, byte[] data, int maskPad, byte[] maskData, byte[] alphaData, int alpha, int transparentPixel, int type, int x, int y, int disposalMethod, int delayTime)":{
			"methodBody":"{\n    return new ImageData(width, height, depth, palette, scanlinePad, data, maskPad, maskData, alphaData, alpha, transparentPixel, type, x, y, disposalMethod, delayTime);\n}",
			"comments":"/**\n* Invokes internal SWT functionality to create a new instance of\n* this class.\n* <p>\n* <b>IMPORTANT:</b> This method is <em>not</em> part of the public\n* API for <code>ImageData</code>. It is marked public only so that it\n* can be shared within the packages provided by SWT. It is subject\n* to change without notice, and should never be called from\n* application code.\n* </p>\n* <p>\n* This method is for internal use, and is not described further.\n* </p>\n*/\n",
			"methodName":"public static ImageData internal_new(int width, int height, int depth, PaletteData palette, int scanlinePad, byte[] data, int maskPad, byte[] maskData, byte[] alphaData, int alpha, int transparentPixel, int type, int x, int y, int disposalMethod, int delayTime)"
		},
		"public void getPixels(int x, int y, int getWidth, byte[] pixels, int startIndex)":{
			"methodBody":"{\n    if (pixels == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (getWidth < 0 || x >= width || y >= height || x < 0 || y < 0)\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    if (getWidth == 0)\n        return;\n    int index;\n    int theByte;\n    int mask = 0;\n    int n = getWidth;\n    int i = startIndex;\n    int srcX = x, srcY = y;\n    if (depth == 1) {\n        index = (y * bytesPerLine) + (x >> 3);\n        theByte = data[index] & 0xFF;\n        while (n > 0) {\n            mask = 1 << (7 - (srcX & 0x7));\n            if ((theByte & mask) == 0) {\n                pixels[i] = 0;\n            } else {\n                pixels[i] = 1;\n            }\n            i++;\n            n--;\n            srcX++;\n            if (srcX >= width) {\n                srcY++;\n                index = srcY * bytesPerLine;\n                if (n > 0)\n                    theByte = data[index] & 0xFF;\n                srcX = 0;\n            } else {\n                if (mask == 1) {\n                    index++;\n                    if (n > 0)\n                        theByte = data[index] & 0xFF;\n                }\n            }\n        }\n        return;\n    }\n    if (depth == 2) {\n        index = (y * bytesPerLine) + (x >> 2);\n        theByte = data[index] & 0xFF;\n        int offset;\n        while (n > 0) {\n            offset = 3 - (srcX % 4);\n            mask = 3 << (offset * 2);\n            pixels[i] = (byte) ((theByte & mask) >> (offset * 2));\n            i++;\n            n--;\n            srcX++;\n            if (srcX >= width) {\n                srcY++;\n                index = srcY * bytesPerLine;\n                if (n > 0)\n                    theByte = data[index] & 0xFF;\n                srcX = 0;\n            } else {\n                if (offset == 0) {\n                    index++;\n                    theByte = data[index] & 0xFF;\n                }\n            }\n        }\n        return;\n    }\n    if (depth == 4) {\n        index = (y * bytesPerLine) + (x >> 1);\n        if ((x & 0x1) == 1) {\n            theByte = data[index] & 0xFF;\n            pixels[i] = (byte) (theByte & 0x0F);\n            i++;\n            n--;\n            srcX++;\n            if (srcX >= width) {\n                srcY++;\n                index = srcY * bytesPerLine;\n                srcX = 0;\n            } else {\n                index++;\n            }\n        }\n        while (n > 1) {\n            theByte = data[index] & 0xFF;\n            pixels[i] = (byte) (theByte >> 4);\n            i++;\n            n--;\n            srcX++;\n            if (srcX >= width) {\n                srcY++;\n                index = srcY * bytesPerLine;\n                srcX = 0;\n            } else {\n                pixels[i] = (byte) (theByte & 0x0F);\n                i++;\n                n--;\n                srcX++;\n                if (srcX >= width) {\n                    srcY++;\n                    index = srcY * bytesPerLine;\n                    srcX = 0;\n                } else {\n                    index++;\n                }\n            }\n        }\n        if (n > 0) {\n            theByte = data[index] & 0xFF;\n            pixels[i] = (byte) (theByte >> 4);\n        }\n        return;\n    }\n    if (depth == 8) {\n        index = (y * bytesPerLine) + x;\n        for (int j = 0; j < getWidth; j++) {\n            pixels[i] = data[index];\n            i++;\n            srcX++;\n            if (srcX >= width) {\n                srcY++;\n                index = srcY * bytesPerLine;\n                srcX = 0;\n            } else {\n                index++;\n            }\n        }\n        return;\n    }\n    SWT.error(SWT.ERROR_UNSUPPORTED_DEPTH);\n}",
			"comments":"/**\n* Returns <code>getWidth</code> pixel values starting at offset\n* <code>x</code> in scanline <code>y</code> in the receiver's\n* data starting at <code>startIndex</code>.\n*\n* @param x the x position of the first pixel to get\n* @param y the y position of the first pixel to get\n* @param getWidth the width of the data to get\n* @param pixels the buffer in which to put the pixels\n* @param startIndex the offset into the byte array to begin storing pixels\n*\n* @exception IndexOutOfBoundsException if getWidth is too large\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if pixels is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if x or y is out of bounds</li>\n*    <li>ERROR_INVALID_ARGUMENT - if getWidth is negative</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_UNSUPPORTED_DEPTH - if the depth is not one of 1, 2, 4 or 8\n*        (For higher depths, use the int[] version of this method.)</li>\n* </ul>\n*/\n",
			"methodName":"public void getPixels(int x, int y, int getWidth, byte[] pixels, int startIndex)"
		},
		"static final void buildPreciseGradientChannel(int from, int to, int steps, int bandWidth, int bandHeight, boolean vertical, byte[] bitmapData, int dp, int bytesPerLine)":{
			"methodBody":"{\n    int val = from << 16;\n    final int inc = ((to << 16) - val) / steps + 1;\n    if (vertical) {\n        for (int dy = 0; dy < bandHeight; ++dy, dp += bytesPerLine) {\n            bitmapData[dp] = (byte) (val >>> 16);\n            val += inc;\n        }\n    } else {\n        for (int dx = 0; dx < bandWidth; ++dx, dp += 4) {\n            bitmapData[dp] = (byte) (val >>> 16);\n            val += inc;\n        }\n    }\n}",
			"comments":"/*\n* Fill in gradated values for a color channel\n*/\n",
			"methodName":"static final void buildPreciseGradientChannel(int from, int to, int steps, int bandWidth, int bandHeight, boolean vertical, byte[] bitmapData, int dp, int bytesPerLine)"
		},
		"public void getAlphas(int x, int y, int getWidth, byte[] alphas, int startIndex)":{
			"methodBody":"{\n    if (alphas == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (getWidth < 0 || x >= width || y >= height || x < 0 || y < 0)\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    if (getWidth == 0)\n        return;\n    if (alphaData == null) {\n        int endIndex = startIndex + getWidth;\n        for (int i = startIndex; i < endIndex; i++) {\n            alphas[i] = (byte) 255;\n        }\n        return;\n    }\n    \n    System.arraycopy(alphaData, y * width + x, alphas, startIndex, getWidth);\n}",
			"comments":"/**\n* Returns <code>getWidth</code> alpha values starting at offset\n* <code>x</code> in scanline <code>y</code> in the receiver's alpha\n* data starting at <code>startIndex</code>.\n*\n* @param x the x position of the pixel to begin getting alpha values\n* @param y the y position of the pixel to begin getting alpha values\n* @param getWidth the width of the data to get\n* @param alphas the buffer in which to put the alpha values\n* @param startIndex the offset into the image to begin getting alpha values\n*\n* @exception IndexOutOfBoundsException if getWidth is too large\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if pixels is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if x or y is out of bounds</li>\n*    <li>ERROR_INVALID_ARGUMENT - if getWidth is negative</li>\n* </ul>\n*/\n// may throw an IndexOutOfBoundsException\n",
			"methodName":"public void getAlphas(int x, int y, int getWidth, byte[] alphas, int startIndex)"
		},
		"public void setAlpha(int x, int y, int alpha)":{
			"methodBody":"{\n    if (x >= width || y >= height || x < 0 || y < 0 || alpha < 0 || alpha > 255)\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    if (alphaData == null)\n        alphaData = new byte[width * height];\n    alphaData[y * width + x] = (byte) alpha;\n}",
			"comments":"/**\n* Sets the alpha value at offset <code>x</code> in\n* scanline <code>y</code> in the receiver's alpha data.\n*\n* @param x the x coordinate of the alpha value to set\n* @param y the y coordinate of the alpha value to set\n* @param alpha the value to set the alpha to\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if x or y is out of bounds</li>\n*  </ul>\n*/\n",
			"methodName":"public void setAlpha(int x, int y, int alpha)"
		},
		"static int getChannelWidth(int mask, int shift)":{
			"methodBody":"{\n    if (mask == 0)\n        return 0;\n    int i;\n    mask >>>= shift;\n    for (i = shift; ((mask & 1) != 0) && (i < 32); ++i) {\n        mask >>>= 1;\n    }\n    return i - shift;\n}",
			"comments":"/**\n* Computes the required channel width (depth) from a mask.\n*/\n",
			"methodName":"static int getChannelWidth(int mask, int shift)"
		},
		"static final byte[] convertPad(byte[] data, int width, int height, int depth, int pad, int newPad)":{
			"methodBody":"{\n    if (pad == newPad)\n        return data;\n    int stride = (width * depth + 7) / 8;\n    int bpl = (stride + (pad - 1)) / pad * pad;\n    int newBpl = (stride + (newPad - 1)) / newPad * newPad;\n    byte[] newData = new byte[height * newBpl];\n    int srcIndex = 0, destIndex = 0;\n    for (int y = 0; y < height; y++) {\n        System.arraycopy(data, srcIndex, newData, destIndex, stride);\n        srcIndex += bpl;\n        destIndex += newBpl;\n    }\n    return newData;\n}",
			"comments":"",
			"methodName":"static final byte[] convertPad(byte[] data, int width, int height, int depth, int pad, int newPad)"
		},
		"static void fillGradientRectangle(GC gc, Device device, int x, int y, int width, int height, boolean vertical, RGB fromRGB, RGB toRGB, int redBits, int greenBits, int blueBits)":{
			"methodBody":"{\n    \n    ImageData band = createGradientBand(width, height, vertical, fromRGB, toRGB, redBits, greenBits, blueBits);\n    Image image = new Image(device, band);\n    if ((band.width == 1) || (band.height == 1)) {\n        gc.drawImage(image, 0, 0, band.width, band.height, x, y, width, height);\n    } else {\n        if (vertical) {\n            for (int dx = 0; dx < width; dx += band.width) {\n                int blitWidth = width - dx;\n                if (blitWidth > band.width)\n                    blitWidth = band.width;\n                gc.drawImage(image, 0, 0, blitWidth, band.height, dx + x, y, blitWidth, band.height);\n            }\n        } else {\n            for (int dy = 0; dy < height; dy += band.height) {\n                int blitHeight = height - dy;\n                if (blitHeight > band.height)\n                    blitHeight = band.height;\n                gc.drawImage(image, 0, 0, band.width, blitHeight, x, dy + y, band.width, blitHeight);\n            }\n        }\n    }\n    image.dispose();\n}",
			"comments":"/**\n* Renders a gradient onto a GC.\n* <p>\n* This is a GC helper.\n* </p>\n*\n* @param gc the GC to render the gradient onto\n* @param device the device the GC belongs to\n* @param x the top-left x coordinate of the region to be filled\n* @param y the top-left y coordinate of the region to be filled\n* @param width the width of the region to be filled\n* @param height the height of the region to be filled\n* @param vertical if true sweeps from top to bottom, else\n*        sweeps from left to right\n* @param fromRGB the color to start with\n* @param toRGB the color to end with\n* @param redBits the number of significant red bits, 0 for palette modes\n* @param greenBits the number of significant green bits, 0 for palette modes\n* @param blueBits the number of significant blue bits, 0 for palette modes\n*/\n/* Create the bitmap and tile it */\n",
			"methodName":"static void fillGradientRectangle(GC gc, Device device, int x, int y, int width, int height, boolean vertical, RGB fromRGB, RGB toRGB, int redBits, int greenBits, int blueBits)"
		},
		"static byte getChannelField(int data, int mask)":{
			"methodBody":"{\n    final int shift = getChannelShift(mask);\n    return ANY_TO_EIGHT[getChannelWidth(mask, shift)][(data & mask) >>> shift];\n}",
			"comments":"/**\n* Extracts a field from packed RGB data given a mask for that field.\n*/\n",
			"methodName":"static byte getChannelField(int data, int mask)"
		},
		"public int getPixel(int x, int y)":{
			"methodBody":"{\n    if (x >= width || y >= height || x < 0 || y < 0)\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    int index;\n    int theByte;\n    int mask;\n    if (depth == 1) {\n        index = (y * bytesPerLine) + (x >> 3);\n        theByte = data[index] & 0xFF;\n        mask = 1 << (7 - (x & 0x7));\n        if ((theByte & mask) == 0) {\n            return 0;\n        } else {\n            return 1;\n        }\n    }\n    if (depth == 2) {\n        index = (y * bytesPerLine) + (x >> 2);\n        theByte = data[index] & 0xFF;\n        int offset = 3 - (x % 4);\n        mask = 3 << (offset * 2);\n        return (theByte & mask) >> (offset * 2);\n    }\n    if (depth == 4) {\n        index = (y * bytesPerLine) + (x >> 1);\n        theByte = data[index] & 0xFF;\n        if ((x & 0x1) == 0) {\n            return theByte >> 4;\n        } else {\n            return theByte & 0x0F;\n        }\n    }\n    if (depth == 8) {\n        index = (y * bytesPerLine) + x;\n        return data[index] & 0xFF;\n    }\n    if (depth == 16) {\n        index = (y * bytesPerLine) + (x * 2);\n        return ((data[index + 1] & 0xFF) << 8) + (data[index] & 0xFF);\n    }\n    if (depth == 24) {\n        index = (y * bytesPerLine) + (x * 3);\n        return ((data[index] & 0xFF) << 16) + ((data[index + 1] & 0xFF) << 8) + (data[index + 2] & 0xFF);\n    }\n    if (depth == 32) {\n        index = (y * bytesPerLine) + (x * 4);\n        return ((data[index] & 0xFF) << 24) + ((data[index + 1] & 0xFF) << 16) + ((data[index + 2] & 0xFF) << 8) + (data[index + 3] & 0xFF);\n    }\n    SWT.error(SWT.ERROR_UNSUPPORTED_DEPTH);\n    return 0;\n}",
			"comments":"/**\n* Returns the pixel value at offset <code>x</code> in\n* scanline <code>y</code> in the receiver's data.\n*\n* @param x the x position of the pixel to get\n* @param y the y position of the pixel to get\n* @return the pixel at the given coordinates\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if either argument is out of bounds</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_UNSUPPORTED_DEPTH if the depth is not one of 1, 2, 4, 8, 16, 24 or 32</li>\n* </ul>\n*/\n",
			"methodName":"public int getPixel(int x, int y)"
		},
		"static PaletteData bwPalette()":{
			"methodBody":"{\n    return new PaletteData(new RGB[] { new RGB(0, 0, 0), new RGB(255, 255, 255) });\n}",
			"comments":"/**\n* Returns a palette with 2 colors: black & white.\n*/\n",
			"methodName":"static PaletteData bwPalette()"
		},
		"public int getAlpha(int x, int y)":{
			"methodBody":"{\n    if (x >= width || y >= height || x < 0 || y < 0)\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    if (alphaData == null)\n        return 255;\n    return alphaData[y * width + x] & 0xFF;\n}",
			"comments":"/**\n* Returns the alpha value at offset <code>x</code> in\n* scanline <code>y</code> in the receiver's alpha data.\n*\n* @param x the x coodinate of the pixel to get the alpha value of\n* @param y the y coordinate of the pixel to get the alpha value of\n* @return the alpha value at the given coordinates\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if either argument is out of range</li>\n* </ul>\n*/\n",
			"methodName":"public int getAlpha(int x, int y)"
		},
		"static int getChannelShift(int mask)":{
			"methodBody":"{\n    if (mask == 0)\n        return 0;\n    int i;\n    for (i = 0; ((mask & 1) == 0) && (i < 32); ++i) {\n        mask >>>= 1;\n    }\n    return i;\n}",
			"comments":"/**\n* Computes the required channel shift from a mask.\n*/\n",
			"methodName":"static int getChannelShift(int mask)"
		},
		"static byte[] checkData(byte[] data)":{
			"methodBody":"{\n    if (data == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    return data;\n}",
			"comments":"",
			"methodName":"static byte[] checkData(byte[] data)"
		},
		"public int getTransparencyType()":{
			"methodBody":"{\n    if (maskData != null)\n        return SWT.TRANSPARENCY_MASK;\n    if (transparentPixel != -1)\n        return SWT.TRANSPARENCY_PIXEL;\n    if (alphaData != null)\n        return SWT.TRANSPARENCY_ALPHA;\n    return SWT.TRANSPARENCY_NONE;\n}",
			"comments":"/**\n* Returns the image transparency type, which will be one of\n* <code>SWT.TRANSPARENCY_NONE</code>, <code>SWT.TRANSPARENCY_MASK</code>,\n* <code>SWT.TRANSPARENCY_PIXEL</code> or <code>SWT.TRANSPARENCY_ALPHA</code>.\n*\n* @return the receiver's transparency type\n*/\n",
			"methodName":"public int getTransparencyType()"
		},
		"static void blit(int op, byte[] srcData, int srcDepth, int srcStride, int srcOrder, int srcX, int srcY, int srcWidth, int srcHeight, int srcRedMask, int srcGreenMask, int srcBlueMask, int alphaMode, byte[] alphaData, int alphaStride, int alphaX, int alphaY, byte[] destData, int destDepth, int destStride, int destOrder, int destX, int destY, int destWidth, int destHeight, int destRedMask, int destGreenMask, int destBlueMask, boolean flipX, boolean flipY)":{
			"methodBody":"{\n    if ((destWidth <= 0) || (destHeight <= 0) || (alphaMode == ALPHA_TRANSPARENT))\n        return;\n    \n    final int srcAlphaMask = 0, destAlphaMask = 0;\n    \n    final int dwm1 = destWidth - 1;\n    final int sfxi = (dwm1 != 0) ? (int) ((((long) srcWidth << 16) - 1) / dwm1) : 0;\n    final int dhm1 = destHeight - 1;\n    final int sfyi = (dhm1 != 0) ? (int) ((((long) srcHeight << 16) - 1) / dhm1) : 0;\n    \n    final int sbpp, stype;\n    switch(srcDepth) {\n        case 8:\n            sbpp = 1;\n            stype = TYPE_GENERIC_8;\n            break;\n        case 16:\n            sbpp = 2;\n            stype = (srcOrder == MSB_FIRST) ? TYPE_GENERIC_16_MSB : TYPE_GENERIC_16_LSB;\n            break;\n        case 24:\n            sbpp = 3;\n            stype = TYPE_GENERIC_24;\n            break;\n        case 32:\n            sbpp = 4;\n            stype = (srcOrder == MSB_FIRST) ? TYPE_GENERIC_32_MSB : TYPE_GENERIC_32_LSB;\n            break;\n        default:\n            \n            return;\n    }\n    int spr = srcY * srcStride + srcX * sbpp;\n    \n    final int dbpp, dtype;\n    switch(destDepth) {\n        case 8:\n            dbpp = 1;\n            dtype = TYPE_GENERIC_8;\n            break;\n        case 16:\n            dbpp = 2;\n            dtype = (destOrder == MSB_FIRST) ? TYPE_GENERIC_16_MSB : TYPE_GENERIC_16_LSB;\n            break;\n        case 24:\n            dbpp = 3;\n            dtype = TYPE_GENERIC_24;\n            break;\n        case 32:\n            dbpp = 4;\n            dtype = (destOrder == MSB_FIRST) ? TYPE_GENERIC_32_MSB : TYPE_GENERIC_32_LSB;\n            break;\n        default:\n            \n            return;\n    }\n    int dpr = ((flipY) ? destY + dhm1 : destY) * destStride + ((flipX) ? destX + dwm1 : destX) * dbpp;\n    final int dprxi = (flipX) ? -dbpp : dbpp;\n    final int dpryi = (flipY) ? -destStride : destStride;\n    \n    int apr;\n    if ((op & BLIT_ALPHA) != 0) {\n        switch(alphaMode) {\n            case ALPHA_MASK_UNPACKED:\n            case ALPHA_CHANNEL_SEPARATE:\n                if (alphaData == null)\n                    alphaMode = 0x10000;\n                apr = alphaY * alphaStride + alphaX;\n                break;\n            case ALPHA_MASK_PACKED:\n                if (alphaData == null)\n                    alphaMode = 0x10000;\n                alphaStride <<= 3;\n                apr = alphaY * alphaStride + alphaX;\n                break;\n            case ALPHA_MASK_INDEX:\n                \n                return;\n            case ALPHA_MASK_RGB:\n                if (alphaData == null)\n                    alphaMode = 0x10000;\n                apr = 0;\n                break;\n            default:\n                \n                alphaMode = (alphaMode << 16) / 255;\n            case ALPHA_CHANNEL_SOURCE:\n                apr = 0;\n                break;\n        }\n    } else {\n        alphaMode = 0x10000;\n        apr = 0;\n    }\n    \n    int dp = dpr;\n    int sp = spr;\n    if ((alphaMode == 0x10000) && (stype == dtype) && (srcRedMask == destRedMask) && (srcGreenMask == destGreenMask) && (srcBlueMask == destBlueMask) && (srcAlphaMask == destAlphaMask)) {\n        \n        switch(sbpp) {\n            case 1:\n                for (int dy = destHeight, sfy = sfyi; dy > 0; --dy, sp = spr += (sfy >>> 16) * srcStride, sfy = (sfy & 0xffff) + sfyi, dp = dpr += dpryi) {\n                    for (int dx = destWidth, sfx = sfxi; dx > 0; --dx, dp += dprxi, sfx = (sfx & 0xffff) + sfxi) {\n                        destData[dp] = srcData[sp];\n                        sp += (sfx >>> 16);\n                    }\n                }\n                break;\n            case 2:\n                for (int dy = destHeight, sfy = sfyi; dy > 0; --dy, sp = spr += (sfy >>> 16) * srcStride, sfy = (sfy & 0xffff) + sfyi, dp = dpr += dpryi) {\n                    for (int dx = destWidth, sfx = sfxi; dx > 0; --dx, dp += dprxi, sfx = (sfx & 0xffff) + sfxi) {\n                        destData[dp] = srcData[sp];\n                        destData[dp + 1] = srcData[sp + 1];\n                        sp += (sfx >>> 16) * 2;\n                    }\n                }\n                break;\n            case 3:\n                for (int dy = destHeight, sfy = sfyi; dy > 0; --dy, sp = spr += (sfy >>> 16) * srcStride, sfy = (sfy & 0xffff) + sfyi, dp = dpr += dpryi) {\n                    for (int dx = destWidth, sfx = sfxi; dx > 0; --dx, dp += dprxi, sfx = (sfx & 0xffff) + sfxi) {\n                        destData[dp] = srcData[sp];\n                        destData[dp + 1] = srcData[sp + 1];\n                        destData[dp + 2] = srcData[sp + 2];\n                        sp += (sfx >>> 16) * 3;\n                    }\n                }\n                break;\n            case 4:\n                for (int dy = destHeight, sfy = sfyi; dy > 0; --dy, sp = spr += (sfy >>> 16) * srcStride, sfy = (sfy & 0xffff) + sfyi, dp = dpr += dpryi) {\n                    for (int dx = destWidth, sfx = sfxi; dx > 0; --dx, dp += dprxi, sfx = (sfx & 0xffff) + sfxi) {\n                        destData[dp] = srcData[sp];\n                        destData[dp + 1] = srcData[sp + 1];\n                        destData[dp + 2] = srcData[sp + 2];\n                        destData[dp + 3] = srcData[sp + 3];\n                        sp += (sfx >>> 16) * 4;\n                    }\n                }\n                break;\n        }\n        return;\n    }\n    \n    final int srcRedShift = getChannelShift(srcRedMask);\n    final byte[] srcReds = ANY_TO_EIGHT[getChannelWidth(srcRedMask, srcRedShift)];\n    final int srcGreenShift = getChannelShift(srcGreenMask);\n    final byte[] srcGreens = ANY_TO_EIGHT[getChannelWidth(srcGreenMask, srcGreenShift)];\n    final int srcBlueShift = getChannelShift(srcBlueMask);\n    final byte[] srcBlues = ANY_TO_EIGHT[getChannelWidth(srcBlueMask, srcBlueShift)];\n    final int srcAlphaShift = getChannelShift(srcAlphaMask);\n    final byte[] srcAlphas = ANY_TO_EIGHT[getChannelWidth(srcAlphaMask, srcAlphaShift)];\n    final int destRedShift = getChannelShift(destRedMask);\n    final int destRedWidth = getChannelWidth(destRedMask, destRedShift);\n    final byte[] destReds = ANY_TO_EIGHT[destRedWidth];\n    final int destRedPreShift = 8 - destRedWidth;\n    final int destGreenShift = getChannelShift(destGreenMask);\n    final int destGreenWidth = getChannelWidth(destGreenMask, destGreenShift);\n    final byte[] destGreens = ANY_TO_EIGHT[destGreenWidth];\n    final int destGreenPreShift = 8 - destGreenWidth;\n    final int destBlueShift = getChannelShift(destBlueMask);\n    final int destBlueWidth = getChannelWidth(destBlueMask, destBlueShift);\n    final byte[] destBlues = ANY_TO_EIGHT[destBlueWidth];\n    final int destBluePreShift = 8 - destBlueWidth;\n    final int destAlphaShift = getChannelShift(destAlphaMask);\n    final int destAlphaWidth = getChannelWidth(destAlphaMask, destAlphaShift);\n    final byte[] destAlphas = ANY_TO_EIGHT[destAlphaWidth];\n    final int destAlphaPreShift = 8 - destAlphaWidth;\n    int ap = apr, alpha = alphaMode;\n    int r = 0, g = 0, b = 0, a = 0;\n    int rq = 0, gq = 0, bq = 0, aq = 0;\n    for (int dy = destHeight, sfy = sfyi; dy > 0; --dy, sp = spr += (sfy >>> 16) * srcStride, ap = apr += (sfy >>> 16) * alphaStride, sfy = (sfy & 0xffff) + sfyi, dp = dpr += dpryi) {\n        for (int dx = destWidth, sfx = sfxi; dx > 0; --dx, dp += dprxi, sfx = (sfx & 0xffff) + sfxi) {\n            \n            switch(stype) {\n                case TYPE_GENERIC_8:\n                    {\n                        final int data = srcData[sp] & 0xff;\n                        sp += (sfx >>> 16);\n                        r = srcReds[(data & srcRedMask) >>> srcRedShift] & 0xff;\n                        g = srcGreens[(data & srcGreenMask) >>> srcGreenShift] & 0xff;\n                        b = srcBlues[(data & srcBlueMask) >>> srcBlueShift] & 0xff;\n                        a = srcAlphas[(data & srcAlphaMask) >>> srcAlphaShift] & 0xff;\n                    }\n                    break;\n                case TYPE_GENERIC_16_MSB:\n                    {\n                        final int data = ((srcData[sp] & 0xff) << 8) | (srcData[sp + 1] & 0xff);\n                        sp += (sfx >>> 16) * 2;\n                        r = srcReds[(data & srcRedMask) >>> srcRedShift] & 0xff;\n                        g = srcGreens[(data & srcGreenMask) >>> srcGreenShift] & 0xff;\n                        b = srcBlues[(data & srcBlueMask) >>> srcBlueShift] & 0xff;\n                        a = srcAlphas[(data & srcAlphaMask) >>> srcAlphaShift] & 0xff;\n                    }\n                    break;\n                case TYPE_GENERIC_16_LSB:\n                    {\n                        final int data = ((srcData[sp + 1] & 0xff) << 8) | (srcData[sp] & 0xff);\n                        sp += (sfx >>> 16) * 2;\n                        r = srcReds[(data & srcRedMask) >>> srcRedShift] & 0xff;\n                        g = srcGreens[(data & srcGreenMask) >>> srcGreenShift] & 0xff;\n                        b = srcBlues[(data & srcBlueMask) >>> srcBlueShift] & 0xff;\n                        a = srcAlphas[(data & srcAlphaMask) >>> srcAlphaShift] & 0xff;\n                    }\n                    break;\n                case TYPE_GENERIC_24:\n                    {\n                        final int data = ((((srcData[sp] & 0xff) << 8) | (srcData[sp + 1] & 0xff)) << 8) | (srcData[sp + 2] & 0xff);\n                        sp += (sfx >>> 16) * 3;\n                        r = srcReds[(data & srcRedMask) >>> srcRedShift] & 0xff;\n                        g = srcGreens[(data & srcGreenMask) >>> srcGreenShift] & 0xff;\n                        b = srcBlues[(data & srcBlueMask) >>> srcBlueShift] & 0xff;\n                        a = srcAlphas[(data & srcAlphaMask) >>> srcAlphaShift] & 0xff;\n                    }\n                    break;\n                case TYPE_GENERIC_32_MSB:\n                    {\n                        final int data = ((((((srcData[sp] & 0xff) << 8) | (srcData[sp + 1] & 0xff)) << 8) | (srcData[sp + 2] & 0xff)) << 8) | (srcData[sp + 3] & 0xff);\n                        sp += (sfx >>> 16) * 4;\n                        r = srcReds[(data & srcRedMask) >>> srcRedShift] & 0xff;\n                        g = srcGreens[(data & srcGreenMask) >>> srcGreenShift] & 0xff;\n                        b = srcBlues[(data & srcBlueMask) >>> srcBlueShift] & 0xff;\n                        a = srcAlphas[(data & srcAlphaMask) >>> srcAlphaShift] & 0xff;\n                    }\n                    break;\n                case TYPE_GENERIC_32_LSB:\n                    {\n                        final int data = ((((((srcData[sp + 3] & 0xff) << 8) | (srcData[sp + 2] & 0xff)) << 8) | (srcData[sp + 1] & 0xff)) << 8) | (srcData[sp] & 0xff);\n                        sp += (sfx >>> 16) * 4;\n                        r = srcReds[(data & srcRedMask) >>> srcRedShift] & 0xff;\n                        g = srcGreens[(data & srcGreenMask) >>> srcGreenShift] & 0xff;\n                        b = srcBlues[(data & srcBlueMask) >>> srcBlueShift] & 0xff;\n                        a = srcAlphas[(data & srcAlphaMask) >>> srcAlphaShift] & 0xff;\n                    }\n                    break;\n            }\n            \n            switch(alphaMode) {\n                case ALPHA_CHANNEL_SEPARATE:\n                    alpha = ((alphaData[ap] & 0xff) << 16) / 255;\n                    ap += (sfx >> 16);\n                    break;\n                case ALPHA_CHANNEL_SOURCE:\n                    alpha = (a << 16) / 255;\n                    break;\n                case ALPHA_MASK_UNPACKED:\n                    alpha = (alphaData[ap] != 0) ? 0x10000 : 0;\n                    ap += (sfx >> 16);\n                    break;\n                case ALPHA_MASK_PACKED:\n                    alpha = (alphaData[ap >> 3] << ((ap & 7) + 9)) & 0x10000;\n                    ap += (sfx >> 16);\n                    break;\n                case ALPHA_MASK_RGB:\n                    alpha = 0x10000;\n                    for (int i = 0; i < alphaData.length; i += 3) {\n                        if ((r == alphaData[i]) && (g == alphaData[i + 1]) && (b == alphaData[i + 2])) {\n                            alpha = 0x0000;\n                            break;\n                        }\n                    }\n                    break;\n            }\n            if (alpha != 0x10000) {\n                if (alpha == 0x0000)\n                    continue;\n                switch(dtype) {\n                    case TYPE_GENERIC_8:\n                        {\n                            final int data = destData[dp] & 0xff;\n                            rq = destReds[(data & destRedMask) >>> destRedShift] & 0xff;\n                            gq = destGreens[(data & destGreenMask) >>> destGreenShift] & 0xff;\n                            bq = destBlues[(data & destBlueMask) >>> destBlueShift] & 0xff;\n                            aq = destAlphas[(data & destAlphaMask) >>> destAlphaShift] & 0xff;\n                        }\n                        break;\n                    case TYPE_GENERIC_16_MSB:\n                        {\n                            final int data = ((destData[dp] & 0xff) << 8) | (destData[dp + 1] & 0xff);\n                            rq = destReds[(data & destRedMask) >>> destRedShift] & 0xff;\n                            gq = destGreens[(data & destGreenMask) >>> destGreenShift] & 0xff;\n                            bq = destBlues[(data & destBlueMask) >>> destBlueShift] & 0xff;\n                            aq = destAlphas[(data & destAlphaMask) >>> destAlphaShift] & 0xff;\n                        }\n                        break;\n                    case TYPE_GENERIC_16_LSB:\n                        {\n                            final int data = ((destData[dp + 1] & 0xff) << 8) | (destData[dp] & 0xff);\n                            rq = destReds[(data & destRedMask) >>> destRedShift] & 0xff;\n                            gq = destGreens[(data & destGreenMask) >>> destGreenShift] & 0xff;\n                            bq = destBlues[(data & destBlueMask) >>> destBlueShift] & 0xff;\n                            aq = destAlphas[(data & destAlphaMask) >>> destAlphaShift] & 0xff;\n                        }\n                        break;\n                    case TYPE_GENERIC_24:\n                        {\n                            final int data = ((((destData[dp] & 0xff) << 8) | (destData[dp + 1] & 0xff)) << 8) | (destData[dp + 2] & 0xff);\n                            rq = destReds[(data & destRedMask) >>> destRedShift] & 0xff;\n                            gq = destGreens[(data & destGreenMask) >>> destGreenShift] & 0xff;\n                            bq = destBlues[(data & destBlueMask) >>> destBlueShift] & 0xff;\n                            aq = destAlphas[(data & destAlphaMask) >>> destAlphaShift] & 0xff;\n                        }\n                        break;\n                    case TYPE_GENERIC_32_MSB:\n                        {\n                            final int data = ((((((destData[dp] & 0xff) << 8) | (destData[dp + 1] & 0xff)) << 8) | (destData[dp + 2] & 0xff)) << 8) | (destData[dp + 3] & 0xff);\n                            rq = destReds[(data & destRedMask) >>> destRedShift] & 0xff;\n                            gq = destGreens[(data & destGreenMask) >>> destGreenShift] & 0xff;\n                            bq = destBlues[(data & destBlueMask) >>> destBlueShift] & 0xff;\n                            aq = destAlphas[(data & destAlphaMask) >>> destAlphaShift] & 0xff;\n                        }\n                        break;\n                    case TYPE_GENERIC_32_LSB:\n                        {\n                            final int data = ((((((destData[dp + 3] & 0xff) << 8) | (destData[dp + 2] & 0xff)) << 8) | (destData[dp + 1] & 0xff)) << 8) | (destData[dp] & 0xff);\n                            rq = destReds[(data & destRedMask) >>> destRedShift] & 0xff;\n                            gq = destGreens[(data & destGreenMask) >>> destGreenShift] & 0xff;\n                            bq = destBlues[(data & destBlueMask) >>> destBlueShift] & 0xff;\n                            aq = destAlphas[(data & destAlphaMask) >>> destAlphaShift] & 0xff;\n                        }\n                        break;\n                }\n                \n                a = aq + ((a - aq) * alpha >> 16);\n                r = rq + ((r - rq) * alpha >> 16);\n                g = gq + ((g - gq) * alpha >> 16);\n                b = bq + ((b - bq) * alpha >> 16);\n            }\n            \n            final int data = (r >>> destRedPreShift << destRedShift) | (g >>> destGreenPreShift << destGreenShift) | (b >>> destBluePreShift << destBlueShift) | (a >>> destAlphaPreShift << destAlphaShift);\n            switch(dtype) {\n                case TYPE_GENERIC_8:\n                    {\n                        destData[dp] = (byte) data;\n                    }\n                    break;\n                case TYPE_GENERIC_16_MSB:\n                    {\n                        destData[dp] = (byte) (data >>> 8);\n                        destData[dp + 1] = (byte) (data & 0xff);\n                    }\n                    break;\n                case TYPE_GENERIC_16_LSB:\n                    {\n                        destData[dp] = (byte) (data & 0xff);\n                        destData[dp + 1] = (byte) (data >>> 8);\n                    }\n                    break;\n                case TYPE_GENERIC_24:\n                    {\n                        destData[dp] = (byte) (data >>> 16);\n                        destData[dp + 1] = (byte) (data >>> 8);\n                        destData[dp + 2] = (byte) (data & 0xff);\n                    }\n                    break;\n                case TYPE_GENERIC_32_MSB:\n                    {\n                        destData[dp] = (byte) (data >>> 24);\n                        destData[dp + 1] = (byte) (data >>> 16);\n                        destData[dp + 2] = (byte) (data >>> 8);\n                        destData[dp + 3] = (byte) (data & 0xff);\n                    }\n                    break;\n                case TYPE_GENERIC_32_LSB:\n                    {\n                        destData[dp] = (byte) (data & 0xff);\n                        destData[dp + 1] = (byte) (data >>> 8);\n                        destData[dp + 2] = (byte) (data >>> 16);\n                        destData[dp + 3] = (byte) (data >>> 24);\n                    }\n                    break;\n            }\n        }\n    }\n}",
			"comments":"/**\n* Blits a direct palette image into a direct palette image.\n* <p>\n* Note: When the source and destination depth, order and masks\n* are pairwise equal and the blitter operation is BLIT_SRC,\n* the masks are ignored.  Hence when not changing the image\n* data format, 0 may be specified for the masks.\n* </p>\n*\n* @param op the blitter operation: a combination of BLIT_xxx flags\n*        (see BLIT_xxx constants)\n* @param srcData the source byte array containing image data\n* @param srcDepth the source depth: one of 8, 16, 24, 32\n* @param srcStride the source number of bytes per line\n* @param srcOrder the source byte ordering: one of MSB_FIRST or LSB_FIRST;\n*        ignored if srcDepth is not 16 or 32\n* @param srcX the top-left x-coord of the source blit region\n* @param srcY the top-left y-coord of the source blit region\n* @param srcWidth the width of the source blit region\n* @param srcHeight the height of the source blit region\n* @param srcRedMask the source red channel mask\n* @param srcGreenMask the source green channel mask\n* @param srcBlueMask the source blue channel mask\n* @param alphaMode the alpha blending or mask mode, may be\n*        an integer 0-255 for global alpha; ignored if BLIT_ALPHA\n*        not specified in the blitter operations\n*        (see ALPHA_MODE_xxx constants)\n* @param alphaData the alpha blending or mask data, varies depending\n*        on the value of alphaMode and sometimes ignored\n* @param alphaStride the alpha data number of bytes per line\n* @param alphaX the top-left x-coord of the alpha blit region\n* @param alphaY the top-left y-coord of the alpha blit region\n* @param destData the destination byte array containing image data\n* @param destDepth the destination depth: one of 8, 16, 24, 32\n* @param destStride the destination number of bytes per line\n* @param destOrder the destination byte ordering: one of MSB_FIRST or LSB_FIRST;\n*        ignored if destDepth is not 16 or 32\n* @param destX the top-left x-coord of the destination blit region\n* @param destY the top-left y-coord of the destination blit region\n* @param destWidth the width of the destination blit region\n* @param destHeight the height of the destination blit region\n* @param destRedMask the destination red channel mask\n* @param destGreenMask the destination green channel mask\n* @param destBlueMask the destination blue channel mask\n* @param flipX if true the resulting image is flipped along the vertical axis\n* @param flipY if true the resulting image is flipped along the horizontal axis\n*/\n// these should be supplied as params later\n/*** Prepare scaling data ***/\n/*** Prepare source-related data ***/\n//throw new IllegalArgumentException(\"Invalid source type\");\n/*** Prepare destination-related data ***/\n//throw new IllegalArgumentException(\"Invalid destination type\");\n/*** Prepare special processing data ***/\n//throw new IllegalArgumentException(\"Invalid alpha type\");\n// prescale\n/*** Blit ***/\n/*** Fast blit (straight copy) ***/\n/*** Comprehensive blit (apply transformations) ***/\n/*** READ NEXT PIXEL ***/\n/*** DO SPECIAL PROCESSING IF REQUIRED ***/\n// Perform alpha blending\n/*** WRITE NEXT PIXEL ***/\n",
			"methodName":"static void blit(int op, byte[] srcData, int srcDepth, int srcStride, int srcOrder, int srcX, int srcY, int srcWidth, int srcHeight, int srcRedMask, int srcGreenMask, int srcBlueMask, int alphaMode, byte[] alphaData, int alphaStride, int alphaX, int alphaY, byte[] destData, int destDepth, int destStride, int destOrder, int destX, int destY, int destWidth, int destHeight, int destRedMask, int destGreenMask, int destBlueMask, boolean flipX, boolean flipY)"
		},
		"static void blit(int op, byte[] srcData, int srcDepth, int srcStride, int srcOrder, int srcX, int srcY, int srcWidth, int srcHeight, byte[] srcReds, byte[] srcGreens, byte[] srcBlues, int alphaMode, byte[] alphaData, int alphaStride, int alphaX, int alphaY, byte[] destData, int destDepth, int destStride, int destOrder, int destX, int destY, int destWidth, int destHeight, int destRedMask, int destGreenMask, int destBlueMask, boolean flipX, boolean flipY)":{
			"methodBody":"{\n    if ((destWidth <= 0) || (destHeight <= 0) || (alphaMode == ALPHA_TRANSPARENT))\n        return;\n    \n    final int destAlphaMask = 0;\n    \n    final int dwm1 = destWidth - 1;\n    final int sfxi = (dwm1 != 0) ? (int) ((((long) srcWidth << 16) - 1) / dwm1) : 0;\n    final int dhm1 = destHeight - 1;\n    final int sfyi = (dhm1 != 0) ? (int) ((((long) srcHeight << 16) - 1) / dhm1) : 0;\n    \n    final int stype;\n    switch(srcDepth) {\n        case 8:\n            stype = TYPE_INDEX_8;\n            break;\n        case 4:\n            srcStride <<= 1;\n            stype = TYPE_INDEX_4;\n            break;\n        case 2:\n            srcStride <<= 2;\n            stype = TYPE_INDEX_2;\n            break;\n        case 1:\n            srcStride <<= 3;\n            stype = (srcOrder == MSB_FIRST) ? TYPE_INDEX_1_MSB : TYPE_INDEX_1_LSB;\n            break;\n        default:\n            \n            return;\n    }\n    int spr = srcY * srcStride + srcX;\n    \n    final int dbpp, dtype;\n    switch(destDepth) {\n        case 8:\n            dbpp = 1;\n            dtype = TYPE_GENERIC_8;\n            break;\n        case 16:\n            dbpp = 2;\n            dtype = (destOrder == MSB_FIRST) ? TYPE_GENERIC_16_MSB : TYPE_GENERIC_16_LSB;\n            break;\n        case 24:\n            dbpp = 3;\n            dtype = TYPE_GENERIC_24;\n            break;\n        case 32:\n            dbpp = 4;\n            dtype = (destOrder == MSB_FIRST) ? TYPE_GENERIC_32_MSB : TYPE_GENERIC_32_LSB;\n            break;\n        default:\n            \n            return;\n    }\n    int dpr = ((flipY) ? destY + dhm1 : destY) * destStride + ((flipX) ? destX + dwm1 : destX) * dbpp;\n    final int dprxi = (flipX) ? -dbpp : dbpp;\n    final int dpryi = (flipY) ? -destStride : destStride;\n    \n    int apr;\n    if ((op & BLIT_ALPHA) != 0) {\n        switch(alphaMode) {\n            case ALPHA_MASK_UNPACKED:\n            case ALPHA_CHANNEL_SEPARATE:\n                if (alphaData == null)\n                    alphaMode = 0x10000;\n                apr = alphaY * alphaStride + alphaX;\n                break;\n            case ALPHA_MASK_PACKED:\n                if (alphaData == null)\n                    alphaMode = 0x10000;\n                alphaStride <<= 3;\n                apr = alphaY * alphaStride + alphaX;\n                break;\n            case ALPHA_MASK_INDEX:\n            case ALPHA_MASK_RGB:\n                if (alphaData == null)\n                    alphaMode = 0x10000;\n                apr = 0;\n                break;\n            default:\n                \n                alphaMode = (alphaMode << 16) / 255;\n            case ALPHA_CHANNEL_SOURCE:\n                apr = 0;\n                break;\n        }\n    } else {\n        alphaMode = 0x10000;\n        apr = 0;\n    }\n    \n    final int destRedShift = getChannelShift(destRedMask);\n    final int destRedWidth = getChannelWidth(destRedMask, destRedShift);\n    final byte[] destReds = ANY_TO_EIGHT[destRedWidth];\n    final int destRedPreShift = 8 - destRedWidth;\n    final int destGreenShift = getChannelShift(destGreenMask);\n    final int destGreenWidth = getChannelWidth(destGreenMask, destGreenShift);\n    final byte[] destGreens = ANY_TO_EIGHT[destGreenWidth];\n    final int destGreenPreShift = 8 - destGreenWidth;\n    final int destBlueShift = getChannelShift(destBlueMask);\n    final int destBlueWidth = getChannelWidth(destBlueMask, destBlueShift);\n    final byte[] destBlues = ANY_TO_EIGHT[destBlueWidth];\n    final int destBluePreShift = 8 - destBlueWidth;\n    final int destAlphaShift = getChannelShift(destAlphaMask);\n    final int destAlphaWidth = getChannelWidth(destAlphaMask, destAlphaShift);\n    final byte[] destAlphas = ANY_TO_EIGHT[destAlphaWidth];\n    final int destAlphaPreShift = 8 - destAlphaWidth;\n    int dp = dpr;\n    int sp = spr;\n    int ap = apr, alpha = alphaMode;\n    int r = 0, g = 0, b = 0, a = 0, index = 0;\n    int rq = 0, gq = 0, bq = 0, aq = 0;\n    for (int dy = destHeight, sfy = sfyi; dy > 0; --dy, sp = spr += (sfy >>> 16) * srcStride, ap = apr += (sfy >>> 16) * alphaStride, sfy = (sfy & 0xffff) + sfyi, dp = dpr += dpryi) {\n        for (int dx = destWidth, sfx = sfxi; dx > 0; --dx, dp += dprxi, sfx = (sfx & 0xffff) + sfxi) {\n            \n            switch(stype) {\n                case TYPE_INDEX_8:\n                    index = srcData[sp] & 0xff;\n                    sp += (sfx >>> 16);\n                    break;\n                case TYPE_INDEX_4:\n                    if ((sp & 1) != 0)\n                        index = srcData[sp >> 1] & 0x0f;\n                    else\n                        index = (srcData[sp >> 1] >>> 4) & 0x0f;\n                    sp += (sfx >>> 16);\n                    break;\n                case TYPE_INDEX_2:\n                    index = (srcData[sp >> 2] >>> (6 - (sp & 3) * 2)) & 0x03;\n                    sp += (sfx >>> 16);\n                    break;\n                case TYPE_INDEX_1_MSB:\n                    index = (srcData[sp >> 3] >>> (7 - (sp & 7))) & 0x01;\n                    sp += (sfx >>> 16);\n                    break;\n                case TYPE_INDEX_1_LSB:\n                    index = (srcData[sp >> 3] >>> (sp & 7)) & 0x01;\n                    sp += (sfx >>> 16);\n                    break;\n            }\n            \n            r = srcReds[index] & 0xff;\n            g = srcGreens[index] & 0xff;\n            b = srcBlues[index] & 0xff;\n            switch(alphaMode) {\n                case ALPHA_CHANNEL_SEPARATE:\n                    alpha = ((alphaData[ap] & 0xff) << 16) / 255;\n                    ap += (sfx >> 16);\n                    break;\n                case ALPHA_MASK_UNPACKED:\n                    alpha = (alphaData[ap] != 0) ? 0x10000 : 0;\n                    ap += (sfx >> 16);\n                    break;\n                case ALPHA_MASK_PACKED:\n                    alpha = (alphaData[ap >> 3] << ((ap & 7) + 9)) & 0x10000;\n                    ap += (sfx >> 16);\n                    break;\n                case ALPHA_MASK_INDEX:\n                    {\n                        \n                        int i = 0;\n                        while (i < alphaData.length) {\n                            if (index == (alphaData[i] & 0xff))\n                                break;\n                        }\n                        if (i < alphaData.length)\n                            continue;\n                    }\n                    break;\n                case ALPHA_MASK_RGB:\n                    {\n                        int i = 0;\n                        while (i < alphaData.length) {\n                            if ((r == (alphaData[i] & 0xff)) && (g == (alphaData[i + 1] & 0xff)) && (b == (alphaData[i + 2] & 0xff)))\n                                break;\n                            i += 3;\n                        }\n                        if (i < alphaData.length)\n                            continue;\n                    }\n                    break;\n            }\n            if (alpha != 0x10000) {\n                if (alpha == 0x0000)\n                    continue;\n                switch(dtype) {\n                    case TYPE_GENERIC_8:\n                        {\n                            final int data = destData[dp] & 0xff;\n                            rq = destReds[(data & destRedMask) >>> destRedShift] & 0xff;\n                            gq = destGreens[(data & destGreenMask) >>> destGreenShift] & 0xff;\n                            bq = destBlues[(data & destBlueMask) >>> destBlueShift] & 0xff;\n                            aq = destAlphas[(data & destAlphaMask) >>> destAlphaShift] & 0xff;\n                        }\n                        break;\n                    case TYPE_GENERIC_16_MSB:\n                        {\n                            final int data = ((destData[dp] & 0xff) << 8) | (destData[dp + 1] & 0xff);\n                            rq = destReds[(data & destRedMask) >>> destRedShift] & 0xff;\n                            gq = destGreens[(data & destGreenMask) >>> destGreenShift] & 0xff;\n                            bq = destBlues[(data & destBlueMask) >>> destBlueShift] & 0xff;\n                            aq = destAlphas[(data & destAlphaMask) >>> destAlphaShift] & 0xff;\n                        }\n                        break;\n                    case TYPE_GENERIC_16_LSB:\n                        {\n                            final int data = ((destData[dp + 1] & 0xff) << 8) | (destData[dp] & 0xff);\n                            rq = destReds[(data & destRedMask) >>> destRedShift] & 0xff;\n                            gq = destGreens[(data & destGreenMask) >>> destGreenShift] & 0xff;\n                            bq = destBlues[(data & destBlueMask) >>> destBlueShift] & 0xff;\n                            aq = destAlphas[(data & destAlphaMask) >>> destAlphaShift] & 0xff;\n                        }\n                        break;\n                    case TYPE_GENERIC_24:\n                        {\n                            final int data = ((((destData[dp] & 0xff) << 8) | (destData[dp + 1] & 0xff)) << 8) | (destData[dp + 2] & 0xff);\n                            rq = destReds[(data & destRedMask) >>> destRedShift] & 0xff;\n                            gq = destGreens[(data & destGreenMask) >>> destGreenShift] & 0xff;\n                            bq = destBlues[(data & destBlueMask) >>> destBlueShift] & 0xff;\n                            aq = destAlphas[(data & destAlphaMask) >>> destAlphaShift] & 0xff;\n                        }\n                        break;\n                    case TYPE_GENERIC_32_MSB:\n                        {\n                            final int data = ((((((destData[dp] & 0xff) << 8) | (destData[dp + 1] & 0xff)) << 8) | (destData[dp + 2] & 0xff)) << 8) | (destData[dp + 3] & 0xff);\n                            rq = destReds[(data & destRedMask) >>> destRedShift] & 0xff;\n                            gq = destGreens[(data & destGreenMask) >>> destGreenShift] & 0xff;\n                            bq = destBlues[(data & destBlueMask) >>> destBlueShift] & 0xff;\n                            aq = destAlphas[(data & destAlphaMask) >>> destAlphaShift] & 0xff;\n                        }\n                        break;\n                    case TYPE_GENERIC_32_LSB:\n                        {\n                            final int data = ((((((destData[dp + 3] & 0xff) << 8) | (destData[dp + 2] & 0xff)) << 8) | (destData[dp + 1] & 0xff)) << 8) | (destData[dp] & 0xff);\n                            rq = destReds[(data & destRedMask) >>> destRedShift] & 0xff;\n                            gq = destGreens[(data & destGreenMask) >>> destGreenShift] & 0xff;\n                            bq = destBlues[(data & destBlueMask) >>> destBlueShift] & 0xff;\n                            aq = destAlphas[(data & destAlphaMask) >>> destAlphaShift] & 0xff;\n                        }\n                        break;\n                }\n                \n                a = aq + ((a - aq) * alpha >> 16);\n                r = rq + ((r - rq) * alpha >> 16);\n                g = gq + ((g - gq) * alpha >> 16);\n                b = bq + ((b - bq) * alpha >> 16);\n            }\n            \n            final int data = (r >>> destRedPreShift << destRedShift) | (g >>> destGreenPreShift << destGreenShift) | (b >>> destBluePreShift << destBlueShift) | (a >>> destAlphaPreShift << destAlphaShift);\n            switch(dtype) {\n                case TYPE_GENERIC_8:\n                    {\n                        destData[dp] = (byte) data;\n                    }\n                    break;\n                case TYPE_GENERIC_16_MSB:\n                    {\n                        destData[dp] = (byte) (data >>> 8);\n                        destData[dp + 1] = (byte) (data & 0xff);\n                    }\n                    break;\n                case TYPE_GENERIC_16_LSB:\n                    {\n                        destData[dp] = (byte) (data & 0xff);\n                        destData[dp + 1] = (byte) (data >>> 8);\n                    }\n                    break;\n                case TYPE_GENERIC_24:\n                    {\n                        destData[dp] = (byte) (data >>> 16);\n                        destData[dp + 1] = (byte) (data >>> 8);\n                        destData[dp + 2] = (byte) (data & 0xff);\n                    }\n                    break;\n                case TYPE_GENERIC_32_MSB:\n                    {\n                        destData[dp] = (byte) (data >>> 24);\n                        destData[dp + 1] = (byte) (data >>> 16);\n                        destData[dp + 2] = (byte) (data >>> 8);\n                        destData[dp + 3] = (byte) (data & 0xff);\n                    }\n                    break;\n                case TYPE_GENERIC_32_LSB:\n                    {\n                        destData[dp] = (byte) (data & 0xff);\n                        destData[dp + 1] = (byte) (data >>> 8);\n                        destData[dp + 2] = (byte) (data >>> 16);\n                        destData[dp + 3] = (byte) (data >>> 24);\n                    }\n                    break;\n            }\n        }\n    }\n}",
			"comments":"/**\n* Blits an index palette image into a direct palette image.\n* <p>\n* Note: The source and destination masks and palettes must\n* always be fully specified.\n* </p>\n*\n* @param op the blitter operation: a combination of BLIT_xxx flags\n*        (see BLIT_xxx constants)\n* @param srcData the source byte array containing image data\n* @param srcDepth the source depth: one of 1, 2, 4, 8\n* @param srcStride the source number of bytes per line\n* @param srcOrder the source byte ordering: one of MSB_FIRST or LSB_FIRST;\n*        ignored if srcDepth is not 1\n* @param srcX the top-left x-coord of the source blit region\n* @param srcY the top-left y-coord of the source blit region\n* @param srcWidth the width of the source blit region\n* @param srcHeight the height of the source blit region\n* @param srcReds the source palette red component intensities\n* @param srcGreens the source palette green component intensities\n* @param srcBlues the source palette blue component intensities\n* @param alphaMode the alpha blending or mask mode, may be\n*        an integer 0-255 for global alpha; ignored if BLIT_ALPHA\n*        not specified in the blitter operations\n*        (see ALPHA_MODE_xxx constants)\n* @param alphaData the alpha blending or mask data, varies depending\n*        on the value of alphaMode and sometimes ignored\n* @param alphaStride the alpha data number of bytes per line\n* @param alphaX the top-left x-coord of the alpha blit region\n* @param alphaY the top-left y-coord of the alpha blit region\n* @param destData the destination byte array containing image data\n* @param destDepth the destination depth: one of 8, 16, 24, 32\n* @param destStride the destination number of bytes per line\n* @param destOrder the destination byte ordering: one of MSB_FIRST or LSB_FIRST;\n*        ignored if destDepth is not 16 or 32\n* @param destX the top-left x-coord of the destination blit region\n* @param destY the top-left y-coord of the destination blit region\n* @param destWidth the width of the destination blit region\n* @param destHeight the height of the destination blit region\n* @param destRedMask the destination red channel mask\n* @param destGreenMask the destination green channel mask\n* @param destBlueMask the destination blue channel mask\n* @param flipX if true the resulting image is flipped along the vertical axis\n* @param flipY if true the resulting image is flipped along the horizontal axis\n*/\n// these should be supplied as params later\n/*** Prepare scaling data ***/\n/*** Prepare source-related data ***/\n//throw new IllegalArgumentException(\"Invalid source type\");\n/*** Prepare destination-related data ***/\n//throw new IllegalArgumentException(\"Invalid destination type\");\n/*** Prepare special processing data ***/\n// prescale\n/*** Comprehensive blit (apply transformations) ***/\n/*** READ NEXT PIXEL ***/\n/*** DO SPECIAL PROCESSING IF REQUIRED ***/\n// could speed up using binary search if we sorted the indices\n// Perform alpha blending\n/*** WRITE NEXT PIXEL ***/\n",
			"methodName":"static void blit(int op, byte[] srcData, int srcDepth, int srcStride, int srcOrder, int srcX, int srcY, int srcWidth, int srcHeight, byte[] srcReds, byte[] srcGreens, byte[] srcBlues, int alphaMode, byte[] alphaData, int alphaStride, int alphaX, int alphaY, byte[] destData, int destDepth, int destStride, int destOrder, int destX, int destY, int destWidth, int destHeight, int destRedMask, int destGreenMask, int destBlueMask, boolean flipX, boolean flipY)"
		},
		"static int closestMatch(int depth, byte red, byte green, byte blue, int redMask, int greenMask, int blueMask, byte[] reds, byte[] greens, byte[] blues)":{
			"methodBody":"{\n    if (depth > 8) {\n        int rshift = 32 - getMSBOffset(redMask);\n        int gshift = 32 - getMSBOffset(greenMask);\n        int bshift = 32 - getMSBOffset(blueMask);\n        return (((red << 24) >>> rshift) & redMask) | (((green << 24) >>> gshift) & greenMask) | (((blue << 24) >>> bshift) & blueMask);\n    }\n    int r, g, b;\n    int minDistance = 0x7fffffff;\n    int nearestPixel = 0;\n    int n = reds.length;\n    for (int j = 0; j < n; j++) {\n        r = (reds[j] & 0xFF) - (red & 0xFF);\n        g = (greens[j] & 0xFF) - (green & 0xFF);\n        b = (blues[j] & 0xFF) - (blue & 0xFF);\n        int distance = r * r + g * g + b * b;\n        if (distance < minDistance) {\n            nearestPixel = j;\n            if (distance == 0)\n                break;\n            minDistance = distance;\n        }\n    }\n    return nearestPixel;\n}",
			"comments":"/**\n* Finds the closest match.\n*/\n",
			"methodName":"static int closestMatch(int depth, byte red, byte green, byte blue, int redMask, int greenMask, int blueMask, byte[] reds, byte[] greens, byte[] blues)"
		},
		"public void setAlphas(int x, int y, int putWidth, byte[] alphas, int startIndex)":{
			"methodBody":"{\n    if (alphas == null)\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\n    if (putWidth < 0 || x >= width || y >= height || x < 0 || y < 0)\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    if (putWidth == 0)\n        return;\n    if (alphaData == null)\n        alphaData = new byte[width * height];\n    \n    System.arraycopy(alphas, startIndex, alphaData, y * width + x, putWidth);\n}",
			"comments":"/**\n* Sets the alpha values starting at offset <code>x</code> in\n* scanline <code>y</code> in the receiver's alpha data to the\n* values from the array <code>alphas</code> starting at\n* <code>startIndex</code>.\n*\n* @param x the x coordinate of the pixel to being setting the alpha values\n* @param y the y coordinate of the pixel to being setting the alpha values\n* @param putWidth the width of the alpha values to set\n* @param alphas the alpha values to set\n* @param startIndex the index at which to begin setting\n*\n* @exception IndexOutOfBoundsException if putWidth is too large\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if pixels is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if x or y is out of bounds</li>\n*    <li>ERROR_INVALID_ARGUMENT - if putWidth is negative</li>\n* </ul>\n*/\n// may throw an IndexOutOfBoundsException\n",
			"methodName":"public void setAlphas(int x, int y, int putWidth, byte[] alphas, int startIndex)"
		},
		"static int getMSBOffset(int mask)":{
			"methodBody":"{\n    for (int i = 31; i >= 0; i--) {\n        if (((mask >> i) & 0x1) != 0)\n            return i + 1;\n    }\n    return 0;\n}",
			"comments":"/**\n* Gets the offset of the most significant bit for\n* the given mask.\n*/\n",
			"methodName":"static int getMSBOffset(int mask)"
		},
		"public ImageData getTransparencyMask()":{
			"methodBody":"{\n    if (getTransparencyType() == SWT.TRANSPARENCY_MASK) {\n        return new ImageData(width, height, 1, bwPalette(), maskPad, maskData);\n    } else {\n        return colorMaskImage(transparentPixel);\n    }\n}",
			"comments":"/**\n* Returns an <code>ImageData</code> which specifies the\n* transparency mask information for the receiver. If the\n* receiver has no transparency or is not an icon, returns\n* an opaque mask.\n*\n* @return the transparency mask\n*/\n",
			"methodName":"public ImageData getTransparencyMask()"
		}
	},
	"ClassORInterfaceName":[
		"ImageData"
	]
}
