{
	"variables":[
		"DEBUG",
		"debug",
		"tracking",
		"errors",
		"objects",
		"hPalette",
		"colorRefCount",
		"systemFont",
		"nFonts",
		"logFonts",
		"metrics",
		"pixels",
		"scripts",
		"gdipToken",
		"disposed",
		"CREATE_LOCK",
		"CurrentDevice",
		"DeviceFinder",
		"device",
		"oldErrorMode",
		"token",
		"input",
		"hDC",
		"pixels",
		"hDC",
		"logPixelsY",
		"pixels",
		"oldFont",
		"lptm",
		"i",
		"isScalable",
		"scalable",
		"newLogFonts",
		"newPixels",
		"logFont",
		"hDC",
		"width",
		"height",
		"data",
		"count",
		"length",
		"i",
		"index",
		"i",
		"hDC",
		"bits",
		"planes",
		"hDC",
		"dpiX",
		"dpiY",
		"callback",
		"lpEnumFontFamProc",
		"i",
		"offset",
		"hDC",
		"i",
		"lf",
		"lpFaceName",
		"logPixelsY",
		"count",
		"result",
		"i",
		"index",
		"error",
		"error",
		"buffer",
		"dwFlags",
		"length",
		"buffer1",
		"pixel",
		"hFont",
		"ppSp",
		"piNumScripts",
		"hDC",
		"rc",
		"bits",
		"planes",
		"numReserved",
		"numEntries",
		"logPalette",
		"lppe",
		"i",
		"i",
		"newObjects",
		"newErrors",
		"DEBUG",
		"DEBUG",
		"Class",
		"DeviceFinder",
		"DeviceFinder",
		"CurrentDevice",
		"CurrentDevice",
		"device",
		"CREATE_LOCK",
		"data",
		"debug",
		"data",
		"tracking",
		"data",
		"data",
		"tracking",
		"errors",
		"objects",
		"systemFont",
		"disposed",
		"SWT",
		"SWT",
		"gdipToken",
		"OS",
		"OS",
		"input",
		"Gdip",
		"token",
		"input",
		"gdipToken",
		"token",
		"SWT",
		"SWT",
		"t",
		"OS",
		"oldErrorMode",
		"Compatibility",
		"height",
		"OS",
		"hDC",
		"OS",
		"hDC",
		"pixels",
		"OS",
		"hDC",
		"OS",
		"logFont",
		"OS",
		"hDC",
		"hFont",
		"OS",
		"OS",
		"hDC",
		"lptm",
		"OS",
		"hDC",
		"oldFont",
		"pixels",
		"logFont",
		"lptm",
		"pixels",
		"logFont",
		"hDC",
		"Compatibility",
		"pixels",
		"logPixelsY",
		"disposed",
		"tracking",
		"objects",
		"errors",
		"i",
		"objects",
		"i",
		"objects",
		"i",
		"object",
		"objects",
		"i",
		"errors",
		"i",
		"FontType",
		"OS",
		"lParam",
		"isScalable",
		"scalable",
		"nFonts",
		"logFonts",
		"logFonts",
		"System",
		"logFonts",
		"newLogFonts",
		"nFonts",
		"logFonts",
		"newLogFonts",
		"newLogFonts",
		"System",
		"pixels",
		"newPixels",
		"nFonts",
		"pixels",
		"newPixels",
		"logFonts",
		"nFonts",
		"logFont",
		"logFont",
		"OS",
		"OS",
		"logFont",
		"lpelfe",
		"LOGFONT",
		"logFonts",
		"nFonts",
		"logFont",
		"logFont",
		"OS",
		"metrics",
		"lpntme",
		"TEXTMETRIC",
		"pixels",
		"nFonts",
		"logFont",
		"metrics",
		"pixels",
		"nFonts",
		"logFont",
		"nFonts",
		"OS",
		"hDC",
		"OS",
		"OS",
		"hDC",
		"OS",
		"hDC",
		"width",
		"height",
		"data",
		"debug",
		"data",
		"tracking",
		"tracking",
		"length",
		"objects",
		"i",
		"length",
		"i",
		"objects",
		"i",
		"count",
		"data",
		"count",
		"data",
		"count",
		"i",
		"length",
		"i",
		"objects",
		"i",
		"data",
		"index",
		"objects",
		"i",
		"data",
		"index",
		"errors",
		"i",
		"index",
		"data",
		"OS",
		"hDC",
		"OS",
		"OS",
		"hDC",
		"OS",
		"hDC",
		"bits",
		"planes",
		"OS",
		"hDC",
		"OS",
		"OS",
		"hDC",
		"OS",
		"hDC",
		"dpiX",
		"dpiY",
		"callback",
		"lpEnumFontFamProc",
		"SWT",
		"SWT",
		"metrics",
		"OS",
		"pixels",
		"nFonts",
		"logFonts",
		"nFonts",
		"i",
		"logFonts",
		"i",
		"logFonts",
		"i",
		"OS",
		"nFonts",
		"faceName",
		"OS",
		"hDC",
		"lpEnumFontFamProc",
		"scalable",
		"offset",
		"nFonts",
		"i",
		"offset",
		"i",
		"logFonts",
		"i",
		"OS",
		"OS",
		"hDC",
		"lf",
		"lpEnumFontFamProc",
		"scalable",
		"OS",
		"hDC",
		"lf",
		"lpEnumFontFamProc",
		"scalable",
		"faceName",
		"OS",
		"hDC",
		"lpFaceName",
		"lpEnumFontFamProc",
		"scalable",
		"OS",
		"hDC",
		"OS",
		"hDC",
		"nFonts",
		"offset",
		"count",
		"i",
		"count",
		"i",
		"i",
		"offset",
		"result",
		"i",
		"FontData",
		"logFonts",
		"index",
		"Compatibility",
		"pixels",
		"index",
		"logPixelsY",
		"callback",
		"logFonts",
		"pixels",
		"metrics",
		"result",
		"OS",
		"error",
		"Integer",
		"error",
		"OS",
		"error",
		"OS",
		"OS",
		"OS",
		"OS",
		"dwFlags",
		"error",
		"OS",
		"buffer",
		"length",
		"Integer",
		"error",
		"length",
		"OS",
		"buffer1",
		"buffer",
		"length",
		"TCHAR",
		"buffer",
		"OS",
		"buffer",
		"buffer1",
		"length",
		"id",
		"SWT",
		"pixel",
		"SWT",
		"pixel",
		"SWT",
		"pixel",
		"SWT",
		"pixel",
		"SWT",
		"pixel",
		"SWT",
		"pixel",
		"SWT",
		"pixel",
		"SWT",
		"pixel",
		"SWT",
		"pixel",
		"SWT",
		"pixel",
		"SWT",
		"pixel",
		"SWT",
		"pixel",
		"SWT",
		"pixel",
		"SWT",
		"pixel",
		"SWT",
		"pixel",
		"SWT",
		"pixel",
		"Color",
		"pixel",
		"OS",
		"OS",
		"Font",
		"hFont",
		"debug",
		"OS",
		"OS",
		"OS",
		"OS",
		"ppSp",
		"piNumScripts",
		"scripts",
		"piNumScripts",
		"OS",
		"scripts",
		"ppSp",
		"scripts",
		"OS",
		"hDC",
		"OS",
		"OS",
		"hDC",
		"OS",
		"OS",
		"hDC",
		"OS",
		"bits",
		"planes",
		"rc",
		"OS",
		"bits",
		"hDC",
		"OS",
		"hDC",
		"OS",
		"OS",
		"hDC",
		"OS",
		"OS",
		"numReserved",
		"numEntries",
		"numReserved",
		"colorRefCount",
		"numEntries",
		"numEntries",
		"logPalette",
		"logPalette",
		"logPalette",
		"logPalette",
		"numEntries",
		"OS",
		"hDC",
		"numEntries",
		"lppe",
		"System",
		"lppe",
		"logPalette",
		"numEntries",
		"i",
		"numReserved",
		"i",
		"colorRefCount",
		"i",
		"colorRefCount",
		"numEntries",
		"i",
		"hDC",
		"hPalette",
		"OS",
		"logPalette",
		"disposed",
		"i",
		"objects",
		"i",
		"objects",
		"i",
		"objects",
		"i",
		"object",
		"errors",
		"i",
		"objects",
		"System",
		"objects",
		"newObjects",
		"objects",
		"newObjects",
		"objects",
		"object",
		"objects",
		"newObjects",
		"errors",
		"System",
		"errors",
		"newErrors",
		"errors",
		"newErrors",
		"errors",
		"errors",
		"newErrors",
		"gdipToken",
		"Gdip",
		"gdipToken",
		"gdipToken",
		"scripts",
		"hPalette",
		"OS",
		"hPalette",
		"hPalette",
		"colorRefCount",
		"logFonts",
		"nFonts",
		"debug",
		"tracking",
		"handle",
		"ERROR_DEVICE_DISPOSED",
		"SEM_FAILCRITICALERRORS",
		"GdiplusVersion",
		"ERROR_NO_GRAPHICS_LIBRARY",
		"LOGPIXELSY",
		"LOGPIXELSY",
		"lfHeight",
		"IsUnicode",
		"lfHeight",
		"tmInternalLeading",
		"lfHeight",
		"length",
		"RASTER_FONTTYPE",
		"length",
		"length",
		"length",
		"IsUnicode",
		"sizeof",
		"lfHeight",
		"sizeof",
		"lfHeight",
		"tmInternalLeading",
		"lfHeight",
		"HORZRES",
		"VERTRES",
		"debug",
		"tracking",
		"length",
		"objects",
		"errors",
		"objects",
		"errors",
		"BITSPIXEL",
		"PLANES",
		"LOGPIXELSX",
		"LOGPIXELSY",
		"ERROR_NO_MORE_CALLBACKS",
		"IsUnicode",
		"length",
		"IsUnicode",
		"IsUnicode",
		"lfFaceName",
		"lfFaceName",
		"LOGPIXELSY",
		"FORMAT_MESSAGE_ALLOCATE_BUFFER",
		"FORMAT_MESSAGE_FROM_SYSTEM",
		"FORMAT_MESSAGE_IGNORE_INSERTS",
		"LANG_USER_DEFAULT",
		"sizeof",
		"COLOR_WHITE",
		"COLOR_BLACK",
		"COLOR_RED",
		"COLOR_DARK_RED",
		"COLOR_GREEN",
		"COLOR_DARK_GREEN",
		"COLOR_YELLOW",
		"COLOR_DARK_YELLOW",
		"COLOR_BLUE",
		"COLOR_DARK_BLUE",
		"COLOR_MAGENTA",
		"COLOR_DARK_MAGENTA",
		"COLOR_CYAN",
		"COLOR_DARK_CYAN",
		"COLOR_GRAY",
		"COLOR_DARK_GRAY",
		"SYSTEM_FONT",
		"IsWinCE",
		"IsWinCE",
		"length",
		"RASTERCAPS",
		"BITSPIXEL",
		"PLANES",
		"RC_PALETTE",
		"NUMRESERVED",
		"SIZEPALETTE",
		"IsWinCE",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"e",
		"data",
		"t",
		"data",
		"height",
		"logFont",
		"hFont",
		"object",
		"lpelfe",
		"lpntme",
		"FontType",
		"lParam",
		"faceName",
		"scalable",
		"id",
		"data",
		"hDC",
		"data",
		"object",
		"warnings"
	],
	"extendORImplementFiles":[
		"Drawable"
	],
	"package":[
		"org.eclipse.swt.graphics"
	],
	"import":[
		"org.eclipse.swt.internal",
		"org.eclipse.swt.internal.gdip",
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt"
	],
	"methods":[
		"getDevice",
		"checkDevice",
		"checkGDIP",
		"create",
		"computePixels",
		"computePoints",
		"destroy",
		"dispose",
		"dispose_Object",
		"EnumFontFamProc",
		"getBounds",
		"getDeviceData",
		"getClientArea",
		"getDepth",
		"getDPI",
		"getFontList",
		"getLastError",
		"getLastErrorText",
		"getSystemColor",
		"getSystemFont",
		"getWarnings",
		"init",
		"internal_new_GC",
		"internal_dispose_GC",
		"isDisposed",
		"new_Object",
		"release",
		"setWarnings",
		"forName",
		"run",
		"create",
		"init",
		"getSystemFont",
		"error",
		"SetErrorMode",
		"GdiplusStartup",
		"error",
		"SetErrorMode",
		"internal_new_GC",
		"round",
		"GetDeviceCaps",
		"internal_dispose_GC",
		"internal_new_GC",
		"GetDeviceCaps",
		"SelectObject",
		"GetTextMetrics",
		"SelectObject",
		"internal_dispose_GC",
		"round",
		"isDisposed",
		"checkDevice",
		"release",
		"destroy",
		"arraycopy",
		"arraycopy",
		"MoveMemory",
		"MoveMemory",
		"checkDevice",
		"internal_new_GC",
		"GetDeviceCaps",
		"GetDeviceCaps",
		"internal_dispose_GC",
		"checkDevice",
		"getBounds",
		"checkDevice",
		"internal_new_GC",
		"GetDeviceCaps",
		"GetDeviceCaps",
		"internal_dispose_GC",
		"checkDevice",
		"internal_new_GC",
		"GetDeviceCaps",
		"GetDeviceCaps",
		"internal_dispose_GC",
		"checkDevice",
		"getAddress",
		"error",
		"internal_new_GC",
		"EnumFontFamilies",
		"EnumFontFamiliesW",
		"EnumFontFamiliesA",
		"EnumFontFamilies",
		"GetDeviceCaps",
		"internal_dispose_GC",
		"win32_new",
		"round",
		"dispose",
		"GetLastError",
		"toHexString",
		"GetLastError",
		"FormatMessage",
		"toHexString",
		"MoveMemory",
		"LocalFree",
		"toString",
		"checkDevice",
		"win32_new",
		"checkDevice",
		"GetStockObject",
		"win32_new",
		"checkDevice",
		"GdiSetBatchLimit",
		"ScriptGetProperties",
		"MoveMemory",
		"internal_new_GC",
		"GetDeviceCaps",
		"GetDeviceCaps",
		"GetDeviceCaps",
		"internal_dispose_GC",
		"GetDeviceCaps",
		"GetDeviceCaps",
		"GetSystemPaletteEntries",
		"arraycopy",
		"internal_dispose_GC",
		"CreatePalette",
		"arraycopy",
		"arraycopy",
		"GdiplusShutdown",
		"DeleteObject",
		"checkDevice",
		"Object",
		"GdiplusStartupInput",
		"TEXTMETRICW",
		"TEXTMETRICA",
		"LOGFONTW",
		"LOGFONTA",
		"Rectangle",
		"DeviceData",
		"Point",
		"Callback",
		"TEXTMETRICW",
		"TEXTMETRICA",
		"LOGFONTW",
		"LOGFONTA",
		"TCHAR",
		"TCHAR",
		"Error",
		"Error"
	],
	"methodsBody":{
		"protected void create(DeviceData data)":{
			"methodBody":"{\n}",
			"comments":"/**\n* Creates the device in the operating system.  If the device\n* does not have a handle, this method may do nothing depending\n* on the device.\n* <p>\n* This method is called before <code>init</code>.\n* </p><p>\n* Subclasses are supposed to reimplement this method and not\n* call the <code>super</code> implementation.\n* </p>\n*\n* @param data the DeviceData which describes the receiver\n*\n* @see #init\n*/\n",
			"methodName":"protected void create(DeviceData data)"
		},
		"public DeviceData getDeviceData()":{
			"methodBody":"{\n    checkDevice();\n    DeviceData data = new DeviceData();\n    data.debug = debug;\n    data.tracking = tracking;\n    int count = 0, length = 0;\n    if (tracking)\n        length = objects.length;\n    for (int i = 0; i < length; i++) {\n        if (objects[i] != null)\n            count++;\n    }\n    int index = 0;\n    data.objects = new Object[count];\n    data.errors = new Error[count];\n    for (int i = 0; i < length; i++) {\n        if (objects[i] != null) {\n            data.objects[index] = objects[i];\n            data.errors[index] = errors[i];\n            index++;\n        }\n    }\n    return data;\n}",
			"comments":"/**\n* Returns a <code>DeviceData</code> based on the receiver.\n* Modifications made to this <code>DeviceData</code> will not\n* affect the receiver.\n*\n* @return a <code>DeviceData</code> containing the device's data and attributes\n*\n* @exception SWTException <ul>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see DeviceData\n*/\n",
			"methodName":"public DeviceData getDeviceData()"
		},
		"protected void destroy()":{
			"methodBody":"{\n}",
			"comments":"/**\n* Destroys the device in the operating system and releases\n* the device's handle.  If the device does not have a handle,\n* this method may do nothing depending on the device.\n* <p>\n* This method is called after <code>release</code>.\n* </p><p>\n* Subclasses are supposed to reimplement this method and not\n* call the <code>super</code> implementation.\n* </p>\n*\n* @see #dispose\n* @see #release\n*/\n",
			"methodName":"protected void destroy()"
		},
		"public boolean isDisposed()":{
			"methodBody":"{\n    return disposed;\n}",
			"comments":"/**\n* Returns <code>true</code> if the device has been disposed,\n* and <code>false</code> otherwise.\n* <p>\n* This method gets the dispose state for the device.\n* When a device has been disposed, it is an error to\n* invoke any other method using the device.\n*\n* @return <code>true</code> when the device is disposed and <code>false</code> otherwise\n*/\n",
			"methodName":"public boolean isDisposed()"
		},
		"public int getDepth()":{
			"methodBody":"{\n    checkDevice();\n    int hDC = internal_new_GC(null);\n    int bits = OS.GetDeviceCaps(hDC, OS.BITSPIXEL);\n    int planes = OS.GetDeviceCaps(hDC, OS.PLANES);\n    internal_dispose_GC(hDC, null);\n    return bits * planes;\n}",
			"comments":"/**\n* Returns the bit depth of the screen, which is the number of\n* bits it takes to represent the number of unique colors that\n* the screen is currently capable of displaying. This number\n* will typically be one of 1, 8, 15, 16, 24 or 32.\n*\n* @return the depth of the screen\n*\n* @exception SWTException <ul>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public int getDepth()"
		},
		"public Rectangle getClientArea()":{
			"methodBody":"{\n    return getBounds();\n}",
			"comments":"/**\n* Returns a rectangle which describes the area of the\n* receiver which is capable of displaying data.\n*\n* @return the client area\n*\n* @exception SWTException <ul>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #getBounds\n*/\n",
			"methodName":"public Rectangle getClientArea()"
		},
		"int computePoints(LOGFONT logFont, int hFont)":{
			"methodBody":"{\n    int hDC = internal_new_GC(null);\n    int logPixelsY = OS.GetDeviceCaps(hDC, OS.LOGPIXELSY);\n    int pixels = 0;\n    if (logFont.lfHeight > 0) {\n        \n        int oldFont = OS.SelectObject(hDC, hFont);\n        TEXTMETRIC lptm = OS.IsUnicode ? (TEXTMETRIC) new TEXTMETRICW() : new TEXTMETRICA();\n        OS.GetTextMetrics(hDC, lptm);\n        OS.SelectObject(hDC, oldFont);\n        pixels = logFont.lfHeight - lptm.tmInternalLeading;\n    } else {\n        pixels = -logFont.lfHeight;\n    }\n    internal_dispose_GC(hDC, null);\n    return Compatibility.round(pixels * 72, logPixelsY);\n}",
			"comments":"/*\n* Feature in Windows. If the lfHeight of the LOGFONT structure\n* is positive, the lfHeight measures the height of the entire\n* cell, including internal leading, in logical units. Since the\n* height of a font in points does not include the internal leading,\n* we must subtract the internal leading, which requires a TEXTMETRIC.\n*/\n",
			"methodName":"int computePoints(LOGFONT logFont, int hFont)"
		},
		"public void setWarnings(boolean warnings)":{
			"methodBody":"{\n    checkDevice();\n}",
			"comments":"/**\n* If the underlying window system supports printing warning messages\n* to the console, setting warnings to <code>false</code> prevents these\n* messages from being printed. If the argument is <code>true</code> then\n* message printing is not blocked.\n*\n* @param warnings <code>true</code>if warnings should be printed, and <code>false</code> otherwise\n*\n* @exception SWTException <ul>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void setWarnings(boolean warnings)"
		},
		"String getLastError()":{
			"methodBody":"{\n    int error = OS.GetLastError();\n    \n    if (error == 0)\n        return \"\";\n    \n    return \" [GetLastError=0x\" + Integer.toHexString(error) + \"]\";\n}",
			"comments":"//$NON-NLS-1$\n//$NON-NLS-1$ //$NON-NLS-2$\n",
			"methodName":"String getLastError()"
		},
		"void checkGDIP()":{
			"methodBody":"{\n    if (gdipToken != null)\n        return;\n    int oldErrorMode = OS.SetErrorMode(OS.SEM_FAILCRITICALERRORS);\n    try {\n        int[] token = new int[1];\n        GdiplusStartupInput input = new GdiplusStartupInput();\n        input.GdiplusVersion = 1;\n        if (Gdip.GdiplusStartup(token, input, 0) == 0) {\n            gdipToken = token;\n        }\n    } catch (Throwable t) {\n        \n        SWT.error(SWT.ERROR_NO_GRAPHICS_LIBRARY, t, \" [GDI+ is required]\");\n    } finally {\n        OS.SetErrorMode(oldErrorMode);\n    }\n}",
			"comments":"//$NON-NLS-1$\n",
			"methodName":"void checkGDIP()"
		},
		"String getLastErrorText()":{
			"methodBody":"{\n    int error = OS.GetLastError();\n    \n    if (error == 0)\n        return \"\";\n    int[] buffer = new int[1];\n    int dwFlags = OS.FORMAT_MESSAGE_ALLOCATE_BUFFER | OS.FORMAT_MESSAGE_FROM_SYSTEM | OS.FORMAT_MESSAGE_IGNORE_INSERTS;\n    int length = OS.FormatMessage(dwFlags, 0, error, OS.LANG_USER_DEFAULT, buffer, 0, 0);\n    \n    if (length == 0)\n        return \" [GetLastError=0x\" + Integer.toHexString(error) + \"]\";\n    TCHAR buffer1 = new TCHAR(0, length);\n    OS.MoveMemory(buffer1, buffer[0], length * TCHAR.sizeof);\n    if (buffer[0] != 0)\n        OS.LocalFree(buffer[0]);\n    return buffer1.toString(0, length);\n}",
			"comments":"//$NON-NLS-1$\n//$NON-NLS-1$ //$NON-NLS-2$\n",
			"methodName":"String getLastErrorText()"
		},
		"protected void init()":{
			"methodBody":"{\n    if (debug) {\n        if (!OS.IsWinCE)\n            OS.GdiSetBatchLimit(1);\n    }\n    \n    if (!OS.IsWinCE) {\n        int[] ppSp = new int[1];\n        int[] piNumScripts = new int[1];\n        OS.ScriptGetProperties(ppSp, piNumScripts);\n        scripts = new int[piNumScripts[0]];\n        OS.MoveMemory(scripts, ppSp[0], scripts.length * 4);\n    }\n    \n    int hDC = internal_new_GC(null);\n    int rc = OS.GetDeviceCaps(hDC, OS.RASTERCAPS);\n    int bits = OS.GetDeviceCaps(hDC, OS.BITSPIXEL);\n    int planes = OS.GetDeviceCaps(hDC, OS.PLANES);\n    bits *= planes;\n    if ((rc & OS.RC_PALETTE) == 0 || bits != 8) {\n        internal_dispose_GC(hDC, null);\n        return;\n    }\n    int numReserved = OS.GetDeviceCaps(hDC, OS.NUMRESERVED);\n    int numEntries = OS.GetDeviceCaps(hDC, OS.SIZEPALETTE);\n    if (OS.IsWinCE) {\n        \n        if (numReserved == 0 && numEntries >= 20)\n            numReserved = 20;\n    }\n    \n    colorRefCount = new int[numEntries];\n    \n    byte[] logPalette = new byte[4 + 4 * numEntries];\n    \n    logPalette[0] = 0x00;\n    logPalette[1] = 0x03;\n    \n    logPalette[2] = 0;\n    logPalette[3] = 1;\n    \n    byte[] lppe = new byte[4 * numEntries];\n    OS.GetSystemPaletteEntries(hDC, 0, numEntries, lppe);\n    \n    System.arraycopy(lppe, 0, logPalette, 4, 4 * numEntries);\n    \n    for (int i = 0; i < numReserved / 2; i++) {\n        colorRefCount[i] = 1;\n        colorRefCount[numEntries - 1 - i] = 1;\n    }\n    internal_dispose_GC(hDC, null);\n    hPalette = OS.CreatePalette(logPalette);\n}",
			"comments":"/**\n* Initializes any internal resources needed by the\n* device.\n* <p>\n* This method is called after <code>create</code>.\n* </p><p>\n* If subclasses reimplement this method, they must\n* call the <code>super</code> implementation.\n* </p>\n*\n* @see #create\n*/\n/* Initialize scripts list */\n/*\n* If we're not on a device which supports palettes,\n* don't create one.\n*/\n/*\n* Feature on WinCE.  For some reason, certain 8 bit WinCE\n* devices return 0 for the number of reserved entries in\n* the system palette.  Their system palette correctly contains\n* the usual 20 system colors.  The workaround is to assume\n* there are 20 reserved system colors instead of 0.\n*/\n/* Create the palette and reference counter */\n/* 4 bytes header + 4 bytes per entry * numEntries entries */\n/* 2 bytes = special header */\n/* 2 bytes = number of colors, LSB first */\n/*\n* Create a palette which contains the system entries\n* as they are located in the system palette.  The\n* MSDN article 'Memory Device Contexts' describes\n* where system entries are located.  On an 8 bit\n* display with 20 reserved colors, the system colors\n* will be the first 10 entries and the last 10 ones.\n*/\n/* Copy all entries from the system palette */\n/* Lock the indices corresponding to the system entries */\n",
			"methodName":"protected void init()"
		},
		"void dispose_Object(Object object)":{
			"methodBody":"{\n    for (int i = 0; i < objects.length; i++) {\n        if (objects[i] == object) {\n            objects[i] = null;\n            errors[i] = null;\n            return;\n        }\n    }\n}",
			"comments":"",
			"methodName":"void dispose_Object(Object object)"
		},
		"public Font getSystemFont()":{
			"methodBody":"{\n    checkDevice();\n    int hFont = OS.GetStockObject(OS.SYSTEM_FONT);\n    return Font.win32_new(this, hFont);\n}",
			"comments":"/**\n* Returns a reasonable font for applications to use.\n* On some platforms, this will match the \"default font\"\n* or \"system font\" if such can be found.  This font\n* should not be freed because it was allocated by the\n* system, not the application.\n* <p>\n* Typically, applications which want the default look\n* should simply not set the font on the widgets they\n* create. Widgets are always created with the correct\n* default font for the class of user-interface component\n* they represent.\n* </p>\n*\n* @return a font\n*\n* @exception SWTException <ul>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public Font getSystemFont()"
		},
		"public void dispose()":{
			"methodBody":"{\n    if (isDisposed())\n        return;\n    checkDevice();\n    release();\n    destroy();\n    disposed = true;\n    if (tracking) {\n        objects = null;\n        errors = null;\n    }\n}",
			"comments":"/**\n* Disposes of the operating system resources associated with\n* the receiver. After this method has been invoked, the receiver\n* will answer <code>true</code> when sent the message\n* <code>isDisposed()</code>.\n*\n* @see #release\n* @see #destroy\n* @see #checkDevice\n*/\n",
			"methodName":"public void dispose()"
		},
		"public boolean getWarnings()":{
			"methodBody":"{\n    checkDevice();\n    return false;\n}",
			"comments":"/**\n* Returns <code>true</code> if the underlying window system prints out\n* warning messages on the console, and <code>setWarnings</code>\n* had previously been called with <code>true</code>.\n*\n* @return <code>true</code>if warnings are being handled, and <code>false</code> otherwise\n*\n* @exception SWTException <ul>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public boolean getWarnings()"
		},
		"public Rectangle getBounds()":{
			"methodBody":"{\n    checkDevice();\n    int hDC = internal_new_GC(null);\n    int width = OS.GetDeviceCaps(hDC, OS.HORZRES);\n    int height = OS.GetDeviceCaps(hDC, OS.VERTRES);\n    internal_dispose_GC(hDC, null);\n    return new Rectangle(0, 0, width, height);\n}",
			"comments":"/**\n* Returns a rectangle describing the receiver's size and location.\n*\n* @return the bounding rectangle\n*\n* @exception SWTException <ul>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public Rectangle getBounds()"
		},
		"public abstract int internal_new_GC(GCData data)":{
			"methodBody":"",
			"comments":"/**\n* Invokes platform specific functionality to allocate a new GC handle.\n* <p>\n* <b>IMPORTANT:</b> This method is <em>not</em> part of the public\n* API for <code>Device</code>. It is marked public only so that it\n* can be shared within the packages provided by SWT. It is not\n* available on all platforms, and should never be called from\n* application code.\n* </p>\n*\n* @param data the platform specific GC data\n* @return the platform specific GC handle\n*/\n",
			"methodName":"public abstract int internal_new_GC(GCData data)"
		},
		"public Point getDPI()":{
			"methodBody":"{\n    checkDevice();\n    int hDC = internal_new_GC(null);\n    int dpiX = OS.GetDeviceCaps(hDC, OS.LOGPIXELSX);\n    int dpiY = OS.GetDeviceCaps(hDC, OS.LOGPIXELSY);\n    internal_dispose_GC(hDC, null);\n    return new Point(dpiX, dpiY);\n}",
			"comments":"/**\n* Returns a point whose x coordinate is the horizontal\n* dots per inch of the display, and whose y coordinate\n* is the vertical dots per inch of the display.\n*\n* @return the horizontal and vertical DPI\n*\n* @exception SWTException <ul>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public Point getDPI()"
		},
		"static synchronized Device getDevice()":{
			"methodBody":"{\n    if (DeviceFinder != null)\n        DeviceFinder.run();\n    Device device = CurrentDevice;\n    CurrentDevice = null;\n    return device;\n}",
			"comments":"/*\n* TEMPORARY CODE.\n*/\n",
			"methodName":"static synchronized Device getDevice()"
		},
		"int computePixels(int height)":{
			"methodBody":"{\n    int hDC = internal_new_GC(null);\n    int pixels = -Compatibility.round(height * OS.GetDeviceCaps(hDC, OS.LOGPIXELSY), 72);\n    internal_dispose_GC(hDC, null);\n    return pixels;\n}",
			"comments":"",
			"methodName":"int computePixels(int height)"
		},
		"public FontData[] getFontList(String faceName, boolean scalable)":{
			"methodBody":"{\n    checkDevice();\n    \n    \n    Callback callback = new Callback(this, \"EnumFontFamProc\", 4);\n    int lpEnumFontFamProc = callback.getAddress();\n    if (lpEnumFontFamProc == 0)\n        SWT.error(SWT.ERROR_NO_MORE_CALLBACKS);\n    \n    metrics = OS.IsUnicode ? (TEXTMETRIC) new TEXTMETRICW() : new TEXTMETRICA();\n    pixels = new int[nFonts];\n    logFonts = new LOGFONT[nFonts];\n    for (int i = 0; i < logFonts.length; i++) {\n        logFonts[i] = OS.IsUnicode ? (LOGFONT) new LOGFONTW() : new LOGFONTA();\n    }\n    nFonts = 0;\n    \n    int offset = 0;\n    int hDC = internal_new_GC(null);\n    if (faceName == null) {\n        \n        OS.EnumFontFamilies(hDC, null, lpEnumFontFamProc, scalable ? 1 : 0);\n        \n        offset = nFonts;\n        for (int i = 0; i < offset; i++) {\n            LOGFONT lf = logFonts[i];\n            \n            if (OS.IsUnicode) {\n                OS.EnumFontFamiliesW(hDC, ((LOGFONTW) lf).lfFaceName, lpEnumFontFamProc, scalable ? 1 : 0);\n            } else {\n                OS.EnumFontFamiliesA(hDC, ((LOGFONTA) lf).lfFaceName, lpEnumFontFamProc, scalable ? 1 : 0);\n            }\n        }\n    } else {\n        \n        TCHAR lpFaceName = new TCHAR(0, faceName, true);\n        \n        OS.EnumFontFamilies(hDC, lpFaceName, lpEnumFontFamProc, scalable ? 1 : 0);\n    }\n    int logPixelsY = OS.GetDeviceCaps(hDC, OS.LOGPIXELSY);\n    internal_dispose_GC(hDC, null);\n    \n    int count = nFonts - offset;\n    FontData[] result = new FontData[count];\n    for (int i = 0; i < count; i++) {\n        int index = i + offset;\n        result[i] = FontData.win32_new(logFonts[index], Compatibility.round(pixels[index] * 72, logPixelsY));\n    }\n    \n    callback.dispose();\n    logFonts = null;\n    pixels = null;\n    metrics = null;\n    return result;\n}",
			"comments":"/**\n* Returns <code>FontData</code> objects which describe\n* the fonts that match the given arguments. If the\n* <code>faceName</code> is null, all fonts will be returned.\n*\n* @param faceName the name of the font to look for, or null\n* @param scalable if true only scalable fonts are returned, otherwise only non-scalable fonts are returned.\n* @return the matching font data\n*\n* @exception SWTException <ul>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n/* Create the callback */\n//$NON-NLS-1$\n/* Initialize the instance variables */\n/* Enumerate */\n/* The user did not specify a face name, so they want all versions of all available face names */\n/**\n* For bitmapped fonts, EnumFontFamilies only enumerates once for each font, regardless\n* of how many styles are available. If the user wants bitmapped fonts, enumerate on\n* each face name now.\n*/\n/**\n* Bug in Windows 98. When EnumFontFamiliesEx is called with a specified face name, it\n* should enumerate for each available style of that font. Instead, it only enumerates\n* once. The fix is to call EnumFontFamilies, which works as expected.\n*/\n/* Use the character encoding for the default locale */\n/**\n* Bug in Windows 98. When EnumFontFamiliesEx is called with a specified face name, it\n* should enumerate for each available style of that font. Instead, it only enumerates\n* once. The fix is to call EnumFontFamilies, which works as expected.\n*/\n/* Create the fontData from the logfonts */\n/* Clean up */\n",
			"methodName":"public FontData[] getFontList(String faceName, boolean scalable)"
		},
		"int EnumFontFamProc(int lpelfe, int lpntme, int FontType, int lParam)":{
			"methodBody":"{\n    boolean isScalable = (FontType & OS.RASTER_FONTTYPE) == 0;\n    boolean scalable = lParam == 1;\n    if (isScalable == scalable) {\n        \n        if (nFonts == logFonts.length) {\n            LOGFONT[] newLogFonts = new LOGFONT[logFonts.length + 128];\n            System.arraycopy(logFonts, 0, newLogFonts, 0, nFonts);\n            logFonts = newLogFonts;\n            int[] newPixels = new int[newLogFonts.length];\n            System.arraycopy(pixels, 0, newPixels, 0, nFonts);\n            pixels = newPixels;\n        }\n        LOGFONT logFont = logFonts[nFonts];\n        if (logFont == null)\n            logFont = OS.IsUnicode ? (LOGFONT) new LOGFONTW() : new LOGFONTA();\n        OS.MoveMemory(logFont, lpelfe, LOGFONT.sizeof);\n        logFonts[nFonts] = logFont;\n        if (logFont.lfHeight > 0) {\n            \n            OS.MoveMemory(metrics, lpntme, TEXTMETRIC.sizeof);\n            pixels[nFonts] = logFont.lfHeight - metrics.tmInternalLeading;\n        } else {\n            pixels[nFonts] = -logFont.lfHeight;\n        }\n        nFonts++;\n    }\n    return 1;\n}",
			"comments":"/* Add the log font to the list of log fonts */\n/*\n* Feature in Windows. If the lfHeight of the LOGFONT structure\n* is positive, the lfHeight measures the height of the entire\n* cell, including internal leading, in logical units. Since the\n* height of a font in points does not include the internal leading,\n* we must subtract the internal leading, which requires a TEXTMETRIC,\n* which in turn requires font creation.\n*/\n",
			"methodName":"int EnumFontFamProc(int lpelfe, int lpntme, int FontType, int lParam)"
		},
		"void new_Object(Object object)":{
			"methodBody":"{\n    for (int i = 0; i < objects.length; i++) {\n        if (objects[i] == null) {\n            objects[i] = object;\n            errors[i] = new Error();\n            return;\n        }\n    }\n    Object[] newObjects = new Object[objects.length + 128];\n    System.arraycopy(objects, 0, newObjects, 0, objects.length);\n    newObjects[objects.length] = object;\n    objects = newObjects;\n    Error[] newErrors = new Error[errors.length + 128];\n    System.arraycopy(errors, 0, newErrors, 0, errors.length);\n    newErrors[errors.length] = new Error();\n    errors = newErrors;\n}",
			"comments":"",
			"methodName":"void new_Object(Object object)"
		},
		"protected void checkDevice()":{
			"methodBody":"{\n    if (disposed)\n        SWT.error(SWT.ERROR_DEVICE_DISPOSED);\n}",
			"comments":"/**\n* Throws an <code>SWTException</code> if the receiver can not\n* be accessed by the caller. This may include both checks on\n* the state of the receiver and more generally on the entire\n* execution context. This method <em>should</em> be called by\n* device implementors to enforce the standard SWT invariants.\n* <p>\n* Currently, it is an error to invoke any method (other than\n* <code>isDisposed()</code> and <code>dispose()</code>) on a\n* device that has had its <code>dispose()</code> method called.\n* </p><p>\n* In future releases of SWT, there may be more or fewer error\n* checks and exceptions may be thrown for different reasons.\n* <p>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"protected void checkDevice()"
		},
		"public Color getSystemColor(int id)":{
			"methodBody":"{\n    checkDevice();\n    int pixel = 0x02000000;\n    switch(id) {\n        case SWT.COLOR_WHITE:\n            pixel = 0x02FFFFFF;\n            break;\n        case SWT.COLOR_BLACK:\n            pixel = 0x02000000;\n            break;\n        case SWT.COLOR_RED:\n            pixel = 0x020000FF;\n            break;\n        case SWT.COLOR_DARK_RED:\n            pixel = 0x02000080;\n            break;\n        case SWT.COLOR_GREEN:\n            pixel = 0x0200FF00;\n            break;\n        case SWT.COLOR_DARK_GREEN:\n            pixel = 0x02008000;\n            break;\n        case SWT.COLOR_YELLOW:\n            pixel = 0x0200FFFF;\n            break;\n        case SWT.COLOR_DARK_YELLOW:\n            pixel = 0x02008080;\n            break;\n        case SWT.COLOR_BLUE:\n            pixel = 0x02FF0000;\n            break;\n        case SWT.COLOR_DARK_BLUE:\n            pixel = 0x02800000;\n            break;\n        case SWT.COLOR_MAGENTA:\n            pixel = 0x02FF00FF;\n            break;\n        case SWT.COLOR_DARK_MAGENTA:\n            pixel = 0x02800080;\n            break;\n        case SWT.COLOR_CYAN:\n            pixel = 0x02FFFF00;\n            break;\n        case SWT.COLOR_DARK_CYAN:\n            pixel = 0x02808000;\n            break;\n        case SWT.COLOR_GRAY:\n            pixel = 0x02C0C0C0;\n            break;\n        case SWT.COLOR_DARK_GRAY:\n            pixel = 0x02808080;\n            break;\n    }\n    return Color.win32_new(this, pixel);\n}",
			"comments":"/**\n* Returns the matching standard color for the given\n* constant, which should be one of the color constants\n* specified in class <code>SWT</code>. Any value other\n* than one of the SWT color constants which is passed\n* in will result in the color black. This color should\n* not be freed because it was allocated by the system,\n* not the application.\n*\n* @param id the color constant\n* @return the matching color\n*\n* @exception SWTException <ul>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see SWT\n*/\n",
			"methodName":"public Color getSystemColor(int id)"
		},
		"public abstract void internal_dispose_GC(int hDC, GCData data)":{
			"methodBody":"",
			"comments":"/**\n* Invokes platform specific functionality to dispose a GC handle.\n* <p>\n* <b>IMPORTANT:</b> This method is <em>not</em> part of the public\n* API for <code>Device</code>. It is marked public only so that it\n* can be shared within the packages provided by SWT. It is not\n* available on all platforms, and should never be called from\n* application code.\n* </p>\n*\n* @param hDC the platform specific GC handle\n* @param data the platform specific GC data\n*/\n",
			"methodName":"public abstract void internal_dispose_GC(int hDC, GCData data)"
		},
		"protected void release()":{
			"methodBody":"{\n    if (gdipToken != null) {\n        Gdip.GdiplusShutdown(gdipToken);\n    }\n    gdipToken = null;\n    scripts = null;\n    if (hPalette != 0)\n        OS.DeleteObject(hPalette);\n    hPalette = 0;\n    colorRefCount = null;\n    logFonts = null;\n    nFonts = 0;\n}",
			"comments":"/**\n* Releases any internal resources back to the operating\n* system and clears all fields except the device handle.\n* <p>\n* When a device is destroyed, resources that were acquired\n* on behalf of the programmer need to be returned to the\n* operating system.  For example, if the device allocated a\n* font to be used as the system font, this font would be\n* freed in <code>release</code>.  Also,to assist the garbage\n* collector and minimize the amount of memory that is not\n* reclaimed when the programmer keeps a reference to a\n* disposed device, all fields except the handle are zero'd.\n* The handle is needed by <code>destroy</code>.\n* </p>\n* This method is called before <code>destroy</code>.\n* </p><p>\n* If subclasses reimplement this method, they must\n* call the <code>super</code> implementation.\n* </p>\n*\n* @see #dispose\n* @see #destroy\n*/\n",
			"methodName":"protected void release()"
		}
	},
	"ClassORInterfaceName":[
		"Device"
	]
}
