{
	"variables":[
		"text",
		"image",
		"image2",
		"font",
		"hCopiedBitmap",
		"LabelProc",
		"LabelClass",
		"ICON_WIDTH",
		"ICON_HEIGHT",
		"lpWndClass",
		"hasAlpha",
		"hImage",
		"imageBits",
		"fImageType",
		"data",
		"rect",
		"gc",
		"gc",
		"rect",
		"newBits",
		"oldBits",
		"flags",
		"width",
		"height",
		"border",
		"lineWidth",
		"bits",
		"isBitmap",
		"isIcon",
		"rect",
		"hDC",
		"newFont",
		"oldFont",
		"rect",
		"flags",
		"length",
		"buffer",
		"tm",
		"bits",
		"control",
		"children",
		"index",
		"mnemonic",
		"bits",
		"newBits",
		"oldBits",
		"hFont",
		"buffer",
		"bits",
		"bits",
		"bits",
		"result",
		"bits",
		"isBitmap",
		"isIcon",
		"result",
		"result",
		"bits",
		"isBitmap",
		"isIcon",
		"result",
		"control",
		"rect",
		"result",
		"struct",
		"rect",
		"lineWidth",
		"flags",
		"bottom",
		"right",
		"OS",
		"LabelClass",
		"lpWndClass",
		"LabelProc",
		"lpWndClass",
		"parent",
		"style",
		"image2",
		"image2",
		"image2",
		"hCopiedBitmap",
		"OS",
		"hCopiedBitmap",
		"hCopiedBitmap",
		"image",
		"image",
		"SWT",
		"image",
		"OS",
		"image",
		"data",
		"SWT",
		"rect",
		"ICON_WIDTH",
		"rect",
		"ICON_HEIGHT",
		"image2",
		"display",
		"data",
		"data",
		"hImage",
		"image2",
		"imageBits",
		"OS",
		"fImageType",
		"OS",
		"SWT",
		"image2",
		"display",
		"rect",
		"rect",
		"image2",
		"gc",
		"gc",
		"rect",
		"gc",
		"image",
		"gc",
		"hImage",
		"image2",
		"imageBits",
		"OS",
		"fImageType",
		"OS",
		"SWT",
		"hImage",
		"image",
		"imageBits",
		"OS",
		"fImageType",
		"OS",
		"data",
		"data",
		"data",
		"hasAlpha",
		"hImage",
		"Display",
		"image",
		"data",
		"data",
		"data",
		"hImage",
		"image",
		"data",
		"display",
		"image2",
		"display",
		"data",
		"data",
		"image2",
		"gc",
		"image",
		"gc",
		"hImage",
		"image2",
		"imageBits",
		"OS",
		"fImageType",
		"OS",
		"SWT",
		"hImage",
		"image",
		"imageBits",
		"OS",
		"fImageType",
		"OS",
		"OS",
		"handle",
		"rect",
		"OS",
		"handle",
		"OS",
		"newBits",
		"newBits",
		"OS",
		"OS",
		"newBits",
		"imageBits",
		"OS",
		"OS",
		"newBits",
		"oldBits",
		"OS",
		"handle",
		"OS",
		"newBits",
		"OS",
		"handle",
		"OS",
		"fImageType",
		"hImage",
		"hasAlpha",
		"hImage",
		"OS",
		"hImage",
		"hCopiedBitmap",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"handle",
		"rect",
		"rect",
		"rect",
		"rect",
		"flags",
		"OS",
		"handle",
		"handle",
		"OS",
		"LabelProc",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"style",
		"SWT",
		"style",
		"SWT",
		"style",
		"style",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"OS",
		"OS",
		"style",
		"SWT",
		"width",
		"DEFAULT_WIDTH",
		"height",
		"lineWidth",
		"width",
		"lineWidth",
		"height",
		"DEFAULT_HEIGHT",
		"wHint",
		"SWT",
		"width",
		"wHint",
		"hHint",
		"SWT",
		"height",
		"hHint",
		"width",
		"border",
		"height",
		"border",
		"width",
		"height",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"OS",
		"bits",
		"OS",
		"OS",
		"isBitmap",
		"isIcon",
		"image",
		"image",
		"width",
		"rect",
		"height",
		"rect",
		"OS",
		"handle",
		"OS",
		"handle",
		"OS",
		"OS",
		"hDC",
		"newFont",
		"OS",
		"OS",
		"OS",
		"style",
		"SWT",
		"wHint",
		"SWT",
		"flags",
		"OS",
		"rect",
		"wHint",
		"OS",
		"handle",
		"length",
		"OS",
		"handle",
		"buffer",
		"length",
		"OS",
		"hDC",
		"buffer",
		"length",
		"rect",
		"flags",
		"width",
		"rect",
		"rect",
		"height",
		"rect",
		"rect",
		"height",
		"OS",
		"OS",
		"hDC",
		"tm",
		"height",
		"tm",
		"newFont",
		"OS",
		"hDC",
		"oldFont",
		"OS",
		"handle",
		"hDC",
		"wHint",
		"SWT",
		"width",
		"wHint",
		"hHint",
		"SWT",
		"height",
		"hHint",
		"width",
		"border",
		"height",
		"border",
		"OS",
		"isBitmap",
		"isIcon",
		"width",
		"width",
		"height",
		"style",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"image",
		"style",
		"SWT",
		"text",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"OS",
		"bits",
		"OS",
		"control",
		"control",
		"index",
		"children",
		"children",
		"index",
		"index",
		"index",
		"index",
		"children",
		"children",
		"index",
		"control",
		"control",
		"mnemonic",
		"Character",
		"key",
		"Character",
		"mnemonic",
		"image2",
		"image2",
		"image2",
		"text",
		"image",
		"hCopiedBitmap",
		"style",
		"SWT",
		"alignment",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"alignment",
		"SWT",
		"SWT",
		"SWT",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"OS",
		"bits",
		"OS",
		"OS",
		"bits",
		"OS",
		"OS",
		"OS",
		"style",
		"SWT",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"handle",
		"style",
		"SWT",
		"image",
		"image",
		"SWT",
		"image",
		"string",
		"SWT",
		"style",
		"SWT",
		"string",
		"text",
		"text",
		"string",
		"OS",
		"handle",
		"OS",
		"newBits",
		"newBits",
		"OS",
		"OS",
		"OS",
		"OS",
		"style",
		"SWT",
		"style",
		"SWT",
		"newBits",
		"OS",
		"style",
		"SWT",
		"newBits",
		"OS",
		"style",
		"SWT",
		"newBits",
		"OS",
		"newBits",
		"oldBits",
		"OS",
		"handle",
		"OS",
		"OS",
		"handle",
		"OS",
		"newBits",
		"hFont",
		"OS",
		"handle",
		"OS",
		"hFont",
		"string",
		"Display",
		"string",
		"string",
		"OS",
		"handle",
		"buffer",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"OS",
		"bits",
		"OS",
		"wrap",
		"bits",
		"OS",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"handle",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"style",
		"SWT",
		"bits",
		"OS",
		"bits",
		"OS",
		"LabelClass",
		"LabelProc",
		"wParam",
		"lParam",
		"result",
		"result",
		"style",
		"SWT",
		"LRESULT",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"OS",
		"bits",
		"OS",
		"OS",
		"isBitmap",
		"isIcon",
		"wParam",
		"LRESULT",
		"result",
		"wParam",
		"lParam",
		"result",
		"result",
		"font",
		"font",
		"font",
		"font",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"result",
		"style",
		"SWT",
		"OS",
		"handle",
		"result",
		"OS",
		"handle",
		"OS",
		"bits",
		"OS",
		"OS",
		"bits",
		"OS",
		"OS",
		"isBitmap",
		"isIcon",
		"OS",
		"handle",
		"result",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"OS",
		"handle",
		"result",
		"result",
		"wParam",
		"lParam",
		"OS",
		"OS",
		"control",
		"OS",
		"wParam",
		"OS",
		"OS",
		"control",
		"rect",
		"OS",
		"control",
		"handle",
		"rect",
		"control",
		"wParam",
		"rect",
		"OS",
		"OS",
		"result",
		"wParam",
		"lParam",
		"result",
		"result",
		"image2",
		"image",
		"result",
		"OS",
		"struct",
		"lParam",
		"DRAWITEMSTRUCT",
		"struct",
		"style",
		"SWT",
		"OS",
		"OS",
		"OS",
		"style",
		"SWT",
		"flags",
		"OS",
		"style",
		"SWT",
		"struct",
		"Math",
		"lineWidth",
		"struct",
		"struct",
		"OS",
		"rect",
		"struct",
		"struct",
		"struct",
		"bottom",
		"OS",
		"struct",
		"rect",
		"flags",
		"OS",
		"struct",
		"Math",
		"lineWidth",
		"struct",
		"struct",
		"OS",
		"rect",
		"struct",
		"struct",
		"right",
		"struct",
		"OS",
		"struct",
		"rect",
		"flags",
		"OS",
		"lpfnWndProc",
		"type",
		"BITMAP",
		"COMCTL32_MAJOR",
		"TRANSPARENCY_PIXEL",
		"width",
		"height",
		"handle",
		"SS_ICON",
		"IMAGE_ICON",
		"TRANSPARENCY_ALPHA",
		"width",
		"height",
		"handle",
		"SS_BITMAP",
		"IMAGE_BITMAP",
		"TRANSPARENCY_NONE",
		"handle",
		"SS_BITMAP",
		"IMAGE_BITMAP",
		"alpha",
		"alphaData",
		"transparentPixel",
		"handle",
		"alpha",
		"alphaData",
		"transparentPixel",
		"handle",
		"depth",
		"width",
		"height",
		"handle",
		"SS_BITMAP",
		"IMAGE_BITMAP",
		"ICON",
		"handle",
		"SS_ICON",
		"IMAGE_ICON",
		"GWL_STYLE",
		"SS_BITMAP",
		"SS_ICON",
		"SS_REALSIZEIMAGE",
		"SS_CENTERIMAGE",
		"GWL_STYLE",
		"STM_SETIMAGE",
		"STM_GETIMAGE",
		"IMAGE_BITMAP",
		"SWP_NOZORDER",
		"SWP_DRAWFRAME",
		"SWP_NOACTIVATE",
		"SWP_NOMOVE",
		"right",
		"left",
		"bottom",
		"top",
		"NO_FOCUS",
		"SEPARATOR",
		"VERTICAL",
		"HORIZONTAL",
		"SHADOW_OUT",
		"SHADOW_IN",
		"SHADOW_NONE",
		"LEFT",
		"CENTER",
		"RIGHT",
		"SEPARATOR",
		"SM_CXBORDER",
		"HORIZONTAL",
		"DEFAULT",
		"DEFAULT",
		"GWL_STYLE",
		"SS_BITMAP",
		"SS_BITMAP",
		"SS_ICON",
		"SS_ICON",
		"width",
		"height",
		"WM_GETFONT",
		"DT_CALCRECT",
		"DT_EDITCONTROL",
		"DT_EXPANDTABS",
		"WRAP",
		"DEFAULT",
		"DT_WORDBREAK",
		"right",
		"right",
		"left",
		"bottom",
		"top",
		"IsUnicode",
		"tmHeight",
		"DEFAULT",
		"DEFAULT",
		"IsWinCE",
		"SEPARATOR",
		"LEFT",
		"LEFT",
		"CENTER",
		"CENTER",
		"RIGHT",
		"RIGHT",
		"LEFT",
		"SEPARATOR",
		"GWL_STYLE",
		"SS_RIGHT",
		"SS_CENTER",
		"SS_LEFTNOWORDWRAP",
		"parent",
		"length",
		"length",
		"parent",
		"SEPARATOR",
		"LEFT",
		"RIGHT",
		"CENTER",
		"LEFT",
		"RIGHT",
		"CENTER",
		"LEFT",
		"RIGHT",
		"CENTER",
		"GWL_STYLE",
		"SS_BITMAP",
		"SS_BITMAP",
		"SS_ICON",
		"SS_ICON",
		"SS_LEFTNOWORDWRAP",
		"SS_CENTER",
		"SS_RIGHT",
		"LEFT",
		"WRAP",
		"SS_LEFTNOWORDWRAP",
		"CENTER",
		"SS_CENTER",
		"RIGHT",
		"SS_RIGHT",
		"GWL_STYLE",
		"SEPARATOR",
		"ERROR_INVALID_ARGUMENT",
		"image",
		"ERROR_NULL_ARGUMENT",
		"SEPARATOR",
		"GWL_STYLE",
		"SS_BITMAP",
		"SS_ICON",
		"SS_REALSIZEIMAGE",
		"SS_CENTERIMAGE",
		"LEFT",
		"WRAP",
		"SS_LEFTNOWORDWRAP",
		"CENTER",
		"SS_CENTER",
		"RIGHT",
		"SS_RIGHT",
		"WM_GETFONT",
		"GWL_STYLE",
		"WM_SETFONT",
		"GWL_STYLE",
		"SS_RIGHT",
		"SS_CENTER",
		"SS_LEFTNOWORDWRAP",
		"SS_LEFTNOWORDWRAP",
		"GWL_STYLE",
		"WS_EX_CLIENTEDGE",
		"BORDER",
		"WS_EX_STATICEDGE",
		"SS_NOTIFY",
		"SEPARATOR",
		"SS_OWNERDRAW",
		"CENTER",
		"SS_CENTER",
		"RIGHT",
		"SS_RIGHT",
		"WRAP",
		"SS_LEFT",
		"SS_LEFTNOWORDWRAP",
		"SEPARATOR",
		"ONE",
		"GWL_STYLE",
		"SS_BITMAP",
		"SS_BITMAP",
		"SS_ICON",
		"SS_ICON",
		"ONE",
		"SEPARATOR",
		"GWL_STYLE",
		"SS_BITMAP",
		"SS_BITMAP",
		"SS_ICON",
		"SS_ICON",
		"WRAP",
		"CENTER",
		"RIGHT",
		"COMCTL32_MAJOR",
		"TRANSPARENT",
		"handle",
		"handle",
		"NULL_BRUSH",
		"sizeof",
		"hDC",
		"SHADOW_NONE",
		"SM_CXBORDER",
		"EDGE_ETCHED",
		"SHADOW_IN",
		"EDGE_SUNKEN",
		"HORIZONTAL",
		"top",
		"bottom",
		"top",
		"left",
		"top",
		"right",
		"hDC",
		"BF_BOTTOM",
		"left",
		"right",
		"left",
		"left",
		"top",
		"bottom",
		"hDC",
		"BF_RIGHT",
		"parent",
		"style",
		"image",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"style",
		"wHint",
		"hHint",
		"changed",
		"key",
		"key",
		"alignment",
		"image",
		"string",
		"wrap",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam"
	],
	"extendORImplementFiles":[
		"Control"
	],
	"package":[
		"org.eclipse.swt.widgets"
	],
	"import":[
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt",
		"org.eclipse.swt.graphics"
	],
	"methods":[
		"_setImage",
		"callWindowProc",
		"checkStyle",
		"computeSize",
		"getAlignment",
		"getImage",
		"getNameText",
		"getText",
		"getWrap",
		"mnemonicHit",
		"mnemonicMatch",
		"releaseWidget",
		"setAlignment",
		"setImage",
		"setText",
		"setWrap",
		"widgetExtStyle",
		"widgetStyle",
		"windowClass",
		"windowProc",
		"WM_ERASEBKGND",
		"WM_GETFONT",
		"WM_SETFONT",
		"WM_SIZE",
		"wmColorChild",
		"WM_SYSCOLORCHANGE",
		"wmDrawChild",
		"GetClassInfo",
		"checkStyle",
		"dispose",
		"DeleteObject",
		"getImageData",
		"getBounds",
		"getTransparencyType",
		"getTransparencyMask",
		"setBackground",
		"getBackground",
		"fillRectangle",
		"drawImage",
		"dispose",
		"create32bitDIB",
		"getDepth",
		"drawImage",
		"dispose",
		"GetWindowRect",
		"GetWindowLong",
		"SetWindowLong",
		"SendMessage",
		"DeleteObject",
		"SendMessage",
		"SetWindowPos",
		"InvalidateRect",
		"CallWindowProc",
		"checkBits",
		"checkBits",
		"checkBits",
		"checkWidget",
		"getBorderWidth",
		"GetSystemMetrics",
		"GetWindowLong",
		"getBounds",
		"GetDC",
		"SendMessage",
		"SelectObject",
		"GetWindowTextLength",
		"getCodePage",
		"GetWindowText",
		"DrawText",
		"GetTextMetrics",
		"SelectObject",
		"ReleaseDC",
		"checkWidget",
		"checkWidget",
		"getText",
		"checkWidget",
		"GetWindowLong",
		"_getChildren",
		"setFocus",
		"findMnemonic",
		"getText",
		"toUpperCase",
		"toUpperCase",
		"releaseWidget",
		"dispose",
		"checkWidget",
		"GetWindowLong",
		"SetWindowLong",
		"InvalidateRect",
		"checkWidget",
		"isDisposed",
		"error",
		"_setImage",
		"checkWidget",
		"error",
		"equals",
		"GetWindowLong",
		"SendMessage",
		"SetWindowLong",
		"SendMessage",
		"withCrLf",
		"getCodePage",
		"SetWindowText",
		"GetWindowLong",
		"SetWindowLong",
		"InvalidateRect",
		"widgetExtStyle",
		"widgetStyle",
		"WM_ERASEBKGND",
		"GetWindowLong",
		"drawBackground",
		"WM_GETFONT",
		"defaultFont",
		"WM_SETFONT",
		"WM_SIZE",
		"isDisposed",
		"InvalidateRect",
		"GetWindowLong",
		"InvalidateRect",
		"InvalidateRect",
		"wmColorChild",
		"IsAppThemed",
		"findThemeControl",
		"SetBkMode",
		"GetClientRect",
		"MapWindowPoints",
		"drawThemeBackground",
		"GetStockObject",
		"WM_SYSCOLORCHANGE",
		"_setImage",
		"MoveMemory",
		"drawBackground",
		"GetSystemMetrics",
		"max",
		"SetRect",
		"DrawEdge",
		"max",
		"SetRect",
		"DrawEdge",
		"TCHAR",
		"WNDCLASS",
		"Image",
		"Image",
		"GC",
		"Image",
		"GC",
		"RECT",
		"Point",
		"RECT",
		"TCHAR",
		"TEXTMETRICW",
		"TEXTMETRICA",
		"Point",
		"TCHAR",
		"LRESULT",
		"RECT",
		"LRESULT",
		"DRAWITEMSTRUCT",
		"RECT"
	],
	"methodsBody":{
		"boolean mnemonicMatch(char key)":{
			"methodBody":"{\n    char mnemonic = findMnemonic(getText());\n    if (mnemonic == '\\0')\n        return false;\n    return Character.toUpperCase(key) == Character.toUpperCase(mnemonic);\n}",
			"comments":"",
			"methodName":"boolean mnemonicMatch(char key)"
		},
		"public void setText(String string)":{
			"methodBody":"{\n    checkWidget();\n    if (string == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if ((style & SWT.SEPARATOR) != 0)\n        return;\n    \n    if (string.equals(text))\n        return;\n    text = string;\n    int newBits = OS.GetWindowLong(handle, OS.GWL_STYLE), oldBits = newBits;\n    newBits &= ~(OS.SS_BITMAP | OS.SS_ICON | OS.SS_REALSIZEIMAGE | OS.SS_CENTERIMAGE);\n    if ((style & SWT.LEFT) != 0 && (style & SWT.WRAP) == 0)\n        newBits |= OS.SS_LEFTNOWORDWRAP;\n    if ((style & SWT.CENTER) != 0)\n        newBits |= OS.SS_CENTER;\n    if ((style & SWT.RIGHT) != 0)\n        newBits |= OS.SS_RIGHT;\n    if (newBits != oldBits) {\n        \n        int hFont = OS.SendMessage(handle, OS.WM_GETFONT, 0, 0);\n        OS.SetWindowLong(handle, OS.GWL_STYLE, newBits);\n        if (hFont != 0)\n            OS.SendMessage(handle, OS.WM_SETFONT, hFont, 0);\n    }\n    string = Display.withCrLf(string);\n    TCHAR buffer = new TCHAR(getCodePage(), string, true);\n    OS.SetWindowText(handle, buffer);\n}",
			"comments":"/**\n* Sets the receiver's text.\n* <p>\n* This method sets the widget label.  The label may include\n* the mnemonic character and line delimiters.\n* </p>\n* <p>\n* Mnemonics are indicated by an '&amp' that causes the next\n* character to be the mnemonic.  When the user presses a\n* key sequence that matches the mnemonic, focus is assigned\n* to the control that follows the label. On most platforms,\n* the mnemonic appears underlined but may be emphasised in a\n* platform specific manner.  The mnemonic indicator character\n*'&amp' can be escaped by doubling it in the string, causing\n* a single '&amp' to be displayed.\n* </p>\n*\n* @param string the new text\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the text is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* Feature in Windows.  For some reason, SetWindowText() for\n* static controls redraws the control, even when the text has\n* has not changed.  The fix is to check for this case and do\n* nothing.\n*/\n/*\n* Bug in Windows.  When the style of a label is SS_BITMAP\n* or SS_ICON, the label does not remember the font that is\n* set in WM_SETFONT.  The fix is to remember the font and\n* return the font in WM_GETFONT and to reset the font when\n* the style is changed from SS_BITMAP or SS_ICON to a style\n* that displays text.\n*/\n",
			"methodName":"public void setText(String string)"
		},
		"void _setImage(Image image)":{
			"methodBody":"{\n    if (image2 != null)\n        image2.dispose();\n    image2 = null;\n    if (hCopiedBitmap != 0)\n        OS.DeleteObject(hCopiedBitmap);\n    hCopiedBitmap = 0;\n    boolean hasAlpha = false;\n    int hImage = 0, imageBits = 0, fImageType = 0;\n    if (image != null) {\n        switch(image.type) {\n            case SWT.BITMAP:\n                {\n                    ImageData data = image.getImageData();\n                    if (OS.COMCTL32_MAJOR < 6) {\n                        Rectangle rect = image.getBounds();\n                        switch(data.getTransparencyType()) {\n                            case SWT.TRANSPARENCY_PIXEL:\n                                if (rect.width <= ICON_WIDTH && rect.height <= ICON_HEIGHT) {\n                                    image2 = new Image(display, data, data.getTransparencyMask());\n                                    hImage = image2.handle;\n                                    imageBits = OS.SS_ICON;\n                                    fImageType = OS.IMAGE_ICON;\n                                    break;\n                                }\n                            \n                            case SWT.TRANSPARENCY_ALPHA:\n                                image2 = new Image(display, rect.width, rect.height);\n                                GC gc = new GC(image2);\n                                gc.setBackground(getBackground());\n                                gc.fillRectangle(rect);\n                                gc.drawImage(image, 0, 0);\n                                gc.dispose();\n                                hImage = image2.handle;\n                                imageBits = OS.SS_BITMAP;\n                                fImageType = OS.IMAGE_BITMAP;\n                                break;\n                            case SWT.TRANSPARENCY_NONE:\n                                hImage = image.handle;\n                                imageBits = OS.SS_BITMAP;\n                                fImageType = OS.IMAGE_BITMAP;\n                                break;\n                        }\n                    } else {\n                        if (data.alpha != -1 || data.alphaData != null || data.transparentPixel != -1) {\n                            hasAlpha = true;\n                            hImage = Display.create32bitDIB(image.handle, data.alpha, data.alphaData, data.transparentPixel);\n                        } else {\n                            hImage = image.handle;\n                            \n                            if (data.depth <= 8 && display.getDepth() > 8) {\n                                image2 = new Image(display, data.width, data.height);\n                                GC gc = new GC(image2);\n                                gc.drawImage(image, 0, 0);\n                                gc.dispose();\n                                hImage = image2.handle;\n                            }\n                        }\n                        imageBits = OS.SS_BITMAP;\n                        fImageType = OS.IMAGE_BITMAP;\n                    }\n                    break;\n                }\n            case SWT.ICON:\n                {\n                    hImage = image.handle;\n                    imageBits = OS.SS_ICON;\n                    fImageType = OS.IMAGE_ICON;\n                    break;\n                }\n        }\n    }\n    RECT rect = new RECT();\n    OS.GetWindowRect(handle, rect);\n    int newBits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n    int oldBits = newBits;\n    newBits &= ~(OS.SS_BITMAP | OS.SS_ICON);\n    newBits |= imageBits | OS.SS_REALSIZEIMAGE | OS.SS_CENTERIMAGE;\n    if (newBits != oldBits) {\n        OS.SetWindowLong(handle, OS.GWL_STYLE, newBits);\n    }\n    OS.SendMessage(handle, OS.STM_SETIMAGE, fImageType, hImage);\n    \n    if (hasAlpha && hImage != 0) {\n        OS.DeleteObject(hImage);\n        hCopiedBitmap = OS.SendMessage(handle, OS.STM_GETIMAGE, OS.IMAGE_BITMAP, 0);\n    }\n    \n    int flags = OS.SWP_NOZORDER | OS.SWP_DRAWFRAME | OS.SWP_NOACTIVATE | OS.SWP_NOMOVE;\n    SetWindowPos(handle, 0, 0, 0, rect.right - rect.left, rect.bottom - rect.top, flags);\n    OS.InvalidateRect(handle, null, true);\n}",
			"comments":"//FALL THROUGH\n/*\n* Bug in Windows.  For some reason in Windows XP only, indexed palette\n* bitmaps are not drawn properly even though the screen depth can\n* handle all colors in the palette.  The fix is to use a higher depth\n* bitmap instead.\n*/\n/*\n* When STM_SETIMAGE encounters a bitmap with alpha information,\n* it makes a copy of the bitmap.  Therefore the bitmap that was\n* created to preserve transparency can be deleted right away.\n*\n* Note: The client code also needs to delete the copied image\n* created by Windows when the image changed but does not need\n* to delete the copied image when the control is disposed.\n*/\n/*\n* Feature in Windows.  When STM_SETIMAGE is used to set the\n* image for a static control, Windows either streches the image\n* to fit the control or shrinks the control to fit the image.\n* While not stricly wrong, neither of these is desirable.\n* The fix is to stop Windows from stretching the image by\n* using SS_REALSIZEIMAGE and SS_CENTERIMAGE, allow Windows\n* to shrink the control, and then restore the control to the\n* original size.\n*/\n",
			"methodName":"void _setImage(Image image)"
		},
		"boolean getWrap()":{
			"methodBody":"{\n    int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n    if ((bits & (OS.SS_RIGHT | OS.SS_CENTER)) != 0)\n        return true;\n    if ((bits & OS.SS_LEFTNOWORDWRAP) != 0)\n        return false;\n    return true;\n}",
			"comments":"/*\n* Not currently used.\n*/\n",
			"methodName":"boolean getWrap()"
		},
		"LRESULT WM_ERASEBKGND(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_ERASEBKGND(wParam, lParam);\n    if (result != null)\n        return result;\n    if ((style & SWT.SEPARATOR) != 0)\n        return LRESULT.ONE;\n    \n    int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n    boolean isBitmap = (bits & OS.SS_BITMAP) == OS.SS_BITMAP;\n    boolean isIcon = (bits & OS.SS_ICON) == OS.SS_ICON;\n    if (isBitmap || isIcon) {\n        drawBackground(wParam);\n        return LRESULT.ONE;\n    }\n    return result;\n}",
			"comments":"/*\n* Bug in Windows.  When a label has the SS_BITMAP\n* or SS_ICON style, the label does not draw the\n* background.  The fix is to draw the background\n* when the label is showing a bitmap or icon.\n*\n* NOTE: SS_BITMAP and SS_ICON are not single bit\n* masks so it is necessary to test for all of the\n* bits in these masks.\n*/\n",
			"methodName":"LRESULT WM_ERASEBKGND(int wParam, int lParam)"
		},
		"LRESULT wmColorChild(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.wmColorChild(wParam, lParam);\n    if (OS.COMCTL32_MAJOR >= 6 && OS.IsAppThemed()) {\n        Control control = findThemeControl();\n        if (control != null) {\n            OS.SetBkMode(wParam, OS.TRANSPARENT);\n            RECT rect = new RECT();\n            OS.GetClientRect(control.handle, rect);\n            OS.MapWindowPoints(control.handle, handle, rect, 2);\n            control.drawThemeBackground(wParam, rect);\n            return new LRESULT(OS.GetStockObject(OS.NULL_BRUSH));\n        }\n    }\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT wmColorChild(int wParam, int lParam)"
		},
		"boolean mnemonicHit(char key)":{
			"methodBody":"{\n    Composite control = this.parent;\n    while (control != null) {\n        Control[] children = control._getChildren();\n        int index = 0;\n        while (index < children.length) {\n            if (children[index] == this)\n                break;\n            index++;\n        }\n        index++;\n        if (index < children.length) {\n            if (children[index].setFocus())\n                return true;\n        }\n        control = control.parent;\n    }\n    return false;\n}",
			"comments":"",
			"methodName":"boolean mnemonicHit(char key)"
		},
		"LRESULT WM_GETFONT(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_GETFONT(wParam, lParam);\n    if (result != null)\n        return result;\n    \n    if (font == 0)\n        font = defaultFont();\n    return new LRESULT(font);\n}",
			"comments":"/*\n* Bug in Windows.  When the style of a label is SS_BITMAP\n* or SS_ICON, the label does not remember the font that is\n* set in WM_SETFONT.  The fix is to remember the font and\n* return the font in WM_GETFONT.\n*/\n",
			"methodName":"LRESULT WM_GETFONT(int wParam, int lParam)"
		},
		"void setWrap(boolean wrap)":{
			"methodBody":"{\n    int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n    if ((bits & (OS.SS_RIGHT | OS.SS_CENTER)) != 0)\n        return;\n    bits &= ~OS.SS_LEFTNOWORDWRAP;\n    if (!wrap)\n        bits |= OS.SS_LEFTNOWORDWRAP;\n    OS.SetWindowLong(handle, OS.GWL_STYLE, bits);\n    OS.InvalidateRect(handle, null, true);\n}",
			"comments":"/*\n* Not currently used.\n*/\n",
			"methodName":"void setWrap(boolean wrap)"
		},
		"static int checkStyle(int style)":{
			"methodBody":"{\n    style |= SWT.NO_FOCUS;\n    if ((style & SWT.SEPARATOR) != 0) {\n        style = checkBits(style, SWT.VERTICAL, SWT.HORIZONTAL, 0, 0, 0, 0);\n        return checkBits(style, SWT.SHADOW_OUT, SWT.SHADOW_IN, SWT.SHADOW_NONE, 0, 0, 0);\n    }\n    return checkBits(style, SWT.LEFT, SWT.CENTER, SWT.RIGHT, 0, 0, 0);\n}",
			"comments":"",
			"methodName":"static int checkStyle(int style)"
		},
		"LRESULT wmDrawChild(int wParam, int lParam)":{
			"methodBody":"{\n    DRAWITEMSTRUCT struct = new DRAWITEMSTRUCT();\n    OS.MoveMemory(struct, lParam, DRAWITEMSTRUCT.sizeof);\n    drawBackground(struct.hDC);\n    if ((style & SWT.SHADOW_NONE) != 0)\n        return null;\n    RECT rect = new RECT();\n    int lineWidth = OS.GetSystemMetrics(OS.SM_CXBORDER);\n    int flags = OS.EDGE_ETCHED;\n    if ((style & SWT.SHADOW_IN) != 0)\n        flags = OS.EDGE_SUNKEN;\n    if ((style & SWT.HORIZONTAL) != 0) {\n        int bottom = struct.top + Math.max(lineWidth * 2, (struct.bottom - struct.top) / 2);\n        OS.SetRect(rect, struct.left, struct.top, struct.right, bottom);\n        OS.DrawEdge(struct.hDC, rect, flags, OS.BF_BOTTOM);\n    } else {\n        int right = struct.left + Math.max(lineWidth * 2, (struct.right - struct.left) / 2);\n        OS.SetRect(rect, struct.left, struct.top, right, struct.bottom);\n        OS.DrawEdge(struct.hDC, rect, flags, OS.BF_RIGHT);\n    }\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT wmDrawChild(int wParam, int lParam)"
		},
		"public int getAlignment()":{
			"methodBody":"{\n    checkWidget();\n    if ((style & SWT.SEPARATOR) != 0)\n        return 0;\n    if ((style & SWT.LEFT) != 0)\n        return SWT.LEFT;\n    if ((style & SWT.CENTER) != 0)\n        return SWT.CENTER;\n    if ((style & SWT.RIGHT) != 0)\n        return SWT.RIGHT;\n    return SWT.LEFT;\n}",
			"comments":"/**\n* Returns a value which describes the position of the\n* text or image in the receiver. The value will be one of\n* <code>LEFT</code>, <code>RIGHT</code> or <code>CENTER</code>\n* unless the receiver is a <code>SEPARATOR</code> label, in\n* which case, <code>NONE</code> is returned.\n*\n* @return the alignment\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getAlignment()"
		},
		"public Point computeSize(int wHint, int hHint, boolean changed)":{
			"methodBody":"{\n    checkWidget();\n    int width = 0, height = 0;\n    int border = getBorderWidth();\n    if ((style & SWT.SEPARATOR) != 0) {\n        int lineWidth = OS.GetSystemMetrics(OS.SM_CXBORDER);\n        if ((style & SWT.HORIZONTAL) != 0) {\n            width = DEFAULT_WIDTH;\n            height = lineWidth * 2;\n        } else {\n            width = lineWidth * 2;\n            height = DEFAULT_HEIGHT;\n        }\n        if (wHint != SWT.DEFAULT)\n            width = wHint;\n        if (hHint != SWT.DEFAULT)\n            height = hHint;\n        width += border * 2;\n        height += border * 2;\n        return new Point(width, height);\n    }\n    \n    int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n    boolean isBitmap = (bits & OS.SS_BITMAP) == OS.SS_BITMAP;\n    boolean isIcon = (bits & OS.SS_ICON) == OS.SS_ICON;\n    if (isBitmap || isIcon) {\n        if (image != null) {\n            Rectangle rect = image.getBounds();\n            width = rect.width;\n            height = rect.height;\n        }\n    } else {\n        int hDC = OS.GetDC(handle);\n        int newFont = OS.SendMessage(handle, OS.WM_GETFONT, 0, 0);\n        int oldFont = OS.SelectObject(hDC, newFont);\n        RECT rect = new RECT();\n        int flags = OS.DT_CALCRECT | OS.DT_EDITCONTROL | OS.DT_EXPANDTABS;\n        if ((style & SWT.WRAP) != 0 && wHint != SWT.DEFAULT) {\n            flags |= OS.DT_WORDBREAK;\n            rect.right = wHint;\n        }\n        int length = OS.GetWindowTextLength(handle);\n        TCHAR buffer = new TCHAR(getCodePage(), length + 1);\n        OS.GetWindowText(handle, buffer, length + 1);\n        OS.DrawText(hDC, buffer, length, rect, flags);\n        width = rect.right - rect.left;\n        height = rect.bottom - rect.top;\n        if (height == 0) {\n            TEXTMETRIC tm = OS.IsUnicode ? (TEXTMETRIC) new TEXTMETRICW() : new TEXTMETRICA();\n            OS.GetTextMetrics(hDC, tm);\n            height = tm.tmHeight;\n        }\n        if (newFont != 0)\n            OS.SelectObject(hDC, oldFont);\n        OS.ReleaseDC(handle, hDC);\n    }\n    if (wHint != SWT.DEFAULT)\n        width = wHint;\n    if (hHint != SWT.DEFAULT)\n        height = hHint;\n    width += border * 2;\n    height += border * 2;\n    \n    if (OS.IsWinCE) {\n        if (!isBitmap && !isIcon)\n            width += 2;\n    }\n    return new Point(width, height);\n}",
			"comments":"/*\n* NOTE: SS_BITMAP and SS_ICON are not single bit\n* masks so it is necessary to test for all of the\n* bits in these masks.\n*/\n/*\n* Feature in WinCE PPC.  Text labels have a trim\n* of one pixel wide on the right and left side.\n* The fix is to increase the size.\n*/\n",
			"methodName":"public Point computeSize(int wHint, int hHint, boolean changed)"
		},
		"int widgetExtStyle()":{
			"methodBody":"{\n    int bits = super.widgetExtStyle() & ~OS.WS_EX_CLIENTEDGE;\n    if ((style & SWT.BORDER) != 0)\n        return bits | OS.WS_EX_STATICEDGE;\n    return bits;\n}",
			"comments":"",
			"methodName":"int widgetExtStyle()"
		},
		"LRESULT WM_SETFONT(int wParam, int lParam)":{
			"methodBody":"{\n    \n    return super.WM_SETFONT(font = wParam, lParam);\n}",
			"comments":"/*\n* Bug in Windows.  When the style of a label is SS_BITMAP\n* or SS_ICON, the label does not remember the font that is\n* set in WM_SETFONT.  The fix is to remember the font and\n* return the font in WM_GETFONT.\n*/\n",
			"methodName":"LRESULT WM_SETFONT(int wParam, int lParam)"
		},
		"public Image getImage()":{
			"methodBody":"{\n    checkWidget();\n    return image;\n}",
			"comments":"/**\n* Returns the receiver's image if it has one, or null\n* if it does not.\n*\n* @return the receiver's image\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Image getImage()"
		},
		"TCHAR windowClass()":{
			"methodBody":"{\n    return LabelClass;\n}",
			"comments":"",
			"methodName":"TCHAR windowClass()"
		},
		"LRESULT WM_SIZE(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_SIZE(wParam, lParam);\n    \n    if (isDisposed())\n        return result;\n    if ((style & SWT.SEPARATOR) != 0) {\n        OS.InvalidateRect(handle, null, true);\n        return result;\n    }\n    \n    int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n    boolean isBitmap = (bits & OS.SS_BITMAP) == OS.SS_BITMAP;\n    boolean isIcon = (bits & OS.SS_ICON) == OS.SS_ICON;\n    if (isBitmap || isIcon) {\n        OS.InvalidateRect(handle, null, true);\n        return result;\n    }\n    \n    if ((style & (SWT.WRAP | SWT.CENTER | SWT.RIGHT)) != 0) {\n        OS.InvalidateRect(handle, null, true);\n        return result;\n    }\n    return result;\n}",
			"comments":"/*\n* It is possible (but unlikely), that application\n* code could have disposed the widget in the resize\n* event.  If this happens, end the processing of the\n* Windows message by returning the result of the\n* WM_SIZE message.\n*/\n/*\n* Bug in Windows.  For some reason, a label with\n* SS_BITMAP or SS_ICON and SS_CENTER does not redraw\n* properly when resized.  Only the new area is drawn\n* and the old area is not cleared.  The fix is to\n* force the redraw.\n*\n* NOTE: SS_BITMAP and SS_ICON are not single bit\n* masks so it is necessary to test for all of the\n* bits in these masks.\n*/\n/*\n* Bug in Windows.  For some reason, a label with\n* style SS_LEFT, SS_CENTER or SS_RIGHT does not\n* redraw the text in the new position when resized.\n* Note that SS_LEFTNOWORDWRAP does not have the\n* problem.  The fix is to force the redraw.\n*/\n",
			"methodName":"LRESULT WM_SIZE(int wParam, int lParam)"
		},
		"public void setImage(Image image)":{
			"methodBody":"{\n    checkWidget();\n    if ((style & SWT.SEPARATOR) != 0)\n        return;\n    if (image != null && image.isDisposed())\n        error(SWT.ERROR_INVALID_ARGUMENT);\n    _setImage(this.image = image);\n}",
			"comments":"/**\n* Sets the receiver's image to the argument, which may be\n* null indicating that no image should be displayed.\n*\n* @param image the image to display on the receiver (may be null)\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the image has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setImage(Image image)"
		},
		"LRESULT WM_SYSCOLORCHANGE(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_SYSCOLORCHANGE(wParam, lParam);\n    if (result != null)\n        return result;\n    if (image2 != null)\n        _setImage(image);\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_SYSCOLORCHANGE(int wParam, int lParam)"
		},
		"String getNameText()":{
			"methodBody":"{\n    return getText();\n}",
			"comments":"",
			"methodName":"String getNameText()"
		},
		"public void setAlignment(int alignment)":{
			"methodBody":"{\n    checkWidget();\n    if ((style & SWT.SEPARATOR) != 0)\n        return;\n    if ((alignment & (SWT.LEFT | SWT.RIGHT | SWT.CENTER)) == 0)\n        return;\n    style &= ~(SWT.LEFT | SWT.RIGHT | SWT.CENTER);\n    style |= alignment & (SWT.LEFT | SWT.RIGHT | SWT.CENTER);\n    int bits = OS.GetWindowLong(handle, OS.GWL_STYLE);\n    \n    if ((bits & OS.SS_BITMAP) == OS.SS_BITMAP)\n        return;\n    if ((bits & OS.SS_ICON) == OS.SS_ICON)\n        return;\n    bits &= ~(OS.SS_LEFTNOWORDWRAP | OS.SS_CENTER | OS.SS_RIGHT);\n    if ((style & SWT.LEFT) != 0 && (style & SWT.WRAP) == 0) {\n        bits |= OS.SS_LEFTNOWORDWRAP;\n    }\n    if ((style & SWT.CENTER) != 0)\n        bits |= OS.SS_CENTER;\n    if ((style & SWT.RIGHT) != 0)\n        bits |= OS.SS_RIGHT;\n    OS.SetWindowLong(handle, OS.GWL_STYLE, bits);\n    OS.InvalidateRect(handle, null, true);\n}",
			"comments":"/**\n* Controls how text and images will be displayed in the receiver.\n* The argument should be one of <code>LEFT</code>, <code>RIGHT</code>\n* or <code>CENTER</code>.  If the receiver is a <code>SEPARATOR</code>\n* label, the argument is ignored and the alignment is not changed.\n*\n* @param alignment the new alignment\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* Feature in Windows.  The windows label does not align\n* the bitmap or icon.  Any attempt to set alignment bits\n* such as SS_CENTER cause the label to display text.  The\n* fix is to disallow alignment.\n*\n* NOTE: SS_BITMAP and SS_ICON are not single bit\n* masks so it is necessary to test for all of the\n* bits in these masks.\n*/\n",
			"methodName":"public void setAlignment(int alignment)"
		},
		"void releaseWidget()":{
			"methodBody":"{\n    super.releaseWidget();\n    if (image2 != null)\n        image2.dispose();\n    image2 = null;\n    text = null;\n    image = null;\n    \n    hCopiedBitmap = 0;\n}",
			"comments":"/* Windows deletes the copied image when the control is disposed */\n",
			"methodName":"void releaseWidget()"
		},
		"public String getText()":{
			"methodBody":"{\n    checkWidget();\n    if ((style & SWT.SEPARATOR) != 0)\n        return \"\";\n    return text;\n}",
			"comments":"/**\n* Returns the receiver's text, which will be an empty\n* string if it has never been set or if the receiver is\n* a <code>SEPARATOR</code> label.\n*\n* @return the receiver's text\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public String getText()"
		},
		"int windowProc()":{
			"methodBody":"{\n    return LabelProc;\n}",
			"comments":"",
			"methodName":"int windowProc()"
		},
		"int callWindowProc(int hwnd, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    if (handle == 0)\n        return 0;\n    return OS.CallWindowProc(LabelProc, hwnd, msg, wParam, lParam);\n}",
			"comments":"",
			"methodName":"int callWindowProc(int hwnd, int msg, int wParam, int lParam)"
		},
		"int widgetStyle()":{
			"methodBody":"{\n    int bits = super.widgetStyle() | OS.SS_NOTIFY;\n    if ((style & SWT.SEPARATOR) != 0)\n        return bits | OS.SS_OWNERDRAW;\n    if ((style & SWT.CENTER) != 0)\n        return bits | OS.SS_CENTER;\n    if ((style & SWT.RIGHT) != 0)\n        return bits | OS.SS_RIGHT;\n    if ((style & SWT.WRAP) != 0)\n        return bits | OS.SS_LEFT;\n    return bits | OS.SS_LEFTNOWORDWRAP;\n}",
			"comments":"",
			"methodName":"int widgetStyle()"
		}
	},
	"ClassORInterfaceName":[
		"Label"
	]
}
