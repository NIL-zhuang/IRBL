{
	"variables":[
		"hwndText",
		"hwndUpDown",
		"ignoreModify",
		"pageIncrement",
		"digits",
		"EditProc",
		"EditClass",
		"UpDownProc",
		"UpDownClass",
		"lpWndClass",
		"hInstance",
		"textExStyle",
		"textStyle",
		"upDownStyle",
		"hIMC",
		"buffer",
		"typedListener",
		"typedListener",
		"typedListener",
		"width",
		"height",
		"newFont",
		"oldFont",
		"hDC",
		"tm",
		"rect",
		"max",
		"string",
		"buffer",
		"count",
		"buffer",
		"flags",
		"trim",
		"rect",
		"bits0",
		"bits1",
		"margins",
		"hwndFocus",
		"tchar",
		"size",
		"udaccel",
		"max",
		"min",
		"length",
		"buffer",
		"string",
		"value",
		"decimalSeparator",
		"index",
		"wholePart",
		"decimalPart",
		"i",
		"j",
		"wholeValue",
		"decimalValue",
		"i",
		"max",
		"min",
		"mbcsSize",
		"buffer",
		"key",
		"stateMask",
		"oldText",
		"start",
		"end",
		"newStart",
		"newEnd",
		"length",
		"newStart",
		"newEnd",
		"newText",
		"buffer",
		"pos",
		"hHeap",
		"count",
		"udaccels",
		"first",
		"udaccel",
		"i",
		"offset",
		"min",
		"pos",
		"max",
		"pos",
		"max",
		"min",
		"string",
		"decimalSeparator",
		"index",
		"buffer",
		"length",
		"buffer",
		"newProc",
		"event",
		"index",
		"decimalSeparator",
		"result",
		"result",
		"result",
		"result",
		"width",
		"height",
		"upDownWidth",
		"textWidth",
		"flags",
		"result",
		"value",
		"call",
		"start",
		"end",
		"oldText",
		"newText",
		"length",
		"buffer",
		"buffer",
		"hHeap",
		"byteCount",
		"pszText",
		"code",
		"code",
		"result",
		"udaccel",
		"delta",
		"value",
		"newValue",
		"max",
		"min",
		"value",
		"value",
		"hdr",
		"lpnmud",
		"value",
		"max",
		"min",
		"code",
		"OS",
		"OS",
		"EditClass",
		"lpWndClass",
		"EditProc",
		"lpWndClass",
		"OS",
		"UpDownClass",
		"lpWndClass",
		"UpDownProc",
		"lpWndClass",
		"parent",
		"style",
		"handle",
		"hwnd",
		"hwndText",
		"OS",
		"EditProc",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"hwnd",
		"hwndUpDown",
		"OS",
		"UpDownProc",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"OS",
		"handle",
		"msg",
		"wParam",
		"lParam",
		"style",
		"SWT",
		"SWT",
		"hwnd",
		"handle",
		"hwnd",
		"hwndText",
		"hwnd",
		"hwndUpDown",
		"SWT",
		"state",
		"CANVAS",
		"OS",
		"style",
		"SWT",
		"OS",
		"OS",
		"OS",
		"OS",
		"style",
		"SWT",
		"textStyle",
		"OS",
		"OS",
		"OS",
		"style",
		"SWT",
		"textExStyle",
		"OS",
		"hwndText",
		"OS",
		"textExStyle",
		"EditClass",
		"textStyle",
		"handle",
		"hInstance",
		"hwndText",
		"SWT",
		"OS",
		"hwndText",
		"OS",
		"hwndText",
		"OS",
		"OS",
		"style",
		"SWT",
		"upDownStyle",
		"OS",
		"hwndUpDown",
		"OS",
		"UpDownClass",
		"upDownStyle",
		"handle",
		"hInstance",
		"hwndUpDown",
		"SWT",
		"OS",
		"hwndUpDown",
		"OS",
		"hwndUpDown",
		"OS",
		"OS",
		"handle",
		"OS",
		"hwndText",
		"hIMC",
		"OS",
		"hwndUpDown",
		"hIMC",
		"OS",
		"handle",
		"hIMC",
		"OS",
		"hwndUpDown",
		"OS",
		"OS",
		"hwndUpDown",
		"OS",
		"OS",
		"OS",
		"pageIncrement",
		"digits",
		"OS",
		"hwndText",
		"buffer",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"SWT",
		"typedListener",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"hwndText",
		"wHint",
		"SWT",
		"hHint",
		"SWT",
		"OS",
		"hwndText",
		"newFont",
		"OS",
		"hwndText",
		"OS",
		"newFont",
		"oldFont",
		"OS",
		"hDC",
		"newFont",
		"OS",
		"OS",
		"hDC",
		"tm",
		"height",
		"tm",
		"OS",
		"hwndUpDown",
		"OS",
		"max",
		"String",
		"max",
		"digits",
		"buffer",
		"string",
		"buffer",
		"digits",
		"string",
		"count",
		"buffer",
		"count",
		"string",
		"buffer",
		"string",
		"OS",
		"OS",
		"OS",
		"OS",
		"hDC",
		"buffer",
		"buffer",
		"rect",
		"flags",
		"width",
		"rect",
		"rect",
		"newFont",
		"OS",
		"hDC",
		"oldFont",
		"OS",
		"hwndText",
		"hDC",
		"width",
		"width",
		"DEFAULT_WIDTH",
		"height",
		"height",
		"DEFAULT_HEIGHT",
		"wHint",
		"SWT",
		"width",
		"wHint",
		"hHint",
		"SWT",
		"height",
		"hHint",
		"width",
		"height",
		"hHint",
		"SWT",
		"trim",
		"Math",
		"trim",
		"OS",
		"OS",
		"trim",
		"trim",
		"OS",
		"rect",
		"x",
		"y",
		"x",
		"width",
		"y",
		"height",
		"OS",
		"hwndText",
		"OS",
		"OS",
		"hwndText",
		"OS",
		"OS",
		"rect",
		"bits0",
		"bits1",
		"width",
		"rect",
		"rect",
		"height",
		"rect",
		"rect",
		"OS",
		"hwndText",
		"OS",
		"x",
		"margins",
		"width",
		"margins",
		"margins",
		"style",
		"SWT",
		"x",
		"y",
		"width",
		"height",
		"width",
		"OS",
		"OS",
		"x",
		"y",
		"width",
		"height",
		"OS",
		"hwndText",
		"OS",
		"style",
		"SWT",
		"OS",
		"hwndText",
		"OS",
		"OS",
		"OS",
		"enabled",
		"OS",
		"hwndText",
		"enabled",
		"OS",
		"hwndUpDown",
		"enabled",
		"display",
		"hwndText",
		"display",
		"hwndUpDown",
		"OS",
		"hwndFocus",
		"handle",
		"hwndFocus",
		"hwndText",
		"hwndFocus",
		"hwndUpDown",
		"digits",
		"OS",
		"OS",
		"OS",
		"tchar",
		"size",
		"tchar",
		"size",
		"OS",
		"hwndUpDown",
		"OS",
		"udaccel",
		"udaccel",
		"OS",
		"hwndUpDown",
		"OS",
		"max",
		"max",
		"OS",
		"hwndUpDown",
		"OS",
		"min",
		"min",
		"pageIncrement",
		"OS",
		"OS",
		"hwndUpDown",
		"OS",
		"OS",
		"hwndUpDown",
		"OS",
		"OS",
		"hwndText",
		"length",
		"OS",
		"hwndText",
		"buffer",
		"length",
		"buffer",
		"length",
		"digits",
		"string",
		"decimalSeparator",
		"index",
		"string",
		"index",
		"string",
		"index",
		"decimalPart",
		"digits",
		"decimalPart",
		"decimalPart",
		"digits",
		"digits",
		"decimalPart",
		"j",
		"i",
		"j",
		"decimalPart",
		"decimalPart",
		"Integer",
		"wholePart",
		"Integer",
		"decimalPart",
		"i",
		"digits",
		"i",
		"wholeValue",
		"value",
		"wholeValue",
		"decimalValue",
		"value",
		"Integer",
		"string",
		"value",
		"Integer",
		"string",
		"OS",
		"hwndUpDown",
		"OS",
		"min",
		"max",
		"min",
		"value",
		"value",
		"max",
		"value",
		"OS",
		"OS",
		"hwndUpDown",
		"OS",
		"OS",
		"hwndUpDown",
		"OS",
		"mbcsPos",
		"OS",
		"mbcsPos",
		"OS",
		"hwndText",
		"mbcsSize",
		"mbcsPos",
		"mbcsSize",
		"mbcsSize",
		"mbcsSize",
		"OS",
		"hwndText",
		"buffer",
		"mbcsSize",
		"OS",
		"OS",
		"buffer",
		"mbcsPos",
		"style",
		"SWT",
		"OS",
		"hwndText",
		"OS",
		"display",
		"hwndText",
		"display",
		"hwndUpDown",
		"hwndText",
		"hwndUpDown",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"eventTable",
		"SWT",
		"listener",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"type",
		"msg",
		"wParam",
		"lParam",
		"event",
		"style",
		"SWT",
		"type",
		"SWT",
		"msg",
		"OS",
		"msg",
		"OS",
		"msg",
		"OS",
		"event",
		"event",
		"event",
		"msg",
		"OS",
		"key",
		"key",
		"key",
		"key",
		"key",
		"OS",
		"stateMask",
		"SWT",
		"SWT",
		"SWT",
		"OS",
		"OS",
		"OS",
		"hwndText",
		"OS",
		"start",
		"end",
		"key",
		"start",
		"end",
		"start",
		"start",
		"start",
		"OS",
		"OS",
		"OS",
		"hwndText",
		"OS",
		"start",
		"end",
		"OS",
		"hwndText",
		"OS",
		"newStart",
		"newEnd",
		"start",
		"newStart",
		"start",
		"start",
		"start",
		"Math",
		"start",
		"start",
		"end",
		"OS",
		"hwndText",
		"start",
		"length",
		"end",
		"end",
		"OS",
		"OS",
		"OS",
		"hwndText",
		"OS",
		"start",
		"end",
		"OS",
		"hwndText",
		"OS",
		"newStart",
		"newEnd",
		"end",
		"newEnd",
		"end",
		"end",
		"end",
		"Math",
		"end",
		"length",
		"key",
		"key",
		"oldText",
		"key",
		"oldText",
		"start",
		"end",
		"event",
		"newText",
		"newText",
		"oldText",
		"newText",
		"OS",
		"hwndText",
		"OS",
		"start",
		"end",
		"OS",
		"hwndText",
		"OS",
		"buffer",
		"background",
		"pixel",
		"pixel",
		"OS",
		"hwndText",
		"value",
		"SWT",
		"value",
		"value",
		"OS",
		"pos",
		"OS",
		"hwndUpDown",
		"OS",
		"pos",
		"OS",
		"hwndUpDown",
		"OS",
		"pos",
		"foreground",
		"pixel",
		"pixel",
		"OS",
		"hwndText",
		"value",
		"OS",
		"OS",
		"hwndUpDown",
		"OS",
		"OS",
		"hHeap",
		"OS",
		"UDACCEL",
		"count",
		"OS",
		"hwndUpDown",
		"OS",
		"count",
		"udaccels",
		"i",
		"count",
		"i",
		"udaccels",
		"i",
		"UDACCEL",
		"OS",
		"udaccel",
		"offset",
		"UDACCEL",
		"first",
		"first",
		"udaccel",
		"udaccel",
		"udaccel",
		"value",
		"first",
		"OS",
		"offset",
		"udaccel",
		"UDACCEL",
		"OS",
		"hwndUpDown",
		"OS",
		"count",
		"udaccels",
		"OS",
		"hHeap",
		"udaccels",
		"value",
		"OS",
		"hwndUpDown",
		"OS",
		"min",
		"value",
		"min",
		"OS",
		"pos",
		"OS",
		"hwndUpDown",
		"OS",
		"pos",
		"OS",
		"hwndUpDown",
		"OS",
		"OS",
		"hwndUpDown",
		"OS",
		"min",
		"value",
		"pos",
		"value",
		"value",
		"value",
		"OS",
		"hwndUpDown",
		"OS",
		"max",
		"value",
		"max",
		"OS",
		"pos",
		"OS",
		"hwndUpDown",
		"OS",
		"pos",
		"OS",
		"hwndUpDown",
		"OS",
		"OS",
		"hwndUpDown",
		"OS",
		"value",
		"max",
		"pos",
		"value",
		"value",
		"value",
		"pageIncrement",
		"value",
		"OS",
		"hwndUpDown",
		"OS",
		"min",
		"max",
		"value",
		"Math",
		"Math",
		"min",
		"value",
		"max",
		"value",
		"OS",
		"hwndUpDown",
		"OS",
		"OS",
		"OS",
		"value",
		"String",
		"value",
		"digits",
		"string",
		"digits",
		"index",
		"buffer",
		"string",
		"index",
		"buffer",
		"decimalSeparator",
		"buffer",
		"string",
		"index",
		"buffer",
		"buffer",
		"decimalSeparator",
		"index",
		"buffer",
		"buffer",
		"string",
		"string",
		"buffer",
		"SWT",
		"SWT",
		"OS",
		"hwndText",
		"string",
		"string",
		"length",
		"string",
		"string",
		"OS",
		"hwndText",
		"buffer",
		"notify",
		"SWT",
		"display",
		"OS",
		"hwndText",
		"OS",
		"newProc",
		"OS",
		"hwndUpDown",
		"OS",
		"newProc",
		"OS",
		"hwndText",
		"OS",
		"EditProc",
		"OS",
		"hwndUpDown",
		"OS",
		"UpDownProc",
		"event",
		"string",
		"event",
		"start",
		"event",
		"end",
		"keyEvent",
		"event",
		"keyEvent",
		"event",
		"keyEvent",
		"event",
		"keyEvent",
		"digits",
		"index",
		"string",
		"decimalSeparator",
		"index",
		"string",
		"string",
		"index",
		"string",
		"index",
		"index",
		"index",
		"string",
		"Character",
		"string",
		"index",
		"index",
		"event",
		"index",
		"string",
		"OS",
		"OS",
		"event",
		"start",
		"event",
		"end",
		"SWT",
		"event",
		"event",
		"event",
		"OS",
		"hwnd",
		"hwndText",
		"hwnd",
		"hwndUpDown",
		"msg",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"hwnd",
		"hwndText",
		"result",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"result",
		"result",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"result",
		"result",
		"wParam",
		"LRESULT",
		"OS",
		"hwndText",
		"wParam",
		"lParam",
		"result",
		"result",
		"OS",
		"hwndText",
		"OS",
		"wParam",
		"lParam",
		"result",
		"wParam",
		"lParam",
		"result",
		"lParam",
		"lParam",
		"OS",
		"OS",
		"width",
		"upDownWidth",
		"OS",
		"OS",
		"OS",
		"hwndText",
		"textWidth",
		"height",
		"flags",
		"hwndUpDown",
		"textWidth",
		"upDownWidth",
		"height",
		"flags",
		"result",
		"hwnd",
		"wParam",
		"lParam",
		"result",
		"result",
		"wParam",
		"SWT",
		"value",
		"SWT",
		"SWT",
		"SWT",
		"LRESULT",
		"result",
		"style",
		"SWT",
		"msg",
		"OS",
		"OS",
		"OS",
		"hwndText",
		"OS",
		"start",
		"end",
		"start",
		"end",
		"newText",
		"call",
		"OS",
		"OS",
		"hwndText",
		"OS",
		"start",
		"end",
		"newText",
		"OS",
		"OS",
		"OS",
		"hwndText",
		"OS",
		"ignoreModify",
		"OS",
		"hwndText",
		"OS",
		"start",
		"end",
		"OS",
		"EditProc",
		"hwndText",
		"msg",
		"wParam",
		"lParam",
		"OS",
		"hwndText",
		"length",
		"start",
		"end",
		"length",
		"OS",
		"hwndText",
		"buffer",
		"length",
		"newText",
		"buffer",
		"start",
		"end",
		"start",
		"newText",
		"OS",
		"EditProc",
		"hwndText",
		"msg",
		"wParam",
		"lParam",
		"ignoreModify",
		"newText",
		"newText",
		"oldText",
		"oldText",
		"newText",
		"newText",
		"newText",
		"start",
		"end",
		"newText",
		"LRESULT",
		"newText",
		"oldText",
		"call",
		"OS",
		"EditProc",
		"hwndText",
		"msg",
		"wParam",
		"lParam",
		"newText",
		"msg",
		"OS",
		"OS",
		"buffer",
		"TCHAR",
		"OS",
		"hHeap",
		"OS",
		"byteCount",
		"OS",
		"pszText",
		"buffer",
		"byteCount",
		"OS",
		"EditProc",
		"hwndText",
		"msg",
		"wParam",
		"pszText",
		"OS",
		"hHeap",
		"pszText",
		"code",
		"OS",
		"hwndText",
		"OS",
		"buffer",
		"LRESULT",
		"wParam",
		"code",
		"OS",
		"ignoreModify",
		"SWT",
		"LRESULT",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam",
		"result",
		"result",
		"OS",
		"hwndUpDown",
		"OS",
		"udaccel",
		"wParam",
		"OS",
		"delta",
		"udaccel",
		"OS",
		"delta",
		"udaccel",
		"OS",
		"delta",
		"pageIncrement",
		"OS",
		"delta",
		"pageIncrement",
		"delta",
		"value",
		"delta",
		"OS",
		"hwndUpDown",
		"OS",
		"min",
		"max",
		"style",
		"SWT",
		"newValue",
		"min",
		"newValue",
		"max",
		"newValue",
		"max",
		"newValue",
		"min",
		"newValue",
		"Math",
		"Math",
		"min",
		"newValue",
		"max",
		"value",
		"newValue",
		"newValue",
		"wParam",
		"OS",
		"OS",
		"LRESULT",
		"result",
		"value",
		"hwnd",
		"wParam",
		"lParam",
		"hwnd",
		"hwndUpDown",
		"OS",
		"hwndUpDown",
		"OS",
		"OS",
		"OS",
		"value",
		"hwnd",
		"wParam",
		"lParam",
		"OS",
		"hdr",
		"lParam",
		"NMHDR",
		"hdr",
		"OS",
		"OS",
		"lpnmud",
		"lParam",
		"NMUPDOWN",
		"lpnmud",
		"lpnmud",
		"OS",
		"hwndUpDown",
		"OS",
		"min",
		"max",
		"style",
		"SWT",
		"value",
		"min",
		"value",
		"max",
		"value",
		"max",
		"value",
		"min",
		"value",
		"Math",
		"Math",
		"min",
		"value",
		"max",
		"value",
		"LRESULT",
		"wParam",
		"lParam",
		"wParam",
		"code",
		"OS",
		"SWT",
		"wParam",
		"lParam",
		"UPDOWN_CLASS",
		"lpfnWndProc",
		"lpfnWndProc",
		"H_SCROLL",
		"V_SCROLL",
		"ERROR_INVALID_SUBCLASS",
		"BORDER",
		"WS_EX_CLIENTEDGE",
		"WS_CHILD",
		"WS_VISIBLE",
		"ES_AUTOHSCROLL",
		"READ_ONLY",
		"ES_READONLY",
		"WIN32_VERSION",
		"RIGHT_TO_LEFT",
		"WS_EX_LAYOUTRTL",
		"ERROR_NO_HANDLES",
		"GWL_ID",
		"WS_CHILD",
		"WS_VISIBLE",
		"WRAP",
		"UDS_WRAP",
		"ERROR_NO_HANDLES",
		"GWL_ID",
		"IsDBLocale",
		"UDM_SETRANGE32",
		"IsWinCE",
		"UDM_SETPOS",
		"UDM_SETPOS32",
		"ERROR_NULL_ARGUMENT",
		"Modify",
		"ERROR_NULL_ARGUMENT",
		"Selection",
		"DefaultSelection",
		"ERROR_NULL_ARGUMENT",
		"Verify",
		"DEFAULT",
		"DEFAULT",
		"WM_GETFONT",
		"IsUnicode",
		"tmHeight",
		"UDM_GETRANGE32",
		"DT_CALCRECT",
		"DT_EDITCONTROL",
		"DT_NOPREFIX",
		"right",
		"left",
		"DEFAULT",
		"DEFAULT",
		"DEFAULT",
		"height",
		"height",
		"SM_CYVSCROLL",
		"width",
		"height",
		"GWL_STYLE",
		"GWL_EXSTYLE",
		"right",
		"left",
		"bottom",
		"top",
		"EM_GETMARGINS",
		"BORDER",
		"SM_CXVSCROLL",
		"WM_COPY",
		"READ_ONLY",
		"WM_CUT",
		"COLOR_WINDOW",
		"LOCALE_USER_DEFAULT",
		"LOCALE_SDECIMAL",
		"UDM_GETACCEL",
		"nInc",
		"UDM_GETRANGE32",
		"UDM_GETRANGE32",
		"IsWinCE",
		"UDM_GETPOS",
		"UDM_GETPOS32",
		"UDM_GETRANGE32",
		"IsWinCE",
		"UDM_GETPOS",
		"UDM_GETPOS32",
		"IsUnicode",
		"MB_PRECOMPOSED",
		"READ_ONLY",
		"WM_PASTE",
		"ERROR_NULL_ARGUMENT",
		"Modify",
		"ERROR_NULL_ARGUMENT",
		"Selection",
		"DefaultSelection",
		"ERROR_NULL_ARGUMENT",
		"Verify",
		"READ_ONLY",
		"KeyDown",
		"WM_CHAR",
		"WM_KEYDOWN",
		"WM_IME_CHAR",
		"character",
		"character",
		"stateMask",
		"WM_CHAR",
		"WM_KEYDOWN",
		"ALT",
		"SHIFT",
		"CONTROL",
		"VK_LBUTTON",
		"EM_GETSEL",
		"IsUnicode",
		"IsDBLocale",
		"EM_SETSEL",
		"EM_GETSEL",
		"IsUnicode",
		"IsDBLocale",
		"EM_SETSEL",
		"EM_GETSEL",
		"EM_SETSEL",
		"EM_REPLACESEL",
		"ERROR_INVALID_ARGUMENT",
		"digits",
		"digits",
		"IsWinCE",
		"UDM_GETPOS",
		"UDM_GETPOS32",
		"UDM_GETACCEL",
		"HEAP_ZERO_MEMORY",
		"sizeof",
		"UDM_GETACCEL",
		"sizeof",
		"sizeof",
		"nInc",
		"nInc",
		"nInc",
		"sizeof",
		"UDM_SETACCEL",
		"UDM_GETRANGE32",
		"IsWinCE",
		"UDM_GETPOS",
		"UDM_GETPOS32",
		"UDM_SETRANGE32",
		"UDM_GETRANGE32",
		"IsWinCE",
		"UDM_GETPOS",
		"UDM_GETPOS32",
		"UDM_SETRANGE32",
		"UDM_GETRANGE32",
		"IsWinCE",
		"UDM_SETPOS",
		"UDM_SETPOS32",
		"Verify",
		"Verify",
		"Selection",
		"windowProc",
		"GWL_WNDPROC",
		"GWL_WNDPROC",
		"GWL_WNDPROC",
		"GWL_WNDPROC",
		"text",
		"start",
		"end",
		"character",
		"character",
		"keyCode",
		"keyCode",
		"stateMask",
		"stateMask",
		"doit",
		"IsUnicode",
		"IsDBLocale",
		"start",
		"end",
		"Verify",
		"doit",
		"text",
		"WS_EX_CLIENTEDGE",
		"WM_CHAR",
		"WM_IME_CHAR",
		"WM_KEYDOWN",
		"WM_KEYUP",
		"WM_SYSCHAR",
		"WM_SYSKEYDOWN",
		"WM_SYSKEYUP",
		"WM_CAPTURECHANGED",
		"WM_LBUTTONDBLCLK",
		"WM_LBUTTONDOWN",
		"WM_LBUTTONUP",
		"WM_MBUTTONDBLCLK",
		"WM_MBUTTONDOWN",
		"WM_MBUTTONUP",
		"WM_MOUSEHOVER",
		"WM_MOUSELEAVE",
		"WM_MOUSEMOVE",
		"WM_RBUTTONDBLCLK",
		"WM_RBUTTONDOWN",
		"WM_RBUTTONUP",
		"WM_XBUTTONDBLCLK",
		"WM_XBUTTONDOWN",
		"WM_XBUTTONUP",
		"WM_SETFOCUS",
		"WM_KILLFOCUS",
		"WM_PAINT",
		"WM_CONTEXTMENU",
		"WM_CLEAR",
		"WM_CUT",
		"WM_PASTE",
		"WM_UNDO",
		"EM_UNDO",
		"value",
		"ONE",
		"WM_SETFONT",
		"SM_CXVSCROLL",
		"SWP_NOZORDER",
		"SWP_DRAWFRAME",
		"SWP_NOACTIVATE",
		"CR",
		"DefaultSelection",
		"TAB",
		"ESC",
		"ZERO",
		"READ_ONLY",
		"WM_CLEAR",
		"WM_CUT",
		"EM_GETSEL",
		"WM_PASTE",
		"EM_GETSEL",
		"EM_UNDO",
		"WM_UNDO",
		"EM_CANUNDO",
		"EM_GETSEL",
		"ZERO",
		"WM_SETTEXT",
		"sizeof",
		"HEAP_ZERO_MEMORY",
		"EM_REPLACESEL",
		"ZERO",
		"EN_CHANGE",
		"Modify",
		"ZERO",
		"UDM_GETACCEL",
		"VK_UP",
		"nInc",
		"VK_DOWN",
		"nInc",
		"VK_PRIOR",
		"VK_NEXT",
		"UDM_GETRANGE32",
		"WRAP",
		"VK_UP",
		"VK_DOWN",
		"ZERO",
		"IsWinCE",
		"UDM_SETPOS",
		"UDM_SETPOS32",
		"sizeof",
		"code",
		"UDN_DELTAPOS",
		"sizeof",
		"iPos",
		"iDelta",
		"UDM_GETRANGE32",
		"WRAP",
		"ONE",
		"SB_THUMBPOSITION",
		"Selection",
		"parent",
		"style",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"style",
		"hwnd",
		"listener",
		"listener",
		"listener",
		"wHint",
		"hHint",
		"changed",
		"x",
		"y",
		"width",
		"height",
		"enabled",
		"e",
		"mbcsPos",
		"listener",
		"listener",
		"listener",
		"type",
		"msg",
		"wParam",
		"lParam",
		"event",
		"pixel",
		"value",
		"pixel",
		"value",
		"value",
		"value",
		"value",
		"value",
		"value",
		"notify",
		"string",
		"start",
		"end",
		"keyEvent",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam",
		"hwndText",
		"msg",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam"
	],
	"extendORImplementFiles":[
		"Composite"
	],
	"package":[
		"org.eclipse.swt.widgets"
	],
	"import":[
		"org.eclipse.swt",
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt.graphics",
		"org.eclipse.swt.events"
	],
	"methods":[
		"callWindowProc",
		"checkStyle",
		"checkHandle",
		"checkSubclass",
		"createHandle",
		"addModifyListener",
		"addSelectionListener",
		"addVerifyListener",
		"borderHandle",
		"computeSize",
		"computeTrim",
		"copy",
		"cut",
		"defaultBackground",
		"enableWidget",
		"deregister",
		"hasFocus",
		"getDigits",
		"getDecimalSeparator",
		"getIncrement",
		"getMaximum",
		"getMinimum",
		"getPageIncrement",
		"getSelection",
		"getSelectionText",
		"mbcsToWcsPos",
		"paste",
		"register",
		"releaseHandle",
		"removeModifyListener",
		"removeSelectionListener",
		"removeVerifyListener",
		"sendKeyEvent",
		"setBackgroundPixel",
		"setDigits",
		"setForegroundPixel",
		"setIncrement",
		"setMaximum",
		"setMinimum",
		"setPageIncrement",
		"setSelection",
		"setSelection",
		"subclass",
		"unsubclass",
		"verifyText",
		"widgetExtStyle",
		"windowProc",
		"WM_ERASEBKGND",
		"WM_KILLFOCUS",
		"WM_SETFOCUS",
		"WM_SETFONT",
		"WM_SIZE",
		"wmChar",
		"wmClipboard",
		"wmCommandChild",
		"wmKeyDown",
		"wmKillFocus",
		"wmLButtonDown",
		"wmNotifyChild",
		"wmScrollChild",
		"GetClassInfo",
		"GetClassInfo",
		"checkStyle",
		"CallWindowProc",
		"CallWindowProc",
		"DefWindowProc",
		"isValidSubclass",
		"error",
		"createHandle",
		"GetModuleHandle",
		"VERSION",
		"CreateWindowEx",
		"error",
		"SetWindowLong",
		"CreateWindowEx",
		"error",
		"SetWindowLong",
		"ImmGetContext",
		"ImmAssociateContext",
		"ImmAssociateContext",
		"ImmReleaseContext",
		"SendMessage",
		"SendMessage",
		"getCodePage",
		"SetWindowText",
		"checkWidget",
		"error",
		"addListener",
		"checkWidget",
		"error",
		"addListener",
		"addListener",
		"checkWidget",
		"error",
		"addListener",
		"checkWidget",
		"GetDC",
		"SendMessage",
		"SelectObject",
		"GetTextMetrics",
		"SendMessage",
		"valueOf",
		"append",
		"append",
		"getDecimalSeparator",
		"length",
		"append",
		"toString",
		"getCodePage",
		"DrawText",
		"length",
		"SelectObject",
		"ReleaseDC",
		"computeTrim",
		"max",
		"GetSystemMetrics",
		"checkWidget",
		"SetRect",
		"GetWindowLong",
		"GetWindowLong",
		"AdjustWindowRectEx",
		"SendMessage",
		"GetSystemMetrics",
		"checkWidget",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"GetSysColor",
		"enableWidget",
		"EnableWindow",
		"EnableWindow",
		"deregister",
		"removeControl",
		"removeControl",
		"GetFocus",
		"checkWidget",
		"getCodePage",
		"GetLocaleInfo",
		"toString",
		"checkWidget",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"checkWidget",
		"SendMessage",
		"checkWidget",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"GetWindowTextLength",
		"getCodePage",
		"GetWindowText",
		"toString",
		"getDecimalSeparator",
		"indexOf",
		"substring",
		"substring",
		"length",
		"substring",
		"length",
		"parseInt",
		"parseInt",
		"parseInt",
		"parseInt",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"GetWindowTextLengthA",
		"GetWindowTextA",
		"MultiByteToWideChar",
		"getCodePage",
		"checkWidget",
		"SendMessage",
		"register",
		"addControl",
		"addControl",
		"releaseHandle",
		"checkWidget",
		"error",
		"unhook",
		"checkWidget",
		"error",
		"unhook",
		"unhook",
		"checkWidget",
		"error",
		"unhook",
		"sendKeyEvent",
		"GetKeyState",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"max",
		"GetWindowTextLength",
		"SendMessage",
		"SendMessage",
		"min",
		"verifyText",
		"getCodePage",
		"SendMessage",
		"SendMessage",
		"setBackgroundPixel",
		"InvalidateRect",
		"checkWidget",
		"error",
		"SendMessage",
		"SendMessage",
		"setSelection",
		"setForegroundPixel",
		"InvalidateRect",
		"checkWidget",
		"GetProcessHeap",
		"SendMessage",
		"HeapAlloc",
		"SendMessage",
		"MoveMemory",
		"MoveMemory",
		"SendMessage",
		"HeapFree",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"setSelection",
		"checkWidget",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"SendMessage",
		"setSelection",
		"checkWidget",
		"checkWidget",
		"SendMessage",
		"min",
		"max",
		"setSelection",
		"SendMessage",
		"valueOf",
		"getDecimalSeparator",
		"length",
		"append",
		"substring",
		"append",
		"append",
		"substring",
		"append",
		"append",
		"append",
		"append",
		"toString",
		"hooks",
		"filters",
		"GetWindowTextLength",
		"verifyText",
		"getCodePage",
		"SetWindowText",
		"postEvent",
		"subclass",
		"SetWindowLong",
		"SetWindowLong",
		"unsubclass",
		"SetWindowLong",
		"SetWindowLong",
		"getDecimalSeparator",
		"indexOf",
		"substring",
		"substring",
		"length",
		"isDigit",
		"charAt",
		"length",
		"mbcsToWcsPos",
		"mbcsToWcsPos",
		"sendEvent",
		"isDisposed",
		"widgetExtStyle",
		"wmChar",
		"wmIMEChar",
		"wmKeyDown",
		"wmKeyUp",
		"wmSysChar",
		"wmSysKeyDown",
		"wmSysKeyUp",
		"wmCaptureChanged",
		"wmLButtonDblClk",
		"wmLButtonDown",
		"wmLButtonUp",
		"wmMButtonDblClk",
		"wmMButtonDown",
		"wmMButtonUp",
		"wmMouseHover",
		"wmMouseLeave",
		"wmMouseMove",
		"wmRButtonDblClk",
		"wmRButtonDown",
		"wmRButtonUp",
		"wmXButtonDblClk",
		"wmXButtonDown",
		"wmXButtonUp",
		"wmSetFocus",
		"wmKillFocus",
		"wmPaint",
		"wmContextMenu",
		"wmClipboard",
		"callWindowProc",
		"windowProc",
		"WM_ERASEBKGND",
		"drawBackground",
		"SetFocus",
		"WM_SETFONT",
		"SendMessage",
		"WM_SIZE",
		"isDisposed",
		"GetSystemMetrics",
		"SetWindowPos",
		"SetWindowPos",
		"wmChar",
		"getSelectionText",
		"setSelection",
		"postEvent",
		"SendMessage",
		"SendMessage",
		"getClipboardText",
		"SendMessage",
		"SendMessage",
		"CallWindowProc",
		"GetWindowTextLength",
		"getCodePage",
		"GetWindowText",
		"toString",
		"CallWindowProc",
		"equals",
		"verifyText",
		"equals",
		"CallWindowProc",
		"getCodePage",
		"GetProcessHeap",
		"length",
		"HeapAlloc",
		"MoveMemory",
		"CallWindowProc",
		"HeapFree",
		"SendMessage",
		"sendEvent",
		"isDisposed",
		"wmCommandChild",
		"wmKeyDown",
		"SendMessage",
		"getSelectionText",
		"SendMessage",
		"min",
		"max",
		"setSelection",
		"getSelectionText",
		"setSelection",
		"wmKillFocus",
		"getSelectionText",
		"SendMessage",
		"wmLButtonDown",
		"MoveMemory",
		"MoveMemory",
		"SendMessage",
		"min",
		"max",
		"setSelection",
		"wmNotifyChild",
		"postEvent",
		"wmScrollChild",
		"TCHAR",
		"TCHAR",
		"WNDCLASS",
		"TCHAR",
		"TypedListener",
		"TypedListener",
		"TypedListener",
		"TEXTMETRICW",
		"TEXTMETRICA",
		"RECT",
		"StringBuffer",
		"TCHAR",
		"Point",
		"RECT",
		"Rectangle",
		"TCHAR",
		"UDACCEL",
		"TCHAR",
		"String",
		"TCHAR",
		"UDACCEL",
		"StringBuffer",
		"TCHAR",
		"Event",
		"TCHAR",
		"TCHAR",
		"LRESULT",
		"UDACCEL",
		"NMHDR",
		"NMUPDOWN"
	],
	"methodsBody":{
		"int windowProc(int hwnd, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    if (hwnd == hwndText || hwnd == hwndUpDown) {\n        LRESULT result = null;\n        switch(msg) {\n            \n            case OS.WM_CHAR:\n                result = wmChar(hwnd, wParam, lParam);\n                break;\n            case OS.WM_IME_CHAR:\n                result = wmIMEChar(hwnd, wParam, lParam);\n                break;\n            case OS.WM_KEYDOWN:\n                result = wmKeyDown(hwnd, wParam, lParam);\n                break;\n            case OS.WM_KEYUP:\n                result = wmKeyUp(hwnd, wParam, lParam);\n                break;\n            case OS.WM_SYSCHAR:\n                result = wmSysChar(hwnd, wParam, lParam);\n                break;\n            case OS.WM_SYSKEYDOWN:\n                result = wmSysKeyDown(hwnd, wParam, lParam);\n                break;\n            case OS.WM_SYSKEYUP:\n                result = wmSysKeyUp(hwnd, wParam, lParam);\n                break;\n            \n            case OS.WM_CAPTURECHANGED:\n                result = wmCaptureChanged(hwnd, wParam, lParam);\n                break;\n            case OS.WM_LBUTTONDBLCLK:\n                result = wmLButtonDblClk(hwnd, wParam, lParam);\n                break;\n            case OS.WM_LBUTTONDOWN:\n                result = wmLButtonDown(hwnd, wParam, lParam);\n                break;\n            case OS.WM_LBUTTONUP:\n                result = wmLButtonUp(hwnd, wParam, lParam);\n                break;\n            case OS.WM_MBUTTONDBLCLK:\n                result = wmMButtonDblClk(hwnd, wParam, lParam);\n                break;\n            case OS.WM_MBUTTONDOWN:\n                result = wmMButtonDown(hwnd, wParam, lParam);\n                break;\n            case OS.WM_MBUTTONUP:\n                result = wmMButtonUp(hwnd, wParam, lParam);\n                break;\n            case OS.WM_MOUSEHOVER:\n                result = wmMouseHover(hwnd, wParam, lParam);\n                break;\n            case OS.WM_MOUSELEAVE:\n                result = wmMouseLeave(hwnd, wParam, lParam);\n                break;\n            case OS.WM_MOUSEMOVE:\n                result = wmMouseMove(hwnd, wParam, lParam);\n                break;\n            \n            case OS.WM_RBUTTONDBLCLK:\n                result = wmRButtonDblClk(hwnd, wParam, lParam);\n                break;\n            case OS.WM_RBUTTONDOWN:\n                result = wmRButtonDown(hwnd, wParam, lParam);\n                break;\n            case OS.WM_RBUTTONUP:\n                result = wmRButtonUp(hwnd, wParam, lParam);\n                break;\n            case OS.WM_XBUTTONDBLCLK:\n                result = wmXButtonDblClk(hwnd, wParam, lParam);\n                break;\n            case OS.WM_XBUTTONDOWN:\n                result = wmXButtonDown(hwnd, wParam, lParam);\n                break;\n            case OS.WM_XBUTTONUP:\n                result = wmXButtonUp(hwnd, wParam, lParam);\n                break;\n            \n            case OS.WM_SETFOCUS:\n                result = wmSetFocus(hwnd, wParam, lParam);\n                break;\n            case OS.WM_KILLFOCUS:\n                result = wmKillFocus(hwnd, wParam, lParam);\n                break;\n            \n            case OS.WM_PAINT:\n                result = wmPaint(hwnd, wParam, lParam);\n                break;\n            \n            case OS.WM_CONTEXTMENU:\n                result = wmContextMenu(hwnd, wParam, lParam);\n                break;\n            \n            case OS.WM_CLEAR:\n            case OS.WM_CUT:\n            case OS.WM_PASTE:\n            case OS.WM_UNDO:\n            case OS.EM_UNDO:\n                if (hwnd == hwndText) {\n                    result = wmClipboard(hwnd, msg, wParam, lParam);\n                }\n                break;\n        }\n        if (result != null)\n            return result.value;\n        return callWindowProc(hwnd, msg, wParam, lParam);\n    }\n    return super.windowProc(hwnd, msg, wParam, lParam);\n}",
			"comments":"/* Keyboard messages */\n/* Mouse Messages */\n//\t\t\tcase OS.WM_MOUSEWHEEL:\t\tresult = wmMouseWheel (hwnd, wParam, lParam); break;\n/* Focus Messages */\n/* Paint messages */\n/* Menu messages */\n/* Clipboard messages */\n",
			"methodName":"int windowProc(int hwnd, int msg, int wParam, int lParam)"
		},
		"boolean hasFocus()":{
			"methodBody":"{\n    int hwndFocus = OS.GetFocus();\n    if (hwndFocus == handle)\n        return true;\n    if (hwndFocus == hwndText)\n        return true;\n    if (hwndFocus == hwndUpDown)\n        return true;\n    return false;\n}",
			"comments":"",
			"methodName":"boolean hasFocus()"
		},
		"void enableWidget(boolean enabled)":{
			"methodBody":"{\n    super.enableWidget(enabled);\n    OS.EnableWindow(hwndText, enabled);\n    OS.EnableWindow(hwndUpDown, enabled);\n}",
			"comments":"",
			"methodName":"void enableWidget(boolean enabled)"
		},
		"public int getPageIncrement()":{
			"methodBody":"{\n    checkWidget();\n    return pageIncrement;\n}",
			"comments":"/**\n* Returns the amount that the receiver's position will be\n* modified by when the page up/down keys are pressed.\n*\n* @return the page increment\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getPageIncrement()"
		},
		"void deregister()":{
			"methodBody":"{\n    super.deregister();\n    display.removeControl(hwndText);\n    display.removeControl(hwndUpDown);\n}",
			"comments":"",
			"methodName":"void deregister()"
		},
		"LRESULT WM_SETFOCUS(int wParam, int lParam)":{
			"methodBody":"{\n    OS.SetFocus(hwndText);\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_SETFOCUS(int wParam, int lParam)"
		},
		"LRESULT wmCommandChild(int wParam, int lParam)":{
			"methodBody":"{\n    int code = wParam >> 16;\n    switch(code) {\n        case OS.EN_CHANGE:\n            if (ignoreModify)\n                break;\n            sendEvent(SWT.Modify);\n            if (isDisposed())\n                return LRESULT.ZERO;\n            break;\n    }\n    return super.wmCommandChild(wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT wmCommandChild(int wParam, int lParam)"
		},
		"public void copy()":{
			"methodBody":"{\n    checkWidget();\n    OS.SendMessage(hwndText, OS.WM_COPY, 0, 0);\n}",
			"comments":"/**\n* Copies the selected text.\n* <p>\n* The current selection is copied to the clipboard.\n* </p>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void copy()"
		},
		"protected void checkSubclass()":{
			"methodBody":"{\n    if (!isValidSubclass())\n        error(SWT.ERROR_INVALID_SUBCLASS);\n}",
			"comments":"",
			"methodName":"protected void checkSubclass()"
		},
		"public int getMaximum()":{
			"methodBody":"{\n    checkWidget();\n    int[] max = new int[1];\n    OS.SendMessage(hwndUpDown, OS.UDM_GETRANGE32, null, max);\n    return max[0];\n}",
			"comments":"/**\n* Returns the maximum value which the receiver will allow.\n*\n* @return the maximum\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getMaximum()"
		},
		"public void removeSelectionListener(SelectionListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.Selection, listener);\n    eventTable.unhook(SWT.DefaultSelection, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when the control is selected.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see SelectionListener\n* @see #addSelectionListener\n*/\n",
			"methodName":"public void removeSelectionListener(SelectionListener listener)"
		},
		"void subclass()":{
			"methodBody":"{\n    super.subclass();\n    int newProc = display.windowProc;\n    OS.SetWindowLong(hwndText, OS.GWL_WNDPROC, newProc);\n    OS.SetWindowLong(hwndUpDown, OS.GWL_WNDPROC, newProc);\n}",
			"comments":"",
			"methodName":"void subclass()"
		},
		"int defaultBackground()":{
			"methodBody":"{\n    return OS.GetSysColor(OS.COLOR_WINDOW);\n}",
			"comments":"",
			"methodName":"int defaultBackground()"
		},
		"LRESULT wmKeyDown(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.wmKeyDown(hwnd, wParam, lParam);\n    if (result != null)\n        return result;\n    \n    UDACCEL udaccel = new UDACCEL();\n    OS.SendMessage(hwndUpDown, OS.UDM_GETACCEL, 1, udaccel);\n    int delta = 0;\n    switch(wParam) {\n        case OS.VK_UP:\n            delta = udaccel.nInc;\n            break;\n        case OS.VK_DOWN:\n            delta = -udaccel.nInc;\n            break;\n        case OS.VK_PRIOR:\n            delta = pageIncrement;\n            break;\n        case OS.VK_NEXT:\n            delta = -pageIncrement;\n            break;\n    }\n    if (delta != 0) {\n        int value = getSelectionText();\n        int newValue = value + delta;\n        int[] max = new int[1], min = new int[1];\n        OS.SendMessage(hwndUpDown, OS.UDM_GETRANGE32, min, max);\n        if ((style & SWT.WRAP) != 0) {\n            if (newValue < min[0])\n                newValue = max[0];\n            if (newValue > max[0])\n                newValue = min[0];\n        }\n        newValue = Math.min(Math.max(min[0], newValue), max[0]);\n        if (value != newValue)\n            setSelection(newValue, true);\n    }\n    \n    switch(wParam) {\n        case OS.VK_UP:\n        case OS.VK_DOWN:\n            return LRESULT.ZERO;\n    }\n    return result;\n}",
			"comments":"/* Increment the value */\n/*  Stop the edit control from moving the caret */\n",
			"methodName":"LRESULT wmKeyDown(int hwnd, int wParam, int lParam)"
		},
		"int widgetExtStyle()":{
			"methodBody":"{\n    return super.widgetExtStyle() & ~OS.WS_EX_CLIENTEDGE;\n}",
			"comments":"",
			"methodName":"int widgetExtStyle()"
		},
		"LRESULT WM_SIZE(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_SIZE(wParam, lParam);\n    if (isDisposed())\n        return result;\n    int width = lParam & 0xFFFF, height = lParam >> 16;\n    int upDownWidth = OS.GetSystemMetrics(OS.SM_CXVSCROLL);\n    int textWidth = width - upDownWidth;\n    int flags = OS.SWP_NOZORDER | OS.SWP_DRAWFRAME | OS.SWP_NOACTIVATE;\n    SetWindowPos(hwndText, 0, 0, 0, textWidth, height, flags);\n    SetWindowPos(hwndUpDown, 0, textWidth, 0, upDownWidth, height, flags);\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_SIZE(int wParam, int lParam)"
		},
		"void addVerifyListener(VerifyListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.Verify, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when the receiver's text is verified, by sending\n* it one of the messages defined in the <code>VerifyListener</code>\n* interface.\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see VerifyListener\n* @see #removeVerifyListener\n*/\n",
			"methodName":"void addVerifyListener(VerifyListener listener)"
		},
		"public int getMinimum()":{
			"methodBody":"{\n    checkWidget();\n    int[] min = new int[1];\n    OS.SendMessage(hwndUpDown, OS.UDM_GETRANGE32, min, null);\n    return min[0];\n}",
			"comments":"/**\n* Returns the minimum value which the receiver will allow.\n*\n* @return the minimum\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getMinimum()"
		},
		"int borderHandle()":{
			"methodBody":"{\n    return hwndText;\n}",
			"comments":"",
			"methodName":"int borderHandle()"
		},
		"public int getDigits()":{
			"methodBody":"{\n    checkWidget();\n    return digits;\n}",
			"comments":"/**\n* Returns the number of decimal places used by the receiver.\n*\n* @return the digits\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getDigits()"
		},
		"void createHandle()":{
			"methodBody":"{\n    super.createHandle();\n    state &= ~CANVAS;\n    int hInstance = OS.GetModuleHandle(null);\n    int textExStyle = (style & SWT.BORDER) != 0 ? OS.WS_EX_CLIENTEDGE : 0;\n    int textStyle = OS.WS_CHILD | OS.WS_VISIBLE | OS.ES_AUTOHSCROLL;\n    if ((style & SWT.READ_ONLY) != 0)\n        textStyle |= OS.ES_READONLY;\n    if (OS.WIN32_VERSION >= OS.VERSION(4, 10)) {\n        if ((style & SWT.RIGHT_TO_LEFT) != 0)\n            textExStyle |= OS.WS_EX_LAYOUTRTL;\n    }\n    hwndText = OS.CreateWindowEx(textExStyle, EditClass, null, textStyle, 0, 0, 0, 0, handle, 0, hInstance, null);\n    if (hwndText == 0)\n        error(SWT.ERROR_NO_HANDLES);\n    OS.SetWindowLong(hwndText, OS.GWL_ID, hwndText);\n    int upDownStyle = OS.WS_CHILD | OS.WS_VISIBLE;\n    if ((style & SWT.WRAP) != 0)\n        upDownStyle |= OS.UDS_WRAP;\n    hwndUpDown = OS.CreateWindowEx(0, UpDownClass, null, upDownStyle, 0, 0, 0, 0, handle, 0, hInstance, null);\n    if (hwndUpDown == 0)\n        error(SWT.ERROR_NO_HANDLES);\n    OS.SetWindowLong(hwndUpDown, OS.GWL_ID, hwndUpDown);\n    if (OS.IsDBLocale) {\n        int hIMC = OS.ImmGetContext(handle);\n        OS.ImmAssociateContext(hwndText, hIMC);\n        OS.ImmAssociateContext(hwndUpDown, hIMC);\n        OS.ImmReleaseContext(handle, hIMC);\n    }\n    OS.SendMessage(hwndUpDown, OS.UDM_SETRANGE32, 0, 100);\n    OS.SendMessage(hwndUpDown, OS.IsWinCE ? OS.UDM_SETPOS : OS.UDM_SETPOS32, 0, 0);\n    pageIncrement = 10;\n    digits = 0;\n    TCHAR buffer = new TCHAR(getCodePage(), \"0\", true);\n    OS.SetWindowText(hwndText, buffer);\n}",
			"comments":"",
			"methodName":"void createHandle()"
		},
		"LRESULT wmScrollChild(int wParam, int lParam)":{
			"methodBody":"{\n    int code = wParam & 0xFFFF;\n    switch(code) {\n        case OS.SB_THUMBPOSITION:\n            postEvent(SWT.Selection);\n            break;\n    }\n    return super.wmScrollChild(wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT wmScrollChild(int wParam, int lParam)"
		},
		"int mbcsToWcsPos(int mbcsPos)":{
			"methodBody":"{\n    if (mbcsPos <= 0)\n        return 0;\n    if (OS.IsUnicode)\n        return mbcsPos;\n    int mbcsSize = OS.GetWindowTextLengthA(hwndText);\n    if (mbcsSize == 0)\n        return 0;\n    if (mbcsPos >= mbcsSize)\n        return mbcsSize;\n    byte[] buffer = new byte[mbcsSize + 1];\n    OS.GetWindowTextA(hwndText, buffer, mbcsSize + 1);\n    return OS.MultiByteToWideChar(getCodePage(), OS.MB_PRECOMPOSED, buffer, mbcsPos, null, 0);\n}",
			"comments":"",
			"methodName":"int mbcsToWcsPos(int mbcsPos)"
		},
		"public void setSelection(int value)":{
			"methodBody":"{\n    checkWidget();\n    int[] max = new int[1], min = new int[1];\n    OS.SendMessage(hwndUpDown, OS.UDM_GETRANGE32, min, max);\n    value = Math.min(Math.max(min[0], value), max[0]);\n    setSelection(value, false);\n}",
			"comments":"/**\n* Sets the <em>selection</em>, which is the receiver's\n* position, to the argument. If the argument is not within\n* the range specified by minimum and maximum, it will be\n* adjusted to fall within this range.\n*\n* @param value the new selection (must be zero or greater)\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setSelection(int value)"
		},
		"LRESULT wmLButtonDown(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    if (hwnd == hwndUpDown) {\n        int value = getSelectionText();\n        OS.SendMessage(hwndUpDown, OS.IsWinCE ? OS.UDM_SETPOS : OS.UDM_SETPOS32, 0, value);\n    }\n    return super.wmLButtonDown(hwnd, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT wmLButtonDown(int hwnd, int wParam, int lParam)"
		},
		"String verifyText(String string, int start, int end, Event keyEvent)":{
			"methodBody":"{\n    Event event = new Event();\n    event.text = string;\n    event.start = start;\n    event.end = end;\n    if (keyEvent != null) {\n        event.character = keyEvent.character;\n        event.keyCode = keyEvent.keyCode;\n        event.stateMask = keyEvent.stateMask;\n    }\n    int index = 0;\n    if (digits > 0) {\n        String decimalSeparator = getDecimalSeparator();\n        index = string.indexOf(decimalSeparator);\n        if (index != -1) {\n            string = string.substring(0, index) + string.substring(index + 1);\n        }\n        index = 0;\n    }\n    while (index < string.length()) {\n        if (!Character.isDigit(string.charAt(index)))\n            break;\n        index++;\n    }\n    event.doit = index == string.length();\n    if (!OS.IsUnicode && OS.IsDBLocale) {\n        event.start = mbcsToWcsPos(start);\n        event.end = mbcsToWcsPos(end);\n    }\n    sendEvent(SWT.Verify, event);\n    if (!event.doit || isDisposed())\n        return null;\n    return event.text;\n}",
			"comments":"",
			"methodName":"String verifyText(String string, int start, int end, Event keyEvent)"
		},
		"public void addSelectionListener(SelectionListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.Selection, typedListener);\n    addListener(SWT.DefaultSelection, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when the control is selected, by sending\n* it one of the messages defined in the <code>SelectionListener</code>\n* interface.\n* <p>\n* <code>widgetSelected</code> is not called for texts.\n* <code>widgetDefaultSelected</code> is typically called when ENTER is pressed in a single-line text.\n* </p>\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see SelectionListener\n* @see #removeSelectionListener\n* @see SelectionEvent\n*/\n",
			"methodName":"public void addSelectionListener(SelectionListener listener)"
		},
		"boolean checkHandle(int hwnd)":{
			"methodBody":"{\n    return hwnd == handle || hwnd == hwndText || hwnd == hwndUpDown;\n}",
			"comments":"",
			"methodName":"boolean checkHandle(int hwnd)"
		},
		"LRESULT wmNotifyChild(int wParam, int lParam)":{
			"methodBody":"{\n    NMHDR hdr = new NMHDR();\n    OS.MoveMemory(hdr, lParam, NMHDR.sizeof);\n    switch(hdr.code) {\n        case OS.UDN_DELTAPOS:\n            NMUPDOWN lpnmud = new NMUPDOWN();\n            OS.MoveMemory(lpnmud, lParam, NMUPDOWN.sizeof);\n            int value = lpnmud.iPos + lpnmud.iDelta;\n            int[] max = new int[1], min = new int[1];\n            OS.SendMessage(hwndUpDown, OS.UDM_GETRANGE32, min, max);\n            if ((style & SWT.WRAP) != 0) {\n                if (value < min[0])\n                    value = max[0];\n                if (value > max[0])\n                    value = min[0];\n            }\n            \n            value = Math.min(Math.max(min[0], value), max[0]);\n            setSelection(value, true);\n            return LRESULT.ONE;\n    }\n    return super.wmNotifyChild(wParam, lParam);\n}",
			"comments":"/*\n* The SWT.Modify event is sent after the widget has been\n* updated with the new state.  Rather than allowing\n* the default updown window proc to set the value\n* when the user clicks on the updown control, set\n* the value explicity and stop the window proc\n* from running.\n*/\n",
			"methodName":"LRESULT wmNotifyChild(int wParam, int lParam)"
		},
		"LRESULT WM_ERASEBKGND(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_ERASEBKGND(wParam, lParam);\n    if (result != null)\n        return result;\n    drawBackground(wParam);\n    return LRESULT.ONE;\n}",
			"comments":"",
			"methodName":"LRESULT WM_ERASEBKGND(int wParam, int lParam)"
		},
		"public void removeModifyListener(ModifyListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.Modify, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when the receiver's text is modified.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see ModifyListener\n* @see #addModifyListener\n*/\n",
			"methodName":"public void removeModifyListener(ModifyListener listener)"
		},
		"void unsubclass()":{
			"methodBody":"{\n    super.unsubclass();\n    OS.SetWindowLong(hwndText, OS.GWL_WNDPROC, EditProc);\n    OS.SetWindowLong(hwndUpDown, OS.GWL_WNDPROC, UpDownProc);\n}",
			"comments":"",
			"methodName":"void unsubclass()"
		},
		"void setBackgroundPixel(int pixel)":{
			"methodBody":"{\n    if (background == pixel)\n        return;\n    super.setBackgroundPixel(pixel);\n    OS.InvalidateRect(hwndText, null, true);\n}",
			"comments":"",
			"methodName":"void setBackgroundPixel(int pixel)"
		},
		"int getSelectionText()":{
			"methodBody":"{\n    int length = OS.GetWindowTextLength(hwndText);\n    TCHAR buffer = new TCHAR(getCodePage(), length + 1);\n    OS.GetWindowText(hwndText, buffer, length + 1);\n    String string = buffer.toString(0, length);\n    try {\n        int value;\n        if (digits > 0) {\n            String decimalSeparator = getDecimalSeparator();\n            int index = string.indexOf(decimalSeparator);\n            if (index != -1) {\n                String wholePart = string.substring(0, index);\n                String decimalPart = string.substring(index + 1);\n                if (decimalPart.length() > digits) {\n                    decimalPart = decimalPart.substring(0, digits);\n                } else {\n                    int i = digits - decimalPart.length();\n                    for (int j = 0; j < i; j++) {\n                        decimalPart = decimalPart + \"0\";\n                    }\n                }\n                int wholeValue = Integer.parseInt(wholePart);\n                int decimalValue = Integer.parseInt(decimalPart);\n                for (int i = 0; i < digits; i++) wholeValue *= 10;\n                value = wholeValue + decimalValue;\n            } else {\n                value = Integer.parseInt(string);\n            }\n        } else {\n            value = Integer.parseInt(string);\n        }\n        int[] max = new int[1], min = new int[1];\n        OS.SendMessage(hwndUpDown, OS.UDM_GETRANGE32, min, max);\n        if (min[0] <= value && value <= max[0])\n            return value;\n    } catch (NumberFormatException e) {\n    }\n    if (OS.IsWinCE) {\n        return OS.SendMessage(hwndUpDown, OS.UDM_GETPOS, 0, 0) & 0xFFFF;\n    } else {\n        return OS.SendMessage(hwndUpDown, OS.UDM_GETPOS32, 0, 0);\n    }\n}",
			"comments":"",
			"methodName":"int getSelectionText()"
		},
		"public void setPageIncrement(int value)":{
			"methodBody":"{\n    checkWidget();\n    if (value < 1)\n        return;\n    pageIncrement = value;\n}",
			"comments":"/**\n* Sets the amount that the receiver's position will be\n* modified by when the page up/down keys are pressed\n* to the argument, which must be at least one.\n*\n* @param value the page increment (must be greater than zero)\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setPageIncrement(int value)"
		},
		"public int getSelection()":{
			"methodBody":"{\n    checkWidget();\n    if (OS.IsWinCE) {\n        return OS.SendMessage(hwndUpDown, OS.UDM_GETPOS, 0, 0) & 0xFFFF;\n    } else {\n        return OS.SendMessage(hwndUpDown, OS.UDM_GETPOS32, 0, 0);\n    }\n}",
			"comments":"/**\n* Returns the <em>selection</em>, which is the receiver's position.\n*\n* @return the selection\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getSelection()"
		},
		"public Rectangle computeTrim(int x, int y, int width, int height)":{
			"methodBody":"{\n    checkWidget();\n    \n    RECT rect = new RECT();\n    OS.SetRect(rect, x, y, x + width, y + height);\n    int bits0 = OS.GetWindowLong(hwndText, OS.GWL_STYLE);\n    int bits1 = OS.GetWindowLong(hwndText, OS.GWL_EXSTYLE);\n    OS.AdjustWindowRectEx(rect, bits0, false, bits1);\n    width = rect.right - rect.left;\n    height = rect.bottom - rect.top;\n    \n    int margins = OS.SendMessage(hwndText, OS.EM_GETMARGINS, 0, 0);\n    x -= margins & 0xFFFF;\n    width += (margins & 0xFFFF) + ((margins >> 16) & 0xFFFF);\n    if ((style & SWT.BORDER) != 0) {\n        x -= 1;\n        y -= 1;\n        width += 2;\n        height += 2;\n    }\n    width += OS.GetSystemMetrics(OS.SM_CXVSCROLL);\n    return new Rectangle(x, y, width, height);\n}",
			"comments":"/* Get the trim of the text control */\n/*\n* The preferred height of a single-line text widget\n* has been hand-crafted to be the same height as\n* the single-line text widget in an editable combo\n* box.\n*/\n",
			"methodName":"public Rectangle computeTrim(int x, int y, int width, int height)"
		},
		"void releaseHandle()":{
			"methodBody":"{\n    super.releaseHandle();\n    hwndText = hwndUpDown = 0;\n}",
			"comments":"",
			"methodName":"void releaseHandle()"
		},
		"static int checkStyle(int style)":{
			"methodBody":"{\n    \n    return style & ~(SWT.H_SCROLL | SWT.V_SCROLL);\n}",
			"comments":"/*\n* Even though it is legal to create this widget\n* with scroll bars, they serve no useful purpose\n* because they do not automatically scroll the\n* widget's client area.  The fix is to clear\n* the SWT style.\n*/\n",
			"methodName":"static int checkStyle(int style)"
		},
		"public Point computeSize(int wHint, int hHint, boolean changed)":{
			"methodBody":"{\n    checkWidget();\n    int width = 0, height = 0;\n    if (wHint == SWT.DEFAULT || hHint == SWT.DEFAULT) {\n        int newFont, oldFont = 0;\n        int hDC = OS.GetDC(hwndText);\n        newFont = OS.SendMessage(hwndText, OS.WM_GETFONT, 0, 0);\n        if (newFont != 0)\n            oldFont = OS.SelectObject(hDC, newFont);\n        TEXTMETRIC tm = OS.IsUnicode ? (TEXTMETRIC) new TEXTMETRICW() : new TEXTMETRICA();\n        OS.GetTextMetrics(hDC, tm);\n        height = tm.tmHeight;\n        RECT rect = new RECT();\n        int[] max = new int[1];\n        OS.SendMessage(hwndUpDown, OS.UDM_GETRANGE32, null, max);\n        String string = String.valueOf(max[0]);\n        if (digits > 0) {\n            StringBuffer buffer = new StringBuffer();\n            buffer.append(string);\n            buffer.append(getDecimalSeparator());\n            int count = digits - string.length();\n            while (count >= 0) {\n                buffer.append(\"0\");\n                count--;\n            }\n            string = buffer.toString();\n        }\n        TCHAR buffer = new TCHAR(getCodePage(), string, false);\n        int flags = OS.DT_CALCRECT | OS.DT_EDITCONTROL | OS.DT_NOPREFIX;\n        OS.DrawText(hDC, buffer, buffer.length(), rect, flags);\n        width = rect.right - rect.left;\n        if (newFont != 0)\n            OS.SelectObject(hDC, oldFont);\n        OS.ReleaseDC(hwndText, hDC);\n    }\n    if (width == 0)\n        width = DEFAULT_WIDTH;\n    if (height == 0)\n        height = DEFAULT_HEIGHT;\n    if (wHint != SWT.DEFAULT)\n        width = wHint;\n    if (hHint != SWT.DEFAULT)\n        height = hHint;\n    Rectangle trim = computeTrim(0, 0, width, height);\n    if (hHint == SWT.DEFAULT) {\n        trim.height = Math.max(trim.height, OS.GetSystemMetrics(OS.SM_CYVSCROLL));\n    }\n    return new Point(trim.width, trim.height);\n}",
			"comments":"",
			"methodName":"public Point computeSize(int wHint, int hHint, boolean changed)"
		},
		"public int getIncrement()":{
			"methodBody":"{\n    checkWidget();\n    UDACCEL udaccel = new UDACCEL();\n    OS.SendMessage(hwndUpDown, OS.UDM_GETACCEL, 1, udaccel);\n    return udaccel.nInc;\n}",
			"comments":"/**\n* Returns the amount that the receiver's value will be\n* modified by when the up/down arrows are pressed.\n*\n* @return the increment\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getIncrement()"
		},
		"public void paste()":{
			"methodBody":"{\n    checkWidget();\n    if ((style & SWT.READ_ONLY) != 0)\n        return;\n    OS.SendMessage(hwndText, OS.WM_PASTE, 0, 0);\n}",
			"comments":"/**\n* Pastes text from clipboard.\n* <p>\n* The selected text is deleted from the widget\n* and new text inserted from the clipboard.\n* </p>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void paste()"
		},
		"LRESULT WM_SETFONT(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_SETFONT(wParam, lParam);\n    if (result != null)\n        return result;\n    OS.SendMessage(hwndText, OS.WM_SETFONT, wParam, lParam);\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_SETFONT(int wParam, int lParam)"
		},
		"LRESULT wmChar(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.wmChar(hwnd, wParam, lParam);\n    if (result != null)\n        return result;\n    \n    switch(wParam) {\n        case SWT.CR:\n            int value = getSelectionText();\n            setSelection(value, true);\n            postEvent(SWT.DefaultSelection);\n        \n        case SWT.TAB:\n        case SWT.ESC:\n            return LRESULT.ZERO;\n    }\n    return result;\n}",
			"comments":"/*\n* Feature in Windows.  For some reason, when the\n* widget is a single line text widget, when the\n* user presses tab, return or escape, Windows beeps.\n* The fix is to look for these keys and not call\n* the window proc.\n*/\n// FALL THROUGH\n",
			"methodName":"LRESULT wmChar(int hwnd, int wParam, int lParam)"
		},
		"void register()":{
			"methodBody":"{\n    super.register();\n    display.addControl(hwndText, this);\n    display.addControl(hwndUpDown, this);\n}",
			"comments":"",
			"methodName":"void register()"
		},
		"String getDecimalSeparator()":{
			"methodBody":"{\n    TCHAR tchar = new TCHAR(getCodePage(), 4);\n    int size = OS.GetLocaleInfo(OS.LOCALE_USER_DEFAULT, OS.LOCALE_SDECIMAL, tchar, 4);\n    return size != 0 ? tchar.toString(0, size - 1) : \".\";\n}",
			"comments":"",
			"methodName":"String getDecimalSeparator()"
		},
		"public void cut()":{
			"methodBody":"{\n    checkWidget();\n    if ((style & SWT.READ_ONLY) != 0)\n        return;\n    OS.SendMessage(hwndText, OS.WM_CUT, 0, 0);\n}",
			"comments":"/**\n* Cuts the selected text.\n* <p>\n* The current selection is first copied to the\n* clipboard and then deleted from the widget.\n* </p>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void cut()"
		},
		"public void addModifyListener(ModifyListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.Modify, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notified when the receiver's text is modified, by sending\n* it one of the messages defined in the <code>ModifyListener</code>\n* interface.\n*\n* @param listener the listener which should be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see ModifyListener\n* @see #removeModifyListener\n*/\n",
			"methodName":"public void addModifyListener(ModifyListener listener)"
		},
		"LRESULT wmKillFocus(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    int value = getSelectionText();\n    setSelection(value, true);\n    return super.wmKillFocus(hwnd, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT wmKillFocus(int hwnd, int wParam, int lParam)"
		},
		"public void setDigits(int value)":{
			"methodBody":"{\n    checkWidget();\n    if (value < 0)\n        error(SWT.ERROR_INVALID_ARGUMENT);\n    if (value == this.digits)\n        return;\n    this.digits = value;\n    int pos;\n    if (OS.IsWinCE) {\n        pos = OS.SendMessage(hwndUpDown, OS.UDM_GETPOS, 0, 0) & 0xFFFF;\n    } else {\n        pos = OS.SendMessage(hwndUpDown, OS.UDM_GETPOS32, 0, 0);\n    }\n    setSelection(pos, false);\n}",
			"comments":"/**\n* Sets the number of decimal places used by the receiver.\n* <p>\n* The digit setting is used to allow for floating point values in the receiver.\n* For example, to set the selection to a floating point value of 1.37 call setDigits() with\n* a value of 2 and setSelection() with a value of 137. Similarly, if getDigits() has a value\n* of 2 and getSelection() returns 137 this should be interpreted as 1.37. This applies to all\n* numeric APIs.\n*\n* @param value the new digits (must be greater than or equal to zero)\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the value is less than zero</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setDigits(int value)"
		},
		"LRESULT WM_KILLFOCUS(int wParam, int lParam)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT WM_KILLFOCUS(int wParam, int lParam)"
		},
		"boolean sendKeyEvent(int type, int msg, int wParam, int lParam, Event event)":{
			"methodBody":"{\n    if (!super.sendKeyEvent(type, msg, wParam, lParam, event)) {\n        return false;\n    }\n    if ((style & SWT.READ_ONLY) != 0)\n        return true;\n    if (type != SWT.KeyDown)\n        return true;\n    if (msg != OS.WM_CHAR && msg != OS.WM_KEYDOWN && msg != OS.WM_IME_CHAR) {\n        return true;\n    }\n    if (event.character == 0)\n        return true;\n    \n    char key = event.character;\n    int stateMask = event.stateMask;\n    \n    switch(msg) {\n        case OS.WM_CHAR:\n            if (key != 0x08 && key != 0x7F && key != '\\r' && key != '\\t' && key != '\\n')\n                break;\n        \n        case OS.WM_KEYDOWN:\n            if ((stateMask & (SWT.ALT | SWT.SHIFT | SWT.CONTROL)) != 0)\n                return false;\n            break;\n    }\n    \n    if (OS.GetKeyState(OS.VK_LBUTTON) < 0) {\n        return true;\n    }\n    \n    String oldText = \"\";\n    int[] start = new int[1], end = new int[1];\n    OS.SendMessage(hwndText, OS.EM_GETSEL, start, end);\n    switch(key) {\n        case 0x08:\n            \n            if (start[0] == end[0]) {\n                if (start[0] == 0)\n                    return true;\n                start[0] = start[0] - 1;\n                if (!OS.IsUnicode && OS.IsDBLocale) {\n                    int[] newStart = new int[1], newEnd = new int[1];\n                    OS.SendMessage(hwndText, OS.EM_SETSEL, start[0], end[0]);\n                    OS.SendMessage(hwndText, OS.EM_GETSEL, newStart, newEnd);\n                    if (start[0] != newStart[0])\n                        start[0] = start[0] - 1;\n                }\n                start[0] = Math.max(start[0], 0);\n            }\n            break;\n        case 0x7F:\n            \n            if (start[0] == end[0]) {\n                int length = OS.GetWindowTextLength(hwndText);\n                if (start[0] == length)\n                    return true;\n                end[0] = end[0] + 1;\n                if (!OS.IsUnicode && OS.IsDBLocale) {\n                    int[] newStart = new int[1], newEnd = new int[1];\n                    OS.SendMessage(hwndText, OS.EM_SETSEL, start[0], end[0]);\n                    OS.SendMessage(hwndText, OS.EM_GETSEL, newStart, newEnd);\n                    if (end[0] != newEnd[0])\n                        end[0] = end[0] + 1;\n                }\n                end[0] = Math.min(end[0], length);\n            }\n            break;\n        case '\\r':\n            \n            return true;\n        default:\n            \n            if (key != '\\t' && key < 0x20)\n                return true;\n            oldText = new String(new char[] { key });\n            break;\n    }\n    String newText = verifyText(oldText, start[0], end[0], event);\n    if (newText == null)\n        return false;\n    if (newText == oldText)\n        return true;\n    TCHAR buffer = new TCHAR(getCodePage(), newText, true);\n    OS.SendMessage(hwndText, OS.EM_SETSEL, start[0], end[0]);\n    OS.SendMessage(hwndText, OS.EM_REPLACESEL, 0, buffer);\n    return false;\n}",
			"comments":"//\tif (!hooks (SWT.Verify) && !filters (SWT.Verify)) return true;\n/*\n* Disable all magic keys that could modify the text\n* and don't send events when Alt, Shift or Ctrl is\n* pressed.\n*/\n// FALL THROUGH\n/*\n* If the left button is down, the text widget refuses the character.\n*/\n/* Verify the character */\n/* Bs */\n/* Del */\n/* Return */\n/* Tab and other characters */\n",
			"methodName":"boolean sendKeyEvent(int type, int msg, int wParam, int lParam, Event event)"
		},
		"public void setMinimum(int value)":{
			"methodBody":"{\n    checkWidget();\n    if (value < 0)\n        return;\n    int[] max = new int[1];\n    OS.SendMessage(hwndUpDown, OS.UDM_GETRANGE32, null, max);\n    if (value >= max[0])\n        return;\n    int pos;\n    if (OS.IsWinCE) {\n        pos = OS.SendMessage(hwndUpDown, OS.UDM_GETPOS, 0, 0) & 0xFFFF;\n    } else {\n        pos = OS.SendMessage(hwndUpDown, OS.UDM_GETPOS32, 0, 0);\n    }\n    OS.SendMessage(hwndUpDown, OS.UDM_SETRANGE32, value, max[0]);\n    if (pos < value)\n        setSelection(value, false);\n}",
			"comments":"/**\n* Sets the minimum value that the receiver will allow.  This new\n* value will be ignored if it is negative or is not less than the receiver's\n* current maximum value.  If the new minimum is applied then the receiver's\n* selection value will be adjusted if necessary to fall within its new range.\n*\n* @param value the new minimum, which must be nonnegative and less than the current maximum\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setMinimum(int value)"
		},
		"public void setIncrement(int value)":{
			"methodBody":"{\n    checkWidget();\n    if (value < 1)\n        return;\n    int hHeap = OS.GetProcessHeap();\n    int count = OS.SendMessage(hwndUpDown, OS.UDM_GETACCEL, 0, (UDACCEL) null);\n    int udaccels = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, UDACCEL.sizeof * count);\n    OS.SendMessage(hwndUpDown, OS.UDM_GETACCEL, count, udaccels);\n    int first = -1;\n    UDACCEL udaccel = new UDACCEL();\n    for (int i = 0; i < count; i++) {\n        int offset = udaccels + (i * UDACCEL.sizeof);\n        OS.MoveMemory(udaccel, offset, UDACCEL.sizeof);\n        if (first == -1)\n            first = udaccel.nInc;\n        udaccel.nInc = udaccel.nInc * value / first;\n        OS.MoveMemory(offset, udaccel, UDACCEL.sizeof);\n    }\n    OS.SendMessage(hwndUpDown, OS.UDM_SETACCEL, count, udaccels);\n    OS.HeapFree(hHeap, 0, udaccels);\n}",
			"comments":"/**\n* Sets the amount that the receiver's value will be\n* modified by when the up/down arrows are pressed to\n* the argument, which must be at least one.\n*\n* @param value the new increment (must be greater than zero)\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setIncrement(int value)"
		},
		"void setSelection(int value, boolean notify)":{
			"methodBody":"{\n    OS.SendMessage(hwndUpDown, OS.IsWinCE ? OS.UDM_SETPOS : OS.UDM_SETPOS32, 0, value);\n    String string = String.valueOf(value);\n    if (digits > 0) {\n        String decimalSeparator = getDecimalSeparator();\n        int index = string.length() - digits;\n        StringBuffer buffer = new StringBuffer();\n        if (index > 0) {\n            buffer.append(string.substring(0, index));\n            buffer.append(decimalSeparator);\n            buffer.append(string.substring(index));\n        } else {\n            buffer.append(\"0\");\n            buffer.append(decimalSeparator);\n            while (index++ < 0) buffer.append(\"0\");\n            buffer.append(string);\n        }\n        string = buffer.toString();\n    }\n    if (hooks(SWT.Verify) || filters(SWT.Verify)) {\n        int length = OS.GetWindowTextLength(hwndText);\n        string = verifyText(string, 0, length, null);\n        if (string == null)\n            return;\n    }\n    TCHAR buffer = new TCHAR(getCodePage(), string, true);\n    OS.SetWindowText(hwndText, buffer);\n    if (notify)\n        postEvent(SWT.Selection);\n}",
			"comments":"",
			"methodName":"void setSelection(int value, boolean notify)"
		},
		"public void setMaximum(int value)":{
			"methodBody":"{\n    checkWidget();\n    if (value < 0)\n        return;\n    int[] min = new int[1];\n    OS.SendMessage(hwndUpDown, OS.UDM_GETRANGE32, min, null);\n    if (value <= min[0])\n        return;\n    int pos;\n    if (OS.IsWinCE) {\n        pos = OS.SendMessage(hwndUpDown, OS.UDM_GETPOS, 0, 0) & 0xFFFF;\n    } else {\n        pos = OS.SendMessage(hwndUpDown, OS.UDM_GETPOS32, 0, 0);\n    }\n    OS.SendMessage(hwndUpDown, OS.UDM_SETRANGE32, min[0], value);\n    if (pos > value)\n        setSelection(value, false);\n}",
			"comments":"/**\n* Sets the maximum value that the receiver will allow.  This new\n* value will be ignored if it is not greater than the receiver's current\n* minimum value.  If the new maximum is applied then the receiver's\n* selection value will be adjusted if necessary to fall within its new range.\n*\n* @param value the new maximum, which must be greater than the current minimum\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setMaximum(int value)"
		},
		"void removeVerifyListener(VerifyListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.Verify, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notified when the control is verified.\n*\n* @param listener the listener which should no longer be notified\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see VerifyListener\n* @see #addVerifyListener\n*/\n",
			"methodName":"void removeVerifyListener(VerifyListener listener)"
		},
		"int callWindowProc(int hwnd, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    if (handle == 0)\n        return 0;\n    if (hwnd == hwndText) {\n        return OS.CallWindowProc(EditProc, hwnd, msg, wParam, lParam);\n    }\n    if (hwnd == hwndUpDown) {\n        return OS.CallWindowProc(UpDownProc, hwnd, msg, wParam, lParam);\n    }\n    return OS.DefWindowProc(handle, msg, wParam, lParam);\n}",
			"comments":"",
			"methodName":"int callWindowProc(int hwnd, int msg, int wParam, int lParam)"
		},
		"void setForegroundPixel(int pixel)":{
			"methodBody":"{\n    if (foreground == pixel)\n        return;\n    super.setForegroundPixel(pixel);\n    OS.InvalidateRect(hwndText, null, true);\n}",
			"comments":"",
			"methodName":"void setForegroundPixel(int pixel)"
		},
		"LRESULT wmClipboard(int hwndText, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    if ((style & SWT.READ_ONLY) != 0)\n        return null;\n    \n    boolean call = false;\n    int[] start = new int[1], end = new int[1];\n    String oldText = null, newText = null;\n    switch(msg) {\n        case OS.WM_CLEAR:\n        case OS.WM_CUT:\n            OS.SendMessage(hwndText, OS.EM_GETSEL, start, end);\n            if (start[0] != end[0]) {\n                newText = \"\";\n                call = true;\n            }\n            break;\n        case OS.WM_PASTE:\n            OS.SendMessage(hwndText, OS.EM_GETSEL, start, end);\n            newText = getClipboardText();\n            break;\n        case OS.EM_UNDO:\n        case OS.WM_UNDO:\n            if (OS.SendMessage(hwndText, OS.EM_CANUNDO, 0, 0) != 0) {\n                ignoreModify = true;\n                OS.SendMessage(hwndText, OS.EM_GETSEL, start, end);\n                OS.CallWindowProc(EditProc, hwndText, msg, wParam, lParam);\n                int length = OS.GetWindowTextLength(hwndText);\n                if (length != 0 && start[0] != end[0]) {\n                    TCHAR buffer = new TCHAR(getCodePage(), length + 1);\n                    OS.GetWindowText(hwndText, buffer, length + 1);\n                    newText = buffer.toString(start[0], end[0] - start[0]);\n                } else {\n                    newText = \"\";\n                }\n                OS.CallWindowProc(EditProc, hwndText, msg, wParam, lParam);\n                ignoreModify = false;\n            }\n            break;\n    }\n    if (newText != null && !newText.equals(oldText)) {\n        oldText = newText;\n        newText = verifyText(newText, start[0], end[0], null);\n        if (newText == null)\n            return LRESULT.ZERO;\n        if (!newText.equals(oldText)) {\n            if (call) {\n                OS.CallWindowProc(EditProc, hwndText, msg, wParam, lParam);\n            }\n            TCHAR buffer = new TCHAR(getCodePage(), newText, true);\n            if (msg == OS.WM_SETTEXT) {\n                int hHeap = OS.GetProcessHeap();\n                int byteCount = buffer.length() * TCHAR.sizeof;\n                int pszText = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, byteCount);\n                OS.MoveMemory(pszText, buffer, byteCount);\n                int code = OS.CallWindowProc(EditProc, hwndText, msg, wParam, pszText);\n                OS.HeapFree(hHeap, 0, pszText);\n                return new LRESULT(code);\n            } else {\n                OS.SendMessage(hwndText, OS.EM_REPLACESEL, 0, buffer);\n                return LRESULT.ZERO;\n            }\n        }\n    }\n    return null;\n}",
			"comments":"//\tif (!hooks (SWT.Verify) && !filters (SWT.Verify)) return null;\n",
			"methodName":"LRESULT wmClipboard(int hwndText, int msg, int wParam, int lParam)"
		}
	},
	"ClassORInterfaceName":[
		"Spinner"
	]
}
