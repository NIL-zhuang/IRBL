{
	"variables":[
		"types",
		"data",
		"i",
		"types",
		"i",
		"format",
		"data",
		"size",
		"newPtr",
		"data",
		"formatetc",
		"stgmedium",
		"hMem",
		"size",
		"buffer",
		"ptr",
		"types",
		"i",
		"types",
		"i",
		"data",
		"i",
		"data",
		"i",
		"types",
		"i",
		"data",
		"i",
		"data",
		"i",
		"types",
		"i",
		"data",
		"i",
		"COM",
		"data",
		"i",
		"data",
		"i",
		"COM",
		"data",
		"transferData",
		"i",
		"types",
		"i",
		"transferData",
		"format",
		"types",
		"i",
		"format",
		"COM",
		"COM",
		"format",
		"COM",
		"COM",
		"object",
		"transferData",
		"DND",
		"DND",
		"object",
		"data",
		"OS",
		"OS",
		"OS",
		"size",
		"OS",
		"newPtr",
		"data",
		"size",
		"transferData",
		"transferData",
		"COM",
		"transferData",
		"newPtr",
		"transferData",
		"transferData",
		"COM",
		"transferData",
		"transferData",
		"transferData",
		"data",
		"transferData",
		"stgmedium",
		"COM",
		"transferData",
		"data",
		"formatetc",
		"stgmedium",
		"data",
		"transferData",
		"COM",
		"stgmedium",
		"OS",
		"hMem",
		"size",
		"OS",
		"hMem",
		"OS",
		"buffer",
		"ptr",
		"size",
		"OS",
		"hMem",
		"OS",
		"hMem",
		"buffer",
		"object",
		"object",
		"object",
		"length",
		"length",
		"type",
		"formatetc",
		"cfFormat",
		"formatetc",
		"dwAspect",
		"formatetc",
		"DVASPECT_CONTENT",
		"lindex",
		"formatetc",
		"tymed",
		"formatetc",
		"TYMED_HGLOBAL",
		"length",
		"formatetc",
		"cfFormat",
		"dwAspect",
		"DVASPECT_CONTENT",
		"DVASPECT_CONTENT",
		"tymed",
		"TYMED_HGLOBAL",
		"TYMED_HGLOBAL",
		"ERROR_INVALID_DATA",
		"length",
		"GMEM_FIXED",
		"GMEM_ZEROINIT",
		"stgmedium",
		"tymed",
		"stgmedium",
		"TYMED_HGLOBAL",
		"unionField",
		"stgmedium",
		"pUnkForRelease",
		"stgmedium",
		"result",
		"S_OK",
		"pIDataObject",
		"pIDataObject",
		"formatetc",
		"tymed",
		"TYMED_HGLOBAL",
		"result",
		"result",
		"S_OK",
		"unionField",
		"length",
		"transferData",
		"object",
		"transferData",
		"transferData",
		"object"
	],
	"extendORImplementFiles":[
		"Transfer"
	],
	"package":[
		"org.eclipse.swt.dnd"
	],
	"import":[
		"org.eclipse.swt.internal.ole.win32",
		"org.eclipse.swt.internal.win32"
	],
	"methods":[
		"getSupportedTypes",
		"isSupportedType",
		"javaToNative",
		"nativeToJava",
		"checkByteArray",
		"getTypeIds",
		"getTypeIds",
		"checkByteArray",
		"isSupportedType",
		"error",
		"GlobalAlloc",
		"MoveMemory",
		"isSupportedType",
		"AddRef",
		"GetData",
		"Release",
		"GlobalSize",
		"GlobalLock",
		"MoveMemory",
		"GlobalUnlock",
		"GlobalFree",
		"TransferData",
		"FORMATETC",
		"STGMEDIUM",
		"IDataObject",
		"STGMEDIUM"
	],
	"methodsBody":{
		"protected void javaToNative(Object object, TransferData transferData)":{
			"methodBody":"{\n    if (!checkByteArray(object) || !isSupportedType(transferData)) {\n        DND.error(DND.ERROR_INVALID_DATA);\n    }\n    \n    \n    byte[] data = (byte[]) object;\n    int size = data.length;\n    int newPtr = OS.GlobalAlloc(OS.GMEM_FIXED | OS.GMEM_ZEROINIT, size);\n    OS.MoveMemory(newPtr, data, size);\n    transferData.stgmedium = new STGMEDIUM();\n    transferData.stgmedium.tymed = COM.TYMED_HGLOBAL;\n    transferData.stgmedium.unionField = newPtr;\n    transferData.stgmedium.pUnkForRelease = 0;\n    transferData.result = COM.S_OK;\n}",
			"comments":"/**\n* This implementation of <code>javaToNative</code> converts a java\n* <code>byte[]</code> to a platform specific representation.  For additional\n* information see <code>Transfer#javaToNative</code>.\n*\n* @see Transfer#javaToNative\n*\n* @param object a java <code>byte[]</code> containing the data to be converted\n* @param transferData an empty <code>TransferData</code> object; this\n*  object will be filled in on return with the platform specific format of the data\n*/\n// Allocate the memory because the caller (DropTarget) has not handed it in\n// The caller of this method must release the data when it is done with it.\n",
			"methodName":"protected void javaToNative(Object object, TransferData transferData)"
		},
		"protected Object nativeToJava(TransferData transferData)":{
			"methodBody":"{\n    if (!isSupportedType(transferData) || transferData.pIDataObject == 0)\n        return null;\n    IDataObject data = new IDataObject(transferData.pIDataObject);\n    data.AddRef();\n    FORMATETC formatetc = transferData.formatetc;\n    STGMEDIUM stgmedium = new STGMEDIUM();\n    stgmedium.tymed = COM.TYMED_HGLOBAL;\n    transferData.result = data.GetData(formatetc, stgmedium);\n    data.Release();\n    if (transferData.result != COM.S_OK)\n        return null;\n    int hMem = stgmedium.unionField;\n    int size = OS.GlobalSize(hMem);\n    byte[] buffer = new byte[size];\n    int ptr = OS.GlobalLock(hMem);\n    OS.MoveMemory(buffer, ptr, size);\n    OS.GlobalUnlock(hMem);\n    OS.GlobalFree(hMem);\n    return buffer;\n}",
			"comments":"/**\n* This implementation of <code>nativeToJava</code> converts a platform specific\n* representation of a byte array to a java <code>byte[]</code>.\n* For additional information see <code>Transfer#nativeToJava</code>.\n*\n* @see Transfer#nativeToJava\n*\n* @param transferData the platform specific representation of the data to be\n* been converted\n* @return a java <code>byte[]</code> containing the converted data if the\n* conversion was successful; otherwise null\n*/\n",
			"methodName":"protected Object nativeToJava(TransferData transferData)"
		},
		"public boolean isSupportedType(TransferData transferData)":{
			"methodBody":"{\n    if (transferData == null)\n        return false;\n    int[] types = getTypeIds();\n    for (int i = 0; i < types.length; i++) {\n        FORMATETC format = transferData.formatetc;\n        if (format.cfFormat == types[i] && (format.dwAspect & COM.DVASPECT_CONTENT) == COM.DVASPECT_CONTENT && (format.tymed & COM.TYMED_HGLOBAL) == COM.TYMED_HGLOBAL)\n            return true;\n    }\n    return false;\n}",
			"comments":"",
			"methodName":"public boolean isSupportedType(TransferData transferData)"
		},
		"boolean checkByteArray(Object object)":{
			"methodBody":"{\n    return (object != null && object instanceof byte[] && ((byte[]) object).length > 0);\n}",
			"comments":"",
			"methodName":"boolean checkByteArray(Object object)"
		},
		"public TransferData[] getSupportedTypes()":{
			"methodBody":"{\n    int[] types = getTypeIds();\n    TransferData[] data = new TransferData[types.length];\n    for (int i = 0; i < types.length; i++) {\n        data[i] = new TransferData();\n        data[i].type = types[i];\n        data[i].formatetc = new FORMATETC();\n        data[i].formatetc.cfFormat = types[i];\n        data[i].formatetc.dwAspect = COM.DVASPECT_CONTENT;\n        data[i].formatetc.lindex = -1;\n        data[i].formatetc.tymed = COM.TYMED_HGLOBAL;\n    }\n    return data;\n}",
			"comments":"",
			"methodName":"public TransferData[] getSupportedTypes()"
		}
	},
	"ClassORInterfaceName":[
		"ByteArrayTransfer"
	]
}
