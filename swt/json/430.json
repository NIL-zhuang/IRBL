{
	"variables":[
		"caret",
		"rect",
		"hDC",
		"isFocus",
		"sourceRect",
		"clientRect",
		"flags",
		"deltaX",
		"deltaY",
		"flags",
		"children",
		"i",
		"child",
		"rect",
		"newCaret",
		"oldCaret",
		"result",
		"result",
		"result",
		"result",
		"result",
		"isFocus",
		"result",
		"isFocus",
		"parent",
		"style",
		"OS",
		"handle",
		"OS",
		"rect",
		"x",
		"y",
		"x",
		"width",
		"y",
		"height",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"hDC",
		"rect",
		"OS",
		"handle",
		"hDC",
		"caret",
		"caret",
		"caret",
		"caret",
		"caret",
		"caret",
		"isFocus",
		"caret",
		"OS",
		"sourceRect",
		"x",
		"y",
		"x",
		"width",
		"y",
		"height",
		"OS",
		"handle",
		"clientRect",
		"OS",
		"clientRect",
		"sourceRect",
		"clientRect",
		"OS",
		"OS",
		"handle",
		"OS",
		"OS",
		"OS",
		"handle",
		"flags",
		"destX",
		"x",
		"destY",
		"y",
		"OS",
		"OS",
		"OS",
		"handle",
		"deltaX",
		"deltaY",
		"sourceRect",
		"flags",
		"all",
		"i",
		"children",
		"i",
		"children",
		"i",
		"child",
		"Math",
		"x",
		"width",
		"rect",
		"rect",
		"Math",
		"x",
		"rect",
		"Math",
		"y",
		"height",
		"rect",
		"rect",
		"Math",
		"y",
		"rect",
		"child",
		"rect",
		"deltaX",
		"rect",
		"deltaY",
		"isFocus",
		"caret",
		"caret",
		"newCaret",
		"oldCaret",
		"oldCaret",
		"newCaret",
		"newCaret",
		"SWT",
		"newCaret",
		"caret",
		"caret",
		"font",
		"font",
		"wParam",
		"lParam",
		"caret",
		"caret",
		"caret",
		"caret",
		"result",
		"wParam",
		"lParam",
		"caret",
		"caret",
		"result",
		"wParam",
		"lParam",
		"caret",
		"caret",
		"result",
		"wParam",
		"lParam",
		"caret",
		"caret",
		"caret",
		"result",
		"wParam",
		"lParam",
		"result",
		"result",
		"style",
		"SWT",
		"caret",
		"caret",
		"isFocus",
		"caret",
		"result",
		"wParam",
		"lParam",
		"result",
		"result",
		"style",
		"SWT",
		"caret",
		"caret",
		"isFocus",
		"caret",
		"result",
		"DCX_CACHE",
		"DCX_CLIPCHILDREN",
		"DCX_CLIPSIBLINGS",
		"IsWinCE",
		"RDW_UPDATENOW",
		"RDW_ALLCHILDREN",
		"SW_INVALIDATE",
		"SW_ERASE",
		"length",
		"x",
		"width",
		"x",
		"y",
		"height",
		"y",
		"x",
		"y",
		"caret",
		"caret",
		"ERROR_INVALID_ARGUMENT",
		"RIGHT_TO_LEFT",
		"RIGHT_TO_LEFT",
		"parent",
		"style",
		"x",
		"y",
		"width",
		"height",
		"destX",
		"destY",
		"x",
		"y",
		"width",
		"height",
		"all",
		"caret",
		"font",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam"
	],
	"extendORImplementFiles":[
		"Composite"
	],
	"package":[
		"org.eclipse.swt.widgets"
	],
	"import":[
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt",
		"org.eclipse.swt.graphics"
	],
	"methods":[
		"clearArea",
		"getCaret",
		"releaseWidget",
		"scroll",
		"setCaret",
		"setFont",
		"WM_INPUTLANGCHANGE",
		"WM_KILLFOCUS",
		"WM_SETFOCUS",
		"WM_SIZE",
		"WM_WINDOWPOSCHANGED",
		"WM_WINDOWPOSCHANGING",
		"checkWidget",
		"IsWindowVisible",
		"SetRect",
		"GetDCEx",
		"drawBackground",
		"ReleaseDC",
		"checkWidget",
		"releaseResources",
		"releaseWidget",
		"checkWidget",
		"forceResize",
		"isFocusCaret",
		"killFocus",
		"SetRect",
		"GetClientRect",
		"IntersectRect",
		"UpdateWindow",
		"RedrawWindow",
		"ScrollWindowEx",
		"_getChildren",
		"getBounds",
		"min",
		"max",
		"min",
		"max",
		"setLocation",
		"setFocus",
		"checkWidget",
		"isFocusControl",
		"killFocus",
		"isDisposed",
		"error",
		"setFocus",
		"checkWidget",
		"setFont",
		"setFont",
		"WM_INPUTLANGCHANGE",
		"isFocusCaret",
		"setIMEFont",
		"resizeIME",
		"WM_KILLFOCUS",
		"killFocus",
		"WM_SETFOCUS",
		"setFocus",
		"WM_SIZE",
		"isFocusCaret",
		"resizeIME",
		"WM_WINDOWPOSCHANGED",
		"isFocusCaret",
		"setFocus",
		"WM_WINDOWPOSCHANGING",
		"isFocusCaret",
		"killFocus",
		"RECT",
		"RECT",
		"RECT"
	],
	"methodsBody":{
		"LRESULT WM_KILLFOCUS(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_KILLFOCUS(wParam, lParam);\n    if (caret != null)\n        caret.killFocus();\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_KILLFOCUS(int wParam, int lParam)"
		},
		"void releaseWidget()":{
			"methodBody":"{\n    if (caret != null)\n        caret.releaseResources();\n    caret = null;\n    super.releaseWidget();\n}",
			"comments":"",
			"methodName":"void releaseWidget()"
		},
		"LRESULT WM_SIZE(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_SIZE(wParam, lParam);\n    if (caret != null && caret.isFocusCaret())\n        caret.resizeIME();\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_SIZE(int wParam, int lParam)"
		},
		"LRESULT WM_WINDOWPOSCHANGED(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_WINDOWPOSCHANGED(wParam, lParam);\n    if (result != null)\n        return result;\n    \n    boolean isFocus = (style & SWT.RIGHT_TO_LEFT) != 0 && caret != null && caret.isFocusCaret();\n    if (isFocus)\n        caret.setFocus();\n    return result;\n}",
			"comments":"/*\n* Bug in Windows.  When a window with style WS_EX_LAYOUTRTL\n* that contains a caret is resized, Windows does not move the\n* caret in relation to the mirrored origin in the top right.\n* The fix is to hide the caret in WM_WINDOWPOSCHANGING and\n* show the caret in WM_WINDOWPOSCHANGED.\n*/\n",
			"methodName":"LRESULT WM_WINDOWPOSCHANGED(int wParam, int lParam)"
		},
		"LRESULT WM_INPUTLANGCHANGE(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_INPUTLANGCHANGE(wParam, lParam);\n    if (caret != null && caret.isFocusCaret()) {\n        caret.setIMEFont();\n        caret.resizeIME();\n    }\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_INPUTLANGCHANGE(int wParam, int lParam)"
		},
		"void clearArea(int x, int y, int width, int height)":{
			"methodBody":"{\n    checkWidget();\n    if (OS.IsWindowVisible(handle))\n        return;\n    RECT rect = new RECT();\n    OS.SetRect(rect, x, y, x + width, y + height);\n    int hDC = OS.GetDCEx(handle, 0, OS.DCX_CACHE | OS.DCX_CLIPCHILDREN | OS.DCX_CLIPSIBLINGS);\n    drawBackground(hDC, rect);\n    OS.ReleaseDC(handle, hDC);\n}",
			"comments":"/*\n* Not currently used.\n*/\n",
			"methodName":"void clearArea(int x, int y, int width, int height)"
		},
		"public void setCaret(Caret caret)":{
			"methodBody":"{\n    checkWidget();\n    Caret newCaret = caret;\n    Caret oldCaret = this.caret;\n    this.caret = newCaret;\n    if (isFocusControl()) {\n        if (oldCaret != null)\n            oldCaret.killFocus();\n        if (newCaret != null) {\n            if (newCaret.isDisposed())\n                error(SWT.ERROR_INVALID_ARGUMENT);\n            newCaret.setFocus();\n        }\n    }\n}",
			"comments":"/**\n* Sets the receiver's caret.\n* <p>\n* The caret for the control is automatically hidden\n* and shown when the control is painted or resized,\n* when focus is gained or lost and when an the control\n* is scrolled.  To avoid drawing on top of the caret,\n* the programmer must hide and show the caret when\n* drawing in the window any other time.\n* </p>\n* @param caret the new caret for the receiver, may be null\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the caret has been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setCaret(Caret caret)"
		},
		"public Caret getCaret()":{
			"methodBody":"{\n    checkWidget();\n    return caret;\n}",
			"comments":"/**\n* Returns the caret.\n* <p>\n* The caret for the control is automatically hidden\n* and shown when the control is painted or resized,\n* when focus is gained or lost and when an the control\n* is scrolled.  To avoid drawing on top of the caret,\n* the programmer must hide and show the caret when\n* drawing in the window any other time.\n* </p>\n*\n* @return the caret\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public Caret getCaret()"
		},
		"public void scroll(int destX, int destY, int x, int y, int width, int height, boolean all)":{
			"methodBody":"{\n    checkWidget();\n    forceResize();\n    boolean isFocus = caret != null && caret.isFocusCaret();\n    if (isFocus)\n        caret.killFocus();\n    RECT sourceRect = new RECT();\n    OS.SetRect(sourceRect, x, y, x + width, y + height);\n    RECT clientRect = new RECT();\n    OS.GetClientRect(handle, clientRect);\n    if (OS.IntersectRect(clientRect, sourceRect, clientRect)) {\n        if (OS.IsWinCE) {\n            OS.UpdateWindow(handle);\n        } else {\n            int flags = OS.RDW_UPDATENOW | OS.RDW_ALLCHILDREN;\n            OS.RedrawWindow(handle, null, 0, flags);\n        }\n    }\n    int deltaX = destX - x, deltaY = destY - y;\n    int flags = OS.SW_INVALIDATE | OS.SW_ERASE;\n    \n    \n    OS.ScrollWindowEx(handle, deltaX, deltaY, sourceRect, null, 0, null, flags);\n    if (all) {\n        Control[] children = _getChildren();\n        for (int i = 0; i < children.length; i++) {\n            Control child = children[i];\n            Rectangle rect = child.getBounds();\n            if (Math.min(x + width, rect.x + rect.width) >= Math.max(x, rect.x) && Math.min(y + height, rect.y + rect.height) >= Math.max(y, rect.y)) {\n                child.setLocation(rect.x + deltaX, rect.y + deltaY);\n            }\n        }\n    }\n    if (isFocus)\n        caret.setFocus();\n}",
			"comments":"/**\n* Scrolls a rectangular area of the receiver by first copying\n* the source area to the destination and then causing the area\n* of the source which is not covered by the destination to\n* be repainted. Children that intersect the rectangle are\n* optionally moved during the operation. In addition, outstanding\n* paint events are flushed before the source area is copied to\n* ensure that the contents of the canvas are drawn correctly.\n*\n* @param destX the x coordinate of the destination\n* @param destY the y coordinate of the destination\n* @param x the x coordinate of the source\n* @param y the y coordinate of the source\n* @param width the width of the area\n* @param height the height of the area\n* @param all <code>true</code>if children should be scrolled, and <code>false</code> otherwise\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n/*\n* Feature in Windows.  If any child in the widget tree partially\n* intersects the scrolling rectangle, Windows moves the child\n* and copies the bits that intersect the scrolling rectangle but\n* does not redraw the child.\n*\n* Feature in Windows.  When any child in the widget tree does not\n* intersect the scrolling rectangle but the parent does intersect,\n* Windows does not move the child.  This is the documented (but\n* strange) Windows behavior.\n*\n* The fix is to not use SW_SCROLLCHILDREN and move the children\n* explicitly after scrolling.\n*/\n//\tif (all) flags |= OS.SW_SCROLLCHILDREN;\n",
			"methodName":"public void scroll(int destX, int destY, int x, int y, int width, int height, boolean all)"
		},
		"LRESULT WM_SETFOCUS(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_SETFOCUS(wParam, lParam);\n    if (caret != null)\n        caret.setFocus();\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_SETFOCUS(int wParam, int lParam)"
		},
		"public void setFont(Font font)":{
			"methodBody":"{\n    checkWidget();\n    if (caret != null)\n        caret.setFont(font);\n    super.setFont(font);\n}",
			"comments":"",
			"methodName":"public void setFont(Font font)"
		},
		"LRESULT WM_WINDOWPOSCHANGING(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_WINDOWPOSCHANGING(wParam, lParam);\n    if (result != null)\n        return result;\n    \n    boolean isFocus = (style & SWT.RIGHT_TO_LEFT) != 0 && caret != null && caret.isFocusCaret();\n    if (isFocus)\n        caret.killFocus();\n    return result;\n}",
			"comments":"/*\n* Bug in Windows.  When a window with style WS_EX_LAYOUTRTL\n* that contains a caret is resized, Windows does not move the\n* caret in relation to the mirrored origin in the top right.\n* The fix is to hide the caret in WM_WINDOWPOSCHANGING and\n* show the caret in WM_WINDOWPOSCHANGED.\n*/\n",
			"methodName":"LRESULT WM_WINDOWPOSCHANGING(int wParam, int lParam)"
		}
	},
	"ClassORInterfaceName":[
		"Canvas"
	]
}
