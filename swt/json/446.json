{
	"variables":[
		"CLIENT_INSET",
		"GroupProc",
		"GroupClass",
		"lpWndClass",
		"WC_BUTTON",
		"hInstance",
		"hHeap",
		"byteCount",
		"lpszClassName",
		"size",
		"length",
		"buffer1",
		"newFont",
		"oldFont",
		"hDC",
		"rect",
		"flags",
		"trim",
		"newFont",
		"oldFont",
		"hDC",
		"tm",
		"rect",
		"newFont",
		"oldFont",
		"hDC",
		"tm",
		"x",
		"y",
		"width",
		"height",
		"length",
		"buffer",
		"mnemonic",
		"buffer",
		"result",
		"result",
		"code",
		"result",
		"result",
		"nSavedDC",
		"code",
		"result",
		"result",
		"control",
		"rect",
		"OS",
		"OS",
		"OS",
		"GroupClass",
		"lpWndClass",
		"GroupProc",
		"lpWndClass",
		"OS",
		"WC_BUTTON",
		"lpWndClass",
		"GroupProc",
		"lpWndClass",
		"OS",
		"OS",
		"hInstance",
		"GroupClass",
		"lpWndClass",
		"OS",
		"lpWndClass",
		"hInstance",
		"lpWndClass",
		"OS",
		"OS",
		"GroupClass",
		"TCHAR",
		"OS",
		"hHeap",
		"OS",
		"byteCount",
		"OS",
		"lpszClassName",
		"GroupClass",
		"byteCount",
		"lpWndClass",
		"lpszClassName",
		"OS",
		"lpWndClass",
		"parent",
		"style",
		"handle",
		"msg",
		"OS",
		"OS",
		"OS",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"OS",
		"GroupProc",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"style",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"wHint",
		"hHint",
		"changed",
		"OS",
		"handle",
		"length",
		"length",
		"OS",
		"handle",
		"buffer1",
		"length",
		"OS",
		"handle",
		"newFont",
		"OS",
		"handle",
		"OS",
		"newFont",
		"oldFont",
		"OS",
		"hDC",
		"newFont",
		"OS",
		"OS",
		"OS",
		"hDC",
		"buffer1",
		"length",
		"rect",
		"flags",
		"newFont",
		"OS",
		"hDC",
		"oldFont",
		"OS",
		"handle",
		"hDC",
		"size",
		"Math",
		"size",
		"rect",
		"rect",
		"CLIENT_INSET",
		"size",
		"x",
		"y",
		"width",
		"height",
		"OS",
		"handle",
		"newFont",
		"OS",
		"handle",
		"OS",
		"newFont",
		"oldFont",
		"OS",
		"hDC",
		"newFont",
		"OS",
		"OS",
		"hDC",
		"tm",
		"newFont",
		"OS",
		"hDC",
		"oldFont",
		"OS",
		"handle",
		"hDC",
		"trim",
		"CLIENT_INSET",
		"trim",
		"tm",
		"trim",
		"CLIENT_INSET",
		"trim",
		"tm",
		"CLIENT_INSET",
		"trim",
		"state",
		"CANVAS",
		"OS",
		"handle",
		"rect",
		"OS",
		"handle",
		"newFont",
		"OS",
		"handle",
		"OS",
		"newFont",
		"oldFont",
		"OS",
		"hDC",
		"newFont",
		"OS",
		"OS",
		"hDC",
		"tm",
		"newFont",
		"OS",
		"hDC",
		"oldFont",
		"OS",
		"handle",
		"hDC",
		"CLIENT_INSET",
		"tm",
		"rect",
		"CLIENT_INSET",
		"rect",
		"y",
		"CLIENT_INSET",
		"x",
		"y",
		"width",
		"height",
		"OS",
		"handle",
		"length",
		"length",
		"OS",
		"handle",
		"buffer",
		"length",
		"buffer",
		"length",
		"mnemonic",
		"Character",
		"key",
		"Character",
		"mnemonic",
		"string",
		"SWT",
		"string",
		"OS",
		"handle",
		"buffer",
		"OS",
		"OS",
		"OS",
		"GroupClass",
		"GroupProc",
		"wParam",
		"lParam",
		"result",
		"result",
		"OS",
		"OS",
		"result",
		"wParam",
		"LRESULT",
		"wParam",
		"lParam",
		"result",
		"result",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"code",
		"OS",
		"code",
		"OS",
		"code",
		"wParam",
		"lParam",
		"result",
		"result",
		"LRESULT",
		"wParam",
		"lParam",
		"result",
		"result",
		"OS",
		"OS",
		"OS",
		"wParam",
		"handle",
		"OS",
		"wParam",
		"lParam",
		"OS",
		"wParam",
		"nSavedDC",
		"code",
		"result",
		"wParam",
		"lParam",
		"OS",
		"result",
		"OS",
		"handle",
		"result",
		"wParam",
		"lParam",
		"OS",
		"OS",
		"control",
		"OS",
		"wParam",
		"OS",
		"OS",
		"control",
		"rect",
		"OS",
		"control",
		"handle",
		"rect",
		"control",
		"wParam",
		"rect",
		"OS",
		"OS",
		"result",
		"IsWinCE",
		"IsWinCE",
		"lpfnWndProc",
		"lpfnWndProc",
		"hInstance",
		"style",
		"CS_HREDRAW",
		"CS_VREDRAW",
		"sizeof",
		"HEAP_ZERO_MEMORY",
		"lpszClassName",
		"WM_LBUTTONDOWN",
		"WM_LBUTTONDBLCLK",
		"NO_FOCUS",
		"H_SCROLL",
		"V_SCROLL",
		"ERROR_INVALID_SUBCLASS",
		"WM_GETFONT",
		"DT_CALCRECT",
		"DT_SINGLELINE",
		"x",
		"x",
		"right",
		"left",
		"WM_GETFONT",
		"IsUnicode",
		"x",
		"y",
		"tmHeight",
		"width",
		"height",
		"tmHeight",
		"WM_GETFONT",
		"IsUnicode",
		"tmHeight",
		"right",
		"bottom",
		"ERROR_NULL_ARGUMENT",
		"BS_GROUPBOX",
		"WS_CLIPCHILDREN",
		"WS_CLIPSIBLINGS",
		"COMCTL32_MAJOR",
		"ONE",
		"WM_NCHITTEST",
		"HTTRANSPARENT",
		"HTCLIENT",
		"ZERO",
		"COMCTL32_MAJOR",
		"WM_PRINTCLIENT",
		"IsWinCE",
		"COMCTL32_MAJOR",
		"TRANSPARENT",
		"handle",
		"handle",
		"NULL_BRUSH",
		"parent",
		"style",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"style",
		"wHint",
		"hHint",
		"changed",
		"x",
		"y",
		"width",
		"height",
		"key",
		"key",
		"string",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam",
		"wParam",
		"lParam"
	],
	"extendORImplementFiles":[
		"Composite"
	],
	"package":[
		"org.eclipse.swt.widgets"
	],
	"import":[
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt",
		"org.eclipse.swt.graphics"
	],
	"methods":[
		"callWindowProc",
		"checkStyle",
		"checkSubclass",
		"computeSize",
		"computeTrim",
		"createHandle",
		"getClientArea",
		"getNameText",
		"getText",
		"mnemonicHit",
		"mnemonicMatch",
		"setText",
		"widgetStyle",
		"windowClass",
		"windowProc",
		"WM_ERASEBKGND",
		"WM_NCHITTEST",
		"WM_MOUSEMOVE",
		"WM_PRINTCLIENT",
		"WM_SIZE",
		"wmColorChild",
		"GetClassInfo",
		"GetClassInfo",
		"GetModuleHandle",
		"GetClassInfo",
		"GetProcessHeap",
		"length",
		"HeapAlloc",
		"MoveMemory",
		"RegisterClass",
		"checkStyle",
		"DefWindowProc",
		"CallWindowProc",
		"isValidSubclass",
		"error",
		"checkWidget",
		"computeSize",
		"GetWindowTextLength",
		"getCodePage",
		"GetWindowText",
		"GetDC",
		"SendMessage",
		"SelectObject",
		"DrawText",
		"SelectObject",
		"ReleaseDC",
		"max",
		"checkWidget",
		"computeTrim",
		"GetDC",
		"SendMessage",
		"SelectObject",
		"GetTextMetrics",
		"SelectObject",
		"ReleaseDC",
		"createHandle",
		"checkWidget",
		"forceResize",
		"GetClientRect",
		"GetDC",
		"SendMessage",
		"SelectObject",
		"GetTextMetrics",
		"SelectObject",
		"ReleaseDC",
		"getText",
		"checkWidget",
		"GetWindowTextLength",
		"getCodePage",
		"GetWindowText",
		"toString",
		"setFocus",
		"findMnemonic",
		"getText",
		"toUpperCase",
		"toUpperCase",
		"checkWidget",
		"error",
		"getCodePage",
		"SetWindowText",
		"widgetStyle",
		"WM_ERASEBKGND",
		"IsAppThemed",
		"findThemeControl",
		"drawBackground",
		"WM_NCHITTEST",
		"callWindowProc",
		"WM_MOUSEMOVE",
		"WM_PRINTCLIENT",
		"IsAppThemed",
		"SaveDC",
		"callWindowProc",
		"RestoreDC",
		"WM_SIZE",
		"InvalidateRect",
		"wmColorChild",
		"IsAppThemed",
		"findThemeControl",
		"SetBkMode",
		"GetClientRect",
		"MapWindowPoints",
		"drawThemeBackground",
		"GetStockObject",
		"TCHAR",
		"WNDCLASS",
		"TCHAR",
		"TCHAR",
		"RECT",
		"TEXTMETRICW",
		"TEXTMETRICA",
		"RECT",
		"TEXTMETRICW",
		"TEXTMETRICA",
		"Rectangle",
		"TCHAR",
		"TCHAR",
		"LRESULT",
		"LRESULT",
		"RECT",
		"LRESULT"
	],
	"methodsBody":{
		"boolean mnemonicMatch(char key)":{
			"methodBody":"{\n    char mnemonic = findMnemonic(getText());\n    if (mnemonic == '\\0')\n        return false;\n    return Character.toUpperCase(key) == Character.toUpperCase(mnemonic);\n}",
			"comments":"",
			"methodName":"boolean mnemonicMatch(char key)"
		},
		"public void setText(String string)":{
			"methodBody":"{\n    checkWidget();\n    if (string == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TCHAR buffer = new TCHAR(getCodePage(), string, true);\n    OS.SetWindowText(handle, buffer);\n}",
			"comments":"/**\n* Sets the receiver's text, which is the string that will\n* be displayed as the receiver's <em>title</em>, to the argument,\n* which may not be null. The string may include the mnemonic character.\n* </p>\n* Mnemonics are indicated by an '&amp' that causes the next\n* character to be the mnemonic.  When the user presses a\n* key sequence that matches the mnemonic, focus is assgned\n* to the first child of the group. On most platforms, the\n* mnemonic appears underlined but may be emphasised in a\n* platform specific manner.  The mnemonic indicator character\n*'&amp' can be escaped by doubling it in the string, causing\n* a single '&amp' to be displayed.\n* </p>\n* @param string the new text\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the text is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setText(String string)"
		},
		"TCHAR windowClass()":{
			"methodBody":"{\n    return GroupClass;\n}",
			"comments":"",
			"methodName":"TCHAR windowClass()"
		},
		"LRESULT WM_SIZE(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_SIZE(wParam, lParam);\n    if (OS.IsWinCE)\n        return result;\n    OS.InvalidateRect(handle, null, true);\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT WM_SIZE(int wParam, int lParam)"
		},
		"LRESULT WM_ERASEBKGND(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_ERASEBKGND(wParam, lParam);\n    if (result != null)\n        return result;\n    \n    if (OS.COMCTL32_MAJOR >= 6 && OS.IsAppThemed()) {\n        if (findThemeControl() != null)\n            return result;\n    }\n    drawBackground(wParam);\n    return LRESULT.ONE;\n}",
			"comments":"/*\n* Feaure in Windows.  Group boxes do not erase\n* the background before drawing.  The fix is to\n* fill the background.\n*\n* NOTE:  This work around causes flashing on XP\n* and is not necessary when a parent has a theme.\n*/\n",
			"methodName":"LRESULT WM_ERASEBKGND(int wParam, int lParam)"
		},
		"LRESULT wmColorChild(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.wmColorChild(wParam, lParam);\n    if (OS.COMCTL32_MAJOR >= 6 && OS.IsAppThemed()) {\n        Control control = findThemeControl();\n        if (control != null) {\n            OS.SetBkMode(wParam, OS.TRANSPARENT);\n            RECT rect = new RECT();\n            OS.GetClientRect(control.handle, rect);\n            OS.MapWindowPoints(control.handle, handle, rect, 2);\n            control.drawThemeBackground(wParam, rect);\n            return new LRESULT(OS.GetStockObject(OS.NULL_BRUSH));\n        }\n    }\n    return result;\n}",
			"comments":"",
			"methodName":"LRESULT wmColorChild(int wParam, int lParam)"
		},
		"void createHandle()":{
			"methodBody":"{\n    super.createHandle();\n    state &= ~CANVAS;\n}",
			"comments":"",
			"methodName":"void createHandle()"
		},
		"boolean mnemonicHit(char key)":{
			"methodBody":"{\n    return setFocus();\n}",
			"comments":"",
			"methodName":"boolean mnemonicHit(char key)"
		},
		"LRESULT WM_MOUSEMOVE(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_MOUSEMOVE(wParam, lParam);\n    if (result != null)\n        return result;\n    \n    return LRESULT.ZERO;\n}",
			"comments":"/*\n* Feature in Windows.  In version 6.00 of COMCTL32.DLL,\n* every time the mouse moves, the group title redraws.\n* This only happens when WM_NCHITTEST returns HTCLIENT.\n* The fix is to avoid calling the group window proc.\n*/\n",
			"methodName":"LRESULT WM_MOUSEMOVE(int wParam, int lParam)"
		},
		"protected void checkSubclass()":{
			"methodBody":"{\n    if (!isValidSubclass())\n        error(SWT.ERROR_INVALID_SUBCLASS);\n}",
			"comments":"",
			"methodName":"protected void checkSubclass()"
		},
		"LRESULT WM_NCHITTEST(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_NCHITTEST(wParam, lParam);\n    if (result != null)\n        return result;\n    \n    int code = callWindowProc(handle, OS.WM_NCHITTEST, wParam, lParam);\n    if (code == OS.HTTRANSPARENT)\n        code = OS.HTCLIENT;\n    return new LRESULT(code);\n}",
			"comments":"/*\n* Feature in Windows.  The window proc for the group box\n* returns HTTRANSPARENT indicating that mouse messages\n* should not be delivered to the receiver and any children.\n* Normally, group boxes in Windows do not have children and\n* this is the correct behavior for this case.  Because we\n* allow children, answer HTCLIENT to allow mouse messages\n* to be delivered to the children.\n*/\n",
			"methodName":"LRESULT WM_NCHITTEST(int wParam, int lParam)"
		},
		"String getNameText()":{
			"methodBody":"{\n    return getText();\n}",
			"comments":"",
			"methodName":"String getNameText()"
		},
		"public Rectangle getClientArea()":{
			"methodBody":"{\n    checkWidget();\n    forceResize();\n    RECT rect = new RECT();\n    OS.GetClientRect(handle, rect);\n    int newFont, oldFont = 0;\n    int hDC = OS.GetDC(handle);\n    newFont = OS.SendMessage(handle, OS.WM_GETFONT, 0, 0);\n    if (newFont != 0)\n        oldFont = OS.SelectObject(hDC, newFont);\n    TEXTMETRIC tm = OS.IsUnicode ? (TEXTMETRIC) new TEXTMETRICW() : new TEXTMETRICA();\n    OS.GetTextMetrics(hDC, tm);\n    if (newFont != 0)\n        OS.SelectObject(hDC, oldFont);\n    OS.ReleaseDC(handle, hDC);\n    int x = CLIENT_INSET, y = tm.tmHeight;\n    int width = rect.right - CLIENT_INSET * 2;\n    int height = rect.bottom - y - CLIENT_INSET;\n    return new Rectangle(x, y, width, height);\n}",
			"comments":"",
			"methodName":"public Rectangle getClientArea()"
		},
		"public Rectangle computeTrim(int x, int y, int width, int height)":{
			"methodBody":"{\n    checkWidget();\n    Rectangle trim = super.computeTrim(x, y, width, height);\n    int newFont, oldFont = 0;\n    int hDC = OS.GetDC(handle);\n    newFont = OS.SendMessage(handle, OS.WM_GETFONT, 0, 0);\n    if (newFont != 0)\n        oldFont = OS.SelectObject(hDC, newFont);\n    TEXTMETRIC tm = OS.IsUnicode ? (TEXTMETRIC) new TEXTMETRICW() : new TEXTMETRICA();\n    OS.GetTextMetrics(hDC, tm);\n    if (newFont != 0)\n        OS.SelectObject(hDC, oldFont);\n    OS.ReleaseDC(handle, hDC);\n    trim.x -= CLIENT_INSET;\n    trim.y -= tm.tmHeight;\n    trim.width += CLIENT_INSET * 2;\n    trim.height += tm.tmHeight + CLIENT_INSET;\n    return trim;\n}",
			"comments":"",
			"methodName":"public Rectangle computeTrim(int x, int y, int width, int height)"
		},
		"public String getText()":{
			"methodBody":"{\n    checkWidget();\n    int length = OS.GetWindowTextLength(handle);\n    if (length == 0)\n        return \"\";\n    TCHAR buffer = new TCHAR(getCodePage(), length + 1);\n    OS.GetWindowText(handle, buffer, length + 1);\n    return buffer.toString(0, length);\n}",
			"comments":"/**\n* Returns the receiver's text, which is the string that the\n* is used as the <em>title</em>. If the text has not previously\n* been set, returns an empty string.\n*\n* @return the text\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public String getText()"
		},
		"static int checkStyle(int style)":{
			"methodBody":"{\n    style |= SWT.NO_FOCUS;\n    \n    return style & ~(SWT.H_SCROLL | SWT.V_SCROLL);\n}",
			"comments":"/*\n* Even though it is legal to create this widget\n* with scroll bars, they serve no useful purpose\n* because they do not automatically scroll the\n* widget's client area.  The fix is to clear\n* the SWT style.\n*/\n",
			"methodName":"static int checkStyle(int style)"
		},
		"int windowProc()":{
			"methodBody":"{\n    return GroupProc;\n}",
			"comments":"",
			"methodName":"int windowProc()"
		},
		"LRESULT WM_PRINTCLIENT(int wParam, int lParam)":{
			"methodBody":"{\n    LRESULT result = super.WM_PRINTCLIENT(wParam, lParam);\n    if (result != null)\n        return result;\n    \n    if (OS.COMCTL32_MAJOR >= 6 && OS.IsAppThemed()) {\n        int nSavedDC = OS.SaveDC(wParam);\n        int code = callWindowProc(handle, OS.WM_PRINTCLIENT, wParam, lParam);\n        OS.RestoreDC(wParam, nSavedDC);\n        return new LRESULT(code);\n    }\n    return result;\n}",
			"comments":"/*\n* Feature in Windows.  In version 6.00 of COMCTL32.DLL,\n* when WM_PRINTCLIENT is sent from a child BS_GROUP\n* control to a parent BS_GROUP, the parent BS_GROUP\n* clears the font from the HDC.  Normally, group boxes\n* in Windows do not have children so this behavior is\n* undefined.  When the parent of a BS_GROUP is not a\n* BS_GROUP, there is no problem.  The fix is to save\n* and restore the current font.\n*/\n",
			"methodName":"LRESULT WM_PRINTCLIENT(int wParam, int lParam)"
		},
		"int callWindowProc(int hwnd, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    if (handle == 0)\n        return 0;\n    \n    switch(msg) {\n        case OS.WM_LBUTTONDOWN:\n        case OS.WM_LBUTTONDBLCLK:\n            return OS.DefWindowProc(hwnd, msg, wParam, lParam);\n    }\n    return OS.CallWindowProc(GroupProc, hwnd, msg, wParam, lParam);\n}",
			"comments":"/*\n* Feature in Windows.  When the user clicks on the group\n* box label, the group box takes focus.  This is unwanted.\n* The fix is to avoid calling the group box window proc.\n*/\n",
			"methodName":"int callWindowProc(int hwnd, int msg, int wParam, int lParam)"
		},
		"public Point computeSize(int wHint, int hHint, boolean changed)":{
			"methodBody":"{\n    checkWidget();\n    Point size = super.computeSize(wHint, hHint, changed);\n    int length = OS.GetWindowTextLength(handle);\n    if (length != 0) {\n        \n        TCHAR buffer1 = new TCHAR(getCodePage(), length + 1);\n        OS.GetWindowText(handle, buffer1, length + 1);\n        int newFont, oldFont = 0;\n        int hDC = OS.GetDC(handle);\n        newFont = OS.SendMessage(handle, OS.WM_GETFONT, 0, 0);\n        if (newFont != 0)\n            oldFont = OS.SelectObject(hDC, newFont);\n        RECT rect = new RECT();\n        int flags = OS.DT_CALCRECT | OS.DT_SINGLELINE;\n        OS.DrawText(hDC, buffer1, length, rect, flags);\n        if (newFont != 0)\n            OS.SelectObject(hDC, oldFont);\n        OS.ReleaseDC(handle, hDC);\n        size.x = Math.max(size.x, rect.right - rect.left + CLIENT_INSET * 6);\n    }\n    return size;\n}",
			"comments":"/*\n* If the group has text, and the text is wider than the\n* client area, pad the width so the text is not clipped.\n*/\n",
			"methodName":"public Point computeSize(int wHint, int hHint, boolean changed)"
		},
		"int widgetStyle()":{
			"methodBody":"{\n    \n    return super.widgetStyle() | OS.BS_GROUPBOX | OS.WS_CLIPCHILDREN | OS.WS_CLIPSIBLINGS;\n}",
			"comments":"/*\n* Bug in Windows.  When GetDCEx() is called with DCX_INTERSECTUPDATE,\n* the HDC that is returned does not include the current update region.\n* This was confirmed under DEBUG Windows when GetDCEx() complained about\n* invalid flags.  Therefore, it is not easily possible to get an HDC from\n* outside of WM_PAINT that includes the current damage and clips children.\n* Because the receiver has children and draws a frame and label, it is\n* necessary that the receiver always draw clipped, in the current damaged\n* area.  The fix is to force the receiver to be fully clipped by including\n* WS_CLIPCHILDREN and WS_CLIPSIBLINGS in the default style bits.\n*/\n",
			"methodName":"int widgetStyle()"
		}
	},
	"ClassORInterfaceName":[
		"Group"
	]
}
