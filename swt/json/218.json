{
	"variables":[
		"SIGNATURE_LENGTH",
		"decodingStream",
		"headerChunk",
		"paletteChunk",
		"imageData",
		"data",
		"alphaPalette",
		"signature",
		"chunkReader",
		"imageSize",
		"chunk",
		"trnsChunk",
		"transparentCount",
		"transparentPixel",
		"i",
		"dataChunk",
		"signature",
		"result",
		"width",
		"height",
		"destBytesPerLine",
		"srcBytesPerLine",
		"rgbData",
		"alphaData",
		"y",
		"srcIndex",
		"destIndex",
		"destAlphaIndex",
		"x",
		"grey",
		"alpha",
		"width",
		"height",
		"destBytesPerLine",
		"srcBytesPerLine",
		"rgbData",
		"alphaData",
		"y",
		"srcIndex",
		"destIndex",
		"destAlphaIndex",
		"x",
		"size",
		"alphaData",
		"pixelData",
		"i",
		"result",
		"interlaceMethod",
		"bitsPerPixel",
		"bitsPerPixel",
		"bitsPerRow",
		"bitsPerByte",
		"width",
		"alignedBytesPerRow",
		"height",
		"pixelsPerRow",
		"bytesPerRow",
		"row1",
		"row2",
		"currentRow",
		"lastRow",
		"row",
		"filterType",
		"col",
		"bytesPerPixel",
		"dataOffset",
		"rowOffset",
		"byteOffset",
		"bitsPerPixel",
		"pixelsPerByte",
		"column",
		"rowBase",
		"valueMask",
		"i",
		"maxShift",
		"byteOffset",
		"bitOffset",
		"dataOffset",
		"value",
		"dataShift",
		"image",
		"finalFrame",
		"dataOffset",
		"alignedBytesPerRow",
		"bytesPerRow",
		"row1",
		"row2",
		"currentRow",
		"lastRow",
		"row",
		"filterType",
		"col",
		"i",
		"sourceIndex",
		"destinationIndex",
		"compressedValue",
		"byteOffset",
		"i",
		"current",
		"left",
		"i",
		"current",
		"above",
		"i",
		"left",
		"above",
		"current",
		"i",
		"left",
		"aboveLeft",
		"above",
		"a",
		"b",
		"c",
		"preductor",
		"currentValue",
		"SIGNATURE_LENGTH",
		"inputStream",
		"signature",
		"inputStream",
		"headerChunk",
		"chunkReader",
		"headerChunk",
		"data",
		"imageSize",
		"imageData",
		"ImageData",
		"headerChunk",
		"headerChunk",
		"headerChunk",
		"data",
		"SWT",
		"headerChunk",
		"imageData",
		"headerChunk",
		"chunkReader",
		"chunkReader",
		"imageData",
		"SWT",
		"SWT",
		"chunkReader",
		"chunk",
		"PngChunk",
		"PngChunk",
		"headerChunk",
		"paletteChunk",
		"chunk",
		"imageData",
		"paletteChunk",
		"PngChunk",
		"chunk",
		"trnsChunk",
		"headerChunk",
		"PngTrnsChunk",
		"imageData",
		"trnsChunk",
		"headerChunk",
		"alphaPalette",
		"trnsChunk",
		"headerChunk",
		"paletteChunk",
		"i",
		"alphaPalette",
		"i",
		"alphaPalette",
		"i",
		"transparentCount",
		"transparentPixel",
		"i",
		"transparentCount",
		"alphaPalette",
		"transparentCount",
		"alphaPalette",
		"transparentPixel",
		"alphaPalette",
		"imageData",
		"transparentPixel",
		"PngChunk",
		"chunkReader",
		"SWT",
		"SWT",
		"chunk",
		"dataChunk",
		"chunkReader",
		"chunk",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SIGNATURE_LENGTH",
		"stream",
		"signature",
		"stream",
		"signature",
		"signature",
		"signature",
		"signature",
		"signature",
		"signature",
		"signature",
		"signature",
		"signature",
		"headerChunk",
		"data",
		"data",
		"result",
		"result",
		"result",
		"data",
		"headerChunk",
		"PngIhdrChunk",
		"imageData",
		"imageData",
		"imageData",
		"headerChunk",
		"srcBytesPerLine",
		"destBytesPerLine",
		"height",
		"width",
		"height",
		"y",
		"height",
		"y",
		"srcBytesPerLine",
		"y",
		"destBytesPerLine",
		"y",
		"width",
		"y",
		"x",
		"width",
		"x",
		"data",
		"srcIndex",
		"data",
		"srcIndex",
		"rgbData",
		"destIndex",
		"grey",
		"rgbData",
		"destIndex",
		"grey",
		"rgbData",
		"destIndex",
		"grey",
		"alphaData",
		"destAlphaIndex",
		"alpha",
		"srcIndex",
		"destIndex",
		"destAlphaIndex",
		"imageData",
		"rgbData",
		"imageData",
		"alphaData",
		"PngIhdrChunk",
		"imageData",
		"imageData",
		"imageData",
		"headerChunk",
		"srcBytesPerLine",
		"destBytesPerLine",
		"height",
		"width",
		"height",
		"y",
		"height",
		"y",
		"srcBytesPerLine",
		"y",
		"destBytesPerLine",
		"y",
		"width",
		"y",
		"x",
		"width",
		"x",
		"rgbData",
		"destIndex",
		"data",
		"srcIndex",
		"rgbData",
		"destIndex",
		"data",
		"srcIndex",
		"rgbData",
		"destIndex",
		"data",
		"srcIndex",
		"alphaData",
		"destAlphaIndex",
		"data",
		"srcIndex",
		"srcIndex",
		"destIndex",
		"destAlphaIndex",
		"imageData",
		"rgbData",
		"imageData",
		"alphaData",
		"PngIhdrChunk",
		"imageData",
		"data",
		"PngIhdrChunk",
		"imageData",
		"data",
		"alphaPalette",
		"imageData",
		"imageData",
		"size",
		"size",
		"imageData",
		"size",
		"pixelData",
		"i",
		"pixelData",
		"i",
		"alphaData",
		"i",
		"alphaPalette",
		"pixelData",
		"i",
		"imageData",
		"alphaData",
		"imageData",
		"data",
		"data",
		"result",
		"imageData",
		"decodingStream",
		"chunk",
		"chunkReader",
		"headerChunk",
		"interlaceMethod",
		"PngIhdrChunk",
		"decodingStream",
		"decodingStream",
		"headerChunk",
		"headerChunk",
		"headerChunk",
		"bitsPerPixel",
		"headerChunk",
		"bitsPerPixel",
		"rowWidthInPixels",
		"bitsPerRow",
		"bitsPerByte",
		"bitsPerByte",
		"headerChunk",
		"headerChunk",
		"startRow",
		"height",
		"startColumn",
		"width",
		"width",
		"startColumn",
		"columnInterval",
		"columnInterval",
		"pixelsPerRow",
		"bytesPerRow",
		"bytesPerRow",
		"row1",
		"row2",
		"startRow",
		"row",
		"height",
		"row",
		"rowInterval",
		"decodingStream",
		"col",
		"bytesPerRow",
		"col",
		"currentRow",
		"col",
		"decodingStream",
		"currentRow",
		"lastRow",
		"filterType",
		"headerChunk",
		"row",
		"alignedBytesPerRow",
		"startColumn",
		"bytesPerPixel",
		"rowOffset",
		"currentRow",
		"rowOffset",
		"bytesPerPixel",
		"byteOffset",
		"bytesPerPixel",
		"byteOffset",
		"data",
		"dataOffset",
		"byteOffset",
		"currentRow",
		"rowOffset",
		"byteOffset",
		"dataOffset",
		"columnInterval",
		"bytesPerPixel",
		"headerChunk",
		"bitsPerPixel",
		"startColumn",
		"row",
		"alignedBytesPerRow",
		"i",
		"bitsPerPixel",
		"i",
		"valueMask",
		"valueMask",
		"bitsPerPixel",
		"byteOffset",
		"currentRow",
		"byteOffset",
		"maxShift",
		"bitOffset",
		"bitOffset",
		"bitsPerPixel",
		"column",
		"width",
		"rowBase",
		"column",
		"bitsPerPixel",
		"currentRow",
		"byteOffset",
		"bitOffset",
		"valueMask",
		"maxShift",
		"bitsPerPixel",
		"column",
		"pixelsPerByte",
		"data",
		"dataOffset",
		"value",
		"dataShift",
		"column",
		"columnInterval",
		"currentRow",
		"currentRow",
		"row1",
		"row2",
		"row1",
		"lastRow",
		"lastRow",
		"row1",
		"row2",
		"row1",
		"data",
		"imageData",
		"frameCount",
		"loader",
		"imageData",
		"frameCount",
		"loader",
		"loader",
		"image",
		"frameCount",
		"finalFrame",
		"bytesPerRow",
		"bytesPerRow",
		"row1",
		"row2",
		"row",
		"headerChunk",
		"row",
		"decodingStream",
		"col",
		"bytesPerRow",
		"col",
		"currentRow",
		"col",
		"decodingStream",
		"currentRow",
		"lastRow",
		"filterType",
		"System",
		"currentRow",
		"data",
		"dataOffset",
		"bytesPerRow",
		"dataOffset",
		"alignedBytesPerRow",
		"currentRow",
		"currentRow",
		"row1",
		"row2",
		"row1",
		"lastRow",
		"lastRow",
		"row1",
		"row2",
		"row1",
		"data",
		"imageData",
		"i",
		"numberOfValues",
		"i",
		"sourceOffset",
		"i",
		"destinationOffset",
		"i",
		"source",
		"sourceIndex",
		"destination",
		"destinationIndex",
		"compressedValue",
		"value",
		"headerChunk",
		"filterType",
		"PngIhdrChunk",
		"PngIhdrChunk",
		"byteOffset",
		"i",
		"row",
		"i",
		"row",
		"i",
		"row",
		"i",
		"byteOffset",
		"row",
		"i",
		"current",
		"left",
		"PngIhdrChunk",
		"i",
		"row",
		"i",
		"row",
		"i",
		"previousRow",
		"i",
		"row",
		"i",
		"current",
		"above",
		"PngIhdrChunk",
		"i",
		"row",
		"i",
		"i",
		"byteOffset",
		"row",
		"i",
		"byteOffset",
		"previousRow",
		"i",
		"row",
		"i",
		"row",
		"i",
		"current",
		"left",
		"above",
		"PngIhdrChunk",
		"i",
		"row",
		"i",
		"i",
		"byteOffset",
		"row",
		"i",
		"byteOffset",
		"i",
		"byteOffset",
		"previousRow",
		"i",
		"byteOffset",
		"previousRow",
		"i",
		"Math",
		"above",
		"aboveLeft",
		"Math",
		"left",
		"aboveLeft",
		"Math",
		"left",
		"aboveLeft",
		"above",
		"aboveLeft",
		"a",
		"b",
		"a",
		"c",
		"preductor",
		"left",
		"b",
		"c",
		"preductor",
		"above",
		"preductor",
		"aboveLeft",
		"row",
		"i",
		"row",
		"i",
		"currentValue",
		"preductor",
		"IMAGE_PNG",
		"palette",
		"ERROR_INVALID_IMAGE",
		"CHUNK_IEND",
		"CHUNK_PLTE",
		"palette",
		"CHUNK_tRNS",
		"TRANSPARENCY_TYPE_PIXEL",
		"transparentPixel",
		"length",
		"transparentPixel",
		"CHUNK_IDAT",
		"ERROR_INVALID_IMAGE",
		"ERROR_NOT_IMPLEMENTED",
		"ERROR_UNSUPPORTED_FORMAT",
		"length",
		"length",
		"COLOR_TYPE_GRAYSCALE_WITH_ALPHA",
		"width",
		"height",
		"bytesPerLine",
		"data",
		"alphaData",
		"COLOR_TYPE_RGB_WITH_ALPHA",
		"width",
		"height",
		"bytesPerLine",
		"data",
		"alphaData",
		"COLOR_TYPE_RGB",
		"data",
		"COLOR_TYPE_PALETTE",
		"data",
		"width",
		"height",
		"length",
		"alphaData",
		"data",
		"INTERLACE_METHOD_NONE",
		"length",
		"length",
		"FILTER_NONE",
		"FILTER_SUB",
		"length",
		"FILTER_UP",
		"length",
		"FILTER_AVERAGE",
		"length",
		"FILTER_PAETH",
		"length",
		"e",
		"chunkReader",
		"p1",
		"stream",
		"e",
		"data",
		"data",
		"imageData",
		"data",
		"imageData",
		"chunk",
		"chunkReader",
		"rowWidthInPixels",
		"rowInterval",
		"columnInterval",
		"startRow",
		"startColumn",
		"frameCount",
		"frameCount",
		"source",
		"sourceOffset",
		"destination",
		"destinationOffset",
		"numberOfValues",
		"value",
		"row",
		"previousRow",
		"filterType"
	],
	"extendORImplementFiles":[
		"FileFormat"
	],
	"package":[
		"org.eclipse.swt.internal.image"
	],
	"import":[
		"java.io",
		"org.eclipse.swt",
		"org.eclipse.swt.graphics"
	],
	"methods":[
		"readSignature",
		"loadFromByteStream",
		"readNextChunk",
		"unloadIntoByteStream",
		"isFileFormat",
		"validateBitDepth",
		"setPixelData",
		"setImageDataValues",
		"readPixelData",
		"getAlignedBytesPerRow",
		"getBytesPerRow",
		"getBytesPerPixel",
		"getBytesPerRow",
		"readInterlaceFrame",
		"readInterlacedImage",
		"fireInterlacedFrameEvent",
		"readNonInterlacedImage",
		"compress16BitDepthTo8BitDepth",
		"compress16BitDepthTo8BitDepth",
		"filterRow",
		"read",
		"readSignature",
		"getIhdrChunk",
		"getAlignedBytesPerRow",
		"getHeight",
		"internal_new",
		"getWidth",
		"getHeight",
		"getSwtBitsPerPixel",
		"usesDirectColor",
		"getPaletteData",
		"hasMoreChunks",
		"readNextChunk",
		"error",
		"readNextChunk",
		"getChunkType",
		"usesDirectColor",
		"getPaletteData",
		"getTransparencyType",
		"getSwtTransparentPixel",
		"getAlphaValues",
		"readPixelData",
		"error",
		"readPixelData",
		"isCritical",
		"error",
		"error",
		"read",
		"unread",
		"getBitDepth",
		"compress16BitDepthTo8BitDepth",
		"getColorType",
		"getAlignedBytesPerRow",
		"getBitDepth",
		"getAlignedBytesPerRow",
		"getBitDepth",
		"getPixels",
		"validateBitDepth",
		"setPixelData",
		"getInterlaceMethod",
		"readNonInterlacedImage",
		"readInterlacedImage",
		"assertImageDataAtEnd",
		"checkAdler",
		"getBytesPerRow",
		"getWidth",
		"getBytesPerRow",
		"getWidth",
		"getBitsPerPixel",
		"getBitsPerPixel",
		"getWidth",
		"getAlignedBytesPerRow",
		"getHeight",
		"getBytesPerRow",
		"getNextDecodedByte",
		"getNextDecodedByte",
		"filterRow",
		"getBitDepth",
		"getBytesPerPixel",
		"getBitDepth",
		"setImageDataValues",
		"fireInterlacedFrameEvent",
		"readInterlaceFrame",
		"readInterlaceFrame",
		"readInterlaceFrame",
		"readInterlaceFrame",
		"readInterlaceFrame",
		"readInterlaceFrame",
		"readInterlaceFrame",
		"hasListeners",
		"clone",
		"notifyListeners",
		"getAlignedBytesPerRow",
		"getBytesPerRow",
		"getHeight",
		"getNextDecodedByte",
		"getNextDecodedByte",
		"filterRow",
		"arraycopy",
		"setImageDataValues",
		"getFilterByteOffset",
		"abs",
		"abs",
		"abs",
		"PngChunkReader",
		"PaletteData",
		"PngDecodingDataStream",
		"ImageLoaderEvent"
	],
	"methodsBody":{
		"ImageData[] loadFromByteStream()":{
			"methodBody":"{\n    try {\n        readSignature();\n        PngChunkReader chunkReader = new PngChunkReader(inputStream);\n        headerChunk = chunkReader.getIhdrChunk();\n        int imageSize = getAlignedBytesPerRow() * headerChunk.getHeight();\n        data = new byte[imageSize];\n        imageData = ImageData.internal_new(headerChunk.getWidth(), headerChunk.getHeight(), headerChunk.getSwtBitsPerPixel(), new PaletteData(0, 0, 0), 4, data, 0, null, null, -1, -1, SWT.IMAGE_PNG, 0, 0, 0, 0);\n        if (headerChunk.usesDirectColor()) {\n            imageData.palette = headerChunk.getPaletteData();\n        }\n        \n        while (chunkReader.hasMoreChunks()) {\n            readNextChunk(chunkReader);\n        }\n        return new ImageData[] { imageData };\n    } catch (IOException e) {\n        SWT.error(SWT.ERROR_INVALID_IMAGE);\n        return null;\n    }\n}",
			"comments":"/**\n* Load the PNG image from the byte stream.\n*/\n// Read and process chunks until the IEND chunk is encountered.\n",
			"methodName":"ImageData[] loadFromByteStream()"
		},
		"void setPixelData(byte[] data, ImageData imageData)":{
			"methodBody":"{\n    switch(headerChunk.getColorType()) {\n        case PngIhdrChunk.COLOR_TYPE_GRAYSCALE_WITH_ALPHA:\n            {\n                int width = imageData.width;\n                int height = imageData.height;\n                int destBytesPerLine = imageData.bytesPerLine;\n                \n                int srcBytesPerLine = getAlignedBytesPerRow();\n                if (headerChunk.getBitDepth() > 8)\n                    srcBytesPerLine /= 2;\n                byte[] rgbData = new byte[destBytesPerLine * height];\n                byte[] alphaData = new byte[width * height];\n                for (int y = 0; y < height; y++) {\n                    int srcIndex = srcBytesPerLine * y;\n                    int destIndex = destBytesPerLine * y;\n                    int destAlphaIndex = width * y;\n                    for (int x = 0; x < width; x++) {\n                        byte grey = data[srcIndex];\n                        byte alpha = data[srcIndex + 1];\n                        rgbData[destIndex + 0] = grey;\n                        rgbData[destIndex + 1] = grey;\n                        rgbData[destIndex + 2] = grey;\n                        alphaData[destAlphaIndex] = alpha;\n                        srcIndex += 2;\n                        destIndex += 3;\n                        destAlphaIndex++;\n                    }\n                }\n                imageData.data = rgbData;\n                imageData.alphaData = alphaData;\n                break;\n            }\n        case PngIhdrChunk.COLOR_TYPE_RGB_WITH_ALPHA:\n            {\n                int width = imageData.width;\n                int height = imageData.height;\n                int destBytesPerLine = imageData.bytesPerLine;\n                int srcBytesPerLine = getAlignedBytesPerRow();\n                \n                if (headerChunk.getBitDepth() > 8)\n                    srcBytesPerLine /= 2;\n                byte[] rgbData = new byte[destBytesPerLine * height];\n                byte[] alphaData = new byte[width * height];\n                for (int y = 0; y < height; y++) {\n                    int srcIndex = srcBytesPerLine * y;\n                    int destIndex = destBytesPerLine * y;\n                    int destAlphaIndex = width * y;\n                    for (int x = 0; x < width; x++) {\n                        rgbData[destIndex + 0] = data[srcIndex + 0];\n                        rgbData[destIndex + 1] = data[srcIndex + 1];\n                        rgbData[destIndex + 2] = data[srcIndex + 2];\n                        alphaData[destAlphaIndex] = data[srcIndex + 3];\n                        srcIndex += 4;\n                        destIndex += 3;\n                        destAlphaIndex++;\n                    }\n                }\n                imageData.data = rgbData;\n                imageData.alphaData = alphaData;\n                break;\n            }\n        case PngIhdrChunk.COLOR_TYPE_RGB:\n            imageData.data = data;\n            break;\n        case PngIhdrChunk.COLOR_TYPE_PALETTE:\n            imageData.data = data;\n            if (alphaPalette != null) {\n                int size = imageData.width * imageData.height;\n                byte[] alphaData = new byte[size];\n                byte[] pixelData = new byte[size];\n                imageData.getPixels(0, 0, size, pixelData, 0);\n                for (int i = 0; i < pixelData.length; i++) {\n                    alphaData[i] = alphaPalette[pixelData[i] & 0xFF];\n                }\n                imageData.alphaData = alphaData;\n            }\n            break;\n        default:\n            imageData.data = data;\n            break;\n    }\n}",
			"comments":"/**\n* SWT does not support greyscale as a color type. For\n* plain grayscale, we create a palette. For Grayscale\n* with Alpha, however, we need to convert the pixels\n* to use RGB values.\n* Note: This method assumes that the bit depth of the\n* data has already been restricted to 8 or less.\n*/\n/*\n* If the image uses 16-bit depth, it is converted\n* to an 8-bit depth image.\n*/\n/*\n* If the image uses 16-bit depth, it is converted\n* to an 8-bit depth image.\n*/\n",
			"methodName":"void setPixelData(byte[] data, ImageData imageData)"
		},
		"void readPixelData(PngIdatChunk chunk, PngChunkReader chunkReader)":{
			"methodBody":"{\n    decodingStream = new PngDecodingDataStream(chunk, chunkReader);\n    int interlaceMethod = headerChunk.getInterlaceMethod();\n    if (interlaceMethod == PngIhdrChunk.INTERLACE_METHOD_NONE) {\n        readNonInterlacedImage();\n    } else {\n        readInterlacedImage();\n    }\n    decodingStream.assertImageDataAtEnd();\n    decodingStream.checkAdler();\n}",
			"comments":"/**\n* Read the image data from the data stream. This must handle\n* decoding the data, filtering, and interlacing.\n*/\n",
			"methodName":"void readPixelData(PngIdatChunk chunk, PngChunkReader chunkReader)"
		},
		"int getAlignedBytesPerRow()":{
			"methodBody":"{\n    return ((getBytesPerRow(headerChunk.getWidth()) + 3) / 4) * 4;\n}",
			"comments":"/**\n* Answer the number of bytes in a word-aligned row of pixel data.\n*/\n",
			"methodName":"int getAlignedBytesPerRow()"
		},
		"void readInterlacedImage()":{
			"methodBody":"{\n    readInterlaceFrame(8, 8, 0, 0, 0);\n    readInterlaceFrame(8, 8, 0, 4, 1);\n    readInterlaceFrame(8, 4, 4, 0, 2);\n    readInterlaceFrame(4, 4, 0, 2, 3);\n    readInterlaceFrame(4, 2, 2, 0, 4);\n    readInterlaceFrame(2, 2, 0, 1, 5);\n    readInterlaceFrame(2, 1, 1, 0, 6);\n}",
			"comments":"/**\n* Read the pixel data for an interlaced image from the\n* data stream.\n*/\n",
			"methodName":"void readInterlacedImage()"
		},
		"void fireInterlacedFrameEvent(int frameCount)":{
			"methodBody":"{\n    if (loader.hasListeners()) {\n        ImageData image = (ImageData) imageData.clone();\n        boolean finalFrame = frameCount == 6;\n        loader.notifyListeners(new ImageLoaderEvent(loader, image, frameCount, finalFrame));\n    }\n}",
			"comments":"/**\n* Fire an event to let listeners know that an interlaced\n* frame has been loaded.\n* finalFrame should be true if the image has finished\n* loading, false if there are more frames to come.\n*/\n",
			"methodName":"void fireInterlacedFrameEvent(int frameCount)"
		},
		"void readSignature() throws IOException":{
			"methodBody":"{\n    byte[] signature = new byte[SIGNATURE_LENGTH];\n    inputStream.read(signature);\n}",
			"comments":"/**\n* Skip over signature data. This has already been\n* verified in isPNGFile().\n*/\n",
			"methodName":"void readSignature() throws IOException"
		},
		"static int compress16BitDepthTo8BitDepth(int value)":{
			"methodBody":"{\n    \n    return value >> 8;\n}",
			"comments":"/**\n* SWT does not support 16-bit depth color formats.\n* Convert the 16-bit data to 8-bit data.\n* The correct way to do this is to multiply each\n* 16 bit value by the value:\n* (2^8 - 1) / (2^16 - 1).\n* The fast way to do this is just to drop the low\n* byte of the 16-bit value.\n*/\n//double multiplier = (Compatibility.pow2(8) - 1) / (Compatibility.pow2(16) - 1);\n//byte compressedValue = (byte)(value * multiplier);\n",
			"methodName":"static int compress16BitDepthTo8BitDepth(int value)"
		},
		"int getBytesPerPixel()":{
			"methodBody":"{\n    int bitsPerPixel = headerChunk.getBitsPerPixel();\n    return (bitsPerPixel + 7) / 8;\n}",
			"comments":"/**\n* Answer the number of bytes needed to represent a pixel.\n* This value depends on the image's color type and bit\n* depth.\n* Note that this method rounds up if an image's pixel size\n* isn't byte-aligned.\n*/\n",
			"methodName":"int getBytesPerPixel()"
		},
		"static void compress16BitDepthTo8BitDepth(byte[] source, int sourceOffset, byte[] destination, int destinationOffset, int numberOfValues)":{
			"methodBody":"{\n    \n    for (int i = 0; i < numberOfValues; i++) {\n        int sourceIndex = sourceOffset + (2 * i);\n        int destinationIndex = destinationOffset + i;\n        \n        \n        byte compressedValue = source[sourceIndex];\n        destination[destinationIndex] = compressedValue;\n    }\n}",
			"comments":"/**\n* SWT does not support 16-bit depth color formats.\n* Convert the 16-bit data to 8-bit data.\n* The correct way to do this is to multiply each\n* 16 bit value by the value:\n* (2^8 - 1) / (2^16 - 1).\n* The fast way to do this is just to drop the low\n* byte of the 16-bit value.\n*/\n//double multiplier = (Compatibility.pow2(8) - 1) / (Compatibility.pow2(16) - 1);\n//int value = (source[sourceIndex] << 8) | source[sourceIndex + 1];\n//byte compressedValue = (byte)(value * multiplier);\n",
			"methodName":"static void compress16BitDepthTo8BitDepth(byte[] source, int sourceOffset, byte[] destination, int destinationOffset, int numberOfValues)"
		},
		"void setImageDataValues(byte[] data, ImageData imageData)":{
			"methodBody":"{\n    byte[] result = validateBitDepth(data);\n    setPixelData(result, imageData);\n}",
			"comments":"/**\n* PNG supports some color types and bit depths that are\n* unsupported by SWT. If the image uses an unsupported\n* color type (either of the gray scale types) or bit\n* depth (16), convert the data to an SWT-supported\n* format. Then assign the data into the ImageData given.\n*/\n",
			"methodName":"void setImageDataValues(byte[] data, ImageData imageData)"
		},
		"boolean isFileFormat(LEDataInputStream stream)":{
			"methodBody":"{\n    try {\n        byte[] signature = new byte[SIGNATURE_LENGTH];\n        stream.read(signature);\n        stream.unread(signature);\n        \n        if ((signature[0] & 0xFF) != 137)\n            return false;\n        \n        if ((signature[1] & 0xFF) != 80)\n            return false;\n        \n        if ((signature[2] & 0xFF) != 78)\n            return false;\n        \n        if ((signature[3] & 0xFF) != 71)\n            return false;\n        \n        if ((signature[4] & 0xFF) != 13)\n            return false;\n        \n        if ((signature[5] & 0xFF) != 10)\n            return false;\n        \n        if ((signature[6] & 0xFF) != 26)\n            return false;\n        \n        if ((signature[7] & 0xFF) != 10)\n            return false;\n        return true;\n    } catch (Exception e) {\n        return false;\n    }\n}",
			"comments":"//137\n//P\n//N\n//G\n//<RETURN>\n//<LINEFEED>\n//<CTRL/Z>\n//<LINEFEED>\n",
			"methodName":"boolean isFileFormat(LEDataInputStream stream)"
		},
		"void readInterlaceFrame(int rowInterval, int columnInterval, int startRow, int startColumn, int frameCount)":{
			"methodBody":"{\n    int width = headerChunk.getWidth();\n    int alignedBytesPerRow = getAlignedBytesPerRow();\n    int height = headerChunk.getHeight();\n    if (startRow >= height || startColumn >= width)\n        return;\n    int pixelsPerRow = (width - startColumn + columnInterval - 1) / columnInterval;\n    int bytesPerRow = getBytesPerRow(pixelsPerRow);\n    byte[] row1 = new byte[bytesPerRow];\n    byte[] row2 = new byte[bytesPerRow];\n    byte[] currentRow = row1;\n    byte[] lastRow = row2;\n    for (int row = startRow; row < height; row += rowInterval) {\n        byte filterType = decodingStream.getNextDecodedByte();\n        for (int col = 0; col < bytesPerRow; col++) {\n            currentRow[col] = decodingStream.getNextDecodedByte();\n        }\n        filterRow(currentRow, lastRow, filterType);\n        if (headerChunk.getBitDepth() >= 8) {\n            int bytesPerPixel = getBytesPerPixel();\n            int dataOffset = (row * alignedBytesPerRow) + (startColumn * bytesPerPixel);\n            for (int rowOffset = 0; rowOffset < currentRow.length; rowOffset += bytesPerPixel) {\n                for (int byteOffset = 0; byteOffset < bytesPerPixel; byteOffset++) {\n                    data[dataOffset + byteOffset] = currentRow[rowOffset + byteOffset];\n                }\n                dataOffset += (columnInterval * bytesPerPixel);\n            }\n        } else {\n            int bitsPerPixel = headerChunk.getBitDepth();\n            int pixelsPerByte = 8 / bitsPerPixel;\n            int column = startColumn;\n            int rowBase = row * alignedBytesPerRow;\n            int valueMask = 0;\n            for (int i = 0; i < bitsPerPixel; i++) {\n                valueMask <<= 1;\n                valueMask |= 1;\n            }\n            int maxShift = 8 - bitsPerPixel;\n            for (int byteOffset = 0; byteOffset < currentRow.length; byteOffset++) {\n                for (int bitOffset = maxShift; bitOffset >= 0; bitOffset -= bitsPerPixel) {\n                    if (column < width) {\n                        int dataOffset = rowBase + (column * bitsPerPixel / 8);\n                        int value = (currentRow[byteOffset] >> bitOffset) & valueMask;\n                        int dataShift = maxShift - (bitsPerPixel * (column % pixelsPerByte));\n                        data[dataOffset] |= value << dataShift;\n                    }\n                    column += columnInterval;\n                }\n            }\n        }\n        currentRow = (currentRow == row1) ? row2 : row1;\n        lastRow = (lastRow == row1) ? row2 : row1;\n    }\n    setImageDataValues(data, imageData);\n    fireInterlacedFrameEvent(frameCount);\n}",
			"comments":"/**\n* 1. Read one of the seven frames of interlaced data.\n* 2. Update the imageData.\n* 3. Notify the image loader's listeners of the frame load.\n*/\n",
			"methodName":"void readInterlaceFrame(int rowInterval, int columnInterval, int startRow, int startColumn, int frameCount)"
		},
		"void filterRow(byte[] row, byte[] previousRow, int filterType)":{
			"methodBody":"{\n    int byteOffset = headerChunk.getFilterByteOffset();\n    switch(filterType) {\n        case PngIhdrChunk.FILTER_NONE:\n            break;\n        case PngIhdrChunk.FILTER_SUB:\n            for (int i = byteOffset; i < row.length; i++) {\n                int current = row[i] & 0xFF;\n                int left = row[i - byteOffset] & 0xFF;\n                row[i] = (byte) ((current + left) & 0xFF);\n            }\n            break;\n        case PngIhdrChunk.FILTER_UP:\n            for (int i = 0; i < row.length; i++) {\n                int current = row[i] & 0xFF;\n                int above = previousRow[i] & 0xFF;\n                row[i] = (byte) ((current + above) & 0xFF);\n            }\n            break;\n        case PngIhdrChunk.FILTER_AVERAGE:\n            for (int i = 0; i < row.length; i++) {\n                int left = (i < byteOffset) ? 0 : row[i - byteOffset] & 0xFF;\n                int above = previousRow[i] & 0xFF;\n                int current = row[i] & 0xFF;\n                row[i] = (byte) ((current + ((left + above) / 2)) & 0xFF);\n            }\n            break;\n        case PngIhdrChunk.FILTER_PAETH:\n            for (int i = 0; i < row.length; i++) {\n                int left = (i < byteOffset) ? 0 : row[i - byteOffset] & 0xFF;\n                int aboveLeft = (i < byteOffset) ? 0 : previousRow[i - byteOffset] & 0xFF;\n                int above = previousRow[i] & 0xFF;\n                int a = Math.abs(above - aboveLeft);\n                int b = Math.abs(left - aboveLeft);\n                int c = Math.abs(left - aboveLeft + above - aboveLeft);\n                int preductor = 0;\n                if (a <= b && a <= c) {\n                    preductor = left;\n                } else if (b <= c) {\n                    preductor = above;\n                } else {\n                    preductor = aboveLeft;\n                }\n                int currentValue = row[i] & 0xFF;\n                row[i] = (byte) ((currentValue + preductor) & 0xFF);\n            }\n            break;\n    }\n}",
			"comments":"/**\n* PNG supports four filtering types. These types are applied\n* per row of image data. This method unfilters the given row\n* based on the filterType.\n*/\n",
			"methodName":"void filterRow(byte[] row, byte[] previousRow, int filterType)"
		},
		"int getBytesPerRow(int rowWidthInPixels)":{
			"methodBody":"{\n    int bitsPerPixel = headerChunk.getBitsPerPixel();\n    int bitsPerRow = bitsPerPixel * rowWidthInPixels;\n    int bitsPerByte = 8;\n    return (bitsPerRow + (bitsPerByte - 1)) / bitsPerByte;\n}",
			"comments":"/**\n* Answer the number of bytes in a row of the given pixel\n* width. Each row is byte-aligned, so images with bit\n* depths less than a byte may have unused bits at the\n* end of each row. The value of these bits is undefined.\n*/\n",
			"methodName":"int getBytesPerRow(int rowWidthInPixels)"
		},
		"void readNonInterlacedImage()":{
			"methodBody":"{\n    int dataOffset = 0;\n    int alignedBytesPerRow = getAlignedBytesPerRow();\n    int bytesPerRow = getBytesPerRow();\n    byte[] row1 = new byte[bytesPerRow];\n    byte[] row2 = new byte[bytesPerRow];\n    byte[] currentRow = row1;\n    byte[] lastRow = row2;\n    for (int row = 0; row < headerChunk.getHeight(); row++) {\n        byte filterType = decodingStream.getNextDecodedByte();\n        for (int col = 0; col < bytesPerRow; col++) {\n            currentRow[col] = decodingStream.getNextDecodedByte();\n        }\n        filterRow(currentRow, lastRow, filterType);\n        System.arraycopy(currentRow, 0, data, dataOffset, bytesPerRow);\n        dataOffset += alignedBytesPerRow;\n        currentRow = (currentRow == row1) ? row2 : row1;\n        lastRow = (lastRow == row1) ? row2 : row1;\n    }\n    setImageDataValues(data, imageData);\n}",
			"comments":"/**\n* Read the pixel data for a non-interlaced image from the\n* data stream.\n* Update the imageData to reflect the new data.\n*/\n",
			"methodName":"void readNonInterlacedImage()"
		},
		"byte[] validateBitDepth(byte[] data)":{
			"methodBody":"{\n    if (headerChunk.getBitDepth() > 8) {\n        byte[] result = new byte[data.length / 2];\n        compress16BitDepthTo8BitDepth(data, 0, result, 0, result.length);\n        return result;\n    } else {\n        return data;\n    }\n}",
			"comments":"/**\n* SWT does not support 16-bit depths. If this image uses\n* 16-bit depths, convert the data to an 8-bit depth.\n*/\n",
			"methodName":"byte[] validateBitDepth(byte[] data)"
		},
		"void readNextChunk(PngChunkReader chunkReader)":{
			"methodBody":"{\n    PngChunk chunk = chunkReader.readNextChunk();\n    switch(chunk.getChunkType()) {\n        case PngChunk.CHUNK_IEND:\n            break;\n        case PngChunk.CHUNK_PLTE:\n            if (!headerChunk.usesDirectColor()) {\n                paletteChunk = (PngPlteChunk) chunk;\n                imageData.palette = paletteChunk.getPaletteData();\n            }\n            break;\n        case PngChunk.CHUNK_tRNS:\n            PngTrnsChunk trnsChunk = (PngTrnsChunk) chunk;\n            if (trnsChunk.getTransparencyType(headerChunk) == PngTrnsChunk.TRANSPARENCY_TYPE_PIXEL) {\n                imageData.transparentPixel = trnsChunk.getSwtTransparentPixel(headerChunk);\n            } else {\n                alphaPalette = trnsChunk.getAlphaValues(headerChunk, paletteChunk);\n                int transparentCount = 0, transparentPixel = -1;\n                for (int i = 0; i < alphaPalette.length; i++) {\n                    if ((alphaPalette[i] & 0xFF) != 255) {\n                        transparentCount++;\n                        transparentPixel = i;\n                    }\n                }\n                if (transparentCount == 0) {\n                    alphaPalette = null;\n                } else if (transparentCount == 1 && alphaPalette[transparentPixel] == 0) {\n                    alphaPalette = null;\n                    imageData.transparentPixel = transparentPixel;\n                }\n            }\n            break;\n        case PngChunk.CHUNK_IDAT:\n            if (chunkReader.readPixelData()) {\n                \n                \n                \n                \n                SWT.error(SWT.ERROR_INVALID_IMAGE);\n            } else {\n                \n                \n                PngIdatChunk dataChunk = (PngIdatChunk) chunk;\n                readPixelData(dataChunk, chunkReader);\n            }\n            break;\n        default:\n            if (chunk.isCritical()) {\n                \n                SWT.error(SWT.ERROR_NOT_IMPLEMENTED);\n            }\n    }\n}",
			"comments":"/**\n* Read and handle the next chunk of data from the\n* PNG file.\n*/\n// All IDAT chunks in an image file must be\n// sequential. If the pixel data has already\n// been read and another IDAT block is encountered,\n// then this is an invalid image.\n// Read in the pixel data for the image. This should\n// go through all the image's IDAT chunks.\n// All critical chunks must be supported.\n",
			"methodName":"void readNextChunk(PngChunkReader chunkReader)"
		},
		"int getBytesPerRow()":{
			"methodBody":"{\n    return getBytesPerRow(headerChunk.getWidth());\n}",
			"comments":"/**\n* Answer the number of bytes in each row of the image\n* data. Each PNG row is byte-aligned, so images with bit\n* depths less than a byte may have unused bits at the\n* end of each row. The value of these bits is undefined.\n*/\n",
			"methodName":"int getBytesPerRow()"
		},
		"void unloadIntoByteStream(ImageData p1)":{
			"methodBody":"{\n    SWT.error(SWT.ERROR_UNSUPPORTED_FORMAT);\n}",
			"comments":"",
			"methodName":"void unloadIntoByteStream(ImageData p1)"
		}
	},
	"ClassORInterfaceName":[
		"PNGFileFormat"
	]
}
