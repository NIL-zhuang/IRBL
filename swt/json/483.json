{
	"variables":[
		"style",
		"state",
		"display",
		"eventTable",
		"data",
		"DISPOSED",
		"CANVAS",
		"KEYED_DATA",
		"DISABLED",
		"HIDDEN",
		"LAYOUT_NEEDED",
		"LAYOUT_CHANGED",
		"DEFAULT_WIDTH",
		"DEFAULT_HEIGHT",
		"MAJOR",
		"MINOR",
		"typedListener",
		"mask",
		"display",
		"lpRect",
		"buffer",
		"i",
		"j",
		"table",
		"i",
		"display",
		"string",
		"index",
		"display",
		"event",
		"event",
		"index",
		"table",
		"newTable",
		"length",
		"newTable",
		"lpRect",
		"event",
		"menu",
		"string",
		"lead",
		"x",
		"y",
		"pt",
		"rect",
		"pos",
		"display",
		"lead",
		"mapKey",
		"msg",
		"flags",
		"asciiKey",
		"display",
		"event",
		"type",
		"mapKey",
		"result",
		"code",
		"result",
		"dragging",
		"mouseDown",
		"dragDetect",
		"pt",
		"result",
		"menu",
		"hasMenu",
		"x",
		"y",
		"shrg",
		"type",
		"event",
		"result",
		"mask",
		"result",
		"result",
		"result",
		"mask",
		"pos",
		"pt",
		"pos",
		"mouseEnter",
		"mouseExit",
		"mouseHover",
		"lpEventTrack",
		"msg",
		"flags",
		"delta",
		"value",
		"count",
		"detail",
		"pt",
		"result",
		"rect",
		"ps",
		"data",
		"gc",
		"width",
		"height",
		"event",
		"rgn",
		"data",
		"gc",
		"rect",
		"width",
		"height",
		"hDC",
		"event",
		"result",
		"result",
		"result",
		"mask",
		"code",
		"display",
		"oldKeyHit",
		"result",
		"consumed",
		"mapKey",
		"button",
		"result",
		"button",
		"result",
		"button",
		"result",
		"mask",
		"OS",
		"OS",
		"OS",
		"MAJOR",
		"MINOR",
		"System",
		"MAJOR",
		"MINOR",
		"System",
		"OS",
		"OS",
		"OS",
		"parent",
		"style",
		"display",
		"parent",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"eventTable",
		"eventType",
		"listener",
		"listener",
		"SWT",
		"listener",
		"SWT",
		"typedListener",
		"int0",
		"int1",
		"int2",
		"int3",
		"int4",
		"int5",
		"style",
		"mask",
		"style",
		"int0",
		"style",
		"int0",
		"style",
		"style",
		"mask",
		"int0",
		"style",
		"int1",
		"style",
		"style",
		"mask",
		"int1",
		"style",
		"int2",
		"style",
		"style",
		"mask",
		"int2",
		"style",
		"int3",
		"style",
		"style",
		"mask",
		"int3",
		"style",
		"int4",
		"style",
		"style",
		"mask",
		"int4",
		"style",
		"int5",
		"style",
		"style",
		"mask",
		"int5",
		"style",
		"style",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"parent",
		"parent",
		"SWT",
		"style",
		"SWT",
		"parent",
		"SWT",
		"style",
		"SWT",
		"style",
		"style",
		"SWT",
		"SWT",
		"parent",
		"SWT",
		"parent",
		"SWT",
		"parent",
		"parent",
		"SWT",
		"display",
		"SWT",
		"display",
		"Thread",
		"SWT",
		"state",
		"DISPOSED",
		"SWT",
		"OS",
		"uFlags",
		"OS",
		"OS",
		"hWnd",
		"lpRect",
		"cy",
		"lpRect",
		"lpRect",
		"cx",
		"lpRect",
		"lpRect",
		"uFlags",
		"OS",
		"uFlags",
		"OS",
		"OS",
		"hWinPosInfo",
		"hWnd",
		"hWndInsertAfter",
		"X",
		"Y",
		"cx",
		"cy",
		"uFlags",
		"SWT",
		"SWT",
		"code",
		"display",
		"eventType",
		"string",
		"string",
		"string",
		"buffer",
		"i",
		"buffer",
		"buffer",
		"i",
		"i",
		"buffer",
		"buffer",
		"i",
		"buffer",
		"j",
		"i",
		"i",
		"buffer",
		"j",
		"buffer",
		"i",
		"j",
		"buffer",
		"buffer",
		"j",
		"buffer",
		"state",
		"KEYED_DATA",
		"data",
		"data",
		"key",
		"SWT",
		"state",
		"KEYED_DATA",
		"data",
		"i",
		"table",
		"i",
		"key",
		"table",
		"i",
		"table",
		"i",
		"display",
		"SWT",
		"display",
		"string",
		"index",
		"string",
		"string",
		"index",
		"string",
		"style",
		"eventTable",
		"eventTable",
		"eventType",
		"state",
		"DISPOSED",
		"eventType",
		"Display",
		"event",
		"event",
		"eventType",
		"event",
		"eventType",
		"eventType",
		"event",
		"state",
		"DISPOSED",
		"display",
		"SWT",
		"eventTable",
		"data",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"eventType",
		"listener",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"eventType",
		"listener",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"SWT",
		"listener",
		"event",
		"display",
		"event",
		"eventTable",
		"eventTable",
		"event",
		"eventType",
		"eventType",
		"event",
		"eventTable",
		"display",
		"eventType",
		"event",
		"event",
		"event",
		"eventType",
		"event",
		"display",
		"event",
		"event",
		"event",
		"display",
		"send",
		"event",
		"display",
		"event",
		"event",
		"type",
		"wParam",
		"lParam",
		"type",
		"msg",
		"wParam",
		"lParam",
		"event",
		"type",
		"event",
		"event",
		"type",
		"button",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"type",
		"type",
		"event",
		"button",
		"event",
		"detail",
		"event",
		"count",
		"event",
		"lParam",
		"event",
		"lParam",
		"event",
		"type",
		"hwnd",
		"event",
		"send",
		"type",
		"event",
		"type",
		"event",
		"event",
		"state",
		"KEYED_DATA",
		"data",
		"data",
		"key",
		"SWT",
		"state",
		"KEYED_DATA",
		"table",
		"data",
		"index",
		"table",
		"key",
		"table",
		"index",
		"index",
		"value",
		"state",
		"KEYED_DATA",
		"index",
		"table",
		"table",
		"System",
		"table",
		"newTable",
		"table",
		"data",
		"table",
		"newTable",
		"table",
		"table",
		"data",
		"data",
		"table",
		"state",
		"KEYED_DATA",
		"table",
		"index",
		"key",
		"table",
		"index",
		"value",
		"state",
		"KEYED_DATA",
		"index",
		"table",
		"table",
		"length",
		"data",
		"table",
		"state",
		"KEYED_DATA",
		"length",
		"System",
		"table",
		"newTable",
		"index",
		"System",
		"table",
		"index",
		"newTable",
		"index",
		"length",
		"index",
		"data",
		"newTable",
		"type",
		"OS",
		"OS",
		"event",
		"SWT",
		"OS",
		"OS",
		"event",
		"SWT",
		"OS",
		"OS",
		"event",
		"SWT",
		"OS",
		"OS",
		"event",
		"SWT",
		"OS",
		"OS",
		"event",
		"SWT",
		"OS",
		"OS",
		"event",
		"SWT",
		"OS",
		"OS",
		"event",
		"SWT",
		"OS",
		"OS",
		"event",
		"SWT",
		"type",
		"SWT",
		"SWT",
		"event",
		"event",
		"SWT",
		"event",
		"event",
		"SWT",
		"event",
		"event",
		"SWT",
		"event",
		"event",
		"SWT",
		"event",
		"event",
		"SWT",
		"SWT",
		"event",
		"event",
		"SWT",
		"event",
		"event",
		"SWT",
		"event",
		"event",
		"SWT",
		"event",
		"event",
		"SWT",
		"event",
		"event",
		"SWT",
		"SWT",
		"SWT",
		"event",
		"SWT",
		"event",
		"SWT",
		"event",
		"SWT",
		"event",
		"SWT",
		"event",
		"SWT",
		"event",
		"SWT",
		"SWT",
		"event",
		"SWT",
		"event",
		"SWT",
		"event",
		"SWT",
		"event",
		"SWT",
		"event",
		"SWT",
		"event",
		"SWT",
		"display",
		"SWT",
		"display",
		"SWT",
		"display",
		"SWT",
		"SWT",
		"display",
		"SWT",
		"display",
		"SWT",
		"display",
		"SWT",
		"display",
		"SWT",
		"lParam",
		"display",
		"SWT",
		"display",
		"display",
		"OS",
		"display",
		"display",
		"OS",
		"display",
		"event",
		"Display",
		"display",
		"event",
		"display",
		"display",
		"display",
		"event",
		"Display",
		"display",
		"event",
		"event",
		"display",
		"event",
		"type",
		"OS",
		"uFlags",
		"OS",
		"OS",
		"hWnd",
		"lpRect",
		"cy",
		"lpRect",
		"lpRect",
		"cx",
		"lpRect",
		"lpRect",
		"uFlags",
		"OS",
		"uFlags",
		"OS",
		"OS",
		"hWnd",
		"hWndInsertAfter",
		"X",
		"Y",
		"cx",
		"cy",
		"uFlags",
		"event",
		"x",
		"event",
		"y",
		"SWT",
		"event",
		"event",
		"menu",
		"menu",
		"x",
		"event",
		"y",
		"event",
		"menu",
		"event",
		"event",
		"menu",
		"string",
		"string",
		"string",
		"display",
		"OS",
		"OS",
		"wParam",
		"OS",
		"lead",
		"display",
		"wParam",
		"display",
		"wParam",
		"SWT",
		"OS",
		"wParam",
		"lParam",
		"LRESULT",
		"wParam",
		"hwnd",
		"OS",
		"lParam",
		"x",
		"pt",
		"lParam",
		"y",
		"pt",
		"lParam",
		"OS",
		"hwnd",
		"pt",
		"OS",
		"hwnd",
		"rect",
		"OS",
		"rect",
		"pt",
		"OS",
		"x",
		"pos",
		"y",
		"pos",
		"x",
		"y",
		"LRESULT",
		"display",
		"display",
		"wParam",
		"display",
		"display",
		"display",
		"SWT",
		"OS",
		"wParam",
		"lParam",
		"LRESULT",
		"SWT",
		"OS",
		"wParam",
		"lParam",
		"display",
		"display",
		"LRESULT",
		"wParam",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"lParam",
		"display",
		"display",
		"display",
		"display",
		"display",
		"OS",
		"OS",
		"wParam",
		"OS",
		"lead",
		"OS",
		"wParam",
		"OS",
		"mapKey",
		"SWT",
		"OS",
		"mapKey",
		"SWT",
		"OS",
		"mapKey",
		"SWT",
		"OS",
		"mapKey",
		"SWT",
		"OS",
		"mapKey",
		"SWT",
		"mapKey",
		"OS",
		"wParam",
		"OS",
		"mapKey",
		"mapKey",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"msg",
		"hwnd",
		"OS",
		"OS",
		"flags",
		"display",
		"display",
		"mapKey",
		"display",
		"display",
		"wParam",
		"mapKey",
		"LRESULT",
		"display",
		"mapKey",
		"display",
		"wParam",
		"display",
		"display",
		"wParam",
		"display",
		"OS",
		"display",
		"OS",
		"display",
		"display",
		"OS",
		"display",
		"display",
		"display",
		"display",
		"display",
		"display",
		"OS",
		"mapKey",
		"wParam",
		"OS",
		"display",
		"display",
		"wParam",
		"asciiKey",
		"asciiKey",
		"asciiKey",
		"wParam",
		"wParam",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"display",
		"display",
		"wParam",
		"display",
		"display",
		"mapKey",
		"display",
		"OS",
		"mapKey",
		"display",
		"display",
		"display",
		"display",
		"SWT",
		"OS",
		"wParam",
		"lParam",
		"LRESULT",
		"OS",
		"OS",
		"wParam",
		"wParam",
		"OS",
		"display",
		"display",
		"display",
		"display",
		"display",
		"event",
		"wParam",
		"OS",
		"lParam",
		"SWT",
		"SWT",
		"event",
		"type",
		"type",
		"event",
		"SWT",
		"display",
		"SWT",
		"display",
		"display",
		"display",
		"display",
		"display",
		"OS",
		"wParam",
		"OS",
		"mapKey",
		"SWT",
		"OS",
		"mapKey",
		"SWT",
		"OS",
		"mapKey",
		"SWT",
		"OS",
		"mapKey",
		"SWT",
		"OS",
		"mapKey",
		"SWT",
		"mapKey",
		"OS",
		"wParam",
		"OS",
		"mapKey",
		"mapKey",
		"display",
		"display",
		"mapKey",
		"display",
		"wParam",
		"display",
		"display",
		"wParam",
		"wParam",
		"OS",
		"display",
		"display",
		"display",
		"display",
		"display",
		"SWT",
		"OS",
		"wParam",
		"lParam",
		"result",
		"LRESULT",
		"display",
		"display",
		"display",
		"display",
		"display",
		"result",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"SWT",
		"LRESULT",
		"code",
		"LRESULT",
		"code",
		"SWT",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"SWT",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"OS",
		"hwnd",
		"OS",
		"hwnd",
		"result",
		"SWT",
		"dragDetect",
		"OS",
		"pt",
		"lParam",
		"pt",
		"lParam",
		"OS",
		"hwnd",
		"pt",
		"dragging",
		"OS",
		"hwnd",
		"pt",
		"mouseDown",
		"OS",
		"OS",
		"SWT",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"OS",
		"menu",
		"menu",
		"hasMenu",
		"SWT",
		"lParam",
		"lParam",
		"shrg",
		"SHRGINFO",
		"shrg",
		"hwnd",
		"shrg",
		"x",
		"shrg",
		"y",
		"shrg",
		"OS",
		"OS",
		"shrg",
		"type",
		"OS",
		"x",
		"y",
		"mouseDown",
		"OS",
		"hwnd",
		"OS",
		"hwnd",
		"dragging",
		"event",
		"lParam",
		"event",
		"lParam",
		"SWT",
		"event",
		"dragDetect",
		"OS",
		"OS",
		"OS",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"result",
		"SWT",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"wParam",
		"mask",
		"OS",
		"hwnd",
		"OS",
		"result",
		"SWT",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"SWT",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"OS",
		"hwnd",
		"OS",
		"hwnd",
		"result",
		"SWT",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"OS",
		"hwnd",
		"OS",
		"hwnd",
		"result",
		"SWT",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"wParam",
		"mask",
		"OS",
		"hwnd",
		"OS",
		"result",
		"SWT",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"SWT",
		"SWT",
		"OS",
		"pt",
		"pos",
		"pt",
		"pos",
		"OS",
		"hwnd",
		"pt",
		"lParam",
		"pt",
		"pt",
		"SWT",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"OS",
		"pos",
		"display",
		"display",
		"OS",
		"SWT",
		"display",
		"SWT",
		"SWT",
		"display",
		"SWT",
		"SWT",
		"display",
		"SWT",
		"mouseEnter",
		"mouseExit",
		"mouseHover",
		"lpEventTrack",
		"TRACKMOUSEEVENT",
		"lpEventTrack",
		"OS",
		"lpEventTrack",
		"hwnd",
		"OS",
		"lpEventTrack",
		"lpEventTrack",
		"lpEventTrack",
		"OS",
		"OS",
		"lpEventTrack",
		"hwnd",
		"OS",
		"lpEventTrack",
		"mouseEnter",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"msg",
		"OS",
		"OS",
		"flags",
		"OS",
		"msg",
		"OS",
		"msg",
		"SWT",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"lpEventTrack",
		"OS",
		"OS",
		"lpEventTrack",
		"pos",
		"display",
		"display",
		"pos",
		"SWT",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"display",
		"SWT",
		"SWT",
		"wParam",
		"OS",
		"OS",
		"value",
		"value",
		"OS",
		"detail",
		"SWT",
		"count",
		"delta",
		"OS",
		"detail",
		"SWT",
		"count",
		"value",
		"delta",
		"OS",
		"pt",
		"lParam",
		"pt",
		"lParam",
		"OS",
		"hwnd",
		"pt",
		"lParam",
		"pt",
		"pt",
		"SWT",
		"count",
		"detail",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"LRESULT",
		"SWT",
		"SWT",
		"OS",
		"OS",
		"hwnd",
		"rect",
		"result",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"OS",
		"hwnd",
		"OS",
		"hwnd",
		"rect",
		"OS",
		"hwnd",
		"data",
		"ps",
		"data",
		"hwnd",
		"data",
		"gc",
		"ps",
		"ps",
		"ps",
		"ps",
		"width",
		"height",
		"event",
		"gc",
		"event",
		"ps",
		"event",
		"ps",
		"event",
		"width",
		"event",
		"height",
		"SWT",
		"event",
		"event",
		"gc",
		"OS",
		"OS",
		"hwnd",
		"rgn",
		"result",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"data",
		"hwnd",
		"data",
		"gc",
		"OS",
		"hwnd",
		"OS",
		"rgn",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"width",
		"height",
		"gc",
		"OS",
		"hDC",
		"rgn",
		"OS",
		"hDC",
		"event",
		"gc",
		"event",
		"rect",
		"event",
		"rect",
		"event",
		"width",
		"event",
		"height",
		"SWT",
		"event",
		"event",
		"gc",
		"OS",
		"hwnd",
		"OS",
		"rgn",
		"result",
		"LRESULT",
		"result",
		"SWT",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"SWT",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"OS",
		"hwnd",
		"OS",
		"hwnd",
		"result",
		"SWT",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"OS",
		"hwnd",
		"OS",
		"hwnd",
		"result",
		"SWT",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"wParam",
		"mask",
		"OS",
		"hwnd",
		"OS",
		"result",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"SWT",
		"LRESULT",
		"code",
		"LRESULT",
		"code",
		"display",
		"wParam",
		"display",
		"wParam",
		"SWT",
		"display",
		"SWT",
		"display",
		"display",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"display",
		"consumed",
		"SWT",
		"OS",
		"wParam",
		"lParam",
		"consumed",
		"display",
		"display",
		"oldKeyHit",
		"consumed",
		"LRESULT",
		"result",
		"wParam",
		"OS",
		"lParam",
		"wParam",
		"OS",
		"wParam",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"lParam",
		"display",
		"display",
		"display",
		"display",
		"display",
		"OS",
		"wParam",
		"OS",
		"mapKey",
		"SWT",
		"OS",
		"mapKey",
		"SWT",
		"OS",
		"mapKey",
		"SWT",
		"OS",
		"mapKey",
		"SWT",
		"OS",
		"mapKey",
		"SWT",
		"mapKey",
		"OS",
		"wParam",
		"display",
		"mapKey",
		"display",
		"wParam",
		"display",
		"display",
		"wParam",
		"display",
		"OS",
		"display",
		"OS",
		"display",
		"display",
		"OS",
		"display",
		"display",
		"display",
		"display",
		"OS",
		"mapKey",
		"OS",
		"wParam",
		"OS",
		"display",
		"SWT",
		"OS",
		"wParam",
		"lParam",
		"LRESULT",
		"hwnd",
		"wParam",
		"lParam",
		"wParam",
		"OS",
		"SWT",
		"button",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"SWT",
		"button",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"OS",
		"hwnd",
		"OS",
		"hwnd",
		"result",
		"wParam",
		"OS",
		"SWT",
		"button",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"OS",
		"hwnd",
		"OS",
		"hwnd",
		"result",
		"wParam",
		"OS",
		"SWT",
		"button",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"hwnd",
		"OS",
		"wParam",
		"lParam",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"wParam",
		"mask",
		"OS",
		"hwnd",
		"OS",
		"result",
		"IsWinCE",
		"COMCTL32_VERSION",
		"out",
		"out",
		"COMCTL32_MAJOR",
		"COMCTL32_MINOR",
		"style",
		"display",
		"ERROR_NULL_ARGUMENT",
		"ERROR_NULL_ARGUMENT",
		"Dispose",
		"MIRRORED",
		"LEFT_TO_RIGHT",
		"RIGHT_TO_LEFT",
		"style",
		"LEFT_TO_RIGHT",
		"LEFT_TO_RIGHT",
		"style",
		"RIGHT_TO_LEFT",
		"RIGHT_TO_LEFT",
		"LEFT_TO_RIGHT",
		"RIGHT_TO_LEFT",
		"ERROR_NULL_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_INVALID_SUBCLASS",
		"display",
		"ERROR_WIDGET_DISPOSED",
		"thread",
		"ERROR_THREAD_INVALID_ACCESS",
		"ERROR_WIDGET_DISPOSED",
		"IsWinCE",
		"SWP_NOSIZE",
		"bottom",
		"top",
		"right",
		"left",
		"SWP_DRAWFRAME",
		"SWP_NOSIZE",
		"ERROR_THREAD_INVALID_ACCESS",
		"length",
		"length",
		"length",
		"ERROR_NULL_ARGUMENT",
		"length",
		"display",
		"ERROR_WIDGET_DISPOSED",
		"Dispose",
		"ERROR_NULL_ARGUMENT",
		"ERROR_NULL_ARGUMENT",
		"ERROR_NULL_ARGUMENT",
		"Dispose",
		"display",
		"type",
		"display",
		"widget",
		"time",
		"time",
		"doit",
		"button",
		"detail",
		"count",
		"x",
		"y",
		"doit",
		"data",
		"data",
		"ERROR_NULL_ARGUMENT",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"VK_MENU",
		"stateMask",
		"ALT",
		"VK_SHIFT",
		"stateMask",
		"SHIFT",
		"VK_CONTROL",
		"stateMask",
		"CONTROL",
		"VK_LBUTTON",
		"stateMask",
		"BUTTON1",
		"VK_MBUTTON",
		"stateMask",
		"BUTTON2",
		"VK_RBUTTON",
		"stateMask",
		"BUTTON3",
		"VK_XBUTTON1",
		"stateMask",
		"BUTTON4",
		"VK_XBUTTON2",
		"stateMask",
		"BUTTON5",
		"MouseDown",
		"MouseDoubleClick",
		"button",
		"stateMask",
		"BUTTON1",
		"button",
		"stateMask",
		"BUTTON2",
		"button",
		"stateMask",
		"BUTTON3",
		"button",
		"stateMask",
		"BUTTON4",
		"button",
		"stateMask",
		"BUTTON5",
		"MouseUp",
		"button",
		"stateMask",
		"BUTTON1",
		"button",
		"stateMask",
		"BUTTON2",
		"button",
		"stateMask",
		"BUTTON3",
		"button",
		"stateMask",
		"BUTTON4",
		"button",
		"stateMask",
		"BUTTON5",
		"KeyDown",
		"Traverse",
		"keyCode",
		"ALT",
		"stateMask",
		"ALT",
		"keyCode",
		"SHIFT",
		"stateMask",
		"SHIFT",
		"keyCode",
		"CONTROL",
		"stateMask",
		"CONTROL",
		"KeyUp",
		"keyCode",
		"ALT",
		"stateMask",
		"ALT",
		"keyCode",
		"SHIFT",
		"stateMask",
		"SHIFT",
		"keyCode",
		"CONTROL",
		"stateMask",
		"CONTROL",
		"lastAscii",
		"DEL",
		"lastKey",
		"BS",
		"lastAscii",
		"BS",
		"LF",
		"lastKey",
		"CR",
		"lastAscii",
		"CR",
		"lastKey",
		"CR",
		"lastAscii",
		"CR",
		"lastKey",
		"KEYPAD_CR",
		"lastVirtual",
		"lastKey",
		"VK_DELETE",
		"lastAscii",
		"lastKey",
		"VK_CANCEL",
		"lastAscii",
		"keyCode",
		"lastKey",
		"keyCode",
		"lastKey",
		"lastAscii",
		"lastNull",
		"character",
		"lastAscii",
		"keyCode",
		"character",
		"lastNull",
		"IsWinCE",
		"SWP_NOSIZE",
		"bottom",
		"top",
		"right",
		"left",
		"SWP_DRAWFRAME",
		"SWP_NOSIZE",
		"x",
		"y",
		"MenuDetect",
		"doit",
		"x",
		"y",
		"x",
		"y",
		"captureChanged",
		"IsUnicode",
		"IsDBLocale",
		"lastAscii",
		"lastNull",
		"KeyDown",
		"WM_CHAR",
		"ONE",
		"IsWinCE",
		"x",
		"y",
		"ZERO",
		"display",
		"lastKey",
		"lastAscii",
		"lastVirtual",
		"lastNull",
		"lastDead",
		"KeyDown",
		"WM_IME_CHAR",
		"ONE",
		"KeyUp",
		"WM_IME_CHAR",
		"lastKey",
		"lastAscii",
		"ONE",
		"VK_SHIFT",
		"VK_MENU",
		"VK_CONTROL",
		"VK_CAPITAL",
		"VK_NUMLOCK",
		"VK_SCROLL",
		"lastAscii",
		"lastKey",
		"lastVirtual",
		"lastNull",
		"lastDead",
		"IsUnicode",
		"IsDBLocale",
		"IsWinCE",
		"VK_BACK",
		"BS",
		"VK_RETURN",
		"CR",
		"VK_DELETE",
		"DEL",
		"VK_ESCAPE",
		"ESC",
		"VK_TAB",
		"TAB",
		"IsWinNT",
		"PM_NOREMOVE",
		"PM_NOYIELD",
		"PM_QS_INPUT",
		"PM_QS_POSTMESSAGE",
		"WM_DEADCHAR",
		"WM_DEADCHAR",
		"lastDead",
		"lastVirtual",
		"lastKey",
		"lastVirtual",
		"ONE",
		"lastVirtual",
		"lastVirtual",
		"lastKey",
		"lastKey",
		"VK_DELETE",
		"lastAscii",
		"VK_NUMPAD0",
		"lastKey",
		"lastKey",
		"VK_DIVIDE",
		"lastKey",
		"lastAscii",
		"lastKey",
		"lastKey",
		"VK_CANCEL",
		"lastVirtual",
		"VK_CANCEL",
		"VK_CONTROL",
		"VK_SHIFT",
		"lastAscii",
		"lastAscii",
		"lastAscii",
		"lastAscii",
		"lastAscii",
		"lastAscii",
		"lastAscii",
		"KeyDown",
		"WM_KEYDOWN",
		"ONE",
		"display",
		"IsWinCE",
		"VK_APP1",
		"VK_APP6",
		"lastKey",
		"lastAscii",
		"lastVirtual",
		"lastNull",
		"lastDead",
		"detail",
		"VK_APP1",
		"HardKeyUp",
		"HardKeyDown",
		"KeyUp",
		"KeyUp",
		"lastKey",
		"lastAscii",
		"lastVirtual",
		"lastNull",
		"lastDead",
		"IsWinCE",
		"VK_BACK",
		"BS",
		"VK_RETURN",
		"CR",
		"VK_DELETE",
		"DEL",
		"VK_ESCAPE",
		"ESC",
		"VK_TAB",
		"TAB",
		"IsWinNT",
		"lastDead",
		"lastVirtual",
		"lastVirtual",
		"lastKey",
		"VK_CANCEL",
		"lastVirtual",
		"lastKey",
		"lastAscii",
		"lastNull",
		"lastDead",
		"KeyUp",
		"WM_KEYUP",
		"ONE",
		"lastKey",
		"lastAscii",
		"lastVirtual",
		"lastNull",
		"lastDead",
		"WM_KILLFOCUS",
		"FocusOut",
		"ZERO",
		"ZERO",
		"MouseDown",
		"WM_LBUTTONDOWN",
		"MouseDoubleClick",
		"WM_LBUTTONDBLCLK",
		"WM_LBUTTONDBLCLK",
		"DragDetect",
		"IsWinCE",
		"x",
		"y",
		"VK_LBUTTON",
		"MouseDown",
		"WM_LBUTTONDOWN",
		"WM_LBUTTONDOWN",
		"IsPPC",
		"MenuDetect",
		"cbSize",
		"sizeof",
		"hwndClient",
		"ptDown_x",
		"ptDown_y",
		"dwFlags",
		"SHRG_RETURNCMD",
		"GN_CONTEXTMENU",
		"x",
		"y",
		"DragDetect",
		"VK_ESCAPE",
		"WM_LBUTTONUP",
		"MouseUp",
		"WM_LBUTTONUP",
		"WM_LBUTTONUP",
		"MK_LBUTTON",
		"MK_MBUTTON",
		"MK_RBUTTON",
		"MK_XBUTTON1",
		"MK_XBUTTON2",
		"MouseDown",
		"WM_MBUTTONDOWN",
		"MouseDoubleClick",
		"WM_MBUTTONDBLCLK",
		"WM_MBUTTONDBLCLK",
		"MouseDown",
		"WM_MBUTTONDOWN",
		"WM_MBUTTONDOWN",
		"MouseUp",
		"WM_MBUTTONUP",
		"WM_MBUTTONUP",
		"MK_LBUTTON",
		"MK_MBUTTON",
		"MK_RBUTTON",
		"MK_XBUTTON1",
		"MK_XBUTTON2",
		"MouseHover",
		"WM_MOUSEHOVER",
		"MouseExit",
		"MouseExit",
		"x",
		"y",
		"x",
		"y",
		"MouseExit",
		"WM_MOUSELEAVE",
		"lastMouse",
		"captureChanged",
		"IsWinCE",
		"MouseEnter",
		"MouseEnter",
		"MouseExit",
		"MouseExit",
		"MouseHover",
		"MouseHover",
		"cbSize",
		"sizeof",
		"dwFlags",
		"TME_QUERY",
		"hwndTrack",
		"dwFlags",
		"dwFlags",
		"TME_LEAVE",
		"TME_HOVER",
		"hwndTrack",
		"PM_REMOVE",
		"PM_NOYIELD",
		"PM_QS_INPUT",
		"PM_QS_POSTMESSAGE",
		"WM_MOUSELEAVE",
		"WM_MOUSELEAVE",
		"MouseEnter",
		"WM_MOUSEMOVE",
		"dwFlags",
		"TME_HOVER",
		"lastMouse",
		"lastMouse",
		"MouseMove",
		"WM_MOUSEMOVE",
		"captureChanged",
		"MouseWheel",
		"MouseWheel",
		"SPI_GETWHEELSCROLLLINES",
		"WHEEL_PAGESCROLL",
		"SCROLL_PAGE",
		"WHEEL_DELTA",
		"SCROLL_LINE",
		"WHEEL_DELTA",
		"x",
		"y",
		"x",
		"y",
		"MouseWheel",
		"WM_MOUSEWHEEL",
		"ZERO",
		"Paint",
		"Paint",
		"IsWinCE",
		"WM_PAINT",
		"ps",
		"hwnd",
		"right",
		"left",
		"bottom",
		"top",
		"gc",
		"x",
		"left",
		"y",
		"top",
		"width",
		"height",
		"Paint",
		"gc",
		"WM_PAINT",
		"hwnd",
		"right",
		"left",
		"bottom",
		"top",
		"handle",
		"gc",
		"x",
		"left",
		"y",
		"top",
		"width",
		"height",
		"Paint",
		"gc",
		"ZERO",
		"MouseDown",
		"WM_RBUTTONDOWN",
		"MouseDoubleClick",
		"WM_RBUTTONDBLCLK",
		"WM_RBUTTONDBLCLK",
		"MouseDown",
		"WM_RBUTTONDOWN",
		"WM_RBUTTONDOWN",
		"MouseUp",
		"WM_RBUTTONUP",
		"WM_RBUTTONUP",
		"MK_LBUTTON",
		"MK_MBUTTON",
		"MK_RBUTTON",
		"MK_XBUTTON1",
		"MK_XBUTTON2",
		"WM_SETFOCUS",
		"FocusIn",
		"ZERO",
		"ZERO",
		"display",
		"lastAscii",
		"lastNull",
		"KeyDown",
		"KeyDown",
		"mnemonicKeyHit",
		"mnemonicKeyHit",
		"WM_SYSCHAR",
		"mnemonicKeyHit",
		"KeyDown",
		"WM_SYSCHAR",
		"mnemonicKeyHit",
		"mnemonicKeyHit",
		"ONE",
		"VK_F10",
		"VK_F4",
		"VK_SHIFT",
		"VK_MENU",
		"VK_CONTROL",
		"VK_CAPITAL",
		"VK_NUMLOCK",
		"VK_SCROLL",
		"lastAscii",
		"lastKey",
		"lastVirtual",
		"lastNull",
		"lastDead",
		"IsWinCE",
		"VK_BACK",
		"BS",
		"VK_RETURN",
		"CR",
		"VK_DELETE",
		"DEL",
		"VK_ESCAPE",
		"ESC",
		"VK_TAB",
		"TAB",
		"lastVirtual",
		"lastVirtual",
		"lastKey",
		"lastKey",
		"VK_DELETE",
		"lastAscii",
		"VK_NUMPAD0",
		"lastKey",
		"lastKey",
		"VK_DIVIDE",
		"lastAscii",
		"lastKey",
		"lastKey",
		"IsWinNT",
		"VK_RETURN",
		"lastAscii",
		"KeyDown",
		"WM_SYSKEYDOWN",
		"ONE",
		"XBUTTON1",
		"MouseDown",
		"WM_XBUTTONDOWN",
		"MouseDoubleClick",
		"WM_XBUTTONDBLCLK",
		"WM_XBUTTONDBLCLK",
		"XBUTTON1",
		"MouseDown",
		"WM_XBUTTONDOWN",
		"WM_XBUTTONDOWN",
		"XBUTTON1",
		"MouseUp",
		"WM_XBUTTONUP",
		"WM_XBUTTONUP",
		"MK_LBUTTON",
		"MK_MBUTTON",
		"MK_RBUTTON",
		"MK_XBUTTON1",
		"MK_XBUTTON2",
		"parent",
		"style",
		"eventType",
		"listener",
		"listener",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"style",
		"int0",
		"int1",
		"int2",
		"int3",
		"int4",
		"int5",
		"parent",
		"parent",
		"hWinPosInfo",
		"hWnd",
		"hWndInsertAfter",
		"X",
		"Y",
		"cx",
		"cy",
		"uFlags",
		"code",
		"eventType",
		"id",
		"string",
		"key",
		"eventType",
		"eventType",
		"hwnd",
		"event",
		"data",
		"eventType",
		"event",
		"eventType",
		"eventType",
		"event",
		"eventType",
		"listener",
		"eventType",
		"listener",
		"listener",
		"event",
		"eventType",
		"eventType",
		"event",
		"eventType",
		"event",
		"send",
		"type",
		"msg",
		"wParam",
		"lParam",
		"type",
		"msg",
		"wParam",
		"lParam",
		"event",
		"type",
		"button",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"type",
		"button",
		"count",
		"detail",
		"send",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"data",
		"key",
		"value",
		"type",
		"event",
		"type",
		"event",
		"type",
		"wParam",
		"lParam",
		"hWnd",
		"hWndInsertAfter",
		"X",
		"Y",
		"cx",
		"cy",
		"uFlags",
		"x",
		"y",
		"hwnd",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam",
		"hwnd",
		"wParam",
		"lParam"
	],
	"extendORImplementFiles":[],
	"package":[
		"org.eclipse.swt.widgets"
	],
	"import":[
		"org.eclipse.swt.internal",
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt",
		"org.eclipse.swt.graphics",
		"org.eclipse.swt.events"
	],
	"methods":[
		"addListener",
		"addDisposeListener",
		"callWindowProc",
		"checkBits",
		"checkOrientation",
		"checkOpened",
		"checkParent",
		"checkSubclass",
		"checkWidget",
		"destroyWidget",
		"DeferWindowPos",
		"dispose",
		"error",
		"filters",
		"findItem",
		"fixMnemonic",
		"getData",
		"getData",
		"getDisplay",
		"getMenu",
		"getName",
		"getNameText",
		"getStyle",
		"hooks",
		"isDisposed",
		"isListening",
		"isValidSubclass",
		"isValidThread",
		"mapEvent",
		"new_GC",
		"notifyListeners",
		"postEvent",
		"postEvent",
		"releaseChild",
		"releaseHandle",
		"releaseResources",
		"releaseWidget",
		"removeListener",
		"removeListener",
		"removeDisposeListener",
		"sendEvent",
		"sendEvent",
		"sendEvent",
		"sendEvent",
		"sendKeyEvent",
		"sendKeyEvent",
		"sendMouseEvent",
		"sendMouseEvent",
		"setData",
		"setData",
		"sendFocusEvent",
		"setInputState",
		"setKeyState",
		"SetWindowPos",
		"showMenu",
		"toString",
		"wmCaptureChanged",
		"wmChar",
		"wmContextMenu",
		"wmIMEChar",
		"wmKeyDown",
		"wmKeyUp",
		"wmKillFocus",
		"wmLButtonDblClk",
		"wmLButtonDown",
		"wmLButtonUp",
		"wmMButtonDblClk",
		"wmMButtonDown",
		"wmMButtonUp",
		"wmMouseHover",
		"wmMouseLeave",
		"wmMouseMove",
		"wmMouseWheel",
		"wmPaint",
		"wmRButtonDblClk",
		"wmRButtonDown",
		"wmRButtonUp",
		"wmSetFocus",
		"wmSysChar",
		"wmSysKeyDown",
		"wmSysKeyUp",
		"wmXButtonDblClk",
		"wmXButtonDown",
		"wmXButtonUp",
		"VERSION",
		"println",
		"println",
		"InitCommonControls",
		"checkSubclass",
		"checkParent",
		"checkWidget",
		"error",
		"hook",
		"checkWidget",
		"error",
		"addListener",
		"checkBits",
		"error",
		"isDisposed",
		"error",
		"checkWidget",
		"checkOpened",
		"isValidSubclass",
		"error",
		"error",
		"currentThread",
		"error",
		"error",
		"releaseHandle",
		"GetWindowRect",
		"DeferWindowPos",
		"isDisposed",
		"isValidThread",
		"error",
		"releaseChild",
		"releaseWidget",
		"destroyWidget",
		"error",
		"filters",
		"length",
		"getChars",
		"length",
		"checkWidget",
		"checkWidget",
		"error",
		"equals",
		"error",
		"getName",
		"getClass",
		"lastIndexOf",
		"substring",
		"length",
		"checkWidget",
		"hooks",
		"checkWidget",
		"hooks",
		"isValidClass",
		"getClass",
		"isValidThread",
		"getDisplay",
		"checkWidget",
		"sendEvent",
		"sendEvent",
		"sendEvent",
		"releaseWidget",
		"releaseHandle",
		"sendEvent",
		"checkWidget",
		"error",
		"unhook",
		"checkWidget",
		"error",
		"unhook",
		"checkWidget",
		"error",
		"unhook",
		"filterEvent",
		"sendEvent",
		"sendEvent",
		"sendEvent",
		"filters",
		"getLastEventTime",
		"sendEvent",
		"postEvent",
		"setKeyState",
		"sendKeyEvent",
		"sendEvent",
		"isDisposed",
		"sendMouseEvent",
		"hooks",
		"filters",
		"setInputState",
		"mapEvent",
		"sendEvent",
		"isDisposed",
		"postEvent",
		"checkWidget",
		"checkWidget",
		"error",
		"equals",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"sendEvent",
		"GetKeyState",
		"GetKeyState",
		"GetKeyState",
		"GetKeyState",
		"GetKeyState",
		"GetKeyState",
		"GetKeyState",
		"GetKeyState",
		"translateKey",
		"mbcsToWcs",
		"setInputState",
		"GetWindowRect",
		"SetWindowPos",
		"sendEvent",
		"getMenu",
		"isDisposed",
		"setLocation",
		"setVisible",
		"isDisposed",
		"isValidThread",
		"getNameText",
		"getName",
		"IsDBCSLeadByte",
		"sendKeyEvent",
		"ScreenToClient",
		"GetClientRect",
		"PtInRect",
		"GetMessagePos",
		"showMenu",
		"sendKeyEvent",
		"sendKeyEvent",
		"IsDBCSLeadByte",
		"MapVirtualKey",
		"PeekMessage",
		"isDisposed",
		"numpadKey",
		"asciiKey",
		"numpadKey",
		"CharLower",
		"asciiKey",
		"GetKeyState",
		"GetKeyState",
		"shiftedKey",
		"CharLower",
		"controlKey",
		"sendKeyEvent",
		"setInputState",
		"sendEvent",
		"hooks",
		"filters",
		"MapVirtualKey",
		"numpadKey",
		"sendKeyEvent",
		"callWindowProc",
		"sendFocusEvent",
		"isDisposed",
		"sendMouseEvent",
		"sendMouseEvent",
		"callWindowProc",
		"GetCapture",
		"SetCapture",
		"hooks",
		"ClientToScreen",
		"DragDetect",
		"GetKeyState",
		"sendMouseEvent",
		"callWindowProc",
		"getMenu",
		"isDisposed",
		"hooks",
		"SHRecognizeGesture",
		"showMenu",
		"GetCapture",
		"SetCapture",
		"postEvent",
		"GetKeyState",
		"SendMessage",
		"sendMouseEvent",
		"callWindowProc",
		"GetCapture",
		"ReleaseCapture",
		"sendMouseEvent",
		"sendMouseEvent",
		"callWindowProc",
		"GetCapture",
		"SetCapture",
		"sendMouseEvent",
		"callWindowProc",
		"GetCapture",
		"SetCapture",
		"sendMouseEvent",
		"callWindowProc",
		"GetCapture",
		"ReleaseCapture",
		"sendMouseEvent",
		"hooks",
		"filters",
		"GetMessagePos",
		"ScreenToClient",
		"sendMouseEvent",
		"GetMessagePos",
		"hooks",
		"filters",
		"hooks",
		"filters",
		"hooks",
		"filters",
		"TrackMouseEvent",
		"TrackMouseEvent",
		"PeekMessage",
		"TranslateMessage",
		"DispatchMessage",
		"sendMouseEvent",
		"TrackMouseEvent",
		"sendMouseEvent",
		"hooks",
		"filters",
		"SystemParametersInfo",
		"ScreenToClient",
		"sendMouseEvent",
		"hooks",
		"filters",
		"GetUpdateRect",
		"callWindowProc",
		"HideCaret",
		"InvalidateRect",
		"ShowCaret",
		"new_GC",
		"sendEvent",
		"dispose",
		"CreateRectRgn",
		"GetUpdateRgn",
		"callWindowProc",
		"new_GC",
		"HideCaret",
		"GetRgnBox",
		"SelectClipRgn",
		"SetMetaRgn",
		"sendEvent",
		"dispose",
		"ShowCaret",
		"DeleteObject",
		"sendMouseEvent",
		"sendMouseEvent",
		"callWindowProc",
		"GetCapture",
		"SetCapture",
		"sendMouseEvent",
		"callWindowProc",
		"GetCapture",
		"SetCapture",
		"sendMouseEvent",
		"callWindowProc",
		"GetCapture",
		"ReleaseCapture",
		"callWindowProc",
		"sendFocusEvent",
		"isDisposed",
		"hooks",
		"filters",
		"callWindowProc",
		"sendKeyEvent",
		"MapVirtualKey",
		"numpadKey",
		"numpadKey",
		"CharLower",
		"sendKeyEvent",
		"wmKeyUp",
		"sendMouseEvent",
		"sendMouseEvent",
		"callWindowProc",
		"GetCapture",
		"SetCapture",
		"sendMouseEvent",
		"callWindowProc",
		"GetCapture",
		"SetCapture",
		"sendMouseEvent",
		"callWindowProc",
		"GetCapture",
		"ReleaseCapture",
		"EventTable",
		"TypedListener",
		"RECT",
		"Event",
		"Event",
		"Event",
		"Event",
		"RECT",
		"Event",
		"POINT",
		"RECT",
		"MSG",
		"Event",
		"LRESULT",
		"LRESULT",
		"POINT",
		"SHRGINFO",
		"Event",
		"LRESULT",
		"LRESULT",
		"LRESULT",
		"LRESULT",
		"LRESULT",
		"POINT",
		"TRACKMOUSEEVENT",
		"MSG",
		"POINT",
		"RECT",
		"PAINTSTRUCT",
		"GCData",
		"Event",
		"GCData",
		"RECT",
		"Event",
		"LRESULT",
		"LRESULT",
		"LRESULT",
		"LRESULT",
		"LRESULT",
		"LRESULT",
		"LRESULT",
		"LRESULT",
		"LRESULT"
	],
	"methodsBody":{
		"public void removeListener(int eventType, Listener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(eventType, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notifed when an event of the given type occurs.\n*\n* @param eventType the type of event to listen for\n* @param listener the listener which should no longer be notified when the event occurs\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see Listener\n* @see #addListener\n*/\n",
			"methodName":"public void removeListener(int eventType, Listener listener)"
		},
		"LRESULT wmContextMenu(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    if (wParam != hwnd)\n        return null;\n    \n    if (OS.IsWinCE)\n        return null;\n    \n    int x = 0, y = 0;\n    if (lParam != -1) {\n        POINT pt = new POINT();\n        x = pt.x = (short) (lParam & 0xFFFF);\n        y = pt.y = (short) (lParam >> 16);\n        OS.ScreenToClient(hwnd, pt);\n        RECT rect = new RECT();\n        OS.GetClientRect(hwnd, rect);\n        if (!OS.PtInRect(rect, pt))\n            return null;\n    } else {\n        int pos = OS.GetMessagePos();\n        x = (short) (pos & 0xFFFF);\n        y = (short) (pos >> 16);\n    }\n    \n    return showMenu(x, y) ? LRESULT.ZERO : null;\n}",
			"comments":"/*\n* Feature in Windows.  SHRecognizeGesture() sends an undocumented\n* WM_CONTEXTMENU notification when the flag SHRG_NOTIFY_PARENT is\n* not set.  This causes the context menu to be displayed twice,\n* once by the caller of SHRecognizeGesture() and once from this\n* method.  The fix is to ignore WM_CONTEXTMENU notifications on\n* all WinCE platforms.\n*\n* NOTE: This only happens on WM2003.  Previous WinCE versions did\n* not support WM_CONTEXTMENU.\n*/\n/*\n* Feature in Windows.  When the user presses  WM_NCRBUTTONUP,\n* a WM_CONTEXTMENU message is generated.  This happens when\n* the user releases the mouse over a scroll bar.  Normally,\n* window displays the default scrolling menu but applications\n* can process WM_CONTEXTMENU to display a different menu.\n* Typically, an application does not want to supply a special\n* scroll menu.  The fix is to look for a WM_CONTEXTMENU that\n* originated from a mouse event and display the menu when the\n* mouse was released in the client area.\n*/\n/* Show the menu */\n",
			"methodName":"LRESULT wmContextMenu(int hwnd, int wParam, int lParam)"
		},
		"String getName()":{
			"methodBody":"{\n    String string = getClass().getName();\n    int index = string.lastIndexOf('.');\n    if (index == -1)\n        return string;\n    return string.substring(index + 1, string.length());\n}",
			"comments":"/**\n* Returns the name of the widget. This is the name of\n* the class without the package name.\n*\n* @return the name of the widget\n*/\n",
			"methodName":"String getName()"
		},
		"protected void checkWidget()":{
			"methodBody":"{\n    Display display = this.display;\n    if (display == null)\n        error(SWT.ERROR_WIDGET_DISPOSED);\n    if (display.thread != Thread.currentThread())\n        error(SWT.ERROR_THREAD_INVALID_ACCESS);\n    if ((state & DISPOSED) != 0)\n        error(SWT.ERROR_WIDGET_DISPOSED);\n}",
			"comments":"/**\n* Throws an <code>SWTException</code> if the receiver can not\n* be accessed by the caller. This may include both checks on\n* the state of the receiver and more generally on the entire\n* execution context. This method <em>should</em> be called by\n* widget implementors to enforce the standard SWT invariants.\n* <p>\n* Currently, it is an error to invoke any method (other than\n* <code>isDisposed()</code>) on a widget that has had its\n* <code>dispose()</code> method called. It is also an error\n* to call widget methods from any thread that is different\n* from the thread that created the widget.\n* </p><p>\n* In future releases of SWT, there may be more or fewer error\n* checks and exceptions may be thrown for different reasons.\n* </p>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"protected void checkWidget()"
		},
		"void mapEvent(int hwnd, Event event)":{
			"methodBody":"{\n}",
			"comments":"",
			"methodName":"void mapEvent(int hwnd, Event event)"
		},
		"boolean setInputState(Event event, int type)":{
			"methodBody":"{\n    if (OS.GetKeyState(OS.VK_MENU) < 0)\n        event.stateMask |= SWT.ALT;\n    if (OS.GetKeyState(OS.VK_SHIFT) < 0)\n        event.stateMask |= SWT.SHIFT;\n    if (OS.GetKeyState(OS.VK_CONTROL) < 0)\n        event.stateMask |= SWT.CONTROL;\n    if (OS.GetKeyState(OS.VK_LBUTTON) < 0)\n        event.stateMask |= SWT.BUTTON1;\n    if (OS.GetKeyState(OS.VK_MBUTTON) < 0)\n        event.stateMask |= SWT.BUTTON2;\n    if (OS.GetKeyState(OS.VK_RBUTTON) < 0)\n        event.stateMask |= SWT.BUTTON3;\n    if (OS.GetKeyState(OS.VK_XBUTTON1) < 0)\n        event.stateMask |= SWT.BUTTON4;\n    if (OS.GetKeyState(OS.VK_XBUTTON2) < 0)\n        event.stateMask |= SWT.BUTTON5;\n    switch(type) {\n        case SWT.MouseDown:\n        case SWT.MouseDoubleClick:\n            if (event.button == 1)\n                event.stateMask &= ~SWT.BUTTON1;\n            if (event.button == 2)\n                event.stateMask &= ~SWT.BUTTON2;\n            if (event.button == 3)\n                event.stateMask &= ~SWT.BUTTON3;\n            if (event.button == 4)\n                event.stateMask &= ~SWT.BUTTON4;\n            if (event.button == 5)\n                event.stateMask &= ~SWT.BUTTON5;\n            break;\n        case SWT.MouseUp:\n            if (event.button == 1)\n                event.stateMask |= SWT.BUTTON1;\n            if (event.button == 2)\n                event.stateMask |= SWT.BUTTON2;\n            if (event.button == 3)\n                event.stateMask |= SWT.BUTTON3;\n            if (event.button == 4)\n                event.stateMask |= SWT.BUTTON4;\n            if (event.button == 5)\n                event.stateMask |= SWT.BUTTON5;\n            break;\n        case SWT.KeyDown:\n        case SWT.Traverse:\n            if (event.keyCode == SWT.ALT)\n                event.stateMask &= ~SWT.ALT;\n            if (event.keyCode == SWT.SHIFT)\n                event.stateMask &= ~SWT.SHIFT;\n            if (event.keyCode == SWT.CONTROL)\n                event.stateMask &= ~SWT.CONTROL;\n            break;\n        case SWT.KeyUp:\n            if (event.keyCode == SWT.ALT)\n                event.stateMask |= SWT.ALT;\n            if (event.keyCode == SWT.SHIFT)\n                event.stateMask |= SWT.SHIFT;\n            if (event.keyCode == SWT.CONTROL)\n                event.stateMask |= SWT.CONTROL;\n            break;\n    }\n    return true;\n}",
			"comments":"",
			"methodName":"boolean setInputState(Event event, int type)"
		},
		"protected void checkSubclass()":{
			"methodBody":"{\n    if (!isValidSubclass())\n        error(SWT.ERROR_INVALID_SUBCLASS);\n}",
			"comments":"/**\n* Checks that this class can be subclassed.\n* <p>\n* The SWT class library is intended to be subclassed\n* only at specific, controlled points (most notably,\n* <code>Composite</code> and <code>Canvas</code> when\n* implementing new widgets). This method enforces this\n* rule unless it is overridden.\n* </p><p>\n* <em>IMPORTANT:</em> By providing an implementation of this\n* method that allows a subclass of a class which does not\n* normally allow subclassing to be created, the implementer\n* agrees to be fully responsible for the fact that any such\n* subclass will likely fail between SWT releases and will be\n* strongly platform specific. No support is provided for\n* user-written classes which are implemented in this fashion.\n* </p><p>\n* The ability to subclass outside of the allowed SWT classes\n* is intended purely to enable those not on the SWT development\n* team to implement patches in order to get around specific\n* limitations in advance of when those limitations can be\n* addressed by the team. Subclassing should not be attempted\n* without an intimate and detailed understanding of the hierarchy.\n* </p>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_INVALID_SUBCLASS - if this class is not an allowed subclass</li>\n* </ul>\n*/\n",
			"methodName":"protected void checkSubclass()"
		},
		"char[] fixMnemonic(String string)":{
			"methodBody":"{\n    char[] buffer = new char[string.length()];\n    string.getChars(0, string.length(), buffer, 0);\n    int i = 0, j = 0;\n    while (i < buffer.length) {\n        if (buffer[i] == '&') {\n            if (i + 1 < buffer.length && buffer[i + 1] == '&') {\n                buffer[j++] = ' ';\n                i++;\n            }\n            i++;\n        } else {\n            buffer[j++] = buffer[i++];\n        }\n    }\n    while (j < buffer.length) buffer[j++] = 0;\n    return buffer;\n}",
			"comments":"",
			"methodName":"char[] fixMnemonic(String string)"
		},
		"LRESULT wmMouseHover(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    sendMouseEvent(SWT.MouseHover, 0, hwnd, OS.WM_MOUSEHOVER, wParam, lParam);\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT wmMouseHover(int hwnd, int wParam, int lParam)"
		},
		"LRESULT wmRButtonDown(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    sendMouseEvent(SWT.MouseDown, 3, hwnd, OS.WM_RBUTTONDOWN, wParam, lParam);\n    int result = callWindowProc(hwnd, OS.WM_RBUTTONDOWN, wParam, lParam);\n    if (OS.GetCapture() != hwnd)\n        OS.SetCapture(hwnd);\n    return new LRESULT(result);\n}",
			"comments":"",
			"methodName":"LRESULT wmRButtonDown(int hwnd, int wParam, int lParam)"
		},
		"LRESULT wmMButtonDown(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    sendMouseEvent(SWT.MouseDown, 2, hwnd, OS.WM_MBUTTONDOWN, wParam, lParam);\n    int result = callWindowProc(hwnd, OS.WM_MBUTTONDOWN, wParam, lParam);\n    if (OS.GetCapture() != hwnd)\n        OS.SetCapture(hwnd);\n    return new LRESULT(result);\n}",
			"comments":"",
			"methodName":"LRESULT wmMButtonDown(int hwnd, int wParam, int lParam)"
		},
		"boolean hooks(int eventType)":{
			"methodBody":"{\n    if (eventTable == null)\n        return false;\n    return eventTable.hooks(eventType);\n}",
			"comments":"/*\n* Returns <code>true</code> if the specified eventType is\n* hooked, and <code>false</code> otherwise. Implementations\n* of SWT can avoid creating objects and sending events\n* when an event happens in the operating system but\n* there are no listeners hooked for the event.\n*\n* @param eventType the event to be checked\n*\n* @return <code>true</code> when the eventType is hooked and <code>false</code> otherwise\n*\n* @see #isListening\n*/\n",
			"methodName":"boolean hooks(int eventType)"
		},
		"void postEvent(int eventType)":{
			"methodBody":"{\n    sendEvent(eventType, null, false);\n}",
			"comments":"",
			"methodName":"void postEvent(int eventType)"
		},
		"boolean isValidSubclass()":{
			"methodBody":"{\n    return Display.isValidClass(getClass());\n}",
			"comments":"/*\n* Returns <code>true</code> when subclassing is\n* allowed and <code>false</code> otherwise\n*\n* @return <code>true</code> when subclassing is allowed and <code>false</code> otherwise\n*/\n",
			"methodName":"boolean isValidSubclass()"
		},
		"void postEvent(int eventType, Event event)":{
			"methodBody":"{\n    sendEvent(eventType, event, false);\n}",
			"comments":"",
			"methodName":"void postEvent(int eventType, Event event)"
		},
		"LRESULT wmRButtonDblClk(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    \n    sendMouseEvent(SWT.MouseDown, 3, hwnd, OS.WM_RBUTTONDOWN, wParam, lParam);\n    sendMouseEvent(SWT.MouseDoubleClick, 3, hwnd, OS.WM_RBUTTONDBLCLK, wParam, lParam);\n    int result = callWindowProc(hwnd, OS.WM_RBUTTONDBLCLK, wParam, lParam);\n    if (OS.GetCapture() != hwnd)\n        OS.SetCapture(hwnd);\n    return new LRESULT(result);\n}",
			"comments":"/*\n* Feature in Windows. Windows sends the following\n* messages when the user double clicks the mouse:\n*\n*\tWM_RBUTTONDOWN\t\t- mouse down\n*\tWM_RBUTTONUP\t\t- mouse up\n*\tWM_RBUTTONDBLCLK\t- double click\n*\tWM_LBUTTONUP\t\t- mouse up\n*\n* Applications that expect matching mouse down/up\n* pairs will not see the second mouse down.  The\n* fix is to send a mouse down event.\n*/\n",
			"methodName":"LRESULT wmRButtonDblClk(int hwnd, int wParam, int lParam)"
		},
		"LRESULT wmMouseLeave(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    if (!hooks(SWT.MouseExit) && !filters(SWT.MouseExit))\n        return null;\n    int pos = OS.GetMessagePos();\n    POINT pt = new POINT();\n    pt.x = (short) (pos & 0xFFFF);\n    pt.y = (short) (pos >> 16);\n    OS.ScreenToClient(hwnd, pt);\n    lParam = pt.x | (pt.y << 16);\n    sendMouseEvent(SWT.MouseExit, 0, hwnd, OS.WM_MOUSELEAVE, wParam, lParam);\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT wmMouseLeave(int hwnd, int wParam, int lParam)"
		},
		"void sendEvent(Event event)":{
			"methodBody":"{\n    Display display = event.display;\n    if (!display.filterEvent(event)) {\n        if (eventTable != null)\n            eventTable.sendEvent(event);\n    }\n}",
			"comments":"",
			"methodName":"void sendEvent(Event event)"
		},
		"GC new_GC(GCData data)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"GC new_GC(GCData data)"
		},
		"boolean showMenu(int x, int y)":{
			"methodBody":"{\n    Event event = new Event();\n    event.x = x;\n    event.y = y;\n    sendEvent(SWT.MenuDetect, event);\n    if (!event.doit)\n        return true;\n    Menu menu = getMenu();\n    if (menu != null && !menu.isDisposed()) {\n        if (x != event.x || y != event.y) {\n            menu.setLocation(event.x, event.y);\n        }\n        menu.setVisible(true);\n        return true;\n    }\n    return false;\n}",
			"comments":"",
			"methodName":"boolean showMenu(int x, int y)"
		},
		"LRESULT wmSysChar(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    Display display = this.display;\n    display.lastAscii = wParam;\n    display.lastNull = wParam == 0;\n    \n    if (!hooks(SWT.KeyDown) && !display.filters(SWT.KeyDown)) {\n        return null;\n    }\n    \n    boolean oldKeyHit = display.mnemonicKeyHit;\n    display.mnemonicKeyHit = true;\n    int result = callWindowProc(hwnd, OS.WM_SYSCHAR, wParam, lParam);\n    boolean consumed = false;\n    if (!display.mnemonicKeyHit) {\n        consumed = !sendKeyEvent(SWT.KeyDown, OS.WM_SYSCHAR, wParam, lParam);\n    \n    }\n    consumed |= display.mnemonicKeyHit;\n    display.mnemonicKeyHit = oldKeyHit;\n    return consumed ? LRESULT.ONE : new LRESULT(result);\n}",
			"comments":"/* Do not issue a key down if a menu bar mnemonic was invoked */\n/* Call the window proc to determine whether it is a system key or mnemonic */\n// widget could be disposed at this point\n",
			"methodName":"LRESULT wmSysChar(int hwnd, int wParam, int lParam)"
		},
		"public void setData(String key, Object value)":{
			"methodBody":"{\n    checkWidget();\n    if (key == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    int index = 1;\n    Object[] table = null;\n    if ((state & KEYED_DATA) != 0) {\n        table = (Object[]) data;\n        while (index < table.length) {\n            if (key.equals(table[index]))\n                break;\n            index += 2;\n        }\n    }\n    if (value != null) {\n        if ((state & KEYED_DATA) != 0) {\n            if (index == table.length) {\n                Object[] newTable = new Object[table.length + 2];\n                System.arraycopy(table, 0, newTable, 0, table.length);\n                data = table = newTable;\n            }\n        } else {\n            table = new Object[3];\n            table[0] = data;\n            data = table;\n            state |= KEYED_DATA;\n        }\n        table[index] = key;\n        table[index + 1] = value;\n    } else {\n        if ((state & KEYED_DATA) != 0) {\n            if (index != table.length) {\n                int length = table.length - 2;\n                if (length == 1) {\n                    data = table[0];\n                    state &= ~KEYED_DATA;\n                } else {\n                    Object[] newTable = new Object[length];\n                    System.arraycopy(table, 0, newTable, 0, index);\n                    System.arraycopy(table, index + 2, newTable, index, length - index);\n                    data = newTable;\n                }\n            }\n        }\n    }\n}",
			"comments":"/**\n* Sets the application defined property of the receiver\n* with the specified name to the given value.\n* <p>\n* Applications may associate arbitrary objects with the\n* receiver in this fashion. If the objects stored in the\n* properties need to be notified when the widget is disposed\n* of, it is the application's responsibility to hook the\n* Dispose event on the widget and do so.\n* </p>\n*\n* @param key the name of the property\n* @param value the new value for the property\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the key is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #getData(String)\n*/\n",
			"methodName":"public void setData(String key, Object value)"
		},
		"LRESULT wmKeyDown(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    \n    switch(wParam) {\n        case OS.VK_SHIFT:\n        case OS.VK_MENU:\n        case OS.VK_CONTROL:\n        case OS.VK_CAPITAL:\n        case OS.VK_NUMLOCK:\n        case OS.VK_SCROLL:\n            if ((lParam & 0x40000000) != 0)\n                return null;\n    }\n    \n    display.lastAscii = display.lastKey = 0;\n    display.lastVirtual = display.lastNull = display.lastDead = false;\n    \n    if (!OS.IsUnicode && OS.IsDBLocale) {\n        byte lead = (byte) (wParam & 0xFF);\n        if (OS.IsDBCSLeadByte(lead))\n            return null;\n    }\n    \n    \n    int mapKey = 0;\n    if (OS.IsWinCE) {\n        switch(wParam) {\n            case OS.VK_BACK:\n                mapKey = SWT.BS;\n                break;\n            case OS.VK_RETURN:\n                mapKey = SWT.CR;\n                break;\n            case OS.VK_DELETE:\n                mapKey = SWT.DEL;\n                break;\n            case OS.VK_ESCAPE:\n                mapKey = SWT.ESC;\n                break;\n            case OS.VK_TAB:\n                mapKey = SWT.TAB;\n                break;\n        }\n    } else {\n        mapKey = OS.MapVirtualKey(wParam, 2);\n    }\n    \n    if (OS.IsWinNT) {\n        if ((mapKey & 0x80000000) != 0)\n            return null;\n    } else {\n        if ((mapKey & 0x8000) != 0)\n            return null;\n    }\n    MSG msg = new MSG();\n    int flags = OS.PM_NOREMOVE | OS.PM_NOYIELD | OS.PM_QS_INPUT | OS.PM_QS_POSTMESSAGE;\n    if (OS.PeekMessage(msg, hwnd, OS.WM_DEADCHAR, OS.WM_DEADCHAR, flags)) {\n        display.lastDead = true;\n        display.lastVirtual = mapKey == 0;\n        display.lastKey = display.lastVirtual ? wParam : mapKey;\n        return null;\n    }\n    \n    if (isDisposed())\n        return LRESULT.ONE;\n    \n    display.lastVirtual = mapKey == 0 || display.numpadKey(wParam) != 0;\n    if (display.lastVirtual) {\n        display.lastKey = wParam;\n        \n        if (display.lastKey == OS.VK_DELETE)\n            display.lastAscii = 0x7F;\n        \n        if (OS.VK_NUMPAD0 <= display.lastKey && display.lastKey <= OS.VK_DIVIDE) {\n            \n            if (display.asciiKey(display.lastKey) != 0)\n                return null;\n            display.lastAscii = display.numpadKey(display.lastKey);\n        }\n    } else {\n        \n        display.lastKey = OS.CharLower((short) mapKey);\n        \n        if (wParam == OS.VK_CANCEL)\n            display.lastVirtual = true;\n        \n        int asciiKey = display.asciiKey(wParam);\n        if (asciiKey != 0) {\n            \n            if (asciiKey == ' ')\n                return null;\n            if (asciiKey != wParam)\n                return null;\n            \n            if (wParam == OS.VK_CANCEL)\n                return null;\n        }\n        \n        if (OS.GetKeyState(OS.VK_CONTROL) >= 0)\n            return null;\n        \n        if (OS.GetKeyState(OS.VK_SHIFT) < 0) {\n            display.lastAscii = display.shiftedKey(wParam);\n            if (display.lastAscii == 0)\n                display.lastAscii = mapKey;\n        } else {\n            display.lastAscii = OS.CharLower((short) mapKey);\n        }\n        \n        if (display.lastAscii == '@')\n            return null;\n        display.lastAscii = display.controlKey(display.lastAscii);\n    }\n    if (!sendKeyEvent(SWT.KeyDown, OS.WM_KEYDOWN, wParam, lParam)) {\n        return LRESULT.ONE;\n    }\n    \n    return null;\n}",
			"comments":"/* Ignore repeating modifier keys by testing key down state */\n/* Clear last key and last ascii because a new key has been typed */\n/*\n* Do not report a lead byte as a key pressed.\n*/\n/* Map the virtual key */\n/*\n* Bug in WinCE.  MapVirtualKey() returns incorrect values.\n* The fix is to rely on a key mappings table to determine\n* whether the key event must be sent now or if a WM_CHAR\n* event will follow.  The key mappings table maps virtual\n* keys to SWT key codes and does not contain mappings for\n* Windows virtual keys like VK_A.  Virtual keys that are\n* both virtual and ASCII are a special case.\n*/\n/*\n* Bug in Windows 95 and NT.  When the user types an accent key such\n* as ^ to get an accented character on a German keyboard, the accent\n* key should be ignored and the next key that the user types is the\n* accented key.  The fix is to detect the accent key stroke (called\n* a dead key) by testing the high bit of the value returned by\n* MapVirtualKey().  A further problem is that the high bit on\n* Windows NT is bit 32 while the high bit on Windows 95 is bit 16.\n* They should both be bit 32.\n*\n* When the user types an accent key that does not correspond to a\n* virtual key, MapVirtualKey() won't set the high bit to indicate\n* a dead key.  This happens when an accent key, such as '^' is the\n* result of a modifier such as Shift key and MapVirtualKey() always\n* returns the unshifted key.  The fix is to peek for a WM_DEADCHAR\n* and avoid issuing the event.\n*/\n/*\n*  Bug in Windows.  Somehow, the widget is becoming disposed after\n*  calling PeekMessage().  In rare cirucmstances, it seems that\n*  PeekMessage() can allow SWT listeners to run that might contain\n*  application code that disposes the widget.  It is not exactly\n*  clear how this can happen.  PeekMessage() is only looking for\n*  WM_DEADCHAR.  It is not dispatching any message that it finds\n*  or removing any message from the queue.  Cross-thread messages\n*  are disabled.  The fix is to check for a disposed widget and\n*  return without calling the window proc.\n*/\n/*\n* If we are going to get a WM_CHAR, ensure that last key has\n* the correct character value for the key down and key up\n* events.  It is not sufficient to ignore the WM_KEYDOWN\n* (when we know we are going to get a WM_CHAR) and compute\n* the key in WM_CHAR because there is not enough information\n* by the time we get the WM_CHAR.  For example, when the user\n* types Ctrl+Shift+6 on a US keyboard, we get a WM_CHAR with\n* wParam=30.  When the user types Ctrl+Shift+6 on a German\n* keyboard, we also get a WM_CHAR with wParam=30.  On the US\n* keyboard Shift+6 is ^, on the German keyboard Shift+6 is &.\n* There is no way to map wParam=30 in WM_CHAR to the correct\n* value.  Also, on international keyboards, the control key\n* may be down when the user has not entered a control character.\n*\n* NOTE: On Windows 98, keypad keys are virtual despite the\n* fact that a WM_CHAR is issued.  On Windows 2000 and XP,\n* they are not virtual.  Therefore it is necessary to force\n* numeric keypad keys to be virtual.\n*/\n/*\n* Feature in Windows.  The virtual key VK_DELETE is not\n* treated as both a virtual key and an ASCII key by Windows.\n* Therefore, we will not receive a WM_CHAR for this key.\n* The fix is to treat VK_DELETE as a special case and map\n* the ASCII value explictly (Delete is 0x7F).\n*/\n/*\n* It is possible to get a WM_CHAR for a virtual key when\n* Num Lock is on.  If the user types Home while Num Lock\n* is down, a WM_CHAR is issued with WPARM=55 (for the\n* character 7).  If we are going to get a WM_CHAR we need\n* to ensure that the last key has the correct value.  Note\n* that Ctrl+Home does not issue a WM_CHAR when Num Lock is\n* down.\n*/\n/*\n* Feature in Windows.  Calling to ToAscii() or ToUnicode(), clears\n* the accented state such that the next WM_CHAR loses the accent.\n* This makes is critical that the accent key is detected.  Also,\n* these functions clear the character that is entered using the\n* special Windows keypad sequence when NumLock is down (ie. typing\n* ALT+0231 should gives 'c' with a cedilla when NumLock is down).\n*/\n/*\n* Convert LastKey to lower case because Windows non-virtual\n* keys that are also ASCII keys, such as like VK_A, are have\n* upper case values in WM_KEYDOWN despite the fact that the\n* Shift was not pressed.\n*/\n/*\n* Feature in Windows. The virtual key VK_CANCEL is treated\n* as both a virtual key and ASCII key by Windows.  This\n* means that a WM_CHAR with WPARAM=3 will be issued for\n* this key.  In order to distinguish between this key and\n* Ctrl+C, mark the key as virtual.\n*/\n/*\n* Some key combinations map to Windows ASCII keys depending\n* on the keyboard.  For example, Ctrl+Alt+Q maps to @ on a\n* German keyboard.  If the current key combination is special,\n* the correct character is placed in wParam for processing in\n* WM_CHAR.  If this is the case, issue the key down event from\n* inside WM_CHAR.\n*/\n/*\n* When the user types Ctrl+Space, ToAscii () maps this to\n* Space.  Normally, ToAscii () maps a key to a different\n* key if both a WM_KEYDOWN and a WM_CHAR will be issued.\n* To avoid the extra SWT.KeyDown, look for a space and\n* issue the event from WM_CHAR.\n*/\n/*\n* Feature in Windows. The virtual key VK_CANCEL is treated\n* as both a virtual key and ASCII key by Windows.  This\n* means that a WM_CHAR with WPARAM=3 will be issued for\n* this key. To avoid the extra SWT.KeyDown, look for\n* VK_CANCEL and issue the event from WM_CHAR.\n*/\n/*\n* If the control key is not down at this point, then\n* the key that was pressed was an accent key or a regular\n* key such as 'A' or Shift+A.  In that case, issue the\n* key event from WM_CHAR.\n*/\n/*\n* Get the shifted state or convert to lower case if necessary.\n* If the user types Ctrl+A, LastAscii should be 'a', not 'A'.\n* If the user types Ctrl+Shift+A, LastAscii should be 'A'.\n* If the user types Ctrl+Shift+6, the value of LastAscii will\n* depend on the international keyboard.\n*/\n/* Note that Ctrl+'@' is ASCII NUL and is delivered in WM_CHAR */\n// widget could be disposed at this point\n",
			"methodName":"LRESULT wmKeyDown(int hwnd, int wParam, int lParam)"
		},
		"boolean filters(int eventType)":{
			"methodBody":"{\n    return display.filters(eventType);\n}",
			"comments":"",
			"methodName":"boolean filters(int eventType)"
		},
		"void destroyWidget()":{
			"methodBody":"{\n    releaseHandle();\n}",
			"comments":"/**\n* Destroys the widget in the operating system and releases\n* the widget's handle.  If the widget does not have a handle,\n* this method may hide the widget, mark the widget as destroyed\n* or do nothing, depending on the widget.\n* <p>\n* When a widget is destroyed in the operating system, its\n* descendents are also destroyed by the operating system.\n* This means that it is only necessary to call <code>destroyWidget</code>\n* on the root of the widget tree.\n* </p><p>\n* This method is called after <code>releaseWidget</code>.\n* </p>\n* @see #dispose\n* @see #releaseChild\n* @see #releaseWidget\n* @see #releaseHandle\n*/\n",
			"methodName":"void destroyWidget()"
		},
		"static int checkBits(int style, int int0, int int1, int int2, int int3, int int4, int int5)":{
			"methodBody":"{\n    int mask = int0 | int1 | int2 | int3 | int4 | int5;\n    if ((style & mask) == 0)\n        style |= int0;\n    if ((style & int0) != 0)\n        style = (style & ~mask) | int0;\n    if ((style & int1) != 0)\n        style = (style & ~mask) | int1;\n    if ((style & int2) != 0)\n        style = (style & ~mask) | int2;\n    if ((style & int3) != 0)\n        style = (style & ~mask) | int3;\n    if ((style & int4) != 0)\n        style = (style & ~mask) | int4;\n    if ((style & int5) != 0)\n        style = (style & ~mask) | int5;\n    return style;\n}",
			"comments":"/**\n* Returns a style with exactly one style bit set out of\n* the specified set of exclusive style bits. All other\n* possible bits are cleared when the first matching bit\n* is found. Bits that are not part of the possible set\n* are untouched.\n*\n* @param style the original style bits\n* @param int0 the 0th possible style bit\n* @param int1 the 1st possible style bit\n* @param int2 the 2nd possible style bit\n* @param int3 the 3rd possible style bit\n* @param int4 the 4th possible style bit\n* @param int5 the 5th possible style bit\n*\n* @return the new style bits\n*/\n",
			"methodName":"static int checkBits(int style, int int0, int int1, int int2, int int3, int int4, int int5)"
		},
		"LRESULT wmXButtonUp(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    int button = (wParam >> 16 == OS.XBUTTON1) ? 4 : 5;\n    sendMouseEvent(SWT.MouseUp, button, hwnd, OS.WM_XBUTTONUP, wParam, lParam);\n    int result = callWindowProc(hwnd, OS.WM_XBUTTONUP, wParam, lParam);\n    int mask = OS.MK_LBUTTON | OS.MK_MBUTTON | OS.MK_RBUTTON | OS.MK_XBUTTON1 | OS.MK_XBUTTON2;\n    if (((wParam & 0xFFFF) & mask) == 0) {\n        if (OS.GetCapture() == hwnd)\n            OS.ReleaseCapture();\n    }\n    return new LRESULT(result);\n}",
			"comments":"",
			"methodName":"LRESULT wmXButtonUp(int hwnd, int wParam, int lParam)"
		},
		"void sendEvent(int eventType)":{
			"methodBody":"{\n    sendEvent(eventType, null, true);\n}",
			"comments":"",
			"methodName":"void sendEvent(int eventType)"
		},
		"LRESULT wmMouseMove(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    int pos = OS.GetMessagePos();\n    if (pos != display.lastMouse || display.captureChanged) {\n        if (!OS.IsWinCE) {\n            boolean mouseEnter = hooks(SWT.MouseEnter) || display.filters(SWT.MouseEnter);\n            boolean mouseExit = hooks(SWT.MouseExit) || display.filters(SWT.MouseExit);\n            boolean mouseHover = hooks(SWT.MouseHover) || display.filters(SWT.MouseHover);\n            if (mouseEnter || mouseExit || mouseHover) {\n                TRACKMOUSEEVENT lpEventTrack = new TRACKMOUSEEVENT();\n                lpEventTrack.cbSize = TRACKMOUSEEVENT.sizeof;\n                lpEventTrack.dwFlags = OS.TME_QUERY;\n                lpEventTrack.hwndTrack = hwnd;\n                OS.TrackMouseEvent(lpEventTrack);\n                if (lpEventTrack.dwFlags == 0) {\n                    lpEventTrack.dwFlags = OS.TME_LEAVE | OS.TME_HOVER;\n                    lpEventTrack.hwndTrack = hwnd;\n                    OS.TrackMouseEvent(lpEventTrack);\n                    if (mouseEnter) {\n                        \n                        MSG msg = new MSG();\n                        int flags = OS.PM_REMOVE | OS.PM_NOYIELD | OS.PM_QS_INPUT | OS.PM_QS_POSTMESSAGE;\n                        while (OS.PeekMessage(msg, 0, OS.WM_MOUSELEAVE, OS.WM_MOUSELEAVE, flags)) {\n                            OS.TranslateMessage(msg);\n                            OS.DispatchMessage(msg);\n                        }\n                        sendMouseEvent(SWT.MouseEnter, 0, hwnd, OS.WM_MOUSEMOVE, wParam, lParam);\n                    }\n                } else {\n                    lpEventTrack.dwFlags = OS.TME_HOVER;\n                    OS.TrackMouseEvent(lpEventTrack);\n                }\n            }\n        }\n        if (pos != display.lastMouse) {\n            display.lastMouse = pos;\n            sendMouseEvent(SWT.MouseMove, 0, hwnd, OS.WM_MOUSEMOVE, wParam, lParam);\n        }\n    }\n    display.captureChanged = false;\n    return null;\n}",
			"comments":"/*\n* Force all outstanding WM_MOUSELEAVE messages to be dispatched before\n* issuing a mouse enter.  This causes mouse exit events to be processed\n* before mouse enter events.  Note that WM_MOUSELEAVE is posted to the\n* event queue by TrackMouseEvent().\n*/\n",
			"methodName":"LRESULT wmMouseMove(int hwnd, int wParam, int lParam)"
		},
		"public int getStyle()":{
			"methodBody":"{\n    checkWidget();\n    return style;\n}",
			"comments":"/**\n* Returns the receiver's style information.\n* <p>\n* Note that the value which is returned by this method <em>may\n* not match</em> the value which was provided to the constructor\n* when the receiver was created. This can occur when the underlying\n* operating system does not support a particular combination of\n* requested styles. For example, if the platform widget used to\n* implement a particular SWT widget always has scroll bars, the\n* result of calling this method would always have the\n* <code>SWT.H_SCROLL</code> and <code>SWT.V_SCROLL</code> bits set.\n* </p>\n*\n* @return the style bits\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public int getStyle()"
		},
		"String getNameText()":{
			"methodBody":"{\n    \n    return \"\";\n}",
			"comments":"/*\n* Returns a short printable representation for the contents\n* of a widget. For example, a button may answer the label\n* text. This is used by <code>toString</code> to provide a\n* more meaningful description of the widget.\n*\n* @return the contents string for the widget\n*\n* @see #toString\n*/\n//$NON-NLS-1$\n",
			"methodName":"String getNameText()"
		},
		"LRESULT wmLButtonDown(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    boolean dragging = false, mouseDown = true;\n    boolean dragDetect = hooks(SWT.DragDetect);\n    if (dragDetect) {\n        if (!OS.IsWinCE) {\n            \n            POINT pt = new POINT();\n            pt.x = (short) (lParam & 0xFFFF);\n            pt.y = (short) (lParam >> 16);\n            OS.ClientToScreen(hwnd, pt);\n            dragging = OS.DragDetect(hwnd, pt);\n            mouseDown = OS.GetKeyState(OS.VK_LBUTTON) < 0;\n        }\n    }\n    sendMouseEvent(SWT.MouseDown, 1, hwnd, OS.WM_LBUTTONDOWN, wParam, lParam);\n    int result = callWindowProc(hwnd, OS.WM_LBUTTONDOWN, wParam, lParam);\n    if (OS.IsPPC) {\n        \n        Menu menu = getMenu();\n        boolean hasMenu = menu != null && !menu.isDisposed();\n        if (hasMenu || hooks(SWT.MenuDetect)) {\n            int x = (short) (lParam & 0xFFFF);\n            int y = (short) (lParam >> 16);\n            SHRGINFO shrg = new SHRGINFO();\n            shrg.cbSize = SHRGINFO.sizeof;\n            shrg.hwndClient = hwnd;\n            shrg.ptDown_x = x;\n            shrg.ptDown_y = y;\n            shrg.dwFlags = OS.SHRG_RETURNCMD;\n            int type = OS.SHRecognizeGesture(shrg);\n            if (type == OS.GN_CONTEXTMENU)\n                showMenu(x, y);\n        }\n    }\n    if (mouseDown) {\n        if (OS.GetCapture() != hwnd)\n            OS.SetCapture(hwnd);\n    }\n    if (dragging) {\n        Event event = new Event();\n        event.x = (short) (lParam & 0xFFFF);\n        event.y = (short) (lParam >> 16);\n        postEvent(SWT.DragDetect, event);\n    } else {\n        if (dragDetect) {\n            \n            if (OS.GetKeyState(OS.VK_ESCAPE) >= 0) {\n                OS.SendMessage(hwnd, OS.WM_LBUTTONUP, wParam, lParam);\n            }\n        }\n    }\n    return new LRESULT(result);\n}",
			"comments":"/*\n* Feature in Windows.  It's possible that the drag\n* operation will not be started while the mouse is\n* down, meaning that the mouse should be captured.\n* This can happen when the user types the ESC key\n* to cancel the drag.  The fix is to query the state\n* of the mouse and capture the mouse accordingly.\n*/\n/*\n* Note: On WinCE PPC, only attempt to recognize the gesture for\n* a context menu when the control contains a valid menu or there\n* are listeners for the MenuDetect event.\n*/\n/*\n* Feature in Windows.  DragDetect() captures the mouse\n* and tracks its movement until the user releases the\n* left mouse button, presses the ESC key, or moves the\n* mouse outside the drag rectangle.  If the user moves\n* the mouse outside of the drag rectangle, DragDetect()\n* returns true and a drag and drop operation can be\n* started.  When the left mouse button is released or\n* the ESC key is pressed, these events are consumed by\n* DragDetect() so that application code that matches\n* mouse down/up pairs or looks for the ESC key will not\n* function properly.  The fix is to send the missing\n* events when the drag has not started.\n*\n* NOTE: For now, don't send a fake WM_KEYDOWN/WM_KEYUP\n* events for the ESC key.  This would require computing\n* wParam (the key) and lParam (the repeat count, scan code,\n* extended-key flag, context code, previous key-state flag,\n* and transition-state flag) which is non-trivial.\n*/\n",
			"methodName":"LRESULT wmLButtonDown(int hwnd, int wParam, int lParam)"
		},
		"LRESULT wmPaint(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    \n    if (!hooks(SWT.Paint) && !filters(SWT.Paint)) {\n        return null;\n    }\n    \n    int result = 0;\n    if (OS.IsWinCE) {\n        RECT rect = new RECT();\n        OS.GetUpdateRect(hwnd, rect, false);\n        result = callWindowProc(hwnd, OS.WM_PAINT, wParam, lParam);\n        \n        OS.HideCaret(hwnd);\n        OS.InvalidateRect(hwnd, rect, false);\n        OS.ShowCaret(hwnd);\n        PAINTSTRUCT ps = new PAINTSTRUCT();\n        GCData data = new GCData();\n        data.ps = ps;\n        data.hwnd = hwnd;\n        GC gc = new_GC(data);\n        if (gc != null) {\n            int width = ps.right - ps.left;\n            int height = ps.bottom - ps.top;\n            if (width != 0 && height != 0) {\n                Event event = new Event();\n                event.gc = gc;\n                event.x = ps.left;\n                event.y = ps.top;\n                event.width = width;\n                event.height = height;\n                sendEvent(SWT.Paint, event);\n                \n                event.gc = null;\n            }\n            gc.dispose();\n        }\n    } else {\n        int rgn = OS.CreateRectRgn(0, 0, 0, 0);\n        OS.GetUpdateRgn(hwnd, rgn, false);\n        result = callWindowProc(hwnd, OS.WM_PAINT, wParam, lParam);\n        GCData data = new GCData();\n        data.hwnd = hwnd;\n        GC gc = new_GC(data);\n        if (gc != null) {\n            OS.HideCaret(hwnd);\n            RECT rect = new RECT();\n            OS.GetRgnBox(rgn, rect);\n            int width = rect.right - rect.left;\n            int height = rect.bottom - rect.top;\n            if (width != 0 && height != 0) {\n                int hDC = gc.handle;\n                OS.SelectClipRgn(hDC, rgn);\n                OS.SetMetaRgn(hDC);\n                Event event = new Event();\n                event.gc = gc;\n                event.x = rect.left;\n                event.y = rect.top;\n                event.width = width;\n                event.height = height;\n                sendEvent(SWT.Paint, event);\n                \n                event.gc = null;\n            }\n            gc.dispose();\n            OS.ShowCaret(hwnd);\n        }\n        OS.DeleteObject(rgn);\n    }\n    if (result == 0)\n        return LRESULT.ZERO;\n    return new LRESULT(result);\n}",
			"comments":"/* Exit early - don't draw the background */\n/* Issue a paint event */\n/*\n* Bug in Windows.  When InvalidateRgn(), InvalidateRect()\n* or RedrawWindow() with RDW_INVALIDATE is called from\n* within WM_PAINT to invalidate a region for a further\n* BeginPaint(), the caret is not properly erased causing\n* pixel corruption.  The fix is to hide and show the\n* caret.\n*/\n// widget could be disposed at this point\n// widget could be disposed at this point\n",
			"methodName":"LRESULT wmPaint(int hwnd, int wParam, int lParam)"
		},
		"void checkOrientation(Widget parent)":{
			"methodBody":"{\n    style &= ~SWT.MIRRORED;\n    if ((style & (SWT.LEFT_TO_RIGHT | SWT.RIGHT_TO_LEFT)) == 0) {\n        if (parent != null) {\n            if ((parent.style & SWT.LEFT_TO_RIGHT) != 0)\n                style |= SWT.LEFT_TO_RIGHT;\n            if ((parent.style & SWT.RIGHT_TO_LEFT) != 0)\n                style |= SWT.RIGHT_TO_LEFT;\n        }\n    }\n    style = checkBits(style, SWT.LEFT_TO_RIGHT, SWT.RIGHT_TO_LEFT, 0, 0, 0, 0);\n}",
			"comments":"",
			"methodName":"void checkOrientation(Widget parent)"
		},
		"LRESULT wmXButtonDblClk(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    \n    int button = (wParam >> 16 == OS.XBUTTON1) ? 4 : 5;\n    sendMouseEvent(SWT.MouseDown, button, hwnd, OS.WM_XBUTTONDOWN, wParam, lParam);\n    sendMouseEvent(SWT.MouseDoubleClick, button, hwnd, OS.WM_XBUTTONDBLCLK, wParam, lParam);\n    int result = callWindowProc(hwnd, OS.WM_XBUTTONDBLCLK, wParam, lParam);\n    if (OS.GetCapture() != hwnd)\n        OS.SetCapture(hwnd);\n    return new LRESULT(result);\n}",
			"comments":"/*\n* Feature in Windows. Windows sends the following\n* messages when the user double clicks the mouse:\n*\n*\tWM_XBUTTONDOWN\t\t- mouse down\n*\tWM_XBUTTONUP\t\t- mouse up\n*\tWM_XLBUTTONDBLCLK\t- double click\n*\tWM_XBUTTONUP\t\t- mouse up\n*\n* Applications that expect matching mouse down/up\n* pairs will not see the second mouse down.  The\n* fix is to send a mouse down event.\n*/\n",
			"methodName":"LRESULT wmXButtonDblClk(int hwnd, int wParam, int lParam)"
		},
		"void releaseChild()":{
			"methodBody":"{\n}",
			"comments":"/*\n* Releases the receiver, a child in a widget hierarchy,\n* from its parent.\n* <p>\n* When a widget is destroyed, it may be necessary to remove\n* it from an internal data structure of the parent. When\n* a widget has no handle, it may also be necessary for the\n* parent to hide the widget or otherwise indicate that the\n* widget has been disposed. For example, disposing a menu\n* bar requires that the menu bar first be released from the\n* shell when the menu bar is active.  This could not be done\n* in <code>destroyWidget</code> for the menu bar because the\n* parent shell as well as other fields have been null'd out\n* already by <code>releaseWidget</code>.\n* </p>\n* This method is called first when a widget is disposed.\n*\n* @see #dispose\n* @see #releaseChild\n* @see #releaseWidget\n* @see #releaseHandle\n*/\n",
			"methodName":"void releaseChild()"
		},
		"void sendEvent(int eventType, Event event, boolean send)":{
			"methodBody":"{\n    if (eventTable == null && !display.filters(eventType)) {\n        return;\n    }\n    if (event == null)\n        event = new Event();\n    event.type = eventType;\n    event.display = display;\n    event.widget = this;\n    if (event.time == 0) {\n        event.time = display.getLastEventTime();\n    }\n    if (send) {\n        sendEvent(event);\n    } else {\n        display.postEvent(event);\n    }\n}",
			"comments":"",
			"methodName":"void sendEvent(int eventType, Event event, boolean send)"
		},
		"public boolean isListening(int eventType)":{
			"methodBody":"{\n    checkWidget();\n    return hooks(eventType);\n}",
			"comments":"/**\n* Returns <code>true</code> if there are any listeners\n* for the specified event type associated with the receiver,\n* and <code>false</code> otherwise.\n*\n* @param\teventType the type of event\n* @return true if the event is hooked\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public boolean isListening(int eventType)"
		},
		"LRESULT wmMButtonDblClk(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    \n    sendMouseEvent(SWT.MouseDown, 2, hwnd, OS.WM_MBUTTONDOWN, wParam, lParam);\n    sendMouseEvent(SWT.MouseDoubleClick, 2, hwnd, OS.WM_MBUTTONDBLCLK, wParam, lParam);\n    int result = callWindowProc(hwnd, OS.WM_MBUTTONDBLCLK, wParam, lParam);\n    if (OS.GetCapture() != hwnd)\n        OS.SetCapture(hwnd);\n    return new LRESULT(result);\n}",
			"comments":"/*\n* Feature in Windows. Windows sends the following\n* messages when the user double clicks the mouse:\n*\n*\tWM_MBUTTONDOWN\t\t- mouse down\n*\tWM_MBUTTONUP\t\t- mouse up\n*\tWM_MLBUTTONDBLCLK\t- double click\n*\tWM_MBUTTONUP\t\t- mouse up\n*\n* Applications that expect matching mouse down/up\n* pairs will not see the second mouse down.  The\n* fix is to send a mouse down event.\n*/\n",
			"methodName":"LRESULT wmMButtonDblClk(int hwnd, int wParam, int lParam)"
		},
		"boolean setKeyState(Event event, int type, int wParam, int lParam)":{
			"methodBody":"{\n    \n    switch(display.lastAscii) {\n        case SWT.DEL:\n            if (display.lastKey == SWT.BS)\n                display.lastAscii = SWT.BS;\n            break;\n        case SWT.LF:\n            if (display.lastKey == SWT.CR)\n                display.lastAscii = SWT.CR;\n            break;\n    }\n    \n    if (display.lastKey == SWT.CR && display.lastAscii == SWT.CR) {\n        if ((lParam & 0x1000000) != 0)\n            display.lastKey = SWT.KEYPAD_CR;\n    }\n    if (display.lastVirtual) {\n        \n        if (display.lastKey == OS.VK_DELETE)\n            display.lastAscii = 0x7F;\n        \n        if (display.lastKey == OS.VK_CANCEL)\n            display.lastAscii = 0x0;\n        event.keyCode = Display.translateKey(display.lastKey);\n    } else {\n        event.keyCode = display.lastKey;\n    }\n    if (display.lastAscii != 0 || display.lastNull) {\n        event.character = Display.mbcsToWcs((char) display.lastAscii);\n    }\n    if (event.keyCode == 0 && event.character == 0) {\n        if (!display.lastNull)\n            return false;\n    }\n    return setInputState(event, type);\n}",
			"comments":"/*\n* Feature in Windows.  When the user presses Ctrl+Backspace\n* or Ctrl+Enter, Windows sends a WM_CHAR with Delete (0x7F)\n* and '\\n' instead of '\\b' and '\\r'.  This is the correct\n* platform behavior but is not portable.  The fix is to detect\n* these cases and convert the character.\n*/\n/*\n* Feature in Windows.  When the user presses either the Enter\n* key or the numeric keypad Enter key, Windows sends a WM_KEYDOWN\n* with wParam=VK_RETURN in both cases.  In order to distinguish\n* between the keys, the extended key bit is tested. If the bit\n* is set, assume that the numeric keypad Enter was pressed.\n*/\n/*\n* Feature in Windows.  The virtual key VK_DELETE is not\n* treated as both a virtual key and an ASCII key by Windows.\n* Therefore, we will not receive a WM_CHAR for this key.\n* The fix is to treat VK_DELETE as a special case and map\n* the ASCII value explictly (Delete is 0x7F).\n*/\n/*\n* Feature in Windows.  When the user presses Ctrl+Pause, the\n* VK_CANCEL key is generated and a WM_CHAR is sent with 0x03,\n* possibly to allow an application to look for Ctrl+C and the\n* the Break key at the same time.  This is unexpected and\n* unwanted.  The fix is to detect the case and set the character\n* to zero.\n*/\n",
			"methodName":"boolean setKeyState(Event event, int type, int wParam, int lParam)"
		},
		"void releaseResources()":{
			"methodBody":"{\n    releaseWidget();\n    releaseHandle();\n}",
			"comments":"",
			"methodName":"void releaseResources()"
		},
		"LRESULT wmMouseWheel(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    if (!hooks(SWT.MouseWheel) && !filters(SWT.MouseWheel))\n        return null;\n    int delta = wParam >> 16;\n    int[] value = new int[1];\n    int count, detail;\n    OS.SystemParametersInfo(OS.SPI_GETWHEELSCROLLLINES, 0, value, 0);\n    if (value[0] == OS.WHEEL_PAGESCROLL) {\n        detail = SWT.SCROLL_PAGE;\n        count = delta / OS.WHEEL_DELTA;\n    } else {\n        detail = SWT.SCROLL_LINE;\n        count = value[0] * delta / OS.WHEEL_DELTA;\n    }\n    POINT pt = new POINT();\n    pt.x = (short) (lParam & 0xFFFF);\n    pt.y = (short) (lParam >> 16);\n    OS.ScreenToClient(hwnd, pt);\n    lParam = pt.x | (pt.y << 16);\n    if (!sendMouseEvent(SWT.MouseWheel, 0, count, detail, true, hwnd, OS.WM_MOUSEWHEEL, wParam, lParam)) {\n        return LRESULT.ZERO;\n    }\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT wmMouseWheel(int hwnd, int wParam, int lParam)"
		},
		"public Display getDisplay()":{
			"methodBody":"{\n    Display display = this.display;\n    if (display == null)\n        error(SWT.ERROR_WIDGET_DISPOSED);\n    return display;\n}",
			"comments":"/**\n* Returns the <code>Display</code> that is associated with\n* the receiver.\n* <p>\n* A widget's display is either provided when it is created\n* (for example, top level <code>Shell</code>s) or is the\n* same as its parent's display.\n* </p>\n*\n* @return the receiver's display\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public Display getDisplay()"
		},
		"public void addDisposeListener(DisposeListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    TypedListener typedListener = new TypedListener(listener);\n    addListener(SWT.Dispose, typedListener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notifed when the widget is disposed. When the widget is\n* disposed, the listener is notified by sending it the\n* <code>widgetDisposed()</code> message.\n*\n* @param listener the listener which should be notified when the receiver is disposed\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see DisposeListener\n* @see #removeDisposeListener\n*/\n",
			"methodName":"public void addDisposeListener(DisposeListener listener)"
		},
		"boolean sendFocusEvent(int type)":{
			"methodBody":"{\n    sendEvent(type);\n    \n    return true;\n}",
			"comments":"// widget could be disposed at this point\n",
			"methodName":"boolean sendFocusEvent(int type)"
		},
		"public boolean isDisposed()":{
			"methodBody":"{\n    return (state & DISPOSED) != 0;\n}",
			"comments":"/**\n* Returns <code>true</code> if the widget has been disposed,\n* and <code>false</code> otherwise.\n* <p>\n* This method gets the dispose state for the widget.\n* When a widget has been disposed, it is an error to\n* invoke any other method using the widget.\n* </p>\n*\n* @return <code>true</code> when the widget is disposed and <code>false</code> otherwise\n*/\n",
			"methodName":"public boolean isDisposed()"
		},
		"public void setData(Object data)":{
			"methodBody":"{\n    checkWidget();\n    if ((state & KEYED_DATA) != 0) {\n        ((Object[]) this.data)[0] = data;\n    } else {\n        this.data = data;\n    }\n}",
			"comments":"/**\n* Sets the application defined widget data associated\n* with the receiver to be the argument. The <em>widget\n* data</em> is a single, unnamed field that is stored\n* with every widget.\n* <p>\n* Applications may put arbitrary objects in this field. If\n* the object stored in the widget data needs to be notified\n* when the widget is disposed of, it is the application's\n* responsibility to hook the Dispose event on the widget and\n* do so.\n* </p>\n*\n* @param data the widget data\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - when the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - when called from the wrong thread</li>\n* </ul>\n*\n* @see #getData()\n*/\n",
			"methodName":"public void setData(Object data)"
		},
		"void checkOpened()":{
			"methodBody":"{\n\n}",
			"comments":"/* Do nothing */\n",
			"methodName":"void checkOpened()"
		},
		"public String toString()":{
			"methodBody":"{\n    \n    String string = \"*Disposed*\";\n    if (!isDisposed()) {\n        \n        string = \"*Wrong Thread*\";\n        if (isValidThread())\n            string = getNameText();\n    }\n    \n    return getName() + \" {\" + string + \"}\";\n}",
			"comments":"/**\n* Returns a string containing a concise, human-readable\n* description of the receiver.\n*\n* @return a string representation of the receiver\n*/\n//$NON-NLS-1$\n//$NON-NLS-1$\n//$NON-NLS-1$ //$NON-NLS-2$\n",
			"methodName":"public String toString()"
		},
		"void releaseHandle()":{
			"methodBody":"{\n    state |= DISPOSED;\n    display = null;\n}",
			"comments":"/*\n* Releases the widget's handle by zero'ing it out.\n* Does not destroy or release any operating system\n* resources.\n* <p>\n* This method is called after <code>releaseWidget</code>\n* or from <code>destroyWidget</code> when a widget is being\n* destroyed to ensure that the widget is marked as destroyed\n* in case the act of destroying the widget in the operating\n* system causes application code to run in callback that\n* could access the widget.\n* </p>\n*\n* @see #dispose\n* @see #releaseChild\n* @see #releaseWidget\n* @see #releaseHandle\n*/\n",
			"methodName":"void releaseHandle()"
		},
		"boolean SetWindowPos(int hWnd, int hWndInsertAfter, int X, int Y, int cx, int cy, int uFlags)":{
			"methodBody":"{\n    if (OS.IsWinCE) {\n        \n        if ((uFlags & OS.SWP_NOSIZE) == 0) {\n            RECT lpRect = new RECT();\n            OS.GetWindowRect(hWnd, lpRect);\n            if (cy == lpRect.bottom - lpRect.top && cx == lpRect.right - lpRect.left) {\n                \n                uFlags &= ~OS.SWP_DRAWFRAME;\n                uFlags |= OS.SWP_NOSIZE;\n            }\n        }\n    }\n    return OS.SetWindowPos(hWnd, hWndInsertAfter, X, Y, cx, cy, uFlags);\n}",
			"comments":"/*\n* Feature in Windows.  On Windows CE, SetWindowPos() always causes\n* a WM_SIZE message, even when the new size is the same as the old\n* size.  The fix is to detect that the size has not changed and set\n* SWP_NOSIZE.\n*/\n/*\n* Feature in Windows.  On Windows CE, SetWindowPos() when called\n* with SWP_DRAWFRAME always causes a WM_SIZE message, even\n* when SWP_NOSIZE is set and when the new size is the same as the\n* old size.  The fix is to clear SWP_DRAWFRAME when the size is\n* the same.\n*/\n",
			"methodName":"boolean SetWindowPos(int hWnd, int hWndInsertAfter, int X, int Y, int cx, int cy, int uFlags)"
		},
		"public void addListener(int eventType, Listener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        eventTable = new EventTable();\n    eventTable.hook(eventType, listener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notifed when an event of the given type occurs. When the\n* event does occur in the widget, the listener is notified by\n* sending it the <code>handleEvent()</code> message.\n*\n* @param eventType the type of event to listen for\n* @param listener the listener which should be notified when the event occurs\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see Listener\n* @see #removeListener\n*/\n",
			"methodName":"public void addListener(int eventType, Listener listener)"
		},
		"public void removeDisposeListener(DisposeListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(SWT.Dispose, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notifed when the widget is disposed.\n*\n* @param listener the listener which should no longer be notified when the receiver is disposed\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see DisposeListener\n* @see #addDisposeListener\n*/\n",
			"methodName":"public void removeDisposeListener(DisposeListener listener)"
		},
		"protected void removeListener(int eventType, SWTEventListener listener)":{
			"methodBody":"{\n    checkWidget();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(eventType, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notifed when an event of the given type occurs.\n* <p>\n* <b>IMPORTANT:</b> This method is <em>not</em> part of the SWT\n* public API. It is marked public only so that it can be shared\n* within the packages provided by SWT. It should never be\n* referenced from application code.\n* </p>\n*\n* @param eventType the type of event to listen for\n* @param listener the listener which should no longer be notified when the event occurs\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see Listener\n* @see #addListener\n*/\n",
			"methodName":"protected void removeListener(int eventType, SWTEventListener listener)"
		},
		"LRESULT wmXButtonDown(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    int button = (wParam >> 16 == OS.XBUTTON1) ? 4 : 5;\n    sendMouseEvent(SWT.MouseDown, button, hwnd, OS.WM_XBUTTONDOWN, wParam, lParam);\n    int result = callWindowProc(hwnd, OS.WM_XBUTTONDOWN, wParam, lParam);\n    if (OS.GetCapture() != hwnd)\n        OS.SetCapture(hwnd);\n    return new LRESULT(result);\n}",
			"comments":"",
			"methodName":"LRESULT wmXButtonDown(int hwnd, int wParam, int lParam)"
		},
		"Widget findItem(int id)":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"Widget findItem(int id)"
		},
		"boolean sendKeyEvent(int type, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    Event event = new Event();\n    if (!setKeyState(event, type, wParam, lParam))\n        return true;\n    return sendKeyEvent(type, msg, wParam, lParam, event);\n}",
			"comments":"",
			"methodName":"boolean sendKeyEvent(int type, int msg, int wParam, int lParam)"
		},
		"LRESULT wmSysKeyUp(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    return wmKeyUp(hwnd, wParam, lParam);\n}",
			"comments":"",
			"methodName":"LRESULT wmSysKeyUp(int hwnd, int wParam, int lParam)"
		},
		"LRESULT wmChar(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    \n    if (!OS.IsUnicode && OS.IsDBLocale) {\n        byte lead = (byte) (wParam & 0xFF);\n        if (OS.IsDBCSLeadByte(lead))\n            return null;\n    }\n    display.lastAscii = wParam;\n    display.lastNull = wParam == 0;\n    if (!sendKeyEvent(SWT.KeyDown, OS.WM_CHAR, wParam, lParam)) {\n        return LRESULT.ONE;\n    }\n    \n    return null;\n}",
			"comments":"/*\n* Do not report a lead byte as a key pressed.\n*/\n// widget could be disposed at this point\n",
			"methodName":"LRESULT wmChar(int hwnd, int wParam, int lParam)"
		},
		"LRESULT wmSysKeyDown(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    \n    if (wParam != OS.VK_F10) {\n        \n        if ((lParam & 0x20000000) == 0)\n            return null;\n    }\n    \n    switch(wParam) {\n        case OS.VK_F4:\n            return null;\n    }\n    \n    switch(wParam) {\n        case OS.VK_SHIFT:\n        case OS.VK_MENU:\n        case OS.VK_CONTROL:\n        case OS.VK_CAPITAL:\n        case OS.VK_NUMLOCK:\n        case OS.VK_SCROLL:\n            if ((lParam & 0x40000000) != 0)\n                return null;\n    }\n    \n    display.lastAscii = display.lastKey = 0;\n    display.lastVirtual = display.lastNull = display.lastDead = false;\n    \n    \n    int mapKey = 0;\n    if (OS.IsWinCE) {\n        switch(wParam) {\n            case OS.VK_BACK:\n                mapKey = SWT.BS;\n                break;\n            case OS.VK_RETURN:\n                mapKey = SWT.CR;\n                break;\n            case OS.VK_DELETE:\n                mapKey = SWT.DEL;\n                break;\n            case OS.VK_ESCAPE:\n                mapKey = SWT.ESC;\n                break;\n            case OS.VK_TAB:\n                mapKey = SWT.TAB;\n                break;\n        }\n    } else {\n        mapKey = OS.MapVirtualKey(wParam, 2);\n    }\n    display.lastVirtual = mapKey == 0 || display.numpadKey(wParam) != 0;\n    if (display.lastVirtual) {\n        display.lastKey = wParam;\n        \n        if (display.lastKey == OS.VK_DELETE)\n            display.lastAscii = 0x7F;\n        \n        if (OS.VK_NUMPAD0 <= display.lastKey && display.lastKey <= OS.VK_DIVIDE) {\n            display.lastAscii = display.numpadKey(display.lastKey);\n        }\n    } else {\n        \n        display.lastKey = OS.CharLower((short) mapKey);\n        \n        if (OS.IsWinNT)\n            return null;\n        if (wParam != OS.VK_RETURN)\n            return null;\n        display.lastAscii = '\\r';\n    }\n    if (!sendKeyEvent(SWT.KeyDown, OS.WM_SYSKEYDOWN, wParam, lParam)) {\n        return LRESULT.ONE;\n    }\n    \n    return null;\n}",
			"comments":"/*\n* Feature in Windows.  When WM_SYSKEYDOWN is sent,\n* the user pressed ALT+<key> or F10 to get to the\n* menu bar.  In order to issue events for F10 but\n* ignore other key presses when the ALT is not down,\n* make sure that either F10 was pressed or that ALT\n* is pressed.\n*/\n/* Make sure WM_SYSKEYDOWN was sent by ALT-<aKey>. */\n/* Ignore well known system keys */\n/* Ignore repeating modifier keys by testing key down state */\n/* Clear last key and last ascii because a new key has been typed */\n/* If are going to get a WM_SYSCHAR, ignore this message. */\n/*\n* Bug in WinCE.  MapVirtualKey() returns incorrect values.\n* The fix is to rely on a key mappings table to determine\n* whether the key event must be sent now or if a WM_CHAR\n* event will follow.  The key mappings table maps virtual\n* keys to SWT key codes and does not contain mappings for\n* Windows virtual keys like VK_A.  Virtual keys that are\n* both virtual and ASCII are a special case.\n*/\n/*\n* Feature in Windows.  The virtual key VK_DELETE is not\n* treated as both a virtual key and an ASCII key by Windows.\n* Therefore, we will not receive a WM_SYSCHAR for this key.\n* The fix is to treat VK_DELETE as a special case and map\n* the ASCII value explictly (Delete is 0x7F).\n*/\n/* When a keypad key is typed, a WM_SYSCHAR is not issued */\n/*\n* Convert LastKey to lower case because Windows non-virtual\n* keys that are also ASCII keys, such as like VK_A, are have\n* upper case values in WM_SYSKEYDOWN despite the fact that the\n* Shift was not pressed.\n*/\n/*\n* Feature in Windows 98.  MapVirtualKey() indicates that\n* a WM_SYSCHAR message will occur for Alt+Enter but\n* this message never happens.  The fix is to issue the\n* event from WM_SYSKEYDOWN and map VK_RETURN to '\\r'.\n*/\n// widget could be disposed at this point\n",
			"methodName":"LRESULT wmSysKeyDown(int hwnd, int wParam, int lParam)"
		},
		"boolean isValidThread()":{
			"methodBody":"{\n    return getDisplay().isValidThread();\n}",
			"comments":"/*\n* Returns <code>true</code> when the current thread is\n* the thread that created the widget and <code>false</code>\n* otherwise.\n*\n* @return <code>true</code> when the current thread is the thread that created the widget and <code>false</code> otherwise\n*/\n",
			"methodName":"boolean isValidThread()"
		},
		"LRESULT wmMButtonUp(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    sendMouseEvent(SWT.MouseUp, 2, hwnd, OS.WM_MBUTTONUP, wParam, lParam);\n    int result = callWindowProc(hwnd, OS.WM_MBUTTONUP, wParam, lParam);\n    int mask = OS.MK_LBUTTON | OS.MK_MBUTTON | OS.MK_RBUTTON | OS.MK_XBUTTON1 | OS.MK_XBUTTON2;\n    if (((wParam & 0xFFFF) & mask) == 0) {\n        if (OS.GetCapture() == hwnd)\n            OS.ReleaseCapture();\n    }\n    return new LRESULT(result);\n}",
			"comments":"",
			"methodName":"LRESULT wmMButtonUp(int hwnd, int wParam, int lParam)"
		},
		"LRESULT wmRButtonUp(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    sendMouseEvent(SWT.MouseUp, 3, hwnd, OS.WM_RBUTTONUP, wParam, lParam);\n    int result = callWindowProc(hwnd, OS.WM_RBUTTONUP, wParam, lParam);\n    int mask = OS.MK_LBUTTON | OS.MK_MBUTTON | OS.MK_RBUTTON | OS.MK_XBUTTON1 | OS.MK_XBUTTON2;\n    if (((wParam & 0xFFFF) & mask) == 0) {\n        if (OS.GetCapture() == hwnd)\n            OS.ReleaseCapture();\n    }\n    return new LRESULT(result);\n}",
			"comments":"",
			"methodName":"LRESULT wmRButtonUp(int hwnd, int wParam, int lParam)"
		},
		"public void dispose()":{
			"methodBody":"{\n    \n    if (isDisposed())\n        return;\n    if (!isValidThread())\n        error(SWT.ERROR_THREAD_INVALID_ACCESS);\n    releaseChild();\n    releaseWidget();\n    destroyWidget();\n}",
			"comments":"/**\n* Disposes of the operating system resources associated with\n* the receiver and all its descendents. After this method has\n* been invoked, the receiver and all descendents will answer\n* <code>true</code> when sent the message <code>isDisposed()</code>.\n* Any internal connections between the widgets in the tree will\n* have been removed to facilitate garbage collection.\n* <p>\n* NOTE: This method is not called recursively on the descendents\n* of the receiver. This means that, widget implementers can not\n* detect when a widget is being disposed of by re-implementing\n* this method, but should instead listen for the <code>Dispose</code>\n* event.\n* </p>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #addDisposeListener\n* @see #removeDisposeListener\n* @see #checkWidget\n*/\n/*\n* Note:  It is valid to attempt to dispose a widget\n* more than once.  If this happens, fail silently.\n*/\n",
			"methodName":"public void dispose()"
		},
		"LRESULT wmLButtonUp(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    sendMouseEvent(SWT.MouseUp, 1, hwnd, OS.WM_LBUTTONUP, wParam, lParam);\n    int result = callWindowProc(hwnd, OS.WM_LBUTTONUP, wParam, lParam);\n    int mask = OS.MK_LBUTTON | OS.MK_MBUTTON | OS.MK_RBUTTON | OS.MK_XBUTTON1 | OS.MK_XBUTTON2;\n    if (((wParam & 0xFFFF) & mask) == 0) {\n        if (OS.GetCapture() == hwnd)\n            OS.ReleaseCapture();\n    }\n    return new LRESULT(result);\n}",
			"comments":"",
			"methodName":"LRESULT wmLButtonUp(int hwnd, int wParam, int lParam)"
		},
		"LRESULT wmSetFocus(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    int code = callWindowProc(hwnd, OS.WM_SETFOCUS, wParam, lParam);\n    sendFocusEvent(SWT.FocusIn);\n    \n    if (isDisposed())\n        return LRESULT.ZERO;\n    if (code == 0)\n        return LRESULT.ZERO;\n    return new LRESULT(code);\n}",
			"comments":"// widget could be disposed at this point\n/*\n* It is possible (but unlikely), that application\n* code could have disposed the widget in the focus\n* or activate events.  If this happens, end the\n* processing of the Windows message by returning\n* zero as the result of the window proc.\n*/\n",
			"methodName":"LRESULT wmSetFocus(int hwnd, int wParam, int lParam)"
		},
		"void sendEvent(int eventType, Event event)":{
			"methodBody":"{\n    sendEvent(eventType, event, true);\n}",
			"comments":"",
			"methodName":"void sendEvent(int eventType, Event event)"
		},
		"boolean sendMouseEvent(int type, int button, int hwnd, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    return sendMouseEvent(type, button, 0, 0, false, hwnd, msg, wParam, lParam);\n}",
			"comments":"",
			"methodName":"boolean sendMouseEvent(int type, int button, int hwnd, int msg, int wParam, int lParam)"
		},
		"public void notifyListeners(int eventType, Event event)":{
			"methodBody":"{\n    checkWidget();\n    if (event == null)\n        event = new Event();\n    sendEvent(eventType, event);\n}",
			"comments":"/**\n* Notifies all of the receiver's listeners for events\n* of the given type that one such event has occurred by\n* invoking their <code>handleEvent()</code> method.\n*\n* @param eventType the type of event which has occurred\n* @param event the event data\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void notifyListeners(int eventType, Event event)"
		},
		"LRESULT wmKillFocus(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    int code = callWindowProc(hwnd, OS.WM_KILLFOCUS, wParam, lParam);\n    sendFocusEvent(SWT.FocusOut);\n    \n    if (isDisposed())\n        return LRESULT.ZERO;\n    if (code == 0)\n        return LRESULT.ZERO;\n    return new LRESULT(code);\n}",
			"comments":"// widget could be disposed at this point\n/*\n* It is possible (but unlikely), that application\n* code could have disposed the widget in the focus\n* or deactivate events.  If this happens, end the\n* processing of the Windows message by returning\n* zero as the result of the window proc.\n*/\n",
			"methodName":"LRESULT wmKillFocus(int hwnd, int wParam, int lParam)"
		},
		"public Object getData(String key)":{
			"methodBody":"{\n    checkWidget();\n    if (key == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if ((state & KEYED_DATA) != 0) {\n        Object[] table = (Object[]) data;\n        for (int i = 1; i < table.length; i += 2) {\n            if (key.equals(table[i]))\n                return table[i + 1];\n        }\n    }\n    return null;\n}",
			"comments":"/**\n* Returns the application defined property of the receiver\n* with the specified name, or null if it has not been set.\n* <p>\n* Applications may have associated arbitrary objects with the\n* receiver in this fashion. If the objects stored in the\n* properties need to be notified when the widget is disposed\n* of, it is the application's responsibility to hook the\n* Dispose event on the widget and do so.\n* </p>\n*\n* @param\tkey the name of the property\n* @return the value of the property or null if it has not been set\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the key is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see #setData(String, Object)\n*/\n",
			"methodName":"public Object getData(String key)"
		},
		"void error(int code)":{
			"methodBody":"{\n    SWT.error(code);\n}",
			"comments":"/**\n* Does whatever widget specific cleanup is required, and then\n* uses the code in <code>SWTError.error</code> to handle the error.\n*\n* @param code the descriptive error code\n*\n* @see SWT#error(int)\n*/\n",
			"methodName":"void error(int code)"
		},
		"void releaseWidget()":{
			"methodBody":"{\n    sendEvent(SWT.Dispose);\n    eventTable = null;\n    data = null;\n}",
			"comments":"/*\n* Releases any internal resources back to the operating\n* system and clears all fields except the widget handle.\n* <p>\n* When a widget is destroyed, resources that were acquired\n* on behalf of the programmer need to be returned to the\n* operating system.  For example, if the widget made a\n* copy of an icon, supplied by the programmer, this copy\n* would be freed in <code>releaseWidget</code>.  Also,\n* to assist the garbage collector and minimize the amount\n* of memory that is not reclaimed when the programmer keeps\n* a reference to a disposed widget, all fields except the\n* handle are zero'd.  The handle is needed by <code>destroyWidget</code>.\n* </p>\n* <p>\n* Typically, a widget with children will broadcast this\n* message to all children so that they too can release their\n* resources.  The <code>releaseHandle</code> method is used\n* as part of this broadcast to zero the handle fields of the\n* children without calling <code>destroyWidget</code>.  In\n* this scenario, the children are actually destroyed later,\n* when the operating system destroys the widget tree.\n* </p>\n* This method is called after <code>releaseChild</code>.\n*\n* @see #dispose\n* @see #releaseChild\n* @see #releaseWidget\n* @see #releaseHandle\n*/\n",
			"methodName":"void releaseWidget()"
		},
		"LRESULT wmCaptureChanged(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    display.captureChanged = true;\n    return null;\n}",
			"comments":"",
			"methodName":"LRESULT wmCaptureChanged(int hwnd, int wParam, int lParam)"
		},
		"boolean sendKeyEvent(int type, int msg, int wParam, int lParam, Event event)":{
			"methodBody":"{\n    sendEvent(type, event);\n    if (isDisposed())\n        return false;\n    return event.doit;\n}",
			"comments":"",
			"methodName":"boolean sendKeyEvent(int type, int msg, int wParam, int lParam, Event event)"
		},
		"LRESULT wmKeyUp(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    Display display = this.display;\n    \n    if (OS.IsWinCE) {\n        if (OS.VK_APP1 <= wParam && wParam <= OS.VK_APP6) {\n            display.lastKey = display.lastAscii = 0;\n            display.lastVirtual = display.lastNull = display.lastDead = false;\n            Event event = new Event();\n            event.detail = wParam - OS.VK_APP1 + 1;\n            \n            int type = (lParam & 0x40000000) != 0 ? SWT.HardKeyUp : SWT.HardKeyDown;\n            if (setInputState(event, type))\n                sendEvent(type, event);\n            \n            return null;\n        }\n    }\n    \n    if (!hooks(SWT.KeyUp) && !display.filters(SWT.KeyUp)) {\n        display.lastKey = display.lastAscii = 0;\n        display.lastVirtual = display.lastNull = display.lastDead = false;\n        return null;\n    }\n    \n    \n    int mapKey = 0;\n    if (OS.IsWinCE) {\n        switch(wParam) {\n            case OS.VK_BACK:\n                mapKey = SWT.BS;\n                break;\n            case OS.VK_RETURN:\n                mapKey = SWT.CR;\n                break;\n            case OS.VK_DELETE:\n                mapKey = SWT.DEL;\n                break;\n            case OS.VK_ESCAPE:\n                mapKey = SWT.ESC;\n                break;\n            case OS.VK_TAB:\n                mapKey = SWT.TAB;\n                break;\n        }\n    } else {\n        mapKey = OS.MapVirtualKey(wParam, 2);\n    }\n    \n    if (OS.IsWinNT) {\n        if ((mapKey & 0x80000000) != 0)\n            return null;\n    } else {\n        if ((mapKey & 0x8000) != 0)\n            return null;\n    }\n    if (display.lastDead)\n        return null;\n    \n    display.lastVirtual = mapKey == 0 || display.numpadKey(wParam) != 0;\n    if (display.lastVirtual) {\n        display.lastKey = wParam;\n    } else {\n        \n        if (wParam == OS.VK_CANCEL)\n            display.lastVirtual = true;\n        if (display.lastKey == 0) {\n            display.lastAscii = 0;\n            display.lastNull = display.lastDead = false;\n            return null;\n        }\n    }\n    LRESULT result = null;\n    if (!sendKeyEvent(SWT.KeyUp, OS.WM_KEYUP, wParam, lParam)) {\n        result = LRESULT.ONE;\n    }\n    \n    display.lastKey = display.lastAscii = 0;\n    display.lastVirtual = display.lastNull = display.lastDead = false;\n    return result;\n}",
			"comments":"/* Check for hardware keys */\n/* Check the bit 30 to get the key state */\n// widget could be disposed at this point\n/*\n* If the key up is not hooked, reset last key\n* and last ascii in case the key down is hooked.\n*/\n/* Map the virtual key. */\n/*\n* Bug in WinCE.  MapVirtualKey() returns incorrect values.\n* The fix is to rely on a key mappings table to determine\n* whether the key event must be sent now or if a WM_CHAR\n* event will follow.  The key mappings table maps virtual\n* keys to SWT key codes and does not contain mappings for\n* Windows virtual keys like VK_A.  Virtual keys that are\n* both virtual and ASCII are a special case.\n*/\n/*\n* Bug in Windows 95 and NT.  When the user types an accent key such\n* as ^ to get an accented character on a German keyboard, the accent\n* key should be ignored and the next key that the user types is the\n* accented key. The fix is to detect the accent key stroke (called\n* a dead key) by testing the high bit of the value returned by\n* MapVirtualKey ().  A further problem is that the high bit on\n* Windows NT is bit 32 while the high bit on Windows 95 is bit 16.\n* They should both be bit 32.\n*/\n/*\n* NOTE: On Windows 98, keypad keys are virtual despite the\n* fact that a WM_CHAR is issued.  On Windows 2000 and XP,\n* they are not virtual.  Therefore it is necessary to force\n* numeric keypad keys to be virtual.\n*/\n/*\n* Feature in Windows. The virtual key VK_CANCEL is treated\n* as both a virtual key and ASCII key by Windows.  This\n* means that a WM_CHAR with WPARAM=3 will be issued for\n* this key.  In order to distingush between this key and\n* Ctrl+C, mark the key as virtual.\n*/\n// widget could be disposed at this point\n",
			"methodName":"LRESULT wmKeyUp(int hwnd, int wParam, int lParam)"
		},
		"public Object getData()":{
			"methodBody":"{\n    checkWidget();\n    return (state & KEYED_DATA) != 0 ? ((Object[]) data)[0] : data;\n}",
			"comments":"/**\n* Returns the application defined widget data associated\n* with the receiver, or null if it has not been set. The\n* <em>widget data</em> is a single, unnamed field that is\n* stored with every widget.\n* <p>\n* Applications may put arbitrary objects in this field. If\n* the object stored in the widget data needs to be notified\n* when the widget is disposed of, it is the application's\n* responsibility to hook the Dispose event on the widget and\n* do so.\n* </p>\n*\n* @return the widget data\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - when the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - when called from the wrong thread</li>\n* </ul>\n*\n* @see #setData(Object)\n*/\n",
			"methodName":"public Object getData()"
		},
		"boolean sendMouseEvent(int type, int button, int count, int detail, boolean send, int hwnd, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    if (!hooks(type) && !filters(type))\n        return true;\n    Event event = new Event();\n    event.button = button;\n    event.detail = detail;\n    event.count = count;\n    event.x = (short) (lParam & 0xFFFF);\n    event.y = (short) (lParam >> 16);\n    setInputState(event, type);\n    mapEvent(hwnd, event);\n    if (send) {\n        sendEvent(type, event);\n        if (isDisposed())\n            return false;\n    } else {\n        postEvent(type, event);\n    }\n    return event.doit;\n}",
			"comments":"",
			"methodName":"boolean sendMouseEvent(int type, int button, int count, int detail, boolean send, int hwnd, int msg, int wParam, int lParam)"
		},
		"int callWindowProc(int hwnd, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    return 0;\n}",
			"comments":"",
			"methodName":"int callWindowProc(int hwnd, int msg, int wParam, int lParam)"
		},
		"int DeferWindowPos(int hWinPosInfo, int hWnd, int hWndInsertAfter, int X, int Y, int cx, int cy, int uFlags)":{
			"methodBody":"{\n    if (OS.IsWinCE) {\n        \n        if ((uFlags & OS.SWP_NOSIZE) == 0) {\n            RECT lpRect = new RECT();\n            OS.GetWindowRect(hWnd, lpRect);\n            if (cy == lpRect.bottom - lpRect.top && cx == lpRect.right - lpRect.left) {\n                \n                uFlags &= ~OS.SWP_DRAWFRAME;\n                uFlags |= OS.SWP_NOSIZE;\n            }\n        }\n    }\n    return OS.DeferWindowPos(hWinPosInfo, hWnd, hWndInsertAfter, X, Y, cx, cy, uFlags);\n}",
			"comments":"/*\n* Feature in Windows.  On Windows CE, DeferWindowPos always causes\n* a WM_SIZE message, even when the new size is the same as the old\n* size.  The fix is to detect that the size has not changed and set\n* SWP_NOSIZE.\n*/\n/*\n* Feature in Windows.  On Windows CE, DeferWindowPos when called\n* with SWP_DRAWFRAME always causes a WM_SIZE message, even\n* when SWP_NOSIZE is set and when the new size is the same as the\n* old size.  The fix is to clear SWP_DRAWFRAME when the size is\n* the same.\n*/\n",
			"methodName":"int DeferWindowPos(int hWinPosInfo, int hWnd, int hWndInsertAfter, int X, int Y, int cx, int cy, int uFlags)"
		},
		"LRESULT wmLButtonDblClk(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    \n    sendMouseEvent(SWT.MouseDown, 1, hwnd, OS.WM_LBUTTONDOWN, wParam, lParam);\n    sendMouseEvent(SWT.MouseDoubleClick, 1, hwnd, OS.WM_LBUTTONDBLCLK, wParam, lParam);\n    int result = callWindowProc(hwnd, OS.WM_LBUTTONDBLCLK, wParam, lParam);\n    if (OS.GetCapture() != hwnd)\n        OS.SetCapture(hwnd);\n    return new LRESULT(result);\n}",
			"comments":"/*\n* Feature in Windows. Windows sends the following\n* messages when the user double clicks the mouse:\n*\n*\tWM_LBUTTONDOWN\t\t- mouse down\n*\tWM_LBUTTONUP\t\t- mouse up\n*\tWM_LBUTTONDBLCLK\t- double click\n*\tWM_LBUTTONUP\t\t- mouse up\n*\n* Applications that expect matching mouse down/up\n* pairs will not see the second mouse down.  The\n* fix is to send a mouse down event.\n*/\n",
			"methodName":"LRESULT wmLButtonDblClk(int hwnd, int wParam, int lParam)"
		},
		"void checkParent(Widget parent)":{
			"methodBody":"{\n    if (parent == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (parent.isDisposed())\n        error(SWT.ERROR_INVALID_ARGUMENT);\n    parent.checkWidget();\n    parent.checkOpened();\n}",
			"comments":"/**\n* Throws an exception if the specified widget can not be\n* used as a parent for the receiver.\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the parent is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the parent is disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the parent</li>\n* </ul>\n*/\n",
			"methodName":"void checkParent(Widget parent)"
		},
		"Menu getMenu()":{
			"methodBody":"{\n    return null;\n}",
			"comments":"",
			"methodName":"Menu getMenu()"
		},
		"LRESULT wmIMEChar(int hwnd, int wParam, int lParam)":{
			"methodBody":"{\n    Display display = this.display;\n    display.lastKey = 0;\n    display.lastAscii = wParam;\n    display.lastVirtual = display.lastNull = display.lastDead = false;\n    if (!sendKeyEvent(SWT.KeyDown, OS.WM_IME_CHAR, wParam, lParam)) {\n        return LRESULT.ONE;\n    }\n    sendKeyEvent(SWT.KeyUp, OS.WM_IME_CHAR, wParam, lParam);\n    \n    display.lastKey = display.lastAscii = 0;\n    return LRESULT.ONE;\n}",
			"comments":"// widget could be disposed at this point\n",
			"methodName":"LRESULT wmIMEChar(int hwnd, int wParam, int lParam)"
		}
	},
	"ClassORInterfaceName":[
		"Widget"
	]
}
