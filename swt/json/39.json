{
	"variables":[
		"GAP",
		"INDENT",
		"ELLIPSIS",
		"align",
		"hIndent",
		"vIndent",
		"text",
		"image",
		"appToolTipText",
		"backgroundImage",
		"gradientColors",
		"gradientPercents",
		"gradientVertical",
		"DRAW_FLAGS",
		"mask",
		"platform",
		"e",
		"index",
		"length",
		"size",
		"r",
		"gc",
		"e",
		"style",
		"accessible",
		"mnemonic",
		"rect",
		"mnemonic",
		"control",
		"children",
		"index",
		"rect",
		"shortenText",
		"t",
		"img",
		"availableWidth",
		"extent",
		"gc",
		"lines",
		"i",
		"e",
		"x",
		"imageRect",
		"xPos",
		"yPos",
		"oldBackground",
		"oldForeground",
		"lastColor",
		"pos",
		"i",
		"gradientHeight",
		"gradientWidth",
		"style",
		"imageRect",
		"lineHeight",
		"textHeight",
		"lineY",
		"i",
		"lineX",
		"lineWidth",
		"lineWidth",
		"disp",
		"c1",
		"c2",
		"style",
		"background",
		"i",
		"background",
		"same",
		"i",
		"i",
		"i",
		"i",
		"w",
		"l",
		"pivot",
		"s",
		"e",
		"s1",
		"s2",
		"l1",
		"l2",
		"lines",
		"start",
		"pos",
		"crlf",
		"newLines",
		"SWT",
		"INDENT",
		"INDENT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"parent",
		"style",
		"style",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"style",
		"SWT",
		"align",
		"SWT",
		"style",
		"SWT",
		"align",
		"SWT",
		"style",
		"SWT",
		"align",
		"SWT",
		"event",
		"event",
		"event",
		"SWT",
		"event",
		"style",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"SWT",
		"style",
		"style",
		"mask",
		"style",
		"SWT",
		"SWT",
		"platform",
		"platform",
		"style",
		"style",
		"SWT",
		"image",
		"text",
		"wHint",
		"SWT",
		"e",
		"hIndent",
		"e",
		"wHint",
		"hHint",
		"SWT",
		"e",
		"vIndent",
		"e",
		"hHint",
		"e",
		"gc",
		"bottomright",
		"gc",
		"x",
		"w",
		"y",
		"x",
		"w",
		"y",
		"h",
		"gc",
		"x",
		"y",
		"h",
		"x",
		"w",
		"y",
		"h",
		"gc",
		"topleft",
		"gc",
		"x",
		"y",
		"x",
		"w",
		"y",
		"gc",
		"x",
		"y",
		"x",
		"y",
		"h",
		"string",
		"string",
		"index",
		"length",
		"string",
		"index",
		"index",
		"index",
		"length",
		"string",
		"index",
		"string",
		"index",
		"index",
		"index",
		"length",
		"align",
		"image",
		"image",
		"image",
		"size",
		"r",
		"size",
		"r",
		"text",
		"text",
		"gc",
		"text",
		"DRAW_FLAGS",
		"size",
		"e",
		"size",
		"Math",
		"size",
		"e",
		"image",
		"size",
		"GAP",
		"size",
		"Math",
		"size",
		"gc",
		"gc",
		"size",
		"align",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"SWT",
		"style",
		"SWT",
		"style",
		"text",
		"appToolTipText",
		"accessible",
		"e",
		"e",
		"CLabel",
		"mnemonic",
		"e",
		"mnemonic",
		"accessible",
		"e",
		"ACC",
		"e",
		"rect",
		"e",
		"rect",
		"e",
		"rect",
		"e",
		"rect",
		"e",
		"e",
		"ACC",
		"e",
		"ACC",
		"e",
		"gradientColors",
		"gradientPercents",
		"backgroundImage",
		"text",
		"image",
		"appToolTipText",
		"text",
		"mnemonic",
		"Character",
		"event",
		"Character",
		"mnemonic",
		"control",
		"control",
		"index",
		"children",
		"children",
		"index",
		"index",
		"index",
		"index",
		"children",
		"children",
		"index",
		"event",
		"event",
		"SWT",
		"control",
		"control",
		"rect",
		"rect",
		"text",
		"image",
		"Math",
		"rect",
		"hIndent",
		"img",
		"t",
		"extent",
		"availableWidth",
		"img",
		"extent",
		"img",
		"t",
		"extent",
		"availableWidth",
		"shortenText",
		"event",
		"text",
		"text",
		"shortenText",
		"extent",
		"i",
		"lines",
		"i",
		"gc",
		"lines",
		"i",
		"DRAW_FLAGS",
		"e",
		"availableWidth",
		"lines",
		"i",
		"gc",
		"lines",
		"i",
		"availableWidth",
		"extent",
		"Math",
		"extent",
		"lines",
		"i",
		"extent",
		"Math",
		"extent",
		"e",
		"appToolTipText",
		"text",
		"appToolTipText",
		"rect",
		"hIndent",
		"align",
		"SWT",
		"x",
		"rect",
		"extent",
		"align",
		"SWT",
		"x",
		"rect",
		"hIndent",
		"extent",
		"backgroundImage",
		"backgroundImage",
		"gc",
		"gc",
		"rect",
		"xPos",
		"rect",
		"yPos",
		"rect",
		"gc",
		"backgroundImage",
		"xPos",
		"yPos",
		"yPos",
		"imageRect",
		"xPos",
		"imageRect",
		"gradientColors",
		"gc",
		"gradientColors",
		"gradientColors",
		"gc",
		"gradientColors",
		"gc",
		"rect",
		"rect",
		"gc",
		"gradientColors",
		"lastColor",
		"lastColor",
		"oldBackground",
		"i",
		"gradientPercents",
		"i",
		"gc",
		"lastColor",
		"lastColor",
		"gradientColors",
		"i",
		"lastColor",
		"lastColor",
		"oldBackground",
		"gc",
		"lastColor",
		"gradientVertical",
		"gradientPercents",
		"i",
		"rect",
		"pos",
		"gc",
		"pos",
		"rect",
		"gradientHeight",
		"pos",
		"gradientHeight",
		"gradientPercents",
		"i",
		"rect",
		"pos",
		"gc",
		"pos",
		"gradientWidth",
		"rect",
		"pos",
		"gradientWidth",
		"gradientVertical",
		"pos",
		"rect",
		"gc",
		"gc",
		"pos",
		"rect",
		"rect",
		"pos",
		"gradientVertical",
		"pos",
		"rect",
		"gc",
		"gc",
		"pos",
		"rect",
		"pos",
		"rect",
		"gc",
		"oldForeground",
		"gc",
		"oldBackground",
		"SWT",
		"gc",
		"gc",
		"rect",
		"SWT",
		"gc",
		"gc",
		"rect",
		"style",
		"SWT",
		"style",
		"SWT",
		"gc",
		"rect",
		"img",
		"img",
		"gc",
		"img",
		"imageRect",
		"imageRect",
		"x",
		"rect",
		"imageRect",
		"imageRect",
		"imageRect",
		"x",
		"imageRect",
		"GAP",
		"extent",
		"imageRect",
		"GAP",
		"lines",
		"gc",
		"lines",
		"lineHeight",
		"Math",
		"vIndent",
		"rect",
		"rect",
		"textHeight",
		"gc",
		"i",
		"lines",
		"i",
		"x",
		"lines",
		"align",
		"SWT",
		"gc",
		"lines",
		"i",
		"DRAW_FLAGS",
		"lineX",
		"x",
		"Math",
		"extent",
		"lineWidth",
		"align",
		"SWT",
		"gc",
		"lines",
		"i",
		"DRAW_FLAGS",
		"lineX",
		"Math",
		"x",
		"rect",
		"rect",
		"hIndent",
		"lineWidth",
		"gc",
		"lines",
		"i",
		"lineX",
		"lineY",
		"DRAW_FLAGS",
		"lineY",
		"lineHeight",
		"style",
		"SWT",
		"c1",
		"disp",
		"SWT",
		"c2",
		"disp",
		"SWT",
		"style",
		"SWT",
		"c1",
		"disp",
		"SWT",
		"c2",
		"disp",
		"SWT",
		"c1",
		"c2",
		"gc",
		"gc",
		"r",
		"r",
		"r",
		"r",
		"c1",
		"c2",
		"align",
		"SWT",
		"align",
		"SWT",
		"align",
		"SWT",
		"SWT",
		"SWT",
		"align",
		"align",
		"color",
		"color",
		"backgroundImage",
		"gradientColors",
		"gradientPercents",
		"color",
		"background",
		"backgroundImage",
		"gradientColors",
		"gradientPercents",
		"colors",
		"percents",
		"colors",
		"percents",
		"percents",
		"colors",
		"SWT",
		"SWT",
		"colors",
		"colors",
		"colors",
		"percents",
		"i",
		"percents",
		"i",
		"percents",
		"i",
		"percents",
		"i",
		"SWT",
		"SWT",
		"i",
		"percents",
		"i",
		"percents",
		"i",
		"SWT",
		"SWT",
		"backgroundImage",
		"gradientColors",
		"colors",
		"gradientColors",
		"colors",
		"i",
		"gradientColors",
		"i",
		"same",
		"gradientColors",
		"i",
		"colors",
		"i",
		"gradientColors",
		"i",
		"colors",
		"i",
		"background",
		"gradientColors",
		"i",
		"background",
		"colors",
		"i",
		"same",
		"same",
		"i",
		"gradientPercents",
		"i",
		"same",
		"gradientPercents",
		"i",
		"percents",
		"i",
		"same",
		"same",
		"vertical",
		"backgroundImage",
		"colors",
		"gradientColors",
		"gradientPercents",
		"gradientVertical",
		"gradientColors",
		"colors",
		"i",
		"colors",
		"i",
		"gradientColors",
		"i",
		"colors",
		"i",
		"colors",
		"i",
		"background",
		"gradientPercents",
		"percents",
		"i",
		"percents",
		"i",
		"gradientPercents",
		"i",
		"percents",
		"i",
		"gradientVertical",
		"vertical",
		"image",
		"backgroundImage",
		"image",
		"gradientColors",
		"gradientPercents",
		"backgroundImage",
		"image",
		"font",
		"image",
		"image",
		"text",
		"text",
		"text",
		"text",
		"string",
		"appToolTipText",
		"t",
		"gc",
		"ELLIPSIS",
		"DRAW_FLAGS",
		"t",
		"l",
		"pivot",
		"pivot",
		"s",
		"e",
		"l",
		"t",
		"s",
		"t",
		"e",
		"l",
		"gc",
		"s1",
		"DRAW_FLAGS",
		"gc",
		"s2",
		"DRAW_FLAGS",
		"l1",
		"w",
		"l2",
		"width",
		"t",
		"s1",
		"ELLIPSIS",
		"s2",
		"s",
		"e",
		"t",
		"pos",
		"text",
		"start",
		"pos",
		"lines",
		"lines",
		"text",
		"start",
		"pos",
		"text",
		"pos",
		"lines",
		"lines",
		"text",
		"start",
		"pos",
		"crlf",
		"start",
		"pos",
		"lines",
		"System",
		"lines",
		"newLines",
		"lines",
		"lines",
		"newLines",
		"pos",
		"lines",
		"LEFT",
		"DRAW_MNEMONIC",
		"DRAW_TAB",
		"DRAW_TRANSPARENT",
		"DRAW_DELIMITER",
		"CENTER",
		"RIGHT",
		"LEFT",
		"CENTER",
		"CENTER",
		"RIGHT",
		"RIGHT",
		"LEFT",
		"LEFT",
		"detail",
		"TRAVERSE_MNEMONIC",
		"BORDER",
		"SHADOW_IN",
		"SHADOW_IN",
		"SHADOW_OUT",
		"SHADOW_NONE",
		"LEFT_TO_RIGHT",
		"RIGHT_TO_LEFT",
		"NO_FOCUS",
		"NO_BACKGROUND",
		"DEFAULT",
		"x",
		"x",
		"DEFAULT",
		"y",
		"y",
		"x",
		"width",
		"y",
		"height",
		"x",
		"x",
		"y",
		"y",
		"y",
		"x",
		"y",
		"y",
		"RIGHT",
		"RIGHT",
		"CENTER",
		"CENTER",
		"LEFT",
		"LEFT",
		"result",
		"result",
		"text",
		"result",
		"childID",
		"CHILDID_SELF",
		"x",
		"x",
		"y",
		"y",
		"width",
		"width",
		"height",
		"height",
		"detail",
		"detail",
		"ROLE_LABEL",
		"detail",
		"STATE_READONLY",
		"result",
		"character",
		"length",
		"length",
		"doit",
		"detail",
		"TRAVERSE_NONE",
		"width",
		"height",
		"width",
		"x",
		"x",
		"gc",
		"x",
		"length",
		"x",
		"x",
		"x",
		"x",
		"x",
		"x",
		"x",
		"x",
		"CENTER",
		"width",
		"x",
		"RIGHT",
		"width",
		"x",
		"width",
		"height",
		"height",
		"width",
		"length",
		"width",
		"height",
		"length",
		"height",
		"width",
		"width",
		"height",
		"height",
		"width",
		"height",
		"width",
		"width",
		"height",
		"NO_BACKGROUND",
		"NO_BACKGROUND",
		"SHADOW_IN",
		"SHADOW_OUT",
		"width",
		"height",
		"height",
		"height",
		"width",
		"height",
		"width",
		"x",
		"width",
		"length",
		"y",
		"height",
		"length",
		"length",
		"CENTER",
		"x",
		"x",
		"RIGHT",
		"x",
		"x",
		"width",
		"SHADOW_IN",
		"COLOR_WIDGET_NORMAL_SHADOW",
		"COLOR_WIDGET_HIGHLIGHT_SHADOW",
		"SHADOW_OUT",
		"COLOR_WIDGET_LIGHT_SHADOW",
		"COLOR_WIDGET_NORMAL_SHADOW",
		"x",
		"y",
		"width",
		"height",
		"LEFT",
		"RIGHT",
		"CENTER",
		"ERROR_INVALID_ARGUMENT",
		"align",
		"align",
		"length",
		"length",
		"ERROR_INVALID_ARGUMENT",
		"length",
		"length",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"length",
		"length",
		"length",
		"length",
		"gradientVertical",
		"length",
		"length",
		"length",
		"length",
		"image",
		"image",
		"text",
		"text",
		"x",
		"x",
		"x",
		"length",
		"length",
		"length",
		"length",
		"parent",
		"style",
		"event",
		"event",
		"event",
		"style",
		"wHint",
		"hHint",
		"changed",
		"gc",
		"x",
		"y",
		"w",
		"h",
		"topleft",
		"bottomright",
		"string",
		"image",
		"text",
		"e",
		"e",
		"e",
		"e",
		"e",
		"e",
		"e",
		"e",
		"e",
		"event",
		"event",
		"event",
		"e",
		"gc",
		"r",
		"align",
		"color",
		"colors",
		"percents",
		"colors",
		"percents",
		"vertical",
		"image",
		"font",
		"image",
		"text",
		"string",
		"gc",
		"t",
		"width",
		"text"
	],
	"extendORImplementFiles":[
		"Canvas"
	],
	"package":[
		"org.eclipse.swt.custom"
	],
	"import":[
		"org.eclipse.swt",
		"org.eclipse.swt.widgets",
		"org.eclipse.swt.graphics",
		"org.eclipse.swt.events",
		"org.eclipse.swt.accessibility"
	],
	"methods":[
		"paintControl",
		"widgetDisposed",
		"keyTraversed",
		"checkStyle",
		"computeSize",
		"drawBevelRect",
		"_findMnemonic",
		"getAlignment",
		"getImage",
		"getTotalSize",
		"getStyle",
		"getText",
		"getToolTipText",
		"initAccessible",
		"getName",
		"getHelp",
		"getKeyboardShortcut",
		"getChildAtPoint",
		"getLocation",
		"getChildCount",
		"getRole",
		"getState",
		"getValue",
		"onDispose",
		"onMnemonic",
		"onPaint",
		"paintBorder",
		"setAlignment",
		"setBackground",
		"setBackground",
		"setBackground",
		"setBackground",
		"setFont",
		"setImage",
		"setText",
		"setToolTipText",
		"shortenText",
		"splitString",
		"checkStyle",
		"addPaintListener",
		"onPaint",
		"addDisposeListener",
		"onDispose",
		"addTraverseListener",
		"onMnemonic",
		"initAccessible",
		"getPlatform",
		"equals",
		"equals",
		"checkWidget",
		"getTotalSize",
		"setForeground",
		"drawLine",
		"drawLine",
		"setForeground",
		"drawLine",
		"drawLine",
		"length",
		"charAt",
		"charAt",
		"charAt",
		"getBounds",
		"length",
		"textExtent",
		"max",
		"max",
		"getHeight",
		"getFontMetrics",
		"dispose",
		"getStyle",
		"checkWidget",
		"getAccessible",
		"addAccessibleListener",
		"getText",
		"getToolTipText",
		"_findMnemonic",
		"addAccessibleControlListener",
		"map",
		"getDisplay",
		"getParent",
		"getBounds",
		"getText",
		"_findMnemonic",
		"toUpperCase",
		"toUpperCase",
		"getParent",
		"getChildren",
		"setFocus",
		"getParent",
		"getClientArea",
		"max",
		"getTotalSize",
		"getTotalSize",
		"splitString",
		"textExtent",
		"shortenText",
		"max",
		"getTotalSize",
		"max",
		"setToolTipText",
		"setToolTipText",
		"getBounds",
		"setBackground",
		"getBackground",
		"fillRectangle",
		"drawImage",
		"getBackground",
		"setBackground",
		"fillRectangle",
		"getForeground",
		"setForeground",
		"setBackground",
		"fillGradientRectangle",
		"fillGradientRectangle",
		"setBackground",
		"getBackground",
		"fillRectangle",
		"setBackground",
		"getBackground",
		"fillRectangle",
		"setForeground",
		"setBackground",
		"getStyle",
		"setBackground",
		"getBackground",
		"fillRectangle",
		"getStyle",
		"setBackground",
		"getBackground",
		"fillRectangle",
		"getStyle",
		"paintBorder",
		"getBounds",
		"drawImage",
		"getHeight",
		"getFontMetrics",
		"max",
		"setForeground",
		"getForeground",
		"textExtent",
		"max",
		"textExtent",
		"max",
		"drawText",
		"getDisplay",
		"getStyle",
		"getSystemColor",
		"getSystemColor",
		"getSystemColor",
		"getSystemColor",
		"setLineWidth",
		"drawBevelRect",
		"checkWidget",
		"error",
		"redraw",
		"setBackground",
		"getBackground",
		"equals",
		"redraw",
		"setBackground",
		"checkWidget",
		"error",
		"getDepth",
		"getDisplay",
		"error",
		"error",
		"getBackground",
		"redraw",
		"checkWidget",
		"redraw",
		"setFont",
		"redraw",
		"checkWidget",
		"redraw",
		"checkWidget",
		"equals",
		"redraw",
		"setToolTipText",
		"getToolTipText",
		"textExtent",
		"length",
		"substring",
		"substring",
		"textExtent",
		"textExtent",
		"indexOf",
		"substring",
		"charAt",
		"substring",
		"arraycopy",
		"PaintListener",
		"DisposeListener",
		"TraverseListener",
		"Point",
		"GC",
		"AccessibleAdapter",
		"AccessibleControlAdapter"
	],
	"methodsBody":{
		"public void keyTraversed(TraverseEvent event)":{
			"methodBody":"{\n    if (event.detail == SWT.TRAVERSE_MNEMONIC) {\n        onMnemonic(event);\n    }\n}",
			"comments":"",
			"methodName":"public void keyTraversed(TraverseEvent event)"
		},
		"private static int checkStyle(int style)":{
			"methodBody":"{\n    if ((style & SWT.BORDER) != 0)\n        style |= SWT.SHADOW_IN;\n    int mask = SWT.SHADOW_IN | SWT.SHADOW_OUT | SWT.SHADOW_NONE | SWT.LEFT_TO_RIGHT | SWT.RIGHT_TO_LEFT;\n    style = style & mask;\n    style |= SWT.NO_FOCUS;\n    \n    \n    String platform = SWT.getPlatform();\n    \n    if (\"carbon\".equals(platform) || \"gtk\".equals(platform))\n        return style;\n    return style | SWT.NO_BACKGROUND;\n}",
			"comments":"/**\n* Check the style bits to ensure that no invalid styles are applied.\n*/\n//TEMPORARY CODE\n/*\n* The default background on carbon and some GTK themes is not a solid color\n* but a texture.  To show the correct default background, we must allow\n* the operating system to draw it and therefore, we can not use the\n* NO_BACKGROUND style.  The NO_BACKGROUND style is not required on platforms\n* that use double buffering which is true in both of these cases.\n*/\n//$NON-NLS-1$ //$NON-NLS-2$\n",
			"methodName":"private static int checkStyle(int style)"
		},
		"public void setBackground(Color[] colors, int[] percents, boolean vertical)":{
			"methodBody":"{\n    checkWidget();\n    if (colors != null) {\n        if (percents == null || percents.length != colors.length - 1) {\n            SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n        }\n        if (getDisplay().getDepth() < 15) {\n            \n            colors = new Color[] { colors[colors.length - 1] };\n            percents = new int[] {};\n        }\n        for (int i = 0; i < percents.length; i++) {\n            if (percents[i] < 0 || percents[i] > 100) {\n                SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n            }\n            if (i > 0 && percents[i] < percents[i - 1]) {\n                SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n            }\n        }\n    }\n    \n    final Color background = getBackground();\n    if (backgroundImage == null) {\n        if ((gradientColors != null) && (colors != null) && (gradientColors.length == colors.length)) {\n            boolean same = false;\n            for (int i = 0; i < gradientColors.length; i++) {\n                same = (gradientColors[i] == colors[i]) || ((gradientColors[i] == null) && (colors[i] == background)) || ((gradientColors[i] == background) && (colors[i] == null));\n                if (!same)\n                    break;\n            }\n            if (same) {\n                for (int i = 0; i < gradientPercents.length; i++) {\n                    same = gradientPercents[i] == percents[i];\n                    if (!same)\n                        break;\n                }\n            }\n            if (same && this.gradientVertical == vertical)\n                return;\n        }\n    } else {\n        backgroundImage = null;\n    }\n    \n    if (colors == null) {\n        gradientColors = null;\n        gradientPercents = null;\n        gradientVertical = false;\n    } else {\n        gradientColors = new Color[colors.length];\n        for (int i = 0; i < colors.length; ++i) gradientColors[i] = (colors[i] != null) ? colors[i] : background;\n        gradientPercents = new int[percents.length];\n        for (int i = 0; i < percents.length; ++i) gradientPercents[i] = percents[i];\n        gradientVertical = vertical;\n    }\n    \n    redraw();\n}",
			"comments":"/**\n* Specify a gradient of colours to be drawn in the background of the CLabel.\n* <p>For example, to draw a gradient that varies from dark blue to white in the vertical,\n* direction use the following call\n* to setBackground:</p>\n* <pre>\n*\tclabel.setBackground(new Color[]{display.getSystemColor(SWT.COLOR_DARK_BLUE),\n*\t\t                           display.getSystemColor(SWT.COLOR_WHITE)},\n*\t\t                 new int[] {100}, true);\n* </pre>\n*\n* @param colors an array of Color that specifies the colors to appear in the gradient\n*               in order of appearance from left/top to right/bottom;  The value <code>null</code>\n*               clears the background gradient; the value <code>null</code> can be used\n*               inside the array of Color to specify the background color.\n* @param percents an array of integers between 0 and 100 specifying the percent of the width/height\n*                 of the widget at which the color should change; the size of the percents\n*                 array must be one less than the size of the colors array.\n* @param vertical indicate the direction of the gradient.  True is vertical and false is horizontal.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the values of colors and percents are not consistent</li>\n* </ul>\n*\n* @since 3.0\n*/\n// Don't use gradients on low color displays\n// Are these settings the same as before?\n// Store the new settings\n// Refresh with the new settings\n",
			"methodName":"public void setBackground(Color[] colors, int[] percents, boolean vertical)"
		},
		"public void paintControl(PaintEvent event)":{
			"methodBody":"{\n    onPaint(event);\n}",
			"comments":"",
			"methodName":"public void paintControl(PaintEvent event)"
		},
		"public void getChildAtPoint(AccessibleControlEvent e)":{
			"methodBody":"{\n    e.childID = ACC.CHILDID_SELF;\n}",
			"comments":"",
			"methodName":"public void getChildAtPoint(AccessibleControlEvent e)"
		},
		"private void paintBorder(GC gc, Rectangle r)":{
			"methodBody":"{\n    Display disp = getDisplay();\n    Color c1 = null;\n    Color c2 = null;\n    int style = getStyle();\n    if ((style & SWT.SHADOW_IN) != 0) {\n        c1 = disp.getSystemColor(SWT.COLOR_WIDGET_NORMAL_SHADOW);\n        c2 = disp.getSystemColor(SWT.COLOR_WIDGET_HIGHLIGHT_SHADOW);\n    }\n    if ((style & SWT.SHADOW_OUT) != 0) {\n        c1 = disp.getSystemColor(SWT.COLOR_WIDGET_LIGHT_SHADOW);\n        c2 = disp.getSystemColor(SWT.COLOR_WIDGET_NORMAL_SHADOW);\n    }\n    if (c1 != null && c2 != null) {\n        gc.setLineWidth(1);\n        drawBevelRect(gc, r.x, r.y, r.width - 1, r.height - 1, c1, c2);\n    }\n}",
			"comments":"/**\n* Paint the Label's border.\n*/\n",
			"methodName":"private void paintBorder(GC gc, Rectangle r)"
		},
		"public void getKeyboardShortcut(AccessibleEvent e)":{
			"methodBody":"{\n    char mnemonic = _findMnemonic(CLabel.this.text);\n    if (mnemonic != '\\0') {\n        \n        e.result = \"Alt+\" + mnemonic;\n    }\n}",
			"comments":"//$NON-NLS-1$\n",
			"methodName":"public void getKeyboardShortcut(AccessibleEvent e)"
		},
		"char _findMnemonic(String string)":{
			"methodBody":"{\n    if (string == null)\n        return '\\0';\n    int index = 0;\n    int length = string.length();\n    do {\n        while (index < length && string.charAt(index) != '&') index++;\n        if (++index >= length)\n            return '\\0';\n        if (string.charAt(index) != '&')\n            return string.charAt(index);\n        index++;\n    } while (index < length);\n    return '\\0';\n}",
			"comments":"",
			"methodName":"char _findMnemonic(String string)"
		},
		"private void initAccessible()":{
			"methodBody":"{\n    Accessible accessible = getAccessible();\n    accessible.addAccessibleListener(new AccessibleAdapter() {\n\n        public void getName(AccessibleEvent e) {\n            e.result = getText();\n        }\n\n        public void getHelp(AccessibleEvent e) {\n            e.result = getToolTipText();\n        }\n\n        public void getKeyboardShortcut(AccessibleEvent e) {\n            char mnemonic = _findMnemonic(CLabel.this.text);\n            if (mnemonic != '\\0') {\n                \n                e.result = \"Alt+\" + mnemonic;\n            }\n        }\n    });\n    accessible.addAccessibleControlListener(new AccessibleControlAdapter() {\n\n        public void getChildAtPoint(AccessibleControlEvent e) {\n            e.childID = ACC.CHILDID_SELF;\n        }\n\n        public void getLocation(AccessibleControlEvent e) {\n            Rectangle rect = getDisplay().map(getParent(), null, getBounds());\n            e.x = rect.x;\n            e.y = rect.y;\n            e.width = rect.width;\n            e.height = rect.height;\n        }\n\n        public void getChildCount(AccessibleControlEvent e) {\n            e.detail = 0;\n        }\n\n        public void getRole(AccessibleControlEvent e) {\n            e.detail = ACC.ROLE_LABEL;\n        }\n\n        public void getState(AccessibleControlEvent e) {\n            e.detail = ACC.STATE_READONLY;\n        }\n\n        public void getValue(AccessibleControlEvent e) {\n            e.result = getText();\n        }\n    });\n}",
			"comments":"//$NON-NLS-1$\n",
			"methodName":"private void initAccessible()"
		},
		"public void getHelp(AccessibleEvent e)":{
			"methodBody":"{\n    e.result = getToolTipText();\n}",
			"comments":"",
			"methodName":"public void getHelp(AccessibleEvent e)"
		},
		"public void getValue(AccessibleControlEvent e)":{
			"methodBody":"{\n    e.result = getText();\n}",
			"comments":"",
			"methodName":"public void getValue(AccessibleControlEvent e)"
		},
		"private void drawBevelRect(GC gc, int x, int y, int w, int h, Color topleft, Color bottomright)":{
			"methodBody":"{\n    gc.setForeground(bottomright);\n    gc.drawLine(x + w, y, x + w, y + h);\n    gc.drawLine(x, y + h, x + w, y + h);\n    gc.setForeground(topleft);\n    gc.drawLine(x, y, x + w - 1, y);\n    gc.drawLine(x, y, x, y + h - 1);\n}",
			"comments":"/**\n* Draw a rectangle in the given colors.\n*/\n",
			"methodName":"private void drawBevelRect(GC gc, int x, int y, int w, int h, Color topleft, Color bottomright)"
		},
		"public int getAlignment()":{
			"methodBody":"{\n    \n    return align;\n}",
			"comments":"/**\n* Returns the alignment.\n* The alignment style (LEFT, CENTER or RIGHT) is returned.\n*\n* @return SWT.LEFT, SWT.RIGHT or SWT.CENTER\n*/\n//checkWidget();\n",
			"methodName":"public int getAlignment()"
		},
		"public void getRole(AccessibleControlEvent e)":{
			"methodBody":"{\n    e.detail = ACC.ROLE_LABEL;\n}",
			"comments":"",
			"methodName":"public void getRole(AccessibleControlEvent e)"
		},
		"void onPaint(PaintEvent event)":{
			"methodBody":"{\n    Rectangle rect = getClientArea();\n    if (rect.width == 0 || rect.height == 0)\n        return;\n    boolean shortenText = false;\n    String t = text;\n    Image img = image;\n    int availableWidth = Math.max(0, rect.width - 2 * hIndent);\n    Point extent = getTotalSize(img, t);\n    if (extent.x > availableWidth) {\n        img = null;\n        extent = getTotalSize(img, t);\n        if (extent.x > availableWidth) {\n            shortenText = true;\n        }\n    }\n    GC gc = event.gc;\n    String[] lines = text == null ? null : splitString(text);\n    \n    if (shortenText) {\n        extent.x = 0;\n        for (int i = 0; i < lines.length; i++) {\n            Point e = gc.textExtent(lines[i], DRAW_FLAGS);\n            if (e.x > availableWidth) {\n                lines[i] = shortenText(gc, lines[i], availableWidth);\n                extent.x = Math.max(extent.x, getTotalSize(null, lines[i]).x);\n            } else {\n                extent.x = Math.max(extent.x, e.x);\n            }\n        }\n        if (appToolTipText == null) {\n            super.setToolTipText(text);\n        }\n    } else {\n        super.setToolTipText(appToolTipText);\n    }\n    \n    int x = rect.x + hIndent;\n    if (align == SWT.CENTER) {\n        x = (rect.width - extent.x) / 2;\n    }\n    if (align == SWT.RIGHT) {\n        x = rect.width - hIndent - extent.x;\n    }\n    \n    try {\n        if (backgroundImage != null) {\n            \n            Rectangle imageRect = backgroundImage.getBounds();\n            \n            gc.setBackground(getBackground());\n            gc.fillRectangle(rect);\n            int xPos = 0;\n            while (xPos < rect.width) {\n                int yPos = 0;\n                while (yPos < rect.height) {\n                    gc.drawImage(backgroundImage, xPos, yPos);\n                    yPos += imageRect.height;\n                }\n                xPos += imageRect.width;\n            }\n        } else if (gradientColors != null) {\n            \n            final Color oldBackground = gc.getBackground();\n            if (gradientColors.length == 1) {\n                if (gradientColors[0] != null)\n                    gc.setBackground(gradientColors[0]);\n                gc.fillRectangle(0, 0, rect.width, rect.height);\n            } else {\n                final Color oldForeground = gc.getForeground();\n                Color lastColor = gradientColors[0];\n                if (lastColor == null)\n                    lastColor = oldBackground;\n                int pos = 0;\n                for (int i = 0; i < gradientPercents.length; ++i) {\n                    gc.setForeground(lastColor);\n                    lastColor = gradientColors[i + 1];\n                    if (lastColor == null)\n                        lastColor = oldBackground;\n                    gc.setBackground(lastColor);\n                    if (gradientVertical) {\n                        final int gradientHeight = (gradientPercents[i] * rect.height / 100) - pos;\n                        gc.fillGradientRectangle(0, pos, rect.width, gradientHeight, true);\n                        pos += gradientHeight;\n                    } else {\n                        final int gradientWidth = (gradientPercents[i] * rect.width / 100) - pos;\n                        gc.fillGradientRectangle(pos, 0, gradientWidth, rect.height, false);\n                        pos += gradientWidth;\n                    }\n                }\n                if (gradientVertical && pos < rect.height) {\n                    gc.setBackground(getBackground());\n                    gc.fillRectangle(0, pos, rect.width, rect.height - pos);\n                }\n                if (!gradientVertical && pos < rect.width) {\n                    gc.setBackground(getBackground());\n                    gc.fillRectangle(pos, 0, rect.width - pos, rect.height);\n                }\n                gc.setForeground(oldForeground);\n            }\n            gc.setBackground(oldBackground);\n        } else {\n            if ((getStyle() & SWT.NO_BACKGROUND) != 0) {\n                gc.setBackground(getBackground());\n                gc.fillRectangle(rect);\n            }\n        }\n    } catch (SWTException e) {\n        if ((getStyle() & SWT.NO_BACKGROUND) != 0) {\n            gc.setBackground(getBackground());\n            gc.fillRectangle(rect);\n        }\n    }\n    \n    int style = getStyle();\n    if ((style & SWT.SHADOW_IN) != 0 || (style & SWT.SHADOW_OUT) != 0) {\n        paintBorder(gc, rect);\n    }\n    \n    if (img != null) {\n        Rectangle imageRect = img.getBounds();\n        gc.drawImage(img, 0, 0, imageRect.width, imageRect.height, x, (rect.height - imageRect.height) / 2, imageRect.width, imageRect.height);\n        x += imageRect.width + GAP;\n        extent.x -= imageRect.width + GAP;\n    }\n    \n    if (lines != null) {\n        int lineHeight = gc.getFontMetrics().getHeight();\n        int textHeight = lines.length * lineHeight;\n        int lineY = Math.max(vIndent, rect.y + (rect.height - textHeight) / 2);\n        gc.setForeground(getForeground());\n        for (int i = 0; i < lines.length; i++) {\n            int lineX = x;\n            if (lines.length > 1) {\n                if (align == SWT.CENTER) {\n                    int lineWidth = gc.textExtent(lines[i], DRAW_FLAGS).x;\n                    lineX = x + Math.max(0, (extent.x - lineWidth) / 2);\n                }\n                if (align == SWT.RIGHT) {\n                    int lineWidth = gc.textExtent(lines[i], DRAW_FLAGS).x;\n                    lineX = Math.max(x, rect.x + rect.width - hIndent - lineWidth);\n                }\n            }\n            gc.drawText(lines[i], lineX, lineY, DRAW_FLAGS);\n            lineY += lineHeight;\n        }\n    }\n}",
			"comments":"// shorten the text\n// determine horizontal position\n// draw a background image behind the text\n// draw a background image behind the text\n// tile image to fill space\n// draw a gradient behind the text\n// draw border\n// draw the image\n// draw the text\n",
			"methodName":"void onPaint(PaintEvent event)"
		},
		"public Point computeSize(int wHint, int hHint, boolean changed)":{
			"methodBody":"{\n    checkWidget();\n    Point e = getTotalSize(image, text);\n    if (wHint == SWT.DEFAULT) {\n        e.x += 2 * hIndent;\n    } else {\n        e.x = wHint;\n    }\n    if (hHint == SWT.DEFAULT) {\n        e.y += 2 * vIndent;\n    } else {\n        e.y = hHint;\n    }\n    return e;\n}",
			"comments":"",
			"methodName":"public Point computeSize(int wHint, int hHint, boolean changed)"
		},
		"public void setBackground(Color color)":{
			"methodBody":"{\n    super.setBackground(color);\n    \n    if (color != null && backgroundImage == null && gradientColors == null && gradientPercents == null) {\n        Color background = getBackground();\n        if (color.equals(background)) {\n            return;\n        }\n    }\n    backgroundImage = null;\n    gradientColors = null;\n    gradientPercents = null;\n    redraw();\n}",
			"comments":"// Are these settings the same as before?\n",
			"methodName":"public void setBackground(Color color)"
		},
		"private String[] splitString(String text)":{
			"methodBody":"{\n    String[] lines = new String[1];\n    int start = 0, pos;\n    do {\n        pos = text.indexOf('\\n', start);\n        if (pos == -1) {\n            lines[lines.length - 1] = text.substring(start);\n        } else {\n            boolean crlf = (pos > 0) && (text.charAt(pos - 1) == '\\r');\n            lines[lines.length - 1] = text.substring(start, pos - (crlf ? 1 : 0));\n            start = pos + 1;\n            String[] newLines = new String[lines.length + 1];\n            System.arraycopy(lines, 0, newLines, 0, lines.length);\n            lines = newLines;\n        }\n    } while (pos != -1);\n    return lines;\n}",
			"comments":"",
			"methodName":"private String[] splitString(String text)"
		},
		"public void getState(AccessibleControlEvent e)":{
			"methodBody":"{\n    e.detail = ACC.STATE_READONLY;\n}",
			"comments":"",
			"methodName":"public void getState(AccessibleControlEvent e)"
		},
		"public void setAlignment(int align)":{
			"methodBody":"{\n    checkWidget();\n    if (align != SWT.LEFT && align != SWT.RIGHT && align != SWT.CENTER) {\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    }\n    if (this.align != align) {\n        this.align = align;\n        redraw();\n    }\n}",
			"comments":"/**\n* Set the alignment of the CLabel.\n* Use the values LEFT, CENTER and RIGHT to align image and text within the available space.\n*\n* @param align the alignment style of LEFT, RIGHT or CENTER\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the value of align is not one of SWT.LEFT, SWT.RIGHT or SWT.CENTER</li>\n* </ul>\n*/\n",
			"methodName":"public void setAlignment(int align)"
		},
		"protected String shortenText(GC gc, String t, int width)":{
			"methodBody":"{\n    if (t == null)\n        return null;\n    int w = gc.textExtent(ELLIPSIS, DRAW_FLAGS).x;\n    int l = t.length();\n    int pivot = l / 2;\n    int s = pivot;\n    int e = pivot + 1;\n    while (s >= 0 && e < l) {\n        String s1 = t.substring(0, s);\n        String s2 = t.substring(e, l);\n        int l1 = gc.textExtent(s1, DRAW_FLAGS).x;\n        int l2 = gc.textExtent(s2, DRAW_FLAGS).x;\n        if (l1 + w + l2 < width) {\n            t = s1 + ELLIPSIS + s2;\n            break;\n        }\n        s--;\n        e++;\n    }\n    return t;\n}",
			"comments":"/**\n* Shorten the given text <code>t</code> so that its length doesn't exceed\n* the given width. The default implementation replaces characters in the\n* center of the original string with an ellipsis (\"...\").\n* Override if you need a different strategy.\n*\n* @param gc the gc to use for text measurement\n* @param t the text to shorten\n* @param width the width to shorten the text to, in pixels\n* @return the shortened text\n*/\n",
			"methodName":"protected String shortenText(GC gc, String t, int width)"
		},
		"public void getChildCount(AccessibleControlEvent e)":{
			"methodBody":"{\n    e.detail = 0;\n}",
			"comments":"",
			"methodName":"public void getChildCount(AccessibleControlEvent e)"
		},
		"public Image getImage()":{
			"methodBody":"{\n    \n    return image;\n}",
			"comments":"/**\n* Return the CLabel's image or <code>null</code>.\n*\n* @return the image of the label or null\n*/\n//checkWidget();\n",
			"methodName":"public Image getImage()"
		},
		"public void setImage(Image image)":{
			"methodBody":"{\n    checkWidget();\n    if (image != this.image) {\n        this.image = image;\n        redraw();\n    }\n}",
			"comments":"/**\n* Set the label's Image.\n* The value <code>null</code> clears it.\n*\n* @param image the image to be displayed in the label or null\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setImage(Image image)"
		},
		"public void getLocation(AccessibleControlEvent e)":{
			"methodBody":"{\n    Rectangle rect = getDisplay().map(getParent(), null, getBounds());\n    e.x = rect.x;\n    e.y = rect.y;\n    e.width = rect.width;\n    e.height = rect.height;\n}",
			"comments":"",
			"methodName":"public void getLocation(AccessibleControlEvent e)"
		},
		"public void setBackground(Color[] colors, int[] percents)":{
			"methodBody":"{\n    setBackground(colors, percents, false);\n}",
			"comments":"/**\n* Specify a gradient of colours to be drawn in the background of the CLabel.\n* <p>For example, to draw a gradient that varies from dark blue to blue and then to\n* white and stays white for the right half of the label, use the following call\n* to setBackground:</p>\n* <pre>\n*\tclabel.setBackground(new Color[]{display.getSystemColor(SWT.COLOR_DARK_BLUE),\n*\t\t                           display.getSystemColor(SWT.COLOR_BLUE),\n*\t\t                           display.getSystemColor(SWT.COLOR_WHITE),\n*\t\t                           display.getSystemColor(SWT.COLOR_WHITE)},\n*\t\t               new int[] {25, 50, 100});\n* </pre>\n*\n* @param colors an array of Color that specifies the colors to appear in the gradient\n*               in order of appearance from left to right;  The value <code>null</code>\n*               clears the background gradient; the value <code>null</code> can be used\n*               inside the array of Color to specify the background color.\n* @param percents an array of integers between 0 and 100 specifying the percent of the width\n*                 of the widget at which the color should change; the size of the percents\n*                 array must be one less than the size of the colors array.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the values of colors and percents are not consistent</li>\n* </ul>\n*/\n",
			"methodName":"public void setBackground(Color[] colors, int[] percents)"
		},
		"void onDispose(DisposeEvent event)":{
			"methodBody":"{\n    gradientColors = null;\n    gradientPercents = null;\n    backgroundImage = null;\n    text = null;\n    image = null;\n    appToolTipText = null;\n}",
			"comments":"",
			"methodName":"void onDispose(DisposeEvent event)"
		},
		"void onMnemonic(TraverseEvent event)":{
			"methodBody":"{\n    char mnemonic = _findMnemonic(text);\n    if (mnemonic == '\\0')\n        return;\n    if (Character.toUpperCase(event.character) != Character.toUpperCase(mnemonic))\n        return;\n    Composite control = this.getParent();\n    while (control != null) {\n        Control[] children = control.getChildren();\n        int index = 0;\n        while (index < children.length) {\n            if (children[index] == this)\n                break;\n            index++;\n        }\n        index++;\n        if (index < children.length) {\n            if (children[index].setFocus()) {\n                event.doit = true;\n                event.detail = SWT.TRAVERSE_NONE;\n            }\n        }\n        control = control.getParent();\n    }\n}",
			"comments":"",
			"methodName":"void onMnemonic(TraverseEvent event)"
		},
		"public void setBackground(Image image)":{
			"methodBody":"{\n    checkWidget();\n    if (image == backgroundImage)\n        return;\n    if (image != null) {\n        gradientColors = null;\n        gradientPercents = null;\n    }\n    backgroundImage = image;\n    redraw();\n}",
			"comments":"/**\n* Set the image to be drawn in the background of the label.\n*\n* @param image the image to be drawn in the background\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n",
			"methodName":"public void setBackground(Image image)"
		},
		"public void widgetDisposed(DisposeEvent event)":{
			"methodBody":"{\n    onDispose(event);\n}",
			"comments":"",
			"methodName":"public void widgetDisposed(DisposeEvent event)"
		},
		"public int getStyle()":{
			"methodBody":"{\n    int style = super.getStyle();\n    switch(align) {\n        case SWT.RIGHT:\n            style |= SWT.RIGHT;\n            break;\n        case SWT.CENTER:\n            style |= SWT.CENTER;\n            break;\n        case SWT.LEFT:\n            style |= SWT.LEFT;\n            break;\n    }\n    return style;\n}",
			"comments":"",
			"methodName":"public int getStyle()"
		},
		"public void setFont(Font font)":{
			"methodBody":"{\n    super.setFont(font);\n    redraw();\n}",
			"comments":"",
			"methodName":"public void setFont(Font font)"
		},
		"public void getName(AccessibleEvent e)":{
			"methodBody":"{\n    e.result = getText();\n}",
			"comments":"",
			"methodName":"public void getName(AccessibleEvent e)"
		},
		"public String getText()":{
			"methodBody":"{\n    \n    return text;\n}",
			"comments":"/**\n* Return the Label's text.\n*\n* @return the text of the label or null\n*/\n//checkWidget();\n",
			"methodName":"public String getText()"
		},
		"public String getToolTipText()":{
			"methodBody":"{\n    checkWidget();\n    return appToolTipText;\n}",
			"comments":"",
			"methodName":"public String getToolTipText()"
		},
		"public void setText(String text)":{
			"methodBody":"{\n    checkWidget();\n    \n    if (text == null)\n        text = \"\";\n    if (!text.equals(this.text)) {\n        this.text = text;\n        redraw();\n    }\n}",
			"comments":"/**\n* Set the label's text.\n* The value <code>null</code> clears it.\n*\n* @param text the text to be displayed in the label or null\n*\n* @exception SWTException <ul>\n*    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*/\n//$NON-NLS-1$\n",
			"methodName":"public void setText(String text)"
		},
		"private Point getTotalSize(Image image, String text)":{
			"methodBody":"{\n    Point size = new Point(0, 0);\n    if (image != null) {\n        Rectangle r = image.getBounds();\n        size.x += r.width;\n        size.y += r.height;\n    }\n    GC gc = new GC(this);\n    if (text != null && text.length() > 0) {\n        Point e = gc.textExtent(text, DRAW_FLAGS);\n        size.x += e.x;\n        size.y = Math.max(size.y, e.y);\n        if (image != null)\n            size.x += GAP;\n    } else {\n        size.y = Math.max(size.y, gc.getFontMetrics().getHeight());\n    }\n    gc.dispose();\n    return size;\n}",
			"comments":"/**\n* Compute the minimum size.\n*/\n",
			"methodName":"private Point getTotalSize(Image image, String text)"
		},
		"public void setToolTipText(String string)":{
			"methodBody":"{\n    super.setToolTipText(string);\n    appToolTipText = super.getToolTipText();\n}",
			"comments":"",
			"methodName":"public void setToolTipText(String string)"
		}
	},
	"ClassORInterfaceName":[
		"CLabel"
	]
}
