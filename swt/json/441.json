{
	"variables":[
		"msg",
		"eventQueue",
		"windowCallback",
		"windowProc",
		"threadId",
		"windowClass",
		"windowShadowClass",
		"WindowClassCount",
		"WindowName",
		"WindowShadowName",
		"eventTable",
		"filterTable",
		"freeSlot",
		"indexTable",
		"controlTable",
		"GROW_SIZE",
		"SWT_OBJECT_INDEX",
		"USE_PROPERTY",
		"focusEvent",
		"focusControl",
		"bars",
		"popups",
		"items",
		"ID_START",
		"msgFilterCallback",
		"msgFilterProc",
		"filterHook",
		"hookMsg",
		"ignoreMsgFilter",
		"foregroundIdleCallback",
		"foregroundIdleProc",
		"idleHook",
		"getMsgCallback",
		"embeddedCallback",
		"getMsgProc",
		"msgHook",
		"embeddedHwnd",
		"embeddedProc",
		"AWT_WINDOW_CLASS",
		"synchronizer",
		"thread",
		"disposeList",
		"tray",
		"nextTrayId",
		"timerIds",
		"timerList",
		"nextTimerId",
		"lastKey",
		"lastAscii",
		"lastMouse",
		"lastVirtual",
		"lastNull",
		"lastDead",
		"keyboard",
		"accelKeyHit",
		"mnemonicKeyHit",
		"lockActiveWindow",
		"captureChanged",
		"ignoreRestoreFocus",
		"lastHittestControl",
		"lastHittest",
		"messageCallback",
		"hwndMessage",
		"messageProc",
		"systemFonts",
		"errorIcon",
		"infoIcon",
		"questionIcon",
		"warningIcon",
		"cursors",
		"imageList",
		"toolImageList",
		"toolHotImageList",
		"toolDisabledImageList",
		"lpCustColors",
		"data",
		"keys",
		"values",
		"KeyTable",
		"Default",
		"Displays",
		"monitors",
		"monitorCount",
		"modalShells",
		"modalDialogShell",
		"TrimEnabled",
		"SWT_GETACCELCOUNT",
		"SWT_GETACCEL",
		"SWT_KEYMSG",
		"SWT_DESTROY",
		"SWT_TRAYICONMSG",
		"SWT_NULL",
		"SWT_TASKBARCREATED",
		"hitCount",
		"PACKAGE_PREFIX",
		"device",
		"length",
		"i",
		"index",
		"newBars",
		"length",
		"newIndexTable",
		"newControlTable",
		"i",
		"oldSlot",
		"i",
		"newItems",
		"length",
		"i",
		"index",
		"newPopups",
		"i",
		"result",
		"result",
		"i",
		"index",
		"length",
		"shells",
		"i",
		"upper",
		"event",
		"bm",
		"imgWidth",
		"imgHeight",
		"hDC",
		"srcHdc",
		"oldSrcBitmap",
		"memHdc",
		"bmiHeader",
		"bmi",
		"pBits",
		"memDib",
		"oldMemBitmap",
		"dibBM",
		"sizeInBytes",
		"red",
		"green",
		"blue",
		"color",
		"srcData",
		"y",
		"dp",
		"x",
		"y",
		"dp",
		"ap",
		"x",
		"y",
		"dp",
		"x",
		"srcWidth",
		"srcHeight",
		"mask",
		"ap",
		"y",
		"x",
		"hMask",
		"hdc",
		"hdc1",
		"hdc2",
		"hMask2",
		"i",
		"i",
		"newDisposeList",
		"i",
		"menu",
		"keyMsg",
		"hHeap",
		"message",
		"control",
		"control",
		"control",
		"i",
		"display",
		"control",
		"width",
		"height",
		"x",
		"y",
		"width",
		"height",
		"rect",
		"width",
		"height",
		"x",
		"y",
		"width",
		"height",
		"index",
		"control",
		"pt",
		"pt",
		"name",
		"index",
		"i",
		"pvParam",
		"buffer1",
		"phkResult",
		"result",
		"depth",
		"lpcbData",
		"lpData",
		"buffer2",
		"i",
		"length",
		"list",
		"size",
		"newList",
		"list",
		"i",
		"length",
		"list",
		"size",
		"newList",
		"list",
		"i",
		"length",
		"list",
		"size",
		"newList",
		"list",
		"i",
		"length",
		"list",
		"size",
		"newList",
		"list",
		"index",
		"shell",
		"callback",
		"lpfnEnum",
		"result",
		"hInstance",
		"msg",
		"hHeap",
		"keyMsg",
		"monitor",
		"width",
		"height",
		"rect",
		"callback",
		"lpfnEnum",
		"result",
		"lpmi",
		"i",
		"monitor",
		"count",
		"i",
		"control",
		"index",
		"result",
		"i",
		"control",
		"pixel",
		"hFont",
		"hIcon",
		"hDC",
		"mask",
		"hHeap",
		"hInstance",
		"lpWndClass",
		"byteCount",
		"systemFont",
		"info",
		"i",
		"xMouseActive",
		"key",
		"phKey",
		"result",
		"lpValueName",
		"lpcbData",
		"lpData",
		"hwndFrom",
		"hwndTo",
		"point",
		"hwndFrom",
		"hwndTo",
		"rect",
		"key",
		"buffer",
		"unicode",
		"cp",
		"count",
		"consumed",
		"keyMsg",
		"control",
		"flags",
		"hHeap",
		"items",
		"i",
		"item",
		"modal",
		"hwndModal",
		"hwndPopup",
		"event",
		"items",
		"i",
		"item",
		"newMonitors",
		"lpmi",
		"monitor",
		"msg",
		"flags",
		"type",
		"inputs",
		"key",
		"hHeap",
		"pInputs",
		"result",
		"inputs",
		"hHeap",
		"pInputs",
		"result",
		"index",
		"length",
		"newQueue",
		"i",
		"newDisplays",
		"shells",
		"i",
		"shell",
		"i",
		"hHeap",
		"hInstance",
		"lpWndClass",
		"i",
		"i",
		"i",
		"length",
		"j",
		"i",
		"length",
		"j",
		"i",
		"length",
		"j",
		"i",
		"length",
		"j",
		"i",
		"control",
		"index",
		"i",
		"event",
		"length",
		"widget",
		"item",
		"result",
		"menu",
		"length",
		"index",
		"runnable",
		"index",
		"newKeys",
		"newValues",
		"i",
		"newKeys",
		"newValues",
		"shells",
		"i",
		"index",
		"length",
		"newModalShells",
		"shells",
		"i",
		"i",
		"result",
		"result",
		"hFont",
		"length",
		"index",
		"timerId",
		"newTimerList",
		"newTimerIds",
		"newTimerID",
		"result",
		"i",
		"i",
		"msg",
		"flags",
		"shells",
		"i",
		"shell",
		"oldFont",
		"systemFont",
		"info",
		"length",
		"newFonts",
		"newFont",
		"shells",
		"i",
		"shell",
		"buffer",
		"index",
		"control",
		"length",
		"i",
		"count",
		"result",
		"j",
		"OS",
		"USE_PROPERTY",
		"SWT_OBJECT_INDEX",
		"OS",
		"SWT_OBJECT_INDEX",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"SWT",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"DeviceFinder",
		"device",
		"device",
		"device",
		"CurrentDevice",
		"device",
		"data",
		"OS",
		"bars",
		"bars",
		"bars",
		"i",
		"length",
		"i",
		"bars",
		"i",
		"menu",
		"index",
		"length",
		"bars",
		"index",
		"index",
		"index",
		"length",
		"length",
		"System",
		"bars",
		"newBars",
		"length",
		"bars",
		"newBars",
		"bars",
		"index",
		"menu",
		"handle",
		"freeSlot",
		"freeSlot",
		"indexTable",
		"GROW_SIZE",
		"length",
		"length",
		"System",
		"indexTable",
		"newIndexTable",
		"freeSlot",
		"System",
		"controlTable",
		"newControlTable",
		"freeSlot",
		"freeSlot",
		"i",
		"length",
		"i",
		"newIndexTable",
		"i",
		"i",
		"newIndexTable",
		"length",
		"indexTable",
		"newIndexTable",
		"controlTable",
		"newControlTable",
		"USE_PROPERTY",
		"OS",
		"handle",
		"SWT_OBJECT_INDEX",
		"freeSlot",
		"OS",
		"handle",
		"OS",
		"freeSlot",
		"freeSlot",
		"freeSlot",
		"indexTable",
		"oldSlot",
		"indexTable",
		"oldSlot",
		"controlTable",
		"oldSlot",
		"control",
		"listener",
		"SWT",
		"filterTable",
		"filterTable",
		"filterTable",
		"eventType",
		"listener",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"eventTable",
		"eventType",
		"listener",
		"items",
		"items",
		"i",
		"items",
		"i",
		"items",
		"i",
		"item",
		"i",
		"ID_START",
		"items",
		"i",
		"item",
		"item",
		"items",
		"ID_START",
		"items",
		"newItems",
		"items",
		"item",
		"System",
		"items",
		"newItems",
		"items",
		"items",
		"newItems",
		"popups",
		"popups",
		"popups",
		"i",
		"length",
		"i",
		"popups",
		"i",
		"menu",
		"index",
		"length",
		"popups",
		"index",
		"index",
		"index",
		"length",
		"length",
		"System",
		"popups",
		"newPopups",
		"length",
		"popups",
		"newPopups",
		"popups",
		"index",
		"menu",
		"OS",
		"i",
		"keyboard",
		"i",
		"keyboard",
		"i",
		"OS",
		"keyboard",
		"OS",
		"OS",
		"key",
		"key",
		"keyboard",
		"result",
		"result",
		"OS",
		"key",
		"key",
		"keyboard",
		"result",
		"result",
		"SWT",
		"synchronizer",
		"runnable",
		"OS",
		"OS",
		"SWT",
		"thread",
		"SWT",
		"thread",
		"Thread",
		"SWT",
		"SWT",
		"i",
		"Displays",
		"i",
		"Displays",
		"i",
		"multiple",
		"SWT",
		"SWT",
		"Displays",
		"i",
		"thread",
		"SWT",
		"SWT",
		"modalShells",
		"modalShells",
		"index",
		"length",
		"modalShells",
		"index",
		"shell",
		"modalShells",
		"index",
		"index",
		"index",
		"length",
		"System",
		"modalShells",
		"index",
		"modalShells",
		"index",
		"length",
		"index",
		"modalShells",
		"length",
		"index",
		"modalShells",
		"modalShells",
		"i",
		"shells",
		"i",
		"shells",
		"i",
		"OS",
		"key",
		"upper",
		"upper",
		"upper",
		"key",
		"SWT",
		"event",
		"event",
		"thread",
		"Thread",
		"data",
		"Default",
		"Default",
		"OS",
		"hBitmap",
		"BITMAP",
		"bm",
		"bm",
		"bm",
		"OS",
		"OS",
		"hDC",
		"OS",
		"srcHdc",
		"hBitmap",
		"OS",
		"hDC",
		"bmiHeader",
		"BITMAPINFOHEADER",
		"bmiHeader",
		"imgWidth",
		"bmiHeader",
		"imgHeight",
		"bmiHeader",
		"bmiHeader",
		"bmiHeader",
		"OS",
		"BITMAPINFOHEADER",
		"OS",
		"bmi",
		"bmiHeader",
		"BITMAPINFOHEADER",
		"OS",
		"bmi",
		"OS",
		"pBits",
		"memDib",
		"SWT",
		"SWT",
		"OS",
		"memHdc",
		"memDib",
		"OS",
		"memDib",
		"BITMAP",
		"dibBM",
		"dibBM",
		"dibBM",
		"OS",
		"memHdc",
		"imgWidth",
		"imgHeight",
		"srcHdc",
		"OS",
		"transparentPixel",
		"bm",
		"OS",
		"srcHdc",
		"transparentPixel",
		"color",
		"blue",
		"color",
		"green",
		"color",
		"red",
		"color",
		"bm",
		"blue",
		"transparentPixel",
		"green",
		"transparentPixel",
		"red",
		"transparentPixel",
		"blue",
		"transparentPixel",
		"green",
		"transparentPixel",
		"red",
		"transparentPixel",
		"blue",
		"transparentPixel",
		"green",
		"transparentPixel",
		"red",
		"transparentPixel",
		"OS",
		"srcHdc",
		"oldSrcBitmap",
		"OS",
		"memHdc",
		"oldMemBitmap",
		"OS",
		"srcHdc",
		"OS",
		"memHdc",
		"OS",
		"hDC",
		"sizeInBytes",
		"OS",
		"srcData",
		"pBits",
		"sizeInBytes",
		"alpha",
		"y",
		"imgHeight",
		"y",
		"x",
		"imgWidth",
		"x",
		"srcData",
		"dp",
		"alpha",
		"dp",
		"alphaData",
		"y",
		"imgHeight",
		"y",
		"x",
		"imgWidth",
		"x",
		"srcData",
		"dp",
		"alphaData",
		"ap",
		"dp",
		"transparentPixel",
		"y",
		"imgHeight",
		"y",
		"x",
		"imgWidth",
		"x",
		"srcData",
		"dp",
		"blue",
		"srcData",
		"dp",
		"green",
		"srcData",
		"dp",
		"red",
		"srcData",
		"dp",
		"srcData",
		"dp",
		"dp",
		"OS",
		"pBits",
		"srcData",
		"sizeInBytes",
		"memDib",
		"data",
		"data",
		"ImageData",
		"srcWidth",
		"srcHeight",
		"y",
		"mask",
		"y",
		"x",
		"mask",
		"x",
		"mask",
		"x",
		"y",
		"data",
		"ap",
		"OS",
		"srcWidth",
		"srcHeight",
		"mask",
		"srcWidth",
		"destWidth",
		"srcHeight",
		"destHeight",
		"OS",
		"OS",
		"hdc",
		"OS",
		"hdc1",
		"hMask",
		"OS",
		"hdc",
		"OS",
		"destWidth",
		"destHeight",
		"OS",
		"hdc2",
		"hMask2",
		"OS",
		"OS",
		"hdc2",
		"OS",
		"OS",
		"hdc2",
		"destWidth",
		"destHeight",
		"hdc1",
		"srcWidth",
		"srcHeight",
		"OS",
		"OS",
		"hdc1",
		"OS",
		"hdc2",
		"OS",
		"hdc",
		"OS",
		"hMask",
		"hMask",
		"hMask2",
		"hMask",
		"i",
		"Displays",
		"i",
		"display",
		"Displays",
		"i",
		"Displays",
		"i",
		"Default",
		"Default",
		"disposeList",
		"disposeList",
		"i",
		"disposeList",
		"i",
		"disposeList",
		"i",
		"disposeList",
		"i",
		"runnable",
		"disposeList",
		"System",
		"disposeList",
		"newDisposeList",
		"disposeList",
		"newDisposeList",
		"disposeList",
		"runnable",
		"disposeList",
		"newDisposeList",
		"bars",
		"i",
		"bars",
		"i",
		"bars",
		"i",
		"menu",
		"menu",
		"menu",
		"bars",
		"msg",
		"SWT_KEYMSG",
		"OS",
		"keyMsg",
		"lParam",
		"MSG",
		"OS",
		"keyMsg",
		"OS",
		"keyMsg",
		"OS",
		"OS",
		"hHeap",
		"lParam",
		"SWT_DESTROY",
		"OS",
		"hwnd",
		"embeddedCallback",
		"embeddedCallback",
		"getMsgCallback",
		"getMsgCallback",
		"embeddedCallback",
		"getMsgCallback",
		"embeddedProc",
		"getMsgProc",
		"OS",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"SWT",
		"code",
		"filterTable",
		"filterTable",
		"event",
		"filterTable",
		"filterTable",
		"eventType",
		"msg",
		"OS",
		"message",
		"message",
		"OS",
		"msg",
		"control",
		"msg",
		"control",
		"msg",
		"control",
		"msg",
		"control",
		"lastAscii",
		"lastKey",
		"lastVirtual",
		"lastNull",
		"lastDead",
		"handle",
		"handle",
		"control",
		"control",
		"handle",
		"OS",
		"handle",
		"handle",
		"handle",
		"control",
		"control",
		"id",
		"code",
		"OS",
		"idleHook",
		"code",
		"wParam",
		"lParam",
		"i",
		"Displays",
		"i",
		"Displays",
		"i",
		"display",
		"display",
		"thread",
		"display",
		"OS",
		"control",
		"control",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"width",
		"height",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"x",
		"y",
		"width",
		"height",
		"Thread",
		"OS",
		"OS",
		"OS",
		"OS",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"width",
		"height",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"x",
		"y",
		"width",
		"height",
		"handle",
		"USE_PROPERTY",
		"index",
		"OS",
		"handle",
		"SWT_OBJECT_INDEX",
		"index",
		"OS",
		"handle",
		"OS",
		"index",
		"index",
		"controlTable",
		"controlTable",
		"index",
		"control",
		"control",
		"handle",
		"control",
		"OS",
		"pt",
		"OS",
		"pt",
		"OS",
		"pt",
		"pt",
		"pt",
		"OS",
		"OS",
		"OS",
		"OS",
		"Default",
		"Default",
		"Default",
		"clazz",
		"name",
		"name",
		"index",
		"PACKAGE_PREFIX",
		"key",
		"SWT",
		"keys",
		"i",
		"keys",
		"i",
		"keys",
		"i",
		"key",
		"values",
		"i",
		"data",
		"SWT",
		"OS",
		"focusControl",
		"focusControl",
		"focusControl",
		"OS",
		"pvParam",
		"HIGHCONTRAST",
		"OS",
		"OS",
		"pvParam",
		"pvParam",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"buffer1",
		"OS",
		"phkResult",
		"result",
		"lpcbData",
		"result",
		"OS",
		"phkResult",
		"buffer2",
		"lpData",
		"lpcbData",
		"result",
		"depth",
		"Integer",
		"lpData",
		"lpData",
		"OS",
		"phkResult",
		"depth",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"imageList",
		"imageList",
		"imageList",
		"i",
		"length",
		"imageList",
		"i",
		"list",
		"list",
		"size",
		"width",
		"size",
		"height",
		"list",
		"style",
		"list",
		"list",
		"i",
		"i",
		"length",
		"length",
		"System",
		"imageList",
		"newList",
		"length",
		"imageList",
		"newList",
		"style",
		"imageList",
		"i",
		"list",
		"list",
		"list",
		"toolImageList",
		"toolImageList",
		"toolImageList",
		"i",
		"length",
		"toolImageList",
		"i",
		"list",
		"list",
		"size",
		"width",
		"size",
		"height",
		"list",
		"style",
		"list",
		"list",
		"i",
		"i",
		"length",
		"length",
		"System",
		"toolImageList",
		"newList",
		"length",
		"toolImageList",
		"newList",
		"style",
		"toolImageList",
		"i",
		"list",
		"list",
		"list",
		"toolDisabledImageList",
		"toolDisabledImageList",
		"toolDisabledImageList",
		"i",
		"length",
		"toolDisabledImageList",
		"i",
		"list",
		"list",
		"size",
		"width",
		"size",
		"height",
		"list",
		"style",
		"list",
		"list",
		"i",
		"i",
		"length",
		"length",
		"System",
		"toolDisabledImageList",
		"newList",
		"length",
		"toolDisabledImageList",
		"newList",
		"style",
		"toolDisabledImageList",
		"i",
		"list",
		"list",
		"list",
		"toolHotImageList",
		"toolHotImageList",
		"toolHotImageList",
		"i",
		"length",
		"toolHotImageList",
		"i",
		"list",
		"list",
		"size",
		"width",
		"size",
		"height",
		"list",
		"style",
		"list",
		"list",
		"i",
		"i",
		"length",
		"length",
		"System",
		"toolHotImageList",
		"newList",
		"length",
		"toolHotImageList",
		"newList",
		"style",
		"toolHotImageList",
		"i",
		"list",
		"list",
		"list",
		"OS",
		"OS",
		"OS",
		"items",
		"id",
		"id",
		"ID_START",
		"id",
		"id",
		"items",
		"items",
		"id",
		"synchronizer",
		"modalShells",
		"modalShells",
		"index",
		"modalShells",
		"index",
		"shell",
		"shell",
		"modalDialogShell",
		"modalDialogShell",
		"modalDialogShell",
		"modalDialogShell",
		"OS",
		"OS",
		"OS",
		"monitors",
		"callback",
		"lpfnEnum",
		"SWT",
		"SWT",
		"OS",
		"lpfnEnum",
		"callback",
		"monitorCount",
		"System",
		"monitors",
		"result",
		"monitorCount",
		"monitors",
		"monitorCount",
		"result",
		"embeddedHwnd",
		"OS",
		"embeddedHwnd",
		"OS",
		"windowClass",
		"OS",
		"hInstance",
		"embeddedCallback",
		"embeddedProc",
		"embeddedCallback",
		"embeddedProc",
		"SWT",
		"OS",
		"embeddedHwnd",
		"OS",
		"embeddedProc",
		"code",
		"wParam",
		"OS",
		"OS",
		"msg",
		"lParam",
		"MSG",
		"msg",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"hHeap",
		"OS",
		"MSG",
		"OS",
		"keyMsg",
		"msg",
		"MSG",
		"OS",
		"hwndMessage",
		"SWT_KEYMSG",
		"wParam",
		"keyMsg",
		"msg",
		"OS",
		"OS",
		"lParam",
		"msg",
		"MSG",
		"OS",
		"msgHook",
		"code",
		"wParam",
		"lParam",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"monitor",
		"width",
		"monitor",
		"height",
		"OS",
		"OS",
		"rect",
		"monitor",
		"rect",
		"monitor",
		"rect",
		"monitor",
		"rect",
		"rect",
		"monitor",
		"rect",
		"rect",
		"monitor",
		"monitors",
		"callback",
		"lpfnEnum",
		"SWT",
		"SWT",
		"OS",
		"lpfnEnum",
		"callback",
		"lpmi",
		"MONITORINFO",
		"i",
		"monitorCount",
		"i",
		"monitors",
		"i",
		"OS",
		"monitors",
		"i",
		"lpmi",
		"lpmi",
		"OS",
		"result",
		"monitor",
		"monitors",
		"monitorCount",
		"result",
		"i",
		"controlTable",
		"i",
		"controlTable",
		"i",
		"control",
		"control",
		"count",
		"count",
		"i",
		"controlTable",
		"i",
		"controlTable",
		"i",
		"control",
		"control",
		"result",
		"index",
		"control",
		"result",
		"SWT",
		"synchronizer",
		"id",
		"SWT",
		"pixel",
		"OS",
		"OS",
		"SWT",
		"pixel",
		"OS",
		"OS",
		"SWT",
		"pixel",
		"OS",
		"OS",
		"SWT",
		"pixel",
		"OS",
		"OS",
		"SWT",
		"pixel",
		"OS",
		"OS",
		"SWT",
		"pixel",
		"OS",
		"OS",
		"SWT",
		"SWT",
		"pixel",
		"OS",
		"OS",
		"SWT",
		"pixel",
		"OS",
		"OS",
		"SWT",
		"pixel",
		"OS",
		"OS",
		"SWT",
		"pixel",
		"OS",
		"OS",
		"SWT",
		"pixel",
		"OS",
		"OS",
		"SWT",
		"pixel",
		"OS",
		"OS",
		"SWT",
		"pixel",
		"OS",
		"OS",
		"SWT",
		"pixel",
		"OS",
		"OS",
		"SWT",
		"pixel",
		"OS",
		"OS",
		"pixel",
		"pixel",
		"OS",
		"OS",
		"SWT",
		"pixel",
		"OS",
		"OS",
		"SWT",
		"pixel",
		"OS",
		"OS",
		"SWT",
		"pixel",
		"OS",
		"OS",
		"pixel",
		"pixel",
		"OS",
		"OS",
		"id",
		"Color",
		"pixel",
		"id",
		"id",
		"cursors",
		"cursors",
		"id",
		"cursors",
		"id",
		"id",
		"cursors",
		"id",
		"Font",
		"hFont",
		"id",
		"SWT",
		"errorIcon",
		"errorIcon",
		"OS",
		"OS",
		"OS",
		"OS",
		"hIcon",
		"errorIcon",
		"SWT",
		"SWT",
		"infoIcon",
		"infoIcon",
		"OS",
		"OS",
		"OS",
		"OS",
		"hIcon",
		"infoIcon",
		"SWT",
		"questionIcon",
		"questionIcon",
		"OS",
		"OS",
		"OS",
		"OS",
		"hIcon",
		"questionIcon",
		"SWT",
		"warningIcon",
		"warningIcon",
		"OS",
		"OS",
		"OS",
		"OS",
		"hIcon",
		"warningIcon",
		"hIcon",
		"Image",
		"SWT",
		"hIcon",
		"tray",
		"tray",
		"tray",
		"SWT",
		"SWT",
		"thread",
		"SWT",
		"SWT",
		"OS",
		"hDC",
		"SWT",
		"SWT",
		"data",
		"SWT",
		"SWT",
		"data",
		"mask",
		"data",
		"data",
		"SWT",
		"OS",
		"data",
		"SWT",
		"data",
		"data",
		"hDC",
		"windowCallback",
		"windowProc",
		"windowCallback",
		"windowProc",
		"SWT",
		"threadId",
		"OS",
		"windowClass",
		"WindowName",
		"WindowClassCount",
		"windowShadowClass",
		"WindowShadowName",
		"WindowClassCount",
		"WindowClassCount",
		"OS",
		"OS",
		"lpWndClass",
		"hInstance",
		"lpWndClass",
		"windowProc",
		"lpWndClass",
		"OS",
		"OS",
		"lpWndClass",
		"OS",
		"OS",
		"windowClass",
		"TCHAR",
		"lpWndClass",
		"OS",
		"hHeap",
		"OS",
		"byteCount",
		"OS",
		"lpWndClass",
		"windowClass",
		"byteCount",
		"OS",
		"lpWndClass",
		"OS",
		"OS",
		"lpWndClass",
		"OS",
		"byteCount",
		"windowShadowClass",
		"TCHAR",
		"lpWndClass",
		"OS",
		"hHeap",
		"OS",
		"byteCount",
		"OS",
		"lpWndClass",
		"windowShadowClass",
		"byteCount",
		"OS",
		"lpWndClass",
		"OS",
		"OS",
		"info",
		"NONCLIENTMETRICS",
		"OS",
		"OS",
		"info",
		"systemFont",
		"OS",
		"OS",
		"info",
		"info",
		"systemFont",
		"systemFont",
		"OS",
		"OS",
		"systemFont",
		"systemFont",
		"OS",
		"OS",
		"systemFont",
		"systemFonts",
		"systemFont",
		"hwndMessage",
		"OS",
		"windowClass",
		"OS",
		"hInstance",
		"messageCallback",
		"messageProc",
		"messageCallback",
		"messageProc",
		"SWT",
		"OS",
		"hwndMessage",
		"OS",
		"messageProc",
		"OS",
		"msgFilterCallback",
		"msgFilterProc",
		"msgFilterCallback",
		"msgFilterProc",
		"SWT",
		"filterHook",
		"OS",
		"OS",
		"msgFilterProc",
		"threadId",
		"OS",
		"foregroundIdleCallback",
		"foregroundIdleProc",
		"foregroundIdleCallback",
		"foregroundIdleProc",
		"SWT",
		"idleHook",
		"OS",
		"OS",
		"foregroundIdleProc",
		"threadId",
		"SWT_TASKBARCREATED",
		"OS",
		"OS",
		"OS",
		"indexTable",
		"GROW_SIZE",
		"controlTable",
		"GROW_SIZE",
		"i",
		"GROW_SIZE",
		"i",
		"indexTable",
		"i",
		"i",
		"indexTable",
		"GROW_SIZE",
		"OS",
		"hDC",
		"OS",
		"OS",
		"key",
		"OS",
		"phKey",
		"result",
		"result",
		"OS",
		"phKey",
		"lpValueName",
		"lpData",
		"lpcbData",
		"result",
		"xMouseActive",
		"lpData",
		"OS",
		"phKey",
		"xMouseActive",
		"thread",
		"Thread",
		"point",
		"SWT",
		"from",
		"to",
		"point",
		"point",
		"from",
		"from",
		"SWT",
		"to",
		"to",
		"SWT",
		"from",
		"from",
		"to",
		"to",
		"point",
		"x",
		"point",
		"y",
		"OS",
		"hwndFrom",
		"hwndTo",
		"point",
		"point",
		"point",
		"rectangle",
		"SWT",
		"from",
		"to",
		"rectangle",
		"rectangle",
		"rectangle",
		"rectangle",
		"from",
		"from",
		"SWT",
		"to",
		"to",
		"SWT",
		"from",
		"from",
		"to",
		"to",
		"rect",
		"x",
		"rect",
		"y",
		"rect",
		"x",
		"width",
		"rect",
		"y",
		"height",
		"OS",
		"hwndFrom",
		"hwndTo",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"rect",
		"ch",
		"OS",
		"ch",
		"ch",
		"key",
		"ch",
		"key",
		"buffer",
		"buffer",
		"key",
		"buffer",
		"buffer",
		"key",
		"buffer",
		"key",
		"codePage",
		"codePage",
		"OS",
		"OS",
		"cp",
		"OS",
		"buffer",
		"buffer",
		"unicode",
		"count",
		"unicode",
		"msg",
		"SWT_KEYMSG",
		"OS",
		"keyMsg",
		"lParam",
		"MSG",
		"keyMsg",
		"control",
		"keyMsg",
		"control",
		"OS",
		"OS",
		"OS",
		"OS",
		"consumed",
		"keyMsg",
		"OS",
		"keyMsg",
		"consumed",
		"OS",
		"keyMsg",
		"OS",
		"keyMsg",
		"keyMsg",
		"OS",
		"OS",
		"flags",
		"consumed",
		"OS",
		"OS",
		"hHeap",
		"lParam",
		"OS",
		"embeddedHwnd",
		"SWT_KEYMSG",
		"wParam",
		"lParam",
		"SWT_TRAYICONMSG",
		"tray",
		"tray",
		"i",
		"items",
		"i",
		"items",
		"i",
		"item",
		"item",
		"wParam",
		"item",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"OS",
		"wParam",
		"modalDialogShell",
		"modalDialogShell",
		"modalDialogShell",
		"modalDialogShell",
		"modalDialogShell",
		"modal",
		"modal",
		"OS",
		"hwndModal",
		"modal",
		"modal",
		"OS",
		"hwndModal",
		"hwndPopup",
		"hwndPopup",
		"modal",
		"hwndPopup",
		"OS",
		"hwndPopup",
		"OS",
		"hwndPopup",
		"OS",
		"wParam",
		"System",
		"OS",
		"SWT",
		"event",
		"event",
		"OS",
		"OS",
		"wParam",
		"msg",
		"SWT_TASKBARCREATED",
		"tray",
		"tray",
		"i",
		"items",
		"i",
		"items",
		"i",
		"item",
		"item",
		"OS",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"monitorCount",
		"monitors",
		"monitors",
		"System",
		"monitors",
		"newMonitors",
		"monitors",
		"monitors",
		"newMonitors",
		"lpmi",
		"MONITORINFO",
		"OS",
		"hmonitor",
		"lpmi",
		"monitor",
		"hmonitor",
		"monitor",
		"lpmi",
		"monitor",
		"lpmi",
		"monitor",
		"lpmi",
		"lpmi",
		"monitor",
		"lpmi",
		"lpmi",
		"monitor",
		"lpmi",
		"monitor",
		"lpmi",
		"monitor",
		"lpmi",
		"lpmi",
		"monitor",
		"lpmi",
		"lpmi",
		"monitors",
		"monitorCount",
		"monitor",
		"ignoreMsgFilter",
		"code",
		"OS",
		"hookMsg",
		"lParam",
		"MSG",
		"hookMsg",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"msg",
		"flags",
		"OS",
		"filterHook",
		"code",
		"wParam",
		"lParam",
		"key",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"SWT",
		"event",
		"SWT",
		"event",
		"type",
		"SWT",
		"SWT",
		"inputs",
		"event",
		"inputs",
		"event",
		"key",
		"SWT",
		"inputs",
		"OS",
		"SWT",
		"inputs",
		"OS",
		"SWT",
		"inputs",
		"OS",
		"SWT",
		"inputs",
		"OS",
		"SWT",
		"inputs",
		"OS",
		"SWT",
		"OS",
		"inputs",
		"OS",
		"key",
		"inputs",
		"OS",
		"key",
		"inputs",
		"inputs",
		"type",
		"SWT",
		"OS",
		"OS",
		"OS",
		"hHeap",
		"OS",
		"INPUT",
		"OS",
		"pInputs",
		"OS",
		"OS",
		"pInputs",
		"inputs",
		"KEYBDINPUT",
		"OS",
		"pInputs",
		"INPUT",
		"OS",
		"hHeap",
		"pInputs",
		"result",
		"SWT",
		"SWT",
		"SWT",
		"type",
		"SWT",
		"inputs",
		"OS",
		"OS",
		"inputs",
		"event",
		"OS",
		"OS",
		"inputs",
		"event",
		"OS",
		"OS",
		"event",
		"inputs",
		"type",
		"SWT",
		"OS",
		"OS",
		"inputs",
		"type",
		"SWT",
		"OS",
		"OS",
		"inputs",
		"type",
		"SWT",
		"OS",
		"OS",
		"OS",
		"OS",
		"hHeap",
		"OS",
		"INPUT",
		"OS",
		"pInputs",
		"OS",
		"OS",
		"pInputs",
		"inputs",
		"MOUSEINPUT",
		"OS",
		"pInputs",
		"INPUT",
		"OS",
		"hHeap",
		"pInputs",
		"result",
		"eventQueue",
		"eventQueue",
		"eventQueue",
		"index",
		"length",
		"eventQueue",
		"index",
		"index",
		"index",
		"length",
		"length",
		"System",
		"eventQueue",
		"newQueue",
		"length",
		"eventQueue",
		"newQueue",
		"eventQueue",
		"index",
		"event",
		"OS",
		"msg",
		"OS",
		"msg",
		"OS",
		"msg",
		"OS",
		"msg",
		"i",
		"Displays",
		"i",
		"Displays",
		"i",
		"Displays",
		"i",
		"display",
		"Displays",
		"System",
		"Displays",
		"newDisplays",
		"Displays",
		"newDisplays",
		"Displays",
		"display",
		"Displays",
		"newDisplays",
		"SWT",
		"i",
		"shells",
		"i",
		"shells",
		"i",
		"shell",
		"shell",
		"tray",
		"tray",
		"tray",
		"disposeList",
		"i",
		"disposeList",
		"i",
		"disposeList",
		"i",
		"disposeList",
		"i",
		"disposeList",
		"synchronizer",
		"synchronizer",
		"embeddedHwnd",
		"OS",
		"embeddedHwnd",
		"SWT_DESTROY",
		"OS",
		"msgHook",
		"OS",
		"msgHook",
		"msgHook",
		"OS",
		"filterHook",
		"OS",
		"filterHook",
		"filterHook",
		"msgFilterCallback",
		"msgFilterCallback",
		"msgFilterProc",
		"OS",
		"idleHook",
		"OS",
		"idleHook",
		"idleHook",
		"foregroundIdleCallback",
		"foregroundIdleCallback",
		"foregroundIdleProc",
		"hwndMessage",
		"OS",
		"hwndMessage",
		"hwndMessage",
		"messageCallback",
		"messageCallback",
		"messageProc",
		"OS",
		"OS",
		"OS",
		"windowClass",
		"lpWndClass",
		"OS",
		"windowClass",
		"hInstance",
		"OS",
		"hHeap",
		"lpWndClass",
		"OS",
		"windowShadowClass",
		"lpWndClass",
		"OS",
		"windowShadowClass",
		"hInstance",
		"OS",
		"hHeap",
		"lpWndClass",
		"windowClass",
		"windowShadowClass",
		"windowCallback",
		"windowCallback",
		"windowProc",
		"systemFonts",
		"i",
		"systemFonts",
		"i",
		"systemFonts",
		"i",
		"OS",
		"systemFonts",
		"i",
		"systemFonts",
		"errorIcon",
		"OS",
		"errorIcon",
		"infoIcon",
		"OS",
		"infoIcon",
		"questionIcon",
		"OS",
		"questionIcon",
		"warningIcon",
		"OS",
		"warningIcon",
		"errorIcon",
		"infoIcon",
		"questionIcon",
		"warningIcon",
		"i",
		"cursors",
		"i",
		"cursors",
		"i",
		"cursors",
		"i",
		"cursors",
		"lpCustColors",
		"OS",
		"hHeap",
		"lpCustColors",
		"lpCustColors",
		"OS",
		"OS",
		"thread",
		"msg",
		"keyboard",
		"modalDialogShell",
		"modalShells",
		"data",
		"keys",
		"values",
		"bars",
		"popups",
		"indexTable",
		"controlTable",
		"lastHittestControl",
		"imageList",
		"toolImageList",
		"toolHotImageList",
		"toolDisabledImageList",
		"imageList",
		"i",
		"length",
		"imageList",
		"i",
		"list",
		"list",
		"list",
		"System",
		"imageList",
		"i",
		"imageList",
		"i",
		"length",
		"i",
		"imageList",
		"length",
		"j",
		"length",
		"j",
		"imageList",
		"j",
		"imageList",
		"i",
		"toolImageList",
		"i",
		"length",
		"toolImageList",
		"i",
		"list",
		"list",
		"list",
		"System",
		"toolImageList",
		"i",
		"toolImageList",
		"i",
		"length",
		"i",
		"toolImageList",
		"length",
		"j",
		"length",
		"j",
		"toolImageList",
		"j",
		"toolImageList",
		"i",
		"toolHotImageList",
		"i",
		"length",
		"toolHotImageList",
		"i",
		"list",
		"list",
		"list",
		"System",
		"toolHotImageList",
		"i",
		"toolHotImageList",
		"i",
		"length",
		"i",
		"toolHotImageList",
		"length",
		"j",
		"length",
		"j",
		"toolHotImageList",
		"j",
		"toolHotImageList",
		"i",
		"toolDisabledImageList",
		"i",
		"length",
		"toolDisabledImageList",
		"i",
		"list",
		"list",
		"list",
		"System",
		"toolDisabledImageList",
		"i",
		"toolDisabledImageList",
		"i",
		"length",
		"i",
		"toolDisabledImageList",
		"length",
		"j",
		"length",
		"j",
		"toolDisabledImageList",
		"j",
		"toolDisabledImageList",
		"i",
		"listener",
		"SWT",
		"filterTable",
		"filterTable",
		"eventType",
		"listener",
		"filterTable",
		"filterTable",
		"listener",
		"SWT",
		"eventTable",
		"eventTable",
		"eventType",
		"listener",
		"bars",
		"i",
		"bars",
		"i",
		"bars",
		"i",
		"menu",
		"bars",
		"i",
		"handle",
		"USE_PROPERTY",
		"index",
		"OS",
		"handle",
		"SWT_OBJECT_INDEX",
		"index",
		"OS",
		"handle",
		"OS",
		"index",
		"index",
		"controlTable",
		"control",
		"controlTable",
		"index",
		"controlTable",
		"index",
		"indexTable",
		"index",
		"freeSlot",
		"freeSlot",
		"index",
		"USE_PROPERTY",
		"OS",
		"handle",
		"OS",
		"control",
		"items",
		"items",
		"item",
		"ID_START",
		"item",
		"popups",
		"i",
		"popups",
		"i",
		"popups",
		"i",
		"menu",
		"popups",
		"i",
		"synchronizer",
		"all",
		"eventQueue",
		"eventQueue",
		"event",
		"eventQueue",
		"System",
		"eventQueue",
		"eventQueue",
		"length",
		"eventQueue",
		"length",
		"event",
		"widget",
		"widget",
		"event",
		"item",
		"item",
		"widget",
		"event",
		"eventQueue",
		"popups",
		"popups",
		"popups",
		"menu",
		"popups",
		"System",
		"popups",
		"popups",
		"length",
		"popups",
		"length",
		"menu",
		"result",
		"popups",
		"result",
		"timerList",
		"timerIds",
		"index",
		"timerIds",
		"timerIds",
		"index",
		"id",
		"OS",
		"hwndMessage",
		"timerIds",
		"index",
		"timerIds",
		"index",
		"timerList",
		"index",
		"timerList",
		"index",
		"runnable",
		"runnable",
		"index",
		"eventTable",
		"filterTable",
		"event",
		"event",
		"event",
		"event",
		"eventType",
		"event",
		"event",
		"event",
		"eventTable",
		"eventTable",
		"event",
		"OS",
		"x",
		"y",
		"point",
		"SWT",
		"point",
		"point",
		"key",
		"SWT",
		"value",
		"keys",
		"index",
		"keys",
		"keys",
		"index",
		"key",
		"index",
		"index",
		"keys",
		"keys",
		"keys",
		"values",
		"keys",
		"values",
		"System",
		"keys",
		"newKeys",
		"index",
		"System",
		"keys",
		"index",
		"newKeys",
		"index",
		"newKeys",
		"index",
		"System",
		"values",
		"newValues",
		"index",
		"System",
		"values",
		"index",
		"newValues",
		"index",
		"newValues",
		"index",
		"keys",
		"newKeys",
		"values",
		"newValues",
		"keys",
		"keys",
		"key",
		"values",
		"value",
		"i",
		"keys",
		"i",
		"keys",
		"i",
		"key",
		"values",
		"i",
		"value",
		"keys",
		"values",
		"System",
		"keys",
		"newKeys",
		"keys",
		"System",
		"values",
		"newValues",
		"values",
		"newKeys",
		"keys",
		"key",
		"newValues",
		"values",
		"value",
		"keys",
		"newKeys",
		"values",
		"newValues",
		"data",
		"modalDialogShell",
		"modalDialogShell",
		"modalDialogShell",
		"modalDailog",
		"i",
		"shells",
		"i",
		"shells",
		"i",
		"modalShells",
		"modalShells",
		"modalShells",
		"index",
		"length",
		"modalShells",
		"index",
		"shell",
		"modalShells",
		"index",
		"index",
		"index",
		"length",
		"length",
		"System",
		"modalShells",
		"newModalShells",
		"length",
		"modalShells",
		"newModalShells",
		"modalShells",
		"index",
		"shell",
		"i",
		"shells",
		"i",
		"shells",
		"i",
		"synchronizer",
		"SWT",
		"synchronizer",
		"OS",
		"i",
		"keyboard",
		"i",
		"keyboard",
		"i",
		"keyboard",
		"OS",
		"OS",
		"OS",
		"key",
		"key",
		"keyboard",
		"result",
		"result",
		"OS",
		"key",
		"key",
		"keyboard",
		"result",
		"result",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"SWT",
		"synchronizer",
		"runnable",
		"systemFonts",
		"systemFonts",
		"length",
		"hFont",
		"systemFonts",
		"length",
		"hFont",
		"hFont",
		"OS",
		"OS",
		"hFont",
		"hFont",
		"OS",
		"OS",
		"hFont",
		"runnable",
		"SWT",
		"timerList",
		"timerList",
		"timerIds",
		"timerIds",
		"index",
		"timerList",
		"timerList",
		"index",
		"runnable",
		"index",
		"index",
		"timerList",
		"timerId",
		"timerIds",
		"index",
		"milliseconds",
		"OS",
		"hwndMessage",
		"timerId",
		"timerList",
		"index",
		"timerIds",
		"index",
		"milliseconds",
		"index",
		"index",
		"timerList",
		"timerList",
		"index",
		"index",
		"nextTimerId",
		"timerId",
		"nextTimerId",
		"index",
		"timerList",
		"timerList",
		"System",
		"timerList",
		"newTimerList",
		"timerList",
		"timerList",
		"newTimerList",
		"timerIds",
		"System",
		"timerIds",
		"newTimerIds",
		"timerIds",
		"timerIds",
		"newTimerIds",
		"OS",
		"hwndMessage",
		"timerId",
		"milliseconds",
		"newTimerID",
		"timerList",
		"index",
		"runnable",
		"timerIds",
		"index",
		"newTimerID",
		"accelKeyHit",
		"control",
		"msg",
		"accelKeyHit",
		"result",
		"i",
		"KeyTable",
		"i",
		"KeyTable",
		"i",
		"key",
		"KeyTable",
		"i",
		"msg",
		"OS",
		"OS",
		"control",
		"msg",
		"msg",
		"OS",
		"msg",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"OS",
		"control",
		"msg",
		"OS",
		"msg",
		"OS",
		"control",
		"msg",
		"i",
		"KeyTable",
		"i",
		"KeyTable",
		"i",
		"key",
		"KeyTable",
		"i",
		"OS",
		"OS",
		"OS",
		"OS",
		"hwndMessage",
		"OS",
		"OS",
		"OS",
		"msg",
		"hwndMessage",
		"SWT_NULL",
		"SWT_NULL",
		"flags",
		"i",
		"shells",
		"i",
		"shells",
		"i",
		"shell",
		"shell",
		"OS",
		"OS",
		"info",
		"NONCLIENTMETRICS",
		"OS",
		"OS",
		"info",
		"systemFont",
		"OS",
		"OS",
		"info",
		"info",
		"systemFont",
		"systemFont",
		"OS",
		"OS",
		"systemFont",
		"systemFont",
		"OS",
		"OS",
		"systemFont",
		"systemFonts",
		"systemFonts",
		"length",
		"systemFonts",
		"System",
		"systemFonts",
		"newFonts",
		"length",
		"newFonts",
		"length",
		"systemFont",
		"systemFonts",
		"newFonts",
		"i",
		"shells",
		"i",
		"shells",
		"i",
		"shell",
		"shell",
		"oldFont",
		"newFont",
		"SWT",
		"thread",
		"Thread",
		"OS",
		"OS",
		"hwndMessage",
		"OS",
		"OS",
		"threadId",
		"OS",
		"OS",
		"ch",
		"ch",
		"ch",
		"codePage",
		"ch",
		"buffer",
		"ch",
		"msg",
		"OS",
		"hitCount",
		"Thread",
		"hitCount",
		"USE_PROPERTY",
		"index",
		"OS",
		"hwnd",
		"SWT_OBJECT_INDEX",
		"index",
		"OS",
		"hwnd",
		"OS",
		"index",
		"index",
		"controlTable",
		"controlTable",
		"index",
		"control",
		"control",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"OS",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"string",
		"length",
		"string",
		"string",
		"i",
		"string",
		"i",
		"string",
		"i",
		"string",
		"i",
		"i",
		"length",
		"i",
		"string",
		"i",
		"count",
		"i",
		"count",
		"length",
		"i",
		"count",
		"i",
		"length",
		"string",
		"i",
		"j",
		"j",
		"length",
		"result",
		"string",
		"i",
		"j",
		"i",
		"j",
		"length",
		"result",
		"i",
		"result",
		"IsWinCE",
		"CURSOR_HAND",
		"VK_MENU",
		"ALT",
		"VK_SHIFT",
		"SHIFT",
		"VK_CONTROL",
		"CONTROL",
		"VK_UP",
		"ARROW_UP",
		"VK_DOWN",
		"ARROW_DOWN",
		"VK_LEFT",
		"ARROW_LEFT",
		"VK_RIGHT",
		"ARROW_RIGHT",
		"VK_PRIOR",
		"PAGE_UP",
		"VK_NEXT",
		"PAGE_DOWN",
		"VK_HOME",
		"HOME",
		"VK_END",
		"END",
		"VK_INSERT",
		"INSERT",
		"VK_BACK",
		"BS",
		"VK_RETURN",
		"CR",
		"VK_DELETE",
		"DEL",
		"VK_ESCAPE",
		"ESC",
		"VK_RETURN",
		"LF",
		"VK_TAB",
		"TAB",
		"VK_F1",
		"F1",
		"VK_F2",
		"F2",
		"VK_F3",
		"F3",
		"VK_F4",
		"F4",
		"VK_F5",
		"F5",
		"VK_F6",
		"F6",
		"VK_F7",
		"F7",
		"VK_F8",
		"F8",
		"VK_F9",
		"F9",
		"VK_F10",
		"F10",
		"VK_F11",
		"F11",
		"VK_F12",
		"F12",
		"VK_F13",
		"F13",
		"VK_F14",
		"F14",
		"VK_F15",
		"F15",
		"VK_MULTIPLY",
		"KEYPAD_MULTIPLY",
		"VK_ADD",
		"KEYPAD_ADD",
		"VK_RETURN",
		"KEYPAD_CR",
		"VK_SUBTRACT",
		"KEYPAD_SUBTRACT",
		"VK_DECIMAL",
		"KEYPAD_DECIMAL",
		"VK_DIVIDE",
		"KEYPAD_DIVIDE",
		"VK_NUMPAD0",
		"KEYPAD_0",
		"VK_NUMPAD1",
		"KEYPAD_1",
		"VK_NUMPAD2",
		"KEYPAD_2",
		"VK_NUMPAD3",
		"KEYPAD_3",
		"VK_NUMPAD4",
		"KEYPAD_4",
		"VK_NUMPAD5",
		"KEYPAD_5",
		"VK_NUMPAD6",
		"KEYPAD_6",
		"VK_NUMPAD7",
		"KEYPAD_7",
		"VK_NUMPAD8",
		"KEYPAD_8",
		"VK_NUMPAD9",
		"KEYPAD_9",
		"VK_CAPITAL",
		"CAPS_LOCK",
		"VK_NUMLOCK",
		"NUM_LOCK",
		"VK_SCROLL",
		"SCROLL_LOCK",
		"VK_PAUSE",
		"PAUSE",
		"VK_CANCEL",
		"BREAK",
		"VK_SNAPSHOT",
		"PRINT_SCREEN",
		"WM_APP",
		"WM_APP",
		"WM_APP",
		"WM_APP",
		"WM_APP",
		"WM_APP",
		"length",
		"length",
		"GWL_USERDATA",
		"ERROR_NULL_ARGUMENT",
		"ERROR_NULL_ARGUMENT",
		"length",
		"id",
		"id",
		"length",
		"length",
		"length",
		"length",
		"length",
		"IsWinCE",
		"length",
		"IsUnicode",
		"ERROR_DEVICE_DISPOSED",
		"MB_OK",
		"ERROR_INVALID_SUBCLASS",
		"ERROR_WIDGET_DISPOSED",
		"ERROR_THREAD_INVALID_ACCESS",
		"ERROR_DEVICE_DISPOSED",
		"length",
		"ERROR_NOT_IMPLEMENTED",
		"thread",
		"ERROR_THREAD_INVALID_ACCESS",
		"length",
		"length",
		"Close",
		"doit",
		"sizeof",
		"bmWidth",
		"bmHeight",
		"biSize",
		"sizeof",
		"biWidth",
		"biHeight",
		"biPlanes",
		"biBitCount",
		"biCompression",
		"BI_RGB",
		"sizeof",
		"sizeof",
		"DIB_RGB_COLORS",
		"ERROR_NO_HANDLES",
		"sizeof",
		"bmWidthBytes",
		"bmHeight",
		"SRCCOPY",
		"bmBitsPixel",
		"bmBitsPixel",
		"width",
		"height",
		"height",
		"width",
		"alphaData",
		"data",
		"IsWinCE",
		"COLORONCOLOR",
		"SRCCOPY",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"sizeof",
		"message",
		"WM_KEYFIRST",
		"WM_KEYLAST",
		"hwnd",
		"length",
		"thread",
		"SM_CMONITORS",
		"SM_CXSCREEN",
		"SM_CYSCREEN",
		"SM_XVIRTUALSCREEN",
		"SM_YVIRTUALSCREEN",
		"SM_CXVIRTUALSCREEN",
		"SM_CYVIRTUALSCREEN",
		"SM_CMONITORS",
		"SPI_GETWORKAREA",
		"right",
		"left",
		"bottom",
		"top",
		"left",
		"top",
		"SM_XVIRTUALSCREEN",
		"SM_YVIRTUALSCREEN",
		"SM_CXVIRTUALSCREEN",
		"SM_CYVIRTUALSCREEN",
		"GWL_USERDATA",
		"length",
		"x",
		"y",
		"SM_CXCURSOR",
		"SM_CYCURSOR",
		"ERROR_NULL_ARGUMENT",
		"length",
		"LEFT",
		"IsWinCE",
		"cbSize",
		"sizeof",
		"SPI_GETHIGHCONTRAST",
		"dwFlags",
		"HCF_HIGHCONTRASTON",
		"IsWinCE",
		"WIN32_VERSION",
		"HKEY_CURRENT_USER",
		"KEY_READ",
		"SM_CXSMICON",
		"SM_CYSMICON",
		"SM_CXICON",
		"SM_CYICON",
		"length",
		"x",
		"y",
		"length",
		"x",
		"y",
		"length",
		"x",
		"y",
		"length",
		"x",
		"y",
		"IsWinCE",
		"length",
		"length",
		"IsWinCE",
		"WIN32_VERSION",
		"ERROR_NO_MORE_CALLBACKS",
		"WS_OVERLAPPED",
		"ERROR_NO_MORE_CALLBACKS",
		"GWL_WNDPROC",
		"PM_NOREMOVE",
		"sizeof",
		"message",
		"WM_KEYDOWN",
		"WM_KEYUP",
		"WM_SYSKEYDOWN",
		"WM_SYSKEYUP",
		"HEAP_ZERO_MEMORY",
		"sizeof",
		"sizeof",
		"message",
		"WM_NULL",
		"sizeof",
		"IsWinCE",
		"WIN32_VERSION",
		"SM_CXSCREEN",
		"SM_CYSCREEN",
		"width",
		"height",
		"SPI_GETWORKAREA",
		"clientX",
		"left",
		"clientY",
		"top",
		"clientWidth",
		"right",
		"left",
		"clientHeight",
		"bottom",
		"top",
		"ERROR_NO_MORE_CALLBACKS",
		"cbSize",
		"sizeof",
		"handle",
		"dwFlags",
		"MONITORINFOF_PRIMARY",
		"length",
		"length",
		"ERROR_DEVICE_DISPOSED",
		"syncThread",
		"COLOR_WIDGET_DARK_SHADOW",
		"COLOR_3DDKSHADOW",
		"COLOR_WIDGET_NORMAL_SHADOW",
		"COLOR_3DSHADOW",
		"COLOR_WIDGET_LIGHT_SHADOW",
		"COLOR_3DLIGHT",
		"COLOR_WIDGET_HIGHLIGHT_SHADOW",
		"COLOR_3DHIGHLIGHT",
		"COLOR_WIDGET_BACKGROUND",
		"COLOR_3DFACE",
		"COLOR_WIDGET_BORDER",
		"COLOR_WINDOWFRAME",
		"COLOR_WIDGET_FOREGROUND",
		"COLOR_LIST_FOREGROUND",
		"COLOR_WINDOWTEXT",
		"COLOR_LIST_BACKGROUND",
		"COLOR_WINDOW",
		"COLOR_LIST_SELECTION",
		"COLOR_HIGHLIGHT",
		"COLOR_LIST_SELECTION_TEXT",
		"COLOR_HIGHLIGHTTEXT",
		"COLOR_INFO_FOREGROUND",
		"COLOR_INFOTEXT",
		"COLOR_INFO_BACKGROUND",
		"COLOR_INFOBK",
		"COLOR_TITLE_FOREGROUND",
		"COLOR_CAPTIONTEXT",
		"COLOR_TITLE_BACKGROUND",
		"COLOR_ACTIVECAPTION",
		"COLOR_TITLE_BACKGROUND_GRADIENT",
		"COLOR_GRADIENTACTIVECAPTION",
		"COLOR_ACTIVECAPTION",
		"COLOR_TITLE_INACTIVE_FOREGROUND",
		"COLOR_INACTIVECAPTIONTEXT",
		"COLOR_TITLE_INACTIVE_BACKGROUND",
		"COLOR_INACTIVECAPTION",
		"COLOR_TITLE_INACTIVE_BACKGROUND_GRADIENT",
		"COLOR_GRADIENTINACTIVECAPTION",
		"COLOR_INACTIVECAPTION",
		"length",
		"ICON_ERROR",
		"OIC_HAND",
		"IMAGE_ICON",
		"LR_SHARED",
		"ICON_WORKING",
		"ICON_INFORMATION",
		"OIC_INFORMATION",
		"IMAGE_ICON",
		"LR_SHARED",
		"ICON_QUESTION",
		"OIC_QUES",
		"IMAGE_ICON",
		"LR_SHARED",
		"ICON_WARNING",
		"OIC_BANG",
		"IMAGE_ICON",
		"LR_SHARED",
		"ICON",
		"NONE",
		"ERROR_DEVICE_DISPOSED",
		"ERROR_DEVICE_DISPOSED",
		"ERROR_NO_HANDLES",
		"LEFT_TO_RIGHT",
		"RIGHT_TO_LEFT",
		"style",
		"layout",
		"style",
		"RIGHT_TO_LEFT",
		"LAYOUT_RTL",
		"style",
		"LEFT_TO_RIGHT",
		"device",
		"hFont",
		"ERROR_NO_MORE_CALLBACKS",
		"hInstance",
		"lpfnWndProc",
		"style",
		"CS_BYTEALIGNWINDOW",
		"CS_DBLCLKS",
		"hCursor",
		"IDC_ARROW",
		"sizeof",
		"lpszClassName",
		"HEAP_ZERO_MEMORY",
		"lpszClassName",
		"WIN32_VERSION",
		"style",
		"CS_DROPSHADOW",
		"sizeof",
		"lpszClassName",
		"HEAP_ZERO_MEMORY",
		"lpszClassName",
		"IsWinCE",
		"IsUnicode",
		"cbSize",
		"sizeof",
		"SPI_GETNONCLIENTMETRICS",
		"IsUnicode",
		"lfMessageFont",
		"lfMessageFont",
		"DEFAULT_GUI_FONT",
		"SYSTEM_FONT",
		"WS_OVERLAPPED",
		"ERROR_NO_MORE_CALLBACKS",
		"GWL_WNDPROC",
		"IsWinCE",
		"ERROR_NO_MORE_CALLBACKS",
		"WH_MSGFILTER",
		"IsWinCE",
		"ERROR_NO_MORE_CALLBACKS",
		"WH_FOREGROUNDIDLE",
		"IsWinCE",
		"HKEY_CURRENT_USER",
		"KEY_READ",
		"ERROR_NULL_ARGUMENT",
		"x",
		"y",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"handle",
		"handle",
		"x",
		"y",
		"x",
		"y",
		"ERROR_NULL_ARGUMENT",
		"x",
		"y",
		"width",
		"height",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"handle",
		"handle",
		"left",
		"top",
		"right",
		"bottom",
		"left",
		"top",
		"right",
		"left",
		"bottom",
		"top",
		"IsUnicode",
		"CP_ACP",
		"MB_PRECOMPOSED",
		"length",
		"sizeof",
		"hwnd",
		"hwnd",
		"handle",
		"PM_REMOVE",
		"PM_NOYIELD",
		"PM_QS_INPUT",
		"PM_QS_POSTMESSAGE",
		"hwnd",
		"WM_KEYFIRST",
		"WM_KEYLAST",
		"items",
		"length",
		"id",
		"WM_ACTIVATEAPP",
		"handle",
		"handle",
		"WM_ENDSESSION",
		"WM_QUERYENDSESSION",
		"Close",
		"doit",
		"WM_SETTINGCHANGE",
		"WM_TIMER",
		"items",
		"length",
		"length",
		"length",
		"length",
		"cbSize",
		"sizeof",
		"handle",
		"x",
		"rcMonitor_left",
		"y",
		"rcMonitor_top",
		"width",
		"rcMonitor_right",
		"rcMonitor_left",
		"height",
		"rcMonitor_bottom",
		"rcMonitor_top",
		"clientX",
		"rcWork_left",
		"clientY",
		"rcWork_top",
		"clientWidth",
		"rcWork_right",
		"rcWork_left",
		"clientHeight",
		"rcWork_bottom",
		"rcWork_top",
		"sizeof",
		"message",
		"WM_NULL",
		"PM_NOREMOVE",
		"PM_NOYIELD",
		"PM_QS_INPUT",
		"PM_QS_POSTMESSAGE",
		"VK_NUMPAD0",
		"VK_NUMPAD1",
		"VK_NUMPAD2",
		"VK_NUMPAD3",
		"VK_NUMPAD4",
		"VK_NUMPAD5",
		"VK_NUMPAD6",
		"VK_NUMPAD7",
		"VK_NUMPAD8",
		"VK_NUMPAD9",
		"VK_MULTIPLY",
		"VK_ADD",
		"VK_SEPARATOR",
		"VK_SUBTRACT",
		"VK_DECIMAL",
		"VK_DIVIDE",
		"ERROR_DEVICE_DISPOSED",
		"ERROR_NULL_ARGUMENT",
		"type",
		"KeyDown",
		"KeyUp",
		"wVk",
		"keyCode",
		"wVk",
		"character",
		"BS",
		"wVk",
		"VK_BACK",
		"CR",
		"wVk",
		"VK_RETURN",
		"DEL",
		"wVk",
		"VK_DELETE",
		"ESC",
		"wVk",
		"VK_ESCAPE",
		"TAB",
		"wVk",
		"VK_TAB",
		"LF",
		"IsWinCE",
		"wVk",
		"wVk",
		"wVk",
		"dwFlags",
		"KeyUp",
		"KEYEVENTF_KEYUP",
		"HEAP_ZERO_MEMORY",
		"sizeof",
		"INPUT_KEYBOARD",
		"sizeof",
		"sizeof",
		"MouseDown",
		"MouseMove",
		"MouseUp",
		"MouseMove",
		"dwFlags",
		"MOUSEEVENTF_MOVE",
		"MOUSEEVENTF_ABSOLUTE",
		"dx",
		"x",
		"SM_CXSCREEN",
		"dy",
		"y",
		"SM_CYSCREEN",
		"button",
		"dwFlags",
		"MouseDown",
		"MOUSEEVENTF_LEFTDOWN",
		"MOUSEEVENTF_LEFTUP",
		"dwFlags",
		"MouseDown",
		"MOUSEEVENTF_MIDDLEDOWN",
		"MOUSEEVENTF_MIDDLEUP",
		"dwFlags",
		"MouseDown",
		"MOUSEEVENTF_RIGHTDOWN",
		"MOUSEEVENTF_RIGHTUP",
		"HEAP_ZERO_MEMORY",
		"sizeof",
		"INPUT_MOUSE",
		"sizeof",
		"sizeof",
		"length",
		"PM_REMOVE",
		"length",
		"length",
		"length",
		"length",
		"Dispose",
		"length",
		"length",
		"IsWinCE",
		"IsWinCE",
		"IsWinCE",
		"lpszClassName",
		"lpszClassName",
		"length",
		"length",
		"IsWinCE",
		"length",
		"length",
		"length",
		"length",
		"ERROR_NULL_ARGUMENT",
		"ERROR_NULL_ARGUMENT",
		"length",
		"GWL_USERDATA",
		"length",
		"GWL_USERDATA",
		"id",
		"id",
		"length",
		"length",
		"widget",
		"item",
		"length",
		"length",
		"display",
		"type",
		"time",
		"time",
		"ERROR_NULL_ARGUMENT",
		"x",
		"y",
		"ERROR_NULL_ARGUMENT",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"data",
		"modalDialogShell",
		"length",
		"length",
		"length",
		"ERROR_NULL_ARGUMENT",
		"synchronizer",
		"synchronizer",
		"synchronizer",
		"IsWinCE",
		"length",
		"VK_SHIFT",
		"IsUnicode",
		"IsWinCE",
		"INFINITE",
		"QS_ALLINPUT",
		"MWMO_INPUTAVAILABLE",
		"ERROR_DEVICE_DISPOSED",
		"length",
		"DEFAULT_GUI_FONT",
		"SYSTEM_FONT",
		"ERROR_NULL_ARGUMENT",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"length",
		"message",
		"WM_CHAR",
		"WM_SYSCHAR",
		"message",
		"WM_KEYDOWN",
		"wParam",
		"VK_RETURN",
		"VK_ESCAPE",
		"VK_TAB",
		"VK_UP",
		"VK_DOWN",
		"VK_LEFT",
		"VK_RIGHT",
		"VK_PRIOR",
		"VK_NEXT",
		"WM_SYSKEYDOWN",
		"wParam",
		"VK_MENU",
		"length",
		"IsWinCE",
		"WIN32_VERSION",
		"PM_REMOVE",
		"PM_NOYIELD",
		"length",
		"IsWinCE",
		"IsUnicode",
		"cbSize",
		"sizeof",
		"SPI_GETNONCLIENTMETRICS",
		"IsUnicode",
		"lfMessageFont",
		"lfMessageFont",
		"DEFAULT_GUI_FONT",
		"SYSTEM_FONT",
		"length",
		"length",
		"ERROR_DEVICE_DISPOSED",
		"IsWinCE",
		"WM_NULL",
		"WM_NULL",
		"IsUnicode",
		"WM_NCHITTEST",
		"GWL_USERDATA",
		"length",
		"device",
		"data",
		"menu",
		"handle",
		"control",
		"eventType",
		"listener",
		"eventType",
		"listener",
		"item",
		"menu",
		"key",
		"runnable",
		"thread",
		"multiple",
		"shell",
		"key",
		"data",
		"data",
		"hBitmap",
		"alpha",
		"alphaData",
		"transparentPixel",
		"data",
		"destWidth",
		"destHeight",
		"display",
		"runnable",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"code",
		"event",
		"eventType",
		"msg",
		"handle",
		"handle",
		"handle",
		"id",
		"code",
		"wParam",
		"lParam",
		"thread",
		"handle",
		"clazz",
		"key",
		"e",
		"style",
		"width",
		"height",
		"style",
		"width",
		"height",
		"style",
		"width",
		"height",
		"style",
		"width",
		"height",
		"id",
		"code",
		"wParam",
		"lParam",
		"id",
		"id",
		"id",
		"data",
		"hDC",
		"data",
		"from",
		"to",
		"point",
		"from",
		"to",
		"x",
		"y",
		"from",
		"to",
		"rectangle",
		"from",
		"to",
		"x",
		"y",
		"width",
		"height",
		"ch",
		"ch",
		"codePage",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"hmonitor",
		"hdc",
		"lprcMonitor",
		"dwData",
		"code",
		"wParam",
		"lParam",
		"key",
		"event",
		"event",
		"display",
		"list",
		"list",
		"list",
		"list",
		"eventType",
		"listener",
		"eventType",
		"listener",
		"menu",
		"handle",
		"item",
		"menu",
		"all",
		"id",
		"eventType",
		"event",
		"x",
		"y",
		"point",
		"key",
		"value",
		"data",
		"name",
		"modalDailog",
		"shell",
		"synchronizer",
		"key",
		"runnable",
		"milliseconds",
		"runnable",
		"msg",
		"control",
		"key",
		"msg",
		"control",
		"msg",
		"control",
		"key",
		"ch",
		"codePage",
		"ch",
		"hwnd",
		"msg",
		"wParam",
		"lParam",
		"t",
		"string"
	],
	"extendORImplementFiles":[
		"Device"
	],
	"package":[
		"org.eclipse.swt.widgets"
	],
	"import":[
		"org.eclipse.swt.internal",
		"org.eclipse.swt.internal.win32",
		"org.eclipse.swt",
		"org.eclipse.swt.graphics"
	],
	"methods":[
		"run",
		"setDevice",
		"_getFocusControl",
		"addBar",
		"addControl",
		"addFilter",
		"addListener",
		"addMenuItem",
		"addPopup",
		"asciiKey",
		"asyncExec",
		"beep",
		"checkSubclass",
		"checkDevice",
		"checkDisplay",
		"clearModal",
		"controlKey",
		"close",
		"create",
		"createDisplay",
		"create32bitDIB",
		"createMaskFromAlpha",
		"deregister",
		"destroy",
		"destroyDisplay",
		"disposeExec",
		"drawMenuBars",
		"embeddedProc",
		"error",
		"filterEvent",
		"filters",
		"filterMessage",
		"findControl",
		"findWidget",
		"findWidget",
		"foregroundIdleProc",
		"findDisplay",
		"getActiveShell",
		"getBounds",
		"getCurrent",
		"getClientArea",
		"getControl",
		"getCursorControl",
		"getCursorLocation",
		"getCursorSizes",
		"getDefault",
		"isValidClass",
		"getData",
		"getData",
		"getDismissalAlignment",
		"getDoubleClickTime",
		"getFocusControl",
		"getHighContrast",
		"getIconDepth",
		"getIconSizes",
		"getImageList",
		"getImageListToolBar",
		"getImageListToolBarDisabled",
		"getImageListToolBarHot",
		"getLastEventTime",
		"getMenuItem",
		"getMessageCount",
		"getModalShell",
		"getModalDialogShell",
		"getMonitors",
		"getMsgProc",
		"getPrimaryMonitor",
		"getShells",
		"getSyncThread",
		"getSystemColor",
		"getSystemCursor",
		"getSystemFont",
		"getSystemImage",
		"getSystemTray",
		"getThread",
		"internal_new_GC",
		"init",
		"internal_dispose_GC",
		"isXMouseActive",
		"isValidThread",
		"map",
		"map",
		"map",
		"map",
		"mbcsToWcs",
		"mbcsToWcs",
		"messageProc",
		"monitorEnumProc",
		"msgFilterProc",
		"numpadKey",
		"post",
		"postEvent",
		"readAndDispatch",
		"register",
		"release",
		"releaseDisplay",
		"releaseImageList",
		"releaseToolImageList",
		"releaseToolHotImageList",
		"releaseToolDisabledImageList",
		"removeFilter",
		"removeListener",
		"removeBar",
		"removeControl",
		"removeMenuItem",
		"removePopup",
		"runAsyncMessages",
		"runDeferredEvents",
		"runPopups",
		"runTimer",
		"sendEvent",
		"setCursorLocation",
		"setCursorLocation",
		"setData",
		"setData",
		"setAppName",
		"setModalDialogShell",
		"setModalShell",
		"setSynchronizer",
		"shiftedKey",
		"sleep",
		"syncExec",
		"systemFont",
		"timerExec",
		"translateAccelerator",
		"translateKey",
		"translateMnemonic",
		"translateTraversal",
		"untranslateKey",
		"update",
		"updateFont",
		"wake",
		"wakeThread",
		"wcsToMbcs",
		"wcsToMbcs",
		"windowProc",
		"withCrLf",
		"GlobalAddAtom",
		"getCurrent",
		"getDefault",
		"setDevice",
		"findControl",
		"GetFocus",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"SetProp",
		"SetWindowLong",
		"checkDevice",
		"error",
		"hook",
		"checkDevice",
		"error",
		"hook",
		"arraycopy",
		"arraycopy",
		"GetKeyboardState",
		"ToUnicode",
		"ToAscii",
		"isDisposed",
		"error",
		"asyncExec",
		"checkDevice",
		"MessageBeep",
		"isValidClass",
		"getClass",
		"error",
		"error",
		"currentThread",
		"error",
		"isDisposed",
		"error",
		"error",
		"error",
		"arraycopy",
		"getShells",
		"updateModal",
		"CharUpper",
		"checkDevice",
		"sendEvent",
		"dispose",
		"checkSubclass",
		"checkDisplay",
		"currentThread",
		"createDisplay",
		"register",
		"GetObject",
		"GetDC",
		"CreateCompatibleDC",
		"SelectObject",
		"CreateCompatibleDC",
		"MoveMemory",
		"CreateDIBSection",
		"error",
		"SelectObject",
		"GetObject",
		"BitBlt",
		"GetDIBColorTable",
		"SelectObject",
		"SelectObject",
		"DeleteObject",
		"DeleteObject",
		"ReleaseDC",
		"MoveMemory",
		"MoveMemory",
		"internal_new",
		"setPixel",
		"CreateBitmap",
		"GetDC",
		"CreateCompatibleDC",
		"SelectObject",
		"CreateCompatibleDC",
		"CreateBitmap",
		"SelectObject",
		"SetStretchBltMode",
		"StretchBlt",
		"DeleteDC",
		"DeleteDC",
		"ReleaseDC",
		"DeleteObject",
		"deregister",
		"destroyDisplay",
		"checkDevice",
		"arraycopy",
		"isDisposed",
		"update",
		"MoveMemory",
		"TranslateMessage",
		"DispatchMessage",
		"GetProcessHeap",
		"HeapFree",
		"DestroyWindow",
		"dispose",
		"dispose",
		"DefWindowProc",
		"error",
		"sendEvent",
		"hooks",
		"findControl",
		"translateAccelerator",
		"translateMnemonic",
		"translateTraversal",
		"getControl",
		"GetParent",
		"checkDevice",
		"getControl",
		"getControl",
		"findItem",
		"getMessageCount",
		"wakeThread",
		"CallNextHookEx",
		"checkDevice",
		"findControl",
		"GetActiveWindow",
		"getShell",
		"checkDevice",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"findDisplay",
		"currentThread",
		"checkDevice",
		"GetSystemMetrics",
		"SystemParametersInfo",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"GetProp",
		"GetWindowLong",
		"checkHandle",
		"checkDevice",
		"GetCursorPos",
		"findControl",
		"WindowFromPoint",
		"checkDevice",
		"GetCursorPos",
		"checkDevice",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"getName",
		"lastIndexOf",
		"equals",
		"substring",
		"checkDevice",
		"error",
		"equals",
		"checkDevice",
		"checkDevice",
		"checkDevice",
		"GetDoubleClickTime",
		"checkDevice",
		"isDisposed",
		"_getFocusControl",
		"checkDevice",
		"SystemParametersInfo",
		"checkDevice",
		"VERSION",
		"getDepth",
		"RegOpenKeyEx",
		"RegQueryValueEx",
		"parseInt",
		"toString",
		"strlen",
		"RegCloseKey",
		"checkDevice",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"getImageSize",
		"getStyle",
		"addRef",
		"arraycopy",
		"addRef",
		"getImageSize",
		"getStyle",
		"addRef",
		"arraycopy",
		"addRef",
		"getImageSize",
		"getStyle",
		"addRef",
		"arraycopy",
		"addRef",
		"getImageSize",
		"getStyle",
		"addRef",
		"arraycopy",
		"addRef",
		"GetTickCount",
		"GetMessageTime",
		"getMessageCount",
		"isDisposed",
		"checkDevice",
		"VERSION",
		"getPrimaryMonitor",
		"getAddress",
		"error",
		"EnumDisplayMonitors",
		"dispose",
		"arraycopy",
		"GetModuleHandle",
		"CreateWindowEx",
		"getAddress",
		"error",
		"SetWindowLong",
		"MoveMemory",
		"GetProcessHeap",
		"HeapAlloc",
		"MoveMemory",
		"PostMessage",
		"MoveMemory",
		"CallNextHookEx",
		"checkDevice",
		"VERSION",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"SystemParametersInfo",
		"getAddress",
		"error",
		"EnumDisplayMonitors",
		"dispose",
		"GetMonitorInfo",
		"checkDevice",
		"isDisposed",
		"error",
		"checkDevice",
		"GetSysColor",
		"GetSysColor",
		"GetSysColor",
		"GetSysColor",
		"GetSysColor",
		"GetSysColor",
		"GetSysColor",
		"GetSysColor",
		"GetSysColor",
		"GetSysColor",
		"GetSysColor",
		"GetSysColor",
		"GetSysColor",
		"GetSysColor",
		"GetSysColor",
		"GetSysColor",
		"GetSysColor",
		"GetSysColor",
		"GetSysColor",
		"GetSysColor",
		"getSystemColor",
		"win32_new",
		"checkDevice",
		"checkDevice",
		"systemFont",
		"win32_new",
		"checkDevice",
		"LoadImage",
		"LoadImage",
		"LoadImage",
		"LoadImage",
		"win32_new",
		"checkDevice",
		"isDisposed",
		"error",
		"isDisposed",
		"error",
		"GetDC",
		"error",
		"systemFont",
		"init",
		"getAddress",
		"error",
		"GetCurrentThreadId",
		"GetProcessHeap",
		"GetModuleHandle",
		"LoadCursor",
		"length",
		"HeapAlloc",
		"MoveMemory",
		"RegisterClass",
		"VERSION",
		"length",
		"HeapAlloc",
		"MoveMemory",
		"RegisterClass",
		"SystemParametersInfo",
		"CreateFontIndirect",
		"GetStockObject",
		"GetStockObject",
		"CreateWindowEx",
		"getAddress",
		"error",
		"SetWindowLong",
		"getAddress",
		"error",
		"SetWindowsHookEx",
		"getAddress",
		"error",
		"SetWindowsHookEx",
		"RegisterWindowMessage",
		"OleInitialize",
		"ReleaseDC",
		"RegOpenKeyEx",
		"RegQueryValueEx",
		"RegCloseKey",
		"currentThread",
		"checkDevice",
		"error",
		"map",
		"checkDevice",
		"isDisposed",
		"error",
		"isDisposed",
		"error",
		"MapWindowPoints",
		"checkDevice",
		"error",
		"map",
		"checkDevice",
		"isDisposed",
		"error",
		"isDisposed",
		"error",
		"MapWindowPoints",
		"mbcsToWcs",
		"MultiByteToWideChar",
		"MoveMemory",
		"findControl",
		"filterMessage",
		"TranslateMessage",
		"DispatchMessage",
		"PeekMessage",
		"GetProcessHeap",
		"HeapFree",
		"PostMessage",
		"messageProc",
		"isXMouseActive",
		"isDisposed",
		"getModalShell",
		"IsWindowEnabled",
		"bringToTop",
		"isDisposed",
		"GetLastActivePopup",
		"getControl",
		"IsWindowEnabled",
		"SetActiveWindow",
		"dispose",
		"exit",
		"sendEvent",
		"updateFont",
		"runTimer",
		"recreate",
		"DefWindowProc",
		"arraycopy",
		"GetMonitorInfo",
		"MoveMemory",
		"PeekMessage",
		"runAsyncMessages",
		"wakeThread",
		"CallNextHookEx",
		"isDisposed",
		"error",
		"error",
		"untranslateKey",
		"CharUpper",
		"VkKeyScan",
		"wcsToMbcs",
		"GetProcessHeap",
		"HeapAlloc",
		"MoveMemory",
		"MoveMemory",
		"SendInput",
		"HeapFree",
		"GetSystemMetrics",
		"GetSystemMetrics",
		"GetProcessHeap",
		"HeapAlloc",
		"MoveMemory",
		"MoveMemory",
		"SendInput",
		"HeapFree",
		"arraycopy",
		"checkDevice",
		"drawMenuBars",
		"runPopups",
		"PeekMessage",
		"filterMessage",
		"TranslateMessage",
		"DispatchMessage",
		"runDeferredEvents",
		"runAsyncMessages",
		"arraycopy",
		"sendEvent",
		"getShells",
		"isDisposed",
		"dispose",
		"dispose",
		"readAndDispatch",
		"run",
		"releaseSynchronizer",
		"releaseDisplay",
		"release",
		"PostMessage",
		"UnhookWindowsHookEx",
		"UnhookWindowsHookEx",
		"dispose",
		"UnhookWindowsHookEx",
		"dispose",
		"DestroyWindow",
		"dispose",
		"GetProcessHeap",
		"GetModuleHandle",
		"GetClassInfo",
		"UnregisterClass",
		"HeapFree",
		"GetClassInfo",
		"UnregisterClass",
		"HeapFree",
		"dispose",
		"DeleteObject",
		"DestroyIcon",
		"DestroyIcon",
		"DestroyIcon",
		"DestroyIcon",
		"dispose",
		"HeapFree",
		"OleUninitialize",
		"removeRef",
		"dispose",
		"arraycopy",
		"removeRef",
		"dispose",
		"arraycopy",
		"removeRef",
		"dispose",
		"arraycopy",
		"removeRef",
		"dispose",
		"arraycopy",
		"checkDevice",
		"error",
		"unhook",
		"size",
		"checkDevice",
		"error",
		"unhook",
		"RemoveProp",
		"GetWindowLong",
		"SetWindowLong",
		"runAsyncMessages",
		"arraycopy",
		"isDisposed",
		"isDisposed",
		"sendEvent",
		"arraycopy",
		"runDeferredEvents",
		"_setVisible",
		"KillTimer",
		"run",
		"getLastEventTime",
		"filterEvent",
		"sendEvent",
		"checkDevice",
		"SetCursorPos",
		"checkDevice",
		"error",
		"setCursorLocation",
		"checkDevice",
		"error",
		"equals",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"arraycopy",
		"equals",
		"arraycopy",
		"arraycopy",
		"checkDevice",
		"isDisposed",
		"getShells",
		"updateModal",
		"arraycopy",
		"getShells",
		"updateModal",
		"checkDevice",
		"error",
		"runAsyncMessages",
		"ToUnicode",
		"ToAscii",
		"checkDevice",
		"getMessageCount",
		"MsgWaitForMultipleObjectsEx",
		"WaitMessage",
		"isDisposed",
		"error",
		"syncExec",
		"GetStockObject",
		"GetStockObject",
		"checkDevice",
		"error",
		"KillTimer",
		"arraycopy",
		"arraycopy",
		"SetTimer",
		"translateAccelerator",
		"translateMnemonic",
		"translateTraversal",
		"translateTraversal",
		"checkDevice",
		"VERSION",
		"IsHungAppWindow",
		"PeekMessage",
		"getShells",
		"isDisposed",
		"update",
		"getSystemFont",
		"SystemParametersInfo",
		"CreateFontIndirect",
		"GetStockObject",
		"GetStockObject",
		"arraycopy",
		"getSystemFont",
		"getShells",
		"isDisposed",
		"updateFont",
		"isDisposed",
		"error",
		"currentThread",
		"wakeThread",
		"PostMessage",
		"PostThreadMessage",
		"tcharAt",
		"wcsToMbcs",
		"sleep",
		"GetProp",
		"GetWindowLong",
		"windowProc",
		"DefWindowProc",
		"length",
		"indexOf",
		"charAt",
		"indexOf",
		"indexOf",
		"append",
		"substring",
		"append",
		"toString",
		"MSG",
		"TCHAR",
		"MSG",
		"Synchronizer",
		"Runnable",
		"EventTable",
		"EventTable",
		"Event",
		"BITMAP",
		"BITMAPINFOHEADER",
		"BITMAP",
		"PaletteData",
		"RGB",
		"RGB",
		"MSG",
		"Rectangle",
		"Rectangle",
		"RECT",
		"Rectangle",
		"Rectangle",
		"POINT",
		"POINT",
		"Point",
		"Point",
		"Display",
		"HIGHCONTRAST",
		"TCHAR",
		"TCHAR",
		"TCHAR",
		"Point",
		"Point",
		"ImageList",
		"ImageList",
		"ImageList",
		"ImageList",
		"Callback",
		"Callback",
		"MSG",
		"Monitor",
		"RECT",
		"Callback",
		"MONITORINFO",
		"Cursor",
		"Tray",
		"Callback",
		"TCHAR",
		"TCHAR",
		"WNDCLASS",
		"NONCLIENTMETRICSW",
		"NONCLIENTMETRICSA",
		"Callback",
		"Callback",
		"Callback",
		"TCHAR",
		"TCHAR",
		"TCHAR",
		"POINT",
		"Point",
		"RECT",
		"Rectangle",
		"MSG",
		"Event",
		"MONITORINFO",
		"Monitor",
		"MSG",
		"KEYBDINPUT",
		"MOUSEINPUT",
		"Event",
		"WNDCLASS",
		"Event",
		"MSG",
		"NONCLIENTMETRICSW",
		"NONCLIENTMETRICSA",
		"TCHAR",
		"StringBuffer"
	],
	"methodsBody":{
		"int foregroundIdleProc(int code, int wParam, int lParam)":{
			"methodBody":"{\n    if (code >= 0) {\n        if (getMessageCount() > 0)\n            wakeThread();\n    }\n    return OS.CallNextHookEx(idleHook, code, wParam, lParam);\n}",
			"comments":"",
			"methodName":"int foregroundIdleProc(int code, int wParam, int lParam)"
		},
		"public Control getCursorControl()":{
			"methodBody":"{\n    checkDevice();\n    POINT pt = new POINT();\n    if (!OS.GetCursorPos(pt))\n        return null;\n    return findControl(OS.WindowFromPoint(pt));\n}",
			"comments":"/**\n* Returns the control which the on-screen pointer is currently\n* over top of, or null if it is not currently over one of the\n* controls built by the currently running application.\n*\n* @return the control under the cursor\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public Control getCursorControl()"
		},
		"protected void create(DeviceData data)":{
			"methodBody":"{\n    checkSubclass();\n    checkDisplay(thread = Thread.currentThread(), true);\n    createDisplay(data);\n    register(this);\n    if (Default == null)\n        Default = this;\n}",
			"comments":"/**\n* Creates the device in the operating system.  If the device\n* does not have a handle, this method may do nothing depending\n* on the device.\n* <p>\n* This method is called before <code>init</code>.\n* </p>\n*\n* @param data the DeviceData which describes the receiver\n*\n* @see #init\n*/\n",
			"methodName":"protected void create(DeviceData data)"
		},
		"public Rectangle map(Control from, Control to, int x, int y, int width, int height)":{
			"methodBody":"{\n    checkDevice();\n    if (from != null && from.isDisposed())\n        error(SWT.ERROR_INVALID_ARGUMENT);\n    if (to != null && to.isDisposed())\n        error(SWT.ERROR_INVALID_ARGUMENT);\n    int hwndFrom = from != null ? from.handle : 0;\n    int hwndTo = to != null ? to.handle : 0;\n    RECT rect = new RECT();\n    rect.left = x;\n    rect.top = y;\n    rect.right = x + width;\n    rect.bottom = y + height;\n    OS.MapWindowPoints(hwndFrom, hwndTo, rect, 2);\n    return new Rectangle(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);\n}",
			"comments":"/**\n* Maps a point from one coordinate system to another.\n* When the control is null, coordinates are mapped to\n* the display.\n* <p>\n* NOTE: On right-to-left platforms where the coordinate\n* systems are mirrored, special care needs to be taken\n* when mapping coordinates from one control to another\n* to ensure the result is correctly mirrored.\n*\n* Mapping a point that is the origin of a rectangle and\n* then adding the width and height is not equivalent to\n* mapping the rectangle.  When one control is mirrored\n* and the other is not, adding the width and height to a\n* point that was mapped causes the rectangle to extend\n* in the wrong direction.  Mapping the entire rectangle\n* instead of just one point causes both the origin and\n* the corner of the rectangle to be mapped.\n* </p>\n*\n* @param from the source <code>Control</code> or <code>null</code>\n* @param to the destination <code>Control</code> or <code>null</code>\n* @param x coordinates to be mapped\n* @param y coordinates to be mapped\n* @param width coordinates to be mapped\n* @param height coordinates to be mapped\n* @return rectangle with mapped coordinates\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the Control from or the Control to have been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @since 2.1.2\n*/\n",
			"methodName":"public Rectangle map(Control from, Control to, int x, int y, int width, int height)"
		},
		"public Widget findWidget(int handle)":{
			"methodBody":"{\n    checkDevice();\n    return getControl(handle);\n}",
			"comments":"/**\n* Given the operating system handle for a widget, returns\n* the instance of the <code>Widget</code> subclass which\n* represents it in the currently running application, if\n* such exists, or null if no matching widget can be found.\n* <p>\n* <b>IMPORTANT:</b> This method should not be called from\n* application code. The arguments are platform-specific.\n* </p>\n*\n* @param handle the handle for the widget\n* @return the SWT widget that the handle represents\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public Widget findWidget(int handle)"
		},
		"public Monitor[] getMonitors()":{
			"methodBody":"{\n    checkDevice();\n    if (OS.IsWinCE || OS.WIN32_VERSION < OS.VERSION(4, 10)) {\n        return new Monitor[] { getPrimaryMonitor() };\n    }\n    monitors = new Monitor[4];\n    \n    Callback callback = new Callback(this, \"monitorEnumProc\", 4);\n    int lpfnEnum = callback.getAddress();\n    if (lpfnEnum == 0)\n        SWT.error(SWT.ERROR_NO_MORE_CALLBACKS);\n    OS.EnumDisplayMonitors(0, null, lpfnEnum, 0);\n    callback.dispose();\n    Monitor[] result = new Monitor[monitorCount];\n    System.arraycopy(monitors, 0, result, 0, monitorCount);\n    monitors = null;\n    monitorCount = 0;\n    return result;\n}",
			"comments":"/**\n* Returns an array of monitors attached to the device.\n*\n* @return the array of monitors\n*\n* @since 3.0\n*/\n//$NON-NLS-1$\n",
			"methodName":"public Monitor[] getMonitors()"
		},
		"boolean translateMnemonic(MSG msg, Control control)":{
			"methodBody":"{\n    switch(msg.message) {\n        case OS.WM_CHAR:\n        case OS.WM_SYSCHAR:\n            return control.translateMnemonic(msg);\n    }\n    return false;\n}",
			"comments":"",
			"methodName":"boolean translateMnemonic(MSG msg, Control control)"
		},
		"public Control getFocusControl()":{
			"methodBody":"{\n    checkDevice();\n    if (focusControl != null && !focusControl.isDisposed()) {\n        return focusControl;\n    }\n    return _getFocusControl();\n}",
			"comments":"/**\n* Returns the control which currently has keyboard focus,\n* or null if keyboard events are not currently going to\n* any of the controls built by the currently running\n* application.\n*\n* @return the control under the cursor\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public Control getFocusControl()"
		},
		"Control _getFocusControl()":{
			"methodBody":"{\n    return findControl(OS.GetFocus());\n}",
			"comments":"",
			"methodName":"Control _getFocusControl()"
		},
		"public static void setAppName(String name)":{
			"methodBody":"{\n\n}",
			"comments":"/**\n* On platforms which support it, sets the application name\n* to be the argument. On Motif, for example, this can be used\n* to set the name used for resource lookup.  Specifying\n* <code>null</code> for the name clears it.\n*\n* @param name the new app name or <code>null</code>\n*/\n/* Do nothing */\n",
			"methodName":"public static void setAppName(String name)"
		},
		"Shell getModalShell()":{
			"methodBody":"{\n    if (modalShells == null)\n        return null;\n    int index = modalShells.length;\n    while (--index >= 0) {\n        Shell shell = modalShells[index];\n        if (shell != null)\n            return shell;\n    }\n    return null;\n}",
			"comments":"",
			"methodName":"Shell getModalShell()"
		},
		"int msgFilterProc(int code, int wParam, int lParam)":{
			"methodBody":"{\n    if (!ignoreMsgFilter) {\n        if (code >= 0) {\n            OS.MoveMemory(hookMsg, lParam, MSG.sizeof);\n            if (hookMsg.message == OS.WM_NULL) {\n                MSG msg = new MSG();\n                int flags = OS.PM_NOREMOVE | OS.PM_NOYIELD | OS.PM_QS_INPUT | OS.PM_QS_POSTMESSAGE;\n                if (!OS.PeekMessage(msg, 0, 0, 0, flags)) {\n                    if (runAsyncMessages(false))\n                        wakeThread();\n                }\n            }\n        }\n    }\n    return OS.CallNextHookEx(filterHook, code, wParam, lParam);\n}",
			"comments":"",
			"methodName":"int msgFilterProc(int code, int wParam, int lParam)"
		},
		"public void internal_dispose_GC(int hDC, GCData data)":{
			"methodBody":"{\n    OS.ReleaseDC(0, hDC);\n}",
			"comments":"/**\n* Invokes platform specific functionality to dispose a GC handle.\n* <p>\n* <b>IMPORTANT:</b> This method is <em>not</em> part of the public\n* API for <code>Display</code>. It is marked public only so that it\n* can be shared within the packages provided by SWT. It is not\n* available on all platforms, and should never be called from\n* application code.\n* </p>\n*\n* @param hDC the platform specific GC handle\n* @param data the platform specific GC data\n*/\n",
			"methodName":"public void internal_dispose_GC(int hDC, GCData data)"
		},
		"static synchronized void deregister(Display display)":{
			"methodBody":"{\n    for (int i = 0; i < Displays.length; i++) {\n        if (display == Displays[i])\n            Displays[i] = null;\n    }\n}",
			"comments":"",
			"methodName":"static synchronized void deregister(Display display)"
		},
		"static int createMaskFromAlpha(ImageData data, int destWidth, int destHeight)":{
			"methodBody":"{\n    int srcWidth = data.width;\n    int srcHeight = data.height;\n    ImageData mask = ImageData.internal_new(srcWidth, srcHeight, 1, new PaletteData(new RGB[] { new RGB(0, 0, 0), new RGB(0xff, 0xff, 0xff) }), 2, null, 1, null, null, -1, -1, -1, 0, 0, 0, 0);\n    int ap = 0;\n    for (int y = 0; y < mask.height; y++) {\n        for (int x = 0; x < mask.width; x++) {\n            mask.setPixel(x, y, (data.alphaData[ap++] & 0xff) <= 127 ? 1 : 0);\n        }\n    }\n    int hMask = OS.CreateBitmap(srcWidth, srcHeight, 1, 1, mask.data);\n    if (srcWidth != destWidth || srcHeight != destHeight) {\n        int hdc = OS.GetDC(0);\n        int hdc1 = OS.CreateCompatibleDC(hdc);\n        OS.SelectObject(hdc1, hMask);\n        int hdc2 = OS.CreateCompatibleDC(hdc);\n        int hMask2 = OS.CreateBitmap(destWidth, destHeight, 1, 1, null);\n        OS.SelectObject(hdc2, hMask2);\n        if (!OS.IsWinCE)\n            OS.SetStretchBltMode(hdc2, OS.COLORONCOLOR);\n        OS.StretchBlt(hdc2, 0, 0, destWidth, destHeight, hdc1, 0, 0, srcWidth, srcHeight, OS.SRCCOPY);\n        OS.DeleteDC(hdc1);\n        OS.DeleteDC(hdc2);\n        OS.ReleaseDC(0, hdc);\n        OS.DeleteObject(hMask);\n        hMask = hMask2;\n    }\n    return hMask;\n}",
			"comments":"",
			"methodName":"static int createMaskFromAlpha(ImageData data, int destWidth, int destHeight)"
		},
		"int numpadKey(int key)":{
			"methodBody":"{\n    switch(key) {\n        case OS.VK_NUMPAD0:\n            return '0';\n        case OS.VK_NUMPAD1:\n            return '1';\n        case OS.VK_NUMPAD2:\n            return '2';\n        case OS.VK_NUMPAD3:\n            return '3';\n        case OS.VK_NUMPAD4:\n            return '4';\n        case OS.VK_NUMPAD5:\n            return '5';\n        case OS.VK_NUMPAD6:\n            return '6';\n        case OS.VK_NUMPAD7:\n            return '7';\n        case OS.VK_NUMPAD8:\n            return '8';\n        case OS.VK_NUMPAD9:\n            return '9';\n        case OS.VK_MULTIPLY:\n            return '*';\n        case OS.VK_ADD:\n            return '+';\n        case OS.VK_SEPARATOR:\n            return '\\0';\n        case OS.VK_SUBTRACT:\n            return '-';\n        case OS.VK_DECIMAL:\n            return '.';\n        case OS.VK_DIVIDE:\n            return '/';\n    }\n    return 0;\n}",
			"comments":"",
			"methodName":"int numpadKey(int key)"
		},
		"MenuItem getMenuItem(int id)":{
			"methodBody":"{\n    if (items == null)\n        return null;\n    id = id - ID_START;\n    if (0 <= id && id < items.length)\n        return items[id];\n    return null;\n}",
			"comments":"",
			"methodName":"MenuItem getMenuItem(int id)"
		},
		"public Rectangle map(Control from, Control to, Rectangle rectangle)":{
			"methodBody":"{\n    checkDevice();\n    if (rectangle == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    return map(from, to, rectangle.x, rectangle.y, rectangle.width, rectangle.height);\n}",
			"comments":"/**\n* Maps a point from one coordinate system to another.\n* When the control is null, coordinates are mapped to\n* the display.\n* <p>\n* NOTE: On right-to-left platforms where the coordinate\n* systems are mirrored, special care needs to be taken\n* when mapping coordinates from one control to another\n* to ensure the result is correctly mirrored.\n*\n* Mapping a point that is the origin of a rectangle and\n* then adding the width and height is not equivalent to\n* mapping the rectangle.  When one control is mirrored\n* and the other is not, adding the width and height to a\n* point that was mapped causes the rectangle to extend\n* in the wrong direction.  Mapping the entire rectangle\n* instead of just one point causes both the origin and\n* the corner of the rectangle to be mapped.\n* </p>\n*\n* @param from the source <code>Control</code> or <code>null</code>\n* @param to the destination <code>Control</code> or <code>null</code>\n* @param rectangle to be mapped\n* @return rectangle with mapped coordinates\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the rectangle is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the Control from or the Control to have been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @since 2.1.2\n*/\n",
			"methodName":"public Rectangle map(Control from, Control to, Rectangle rectangle)"
		},
		"void addPopup(Menu menu)":{
			"methodBody":"{\n    if (popups == null)\n        popups = new Menu[4];\n    int length = popups.length;\n    for (int i = 0; i < length; i++) {\n        if (popups[i] == menu)\n            return;\n    }\n    int index = 0;\n    while (index < length) {\n        if (popups[index] == null)\n            break;\n        index++;\n    }\n    if (index == length) {\n        Menu[] newPopups = new Menu[length + 4];\n        System.arraycopy(popups, 0, newPopups, 0, length);\n        popups = newPopups;\n    }\n    popups[index] = menu;\n}",
			"comments":"",
			"methodName":"void addPopup(Menu menu)"
		},
		"public void setData(String key, Object value)":{
			"methodBody":"{\n    checkDevice();\n    if (key == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    \n    if (value == null) {\n        if (keys == null)\n            return;\n        int index = 0;\n        while (index < keys.length && !keys[index].equals(key)) index++;\n        if (index == keys.length)\n            return;\n        if (keys.length == 1) {\n            keys = null;\n            values = null;\n        } else {\n            String[] newKeys = new String[keys.length - 1];\n            Object[] newValues = new Object[values.length - 1];\n            System.arraycopy(keys, 0, newKeys, 0, index);\n            System.arraycopy(keys, index + 1, newKeys, index, newKeys.length - index);\n            System.arraycopy(values, 0, newValues, 0, index);\n            System.arraycopy(values, index + 1, newValues, index, newValues.length - index);\n            keys = newKeys;\n            values = newValues;\n        }\n        return;\n    }\n    \n    if (keys == null) {\n        keys = new String[] { key };\n        values = new Object[] { value };\n        return;\n    }\n    for (int i = 0; i < keys.length; i++) {\n        if (keys[i].equals(key)) {\n            values[i] = value;\n            return;\n        }\n    }\n    String[] newKeys = new String[keys.length + 1];\n    Object[] newValues = new Object[values.length + 1];\n    System.arraycopy(keys, 0, newKeys, 0, keys.length);\n    System.arraycopy(values, 0, newValues, 0, values.length);\n    newKeys[keys.length] = key;\n    newValues[values.length] = value;\n    keys = newKeys;\n    values = newValues;\n}",
			"comments":"/**\n* Sets the application defined property of the receiver\n* with the specified name to the given argument.\n* <p>\n* Applications may have associated arbitrary objects with the\n* receiver in this fashion. If the objects stored in the\n* properties need to be notified when the display is disposed\n* of, it is the application's responsibility provide a\n* <code>disposeExec()</code> handler which does so.\n* </p>\n*\n* @param key the name of the property\n* @param value the new value for the property\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the key is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #getData(String)\n* @see #disposeExec(Runnable)\n*/\n/* Remove the key/value pair */\n/* Add the key/value pair */\n",
			"methodName":"public void setData(String key, Object value)"
		},
		"boolean filters(int eventType)":{
			"methodBody":"{\n    if (filterTable == null)\n        return false;\n    return filterTable.hooks(eventType);\n}",
			"comments":"",
			"methodName":"boolean filters(int eventType)"
		},
		"public Shell[] getShells()":{
			"methodBody":"{\n    checkDevice();\n    int count = 0;\n    for (int i = 0; i < controlTable.length; i++) {\n        Control control = controlTable[i];\n        if (control != null && control instanceof Shell)\n            count++;\n    }\n    int index = 0;\n    Shell[] result = new Shell[count];\n    for (int i = 0; i < controlTable.length; i++) {\n        Control control = controlTable[i];\n        if (control != null && control instanceof Shell) {\n            result[index++] = (Shell) control;\n        }\n    }\n    return result;\n}",
			"comments":"/**\n* Returns a (possibly empty) array containing all shells which have\n* not been disposed and have the receiver as their display.\n*\n* @return the receiver's shells\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public Shell[] getShells()"
		},
		"public Font getSystemFont()":{
			"methodBody":"{\n    checkDevice();\n    int hFont = systemFont();\n    return Font.win32_new(this, hFont);\n}",
			"comments":"/**\n* Returns a reasonable font for applications to use.\n* On some platforms, this will match the \"default font\"\n* or \"system font\" if such can be found.  This font\n* should not be free'd because it was allocated by the\n* system, not the application.\n* <p>\n* Typically, applications which want the default look\n* should simply not set the font on the widgets they\n* create. Widgets are always created with the correct\n* default font for the class of user-interface component\n* they represent.\n* </p>\n*\n* @return a font\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public Font getSystemFont()"
		},
		"boolean filterMessage(MSG msg)":{
			"methodBody":"{\n    int message = msg.message;\n    if (OS.WM_KEYFIRST <= message && message <= OS.WM_KEYLAST) {\n        Control control = findControl(msg.hwnd);\n        if (control != null) {\n            if (translateAccelerator(msg, control) || translateMnemonic(msg, control) || translateTraversal(msg, control)) {\n                lastAscii = lastKey = 0;\n                lastVirtual = lastNull = lastDead = false;\n                return true;\n            }\n        }\n    }\n    return false;\n}",
			"comments":"",
			"methodName":"boolean filterMessage(MSG msg)"
		},
		"public Rectangle getBounds()":{
			"methodBody":"{\n    checkDevice();\n    if (OS.GetSystemMetrics(OS.SM_CMONITORS) < 2) {\n        int width = OS.GetSystemMetrics(OS.SM_CXSCREEN);\n        int height = OS.GetSystemMetrics(OS.SM_CYSCREEN);\n        return new Rectangle(0, 0, width, height);\n    }\n    int x = OS.GetSystemMetrics(OS.SM_XVIRTUALSCREEN);\n    int y = OS.GetSystemMetrics(OS.SM_YVIRTUALSCREEN);\n    int width = OS.GetSystemMetrics(OS.SM_CXVIRTUALSCREEN);\n    int height = OS.GetSystemMetrics(OS.SM_CYVIRTUALSCREEN);\n    return new Rectangle(x, y, width, height);\n}",
			"comments":"/**\n* Returns a rectangle describing the receiver's size and location.\n*\n* @return the bounding rectangle\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public Rectangle getBounds()"
		},
		"public void wake()":{
			"methodBody":"{\n    if (isDisposed())\n        error(SWT.ERROR_DEVICE_DISPOSED);\n    if (thread == Thread.currentThread())\n        return;\n    wakeThread();\n}",
			"comments":"/**\n* If the receiver's user-interface thread was <code>sleep</code>ing,\n* causes it to be awakened and start running again. Note that this\n* method may be called from any thread.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #sleep\n*/\n",
			"methodName":"public void wake()"
		},
		"static boolean isValidClass(Class clazz)":{
			"methodBody":"{\n    String name = clazz.getName();\n    int index = name.lastIndexOf('.');\n    return name.substring(0, index + 1).equals(PACKAGE_PREFIX);\n}",
			"comments":"",
			"methodName":"static boolean isValidClass(Class clazz)"
		},
		"public void run()":{
			"methodBody":"{\n    Device device = getCurrent();\n    if (device == null) {\n        device = getDefault();\n    }\n    setDevice(device);\n}",
			"comments":"",
			"methodName":"public void run()"
		},
		"Shell getModalDialogShell()":{
			"methodBody":"{\n    if (modalDialogShell != null && modalDialogShell.isDisposed())\n        modalDialogShell = null;\n    return modalDialogShell;\n}",
			"comments":"",
			"methodName":"Shell getModalDialogShell()"
		},
		"public Cursor getSystemCursor(int id)":{
			"methodBody":"{\n    checkDevice();\n    if (!(0 <= id && id < cursors.length))\n        return null;\n    if (cursors[id] == null) {\n        cursors[id] = new Cursor(this, id);\n    }\n    return cursors[id];\n}",
			"comments":"/**\n* Returns the matching standard platform cursor for the given\n* constant, which should be one of the cursor constants\n* specified in class <code>SWT</code>. This cursor should\n* not be free'd because it was allocated by the system,\n* not the application.  A value of <code>null</code> will\n* be returned if the supplied constant is not an swt cursor\n* constant.\n*\n* @param id the swt cursor constant\n* @return the corresponding cursor or <code>null</code>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see SWT#CURSOR_ARROW\n* @see SWT#CURSOR_WAIT\n* @see SWT#CURSOR_CROSS\n* @see SWT#CURSOR_APPSTARTING\n* @see SWT#CURSOR_HELP\n* @see SWT#CURSOR_SIZEALL\n* @see SWT#CURSOR_SIZENESW\n* @see SWT#CURSOR_SIZENS\n* @see SWT#CURSOR_SIZENWSE\n* @see SWT#CURSOR_SIZEWE\n* @see SWT#CURSOR_SIZEN\n* @see SWT#CURSOR_SIZES\n* @see SWT#CURSOR_SIZEE\n* @see SWT#CURSOR_SIZEW\n* @see SWT#CURSOR_SIZENE\n* @see SWT#CURSOR_SIZESE\n* @see SWT#CURSOR_SIZESW\n* @see SWT#CURSOR_SIZENW\n* @see SWT#CURSOR_UPARROW\n* @see SWT#CURSOR_IBEAM\n* @see SWT#CURSOR_NO\n* @see SWT#CURSOR_HAND\n*\n* @since 3.0\n*/\n",
			"methodName":"public Cursor getSystemCursor(int id)"
		},
		"void postEvent(Event event)":{
			"methodBody":"{\n    \n    if (eventQueue == null)\n        eventQueue = new Event[4];\n    int index = 0;\n    int length = eventQueue.length;\n    while (index < length) {\n        if (eventQueue[index] == null)\n            break;\n        index++;\n    }\n    if (index == length) {\n        Event[] newQueue = new Event[length + 4];\n        System.arraycopy(eventQueue, 0, newQueue, 0, length);\n        eventQueue = newQueue;\n    }\n    eventQueue[index] = event;\n}",
			"comments":"/*\n* Place the event at the end of the event queue.\n* This code is always called in the Display's\n* thread so it must be re-enterant but does not\n* need to be synchronized.\n*/\n",
			"methodName":"void postEvent(Event event)"
		},
		"boolean runAsyncMessages(boolean all)":{
			"methodBody":"{\n    return synchronizer.runAsyncMessages(all);\n}",
			"comments":"",
			"methodName":"boolean runAsyncMessages(boolean all)"
		},
		"int getMessageCount()":{
			"methodBody":"{\n    return synchronizer.getMessageCount();\n}",
			"comments":"",
			"methodName":"int getMessageCount()"
		},
		"protected void checkDevice()":{
			"methodBody":"{\n    if (thread == null)\n        error(SWT.ERROR_WIDGET_DISPOSED);\n    if (thread != Thread.currentThread())\n        error(SWT.ERROR_THREAD_INVALID_ACCESS);\n    if (isDisposed())\n        error(SWT.ERROR_DEVICE_DISPOSED);\n}",
			"comments":"",
			"methodName":"protected void checkDevice()"
		},
		"public void removeFilter(int eventType, Listener listener)":{
			"methodBody":"{\n    checkDevice();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (filterTable == null)\n        return;\n    filterTable.unhook(eventType, listener);\n    if (filterTable.size() == 0)\n        filterTable = null;\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notifed when an event of the given type occurs anywhere in\n* a widget.\n*\n* @param eventType the type of event to listen for\n* @param listener the listener which should no longer be notified when the event occurs\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n* </ul>\n*\n* @see Listener\n* @see #addFilter\n* @see #addListener\n*\n* @since 3.0\n*/\n",
			"methodName":"public void removeFilter(int eventType, Listener listener)"
		},
		"public void beep()":{
			"methodBody":"{\n    checkDevice();\n    OS.MessageBeep(OS.MB_OK);\n}",
			"comments":"/**\n* Causes the system hardware to emit a short sound\n* (if it supports this capability).\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void beep()"
		},
		"public int getDoubleClickTime()":{
			"methodBody":"{\n    checkDevice();\n    return OS.GetDoubleClickTime();\n}",
			"comments":"/**\n* Returns the longest duration, in milliseconds, between\n* two mouse button clicks that will be considered a\n* <em>double click</em> by the underlying operating system.\n*\n* @return the double click time\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public int getDoubleClickTime()"
		},
		"public int getDismissalAlignment()":{
			"methodBody":"{\n    checkDevice();\n    return SWT.LEFT;\n}",
			"comments":"/**\n* Returns the button dismissal alignment, one of <code>LEFT</code> or <code>RIGHT</code>.\n* The button dismissal alignment is the ordering that should be used when positioning the\n* default dismissal button for a dialog.  For example, in a dialog that contains an OK and\n* CANCEL button, on platforms where the button dismissal alignment is <code>LEFT</code>, the\n* button ordering should be OK/CANCEL.  When button dismissal alignment is <code>RIGHT</code>,\n* the button ordering should be CANCEL/OK.\n*\n* @return the button dismissal order\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @since 2.1\n*/\n",
			"methodName":"public int getDismissalAlignment()"
		},
		"void releaseImageList(ImageList list)":{
			"methodBody":"{\n    int i = 0;\n    int length = imageList.length;\n    while (i < length) {\n        if (imageList[i] == list) {\n            if (list.removeRef() > 0)\n                return;\n            list.dispose();\n            System.arraycopy(imageList, i + 1, imageList, i, --length - i);\n            imageList[length] = null;\n            for (int j = 0; j < length; j++) {\n                if (imageList[j] != null)\n                    return;\n            }\n            imageList = null;\n            return;\n        }\n        i++;\n    }\n}",
			"comments":"",
			"methodName":"void releaseImageList(ImageList list)"
		},
		"public Thread getThread()":{
			"methodBody":"{\n    if (isDisposed())\n        error(SWT.ERROR_DEVICE_DISPOSED);\n    return thread;\n}",
			"comments":"/**\n* Returns the user-interface thread for the receiver.\n*\n* @return the receiver's user-interface thread\n*\n* @exception SWTException <ul>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public Thread getThread()"
		},
		"ImageList getImageListToolBarDisabled(int style, int width, int height)":{
			"methodBody":"{\n    if (toolDisabledImageList == null)\n        toolDisabledImageList = new ImageList[4];\n    int i = 0;\n    int length = toolDisabledImageList.length;\n    while (i < length) {\n        ImageList list = toolDisabledImageList[i];\n        if (list == null)\n            break;\n        Point size = list.getImageSize();\n        if (size.x == width && size.y == height) {\n            if (list.getStyle() == style) {\n                list.addRef();\n                return list;\n            }\n        }\n        i++;\n    }\n    if (i == length) {\n        ImageList[] newList = new ImageList[length + 4];\n        System.arraycopy(toolDisabledImageList, 0, newList, 0, length);\n        toolDisabledImageList = newList;\n    }\n    ImageList list = new ImageList(style);\n    toolDisabledImageList[i] = list;\n    list.addRef();\n    return list;\n}",
			"comments":"",
			"methodName":"ImageList getImageListToolBarDisabled(int style, int width, int height)"
		},
		"Control removeControl(int handle)":{
			"methodBody":"{\n    if (handle == 0)\n        return null;\n    Control control = null;\n    int index;\n    if (USE_PROPERTY) {\n        index = OS.RemoveProp(handle, SWT_OBJECT_INDEX) - 1;\n    } else {\n        index = OS.GetWindowLong(handle, OS.GWL_USERDATA) - 1;\n    }\n    if (0 <= index && index < controlTable.length) {\n        control = controlTable[index];\n        controlTable[index] = null;\n        indexTable[index] = freeSlot;\n        freeSlot = index;\n        if (!USE_PROPERTY) {\n            OS.SetWindowLong(handle, OS.GWL_USERDATA, 0);\n        }\n    }\n    return control;\n}",
			"comments":"",
			"methodName":"Control removeControl(int handle)"
		},
		"public void setData(Object data)":{
			"methodBody":"{\n    checkDevice();\n    this.data = data;\n}",
			"comments":"/**\n* Sets the application defined, display specific data\n* associated with the receiver, to the argument.\n* The <em>display specific data</em> is a single,\n* unnamed field that is stored with every display.\n* <p>\n* Applications may put arbitrary objects in this field. If\n* the object stored in the display specific data needs to\n* be notified when the display is disposed of, it is the\n* application's responsibility provide a\n* <code>disposeExec()</code> handler which does so.\n* </p>\n*\n* @param data the new display specific data\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #getData()\n* @see #disposeExec(Runnable)\n*/\n",
			"methodName":"public void setData(Object data)"
		},
		"public Rectangle getClientArea()":{
			"methodBody":"{\n    checkDevice();\n    if (OS.GetSystemMetrics(OS.SM_CMONITORS) < 2) {\n        RECT rect = new RECT();\n        OS.SystemParametersInfo(OS.SPI_GETWORKAREA, 0, rect, 0);\n        int width = rect.right - rect.left;\n        int height = rect.bottom - rect.top;\n        return new Rectangle(rect.left, rect.top, width, height);\n    }\n    int x = OS.GetSystemMetrics(OS.SM_XVIRTUALSCREEN);\n    int y = OS.GetSystemMetrics(OS.SM_YVIRTUALSCREEN);\n    int width = OS.GetSystemMetrics(OS.SM_CXVIRTUALSCREEN);\n    int height = OS.GetSystemMetrics(OS.SM_CYVIRTUALSCREEN);\n    return new Rectangle(x, y, width, height);\n}",
			"comments":"/**\n* Returns a rectangle which describes the area of the\n* receiver which is capable of displaying data.\n*\n* @return the client area\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #getBounds\n*/\n",
			"methodName":"public Rectangle getClientArea()"
		},
		"public Point getCursorLocation()":{
			"methodBody":"{\n    checkDevice();\n    POINT pt = new POINT();\n    OS.GetCursorPos(pt);\n    return new Point(pt.x, pt.y);\n}",
			"comments":"/**\n* Returns the location of the on-screen pointer relative\n* to the top left corner of the screen.\n*\n* @return the cursor location\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public Point getCursorLocation()"
		},
		"static int untranslateKey(int key)":{
			"methodBody":"{\n    for (int i = 0; i < KeyTable.length; i++) {\n        if (KeyTable[i][1] == key)\n            return KeyTable[i][0];\n    }\n    return 0;\n}",
			"comments":"",
			"methodName":"static int untranslateKey(int key)"
		},
		"public Point[] getIconSizes()":{
			"methodBody":"{\n    checkDevice();\n    return new Point[] { new Point(OS.GetSystemMetrics(OS.SM_CXSMICON), OS.GetSystemMetrics(OS.SM_CYSMICON)), new Point(OS.GetSystemMetrics(OS.SM_CXICON), OS.GetSystemMetrics(OS.SM_CYICON)) };\n}",
			"comments":"/**\n* Returns an array containing the recommended icon sizes.\n*\n* @return the array of icon sizes\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see Decorations#setImages(Image[])\n*\n* @since 3.0\n*/\n",
			"methodName":"public Point[] getIconSizes()"
		},
		"public void addListener(int eventType, Listener listener)":{
			"methodBody":"{\n    checkDevice();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        eventTable = new EventTable();\n    eventTable.hook(eventType, listener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notifed when an event of the given type occurs. When the\n* event does occur in the display, the listener is notified by\n* sending it the <code>handleEvent()</code> message.\n*\n* @param eventType the type of event to listen for\n* @param listener the listener which should be notified when the event occurs\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see Listener\n* @see #removeListener\n*\n* @since 2.0\n*/\n",
			"methodName":"public void addListener(int eventType, Listener listener)"
		},
		"public void close()":{
			"methodBody":"{\n    checkDevice();\n    Event event = new Event();\n    sendEvent(SWT.Close, event);\n    if (event.doit)\n        dispose();\n}",
			"comments":"/**\n* Requests that the connection between SWT and the underlying\n* operating system be closed.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see Device#dispose\n*\n* @since 2.0\n*/\n",
			"methodName":"public void close()"
		},
		"public Point map(Control from, Control to, Point point)":{
			"methodBody":"{\n    checkDevice();\n    if (point == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    return map(from, to, point.x, point.y);\n}",
			"comments":"/**\n* Maps a point from one coordinate system to another.\n* When the control is null, coordinates are mapped to\n* the display.\n* <p>\n* NOTE: On right-to-left platforms where the coordinate\n* systems are mirrored, special care needs to be taken\n* when mapping coordinates from one control to another\n* to ensure the result is correctly mirrored.\n*\n* Mapping a point that is the origin of a rectangle and\n* then adding the width and height is not equivalent to\n* mapping the rectangle.  When one control is mirrored\n* and the other is not, adding the width and height to a\n* point that was mapped causes the rectangle to extend\n* in the wrong direction.  Mapping the entire rectangle\n* instead of just one point causes both the origin and\n* the corner of the rectangle to be mapped.\n* </p>\n*\n* @param from the source <code>Control</code> or <code>null</code>\n* @param to the destination <code>Control</code> or <code>null</code>\n* @param point to be mapped\n* @return point with mapped coordinates\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the point is null</li>\n*    <li>ERROR_INVALID_ARGUMENT - if the Control from or the Control to have been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @since 2.1.2\n*/\n",
			"methodName":"public Point map(Control from, Control to, Point point)"
		},
		"void removeMenuItem(MenuItem item)":{
			"methodBody":"{\n    if (items == null)\n        return;\n    items[item.id - ID_START] = null;\n    item.id = -1;\n}",
			"comments":"",
			"methodName":"void removeMenuItem(MenuItem item)"
		},
		"void sendEvent(int eventType, Event event)":{
			"methodBody":"{\n    if (eventTable == null && filterTable == null) {\n        return;\n    }\n    if (event == null)\n        event = new Event();\n    event.display = this;\n    event.type = eventType;\n    if (event.time == 0)\n        event.time = getLastEventTime();\n    if (!filterEvent(event)) {\n        if (eventTable != null)\n            eventTable.sendEvent(event);\n    }\n}",
			"comments":"",
			"methodName":"void sendEvent(int eventType, Event event)"
		},
		"void setModalShell(Shell shell)":{
			"methodBody":"{\n    if (modalShells == null)\n        modalShells = new Shell[4];\n    int index = 0, length = modalShells.length;\n    while (index < length) {\n        if (modalShells[index] == shell)\n            return;\n        if (modalShells[index] == null)\n            break;\n        index++;\n    }\n    if (index == length) {\n        Shell[] newModalShells = new Shell[length + 4];\n        System.arraycopy(modalShells, 0, newModalShells, 0, length);\n        modalShells = newModalShells;\n    }\n    modalShells[index] = shell;\n    Shell[] shells = getShells();\n    for (int i = 0; i < shells.length; i++) shells[i].updateModal();\n}",
			"comments":"",
			"methodName":"void setModalShell(Shell shell)"
		},
		"static int wcsToMbcs(char ch, int codePage)":{
			"methodBody":"{\n    if (OS.IsUnicode)\n        return ch;\n    if (ch <= 0x7F)\n        return ch;\n    TCHAR buffer = new TCHAR(codePage, ch, false);\n    return buffer.tcharAt(0);\n}",
			"comments":"/*\n* Returns a single character, converted from the wide\n* character set (WCS) used by Java to the specified\n* multi-byte character set used by the operating system\n* widgets.\n*\n* @param ch the WCS character\n* @param codePage the code page used to convert the character\n* @return the MBCS character\n*/\n",
			"methodName":"static int wcsToMbcs(char ch, int codePage)"
		},
		"ImageList getImageListToolBar(int style, int width, int height)":{
			"methodBody":"{\n    if (toolImageList == null)\n        toolImageList = new ImageList[4];\n    int i = 0;\n    int length = toolImageList.length;\n    while (i < length) {\n        ImageList list = toolImageList[i];\n        if (list == null)\n            break;\n        Point size = list.getImageSize();\n        if (size.x == width && size.y == height) {\n            if (list.getStyle() == style) {\n                list.addRef();\n                return list;\n            }\n        }\n        i++;\n    }\n    if (i == length) {\n        ImageList[] newList = new ImageList[length + 4];\n        System.arraycopy(toolImageList, 0, newList, 0, length);\n        toolImageList = newList;\n    }\n    ImageList list = new ImageList(style);\n    toolImageList[i] = list;\n    list.addRef();\n    return list;\n}",
			"comments":"",
			"methodName":"ImageList getImageListToolBar(int style, int width, int height)"
		},
		"public boolean getHighContrast()":{
			"methodBody":"{\n    checkDevice();\n    if (OS.IsWinCE)\n        return false;\n    HIGHCONTRAST pvParam = new HIGHCONTRAST();\n    pvParam.cbSize = HIGHCONTRAST.sizeof;\n    OS.SystemParametersInfo(OS.SPI_GETHIGHCONTRAST, 0, pvParam, 0);\n    return (pvParam.dwFlags & OS.HCF_HIGHCONTRASTON) != 0;\n}",
			"comments":"/**\n* Returns true when the high contrast mode is enabled.\n* Otherwise, false is returned.\n* <p>\n* Note: This operation is a hint and is not supported on\n* platforms that do not have this concept.\n* </p>\n*\n* @return the high contrast mode\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public boolean getHighContrast()"
		},
		"void removePopup(Menu menu)":{
			"methodBody":"{\n    if (popups == null)\n        return;\n    for (int i = 0; i < popups.length; i++) {\n        if (popups[i] == menu) {\n            popups[i] = null;\n            return;\n        }\n    }\n}",
			"comments":"",
			"methodName":"void removePopup(Menu menu)"
		},
		"ImageList getImageList(int style, int width, int height)":{
			"methodBody":"{\n    if (imageList == null)\n        imageList = new ImageList[4];\n    int i = 0;\n    int length = imageList.length;\n    while (i < length) {\n        ImageList list = imageList[i];\n        if (list == null)\n            break;\n        Point size = list.getImageSize();\n        if (size.x == width && size.y == height) {\n            if (list.getStyle() == style) {\n                list.addRef();\n                return list;\n            }\n        }\n        i++;\n    }\n    if (i == length) {\n        ImageList[] newList = new ImageList[length + 4];\n        System.arraycopy(imageList, 0, newList, 0, length);\n        imageList = newList;\n    }\n    ImageList list = new ImageList(style);\n    imageList[i] = list;\n    list.addRef();\n    return list;\n}",
			"comments":"",
			"methodName":"ImageList getImageList(int style, int width, int height)"
		},
		"void wakeThread()":{
			"methodBody":"{\n    if (OS.IsWinCE) {\n        OS.PostMessage(hwndMessage, OS.WM_NULL, 0, 0);\n    } else {\n        OS.PostThreadMessage(threadId, OS.WM_NULL, 0, 0);\n    }\n}",
			"comments":"",
			"methodName":"void wakeThread()"
		},
		"void setModalDialogShell(Shell modalDailog)":{
			"methodBody":"{\n    if (modalDialogShell != null && modalDialogShell.isDisposed())\n        modalDialogShell = null;\n    this.modalDialogShell = modalDailog;\n    Shell[] shells = getShells();\n    for (int i = 0; i < shells.length; i++) shells[i].updateModal();\n}",
			"comments":"",
			"methodName":"void setModalDialogShell(Shell modalDailog)"
		},
		"public Color getSystemColor(int id)":{
			"methodBody":"{\n    checkDevice();\n    int pixel = 0x02000000;\n    switch(id) {\n        case SWT.COLOR_WIDGET_DARK_SHADOW:\n            pixel = OS.GetSysColor(OS.COLOR_3DDKSHADOW);\n            break;\n        case SWT.COLOR_WIDGET_NORMAL_SHADOW:\n            pixel = OS.GetSysColor(OS.COLOR_3DSHADOW);\n            break;\n        case SWT.COLOR_WIDGET_LIGHT_SHADOW:\n            pixel = OS.GetSysColor(OS.COLOR_3DLIGHT);\n            break;\n        case SWT.COLOR_WIDGET_HIGHLIGHT_SHADOW:\n            pixel = OS.GetSysColor(OS.COLOR_3DHIGHLIGHT);\n            break;\n        case SWT.COLOR_WIDGET_BACKGROUND:\n            pixel = OS.GetSysColor(OS.COLOR_3DFACE);\n            break;\n        case SWT.COLOR_WIDGET_BORDER:\n            pixel = OS.GetSysColor(OS.COLOR_WINDOWFRAME);\n            break;\n        case SWT.COLOR_WIDGET_FOREGROUND:\n        case SWT.COLOR_LIST_FOREGROUND:\n            pixel = OS.GetSysColor(OS.COLOR_WINDOWTEXT);\n            break;\n        case SWT.COLOR_LIST_BACKGROUND:\n            pixel = OS.GetSysColor(OS.COLOR_WINDOW);\n            break;\n        case SWT.COLOR_LIST_SELECTION:\n            pixel = OS.GetSysColor(OS.COLOR_HIGHLIGHT);\n            break;\n        case SWT.COLOR_LIST_SELECTION_TEXT:\n            pixel = OS.GetSysColor(OS.COLOR_HIGHLIGHTTEXT);\n            break;\n        case SWT.COLOR_INFO_FOREGROUND:\n            pixel = OS.GetSysColor(OS.COLOR_INFOTEXT);\n            break;\n        case SWT.COLOR_INFO_BACKGROUND:\n            pixel = OS.GetSysColor(OS.COLOR_INFOBK);\n            break;\n        case SWT.COLOR_TITLE_FOREGROUND:\n            pixel = OS.GetSysColor(OS.COLOR_CAPTIONTEXT);\n            break;\n        case SWT.COLOR_TITLE_BACKGROUND:\n            pixel = OS.GetSysColor(OS.COLOR_ACTIVECAPTION);\n            break;\n        case SWT.COLOR_TITLE_BACKGROUND_GRADIENT:\n            pixel = OS.GetSysColor(OS.COLOR_GRADIENTACTIVECAPTION);\n            if (pixel == 0)\n                pixel = OS.GetSysColor(OS.COLOR_ACTIVECAPTION);\n            break;\n        case SWT.COLOR_TITLE_INACTIVE_FOREGROUND:\n            pixel = OS.GetSysColor(OS.COLOR_INACTIVECAPTIONTEXT);\n            break;\n        case SWT.COLOR_TITLE_INACTIVE_BACKGROUND:\n            pixel = OS.GetSysColor(OS.COLOR_INACTIVECAPTION);\n            break;\n        case SWT.COLOR_TITLE_INACTIVE_BACKGROUND_GRADIENT:\n            pixel = OS.GetSysColor(OS.COLOR_GRADIENTINACTIVECAPTION);\n            if (pixel == 0)\n                pixel = OS.GetSysColor(OS.COLOR_INACTIVECAPTION);\n            break;\n        default:\n            return super.getSystemColor(id);\n    }\n    return Color.win32_new(this, pixel);\n}",
			"comments":"/**\n* Returns the matching standard color for the given\n* constant, which should be one of the color constants\n* specified in class <code>SWT</code>. Any value other\n* than one of the SWT color constants which is passed\n* in will result in the color black. This color should\n* not be free'd because it was allocated by the system,\n* not the application.\n*\n* @param id the color constant\n* @return the matching color\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see SWT\n*/\n",
			"methodName":"public Color getSystemColor(int id)"
		},
		"ImageList getImageListToolBarHot(int style, int width, int height)":{
			"methodBody":"{\n    if (toolHotImageList == null)\n        toolHotImageList = new ImageList[4];\n    int i = 0;\n    int length = toolHotImageList.length;\n    while (i < length) {\n        ImageList list = toolHotImageList[i];\n        if (list == null)\n            break;\n        Point size = list.getImageSize();\n        if (size.x == width && size.y == height) {\n            if (list.getStyle() == style) {\n                list.addRef();\n                return list;\n            }\n        }\n        i++;\n    }\n    if (i == length) {\n        ImageList[] newList = new ImageList[length + 4];\n        System.arraycopy(toolHotImageList, 0, newList, 0, length);\n        toolHotImageList = newList;\n    }\n    ImageList list = new ImageList(style);\n    toolHotImageList[i] = list;\n    list.addRef();\n    return list;\n}",
			"comments":"",
			"methodName":"ImageList getImageListToolBarHot(int style, int width, int height)"
		},
		"public boolean readAndDispatch()":{
			"methodBody":"{\n    checkDevice();\n    drawMenuBars();\n    runPopups();\n    if (OS.PeekMessage(msg, 0, 0, 0, OS.PM_REMOVE)) {\n        if (!filterMessage(msg)) {\n            OS.TranslateMessage(msg);\n            OS.DispatchMessage(msg);\n        }\n        runDeferredEvents();\n        return true;\n    }\n    return runAsyncMessages(false);\n}",
			"comments":"/**\n* Reads an event from the operating system's event queue,\n* dispatches it appropriately, and returns <code>true</code>\n* if there is potentially more work to do, or <code>false</code>\n* if the caller can sleep until another event is placed on\n* the event queue.\n* <p>\n* In addition to checking the system event queue, this method also\n* checks if any inter-thread messages (created by <code>syncExec()</code>\n* or <code>asyncExec()</code>) are waiting to be processed, and if\n* so handles them before returning.\n* </p>\n*\n* @return <code>false</code> if the caller can sleep upon return from this method\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_FAILED_EXEC - if an exception occurred while running an inter-thread message</li>\n* </ul>\n*\n* @see #sleep\n* @see #wake\n*/\n",
			"methodName":"public boolean readAndDispatch()"
		},
		"protected void release()":{
			"methodBody":"{\n    sendEvent(SWT.Dispose, new Event());\n    Shell[] shells = getShells();\n    for (int i = 0; i < shells.length; i++) {\n        Shell shell = shells[i];\n        if (!shell.isDisposed())\n            shell.dispose();\n    }\n    if (tray != null)\n        tray.dispose();\n    tray = null;\n    while (readAndDispatch()) {\n    }\n    if (disposeList != null) {\n        for (int i = 0; i < disposeList.length; i++) {\n            if (disposeList[i] != null)\n                disposeList[i].run();\n        }\n    }\n    disposeList = null;\n    synchronizer.releaseSynchronizer();\n    synchronizer = null;\n    releaseDisplay();\n    super.release();\n}",
			"comments":"/**\n* Releases any internal resources back to the operating\n* system and clears all fields except the device handle.\n* <p>\n* Disposes all shells which are currently open on the display.\n* After this method has been invoked, all related related shells\n* will answer <code>true</code> when sent the message\n* <code>isDisposed()</code>.\n* </p><p>\n* When a device is destroyed, resources that were acquired\n* on behalf of the programmer need to be returned to the\n* operating system.  For example, if the device allocated a\n* font to be used as the system font, this font would be\n* freed in <code>release</code>.  Also,to assist the garbage\n* collector and minimize the amount of memory that is not\n* reclaimed when the programmer keeps a reference to a\n* disposed device, all fields except the handle are zero'd.\n* The handle is needed by <code>destroy</code>.\n* </p>\n* This method is called before <code>destroy</code>.\n*\n* @see Device#dispose\n* @see #destroy\n*/\n",
			"methodName":"protected void release()"
		},
		"public void disposeExec(Runnable runnable)":{
			"methodBody":"{\n    checkDevice();\n    if (disposeList == null)\n        disposeList = new Runnable[4];\n    for (int i = 0; i < disposeList.length; i++) {\n        if (disposeList[i] == null) {\n            disposeList[i] = runnable;\n            return;\n        }\n    }\n    Runnable[] newDisposeList = new Runnable[disposeList.length + 4];\n    System.arraycopy(disposeList, 0, newDisposeList, 0, disposeList.length);\n    newDisposeList[disposeList.length] = runnable;\n    disposeList = newDisposeList;\n}",
			"comments":"/**\n* Causes the <code>run()</code> method of the runnable to\n* be invoked by the user-interface thread just before the\n* receiver is disposed.  Specifying a <code>null</code> runnable\n* is ignored.\n*\n* @param runnable code to run at dispose time.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public void disposeExec(Runnable runnable)"
		},
		"boolean filterEvent(Event event)":{
			"methodBody":"{\n    if (filterTable != null)\n        filterTable.sendEvent(event);\n    return false;\n}",
			"comments":"",
			"methodName":"boolean filterEvent(Event event)"
		},
		"public void removeListener(int eventType, Listener listener)":{
			"methodBody":"{\n    checkDevice();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (eventTable == null)\n        return;\n    eventTable.unhook(eventType, listener);\n}",
			"comments":"/**\n* Removes the listener from the collection of listeners who will\n* be notifed when an event of the given type occurs.\n*\n* @param eventType the type of event to listen for\n* @param listener the listener which should no longer be notified when the event occurs\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see Listener\n* @see #addListener\n*\n* @since 2.0\n*/\n",
			"methodName":"public void removeListener(int eventType, Listener listener)"
		},
		"int windowProc(int hwnd, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    \n    if (msg == OS.WM_NCHITTEST) {\n        if (hitCount++ >= 1024) {\n            try {\n                Thread.sleep(1);\n            } catch (Throwable t) {\n            }\n        }\n    } else {\n        hitCount = 0;\n    }\n    int index;\n    if (USE_PROPERTY) {\n        index = OS.GetProp(hwnd, SWT_OBJECT_INDEX) - 1;\n    } else {\n        index = OS.GetWindowLong(hwnd, OS.GWL_USERDATA) - 1;\n    }\n    if (0 <= index && index < controlTable.length) {\n        Control control = controlTable[index];\n        if (control != null) {\n            return control.windowProc(hwnd, msg, wParam, lParam);\n        }\n    }\n    return OS.DefWindowProc(hwnd, msg, wParam, lParam);\n}",
			"comments":"/*\n* Bug in Adobe Reader 7.0.  For some reason, when Adobe\n* Reader 7.0 is deactivated from within Internet Explorer,\n* it sends thousands of consecutive WM_NCHITTEST messages\n* to the control that is under the cursor.  It seems that\n* if the control takes some time to respond to the message,\n* Adobe stops sending them.  The fix is to detect this case\n* and sleep.\n*\n* NOTE: Under normal circumstances, Windows will never send\n* consecutive WM_NCHITTEST messages to the same control without\n* another message (normally WM_SETCURSOR) in between.\n*/\n",
			"methodName":"int windowProc(int hwnd, int msg, int wParam, int lParam)"
		},
		"int getLastEventTime()":{
			"methodBody":"{\n    return OS.IsWinCE ? OS.GetTickCount() : OS.GetMessageTime();\n}",
			"comments":"",
			"methodName":"int getLastEventTime()"
		},
		"int getMsgProc(int code, int wParam, int lParam)":{
			"methodBody":"{\n    if (embeddedHwnd == 0) {\n        int hInstance = OS.GetModuleHandle(null);\n        embeddedHwnd = OS.CreateWindowEx(0, windowClass, null, OS.WS_OVERLAPPED, 0, 0, 0, 0, 0, 0, hInstance, null);\n        \n        embeddedCallback = new Callback(this, \"embeddedProc\", 4);\n        embeddedProc = embeddedCallback.getAddress();\n        if (embeddedProc == 0)\n            error(SWT.ERROR_NO_MORE_CALLBACKS);\n        OS.SetWindowLong(embeddedHwnd, OS.GWL_WNDPROC, embeddedProc);\n    }\n    if (code >= 0 && wParam != OS.PM_NOREMOVE) {\n        MSG msg = new MSG();\n        OS.MoveMemory(msg, lParam, MSG.sizeof);\n        switch(msg.message) {\n            case OS.WM_KEYDOWN:\n            case OS.WM_KEYUP:\n            case OS.WM_SYSKEYDOWN:\n            case OS.WM_SYSKEYUP:\n                {\n                    int hHeap = OS.GetProcessHeap();\n                    int keyMsg = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, MSG.sizeof);\n                    OS.MoveMemory(keyMsg, msg, MSG.sizeof);\n                    OS.PostMessage(hwndMessage, SWT_KEYMSG, wParam, keyMsg);\n                    msg.message = OS.WM_NULL;\n                    OS.MoveMemory(lParam, msg, MSG.sizeof);\n                }\n        }\n    }\n    return OS.CallNextHookEx(msgHook, code, wParam, lParam);\n}",
			"comments":"//$NON-NLS-1$\n",
			"methodName":"int getMsgProc(int code, int wParam, int lParam)"
		},
		"boolean runDeferredEvents()":{
			"methodBody":"{\n    \n    while (eventQueue != null) {\n        \n        Event event = eventQueue[0];\n        if (event == null)\n            break;\n        int length = eventQueue.length;\n        System.arraycopy(eventQueue, 1, eventQueue, 0, --length);\n        eventQueue[length] = null;\n        \n        Widget widget = event.widget;\n        if (widget != null && !widget.isDisposed()) {\n            Widget item = event.item;\n            if (item == null || !item.isDisposed()) {\n                widget.sendEvent(event);\n            }\n        }\n    \n    }\n    \n    eventQueue = null;\n    return true;\n}",
			"comments":"/*\n* Run deferred events.  This code is always\n* called in the Display's thread so it must\n* be re-enterant but need not be synchronized.\n*/\n/* Take an event off the queue */\n/* Run the event */\n/*\n* At this point, the event queue could\n* be null due to a recursive invokation\n* when running the event.\n*/\n/* Clear the queue */\n",
			"methodName":"boolean runDeferredEvents()"
		},
		"Control getControl(int handle)":{
			"methodBody":"{\n    if (handle == 0)\n        return null;\n    int index;\n    if (USE_PROPERTY) {\n        index = OS.GetProp(handle, SWT_OBJECT_INDEX) - 1;\n    } else {\n        index = OS.GetWindowLong(handle, OS.GWL_USERDATA) - 1;\n    }\n    if (0 <= index && index < controlTable.length) {\n        Control control = controlTable[index];\n        \n        if (control != null && control.checkHandle(handle)) {\n            return control;\n        }\n    }\n    return null;\n}",
			"comments":"/*\n* Because GWL_USERDATA can be used by native widgets that\n* do not belong to SWT, it is possible that GWL_USERDATA\n* could return an index that is in the range of the table,\n* but was not put there by SWT.  Therefore, it is necessary\n* to check the handle of the control that is in the table\n* against the handle that provided the GWL_USERDATA.\n*/\n",
			"methodName":"Control getControl(int handle)"
		},
		"void clearModal(Shell shell)":{
			"methodBody":"{\n    if (modalShells == null)\n        return;\n    int index = 0, length = modalShells.length;\n    while (index < length) {\n        if (modalShells[index] == shell)\n            break;\n        if (modalShells[index] == null)\n            return;\n        index++;\n    }\n    if (index == length)\n        return;\n    System.arraycopy(modalShells, index + 1, modalShells, index, --length - index);\n    modalShells[length] = null;\n    if (index == 0 && modalShells[0] == null)\n        modalShells = null;\n    Shell[] shells = getShells();\n    for (int i = 0; i < shells.length; i++) shells[i].updateModal();\n}",
			"comments":"",
			"methodName":"void clearModal(Shell shell)"
		},
		"protected void destroy()":{
			"methodBody":"{\n    if (this == Default)\n        Default = null;\n    deregister(this);\n    destroyDisplay();\n}",
			"comments":"/**\n* Destroys the device in the operating system and releases\n* the device's handle.  If the device does not have a handle,\n* this method may do nothing depending on the device.\n* <p>\n* This method is called after <code>release</code>.\n* </p>\n* @see Device#dispose\n* @see #release\n*/\n",
			"methodName":"protected void destroy()"
		},
		"protected void checkSubclass()":{
			"methodBody":"{\n    if (!isValidClass(getClass()))\n        error(SWT.ERROR_INVALID_SUBCLASS);\n}",
			"comments":"/**\n* Checks that this class can be subclassed.\n* <p>\n* IMPORTANT: See the comment in <code>Widget.checkSubclass()</code>.\n* </p>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_INVALID_SUBCLASS - if this class is not an allowed subclass</li>\n* </ul>\n*\n* @see Widget#checkSubclass\n*/\n",
			"methodName":"protected void checkSubclass()"
		},
		"boolean translateAccelerator(MSG msg, Control control)":{
			"methodBody":"{\n    accelKeyHit = true;\n    boolean result = control.translateAccelerator(msg);\n    accelKeyHit = false;\n    return result;\n}",
			"comments":"",
			"methodName":"boolean translateAccelerator(MSG msg, Control control)"
		},
		"boolean translateTraversal(MSG msg, Control control)":{
			"methodBody":"{\n    switch(msg.message) {\n        case OS.WM_KEYDOWN:\n            switch(msg.wParam) {\n                case OS.VK_RETURN:\n                case OS.VK_ESCAPE:\n                case OS.VK_TAB:\n                case OS.VK_UP:\n                case OS.VK_DOWN:\n                case OS.VK_LEFT:\n                case OS.VK_RIGHT:\n                case OS.VK_PRIOR:\n                case OS.VK_NEXT:\n                    return control.translateTraversal(msg);\n            }\n            break;\n        case OS.WM_SYSKEYDOWN:\n            switch(msg.wParam) {\n                case OS.VK_MENU:\n                    return control.translateTraversal(msg);\n            }\n            break;\n    }\n    return false;\n}",
			"comments":"",
			"methodName":"boolean translateTraversal(MSG msg, Control control)"
		},
		"public boolean post(Event event)":{
			"methodBody":"{\n    if (isDisposed())\n        error(SWT.ERROR_DEVICE_DISPOSED);\n    if (event == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    int type = event.type;\n    switch(type) {\n        case SWT.KeyDown:\n        case SWT.KeyUp:\n            {\n                KEYBDINPUT inputs = new KEYBDINPUT();\n                inputs.wVk = (short) untranslateKey(event.keyCode);\n                if (inputs.wVk == 0) {\n                    char key = event.character;\n                    switch(key) {\n                        case SWT.BS:\n                            inputs.wVk = (short) OS.VK_BACK;\n                            break;\n                        case SWT.CR:\n                            inputs.wVk = (short) OS.VK_RETURN;\n                            break;\n                        case SWT.DEL:\n                            inputs.wVk = (short) OS.VK_DELETE;\n                            break;\n                        case SWT.ESC:\n                            inputs.wVk = (short) OS.VK_ESCAPE;\n                            break;\n                        case SWT.TAB:\n                            inputs.wVk = (short) OS.VK_TAB;\n                            break;\n                        \n                        case SWT.LF:\n                            return false;\n                        default:\n                            {\n                                if (OS.IsWinCE) {\n                                    inputs.wVk = OS.CharUpper((short) key);\n                                } else {\n                                    inputs.wVk = OS.VkKeyScan((short) wcsToMbcs(key, 0));\n                                    if (inputs.wVk == -1)\n                                        return false;\n                                }\n                            }\n                    }\n                }\n                inputs.dwFlags = type == SWT.KeyUp ? OS.KEYEVENTF_KEYUP : 0;\n                int hHeap = OS.GetProcessHeap();\n                int pInputs = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, INPUT.sizeof);\n                OS.MoveMemory(pInputs, new int[] { OS.INPUT_KEYBOARD }, 4);\n                OS.MoveMemory(pInputs + 4, inputs, KEYBDINPUT.sizeof);\n                boolean result = OS.SendInput(1, pInputs, INPUT.sizeof) != 0;\n                OS.HeapFree(hHeap, 0, pInputs);\n                return result;\n            }\n        case SWT.MouseDown:\n        case SWT.MouseMove:\n        case SWT.MouseUp:\n            {\n                MOUSEINPUT inputs = new MOUSEINPUT();\n                if (type == SWT.MouseMove) {\n                    inputs.dwFlags = OS.MOUSEEVENTF_MOVE | OS.MOUSEEVENTF_ABSOLUTE;\n                    inputs.dx = event.x * 65535 / (OS.GetSystemMetrics(OS.SM_CXSCREEN) - 1);\n                    inputs.dy = event.y * 65535 / (OS.GetSystemMetrics(OS.SM_CYSCREEN) - 1);\n                } else {\n                    switch(event.button) {\n                        case 1:\n                            inputs.dwFlags = type == SWT.MouseDown ? OS.MOUSEEVENTF_LEFTDOWN : OS.MOUSEEVENTF_LEFTUP;\n                            break;\n                        case 2:\n                            inputs.dwFlags = type == SWT.MouseDown ? OS.MOUSEEVENTF_MIDDLEDOWN : OS.MOUSEEVENTF_MIDDLEUP;\n                            break;\n                        case 3:\n                            inputs.dwFlags = type == SWT.MouseDown ? OS.MOUSEEVENTF_RIGHTDOWN : OS.MOUSEEVENTF_RIGHTUP;\n                            break;\n                        default:\n                            return false;\n                    }\n                }\n                int hHeap = OS.GetProcessHeap();\n                int pInputs = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, INPUT.sizeof);\n                OS.MoveMemory(pInputs, new int[] { OS.INPUT_MOUSE }, 4);\n                OS.MoveMemory(pInputs + 4, inputs, MOUSEINPUT.sizeof);\n                boolean result = OS.SendInput(1, pInputs, INPUT.sizeof) != 0;\n                OS.HeapFree(hHeap, 0, pInputs);\n                return result;\n            }\n    }\n    return false;\n}",
			"comments":"/**\n* Generate a low level system event.\n*\n* <code>post</code> is used to generate low level keyboard\n* and mouse events. The intent is to enable automated UI\n* testing by simulating the input from the user.  Most\n* SWT applications should never need to call this method.\n* <p>\n* Note that this operation can fail when the operating system\n* fails to generate the event for any reason.  For example,\n* this can happen when there is no such key or mouse button\n* or when the system event queue is full.\n* </p>\n* <p>\n* <b>Event Types:</b>\n* <p>KeyDown, KeyUp\n* <p>The following fields in the <code>Event</code> apply:\n* <ul>\n* <li>(in) type KeyDown or KeyUp</li>\n* <p> Either one of:\n* <li>(in) character a character that corresponds to a keyboard key</li>\n* <li>(in) keyCode the key code of the key that was typed,\n*          as defined by the key code constants in class <code>SWT</code></li>\n* </ul>\n* <p>MouseDown, MouseUp</p>\n* <p>The following fields in the <code>Event</code> apply:\n* <ul>\n* <li>(in) type MouseDown or MouseUp\n* <li>(in) button the button that is pressed or released\n* </ul>\n* <p>MouseMove</p>\n* <p>The following fields in the <code>Event</code> apply:\n* <ul>\n* <li>(in) type MouseMove\n* <li>(in) x the x coordinate to move the mouse pointer to in screen coordinates\n* <li>(in) y the y coordinate to move the mouse pointer to in screen coordinates\n* </ul>\n* </dl>\n*\n* @param event the event to be generated\n*\n* @return true if the event was generated or false otherwise\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the event is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @since 3.0\n*\n*/\n/*\n* Since there is no LF key on the keyboard, do not attempt\n* to map LF to CR or attempt to post an LF key.\n*/\n//\t\t\t\t\tcase SWT.LF: inputs.wVk = (short) OS.VK_RETURN; break;\n",
			"methodName":"public boolean post(Event event)"
		},
		"static String withCrLf(String string)":{
			"methodBody":"{\n    \n    int length = string.length();\n    if (length == 0)\n        return string;\n    \n    int i = string.indexOf('\\n', 0);\n    if (i == -1)\n        return string;\n    if (i > 0 && string.charAt(i - 1) == '\\r') {\n        return string;\n    }\n    \n    i++;\n    int count = 1;\n    while (i < length) {\n        if ((i = string.indexOf('\\n', i)) == -1)\n            break;\n        count++;\n        i++;\n    }\n    count += length;\n    \n    i = 0;\n    StringBuffer result = new StringBuffer(count);\n    while (i < length) {\n        int j = string.indexOf('\\n', i);\n        if (j == -1)\n            j = length;\n        result.append(string.substring(i, j));\n        if ((i = j) < length) {\n            \n            result.append(\"\\r\\n\");\n            i++;\n        }\n    }\n    return result.toString();\n}",
			"comments":"/* If the string is empty, return the string. */\n/*\n* Check for an LF or CR/LF and assume the rest of\n* the string is formated that way.  This will not\n* work if the string contains mixed delimiters.\n*/\n/*\n* The string is formatted with LF.  Compute the\n* number of lines and the size of the buffer\n* needed to hold the result\n*/\n/* Create a new string with the CR/LF line terminator. */\n//$NON-NLS-1$\n",
			"methodName":"static String withCrLf(String string)"
		},
		"public boolean sleep()":{
			"methodBody":"{\n    checkDevice();\n    if (getMessageCount() != 0)\n        return true;\n    if (OS.IsWinCE) {\n        OS.MsgWaitForMultipleObjectsEx(0, 0, OS.INFINITE, OS.QS_ALLINPUT, OS.MWMO_INPUTAVAILABLE);\n        return true;\n    }\n    return OS.WaitMessage();\n}",
			"comments":"/**\n* Causes the user-interface thread to <em>sleep</em> (that is,\n* to be put in a state where it does not consume CPU cycles)\n* until an event is received or it is otherwise awakened.\n*\n* @return <code>true</code> if an event requiring dispatching was placed on the queue.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #wake\n*/\n",
			"methodName":"public boolean sleep()"
		},
		"protected void init()":{
			"methodBody":"{\n    super.init();\n    \n    \n    windowCallback = new Callback(this, \"windowProc\", 4);\n    windowProc = windowCallback.getAddress();\n    if (windowProc == 0)\n        error(SWT.ERROR_NO_MORE_CALLBACKS);\n    \n    threadId = OS.GetCurrentThreadId();\n    \n    windowClass = new TCHAR(0, WindowName + WindowClassCount, true);\n    windowShadowClass = new TCHAR(0, WindowShadowName + WindowClassCount, true);\n    WindowClassCount++;\n    \n    int hHeap = OS.GetProcessHeap();\n    int hInstance = OS.GetModuleHandle(null);\n    WNDCLASS lpWndClass = new WNDCLASS();\n    lpWndClass.hInstance = hInstance;\n    lpWndClass.lpfnWndProc = windowProc;\n    lpWndClass.style = OS.CS_BYTEALIGNWINDOW | OS.CS_DBLCLKS;\n    lpWndClass.hCursor = OS.LoadCursor(0, OS.IDC_ARROW);\n    int byteCount = windowClass.length() * TCHAR.sizeof;\n    lpWndClass.lpszClassName = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, byteCount);\n    OS.MoveMemory(lpWndClass.lpszClassName, windowClass, byteCount);\n    OS.RegisterClass(lpWndClass);\n    \n    if (OS.WIN32_VERSION >= OS.VERSION(5, 1)) {\n        lpWndClass.style |= OS.CS_DROPSHADOW;\n    }\n    byteCount = windowShadowClass.length() * TCHAR.sizeof;\n    lpWndClass.lpszClassName = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, byteCount);\n    OS.MoveMemory(lpWndClass.lpszClassName, windowShadowClass, byteCount);\n    OS.RegisterClass(lpWndClass);\n    \n    int systemFont = 0;\n    if (!OS.IsWinCE) {\n        NONCLIENTMETRICS info = OS.IsUnicode ? (NONCLIENTMETRICS) new NONCLIENTMETRICSW() : new NONCLIENTMETRICSA();\n        info.cbSize = NONCLIENTMETRICS.sizeof;\n        if (OS.SystemParametersInfo(OS.SPI_GETNONCLIENTMETRICS, 0, info, 0)) {\n            systemFont = OS.CreateFontIndirect(OS.IsUnicode ? (LOGFONT) ((NONCLIENTMETRICSW) info).lfMessageFont : ((NONCLIENTMETRICSA) info).lfMessageFont);\n        }\n    }\n    if (systemFont == 0)\n        systemFont = OS.GetStockObject(OS.DEFAULT_GUI_FONT);\n    if (systemFont == 0)\n        systemFont = OS.GetStockObject(OS.SYSTEM_FONT);\n    if (systemFont != 0)\n        systemFonts = new int[] { systemFont };\n    \n    hwndMessage = OS.CreateWindowEx(0, windowClass, null, OS.WS_OVERLAPPED, 0, 0, 0, 0, 0, 0, hInstance, null);\n    \n    messageCallback = new Callback(this, \"messageProc\", 4);\n    messageProc = messageCallback.getAddress();\n    if (messageProc == 0)\n        error(SWT.ERROR_NO_MORE_CALLBACKS);\n    OS.SetWindowLong(hwndMessage, OS.GWL_WNDPROC, messageProc);\n    \n    if (!OS.IsWinCE) {\n        \n        msgFilterCallback = new Callback(this, \"msgFilterProc\", 3);\n        msgFilterProc = msgFilterCallback.getAddress();\n        if (msgFilterProc == 0)\n            error(SWT.ERROR_NO_MORE_CALLBACKS);\n        filterHook = OS.SetWindowsHookEx(OS.WH_MSGFILTER, msgFilterProc, 0, threadId);\n    }\n    \n    if (!OS.IsWinCE) {\n        \n        foregroundIdleCallback = new Callback(this, \"foregroundIdleProc\", 3);\n        foregroundIdleProc = foregroundIdleCallback.getAddress();\n        if (foregroundIdleProc == 0)\n            error(SWT.ERROR_NO_MORE_CALLBACKS);\n        idleHook = OS.SetWindowsHookEx(OS.WH_FOREGROUNDIDLE, foregroundIdleProc, 0, threadId);\n    }\n    \n    SWT_TASKBARCREATED = OS.RegisterWindowMessage(new TCHAR(0, \"TaskbarCreated\", true));\n    \n    if (!OS.IsWinCE) {\n        OS.OleInitialize(0);\n    }\n    \n    indexTable = new int[GROW_SIZE];\n    controlTable = new Control[GROW_SIZE];\n    for (int i = 0; i < GROW_SIZE - 1; i++) indexTable[i] = i + 1;\n    indexTable[GROW_SIZE - 1] = -1;\n}",
			"comments":"/**\n* Initializes any internal resources needed by the\n* device.\n* <p>\n* This method is called after <code>create</code>.\n* </p>\n*\n* @see #create\n*/\n/* Create the callbacks */\n//$NON-NLS-1$\n/* Remember the current thread id */\n/* Use the character encoding for the default locale */\n/* Register the SWT window class */\n/* Register the SWT drop shadow window class */\n/* Initialize the system font */\n/* Create the message only HWND */\n//$NON-NLS-1$\n/* Create the filter hook */\n//$NON-NLS-1$\n/* Create the idle hook */\n//$NON-NLS-1$\n/* Register the task bar created message */\n/* Initialize OLE */\n/* Initialize the Widget Table */\n",
			"methodName":"protected void init()"
		},
		"int shiftedKey(int key)":{
			"methodBody":"{\n    if (OS.IsWinCE)\n        return 0;\n    \n    for (int i = 0; i < keyboard.length; i++) keyboard[i] = 0;\n    keyboard[OS.VK_SHIFT] |= 0x80;\n    \n    if (OS.IsUnicode) {\n        char[] result = new char[1];\n        if (OS.ToUnicode(key, key, keyboard, result, 1, 0) == 1)\n            return result[0];\n    } else {\n        short[] result = new short[1];\n        if (OS.ToAscii(key, key, keyboard, result, 0) == 1)\n            return result[0];\n    }\n    return 0;\n}",
			"comments":"/* Clear the virtual keyboard and press the shift key */\n/* Translate the key to ASCII or UNICODE using the virtual keyboard */\n",
			"methodName":"int shiftedKey(int key)"
		},
		"public void setCursorLocation(Point point)":{
			"methodBody":"{\n    checkDevice();\n    if (point == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    setCursorLocation(point.x, point.y);\n}",
			"comments":"/**\n* Sets the location of the on-screen pointer relative to the top left corner\n* of the screen.  <b>Note: It is typically considered bad practice for a\n* program to move the on-screen pointer location.</b>\n*\n* @param point new position\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_NULL_ARGUMENT - if the point is null\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @since 2.0\n*/\n",
			"methodName":"public void setCursorLocation(Point point)"
		},
		"public Point map(Control from, Control to, int x, int y)":{
			"methodBody":"{\n    checkDevice();\n    if (from != null && from.isDisposed())\n        error(SWT.ERROR_INVALID_ARGUMENT);\n    if (to != null && to.isDisposed())\n        error(SWT.ERROR_INVALID_ARGUMENT);\n    int hwndFrom = from != null ? from.handle : 0;\n    int hwndTo = to != null ? to.handle : 0;\n    POINT point = new POINT();\n    point.x = x;\n    point.y = y;\n    OS.MapWindowPoints(hwndFrom, hwndTo, point, 1);\n    return new Point(point.x, point.y);\n}",
			"comments":"/**\n* Maps a point from one coordinate system to another.\n* When the control is null, coordinates are mapped to\n* the display.\n* <p>\n* NOTE: On right-to-left platforms where the coordinate\n* systems are mirrored, special care needs to be taken\n* when mapping coordinates from one control to another\n* to ensure the result is correctly mirrored.\n*\n* Mapping a point that is the origin of a rectangle and\n* then adding the width and height is not equivalent to\n* mapping the rectangle.  When one control is mirrored\n* and the other is not, adding the width and height to a\n* point that was mapped causes the rectangle to extend\n* in the wrong direction.  Mapping the entire rectangle\n* instead of just one point causes both the origin and\n* the corner of the rectangle to be mapped.\n* </p>\n*\n* @param from the source <code>Control</code> or <code>null</code>\n* @param to the destination <code>Control</code> or <code>null</code>\n* @param x coordinates to be mapped\n* @param y coordinates to be mapped\n* @return point with mapped coordinates\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_INVALID_ARGUMENT - if the Control from or the Control to have been disposed</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @since 2.1.2\n*/\n",
			"methodName":"public Point map(Control from, Control to, int x, int y)"
		},
		"int embeddedProc(int hwnd, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    switch(msg) {\n        case SWT_KEYMSG:\n            {\n                MSG keyMsg = new MSG();\n                OS.MoveMemory(keyMsg, lParam, MSG.sizeof);\n                OS.TranslateMessage(keyMsg);\n                OS.DispatchMessage(keyMsg);\n                int hHeap = OS.GetProcessHeap();\n                OS.HeapFree(hHeap, 0, lParam);\n                break;\n            }\n        case SWT_DESTROY:\n            {\n                OS.DestroyWindow(hwnd);\n                if (embeddedCallback != null)\n                    embeddedCallback.dispose();\n                if (getMsgCallback != null)\n                    getMsgCallback.dispose();\n                embeddedCallback = getMsgCallback = null;\n                embeddedProc = getMsgProc = 0;\n                break;\n            }\n    }\n    return OS.DefWindowProc(hwnd, msg, wParam, lParam);\n}",
			"comments":"",
			"methodName":"int embeddedProc(int hwnd, int msg, int wParam, int lParam)"
		},
		"static synchronized void checkDisplay(Thread thread, boolean multiple)":{
			"methodBody":"{\n    for (int i = 0; i < Displays.length; i++) {\n        if (Displays[i] != null) {\n            if (!multiple)\n                SWT.error(SWT.ERROR_NOT_IMPLEMENTED, null, \" [multiple displays]\");\n            if (Displays[i].thread == thread)\n                SWT.error(SWT.ERROR_THREAD_INVALID_ACCESS);\n        }\n    }\n}",
			"comments":"",
			"methodName":"static synchronized void checkDisplay(Thread thread, boolean multiple)"
		},
		"void addMenuItem(MenuItem item)":{
			"methodBody":"{\n    if (items == null)\n        items = new MenuItem[64];\n    for (int i = 0; i < items.length; i++) {\n        if (items[i] == null) {\n            item.id = i + ID_START;\n            items[i] = item;\n            return;\n        }\n    }\n    item.id = items.length + ID_START;\n    MenuItem[] newItems = new MenuItem[items.length + 64];\n    newItems[items.length] = item;\n    System.arraycopy(items, 0, newItems, 0, items.length);\n    items = newItems;\n}",
			"comments":"",
			"methodName":"void addMenuItem(MenuItem item)"
		},
		"int controlKey(int key)":{
			"methodBody":"{\n    int upper = OS.CharUpper((short) key);\n    if (64 <= upper && upper <= 95)\n        return upper & 0xBF;\n    return key;\n}",
			"comments":"",
			"methodName":"int controlKey(int key)"
		},
		"public void syncExec(Runnable runnable)":{
			"methodBody":"{\n    if (isDisposed())\n        error(SWT.ERROR_DEVICE_DISPOSED);\n    synchronizer.syncExec(runnable);\n}",
			"comments":"/**\n* Causes the <code>run()</code> method of the runnable to\n* be invoked by the user-interface thread at the next\n* reasonable opportunity. The thread which calls this method\n* is suspended until the runnable completes.  Specifying <code>null</code>\n* as the runnable simply wakes the user-interface thread.\n* <p>\n* Note that at the time the runnable is invoked, widgets\n* that have the receiver as their display may have been\n* disposed. Therefore, it is necessary to check for this\n* case inside the runnable before accessing the widget.\n* </p>\n*\n* @param runnable code to run on the user-interface thread or <code>null</code>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_FAILED_EXEC - if an exception occured when executing the runnable</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #asyncExec\n*/\n",
			"methodName":"public void syncExec(Runnable runnable)"
		},
		"void removeBar(Menu menu)":{
			"methodBody":"{\n    if (bars == null)\n        return;\n    for (int i = 0; i < bars.length; i++) {\n        if (bars[i] == menu) {\n            bars[i] = null;\n            return;\n        }\n    }\n}",
			"comments":"",
			"methodName":"void removeBar(Menu menu)"
		},
		"static char mbcsToWcs(int ch, int codePage)":{
			"methodBody":"{\n    if (OS.IsUnicode)\n        return (char) ch;\n    int key = ch & 0xFFFF;\n    if (key <= 0x7F)\n        return (char) ch;\n    byte[] buffer;\n    if (key <= 0xFF) {\n        buffer = new byte[1];\n        buffer[0] = (byte) key;\n    } else {\n        buffer = new byte[2];\n        buffer[0] = (byte) ((key >> 8) & 0xFF);\n        buffer[1] = (byte) (key & 0xFF);\n    }\n    char[] unicode = new char[1];\n    int cp = codePage != 0 ? codePage : OS.CP_ACP;\n    int count = OS.MultiByteToWideChar(cp, OS.MB_PRECOMPOSED, buffer, buffer.length, unicode, 1);\n    if (count == 0)\n        return 0;\n    return unicode[0];\n}",
			"comments":"/*\n* Returns a single character, converted from the specified\n* multi-byte character set (MBCS) used by the operating\n* system widgets to a wide character set (WCS) used by Java.\n*\n* @param ch the MBCS character\n* @param codePage the code page used to convert the character\n* @return the WCS character\n*/\n",
			"methodName":"static char mbcsToWcs(int ch, int codePage)"
		},
		"public Tray getSystemTray()":{
			"methodBody":"{\n    checkDevice();\n    if (tray != null)\n        return tray;\n    return tray = new Tray(this, SWT.NONE);\n}",
			"comments":"/**\n* Returns the single instance of the system tray or null\n* when there is no system tray available for the platform.\n*\n* @return the system tray or <code>null</code>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public Tray getSystemTray()"
		},
		"public void timerExec(int milliseconds, Runnable runnable)":{
			"methodBody":"{\n    checkDevice();\n    if (runnable == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (timerList == null)\n        timerList = new Runnable[4];\n    if (timerIds == null)\n        timerIds = new int[4];\n    int index = 0;\n    while (index < timerList.length) {\n        if (timerList[index] == runnable)\n            break;\n        index++;\n    }\n    int timerId = 0;\n    if (index != timerList.length) {\n        timerId = timerIds[index];\n        if (milliseconds < 0) {\n            OS.KillTimer(hwndMessage, timerId);\n            timerList[index] = null;\n            timerIds[index] = 0;\n            return;\n        }\n    } else {\n        if (milliseconds < 0)\n            return;\n        index = 0;\n        while (index < timerList.length) {\n            if (timerList[index] == null)\n                break;\n            index++;\n        }\n        nextTimerId++;\n        timerId = nextTimerId;\n        if (index == timerList.length) {\n            Runnable[] newTimerList = new Runnable[timerList.length + 4];\n            System.arraycopy(timerList, 0, newTimerList, 0, timerList.length);\n            timerList = newTimerList;\n            int[] newTimerIds = new int[timerIds.length + 4];\n            System.arraycopy(timerIds, 0, newTimerIds, 0, timerIds.length);\n            timerIds = newTimerIds;\n        }\n    }\n    int newTimerID = OS.SetTimer(hwndMessage, timerId, milliseconds, 0);\n    if (newTimerID != 0) {\n        timerList[index] = runnable;\n        timerIds[index] = newTimerID;\n    }\n}",
			"comments":"/**\n* Causes the <code>run()</code> method of the runnable to\n* be invoked by the user-interface thread after the specified\n* number of milliseconds have elapsed. If milliseconds is less\n* than zero, the runnable is not executed.\n* <p>\n* Note that at the time the runnable is invoked, widgets\n* that have the receiver as their display may have been\n* disposed. Therefore, it is necessary to check for this\n* case inside the runnable before accessing the widget.\n* </p>\n*\n* @param milliseconds the delay before running the runnable\n* @param runnable code to run on the user-interface thread\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the runnable is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #asyncExec\n*/\n",
			"methodName":"public void timerExec(int milliseconds, Runnable runnable)"
		},
		"static int wcsToMbcs(char ch)":{
			"methodBody":"{\n    return wcsToMbcs(ch, 0);\n}",
			"comments":"/*\n* Returns a single character, converted from the wide\n* character set (WCS) used by Java to the default\n* multi-byte character set used by the operating system\n* widgets.\n*\n* @param ch the WCS character\n* @return the MBCS character\n*/\n",
			"methodName":"static int wcsToMbcs(char ch)"
		},
		"void addControl(int handle, Control control)":{
			"methodBody":"{\n    if (handle == 0)\n        return;\n    if (freeSlot == -1) {\n        int length = (freeSlot = indexTable.length) + GROW_SIZE;\n        int[] newIndexTable = new int[length];\n        Control[] newControlTable = new Control[length];\n        System.arraycopy(indexTable, 0, newIndexTable, 0, freeSlot);\n        System.arraycopy(controlTable, 0, newControlTable, 0, freeSlot);\n        for (int i = freeSlot; i < length - 1; i++) newIndexTable[i] = i + 1;\n        newIndexTable[length - 1] = -1;\n        indexTable = newIndexTable;\n        controlTable = newControlTable;\n    }\n    if (USE_PROPERTY) {\n        OS.SetProp(handle, SWT_OBJECT_INDEX, freeSlot + 1);\n    } else {\n        OS.SetWindowLong(handle, OS.GWL_USERDATA, freeSlot + 1);\n    }\n    int oldSlot = freeSlot;\n    freeSlot = indexTable[oldSlot];\n    indexTable[oldSlot] = -2;\n    controlTable[oldSlot] = control;\n}",
			"comments":"",
			"methodName":"void addControl(int handle, Control control)"
		},
		"int systemFont()":{
			"methodBody":"{\n    int hFont = 0;\n    if (systemFonts != null) {\n        int length = systemFonts.length;\n        if (length != 0)\n            hFont = systemFonts[length - 1];\n    }\n    if (hFont == 0)\n        hFont = OS.GetStockObject(OS.DEFAULT_GUI_FONT);\n    if (hFont == 0)\n        hFont = OS.GetStockObject(OS.SYSTEM_FONT);\n    return hFont;\n}",
			"comments":"",
			"methodName":"int systemFont()"
		},
		"public Widget findWidget(int handle, int id)":{
			"methodBody":"{\n    Control control = getControl(handle);\n    return control != null ? control.findItem(id) : null;\n}",
			"comments":"/**\n* Given the operating system handle for a widget,\n* and widget-specific id, returns the instance of\n* the <code>Widget</code> subclass which represents\n* the handle/id pair in the currently running application,\n* if such exists, or null if no matching widget can be found.\n* <p>\n* <b>IMPORTANT:</b> This method should not be called from\n* application code. The arguments are platform-specific.\n* </p>\n*\n* @param handle the handle for the widget\n* @param id the id for the subwidget (usually an item)\n* @return the SWT widget that the handle/id pair represents\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @since 3.1\n*/\n",
			"methodName":"public Widget findWidget(int handle, int id)"
		},
		"void releaseToolImageList(ImageList list)":{
			"methodBody":"{\n    int i = 0;\n    int length = toolImageList.length;\n    while (i < length) {\n        if (toolImageList[i] == list) {\n            if (list.removeRef() > 0)\n                return;\n            list.dispose();\n            System.arraycopy(toolImageList, i + 1, toolImageList, i, --length - i);\n            toolImageList[length] = null;\n            for (int j = 0; j < length; j++) {\n                if (toolImageList[j] != null)\n                    return;\n            }\n            toolImageList = null;\n            return;\n        }\n        i++;\n    }\n}",
			"comments":"",
			"methodName":"void releaseToolImageList(ImageList list)"
		},
		"public Shell getActiveShell()":{
			"methodBody":"{\n    checkDevice();\n    Control control = findControl(OS.GetActiveWindow());\n    return control != null ? control.getShell() : null;\n}",
			"comments":"/**\n* Returns the currently active <code>Shell</code>, or null\n* if no shell belonging to the currently running application\n* is active.\n*\n* @return the active shell or null\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public Shell getActiveShell()"
		},
		"boolean runPopups()":{
			"methodBody":"{\n    if (popups == null)\n        return false;\n    boolean result = false;\n    while (popups != null) {\n        Menu menu = popups[0];\n        if (menu == null)\n            break;\n        int length = popups.length;\n        System.arraycopy(popups, 1, popups, 0, --length);\n        popups[length] = null;\n        runDeferredEvents();\n        menu._setVisible(true);\n        result = true;\n    }\n    popups = null;\n    return result;\n}",
			"comments":"",
			"methodName":"boolean runPopups()"
		},
		"static int create32bitDIB(int hBitmap, int alpha, byte[] alphaData, int transparentPixel)":{
			"methodBody":"{\n    BITMAP bm = new BITMAP();\n    OS.GetObject(hBitmap, BITMAP.sizeof, bm);\n    int imgWidth = bm.bmWidth;\n    int imgHeight = bm.bmHeight;\n    int hDC = OS.GetDC(0);\n    int srcHdc = OS.CreateCompatibleDC(hDC);\n    int oldSrcBitmap = OS.SelectObject(srcHdc, hBitmap);\n    int memHdc = OS.CreateCompatibleDC(hDC);\n    BITMAPINFOHEADER bmiHeader = new BITMAPINFOHEADER();\n    bmiHeader.biSize = BITMAPINFOHEADER.sizeof;\n    bmiHeader.biWidth = imgWidth;\n    bmiHeader.biHeight = -imgHeight;\n    bmiHeader.biPlanes = 1;\n    bmiHeader.biBitCount = (short) 32;\n    bmiHeader.biCompression = OS.BI_RGB;\n    byte[] bmi = new byte[BITMAPINFOHEADER.sizeof];\n    OS.MoveMemory(bmi, bmiHeader, BITMAPINFOHEADER.sizeof);\n    int[] pBits = new int[1];\n    int memDib = OS.CreateDIBSection(0, bmi, OS.DIB_RGB_COLORS, pBits, 0, 0);\n    if (memDib == 0)\n        SWT.error(SWT.ERROR_NO_HANDLES);\n    int oldMemBitmap = OS.SelectObject(memHdc, memDib);\n    BITMAP dibBM = new BITMAP();\n    OS.GetObject(memDib, BITMAP.sizeof, dibBM);\n    int sizeInBytes = dibBM.bmWidthBytes * dibBM.bmHeight;\n    OS.BitBlt(memHdc, 0, 0, imgWidth, imgHeight, srcHdc, 0, 0, OS.SRCCOPY);\n    byte red = 0, green = 0, blue = 0;\n    if (transparentPixel != -1) {\n        if (bm.bmBitsPixel <= 8) {\n            byte[] color = new byte[4];\n            OS.GetDIBColorTable(srcHdc, transparentPixel, 1, color);\n            blue = color[0];\n            green = color[1];\n            red = color[2];\n        } else {\n            switch(bm.bmBitsPixel) {\n                case 16:\n                    blue = (byte) ((transparentPixel & 0x1F) << 3);\n                    green = (byte) ((transparentPixel & 0x3E0) >> 2);\n                    red = (byte) ((transparentPixel & 0x7C00) >> 7);\n                    break;\n                case 24:\n                    blue = (byte) ((transparentPixel & 0xFF0000) >> 16);\n                    green = (byte) ((transparentPixel & 0xFF00) >> 8);\n                    red = (byte) (transparentPixel & 0xFF);\n                    break;\n                case 32:\n                    blue = (byte) ((transparentPixel & 0xFF000000) >>> 24);\n                    green = (byte) ((transparentPixel & 0xFF0000) >> 16);\n                    red = (byte) ((transparentPixel & 0xFF00) >> 8);\n                    break;\n            }\n        }\n    }\n    OS.SelectObject(srcHdc, oldSrcBitmap);\n    OS.SelectObject(memHdc, oldMemBitmap);\n    OS.DeleteObject(srcHdc);\n    OS.DeleteObject(memHdc);\n    OS.ReleaseDC(0, hDC);\n    byte[] srcData = new byte[sizeInBytes];\n    OS.MoveMemory(srcData, pBits[0], sizeInBytes);\n    if (alpha != -1) {\n        for (int y = 0, dp = 0; y < imgHeight; ++y) {\n            for (int x = 0; x < imgWidth; ++x) {\n                srcData[dp + 3] = (byte) alpha;\n                dp += 4;\n            }\n        }\n    } else if (alphaData != null) {\n        for (int y = 0, dp = 0, ap = 0; y < imgHeight; ++y) {\n            for (int x = 0; x < imgWidth; ++x) {\n                srcData[dp + 3] = alphaData[ap++];\n                dp += 4;\n            }\n        }\n    } else if (transparentPixel != -1) {\n        for (int y = 0, dp = 0; y < imgHeight; ++y) {\n            for (int x = 0; x < imgWidth; ++x) {\n                if (srcData[dp] == blue && srcData[dp + 1] == green && srcData[dp + 2] == red) {\n                    srcData[dp + 3] = (byte) 0;\n                } else {\n                    srcData[dp + 3] = (byte) 0xFF;\n                }\n                dp += 4;\n            }\n        }\n    }\n    OS.MoveMemory(pBits[0], srcData, sizeInBytes);\n    return memDib;\n}",
			"comments":"",
			"methodName":"static int create32bitDIB(int hBitmap, int alpha, byte[] alphaData, int transparentPixel)"
		},
		"void releaseDisplay()":{
			"methodBody":"{\n    if (embeddedHwnd != 0) {\n        OS.PostMessage(embeddedHwnd, SWT_DESTROY, 0, 0);\n    }\n    \n    if (!OS.IsWinCE) {\n        if (msgHook != 0)\n            OS.UnhookWindowsHookEx(msgHook);\n        msgHook = 0;\n    }\n    \n    if (!OS.IsWinCE) {\n        if (filterHook != 0)\n            OS.UnhookWindowsHookEx(filterHook);\n        filterHook = 0;\n        msgFilterCallback.dispose();\n        msgFilterCallback = null;\n        msgFilterProc = 0;\n    }\n    \n    if (!OS.IsWinCE) {\n        if (idleHook != 0)\n            OS.UnhookWindowsHookEx(idleHook);\n        idleHook = 0;\n        foregroundIdleCallback.dispose();\n        foregroundIdleCallback = null;\n        foregroundIdleProc = 0;\n    }\n    \n    if (hwndMessage != 0)\n        OS.DestroyWindow(hwndMessage);\n    hwndMessage = 0;\n    messageCallback.dispose();\n    messageCallback = null;\n    messageProc = 0;\n    \n    int hHeap = OS.GetProcessHeap();\n    int hInstance = OS.GetModuleHandle(null);\n    WNDCLASS lpWndClass = new WNDCLASS();\n    OS.GetClassInfo(0, windowClass, lpWndClass);\n    OS.UnregisterClass(windowClass, hInstance);\n    OS.HeapFree(hHeap, 0, lpWndClass.lpszClassName);\n    \n    OS.GetClassInfo(0, windowShadowClass, lpWndClass);\n    OS.UnregisterClass(windowShadowClass, hInstance);\n    OS.HeapFree(hHeap, 0, lpWndClass.lpszClassName);\n    windowClass = windowShadowClass = null;\n    windowCallback.dispose();\n    windowCallback = null;\n    windowProc = 0;\n    \n    if (systemFonts != null) {\n        for (int i = 0; i < systemFonts.length; i++) {\n            if (systemFonts[i] != 0)\n                OS.DeleteObject(systemFonts[i]);\n        }\n    }\n    systemFonts = null;\n    \n    if (errorIcon != 0)\n        OS.DestroyIcon(errorIcon);\n    if (infoIcon != 0)\n        OS.DestroyIcon(infoIcon);\n    if (questionIcon != 0)\n        OS.DestroyIcon(questionIcon);\n    if (warningIcon != 0)\n        OS.DestroyIcon(warningIcon);\n    errorIcon = infoIcon = questionIcon = warningIcon = 0;\n    \n    for (int i = 0; i < cursors.length; i++) {\n        if (cursors[i] != null)\n            cursors[i].dispose();\n    }\n    cursors = null;\n    \n    if (lpCustColors != 0)\n        OS.HeapFree(hHeap, 0, lpCustColors);\n    lpCustColors = 0;\n    \n    if (!OS.IsWinCE) {\n        OS.OleUninitialize();\n    }\n    \n    thread = null;\n    msg = null;\n    keyboard = null;\n    modalDialogShell = null;\n    modalShells = null;\n    data = null;\n    keys = null;\n    values = null;\n    bars = popups = null;\n    indexTable = null;\n    controlTable = null;\n    lastHittestControl = null;\n    imageList = toolImageList = toolHotImageList = toolDisabledImageList = null;\n}",
			"comments":"/* Unhook the message hook */\n/* Unhook the filter hook */\n/* Unhook the idle hook */\n/* Destroy the message only HWND */\n/* Unregister the SWT window class */\n/* Unregister the SWT drop shadow window class */\n/* Release the system fonts */\n/* Release the System Images */\n/* Release the System Cursors */\n/* Release Custom Colors for ChooseColor */\n/* Uninitialize OLE */\n/* Release references */\n",
			"methodName":"void releaseDisplay()"
		},
		"public void addFilter(int eventType, Listener listener)":{
			"methodBody":"{\n    checkDevice();\n    if (listener == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (filterTable == null)\n        filterTable = new EventTable();\n    filterTable.hook(eventType, listener);\n}",
			"comments":"/**\n* Adds the listener to the collection of listeners who will\n* be notifed when an event of the given type occurs anywhere\n* in a widget. When the event does occur, the listener is\n* notified by sending it the <code>handleEvent()</code> message.\n* <p>\n* Setting the type of an event to <code>SWT.None</code> from\n* within the <code>handleEvent()</code> method can be used to\n* change the event type and stop subsequent Java listeners\n* from running. Because event filters run before other listeners,\n* event filters can both block other listeners and set arbitrary\n* fields within an event. For this reason, event filters are both\n* powerful and dangerous. They should generally be avoided for\n* performance, debugging and code maintenance reasons.\n* </p>\n*\n* @param eventType the type of event to listen for\n* @param listener the listener which should be notified when the event occurs\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see Listener\n* @see #removeFilter\n* @see #removeListener\n*\n* @since 3.0\n*/\n",
			"methodName":"public void addFilter(int eventType, Listener listener)"
		},
		"void addBar(Menu menu)":{
			"methodBody":"{\n    if (bars == null)\n        bars = new Menu[4];\n    int length = bars.length;\n    for (int i = 0; i < length; i++) {\n        if (bars[i] == menu)\n            return;\n    }\n    int index = 0;\n    while (index < length) {\n        if (bars[index] == null)\n            break;\n        index++;\n    }\n    if (index == length) {\n        Menu[] newBars = new Menu[length + 4];\n        System.arraycopy(bars, 0, newBars, 0, length);\n        bars = newBars;\n    }\n    bars[index] = menu;\n}",
			"comments":"",
			"methodName":"void addBar(Menu menu)"
		},
		"void drawMenuBars()":{
			"methodBody":"{\n    if (bars == null)\n        return;\n    for (int i = 0; i < bars.length; i++) {\n        Menu menu = bars[i];\n        if (menu != null && !menu.isDisposed())\n            menu.update();\n    }\n    bars = null;\n}",
			"comments":"",
			"methodName":"void drawMenuBars()"
		},
		"public Point[] getCursorSizes()":{
			"methodBody":"{\n    checkDevice();\n    return new Point[] { new Point(OS.GetSystemMetrics(OS.SM_CXCURSOR), OS.GetSystemMetrics(OS.SM_CYCURSOR)) };\n}",
			"comments":"/**\n* Returns an array containing the recommended cursor sizes.\n*\n* @return the array of cursor sizes\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @since 3.0\n*/\n",
			"methodName":"public Point[] getCursorSizes()"
		},
		"int messageProc(int hwnd, int msg, int wParam, int lParam)":{
			"methodBody":"{\n    switch(msg) {\n        case SWT_KEYMSG:\n            boolean consumed = false;\n            MSG keyMsg = new MSG();\n            OS.MoveMemory(keyMsg, lParam, MSG.sizeof);\n            Control control = findControl(keyMsg.hwnd);\n            if (control != null) {\n                keyMsg.hwnd = control.handle;\n                int flags = OS.PM_REMOVE | OS.PM_NOYIELD | OS.PM_QS_INPUT | OS.PM_QS_POSTMESSAGE;\n                do {\n                    if (!(consumed |= filterMessage(keyMsg))) {\n                        OS.TranslateMessage(keyMsg);\n                        consumed |= OS.DispatchMessage(keyMsg) == 1;\n                    }\n                } while (OS.PeekMessage(keyMsg, keyMsg.hwnd, OS.WM_KEYFIRST, OS.WM_KEYLAST, flags));\n            }\n            if (consumed) {\n                int hHeap = OS.GetProcessHeap();\n                OS.HeapFree(hHeap, 0, lParam);\n            } else {\n                OS.PostMessage(embeddedHwnd, SWT_KEYMSG, wParam, lParam);\n            }\n            return 0;\n        case SWT_TRAYICONMSG:\n            if (tray != null) {\n                TrayItem[] items = tray.items;\n                for (int i = 0; i < items.length; i++) {\n                    TrayItem item = items[i];\n                    if (item != null && item.id == wParam) {\n                        return item.messageProc(hwnd, msg, wParam, lParam);\n                    }\n                }\n            }\n            return 0;\n        case OS.WM_ACTIVATEAPP:\n            \n            if (wParam != 0) {\n                if (!isXMouseActive()) {\n                    if (modalDialogShell != null && modalDialogShell.isDisposed())\n                        modalDialogShell = null;\n                    Shell modal = modalDialogShell != null ? modalDialogShell : getModalShell();\n                    if (modal != null) {\n                        int hwndModal = modal.handle;\n                        if (OS.IsWindowEnabled(hwndModal)) {\n                            modal.bringToTop();\n                            if (modal.isDisposed())\n                                break;\n                        }\n                        int hwndPopup = OS.GetLastActivePopup(hwndModal);\n                        if (hwndPopup != 0 && hwndPopup != modal.handle) {\n                            if (getControl(hwndPopup) == null) {\n                                if (OS.IsWindowEnabled(hwndPopup)) {\n                                    OS.SetActiveWindow(hwndPopup);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            break;\n        case OS.WM_ENDSESSION:\n            if (wParam != 0) {\n                dispose();\n                \n                System.exit(0);\n            }\n            break;\n        case OS.WM_QUERYENDSESSION:\n            Event event = new Event();\n            sendEvent(SWT.Close, event);\n            if (!event.doit)\n                return 0;\n            break;\n        case OS.WM_SETTINGCHANGE:\n            updateFont();\n            break;\n        case OS.WM_TIMER:\n            runTimer(wParam);\n            break;\n        default:\n            if (msg == SWT_TASKBARCREATED) {\n                if (tray != null) {\n                    TrayItem[] items = tray.items;\n                    for (int i = 0; i < items.length; i++) {\n                        TrayItem item = items[i];\n                        if (item != null)\n                            item.recreate();\n                    }\n                }\n            }\n    }\n    return OS.DefWindowProc(hwnd, msg, wParam, lParam);\n}",
			"comments":"/*\n* Feature in Windows.  When multiple shells are\n* disabled and one of the shells has an enabled\n* dialog child and the user selects a disabled\n* shell that does not have the enabled dialog\n* child using the Task bar, Windows brings the\n* disabled shell to the front.  As soon as the\n* user clicks on the disabled shell, the enabled\n* dialog child comes to the front.  This behavior\n* is unspecified and seems strange.  Normally, a\n* disabled shell is frozen on the screen and the\n* user cannot change the z-order by clicking with\n* the mouse.  The fix is to look for WM_ACTIVATEAPP\n* and force the enabled dialog child to the front.\n* This is typically what the user is expecting.\n*\n* NOTE: If the modal shell is disabled for any\n* reason, it should not be brought to the front.\n*/\n/*\n* When the session is ending, no SWT program can continue\n* to run.  In order to avoid running code after the display\n* has been disposed, exit from Java.\n*/\n",
			"methodName":"int messageProc(int hwnd, int msg, int wParam, int lParam)"
		},
		"static synchronized void register(Display display)":{
			"methodBody":"{\n    for (int i = 0; i < Displays.length; i++) {\n        if (Displays[i] == null) {\n            Displays[i] = display;\n            return;\n        }\n    }\n    Display[] newDisplays = new Display[Displays.length + 4];\n    System.arraycopy(Displays, 0, newDisplays, 0, Displays.length);\n    newDisplays[Displays.length] = display;\n    Displays = newDisplays;\n}",
			"comments":"",
			"methodName":"static synchronized void register(Display display)"
		},
		"void updateFont()":{
			"methodBody":"{\n    if (OS.IsWinCE)\n        return;\n    Font oldFont = getSystemFont();\n    int systemFont = 0;\n    NONCLIENTMETRICS info = OS.IsUnicode ? (NONCLIENTMETRICS) new NONCLIENTMETRICSW() : new NONCLIENTMETRICSA();\n    info.cbSize = NONCLIENTMETRICS.sizeof;\n    if (OS.SystemParametersInfo(OS.SPI_GETNONCLIENTMETRICS, 0, info, 0)) {\n        systemFont = OS.CreateFontIndirect(OS.IsUnicode ? (LOGFONT) ((NONCLIENTMETRICSW) info).lfMessageFont : ((NONCLIENTMETRICSA) info).lfMessageFont);\n    }\n    if (systemFont == 0)\n        systemFont = OS.GetStockObject(OS.DEFAULT_GUI_FONT);\n    if (systemFont == 0)\n        systemFont = OS.GetStockObject(OS.SYSTEM_FONT);\n    if (systemFont == 0)\n        return;\n    int length = systemFonts == null ? 0 : systemFonts.length;\n    int[] newFonts = new int[length + 1];\n    if (systemFonts != null) {\n        System.arraycopy(systemFonts, 0, newFonts, 0, length);\n    }\n    newFonts[length] = systemFont;\n    systemFonts = newFonts;\n    Font newFont = getSystemFont();\n    Shell[] shells = getShells();\n    for (int i = 0; i < shells.length; i++) {\n        Shell shell = shells[i];\n        if (!shell.isDisposed()) {\n            shell.updateFont(oldFont, newFont);\n        }\n    }\n}",
			"comments":"",
			"methodName":"void updateFont()"
		},
		"public void setCursorLocation(int x, int y)":{
			"methodBody":"{\n    checkDevice();\n    OS.SetCursorPos(x, y);\n}",
			"comments":"/**\n* Sets the location of the on-screen pointer relative to the top left corner\n* of the screen.  <b>Note: It is typically considered bad practice for a\n* program to move the on-screen pointer location.</b>\n*\n* @param x the new x coordinate for the cursor\n* @param y the new y coordinate for the cursor\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @since 2.1\n*/\n",
			"methodName":"public void setCursorLocation(int x, int y)"
		},
		"public void asyncExec(Runnable runnable)":{
			"methodBody":"{\n    if (isDisposed())\n        error(SWT.ERROR_DEVICE_DISPOSED);\n    synchronizer.asyncExec(runnable);\n}",
			"comments":"/**\n* Causes the <code>run()</code> method of the runnable to\n* be invoked by the user-interface thread at the next\n* reasonable opportunity. The caller of this method continues\n* to run in parallel, and is not notified when the\n* runnable has completed.  Specifying <code>null</code> as the\n* runnable simply wakes the user-interface thread when run.\n* <p>\n* Note that at the time the runnable is invoked, widgets\n* that have the receiver as their display may have been\n* disposed. Therefore, it is necessary to check for this\n* case inside the runnable before accessing the widget.\n* </p>\n*\n* @param runnable code to run on the user-interface thread or <code>null</code>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #syncExec\n*/\n",
			"methodName":"public void asyncExec(Runnable runnable)"
		},
		"public Thread getSyncThread()":{
			"methodBody":"{\n    if (isDisposed())\n        error(SWT.ERROR_DEVICE_DISPOSED);\n    return synchronizer.syncThread;\n}",
			"comments":"/**\n* Returns the thread that has invoked <code>syncExec</code>\n* or null if no such runnable is currently being invoked by\n* the user-interface thread.\n* <p>\n* Note: If a runnable invoked by asyncExec is currently\n* running, this method will return null.\n* </p>\n*\n* @return the receiver's sync-interface thread\n*\n* @exception SWTException <ul>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*/\n",
			"methodName":"public Thread getSyncThread()"
		},
		"Control findControl(int handle)":{
			"methodBody":"{\n    if (handle == 0)\n        return null;\n    do {\n        Control control = getControl(handle);\n        if (control != null)\n            return control;\n    } while ((handle = OS.GetParent(handle)) != 0);\n    return null;\n}",
			"comments":"",
			"methodName":"Control findControl(int handle)"
		},
		"public int internal_new_GC(GCData data)":{
			"methodBody":"{\n    if (isDisposed())\n        SWT.error(SWT.ERROR_DEVICE_DISPOSED);\n    int hDC = OS.GetDC(0);\n    if (hDC == 0)\n        SWT.error(SWT.ERROR_NO_HANDLES);\n    if (data != null) {\n        int mask = SWT.LEFT_TO_RIGHT | SWT.RIGHT_TO_LEFT;\n        if ((data.style & mask) != 0) {\n            data.layout = (data.style & SWT.RIGHT_TO_LEFT) != 0 ? OS.LAYOUT_RTL : 0;\n        } else {\n            data.style |= SWT.LEFT_TO_RIGHT;\n        }\n        data.device = this;\n        data.hFont = systemFont();\n    }\n    return hDC;\n}",
			"comments":"/**\n* Invokes platform specific functionality to allocate a new GC handle.\n* <p>\n* <b>IMPORTANT:</b> This method is <em>not</em> part of the public\n* API for <code>Display</code>. It is marked public only so that it\n* can be shared within the packages provided by SWT. It is not\n* available on all platforms, and should never be called from\n* application code.\n* </p>\n*\n* @param data the platform specific GC data\n* @return the platform specific GC handle\n*\n* @exception SWTException <ul>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n* @exception SWTError <ul>\n*    <li>ERROR_NO_HANDLES if a handle could not be obtained for gc creation</li>\n* </ul>\n*/\n",
			"methodName":"public int internal_new_GC(GCData data)"
		},
		"boolean isXMouseActive()":{
			"methodBody":"{\n    \n    boolean xMouseActive = false;\n    \n    TCHAR key = new TCHAR(0, \"Control Panel\\\\Desktop\", true);\n    int[] phKey = new int[1];\n    int result = OS.RegOpenKeyEx(OS.HKEY_CURRENT_USER, key, 0, OS.KEY_READ, phKey);\n    if (result == 0) {\n        \n        TCHAR lpValueName = new TCHAR(0, \"UserPreferencesMask\", true);\n        int[] lpcbData = new int[] { 4 }, lpData = new int[1];\n        result = OS.RegQueryValueEx(phKey[0], lpValueName, 0, null, lpData, lpcbData);\n        if (result == 0)\n            xMouseActive = (lpData[0] & 0x01) != 0;\n        OS.RegCloseKey(phKey[0]);\n    }\n    return xMouseActive;\n}",
			"comments":"/*\n* NOTE: X-Mouse is active when bit 1 of the UserPreferencesMask is set.\n*/\n//$NON-NLS-1$\n//$NON-NLS-1$\n",
			"methodName":"boolean isXMouseActive()"
		},
		"void createDisplay(DeviceData data)":{
			"methodBody":"{\n}",
			"comments":"",
			"methodName":"void createDisplay(DeviceData data)"
		},
		"public static synchronized Display getDefault()":{
			"methodBody":"{\n    if (Default == null)\n        Default = new Display();\n    return Default;\n}",
			"comments":"/**\n* Returns the default display. One is created (making the\n* thread that invokes this method its user-interface thread)\n* if it did not already exist.\n*\n* @return the default display\n*/\n",
			"methodName":"public static synchronized Display getDefault()"
		},
		"boolean isValidThread()":{
			"methodBody":"{\n    return thread == Thread.currentThread();\n}",
			"comments":"",
			"methodName":"boolean isValidThread()"
		},
		"static char mbcsToWcs(int ch)":{
			"methodBody":"{\n    return mbcsToWcs(ch, 0);\n}",
			"comments":"/*\n* Returns a single character, converted from the default\n* multi-byte character set (MBCS) used by the operating\n* system widgets to a wide character set (WCS) used by Java.\n*\n* @param ch the MBCS character\n* @return the WCS character\n*/\n",
			"methodName":"static char mbcsToWcs(int ch)"
		},
		"void releaseToolHotImageList(ImageList list)":{
			"methodBody":"{\n    int i = 0;\n    int length = toolHotImageList.length;\n    while (i < length) {\n        if (toolHotImageList[i] == list) {\n            if (list.removeRef() > 0)\n                return;\n            list.dispose();\n            System.arraycopy(toolHotImageList, i + 1, toolHotImageList, i, --length - i);\n            toolHotImageList[length] = null;\n            for (int j = 0; j < length; j++) {\n                if (toolHotImageList[j] != null)\n                    return;\n            }\n            toolHotImageList = null;\n            return;\n        }\n        i++;\n    }\n}",
			"comments":"",
			"methodName":"void releaseToolHotImageList(ImageList list)"
		},
		"public static synchronized Display getCurrent()":{
			"methodBody":"{\n    return findDisplay(Thread.currentThread());\n}",
			"comments":"/**\n* Returns the display which the currently running thread is\n* the user-interface thread for, or null if the currently\n* running thread is not a user-interface thread for any display.\n*\n* @return the current display\n*/\n",
			"methodName":"public static synchronized Display getCurrent()"
		},
		"public Monitor getPrimaryMonitor()":{
			"methodBody":"{\n    checkDevice();\n    if (OS.IsWinCE || OS.WIN32_VERSION < OS.VERSION(4, 10)) {\n        Monitor monitor = new Monitor();\n        int width = OS.GetSystemMetrics(OS.SM_CXSCREEN);\n        int height = OS.GetSystemMetrics(OS.SM_CYSCREEN);\n        monitor.width = width;\n        monitor.height = height;\n        RECT rect = new RECT();\n        OS.SystemParametersInfo(OS.SPI_GETWORKAREA, 0, rect, 0);\n        monitor.clientX = rect.left;\n        monitor.clientY = rect.top;\n        monitor.clientWidth = rect.right - rect.left;\n        monitor.clientHeight = rect.bottom - rect.top;\n        return monitor;\n    }\n    monitors = new Monitor[4];\n    \n    Callback callback = new Callback(this, \"monitorEnumProc\", 4);\n    int lpfnEnum = callback.getAddress();\n    if (lpfnEnum == 0)\n        SWT.error(SWT.ERROR_NO_MORE_CALLBACKS);\n    OS.EnumDisplayMonitors(0, null, lpfnEnum, 0);\n    callback.dispose();\n    Monitor result = null;\n    MONITORINFO lpmi = new MONITORINFO();\n    lpmi.cbSize = MONITORINFO.sizeof;\n    for (int i = 0; i < monitorCount; i++) {\n        Monitor monitor = monitors[i];\n        OS.GetMonitorInfo(monitors[i].handle, lpmi);\n        if ((lpmi.dwFlags & OS.MONITORINFOF_PRIMARY) != 0) {\n            result = monitor;\n            break;\n        }\n    }\n    monitors = null;\n    monitorCount = 0;\n    return result;\n}",
			"comments":"/**\n* Returns the primary monitor for that device.\n*\n* @return the primary monitor\n*\n* @since 3.0\n*/\n//$NON-NLS-1$\n",
			"methodName":"public Monitor getPrimaryMonitor()"
		},
		"public static synchronized Display findDisplay(Thread thread)":{
			"methodBody":"{\n    for (int i = 0; i < Displays.length; i++) {\n        Display display = Displays[i];\n        if (display != null && display.thread == thread) {\n            return display;\n        }\n    }\n    return null;\n}",
			"comments":"/**\n* Returns the display which the given thread is the\n* user-interface thread for, or null if the given thread\n* is not a user-interface thread for any display.  Specifying\n* <code>null</code> as the thread will return <code>null</code>\n* for the display.\n*\n* @param thread the user-interface thread\n* @return the display for the given thread\n*/\n",
			"methodName":"public static synchronized Display findDisplay(Thread thread)"
		},
		"int monitorEnumProc(int hmonitor, int hdc, int lprcMonitor, int dwData)":{
			"methodBody":"{\n    if (monitorCount >= monitors.length) {\n        Monitor[] newMonitors = new Monitor[monitors.length + 4];\n        System.arraycopy(monitors, 0, newMonitors, 0, monitors.length);\n        monitors = newMonitors;\n    }\n    MONITORINFO lpmi = new MONITORINFO();\n    lpmi.cbSize = MONITORINFO.sizeof;\n    OS.GetMonitorInfo(hmonitor, lpmi);\n    Monitor monitor = new Monitor();\n    monitor.handle = hmonitor;\n    monitor.x = lpmi.rcMonitor_left;\n    monitor.y = lpmi.rcMonitor_top;\n    monitor.width = lpmi.rcMonitor_right - lpmi.rcMonitor_left;\n    monitor.height = lpmi.rcMonitor_bottom - lpmi.rcMonitor_top;\n    monitor.clientX = lpmi.rcWork_left;\n    monitor.clientY = lpmi.rcWork_top;\n    monitor.clientWidth = lpmi.rcWork_right - lpmi.rcWork_left;\n    monitor.clientHeight = lpmi.rcWork_bottom - lpmi.rcWork_top;\n    monitors[monitorCount++] = monitor;\n    return 1;\n}",
			"comments":"",
			"methodName":"int monitorEnumProc(int hmonitor, int hdc, int lprcMonitor, int dwData)"
		},
		"boolean runTimer(int id)":{
			"methodBody":"{\n    if (timerList != null && timerIds != null) {\n        int index = 0;\n        while (index < timerIds.length) {\n            if (timerIds[index] == id) {\n                OS.KillTimer(hwndMessage, timerIds[index]);\n                timerIds[index] = 0;\n                Runnable runnable = timerList[index];\n                timerList[index] = null;\n                if (runnable != null)\n                    runnable.run();\n                return true;\n            }\n            index++;\n        }\n    }\n    return false;\n}",
			"comments":"",
			"methodName":"boolean runTimer(int id)"
		},
		"void releaseToolDisabledImageList(ImageList list)":{
			"methodBody":"{\n    int i = 0;\n    int length = toolDisabledImageList.length;\n    while (i < length) {\n        if (toolDisabledImageList[i] == list) {\n            if (list.removeRef() > 0)\n                return;\n            list.dispose();\n            System.arraycopy(toolDisabledImageList, i + 1, toolDisabledImageList, i, --length - i);\n            toolDisabledImageList[length] = null;\n            for (int j = 0; j < length; j++) {\n                if (toolDisabledImageList[j] != null)\n                    return;\n            }\n            toolDisabledImageList = null;\n            return;\n        }\n        i++;\n    }\n}",
			"comments":"",
			"methodName":"void releaseToolDisabledImageList(ImageList list)"
		},
		"int asciiKey(int key)":{
			"methodBody":"{\n    if (OS.IsWinCE)\n        return 0;\n    \n    for (int i = 0; i < keyboard.length; i++) keyboard[i] = 0;\n    if (!OS.GetKeyboardState(keyboard))\n        return 0;\n    \n    if (OS.IsUnicode) {\n        char[] result = new char[1];\n        if (OS.ToUnicode(key, key, keyboard, result, 1, 0) == 1)\n            return result[0];\n    } else {\n        short[] result = new short[1];\n        if (OS.ToAscii(key, key, keyboard, result, 0) == 1)\n            return result[0];\n    }\n    return 0;\n}",
			"comments":"/* Get the current keyboard. */\n/* Translate the key to ASCII or UNICODE using the virtual keyboard */\n",
			"methodName":"int asciiKey(int key)"
		},
		"public Object getData(String key)":{
			"methodBody":"{\n    checkDevice();\n    if (key == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (keys == null)\n        return null;\n    for (int i = 0; i < keys.length; i++) {\n        if (keys[i].equals(key))\n            return values[i];\n    }\n    return null;\n}",
			"comments":"/**\n* Returns the application defined property of the receiver\n* with the specified name, or null if it has not been set.\n* <p>\n* Applications may have associated arbitrary objects with the\n* receiver in this fashion. If the objects stored in the\n* properties need to be notified when the display is disposed\n* of, it is the application's responsibility to provide a\n* <code>disposeExec()</code> handler which does so.\n* </p>\n*\n* @param key the name of the property\n* @return the value of the property or null if it has not been set\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the key is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #setData(String, Object)\n* @see #disposeExec(Runnable)\n*/\n",
			"methodName":"public Object getData(String key)"
		},
		"public Image getSystemImage(int id)":{
			"methodBody":"{\n    checkDevice();\n    int hIcon = 0;\n    switch(id) {\n        case SWT.ICON_ERROR:\n            if (errorIcon == 0) {\n                errorIcon = OS.LoadImage(0, OS.OIC_HAND, OS.IMAGE_ICON, 0, 0, OS.LR_SHARED);\n            }\n            hIcon = errorIcon;\n            break;\n        case SWT.ICON_WORKING:\n        case SWT.ICON_INFORMATION:\n            if (infoIcon == 0) {\n                infoIcon = OS.LoadImage(0, OS.OIC_INFORMATION, OS.IMAGE_ICON, 0, 0, OS.LR_SHARED);\n            }\n            hIcon = infoIcon;\n            break;\n        case SWT.ICON_QUESTION:\n            if (questionIcon == 0) {\n                questionIcon = OS.LoadImage(0, OS.OIC_QUES, OS.IMAGE_ICON, 0, 0, OS.LR_SHARED);\n            }\n            hIcon = questionIcon;\n            break;\n        case SWT.ICON_WARNING:\n            if (warningIcon == 0) {\n                warningIcon = OS.LoadImage(0, OS.OIC_BANG, OS.IMAGE_ICON, 0, 0, OS.LR_SHARED);\n            }\n            hIcon = warningIcon;\n            break;\n    }\n    if (hIcon == 0)\n        return null;\n    return Image.win32_new(this, SWT.ICON, hIcon);\n}",
			"comments":"/**\n* Returns the matching standard platform image for the given\n* constant, which should be one of the icon constants\n* specified in class <code>SWT</code>. This image should\n* not be free'd because it was allocated by the system,\n* not the application.  A value of <code>null</code> will\n* be returned either if the supplied constant is not an\n* swt icon constant or if the platform does not define an\n* image that corresponds to the constant.\n*\n* @param id the swt icon constant\n* @return the corresponding image or <code>null</code>\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see SWT#ICON_ERROR\n* @see SWT#ICON_INFORMATION\n* @see SWT#ICON_QUESTION\n* @see SWT#ICON_WARNING\n* @see SWT#ICON_WORKING\n*\n* @since 3.0\n*/\n",
			"methodName":"public Image getSystemImage(int id)"
		},
		"public void setSynchronizer(Synchronizer synchronizer)":{
			"methodBody":"{\n    checkDevice();\n    if (synchronizer == null)\n        error(SWT.ERROR_NULL_ARGUMENT);\n    if (this.synchronizer != null) {\n        this.synchronizer.runAsyncMessages(true);\n    }\n    this.synchronizer = synchronizer;\n}",
			"comments":"/**\n* Sets the synchronizer used by the display to be\n* the argument, which can not be null.\n*\n* @param synchronizer the new synchronizer for the display (must not be null)\n*\n* @exception IllegalArgumentException <ul>\n*    <li>ERROR_NULL_ARGUMENT - if the synchronizer is null</li>\n* </ul>\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n*    <li>ERROR_FAILED_EXEC - if an exception occurred while running an inter-thread message</li>\n* </ul>\n*/\n",
			"methodName":"public void setSynchronizer(Synchronizer synchronizer)"
		},
		"void error(int code)":{
			"methodBody":"{\n    SWT.error(code);\n}",
			"comments":"/**\n* Does whatever display specific cleanup is required, and then\n* uses the code in <code>SWTError.error</code> to handle the error.\n*\n* @param code the descriptive error code\n*\n* @see SWT#error(int)\n*/\n",
			"methodName":"void error(int code)"
		},
		"public int getIconDepth()":{
			"methodBody":"{\n    checkDevice();\n    if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION(5, 1)) {\n        if (getDepth() >= 24)\n            return 32;\n    }\n    \n    \n    TCHAR buffer1 = new TCHAR(0, \"Control Panel\\\\Desktop\\\\WindowMetrics\", true);\n    int[] phkResult = new int[1];\n    int result = OS.RegOpenKeyEx(OS.HKEY_CURRENT_USER, buffer1, 0, OS.KEY_READ, phkResult);\n    if (result != 0)\n        return 4;\n    int depth = 4;\n    int[] lpcbData = { 128 };\n    \n    TCHAR lpData = new TCHAR(0, lpcbData[0]);\n    \n    TCHAR buffer2 = new TCHAR(0, \"Shell Icon BPP\", true);\n    result = OS.RegQueryValueEx(phkResult[0], buffer2, 0, null, lpData, lpcbData);\n    if (result == 0) {\n        try {\n            depth = Integer.parseInt(lpData.toString(0, lpData.strlen()));\n        } catch (NumberFormatException e) {\n        }\n    }\n    OS.RegCloseKey(phkResult[0]);\n    return depth;\n}",
			"comments":"/**\n* Returns the maximum allowed depth of icons on this display, in bits per pixel.\n* On some platforms, this may be different than the actual depth of the display.\n*\n* @return the maximum icon depth\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see Device#getDepth\n*/\n/* Use the character encoding for the default locale */\n//$NON-NLS-1$\n/* Use the character encoding for the default locale */\n//$NON-NLS-1$\n",
			"methodName":"public int getIconDepth()"
		},
		"static void setDevice(Device device)":{
			"methodBody":"{\n    CurrentDevice = device;\n}",
			"comments":"/*\n* TEMPORARY CODE.\n*/\n",
			"methodName":"static void setDevice(Device device)"
		},
		"static int translateKey(int key)":{
			"methodBody":"{\n    for (int i = 0; i < KeyTable.length; i++) {\n        if (KeyTable[i][0] == key)\n            return KeyTable[i][1];\n    }\n    return 0;\n}",
			"comments":"",
			"methodName":"static int translateKey(int key)"
		},
		"public Object getData()":{
			"methodBody":"{\n    checkDevice();\n    return data;\n}",
			"comments":"/**\n* Returns the application defined, display specific data\n* associated with the receiver, or null if it has not been\n* set. The <em>display specific data</em> is a single,\n* unnamed field that is stored with every display.\n* <p>\n* Applications may put arbitrary objects in this field. If\n* the object stored in the display specific data needs to\n* be notified when the display is disposed of, it is the\n* application's responsibility to provide a\n* <code>disposeExec()</code> handler which does so.\n* </p>\n*\n* @return the display specific data\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see #setData(Object)\n* @see #disposeExec(Runnable)\n*/\n",
			"methodName":"public Object getData()"
		},
		"void destroyDisplay()":{
			"methodBody":"{\n}",
			"comments":"",
			"methodName":"void destroyDisplay()"
		},
		"public void update()":{
			"methodBody":"{\n    checkDevice();\n    \n    if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION(4, 10)) {\n        if (OS.IsHungAppWindow(hwndMessage)) {\n            MSG msg = new MSG();\n            int flags = OS.PM_REMOVE | OS.PM_NOYIELD;\n            OS.PeekMessage(msg, hwndMessage, SWT_NULL, SWT_NULL, flags);\n        }\n    }\n    Shell[] shells = getShells();\n    for (int i = 0; i < shells.length; i++) {\n        Shell shell = shells[i];\n        if (!shell.isDisposed())\n            shell.update(true);\n    }\n}",
			"comments":"/**\n* Forces all outstanding paint requests for the display\n* to be processed before this method returns.\n*\n* @exception SWTException <ul>\n*    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\n*    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>\n* </ul>\n*\n* @see Control#update()\n*/\n/*\n* Feature in Windows.  When an application does not remove\n* events from the event queue for some time, Windows assumes\n* the application is not responding and no longer sends paint\n* events to the application.  The fix is to detect that the\n* application is not responding and call PeekMessage() with\n* PM_REMOVE to tell Windows that the application is ready\n* to dispatch events.  Note that the message does not have\n* to be found or dispatched in order to wake Windows up.\n*\n* NOTE: This allows other cross thread messages to be delivered,\n* most notably WM_ACTIVATE.\n*/\n",
			"methodName":"public void update()"
		}
	},
	"ClassORInterfaceName":[
		"Display"
	]
}
