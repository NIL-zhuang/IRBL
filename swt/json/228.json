{
	"variables":[
		"isLastBlock",
		"compressionType",
		"uncompressedBytesRemaining",
		"stream",
		"huffmanTables",
		"window",
		"windowIndex",
		"copyIndex",
		"copyBytesRemaining",
		"UNCOMPRESSED",
		"COMPRESSED_FIXED",
		"COMPRESSED_DYNAMIC",
		"END_OF_COMPRESSED_BLOCK",
		"FIRST_LENGTH_CODE",
		"LAST_LENGTH_CODE",
		"FIRST_DISTANCE_CODE",
		"LAST_DISTANCE_CODE",
		"FIRST_CODE_LENGTH_CODE",
		"LAST_CODE_LENGTH_CODE",
		"lengthBases",
		"extraLengthBits",
		"distanceBases",
		"extraDistanceBits",
		"b1",
		"b2",
		"b3",
		"b4",
		"value",
		"value",
		"value",
		"extraBits",
		"length",
		"distance",
		"stream",
		"isLastBlock",
		"window",
		"windowSize",
		"isLastBlock",
		"stream",
		"compressionType",
		"stream",
		"compressionType",
		"stream",
		"compressionType",
		"UNCOMPRESSED",
		"stream",
		"stream",
		"stream",
		"stream",
		"b1",
		"b3",
		"b2",
		"b4",
		"stream",
		"uncompressedBytesRemaining",
		"b1",
		"b2",
		"compressionType",
		"COMPRESSED_DYNAMIC",
		"huffmanTables",
		"PngHuffmanTables",
		"stream",
		"huffmanTables",
		"PngHuffmanTables",
		"compressionType",
		"UNCOMPRESSED",
		"uncompressedBytesRemaining",
		"uncompressedBytesRemaining",
		"stream",
		"value",
		"END_OF_COMPRESSED_BLOCK",
		"isLastBlock",
		"stream",
		"value",
		"compressionType",
		"UNCOMPRESSED",
		"uncompressedBytesRemaining",
		"stream",
		"copyBytesRemaining",
		"huffmanTables",
		"stream",
		"END_OF_COMPRESSED_BLOCK",
		"stream",
		"isLastBlock",
		"copyBytesRemaining",
		"window",
		"copyIndex",
		"window",
		"windowIndex",
		"value",
		"copyBytesRemaining",
		"copyIndex",
		"windowIndex",
		"copyIndex",
		"window",
		"copyIndex",
		"windowIndex",
		"window",
		"windowIndex",
		"value",
		"huffmanTables",
		"stream",
		"value",
		"END_OF_COMPRESSED_BLOCK",
		"window",
		"windowIndex",
		"value",
		"windowIndex",
		"windowIndex",
		"window",
		"windowIndex",
		"value",
		"value",
		"END_OF_COMPRESSED_BLOCK",
		"value",
		"LAST_LENGTH_CODE",
		"extraLengthBits",
		"value",
		"FIRST_LENGTH_CODE",
		"lengthBases",
		"value",
		"FIRST_LENGTH_CODE",
		"extraBits",
		"length",
		"stream",
		"extraBits",
		"value",
		"huffmanTables",
		"stream",
		"value",
		"LAST_DISTANCE_CODE",
		"stream",
		"extraBits",
		"extraDistanceBits",
		"value",
		"distanceBases",
		"value",
		"extraBits",
		"distance",
		"stream",
		"extraBits",
		"copyIndex",
		"windowIndex",
		"distance",
		"copyIndex",
		"copyIndex",
		"window",
		"copyBytesRemaining",
		"length",
		"stream",
		"stream",
		"length",
		"length",
		"length",
		"length",
		"stream",
		"windowSize"
	],
	"extendORImplementFiles":[],
	"package":[
		"org.eclipse.swt.internal.image"
	],
	"import":[],
	"methods":[
		"setWindowSize",
		"readNextBlockHeader",
		"getNextByte",
		"assertBlockAtEnd",
		"assertCompressedDataAtEnd",
		"getNextCompressedByte",
		"getNextIdatBit",
		"getNextIdatBits",
		"error",
		"getNextIdatByte",
		"getNextIdatByte",
		"getNextIdatByte",
		"getNextIdatByte",
		"error",
		"getDynamicTables",
		"getFixedTables",
		"readNextBlockHeader",
		"getNextByte",
		"getNextIdatByte",
		"getNextCompressedByte",
		"error",
		"readNextBlockHeader",
		"getNextByte",
		"error",
		"getNextLiteralValue",
		"error",
		"assertBlockAtEnd",
		"readNextBlockHeader",
		"assertBlockAtEnd",
		"getNextLiteralValue",
		"readNextBlockHeader",
		"getNextByte",
		"getNextIdatBits",
		"getNextDistanceValue",
		"error",
		"getNextIdatBits",
		"getNextCompressedByte",
		"error"
	],
	"methodsBody":{
		"void readNextBlockHeader()":{
			"methodBody":"{\n    isLastBlock = stream.getNextIdatBit() != 0;\n    compressionType = (byte) (stream.getNextIdatBits(2) & 0xFF);\n    if (compressionType > 2)\n        stream.error();\n    if (compressionType == UNCOMPRESSED) {\n        byte b1 = stream.getNextIdatByte();\n        byte b2 = stream.getNextIdatByte();\n        byte b3 = stream.getNextIdatByte();\n        byte b4 = stream.getNextIdatByte();\n        if (b1 != ~b3 || b2 != ~b4)\n            stream.error();\n        uncompressedBytesRemaining = (b1 & 0xFF) | ((b2 & 0xFF) << 8);\n    } else if (compressionType == COMPRESSED_DYNAMIC) {\n        huffmanTables = PngHuffmanTables.getDynamicTables(stream);\n    } else {\n        huffmanTables = PngHuffmanTables.getFixedTables();\n    }\n}",
			"comments":"",
			"methodName":"void readNextBlockHeader()"
		},
		"private void assertBlockAtEnd()":{
			"methodBody":"{\n    if (compressionType == UNCOMPRESSED) {\n        if (uncompressedBytesRemaining > 0)\n            stream.error();\n    } else if (copyBytesRemaining > 0 || (huffmanTables.getNextLiteralValue(stream) != END_OF_COMPRESSED_BLOCK)) {\n        stream.error();\n    }\n}",
			"comments":"",
			"methodName":"private void assertBlockAtEnd()"
		},
		"void setWindowSize(int windowSize)":{
			"methodBody":"{\n    window = new byte[windowSize];\n}",
			"comments":"",
			"methodName":"void setWindowSize(int windowSize)"
		},
		"byte getNextByte()":{
			"methodBody":"{\n    if (compressionType == UNCOMPRESSED) {\n        if (uncompressedBytesRemaining == 0) {\n            readNextBlockHeader();\n            return getNextByte();\n        }\n        uncompressedBytesRemaining--;\n        return stream.getNextIdatByte();\n    } else {\n        byte value = getNextCompressedByte();\n        if (value == END_OF_COMPRESSED_BLOCK) {\n            if (isLastBlock)\n                stream.error();\n            readNextBlockHeader();\n            return getNextByte();\n        } else {\n            return value;\n        }\n    }\n}",
			"comments":"",
			"methodName":"byte getNextByte()"
		},
		"void assertCompressedDataAtEnd()":{
			"methodBody":"{\n    assertBlockAtEnd();\n    while (!isLastBlock) {\n        readNextBlockHeader();\n        assertBlockAtEnd();\n    }\n}",
			"comments":"",
			"methodName":"void assertCompressedDataAtEnd()"
		},
		"private byte getNextCompressedByte()":{
			"methodBody":"{\n    if (copyBytesRemaining > 0) {\n        byte value = window[copyIndex];\n        window[windowIndex] = value;\n        copyBytesRemaining--;\n        copyIndex++;\n        windowIndex++;\n        if (copyIndex == window.length)\n            copyIndex = 0;\n        if (windowIndex == window.length)\n            windowIndex = 0;\n        return value;\n    }\n    int value = huffmanTables.getNextLiteralValue(stream);\n    if (value < END_OF_COMPRESSED_BLOCK) {\n        window[windowIndex] = (byte) (value & 0xFF);\n        windowIndex++;\n        if (windowIndex >= window.length)\n            windowIndex = 0;\n        return (byte) (value & 0xFF);\n    } else if (value == END_OF_COMPRESSED_BLOCK) {\n        readNextBlockHeader();\n        return getNextByte();\n    } else if (value <= LAST_LENGTH_CODE) {\n        int extraBits = extraLengthBits[value - FIRST_LENGTH_CODE];\n        int length = lengthBases[value - FIRST_LENGTH_CODE];\n        if (extraBits > 0) {\n            length += stream.getNextIdatBits(extraBits);\n        }\n        value = huffmanTables.getNextDistanceValue(stream);\n        if (value > LAST_DISTANCE_CODE)\n            stream.error();\n        extraBits = extraDistanceBits[value];\n        int distance = distanceBases[value];\n        if (extraBits > 0) {\n            distance += stream.getNextIdatBits(extraBits);\n        }\n        copyIndex = windowIndex - distance;\n        if (copyIndex < 0)\n            copyIndex += window.length;\n        copyBytesRemaining = length;\n        return getNextCompressedByte();\n    } else {\n        stream.error();\n        return 0;\n    }\n}",
			"comments":"",
			"methodName":"private byte getNextCompressedByte()"
		}
	},
	"ClassORInterfaceName":[
		"PngLzBlockReader"
	]
}
