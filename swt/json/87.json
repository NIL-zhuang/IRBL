{
	"variables":[
		"LINE_OFFSET",
		"LINE_LENGTH",
		"renderer",
		"logicalContent",
		"visualLines",
		"visualLineCount",
		"size",
		"newLines",
		"line",
		"lastLine",
		"lastChar",
		"high",
		"low",
		"index",
		"lineStart",
		"lineEnd",
		"lineCount",
		"offset",
		"visualFirstLineOffset",
		"logicalFirstLine",
		"logicalFirstLineOffset",
		"visualFirstLine",
		"lastLine",
		"lastLineEnd",
		"logicalEndLine",
		"endLine",
		"i",
		"logicalStartLine",
		"visualStartLine",
		"visualReplaceLastLine",
		"textChangeDelta",
		"i",
		"emptyLineCount",
		"width",
		"i",
		"copyLineCount",
		"i",
		"line",
		"lineOffset",
		"lineLength",
		"layout",
		"offsets",
		"j",
		"width",
		"lineCount",
		"renderer",
		"logicalContent",
		"logicalContent",
		"listener",
		"visualLines",
		"size",
		"numLines",
		"Math",
		"size",
		"numLines",
		"System",
		"visualLines",
		"newLines",
		"size",
		"visualLines",
		"newLines",
		"size",
		"visualLines",
		"size",
		"logicalContent",
		"visualLineCount",
		"line",
		"logicalContent",
		"lineIndex",
		"lineIndex",
		"visualLineCount",
		"lineIndex",
		"SWT",
		"SWT",
		"line",
		"logicalContent",
		"visualLines",
		"lineIndex",
		"LINE_OFFSET",
		"visualLines",
		"lineIndex",
		"LINE_LENGTH",
		"line",
		"visualLineCount",
		"visualLineCount",
		"logicalContent",
		"offset",
		"lastChar",
		"visualLines",
		"lastLine",
		"LINE_OFFSET",
		"visualLines",
		"lastLine",
		"LINE_LENGTH",
		"offset",
		"offset",
		"offset",
		"lastChar",
		"SWT",
		"SWT",
		"offset",
		"lastChar",
		"lastLine",
		"visualLineCount",
		"visualLineCount",
		"high",
		"low",
		"index",
		"high",
		"low",
		"visualLines",
		"index",
		"LINE_OFFSET",
		"offset",
		"lineStart",
		"lineStart",
		"visualLines",
		"index",
		"LINE_LENGTH",
		"low",
		"index",
		"offset",
		"lineEnd",
		"high",
		"index",
		"low",
		"offset",
		"visualLines",
		"low",
		"LINE_OFFSET",
		"visualLines",
		"low",
		"LINE_LENGTH",
		"low",
		"low",
		"visualLineCount",
		"visualLineCount",
		"lineCount",
		"logicalContent",
		"lineCount",
		"logicalContent",
		"visualLineCount",
		"offset",
		"logicalContent",
		"lineIndex",
		"lineIndex",
		"visualLineCount",
		"lineIndex",
		"SWT",
		"SWT",
		"offset",
		"visualLines",
		"lineIndex",
		"LINE_OFFSET",
		"offset",
		"logicalContent",
		"start",
		"length",
		"visualLineCount",
		"logicalContent",
		"listener",
		"lineCount",
		"visualLineCount",
		"startLine",
		"lineCount",
		"lineCount",
		"startLine",
		"startLine",
		"logicalContent",
		"visualFirstLineOffset",
		"logicalContent",
		"logicalFirstLine",
		"logicalFirstLineOffset",
		"lineCount",
		"startLine",
		"visualFirstLine",
		"startLine",
		"visualFirstLine",
		"startLine",
		"lineCount",
		"visualLines",
		"lastLine",
		"LINE_OFFSET",
		"visualLines",
		"lastLine",
		"LINE_LENGTH",
		"lastLine",
		"visualLineCount",
		"lastLineEnd",
		"visualLines",
		"lastLine",
		"LINE_OFFSET",
		"lastLine",
		"lastLineEnd",
		"visualLines",
		"lastLine",
		"LINE_OFFSET",
		"visualLines",
		"lastLine",
		"LINE_LENGTH",
		"wrap",
		"lastLine",
		"visualLineCount",
		"logicalEndLine",
		"logicalContent",
		"logicalEndLine",
		"logicalContent",
		"visualLines",
		"lastLine",
		"LINE_OFFSET",
		"lineCount",
		"lastLine",
		"startLine",
		"startLine",
		"lineCount",
		"visualLineCount",
		"lineCount",
		"wrap",
		"logicalFirstLine",
		"logicalEndLine",
		"startLine",
		"startLine",
		"startLine",
		"lineCount",
		"startLine",
		"i",
		"endLine",
		"i",
		"visualLines",
		"i",
		"logicalContent",
		"start",
		"replaceLength",
		"text",
		"logicalContent",
		"text",
		"visualLineCount",
		"visualLines",
		"visualLineIndex",
		"LINE_OFFSET",
		"System",
		"visualLines",
		"visualLineIndex",
		"visualLines",
		"visualLineIndex",
		"visualLineCount",
		"visualLineIndex",
		"visualLines",
		"visualLineIndex",
		"visualLines",
		"visualLineIndex",
		"LINE_OFFSET",
		"visualLineOffset",
		"visualLines",
		"visualLineIndex",
		"LINE_LENGTH",
		"visualLineLength",
		"visualLineCount",
		"visualLineCount",
		"logicalContent",
		"startOffset",
		"startOffset",
		"visualLineCount",
		"newCharCount",
		"replaceCharCount",
		"replaceLineCount",
		"visualReplaceLastLine",
		"startOffset",
		"replaceCharCount",
		"visualReplaceLastLine",
		"visualLines",
		"visualReplaceLastLine",
		"LINE_OFFSET",
		"visualLines",
		"visualReplaceLastLine",
		"LINE_OFFSET",
		"visualLines",
		"visualReplaceLastLine",
		"LINE_LENGTH",
		"visualReplaceLastLine",
		"visualLineCount",
		"visualReplaceLastLine",
		"visualStartLine",
		"visualStartLine",
		"visualReplaceLastLine",
		"visualStartLine",
		"visualStartLine",
		"visualStartLine",
		"visualReplaceLastLine",
		"logicalStartLine",
		"logicalStartLine",
		"newLineCount",
		"visualStartLine",
		"visualReplaceLastLine",
		"i",
		"visualLineCount",
		"i",
		"visualLines",
		"i",
		"LINE_OFFSET",
		"textChangeDelta",
		"renderer",
		"renderer",
		"renderer",
		"visualLineIndex",
		"startLine",
		"endLine",
		"visualLineIndex",
		"width",
		"visualLineIndex",
		"i",
		"visualLines",
		"i",
		"emptyLineCount",
		"visualLines",
		"i",
		"LINE_OFFSET",
		"emptyLineCount",
		"visualLineCount",
		"visualLineIndex",
		"System",
		"visualLines",
		"visualLineIndex",
		"emptyLineCount",
		"visualLines",
		"visualLineIndex",
		"copyLineCount",
		"visualLineIndex",
		"copyLineCount",
		"emptyLineCount",
		"visualLineIndex",
		"visualLineCount",
		"width",
		"visualLineIndex",
		"startLine",
		"i",
		"endLine",
		"i",
		"logicalContent",
		"i",
		"logicalContent",
		"i",
		"line",
		"lineLength",
		"visualLineIndex",
		"lineOffset",
		"visualLineIndex",
		"renderer",
		"line",
		"lineOffset",
		"layout",
		"Math",
		"width",
		"layout",
		"j",
		"offsets",
		"j",
		"visualLineIndex",
		"lineOffset",
		"offsets",
		"j",
		"offsets",
		"j",
		"offsets",
		"j",
		"renderer",
		"layout",
		"visualLineIndex",
		"renderer",
		"renderer",
		"renderer",
		"width",
		"logicalContent",
		"visualLineCount",
		"visualLines",
		"lineCount",
		"visualLines",
		"lineCount",
		"width",
		"renderer",
		"logicalContent",
		"length",
		"length",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"ERROR_INVALID_ARGUMENT",
		"width",
		"length",
		"length",
		"width",
		"length",
		"renderer",
		"logicalContent",
		"listener",
		"numLines",
		"lineIndex",
		"offset",
		"lineIndex",
		"start",
		"length",
		"listener",
		"startLine",
		"lineCount",
		"startLine",
		"lineCount",
		"wrap",
		"startLine",
		"lineCount",
		"start",
		"replaceLength",
		"text",
		"text",
		"visualLineIndex",
		"visualLineOffset",
		"visualLineLength",
		"startOffset",
		"newLineCount",
		"replaceLineCount",
		"newCharCount",
		"replaceCharCount",
		"startLine",
		"endLine",
		"visualLineIndex",
		"startLine",
		"endLine",
		"visualLineIndex",
		"width",
		"width"
	],
	"extendORImplementFiles":[
		"StyledTextContent"
	],
	"package":[
		"org.eclipse.swt.custom"
	],
	"import":[
		"org.eclipse.swt",
		"org.eclipse.swt.graphics"
	],
	"methods":[
		"addTextChangeListener",
		"ensureSize",
		"getCharCount",
		"getLine",
		"getLineAtOffset",
		"getLineCount",
		"getLineDelimiter",
		"getOffsetAtLine",
		"getTextRange",
		"getVisualLineCount",
		"removeTextChangeListener",
		"reset",
		"reset",
		"resetVisualLines",
		"replaceTextRange",
		"setText",
		"setVisualLine",
		"textChanged",
		"wrapLineRange",
		"wrapLineRange",
		"wrapLines",
		"wrapLines",
		"addTextChangeListener",
		"max",
		"arraycopy",
		"resetVisualLines",
		"getCharCount",
		"getLine",
		"error",
		"getTextRange",
		"getLineAtOffset",
		"error",
		"getLineCount",
		"getLineDelimiter",
		"getOffsetAtLine",
		"error",
		"getTextRange",
		"removeTextChangeListener",
		"reset",
		"getOffsetAtLine",
		"getLineAtOffset",
		"getOffsetAtLine",
		"getLineAtOffset",
		"getLineCount",
		"getLineAtOffset",
		"resetVisualLines",
		"wrapLineRange",
		"replaceTextRange",
		"setText",
		"ensureSize",
		"arraycopy",
		"getLineAtOffset",
		"getLineAtOffset",
		"getLineAtOffset",
		"reset",
		"reset",
		"wrapLineRange",
		"getClientArea",
		"getLeftMargin",
		"getRightMargin",
		"wrapLineRange",
		"arraycopy",
		"resetVisualLines",
		"getLine",
		"getOffsetAtLine",
		"length",
		"setVisualLine",
		"getTextLayout",
		"setWidth",
		"max",
		"getLineOffsets",
		"setVisualLine",
		"disposeTextLayout",
		"getClientArea",
		"getLeftMargin",
		"getRightMargin",
		"wrapLines",
		"getLineCount",
		"resetVisualLines",
		"wrapLineRange"
	],
	"methodsBody":{
		"int getVisualLineCount()":{
			"methodBody":"{\n    return visualLineCount;\n}",
			"comments":"/**\n* Returns the number of visual (wrapped) lines.\n*\n* @return the number of visual (wrapped) lines\n*/\n",
			"methodName":"int getVisualLineCount()"
		},
		"private int reset(int startLine, int lineCount, boolean wrap)":{
			"methodBody":"{\n    if (lineCount <= 0) {\n        return startLine;\n    }\n    \n    \n    \n    int visualFirstLineOffset = getOffsetAtLine(startLine);\n    int logicalFirstLine = logicalContent.getLineAtOffset(visualFirstLineOffset);\n    int logicalFirstLineOffset = logicalContent.getOffsetAtLine(logicalFirstLine);\n    int visualFirstLine = getLineAtOffset(logicalFirstLineOffset);\n    lineCount += startLine - visualFirstLine;\n    startLine = visualFirstLine;\n    \n    \n    int lastLine = startLine + lineCount - 1;\n    int lastLineEnd = visualLines[lastLine][LINE_OFFSET] + visualLines[lastLine][LINE_LENGTH];\n    int logicalEndLine = 0;\n    while (lastLine < visualLineCount - 1 && lastLineEnd == visualLines[lastLine + 1][LINE_OFFSET]) {\n        lastLine++;\n        lastLineEnd = visualLines[lastLine][LINE_OFFSET] + visualLines[lastLine][LINE_LENGTH];\n    }\n    if (wrap) {\n        if (lastLine == visualLineCount - 1) {\n            logicalEndLine = logicalContent.getLineCount();\n        } else {\n            logicalEndLine = logicalContent.getLineAtOffset(visualLines[lastLine + 1][LINE_OFFSET]);\n        }\n    }\n    lineCount = lastLine - startLine + 1;\n    resetVisualLines(startLine, lineCount);\n    visualLineCount -= lineCount;\n    if (wrap) {\n        \n        \n        \n        wrapLineRange(logicalFirstLine, logicalEndLine, startLine);\n    }\n    return startLine;\n}",
			"comments":"/**\n* Reset the visual (wrapped) lines in the specified range.\n* If the range specifies partial logical lines (e.g., startLine is\n* the second of two visual lines) it is extended to reset all visual\n* lines of a logical line.\n* <p>\n*\n* @param startLine index of the first visual line\n* @param lineCount number of visual lines\n* @param wrap true=rewrap the logical lines in the reset visual range\n* \tfalse=don't rewrap lines. Visual lines will be left in an inconsistent\n* \tstate since there will be a range of unwrapped and unknown lines.\n* @return the first visual line that was reset\n*/\n// make sure that all visual lines of the first logical line are\n// being reset. visualFirstLine is the first visual line of the\n// first logical line that has at least one visual line reset.\n// make sure that all visual lines of the last logical line are\n// being reset.\n// always recalculate line wrap immediately after a reset\n// because the content always needs to be in a usable state.\n// i.e., there must not be any reset but unwrapped lines\n",
			"methodName":"private int reset(int startLine, int lineCount, boolean wrap)"
		},
		"void reset(int startLine, int lineCount)":{
			"methodBody":"{\n    if (lineCount <= 0 || visualLineCount == 0) {\n        return;\n    }\n    reset(startLine, lineCount, true);\n}",
			"comments":"/**\n* Reset the visual (wrapped) lines in the specified range.\n* If the range specifies partial logical lines (e.g., startLine is\n* the second of two visual lines) it is extended to reset all visual\n* lines of a logical line.\n* Following the reset the logical lines in the reset visual range are\n* rewrapped.\n* <p>\n*\n* @param startLine index of the first visual line\n* @param lineCount number of visual lines\n*/\n",
			"methodName":"void reset(int startLine, int lineCount)"
		},
		"public void addTextChangeListener(TextChangeListener listener)":{
			"methodBody":"{\n    logicalContent.addTextChangeListener(listener);\n}",
			"comments":"/**\n* @see StyledTextContent#addTextChangeListener(TextChangeListener)\n*/\n",
			"methodName":"public void addTextChangeListener(TextChangeListener listener)"
		},
		"public String getTextRange(int start, int length)":{
			"methodBody":"{\n    return logicalContent.getTextRange(start, length);\n}",
			"comments":"/**\n* @see StyledTextContent#getTextRange(int, int)\n*/\n",
			"methodName":"public String getTextRange(int start, int length)"
		},
		"void textChanged(int startOffset, int newLineCount, int replaceLineCount, int newCharCount, int replaceCharCount)":{
			"methodBody":"{\n    \n    if (visualLineCount == 0) {\n        return;\n    }\n    int logicalStartLine = logicalContent.getLineAtOffset(startOffset);\n    int visualStartLine = getLineAtOffset(startOffset);\n    int visualReplaceLastLine = visualLineCount - 1;\n    int textChangeDelta = newCharCount - replaceCharCount;\n    if (replaceLineCount > 0) {\n        visualReplaceLastLine = getLineAtOffset(startOffset + replaceCharCount);\n        \n        if ((visualReplaceLastLine == 0 || visualLines[visualReplaceLastLine][LINE_OFFSET] == visualLines[visualReplaceLastLine - 1][LINE_OFFSET] + visualLines[visualReplaceLastLine - 1][LINE_LENGTH]) && visualReplaceLastLine != visualLineCount - 1) {\n            visualReplaceLastLine++;\n        }\n        visualStartLine = reset(visualStartLine, visualReplaceLastLine - visualStartLine + 1, false);\n    } else {\n        visualStartLine = reset(visualStartLine, 1, false);\n    }\n    visualReplaceLastLine = wrapLineRange(logicalStartLine, logicalStartLine + 1 + newLineCount, visualStartLine);\n    for (int i = visualReplaceLastLine; i < visualLineCount; i++) {\n        visualLines[i][LINE_OFFSET] += textChangeDelta;\n    }\n}",
			"comments":"/**\n* Recalculates the line wrap for the lines affected by the\n* text change.\n* <p>\n*\n* @param startOffset\tthe start offset of the text change\n* @param newLineCount the number of inserted lines\n* @param replaceLineCount the number of deleted lines\n* @param newCharCount the number of new characters\n* @param replaceCharCount the number of deleted characters\n*/\n// do nothing if there are no wrapped lines\n// at the start of a visual line/end of the previous visual line?\n",
			"methodName":"void textChanged(int startOffset, int newLineCount, int replaceLineCount, int newCharCount, int replaceCharCount)"
		},
		"public String getLine(int lineIndex)":{
			"methodBody":"{\n    String line;\n    \n    if (visualLineCount == 0) {\n        line = logicalContent.getLine(lineIndex);\n    } else {\n        if (lineIndex >= visualLineCount || lineIndex < 0) {\n            SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n        }\n        line = logicalContent.getTextRange(visualLines[lineIndex][LINE_OFFSET], visualLines[lineIndex][LINE_LENGTH]);\n    }\n    return line;\n}",
			"comments":"/**\n* @return the visual (wrapped) line at the specified index\n* @see StyledTextContent#getLine(int)\n*/\n// redirect call to logical content if there are no wrapped lines\n",
			"methodName":"public String getLine(int lineIndex)"
		},
		"public int getOffsetAtLine(int lineIndex)":{
			"methodBody":"{\n    int offset;\n    \n    if (visualLineCount == 0) {\n        offset = logicalContent.getOffsetAtLine(lineIndex);\n    } else {\n        if (lineIndex >= visualLineCount || lineIndex < 0) {\n            SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n        }\n        offset = visualLines[lineIndex][LINE_OFFSET];\n    }\n    return offset;\n}",
			"comments":"/**\n* @return the start offset of the visual (wrapped) line at the given\n* \tindex\n* @see StyledTextContent#getOffsetAtLine(int)\n*/\n// redirect call to logical content if there are no wrapped lines\n",
			"methodName":"public int getOffsetAtLine(int lineIndex)"
		},
		"private void setVisualLine(int visualLineIndex, int visualLineOffset, int visualLineLength)":{
			"methodBody":"{\n    ensureSize(visualLineCount + 1);\n    \n    if (visualLines[visualLineIndex][LINE_OFFSET] != -1) {\n        System.arraycopy(visualLines, visualLineIndex, visualLines, visualLineIndex + 1, visualLineCount - visualLineIndex);\n        visualLines[visualLineIndex] = new int[2];\n    }\n    visualLines[visualLineIndex][LINE_OFFSET] = visualLineOffset;\n    visualLines[visualLineIndex][LINE_LENGTH] = visualLineLength;\n    visualLineCount++;\n}",
			"comments":"/**\n* Set the line wrap data for the specified visual (wrapped) line.\n* <p>\n*\n* @param visualLineIndex index of the visual line\n* @param visualLineOffset start offset of the visual line, relative\n* \tto the start of the document\n* @param visualLineLength length of the visual line\n*/\n// is the space for the visual line already taken? can happen if\n// there are more visual lines for a given logical line than before\n",
			"methodName":"private void setVisualLine(int visualLineIndex, int visualLineOffset, int visualLineLength)"
		},
		"public String getLineDelimiter()":{
			"methodBody":"{\n    return logicalContent.getLineDelimiter();\n}",
			"comments":"/**\n* @see StyledTextContent#getLineDelimiter()\n*/\n",
			"methodName":"public String getLineDelimiter()"
		},
		"private void resetVisualLines(int startLine, int lineCount)":{
			"methodBody":"{\n    int endLine = startLine + lineCount;\n    for (int i = startLine; i < endLine; i++) {\n        visualLines[i] = new int[] { -1, -1 };\n    }\n}",
			"comments":"/**\n* Reset the visual (wrapped) lines in the specified range.\n* <p>\n*\n* @param startLine index of the first visual line\n* @param lineCount number of visual lines\n*/\n",
			"methodName":"private void resetVisualLines(int startLine, int lineCount)"
		},
		"private void ensureSize(int numLines)":{
			"methodBody":"{\n    int size = visualLines.length;\n    if (size >= numLines) {\n        return;\n    }\n    int[][] newLines = new int[Math.max(size * 2, numLines)][2];\n    System.arraycopy(visualLines, 0, newLines, 0, size);\n    visualLines = newLines;\n    resetVisualLines(size, visualLines.length - size);\n}",
			"comments":"/**\n* Grow the lines array to at least the specified size.\n* <p>\n*\n* @param numLines number of elements that the array should have\n* \tat a minimum\n*/\n",
			"methodName":"private void ensureSize(int numLines)"
		},
		"public int getCharCount()":{
			"methodBody":"{\n    return logicalContent.getCharCount();\n}",
			"comments":"/**\n* @see StyledTextContent#getCharCount()\n*/\n",
			"methodName":"public int getCharCount()"
		},
		"public void replaceTextRange(int start, int replaceLength, String text)":{
			"methodBody":"{\n    logicalContent.replaceTextRange(start, replaceLength, text);\n}",
			"comments":"/**\n* @see StyledTextContent#replaceTextRange(int, int, String)\n*/\n",
			"methodName":"public void replaceTextRange(int start, int replaceLength, String text)"
		},
		"public int getLineCount()":{
			"methodBody":"{\n    int lineCount = visualLineCount;\n    \n    if (visualLineCount == 0) {\n        lineCount = logicalContent.getLineCount();\n    }\n    return lineCount;\n}",
			"comments":"/**\n* @return the number of visual (wrapped) lines\n* @see StyledTextContent#getLineCount()\n*/\n// redirect call to logical content if there are no wrapped lines\n",
			"methodName":"public int getLineCount()"
		},
		"public void setText(String text)":{
			"methodBody":"{\n    logicalContent.setText(text);\n}",
			"comments":"/**\n* @see StyledTextContent#setText(String)\n*/\n",
			"methodName":"public void setText(String text)"
		},
		"void wrapLines()":{
			"methodBody":"{\n    int width = renderer.getClientArea().width - renderer.getLeftMargin() - renderer.getRightMargin();\n    wrapLines(width);\n}",
			"comments":"/**\n* Wrap all logical lines at the current client area width of the\n* StyledText widget\n*/\n",
			"methodName":"void wrapLines()"
		},
		"public int getLineAtOffset(int offset)":{
			"methodBody":"{\n    int lastLine = visualLineCount - 1;\n    int lastChar;\n    \n    if (visualLineCount == 0) {\n        return logicalContent.getLineAtOffset(offset);\n    }\n    \n    \n    \n    \n    \n    lastChar = visualLines[lastLine][LINE_OFFSET] + visualLines[lastLine][LINE_LENGTH];\n    if (offset < 0 || (offset > 0 && offset > lastChar)) {\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\n    }\n    \n    if (offset == lastChar) {\n        return lastLine;\n    }\n    int high = visualLineCount;\n    int low = -1;\n    int index = visualLineCount;\n    while (high - low > 1) {\n        index = (high + low) / 2;\n        int lineStart = visualLines[index][LINE_OFFSET];\n        if (offset >= lineStart) {\n            int lineEnd = lineStart + visualLines[index][LINE_LENGTH];\n            low = index;\n            if (offset <= lineEnd) {\n                break;\n            }\n        } else {\n            high = index;\n        }\n    }\n    if (low > 0 && offset == visualLines[low - 1][LINE_OFFSET] + visualLines[low - 1][LINE_LENGTH]) {\n        \n        \n        low--;\n    }\n    return low;\n}",
			"comments":"/**\n* Returns the visual (wrapped) line at given offset.\n* <p>\n* The offset is ambiguous if it identifies the end of a visual line and\n* there is another visual line below. In this case the end of the visual\n* line has the same offset as the beginning of the next visual line\n* since the visual line break is not represented by any character in the\n* logical line.\n* In this ambiguous case the offset is assumed to represent the end of a\n* visual line and the index of the first visual line is returned.\n* </p>\n*\n* @param offset offset of the desired line.\n* @return the index of the visual (wrapped) line at the specified offset\n* @see StyledTextContent#getLineAtOffset(int)\n*/\n// redirect call to logical content if there are no wrapped lines\n// can't use getCharCount to get the number of characters since this\n// method is called in textChanged, when the logicalContent used by\n// getCharCount has already changed. at that point the visual lines\n// have not been updated yet and we thus need to use the old character\n// count which is only available in the visual content.\n// if last line and the line is not empty you can ask for\n// a position that doesn't exist (the one to the right of the\n// last character) - for inserting\n// end of a visual line/beginning of next visual line is ambiguous\n// (they have the same offset). always return the first visual line\n",
			"methodName":"public int getLineAtOffset(int offset)"
		},
		"void wrapLines(int width)":{
			"methodBody":"{\n    int lineCount = logicalContent.getLineCount();\n    visualLineCount = 0;\n    visualLines = new int[lineCount][2];\n    resetVisualLines(0, visualLines.length);\n    wrapLineRange(0, lineCount, 0, width);\n}",
			"comments":"/**\n* Wrap all logical lines at the given width.\n* <p>\n*\n* @param width width to wrap lines at\n*/\n",
			"methodName":"void wrapLines(int width)"
		},
		"private int wrapLineRange(int startLine, int endLine, int visualLineIndex)":{
			"methodBody":"{\n    int emptyLineCount = 0;\n    int width = renderer.getClientArea().width - renderer.getLeftMargin() - renderer.getRightMargin();\n    visualLineIndex = wrapLineRange(startLine, endLine, visualLineIndex, width);\n    \n    for (int i = visualLineIndex; i < visualLines.length; i++, emptyLineCount++) {\n        if (visualLines[i][LINE_OFFSET] != -1) {\n            break;\n        }\n    }\n    if (emptyLineCount > 0) {\n        int copyLineCount = visualLineCount - visualLineIndex;\n        System.arraycopy(visualLines, visualLineIndex + emptyLineCount, visualLines, visualLineIndex, copyLineCount);\n        resetVisualLines(visualLineIndex + copyLineCount, emptyLineCount);\n    }\n    return visualLineIndex;\n}",
			"comments":"/**\n* Wrap the logical lines in the given range at the current client\n* area width of the StyledText widget\n* <p>\n*\n* @param startLine first logical line to wrap\n* @param endLine line after last logical line\n* @param visualLineIndex visual (wrapped) line index that startLine\n* \tcorresponds to.\n* @return index of the line following the last wrapped line\n*/\n// is there space left for more visual lines? can happen if there are fewer\n// visual lines for a given logical line than before\n",
			"methodName":"private int wrapLineRange(int startLine, int endLine, int visualLineIndex)"
		},
		"private int wrapLineRange(int startLine, int endLine, int visualLineIndex, int width)":{
			"methodBody":"{\n    \n    if (visualLineCount == 0 && width == 0) {\n        return visualLineIndex;\n    }\n    for (int i = startLine; i < endLine; i++) {\n        String line = logicalContent.getLine(i);\n        int lineOffset = logicalContent.getOffsetAtLine(i);\n        int lineLength = line.length();\n        if (lineLength == 0) {\n            setVisualLine(visualLineIndex, lineOffset, 0);\n            visualLineIndex++;\n            continue;\n        }\n        TextLayout layout = renderer.getTextLayout(line, lineOffset);\n        layout.setWidth(Math.max(1, width));\n        int[] offsets = layout.getLineOffsets();\n        for (int j = 0; j < offsets.length - 1; j++) {\n            setVisualLine(visualLineIndex++, lineOffset + offsets[j], offsets[j + 1] - offsets[j]);\n        }\n        renderer.disposeTextLayout(layout);\n    }\n    return visualLineIndex;\n}",
			"comments":"/**\n* Wrap the lines in the given range. Skip lines that have already\n* been wrapped.\n* <p>\n*\n* @param startLine first logical line to wrap\n* @param endLine line after last logical line\n* @param visualLineIndex visual (wrapped) line index that startLine\n* \tcorresponds to.\n* @param width line width to wrap at\n* @return index of last wrapped line\n*/\n// if there are no wrapped lines and the width is 0 the widget has\n// not been made visible/sized yet. don't wrap until the widget size\n// is known.\n",
			"methodName":"private int wrapLineRange(int startLine, int endLine, int visualLineIndex, int width)"
		},
		"public void removeTextChangeListener(TextChangeListener listener)":{
			"methodBody":"{\n    logicalContent.removeTextChangeListener(listener);\n}",
			"comments":"/**\n* @see StyledTextContent#removeTextChangeListener(TextChangeListener)\n*/\n",
			"methodName":"public void removeTextChangeListener(TextChangeListener listener)"
		}
	},
	"ClassORInterfaceName":[
		"WrappedContent"
	]
}
